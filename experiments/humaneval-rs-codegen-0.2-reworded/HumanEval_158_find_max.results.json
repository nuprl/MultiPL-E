{
  "name": "HumanEval_158_find_max",
  "language": "rs",
  "prompt": "/// Write a function that accepts a vector of strings.\n/// The vector contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n",
  "tests": "}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]), String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]), String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]), String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n}\n",
  "stop_tokens": [
    "\n}"
  ],
  "results": [
    {
      "program": "/// Write a function that accepts a vector of strings.\n/// The vector contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n  let max_count = 0\n  let max_word = \"\"\n  for w in words {\n    let count = w.count(c => c.is_upper())\n    if count > max_count {\n      max_count = count\n      max_word = w\n    }\n  }\n  return max_word\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]), String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]), String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]), String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n}\n",
      "timestamp": 1664292578,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmp_1aykjz4.rs:12:20\n   |\n12 |   let max_count = 0\n   |                    ^ help: add `;` here\n13 |   let max_word = \"\"\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmp_1aykjz4.rs:13:20\n   |\n13 |   let max_word = \"\"\n   |                    ^ help: add `;` here\n14 |   for w in words {\n   |   --- unexpected token\n\nerror: expected one of `!`, `)`, `,`, `.`, `::`, `?`, `{`, or an operator, found `=>`\n  --> /tmp/tmp_1aykjz4.rs:15:27\n   |\n15 |     let count = w.count(c => c.is_upper())\n   |                           ^^ expected one of 8 possible tokens\n\nerror: aborting due to 3 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function that accepts a vector of strings.\n/// The vector contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n  let max_count = 0\n  let max_word = \"\"\n  for w in words {\n    let count = count_unique_chars(w)\n    if count > max_count {\n      max_count = count\n      max_word = w\n    }\n  }\n  return max_word\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]), String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]), String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]), String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n}\n",
      "timestamp": 1664292578,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmp095up2vv.rs:12:20\n   |\n12 |   let max_count = 0\n   |                    ^ help: add `;` here\n13 |   let max_word = \"\"\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmp095up2vv.rs:13:20\n   |\n13 |   let max_word = \"\"\n   |                    ^ help: add `;` here\n14 |   for w in words {\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `if`\n  --> /tmp/tmp095up2vv.rs:15:38\n   |\n15 |     let count = count_unique_chars(w)\n   |                                      ^ help: add `;` here\n16 |     if count > max_count {\n   |     -- unexpected token\n\nerror: expected `;`, found `max_word`\n  --> /tmp/tmp095up2vv.rs:17:24\n   |\n17 |       max_count = count\n   |                        ^ help: add `;` here\n18 |       max_word = w\n   |       -------- unexpected token\n\nerror[E0425]: cannot find function `count_unique_chars` in this scope\n  --> /tmp/tmp095up2vv.rs:15:17\n   |\n15 |     let count = count_unique_chars(w)\n   |                 ^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp095up2vv.rs:18:18\n   |\n13 |   let max_word = \"\"\n   |                  -- expected due to this value\n...\n18 |       max_word = w\n   |                  ^\n   |                  |\n   |                  expected `&str`, found struct `String`\n   |                  help: consider borrowing here: `&w`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp095up2vv.rs:21:10\n   |\n11 | fn find_max(words: Vec<String>) -> String {\n   |                                    ------ expected `String` because of return type\n...\n21 |   return max_word\n   |          ^^^^^^^^- help: try using a conversion method: `.to_string()`\n   |          |\n   |          expected struct `String`, found `&str`\n\nerror: aborting due to 7 previous errors\n\nSome errors have detailed explanations: E0308, E0425.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function that accepts a vector of strings.\n/// The vector contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n  let max_count = 0\n  let max_word = \"\"\n  for w in words {\n    let count = count_unique_chars(w)\n    if count > max_count {\n      max_count = count\n      max_word = w\n    }\n  }\n  return max_word\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]), String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]), String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]), String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n}\n",
      "timestamp": 1664292578,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmp095up2vv.rs:12:20\n   |\n12 |   let max_count = 0\n   |                    ^ help: add `;` here\n13 |   let max_word = \"\"\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmp095up2vv.rs:13:20\n   |\n13 |   let max_word = \"\"\n   |                    ^ help: add `;` here\n14 |   for w in words {\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `if`\n  --> /tmp/tmp095up2vv.rs:15:38\n   |\n15 |     let count = count_unique_chars(w)\n   |                                      ^ help: add `;` here\n16 |     if count > max_count {\n   |     -- unexpected token\n\nerror: expected `;`, found `max_word`\n  --> /tmp/tmp095up2vv.rs:17:24\n   |\n17 |       max_count = count\n   |                        ^ help: add `;` here\n18 |       max_word = w\n   |       -------- unexpected token\n\nerror[E0425]: cannot find function `count_unique_chars` in this scope\n  --> /tmp/tmp095up2vv.rs:15:17\n   |\n15 |     let count = count_unique_chars(w)\n   |                 ^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp095up2vv.rs:18:18\n   |\n13 |   let max_word = \"\"\n   |                  -- expected due to this value\n...\n18 |       max_word = w\n   |                  ^\n   |                  |\n   |                  expected `&str`, found struct `String`\n   |                  help: consider borrowing here: `&w`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp095up2vv.rs:21:10\n   |\n11 | fn find_max(words: Vec<String>) -> String {\n   |                                    ------ expected `String` because of return type\n...\n21 |   return max_word\n   |          ^^^^^^^^- help: try using a conversion method: `.to_string()`\n   |          |\n   |          expected struct `String`, found `&str`\n\nerror: aborting due to 7 previous errors\n\nSome errors have detailed explanations: E0308, E0425.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function that accepts a vector of strings.\n/// The vector contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n  let max_count = 0\n  let max_word = \"\"\n  for word in words {\n    let count = word.count(/[a-z]/)\n    if count > max_count {\n      max_count = count\n      max_word = word\n    }\n  }\n  return max_word\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]), String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]), String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]), String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n}\n",
      "timestamp": 1664292578,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmplz_du44f.rs:12:20\n   |\n12 |   let max_count = 0\n   |                    ^ help: add `;` here\n13 |   let max_word = \"\"\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmplz_du44f.rs:13:20\n   |\n13 |   let max_word = \"\"\n   |                    ^ help: add `;` here\n14 |   for word in words {\n   |   --- unexpected token\n\nerror: expected expression, found `/`\n  --> /tmp/tmplz_du44f.rs:15:28\n   |\n15 |     let count = word.count(/[a-z]/)\n   |                            ^ expected expression\n\nerror[E0308]: mismatched types\n  --> /tmp/tmplz_du44f.rs:21:10\n   |\n11 | fn find_max(words: Vec<String>) -> String {\n   |                                    ------ expected `String` because of return type\n...\n21 |   return max_word\n   |          ^^^^^^^^- help: try using a conversion method: `.to_string()`\n   |          |\n   |          expected struct `String`, found `&str`\n\nerror: aborting due to 4 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function that accepts a vector of strings.\n/// The vector contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n  let max_count = 0\n  let max_word = \"\"\n  for w in words {\n    let count = count_unique_chars(w)\n    if count > max_count {\n      max_count = count\n      max_word = w\n    }\n  }\n  return max_word\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]), String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]), String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]), String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n}\n",
      "timestamp": 1664292578,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmp095up2vv.rs:12:20\n   |\n12 |   let max_count = 0\n   |                    ^ help: add `;` here\n13 |   let max_word = \"\"\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmp095up2vv.rs:13:20\n   |\n13 |   let max_word = \"\"\n   |                    ^ help: add `;` here\n14 |   for w in words {\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `if`\n  --> /tmp/tmp095up2vv.rs:15:38\n   |\n15 |     let count = count_unique_chars(w)\n   |                                      ^ help: add `;` here\n16 |     if count > max_count {\n   |     -- unexpected token\n\nerror: expected `;`, found `max_word`\n  --> /tmp/tmp095up2vv.rs:17:24\n   |\n17 |       max_count = count\n   |                        ^ help: add `;` here\n18 |       max_word = w\n   |       -------- unexpected token\n\nerror[E0425]: cannot find function `count_unique_chars` in this scope\n  --> /tmp/tmp095up2vv.rs:15:17\n   |\n15 |     let count = count_unique_chars(w)\n   |                 ^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp095up2vv.rs:18:18\n   |\n13 |   let max_word = \"\"\n   |                  -- expected due to this value\n...\n18 |       max_word = w\n   |                  ^\n   |                  |\n   |                  expected `&str`, found struct `String`\n   |                  help: consider borrowing here: `&w`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp095up2vv.rs:21:10\n   |\n11 | fn find_max(words: Vec<String>) -> String {\n   |                                    ------ expected `String` because of return type\n...\n21 |   return max_word\n   |          ^^^^^^^^- help: try using a conversion method: `.to_string()`\n   |          |\n   |          expected struct `String`, found `&str`\n\nerror: aborting due to 7 previous errors\n\nSome errors have detailed explanations: E0308, E0425.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function that accepts a vector of strings.\n/// The vector contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n    let max_count = 0;\n    let max_word = String::from(\"\");\n    for w in words {\n        let count = w.count_unique();\n        if count > max_count {\n            max_count = count;\n            max_word = w;\n        }\n    }\n    return max_word;\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]), String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]), String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]), String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n}\n",
      "timestamp": 1664292578,
      "stdout": "",
      "stderr": "error[E0599]: no method named `count_unique` found for struct `String` in the current scope\n  --> /tmp/tmp2yxvzvns.rs:15:23\n   |\n15 |         let count = w.count_unique();\n   |                       ^^^^^^^^^^^^ method not found in `String`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function that accepts a vector of strings.\n/// The vector contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n  let max_count = 0\n  let max_word = \"\"\n  for w in words {\n    let count = 0\n    for i in w {\n      count += 1\n      if i == \"a\" || i == \"e\" || i == \"i\" || i == \"o\" || i == \"u\" {\n        count += 1\n      }\n    }\n    if count > max_count {\n      max_count = count\n      max_word = w\n    }\n  }\n  return max_word\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]), String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]), String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]), String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n}\n",
      "timestamp": 1664292578,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmpipl03zk2.rs:12:20\n   |\n12 |   let max_count = 0\n   |                    ^ help: add `;` here\n13 |   let max_word = \"\"\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpipl03zk2.rs:13:20\n   |\n13 |   let max_word = \"\"\n   |                    ^ help: add `;` here\n14 |   for w in words {\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpipl03zk2.rs:15:18\n   |\n15 |     let count = 0\n   |                  ^ help: add `;` here\n16 |     for i in w {\n   |     --- unexpected token\n\nerror: expected `;`, found keyword `if`\n  --> /tmp/tmpipl03zk2.rs:17:17\n   |\n17 |       count += 1\n   |                 ^ help: add `;` here\n18 |       if i == \"a\" || i == \"e\" || i == \"i\" || i == \"o\" || i == \"u\" {\n   |       -- unexpected token\n\nerror: expected `;`, found `max_word`\n  --> /tmp/tmpipl03zk2.rs:23:24\n   |\n23 |       max_count = count\n   |                        ^ help: add `;` here\n24 |       max_word = w\n   |       -------- unexpected token\n\nerror[E0277]: `String` is not an iterator\n  --> /tmp/tmpipl03zk2.rs:16:14\n   |\n16 |     for i in w {\n   |              ^ `String` is not an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait `Iterator` is not implemented for `String`\n   = note: required because of the requirements on the impl of `IntoIterator` for `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpipl03zk2.rs:24:18\n   |\n13 |   let max_word = \"\"\n   |                  -- expected due to this value\n...\n24 |       max_word = w\n   |                  ^\n   |                  |\n   |                  expected `&str`, found struct `String`\n   |                  help: consider borrowing here: `&w`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpipl03zk2.rs:27:10\n   |\n11 | fn find_max(words: Vec<String>) -> String {\n   |                                    ------ expected `String` because of return type\n...\n27 |   return max_word\n   |          ^^^^^^^^- help: try using a conversion method: `.to_",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function that accepts a vector of strings.\n/// The vector contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n  let max_count = 0\n  let max_word = \"\"\n  for word in words {\n    let count = count_unique_chars(word)\n    if count > max_count {\n      max_count = count\n      max_word = word\n    }\n  }\n  return max_word\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]), String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]), String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]), String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n}\n",
      "timestamp": 1664292578,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmpblowsbak.rs:12:20\n   |\n12 |   let max_count = 0\n   |                    ^ help: add `;` here\n13 |   let max_word = \"\"\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpblowsbak.rs:13:20\n   |\n13 |   let max_word = \"\"\n   |                    ^ help: add `;` here\n14 |   for word in words {\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `if`\n  --> /tmp/tmpblowsbak.rs:15:41\n   |\n15 |     let count = count_unique_chars(word)\n   |                                         ^ help: add `;` here\n16 |     if count > max_count {\n   |     -- unexpected token\n\nerror: expected `;`, found `max_word`\n  --> /tmp/tmpblowsbak.rs:17:24\n   |\n17 |       max_count = count\n   |                        ^ help: add `;` here\n18 |       max_word = word\n   |       -------- unexpected token\n\nerror[E0425]: cannot find function `count_unique_chars` in this scope\n  --> /tmp/tmpblowsbak.rs:15:17\n   |\n15 |     let count = count_unique_chars(word)\n   |                 ^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpblowsbak.rs:18:18\n   |\n13 |   let max_word = \"\"\n   |                  -- expected due to this value\n...\n18 |       max_word = word\n   |                  ^^^^\n   |                  |\n   |                  expected `&str`, found struct `String`\n   |                  help: consider borrowing here: `&word`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpblowsbak.rs:21:10\n   |\n11 | fn find_max(words: Vec<String>) -> String {\n   |                                    ------ expected `String` because of return type\n...\n21 |   return max_word\n   |          ^^^^^^^^- help: try using a conversion method: `.to_string()`\n   |          |\n   |          expected struct `String`, found `&str`\n\nerror: aborting due to 7 previous errors\n\nSome errors have detailed explanations: E0308, E0425.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function that accepts a vector of strings.\n/// The vector contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n  let max_count = 0\n  let max_word = \"\"\n  for w in words {\n    let count = count_unique_chars(w)\n    if count > max_count {\n      max_count = count\n      max_word = w\n    }\n  }\n  return max_word\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]), String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]), String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]), String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n}\n",
      "timestamp": 1664292578,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmp095up2vv.rs:12:20\n   |\n12 |   let max_count = 0\n   |                    ^ help: add `;` here\n13 |   let max_word = \"\"\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmp095up2vv.rs:13:20\n   |\n13 |   let max_word = \"\"\n   |                    ^ help: add `;` here\n14 |   for w in words {\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `if`\n  --> /tmp/tmp095up2vv.rs:15:38\n   |\n15 |     let count = count_unique_chars(w)\n   |                                      ^ help: add `;` here\n16 |     if count > max_count {\n   |     -- unexpected token\n\nerror: expected `;`, found `max_word`\n  --> /tmp/tmp095up2vv.rs:17:24\n   |\n17 |       max_count = count\n   |                        ^ help: add `;` here\n18 |       max_word = w\n   |       -------- unexpected token\n\nerror[E0425]: cannot find function `count_unique_chars` in this scope\n  --> /tmp/tmp095up2vv.rs:15:17\n   |\n15 |     let count = count_unique_chars(w)\n   |                 ^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp095up2vv.rs:18:18\n   |\n13 |   let max_word = \"\"\n   |                  -- expected due to this value\n...\n18 |       max_word = w\n   |                  ^\n   |                  |\n   |                  expected `&str`, found struct `String`\n   |                  help: consider borrowing here: `&w`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp095up2vv.rs:21:10\n   |\n11 | fn find_max(words: Vec<String>) -> String {\n   |                                    ------ expected `String` because of return type\n...\n21 |   return max_word\n   |          ^^^^^^^^- help: try using a conversion method: `.to_string()`\n   |          |\n   |          expected struct `String`, found `&str`\n\nerror: aborting due to 7 previous errors\n\nSome errors have detailed explanations: E0308, E0425.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function that accepts a vector of strings.\n/// The vector contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n  let max_count = 0\n  let max_word = \"\"\n  for w in words {\n    let count = w.count(/[a-z]/)\n    if count > max_count {\n      max_count = count\n      max_word = w\n    }\n  }\n  return max_word\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]), String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]), String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]), String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n}\n",
      "timestamp": 1664292578,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmpjn5c1gme.rs:12:20\n   |\n12 |   let max_count = 0\n   |                    ^ help: add `;` here\n13 |   let max_word = \"\"\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpjn5c1gme.rs:13:20\n   |\n13 |   let max_word = \"\"\n   |                    ^ help: add `;` here\n14 |   for w in words {\n   |   --- unexpected token\n\nerror: expected expression, found `/`\n  --> /tmp/tmpjn5c1gme.rs:15:25\n   |\n15 |     let count = w.count(/[a-z]/)\n   |                         ^ expected expression\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpjn5c1gme.rs:21:10\n   |\n11 | fn find_max(words: Vec<String>) -> String {\n   |                                    ------ expected `String` because of return type\n...\n21 |   return max_word\n   |          ^^^^^^^^- help: try using a conversion method: `.to_string()`\n   |          |\n   |          expected struct `String`, found `&str`\n\nerror: aborting due to 4 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function that accepts a vector of strings.\n/// The vector contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n  let max_count = 0\n  let max_word = \"\"\n  for w in words {\n    let count = count_unique_chars(w)\n    if count > max_count {\n      max_count = count\n      max_word = w\n    }\n  }\n  return max_word\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]), String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]), String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]), String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n}\n",
      "timestamp": 1664292578,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmp095up2vv.rs:12:20\n   |\n12 |   let max_count = 0\n   |                    ^ help: add `;` here\n13 |   let max_word = \"\"\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmp095up2vv.rs:13:20\n   |\n13 |   let max_word = \"\"\n   |                    ^ help: add `;` here\n14 |   for w in words {\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `if`\n  --> /tmp/tmp095up2vv.rs:15:38\n   |\n15 |     let count = count_unique_chars(w)\n   |                                      ^ help: add `;` here\n16 |     if count > max_count {\n   |     -- unexpected token\n\nerror: expected `;`, found `max_word`\n  --> /tmp/tmp095up2vv.rs:17:24\n   |\n17 |       max_count = count\n   |                        ^ help: add `;` here\n18 |       max_word = w\n   |       -------- unexpected token\n\nerror[E0425]: cannot find function `count_unique_chars` in this scope\n  --> /tmp/tmp095up2vv.rs:15:17\n   |\n15 |     let count = count_unique_chars(w)\n   |                 ^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp095up2vv.rs:18:18\n   |\n13 |   let max_word = \"\"\n   |                  -- expected due to this value\n...\n18 |       max_word = w\n   |                  ^\n   |                  |\n   |                  expected `&str`, found struct `String`\n   |                  help: consider borrowing here: `&w`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp095up2vv.rs:21:10\n   |\n11 | fn find_max(words: Vec<String>) -> String {\n   |                                    ------ expected `String` because of return type\n...\n21 |   return max_word\n   |          ^^^^^^^^- help: try using a conversion method: `.to_string()`\n   |          |\n   |          expected struct `String`, found `&str`\n\nerror: aborting due to 7 previous errors\n\nSome errors have detailed explanations: E0308, E0425.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function that accepts a vector of strings.\n/// The vector contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n  let max_count = 0\n  let max_word = \"\"\n  for word in words {\n    let count = count_unique_chars(word)\n    if count > max_count {\n      max_count = count\n      max_word = word\n    }\n  }\n  return max_word\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]), String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]), String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]), String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n}\n",
      "timestamp": 1664292578,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmpblowsbak.rs:12:20\n   |\n12 |   let max_count = 0\n   |                    ^ help: add `;` here\n13 |   let max_word = \"\"\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpblowsbak.rs:13:20\n   |\n13 |   let max_word = \"\"\n   |                    ^ help: add `;` here\n14 |   for word in words {\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `if`\n  --> /tmp/tmpblowsbak.rs:15:41\n   |\n15 |     let count = count_unique_chars(word)\n   |                                         ^ help: add `;` here\n16 |     if count > max_count {\n   |     -- unexpected token\n\nerror: expected `;`, found `max_word`\n  --> /tmp/tmpblowsbak.rs:17:24\n   |\n17 |       max_count = count\n   |                        ^ help: add `;` here\n18 |       max_word = word\n   |       -------- unexpected token\n\nerror[E0425]: cannot find function `count_unique_chars` in this scope\n  --> /tmp/tmpblowsbak.rs:15:17\n   |\n15 |     let count = count_unique_chars(word)\n   |                 ^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpblowsbak.rs:18:18\n   |\n13 |   let max_word = \"\"\n   |                  -- expected due to this value\n...\n18 |       max_word = word\n   |                  ^^^^\n   |                  |\n   |                  expected `&str`, found struct `String`\n   |                  help: consider borrowing here: `&word`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpblowsbak.rs:21:10\n   |\n11 | fn find_max(words: Vec<String>) -> String {\n   |                                    ------ expected `String` because of return type\n...\n21 |   return max_word\n   |          ^^^^^^^^- help: try using a conversion method: `.to_string()`\n   |          |\n   |          expected struct `String`, found `&str`\n\nerror: aborting due to 7 previous errors\n\nSome errors have detailed explanations: E0308, E0425.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function that accepts a vector of strings.\n/// The vector contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n  let max_count = 0\n  let max_word = \"\"\n  for w in words {\n    let count = count_unique_chars(w)\n    if count > max_count {\n      max_count = count\n      max_word = w\n    }\n  }\n  return max_word\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]), String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]), String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]), String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n}\n",
      "timestamp": 1664292578,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmp095up2vv.rs:12:20\n   |\n12 |   let max_count = 0\n   |                    ^ help: add `;` here\n13 |   let max_word = \"\"\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmp095up2vv.rs:13:20\n   |\n13 |   let max_word = \"\"\n   |                    ^ help: add `;` here\n14 |   for w in words {\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `if`\n  --> /tmp/tmp095up2vv.rs:15:38\n   |\n15 |     let count = count_unique_chars(w)\n   |                                      ^ help: add `;` here\n16 |     if count > max_count {\n   |     -- unexpected token\n\nerror: expected `;`, found `max_word`\n  --> /tmp/tmp095up2vv.rs:17:24\n   |\n17 |       max_count = count\n   |                        ^ help: add `;` here\n18 |       max_word = w\n   |       -------- unexpected token\n\nerror[E0425]: cannot find function `count_unique_chars` in this scope\n  --> /tmp/tmp095up2vv.rs:15:17\n   |\n15 |     let count = count_unique_chars(w)\n   |                 ^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp095up2vv.rs:18:18\n   |\n13 |   let max_word = \"\"\n   |                  -- expected due to this value\n...\n18 |       max_word = w\n   |                  ^\n   |                  |\n   |                  expected `&str`, found struct `String`\n   |                  help: consider borrowing here: `&w`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp095up2vv.rs:21:10\n   |\n11 | fn find_max(words: Vec<String>) -> String {\n   |                                    ------ expected `String` because of return type\n...\n21 |   return max_word\n   |          ^^^^^^^^- help: try using a conversion method: `.to_string()`\n   |          |\n   |          expected struct `String`, found `&str`\n\nerror: aborting due to 7 previous errors\n\nSome errors have detailed explanations: E0308, E0425.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function that accepts a vector of strings.\n/// The vector contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n  let max_count = 0\n  let max_word = \"\"\n  for w in words {\n    let count = count_unique_chars(w)\n    if count > max_count {\n      max_count = count\n      max_word = w\n    }\n  }\n  return max_word\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]), String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]), String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]), String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n}\n",
      "timestamp": 1664292578,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmp095up2vv.rs:12:20\n   |\n12 |   let max_count = 0\n   |                    ^ help: add `;` here\n13 |   let max_word = \"\"\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmp095up2vv.rs:13:20\n   |\n13 |   let max_word = \"\"\n   |                    ^ help: add `;` here\n14 |   for w in words {\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `if`\n  --> /tmp/tmp095up2vv.rs:15:38\n   |\n15 |     let count = count_unique_chars(w)\n   |                                      ^ help: add `;` here\n16 |     if count > max_count {\n   |     -- unexpected token\n\nerror: expected `;`, found `max_word`\n  --> /tmp/tmp095up2vv.rs:17:24\n   |\n17 |       max_count = count\n   |                        ^ help: add `;` here\n18 |       max_word = w\n   |       -------- unexpected token\n\nerror[E0425]: cannot find function `count_unique_chars` in this scope\n  --> /tmp/tmp095up2vv.rs:15:17\n   |\n15 |     let count = count_unique_chars(w)\n   |                 ^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp095up2vv.rs:18:18\n   |\n13 |   let max_word = \"\"\n   |                  -- expected due to this value\n...\n18 |       max_word = w\n   |                  ^\n   |                  |\n   |                  expected `&str`, found struct `String`\n   |                  help: consider borrowing here: `&w`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp095up2vv.rs:21:10\n   |\n11 | fn find_max(words: Vec<String>) -> String {\n   |                                    ------ expected `String` because of return type\n...\n21 |   return max_word\n   |          ^^^^^^^^- help: try using a conversion method: `.to_string()`\n   |          |\n   |          expected struct `String`, found `&str`\n\nerror: aborting due to 7 previous errors\n\nSome errors have detailed explanations: E0308, E0425.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function that accepts a vector of strings.\n/// The vector contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n  let max_count = 0\n  let max_word = \"\"\n  for word in words {\n    let count = count_unique_chars(word)\n    if count > max_count {\n      max_count = count\n      max_word = word\n    }\n  }\n  return max_word\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]), String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]), String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]), String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n}\n",
      "timestamp": 1664292578,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmpblowsbak.rs:12:20\n   |\n12 |   let max_count = 0\n   |                    ^ help: add `;` here\n13 |   let max_word = \"\"\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpblowsbak.rs:13:20\n   |\n13 |   let max_word = \"\"\n   |                    ^ help: add `;` here\n14 |   for word in words {\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `if`\n  --> /tmp/tmpblowsbak.rs:15:41\n   |\n15 |     let count = count_unique_chars(word)\n   |                                         ^ help: add `;` here\n16 |     if count > max_count {\n   |     -- unexpected token\n\nerror: expected `;`, found `max_word`\n  --> /tmp/tmpblowsbak.rs:17:24\n   |\n17 |       max_count = count\n   |                        ^ help: add `;` here\n18 |       max_word = word\n   |       -------- unexpected token\n\nerror[E0425]: cannot find function `count_unique_chars` in this scope\n  --> /tmp/tmpblowsbak.rs:15:17\n   |\n15 |     let count = count_unique_chars(word)\n   |                 ^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpblowsbak.rs:18:18\n   |\n13 |   let max_word = \"\"\n   |                  -- expected due to this value\n...\n18 |       max_word = word\n   |                  ^^^^\n   |                  |\n   |                  expected `&str`, found struct `String`\n   |                  help: consider borrowing here: `&word`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpblowsbak.rs:21:10\n   |\n11 | fn find_max(words: Vec<String>) -> String {\n   |                                    ------ expected `String` because of return type\n...\n21 |   return max_word\n   |          ^^^^^^^^- help: try using a conversion method: `.to_string()`\n   |          |\n   |          expected struct `String`, found `&str`\n\nerror: aborting due to 7 previous errors\n\nSome errors have detailed explanations: E0308, E0425.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function that accepts a vector of strings.\n/// The vector contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n  let max_count = 0\n  let max_word = \"\"\n  for w in words {\n    let count = count_unique_chars(w)\n    if count > max_count {\n      max_count = count\n      max_word = w\n    }\n  }\n  return max_word\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]), String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]), String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]), String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n}\n",
      "timestamp": 1664292578,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmp095up2vv.rs:12:20\n   |\n12 |   let max_count = 0\n   |                    ^ help: add `;` here\n13 |   let max_word = \"\"\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmp095up2vv.rs:13:20\n   |\n13 |   let max_word = \"\"\n   |                    ^ help: add `;` here\n14 |   for w in words {\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `if`\n  --> /tmp/tmp095up2vv.rs:15:38\n   |\n15 |     let count = count_unique_chars(w)\n   |                                      ^ help: add `;` here\n16 |     if count > max_count {\n   |     -- unexpected token\n\nerror: expected `;`, found `max_word`\n  --> /tmp/tmp095up2vv.rs:17:24\n   |\n17 |       max_count = count\n   |                        ^ help: add `;` here\n18 |       max_word = w\n   |       -------- unexpected token\n\nerror[E0425]: cannot find function `count_unique_chars` in this scope\n  --> /tmp/tmp095up2vv.rs:15:17\n   |\n15 |     let count = count_unique_chars(w)\n   |                 ^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp095up2vv.rs:18:18\n   |\n13 |   let max_word = \"\"\n   |                  -- expected due to this value\n...\n18 |       max_word = w\n   |                  ^\n   |                  |\n   |                  expected `&str`, found struct `String`\n   |                  help: consider borrowing here: `&w`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp095up2vv.rs:21:10\n   |\n11 | fn find_max(words: Vec<String>) -> String {\n   |                                    ------ expected `String` because of return type\n...\n21 |   return max_word\n   |          ^^^^^^^^- help: try using a conversion method: `.to_string()`\n   |          |\n   |          expected struct `String`, found `&str`\n\nerror: aborting due to 7 previous errors\n\nSome errors have detailed explanations: E0308, E0425.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function that accepts a vector of strings.\n/// The vector contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n  let max_count = 0\n  let max_word = \"\"\n\n  for w in words {\n    let count = 0\n    for i in w {\n      if i.is_upper() {\n        count += 1\n      }\n    }\n    if count > max_count {\n      max_count = count\n      max_word = w\n    }\n  }\n  return max_word\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]), String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]), String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]), String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n}\n",
      "timestamp": 1664292578,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmpo6clqbly.rs:12:20\n   |\n12 |   let max_count = 0\n   |                    ^ help: add `;` here\n13 |   let max_word = \"\"\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpo6clqbly.rs:13:20\n   |\n13 |   let max_word = \"\"\n   |                    ^ help: add `;` here\n14 | \n15 |   for w in words {\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpo6clqbly.rs:16:18\n   |\n16 |     let count = 0\n   |                  ^ help: add `;` here\n17 |     for i in w {\n   |     --- unexpected token\n\nerror: expected `;`, found `max_word`\n  --> /tmp/tmpo6clqbly.rs:23:24\n   |\n23 |       max_count = count\n   |                        ^ help: add `;` here\n24 |       max_word = w\n   |       -------- unexpected token\n\nerror[E0277]: `String` is not an iterator\n  --> /tmp/tmpo6clqbly.rs:17:14\n   |\n17 |     for i in w {\n   |              ^ `String` is not an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait `Iterator` is not implemented for `String`\n   = note: required because of the requirements on the impl of `IntoIterator` for `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpo6clqbly.rs:24:18\n   |\n13 |   let max_word = \"\"\n   |                  -- expected due to this value\n...\n24 |       max_word = w\n   |                  ^\n   |                  |\n   |                  expected `&str`, found struct `String`\n   |                  help: consider borrowing here: `&w`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpo6clqbly.rs:27:10\n   |\n11 | fn find_max(words: Vec<String>) -> String {\n   |                                    ------ expected `String` because of return type\n...\n27 |   return max_word\n   |          ^^^^^^^^- help: try using a conversion method: `.to_string()`\n   |          |\n   |          expected struct `String`, found `&str`\n\nerror: aborting due to 7 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function that accepts a vector of strings.\n/// The vector contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n  let max_count = 0\n  let max_word = \"\"\n  for w in words {\n    let count = count_unique_chars(w)\n    if count > max_count {\n      max_count = count\n      max_word = w\n    }\n  }\n  return max_word\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]), String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]), String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]), String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n}\n",
      "timestamp": 1664292578,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmp095up2vv.rs:12:20\n   |\n12 |   let max_count = 0\n   |                    ^ help: add `;` here\n13 |   let max_word = \"\"\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmp095up2vv.rs:13:20\n   |\n13 |   let max_word = \"\"\n   |                    ^ help: add `;` here\n14 |   for w in words {\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `if`\n  --> /tmp/tmp095up2vv.rs:15:38\n   |\n15 |     let count = count_unique_chars(w)\n   |                                      ^ help: add `;` here\n16 |     if count > max_count {\n   |     -- unexpected token\n\nerror: expected `;`, found `max_word`\n  --> /tmp/tmp095up2vv.rs:17:24\n   |\n17 |       max_count = count\n   |                        ^ help: add `;` here\n18 |       max_word = w\n   |       -------- unexpected token\n\nerror[E0425]: cannot find function `count_unique_chars` in this scope\n  --> /tmp/tmp095up2vv.rs:15:17\n   |\n15 |     let count = count_unique_chars(w)\n   |                 ^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp095up2vv.rs:18:18\n   |\n13 |   let max_word = \"\"\n   |                  -- expected due to this value\n...\n18 |       max_word = w\n   |                  ^\n   |                  |\n   |                  expected `&str`, found struct `String`\n   |                  help: consider borrowing here: `&w`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp095up2vv.rs:21:10\n   |\n11 | fn find_max(words: Vec<String>) -> String {\n   |                                    ------ expected `String` because of return type\n...\n21 |   return max_word\n   |          ^^^^^^^^- help: try using a conversion method: `.to_string()`\n   |          |\n   |          expected struct `String`, found `&str`\n\nerror: aborting due to 7 previous errors\n\nSome errors have detailed explanations: E0308, E0425.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function that accepts a vector of strings.\n/// The vector contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n  let max_count = 0\n  let max_word = \"\"\n  for w in words {\n    let count = w.count(c => c.is_upper())\n    if count > max_count {\n      max_count = count\n      max_word = w\n    }\n  }\n  return max_word\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]), String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]), String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]), String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n}\n",
      "timestamp": 1664292578,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmp_1aykjz4.rs:12:20\n   |\n12 |   let max_count = 0\n   |                    ^ help: add `;` here\n13 |   let max_word = \"\"\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmp_1aykjz4.rs:13:20\n   |\n13 |   let max_word = \"\"\n   |                    ^ help: add `;` here\n14 |   for w in words {\n   |   --- unexpected token\n\nerror: expected one of `!`, `)`, `,`, `.`, `::`, `?`, `{`, or an operator, found `=>`\n  --> /tmp/tmp_1aykjz4.rs:15:27\n   |\n15 |     let count = w.count(c => c.is_upper())\n   |                           ^^ expected one of 8 possible tokens\n\nerror: aborting due to 3 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function that accepts a vector of strings.\n/// The vector contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n  let max_count = 0\n  let max_word = \"\"\n  for word in words {\n    let count = word.count(/[a-z]/);\n    if count > max_count {\n      max_count = count\n      max_word = word\n    }\n  }\n  return max_word\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]), String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]), String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]), String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n}\n",
      "timestamp": 1664292578,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmpsfumfyuh.rs:12:20\n   |\n12 |   let max_count = 0\n   |                    ^ help: add `;` here\n13 |   let max_word = \"\"\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpsfumfyuh.rs:13:20\n   |\n13 |   let max_word = \"\"\n   |                    ^ help: add `;` here\n14 |   for word in words {\n   |   --- unexpected token\n\nerror: expected expression, found `/`\n  --> /tmp/tmpsfumfyuh.rs:15:28\n   |\n15 |     let count = word.count(/[a-z]/);\n   |                            ^ expected expression\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpsfumfyuh.rs:21:10\n   |\n11 | fn find_max(words: Vec<String>) -> String {\n   |                                    ------ expected `String` because of return type\n...\n21 |   return max_word\n   |          ^^^^^^^^- help: try using a conversion method: `.to_string()`\n   |          |\n   |          expected struct `String`, found `&str`\n\nerror: aborting due to 4 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function that accepts a vector of strings.\n/// The vector contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n  let max_count = 0\n  let max_word = \"\"\n  for w in words {\n    let count = w.count(/[a-z]/);\n    if count > max_count {\n      max_count = count\n      max_word = w\n    }\n  }\n  return max_word\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]), String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]), String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]), String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n}\n",
      "timestamp": 1664292578,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmpk6mb5m3s.rs:12:20\n   |\n12 |   let max_count = 0\n   |                    ^ help: add `;` here\n13 |   let max_word = \"\"\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpk6mb5m3s.rs:13:20\n   |\n13 |   let max_word = \"\"\n   |                    ^ help: add `;` here\n14 |   for w in words {\n   |   --- unexpected token\n\nerror: expected expression, found `/`\n  --> /tmp/tmpk6mb5m3s.rs:15:25\n   |\n15 |     let count = w.count(/[a-z]/);\n   |                         ^ expected expression\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpk6mb5m3s.rs:21:10\n   |\n11 | fn find_max(words: Vec<String>) -> String {\n   |                                    ------ expected `String` because of return type\n...\n21 |   return max_word\n   |          ^^^^^^^^- help: try using a conversion method: `.to_string()`\n   |          |\n   |          expected struct `String`, found `&str`\n\nerror: aborting due to 4 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function that accepts a vector of strings.\n/// The vector contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n  let max_count = 0\n  let max_word = \"\"\n  for w in words {\n    let count = w.count(/[a-z]/);\n    if count > max_count {\n      max_count = count\n      max_word = w\n    }\n  }\n  return max_word\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]), String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]), String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]), String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n}\n",
      "timestamp": 1664292578,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmpk6mb5m3s.rs:12:20\n   |\n12 |   let max_count = 0\n   |                    ^ help: add `;` here\n13 |   let max_word = \"\"\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpk6mb5m3s.rs:13:20\n   |\n13 |   let max_word = \"\"\n   |                    ^ help: add `;` here\n14 |   for w in words {\n   |   --- unexpected token\n\nerror: expected expression, found `/`\n  --> /tmp/tmpk6mb5m3s.rs:15:25\n   |\n15 |     let count = w.count(/[a-z]/);\n   |                         ^ expected expression\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpk6mb5m3s.rs:21:10\n   |\n11 | fn find_max(words: Vec<String>) -> String {\n   |                                    ------ expected `String` because of return type\n...\n21 |   return max_word\n   |          ^^^^^^^^- help: try using a conversion method: `.to_string()`\n   |          |\n   |          expected struct `String`, found `&str`\n\nerror: aborting due to 4 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function that accepts a vector of strings.\n/// The vector contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n  let max_count = 0\n  let max_word = \"\"\n  for w in words {\n    let count = w.count(/[a-z]/);\n    if count > max_count {\n      max_count = count\n      max_word = w\n    }\n  }\n  return max_word\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]), String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]), String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]), String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n}\n",
      "timestamp": 1664292578,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmpk6mb5m3s.rs:12:20\n   |\n12 |   let max_count = 0\n   |                    ^ help: add `;` here\n13 |   let max_word = \"\"\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpk6mb5m3s.rs:13:20\n   |\n13 |   let max_word = \"\"\n   |                    ^ help: add `;` here\n14 |   for w in words {\n   |   --- unexpected token\n\nerror: expected expression, found `/`\n  --> /tmp/tmpk6mb5m3s.rs:15:25\n   |\n15 |     let count = w.count(/[a-z]/);\n   |                         ^ expected expression\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpk6mb5m3s.rs:21:10\n   |\n11 | fn find_max(words: Vec<String>) -> String {\n   |                                    ------ expected `String` because of return type\n...\n21 |   return max_word\n   |          ^^^^^^^^- help: try using a conversion method: `.to_string()`\n   |          |\n   |          expected struct `String`, found `&str`\n\nerror: aborting due to 4 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function that accepts a vector of strings.\n/// The vector contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n  let max_count = 0\n  let max_word = \"\"\n  for w in words {\n    let count = w.count_unique()\n    if count > max_count {\n      max_count = count\n      max_word = w\n    }\n  }\n  return max_word\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]), String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]), String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]), String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n}\n",
      "timestamp": 1664292578,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmp5vp_ies0.rs:12:20\n   |\n12 |   let max_count = 0\n   |                    ^ help: add `;` here\n13 |   let max_word = \"\"\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmp5vp_ies0.rs:13:20\n   |\n13 |   let max_word = \"\"\n   |                    ^ help: add `;` here\n14 |   for w in words {\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `if`\n  --> /tmp/tmp5vp_ies0.rs:15:33\n   |\n15 |     let count = w.count_unique()\n   |                                 ^ help: add `;` here\n16 |     if count > max_count {\n   |     -- unexpected token\n\nerror: expected `;`, found `max_word`\n  --> /tmp/tmp5vp_ies0.rs:17:24\n   |\n17 |       max_count = count\n   |                        ^ help: add `;` here\n18 |       max_word = w\n   |       -------- unexpected token\n\nerror[E0599]: no method named `count_unique` found for struct `String` in the current scope\n  --> /tmp/tmp5vp_ies0.rs:15:19\n   |\n15 |     let count = w.count_unique()\n   |                   ^^^^^^^^^^^^ method not found in `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp5vp_ies0.rs:18:18\n   |\n13 |   let max_word = \"\"\n   |                  -- expected due to this value\n...\n18 |       max_word = w\n   |                  ^\n   |                  |\n   |                  expected `&str`, found struct `String`\n   |                  help: consider borrowing here: `&w`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp5vp_ies0.rs:21:10\n   |\n11 | fn find_max(words: Vec<String>) -> String {\n   |                                    ------ expected `String` because of return type\n...\n21 |   return max_word\n   |          ^^^^^^^^- help: try using a conversion method: `.to_string()`\n   |          |\n   |          expected struct `String`, found `&str`\n\nerror: aborting due to 7 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function that accepts a vector of strings.\n/// The vector contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n  let max_count = 0\n  let max_count_index = 0\n  let max_count_word = \"\"\n  for i in 0..words.len() {\n    let count = words[i].count_unique_chars()\n    if count > max_count {\n      max_count = count\n      max_count_index = i\n      max_count_word = words[i]\n    }\n  }\n  return max_count_word\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]), String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]), String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]), String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n}\n",
      "timestamp": 1664292578,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmp24evb004.rs:12:20\n   |\n12 |   let max_count = 0\n   |                    ^ help: add `;` here\n13 |   let max_count_index = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmp24evb004.rs:13:26\n   |\n13 |   let max_count_index = 0\n   |                          ^ help: add `;` here\n14 |   let max_count_word = \"\"\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmp24evb004.rs:14:26\n   |\n14 |   let max_count_word = \"\"\n   |                          ^ help: add `;` here\n15 |   for i in 0..words.len() {\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `if`\n  --> /tmp/tmp24evb004.rs:16:46\n   |\n16 |     let count = words[i].count_unique_chars()\n   |                                              ^ help: add `;` here\n17 |     if count > max_count {\n   |     -- unexpected token\n\nerror: expected `;`, found `max_count_index`\n  --> /tmp/tmp24evb004.rs:18:24\n   |\n18 |       max_count = count\n   |                        ^ help: add `;` here\n19 |       max_count_index = i\n   |       --------------- unexpected token\n\nerror: expected `;`, found `max_count_word`\n  --> /tmp/tmp24evb004.rs:19:26\n   |\n19 |       max_count_index = i\n   |                          ^ help: add `;` here\n20 |       max_count_word = words[i]\n   |       -------------- unexpected token\n\nerror[E0599]: no method named `count_unique_chars` found for struct `String` in the current scope\n  --> /tmp/tmp24evb004.rs:16:26\n   |\n16 |     let count = words[i].count_unique_chars()\n   |                          ^^^^^^^^^^^^^^^^^^ method not found in `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp24evb004.rs:20:24\n   |\n14 |   let max_count_word = \"\"\n   |                        -- expected due to this value\n...\n20 |       max_count_word = words[i]\n   |                        ^^^^^^^^\n   |                        |\n   |                        expected `&str`, found struct `String`\n   |                        help: consider borrowing here: `",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function that accepts a vector of strings.\n/// The vector contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n  let max_count = 0\n  let max_word = \"\"\n  for w in words {\n    let count = 0\n    for i in 0..len(w) {\n      let c = w[i]\n      if c == ' ' {\n        continue\n      }\n      count += 1\n    }\n    if count > max_count {\n      max_count = count\n      max_word = w\n    }\n  }\n  return max_word\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]), String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]), String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]), String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n}\n",
      "timestamp": 1664292578,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmpfry12pct.rs:12:20\n   |\n12 |   let max_count = 0\n   |                    ^ help: add `;` here\n13 |   let max_word = \"\"\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpfry12pct.rs:13:20\n   |\n13 |   let max_word = \"\"\n   |                    ^ help: add `;` here\n14 |   for w in words {\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpfry12pct.rs:15:18\n   |\n15 |     let count = 0\n   |                  ^ help: add `;` here\n16 |     for i in 0..len(w) {\n   |     --- unexpected token\n\nerror: expected `;`, found keyword `if`\n  --> /tmp/tmpfry12pct.rs:17:19\n   |\n17 |       let c = w[i]\n   |                   ^ help: add `;` here\n18 |       if c == ' ' {\n   |       -- unexpected token\n\nerror: expected `;`, found `max_word`\n  --> /tmp/tmpfry12pct.rs:24:24\n   |\n24 |       max_count = count\n   |                        ^ help: add `;` here\n25 |       max_word = w\n   |       -------- unexpected token\n\nerror[E0425]: cannot find function `len` in this scope\n  --> /tmp/tmpfry12pct.rs:16:17\n   |\n16 |     for i in 0..len(w) {\n   |                 ^^^ not found in this scope\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmpfry12pct.rs:17:15\n   |\n17 |       let c = w[i]\n   |               ^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpfry12pct.rs:25:18\n   |\n13 |   let max_word = \"\"\n   |                  -- expected due to this value\n...\n25 |       max_word = w\n   |   ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function that accepts a vector of strings.\n/// The vector contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n  let max_count = 0\n  let max_word = \"\"\n  for w in words {\n    let count = count_unique_chars(w)\n    if count > max_count {\n      max_count = count\n      max_word = w\n    }\n  }\n  return max_word\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]), String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]), String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]), String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n}\n",
      "timestamp": 1664292578,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmp095up2vv.rs:12:20\n   |\n12 |   let max_count = 0\n   |                    ^ help: add `;` here\n13 |   let max_word = \"\"\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmp095up2vv.rs:13:20\n   |\n13 |   let max_word = \"\"\n   |                    ^ help: add `;` here\n14 |   for w in words {\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `if`\n  --> /tmp/tmp095up2vv.rs:15:38\n   |\n15 |     let count = count_unique_chars(w)\n   |                                      ^ help: add `;` here\n16 |     if count > max_count {\n   |     -- unexpected token\n\nerror: expected `;`, found `max_word`\n  --> /tmp/tmp095up2vv.rs:17:24\n   |\n17 |       max_count = count\n   |                        ^ help: add `;` here\n18 |       max_word = w\n   |       -------- unexpected token\n\nerror[E0425]: cannot find function `count_unique_chars` in this scope\n  --> /tmp/tmp095up2vv.rs:15:17\n   |\n15 |     let count = count_unique_chars(w)\n   |                 ^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp095up2vv.rs:18:18\n   |\n13 |   let max_word = \"\"\n   |                  -- expected due to this value\n...\n18 |       max_word = w\n   |                  ^\n   |                  |\n   |                  expected `&str`, found struct `String`\n   |                  help: consider borrowing here: `&w`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp095up2vv.rs:21:10\n   |\n11 | fn find_max(words: Vec<String>) -> String {\n   |                                    ------ expected `String` because of return type\n...\n21 |   return max_word\n   |          ^^^^^^^^- help: try using a conversion method: `.to_string()`\n   |          |\n   |          expected struct `String`, found `&str`\n\nerror: aborting due to 7 previous errors\n\nSome errors have detailed explanations: E0308, E0425.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function that accepts a vector of strings.\n/// The vector contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n  let max_count = 0\n  let max_word = \"\"\n  for w in words {\n    let count = count_unique_chars(w)\n    if count > max_count {\n      max_count = count\n      max_word = w\n    }\n  }\n  return max_word\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]), String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]), String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]), String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n}\n",
      "timestamp": 1664292578,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmp095up2vv.rs:12:20\n   |\n12 |   let max_count = 0\n   |                    ^ help: add `;` here\n13 |   let max_word = \"\"\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmp095up2vv.rs:13:20\n   |\n13 |   let max_word = \"\"\n   |                    ^ help: add `;` here\n14 |   for w in words {\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `if`\n  --> /tmp/tmp095up2vv.rs:15:38\n   |\n15 |     let count = count_unique_chars(w)\n   |                                      ^ help: add `;` here\n16 |     if count > max_count {\n   |     -- unexpected token\n\nerror: expected `;`, found `max_word`\n  --> /tmp/tmp095up2vv.rs:17:24\n   |\n17 |       max_count = count\n   |                        ^ help: add `;` here\n18 |       max_word = w\n   |       -------- unexpected token\n\nerror[E0425]: cannot find function `count_unique_chars` in this scope\n  --> /tmp/tmp095up2vv.rs:15:17\n   |\n15 |     let count = count_unique_chars(w)\n   |                 ^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp095up2vv.rs:18:18\n   |\n13 |   let max_word = \"\"\n   |                  -- expected due to this value\n...\n18 |       max_word = w\n   |                  ^\n   |                  |\n   |                  expected `&str`, found struct `String`\n   |                  help: consider borrowing here: `&w`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp095up2vv.rs:21:10\n   |\n11 | fn find_max(words: Vec<String>) -> String {\n   |                                    ------ expected `String` because of return type\n...\n21 |   return max_word\n   |          ^^^^^^^^- help: try using a conversion method: `.to_string()`\n   |          |\n   |          expected struct `String`, found `&str`\n\nerror: aborting due to 7 previous errors\n\nSome errors have detailed explanations: E0308, E0425.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function that accepts a vector of strings.\n/// The vector contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n  let max_count = 0;\n  let max_word = String::from(\"\");\n  for word in words {\n    let count = word.count(/[a-z]/);\n    if count > max_count {\n      max_count = count;\n      max_word = word;\n    }\n  }\n  return max_word;\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]), String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]), String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]), String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n}\n",
      "timestamp": 1664292578,
      "stdout": "",
      "stderr": "error: expected expression, found `/`\n  --> /tmp/tmph3jntl0q.rs:15:28\n   |\n15 |     let count = word.count(/[a-z]/);\n   |                            ^ expected expression\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function that accepts a vector of strings.\n/// The vector contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n  let max_count = 0\n  let max_word = \"\"\n  for w in words {\n    let count = count_unique_chars(w)\n    if count > max_count {\n      max_count = count\n      max_word = w\n    }\n  }\n  return max_word\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]), String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]), String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]), String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n}\n",
      "timestamp": 1664292578,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmp095up2vv.rs:12:20\n   |\n12 |   let max_count = 0\n   |                    ^ help: add `;` here\n13 |   let max_word = \"\"\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmp095up2vv.rs:13:20\n   |\n13 |   let max_word = \"\"\n   |                    ^ help: add `;` here\n14 |   for w in words {\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `if`\n  --> /tmp/tmp095up2vv.rs:15:38\n   |\n15 |     let count = count_unique_chars(w)\n   |                                      ^ help: add `;` here\n16 |     if count > max_count {\n   |     -- unexpected token\n\nerror: expected `;`, found `max_word`\n  --> /tmp/tmp095up2vv.rs:17:24\n   |\n17 |       max_count = count\n   |                        ^ help: add `;` here\n18 |       max_word = w\n   |       -------- unexpected token\n\nerror[E0425]: cannot find function `count_unique_chars` in this scope\n  --> /tmp/tmp095up2vv.rs:15:17\n   |\n15 |     let count = count_unique_chars(w)\n   |                 ^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp095up2vv.rs:18:18\n   |\n13 |   let max_word = \"\"\n   |                  -- expected due to this value\n...\n18 |       max_word = w\n   |                  ^\n   |                  |\n   |                  expected `&str`, found struct `String`\n   |                  help: consider borrowing here: `&w`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp095up2vv.rs:21:10\n   |\n11 | fn find_max(words: Vec<String>) -> String {\n   |                                    ------ expected `String` because of return type\n...\n21 |   return max_word\n   |          ^^^^^^^^- help: try using a conversion method: `.to_string()`\n   |          |\n   |          expected struct `String`, found `&str`\n\nerror: aborting due to 7 previous errors\n\nSome errors have detailed explanations: E0308, E0425.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function that accepts a vector of strings.\n/// The vector contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n  let max_count = 0\n  let max_word = \"\"\n  for w in words {\n    let count = w.count(c => c.is_upper())\n    if count > max_count {\n      max_count = count\n      max_word = w\n    }\n  }\n  return max_word\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]), String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]), String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]), String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n}\n",
      "timestamp": 1664292578,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmp_1aykjz4.rs:12:20\n   |\n12 |   let max_count = 0\n   |                    ^ help: add `;` here\n13 |   let max_word = \"\"\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmp_1aykjz4.rs:13:20\n   |\n13 |   let max_word = \"\"\n   |                    ^ help: add `;` here\n14 |   for w in words {\n   |   --- unexpected token\n\nerror: expected one of `!`, `)`, `,`, `.`, `::`, `?`, `{`, or an operator, found `=>`\n  --> /tmp/tmp_1aykjz4.rs:15:27\n   |\n15 |     let count = w.count(c => c.is_upper())\n   |                           ^^ expected one of 8 possible tokens\n\nerror: aborting due to 3 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function that accepts a vector of strings.\n/// The vector contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n  let max_count = 0\n  let max_word = \"\"\n  for word in words {\n    let count = count_unique_chars(word)\n    if count > max_count {\n      max_count = count\n      max_word = word\n    }\n  }\n  return max_word\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]), String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]), String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]), String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n}\n",
      "timestamp": 1664292578,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmpblowsbak.rs:12:20\n   |\n12 |   let max_count = 0\n   |                    ^ help: add `;` here\n13 |   let max_word = \"\"\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpblowsbak.rs:13:20\n   |\n13 |   let max_word = \"\"\n   |                    ^ help: add `;` here\n14 |   for word in words {\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `if`\n  --> /tmp/tmpblowsbak.rs:15:41\n   |\n15 |     let count = count_unique_chars(word)\n   |                                         ^ help: add `;` here\n16 |     if count > max_count {\n   |     -- unexpected token\n\nerror: expected `;`, found `max_word`\n  --> /tmp/tmpblowsbak.rs:17:24\n   |\n17 |       max_count = count\n   |                        ^ help: add `;` here\n18 |       max_word = word\n   |       -------- unexpected token\n\nerror[E0425]: cannot find function `count_unique_chars` in this scope\n  --> /tmp/tmpblowsbak.rs:15:17\n   |\n15 |     let count = count_unique_chars(word)\n   |                 ^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpblowsbak.rs:18:18\n   |\n13 |   let max_word = \"\"\n   |                  -- expected due to this value\n...\n18 |       max_word = word\n   |                  ^^^^\n   |                  |\n   |                  expected `&str`, found struct `String`\n   |                  help: consider borrowing here: `&word`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpblowsbak.rs:21:10\n   |\n11 | fn find_max(words: Vec<String>) -> String {\n   |                                    ------ expected `String` because of return type\n...\n21 |   return max_word\n   |          ^^^^^^^^- help: try using a conversion method: `.to_string()`\n   |          |\n   |          expected struct `String`, found `&str`\n\nerror: aborting due to 7 previous errors\n\nSome errors have detailed explanations: E0308, E0425.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function that accepts a vector of strings.\n/// The vector contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n  let max_count = 0\n  let max_word = \"\"\n  for w in words {\n    let count = count_unique_chars(w)\n    if count > max_count {\n      max_count = count\n      max_word = w\n    }\n  }\n  return max_word\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]), String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]), String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]), String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n}\n",
      "timestamp": 1664292578,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmp095up2vv.rs:12:20\n   |\n12 |   let max_count = 0\n   |                    ^ help: add `;` here\n13 |   let max_word = \"\"\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmp095up2vv.rs:13:20\n   |\n13 |   let max_word = \"\"\n   |                    ^ help: add `;` here\n14 |   for w in words {\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `if`\n  --> /tmp/tmp095up2vv.rs:15:38\n   |\n15 |     let count = count_unique_chars(w)\n   |                                      ^ help: add `;` here\n16 |     if count > max_count {\n   |     -- unexpected token\n\nerror: expected `;`, found `max_word`\n  --> /tmp/tmp095up2vv.rs:17:24\n   |\n17 |       max_count = count\n   |                        ^ help: add `;` here\n18 |       max_word = w\n   |       -------- unexpected token\n\nerror[E0425]: cannot find function `count_unique_chars` in this scope\n  --> /tmp/tmp095up2vv.rs:15:17\n   |\n15 |     let count = count_unique_chars(w)\n   |                 ^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp095up2vv.rs:18:18\n   |\n13 |   let max_word = \"\"\n   |                  -- expected due to this value\n...\n18 |       max_word = w\n   |                  ^\n   |                  |\n   |                  expected `&str`, found struct `String`\n   |                  help: consider borrowing here: `&w`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp095up2vv.rs:21:10\n   |\n11 | fn find_max(words: Vec<String>) -> String {\n   |                                    ------ expected `String` because of return type\n...\n21 |   return max_word\n   |          ^^^^^^^^- help: try using a conversion method: `.to_string()`\n   |          |\n   |          expected struct `String`, found `&str`\n\nerror: aborting due to 7 previous errors\n\nSome errors have detailed explanations: E0308, E0425.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function that accepts a vector of strings.\n/// The vector contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n  let max_count = 0\n  let max_word = \"\"\n  for w in words {\n    let count = count_unique_chars(w)\n    if count > max_count {\n      max_count = count\n      max_word = w\n    }\n  }\n  return max_word\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]), String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]), String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]), String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n}\n",
      "timestamp": 1664292578,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmp095up2vv.rs:12:20\n   |\n12 |   let max_count = 0\n   |                    ^ help: add `;` here\n13 |   let max_word = \"\"\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmp095up2vv.rs:13:20\n   |\n13 |   let max_word = \"\"\n   |                    ^ help: add `;` here\n14 |   for w in words {\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `if`\n  --> /tmp/tmp095up2vv.rs:15:38\n   |\n15 |     let count = count_unique_chars(w)\n   |                                      ^ help: add `;` here\n16 |     if count > max_count {\n   |     -- unexpected token\n\nerror: expected `;`, found `max_word`\n  --> /tmp/tmp095up2vv.rs:17:24\n   |\n17 |       max_count = count\n   |                        ^ help: add `;` here\n18 |       max_word = w\n   |       -------- unexpected token\n\nerror[E0425]: cannot find function `count_unique_chars` in this scope\n  --> /tmp/tmp095up2vv.rs:15:17\n   |\n15 |     let count = count_unique_chars(w)\n   |                 ^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp095up2vv.rs:18:18\n   |\n13 |   let max_word = \"\"\n   |                  -- expected due to this value\n...\n18 |       max_word = w\n   |                  ^\n   |                  |\n   |                  expected `&str`, found struct `String`\n   |                  help: consider borrowing here: `&w`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp095up2vv.rs:21:10\n   |\n11 | fn find_max(words: Vec<String>) -> String {\n   |                                    ------ expected `String` because of return type\n...\n21 |   return max_word\n   |          ^^^^^^^^- help: try using a conversion method: `.to_string()`\n   |          |\n   |          expected struct `String`, found `&str`\n\nerror: aborting due to 7 previous errors\n\nSome errors have detailed explanations: E0308, E0425.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function that accepts a vector of strings.\n/// The vector contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n  let max_count = 0\n  let max_word = \"\"\n  for w in words {\n    let count = count_unique_chars(w)\n    if count > max_count {\n      max_count = count\n      max_word = w\n    }\n  }\n  return max_word\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]), String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]), String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]), String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n}\n",
      "timestamp": 1664292578,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmp095up2vv.rs:12:20\n   |\n12 |   let max_count = 0\n   |                    ^ help: add `;` here\n13 |   let max_word = \"\"\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmp095up2vv.rs:13:20\n   |\n13 |   let max_word = \"\"\n   |                    ^ help: add `;` here\n14 |   for w in words {\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `if`\n  --> /tmp/tmp095up2vv.rs:15:38\n   |\n15 |     let count = count_unique_chars(w)\n   |                                      ^ help: add `;` here\n16 |     if count > max_count {\n   |     -- unexpected token\n\nerror: expected `;`, found `max_word`\n  --> /tmp/tmp095up2vv.rs:17:24\n   |\n17 |       max_count = count\n   |                        ^ help: add `;` here\n18 |       max_word = w\n   |       -------- unexpected token\n\nerror[E0425]: cannot find function `count_unique_chars` in this scope\n  --> /tmp/tmp095up2vv.rs:15:17\n   |\n15 |     let count = count_unique_chars(w)\n   |                 ^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp095up2vv.rs:18:18\n   |\n13 |   let max_word = \"\"\n   |                  -- expected due to this value\n...\n18 |       max_word = w\n   |                  ^\n   |                  |\n   |                  expected `&str`, found struct `String`\n   |                  help: consider borrowing here: `&w`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp095up2vv.rs:21:10\n   |\n11 | fn find_max(words: Vec<String>) -> String {\n   |                                    ------ expected `String` because of return type\n...\n21 |   return max_word\n   |          ^^^^^^^^- help: try using a conversion method: `.to_string()`\n   |          |\n   |          expected struct `String`, found `&str`\n\nerror: aborting due to 7 previous errors\n\nSome errors have detailed explanations: E0308, E0425.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function that accepts a vector of strings.\n/// The vector contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n  let max_count = 0\n  let max_word = \"\"\n  for w in words {\n    let count = count_unique_chars(w)\n    if count > max_count {\n      max_count = count\n      max_word = w\n    }\n  }\n  return max_word\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]), String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]), String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]), String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n}\n",
      "timestamp": 1664292578,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmp095up2vv.rs:12:20\n   |\n12 |   let max_count = 0\n   |                    ^ help: add `;` here\n13 |   let max_word = \"\"\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmp095up2vv.rs:13:20\n   |\n13 |   let max_word = \"\"\n   |                    ^ help: add `;` here\n14 |   for w in words {\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `if`\n  --> /tmp/tmp095up2vv.rs:15:38\n   |\n15 |     let count = count_unique_chars(w)\n   |                                      ^ help: add `;` here\n16 |     if count > max_count {\n   |     -- unexpected token\n\nerror: expected `;`, found `max_word`\n  --> /tmp/tmp095up2vv.rs:17:24\n   |\n17 |       max_count = count\n   |                        ^ help: add `;` here\n18 |       max_word = w\n   |       -------- unexpected token\n\nerror[E0425]: cannot find function `count_unique_chars` in this scope\n  --> /tmp/tmp095up2vv.rs:15:17\n   |\n15 |     let count = count_unique_chars(w)\n   |                 ^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp095up2vv.rs:18:18\n   |\n13 |   let max_word = \"\"\n   |                  -- expected due to this value\n...\n18 |       max_word = w\n   |                  ^\n   |                  |\n   |                  expected `&str`, found struct `String`\n   |                  help: consider borrowing here: `&w`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp095up2vv.rs:21:10\n   |\n11 | fn find_max(words: Vec<String>) -> String {\n   |                                    ------ expected `String` because of return type\n...\n21 |   return max_word\n   |          ^^^^^^^^- help: try using a conversion method: `.to_string()`\n   |          |\n   |          expected struct `String`, found `&str`\n\nerror: aborting due to 7 previous errors\n\nSome errors have detailed explanations: E0308, E0425.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function that accepts a vector of strings.\n/// The vector contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n  let max_count = 0\n  let max_word = String::from(\"\")\n  for w in words {\n    let count = w.count(/[a-z]/)\n    if count > max_count {\n      max_count = count\n      max_word = w\n    }\n  }\n  return max_word\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]), String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]), String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]), String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n}\n",
      "timestamp": 1664292578,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmpk2uxpx2c.rs:12:20\n   |\n12 |   let max_count = 0\n   |                    ^ help: add `;` here\n13 |   let max_word = String::from(\"\")\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpk2uxpx2c.rs:13:34\n   |\n13 |   let max_word = String::from(\"\")\n   |                                  ^ help: add `;` here\n14 |   for w in words {\n   |   --- unexpected token\n\nerror: expected expression, found `/`\n  --> /tmp/tmpk2uxpx2c.rs:15:25\n   |\n15 |     let count = w.count(/[a-z]/)\n   |                         ^ expected expression\n\nerror: aborting due to 3 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function that accepts a vector of strings.\n/// The vector contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n  let max_count = 0\n  let max_word = \"\"\n  for w in words {\n    let count = w.count(c => c.is_upper())\n    if count > max_count {\n      max_count = count\n      max_word = w\n    }\n  }\n  return max_word\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]), String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]), String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]), String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n}\n",
      "timestamp": 1664292578,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmp_1aykjz4.rs:12:20\n   |\n12 |   let max_count = 0\n   |                    ^ help: add `;` here\n13 |   let max_word = \"\"\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmp_1aykjz4.rs:13:20\n   |\n13 |   let max_word = \"\"\n   |                    ^ help: add `;` here\n14 |   for w in words {\n   |   --- unexpected token\n\nerror: expected one of `!`, `)`, `,`, `.`, `::`, `?`, `{`, or an operator, found `=>`\n  --> /tmp/tmp_1aykjz4.rs:15:27\n   |\n15 |     let count = w.count(c => c.is_upper())\n   |                           ^^ expected one of 8 possible tokens\n\nerror: aborting due to 3 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function that accepts a vector of strings.\n/// The vector contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n  let max_count = 0\n  let max_word = \"\"\n  for word in words {\n    let count = count_unique_chars(word)\n    if count > max_count {\n      max_count = count\n      max_word = word\n    }\n  }\n  return max_word\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]), String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]), String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]), String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n}\n",
      "timestamp": 1664292578,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmpblowsbak.rs:12:20\n   |\n12 |   let max_count = 0\n   |                    ^ help: add `;` here\n13 |   let max_word = \"\"\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpblowsbak.rs:13:20\n   |\n13 |   let max_word = \"\"\n   |                    ^ help: add `;` here\n14 |   for word in words {\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `if`\n  --> /tmp/tmpblowsbak.rs:15:41\n   |\n15 |     let count = count_unique_chars(word)\n   |                                         ^ help: add `;` here\n16 |     if count > max_count {\n   |     -- unexpected token\n\nerror: expected `;`, found `max_word`\n  --> /tmp/tmpblowsbak.rs:17:24\n   |\n17 |       max_count = count\n   |                        ^ help: add `;` here\n18 |       max_word = word\n   |       -------- unexpected token\n\nerror[E0425]: cannot find function `count_unique_chars` in this scope\n  --> /tmp/tmpblowsbak.rs:15:17\n   |\n15 |     let count = count_unique_chars(word)\n   |                 ^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpblowsbak.rs:18:18\n   |\n13 |   let max_word = \"\"\n   |                  -- expected due to this value\n...\n18 |       max_word = word\n   |                  ^^^^\n   |                  |\n   |                  expected `&str`, found struct `String`\n   |                  help: consider borrowing here: `&word`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpblowsbak.rs:21:10\n   |\n11 | fn find_max(words: Vec<String>) -> String {\n   |                                    ------ expected `String` because of return type\n...\n21 |   return max_word\n   |          ^^^^^^^^- help: try using a conversion method: `.to_string()`\n   |          |\n   |          expected struct `String`, found `&str`\n\nerror: aborting due to 7 previous errors\n\nSome errors have detailed explanations: E0308, E0425.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function that accepts a vector of strings.\n/// The vector contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n  let max_count = 0\n  let max_count_index = 0\n  let max_count_word = \"\"\n  for i in words {\n    let count = count_unique_chars(i)\n    if count > max_count {\n      max_count = count\n      max_count_index = i\n      max_count_word = i\n    }\n  }\n  return max_count_word\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]), String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]), String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]), String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n}\n",
      "timestamp": 1664292578,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmp62dii2xh.rs:12:20\n   |\n12 |   let max_count = 0\n   |                    ^ help: add `;` here\n13 |   let max_count_index = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmp62dii2xh.rs:13:26\n   |\n13 |   let max_count_index = 0\n   |                          ^ help: add `;` here\n14 |   let max_count_word = \"\"\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmp62dii2xh.rs:14:26\n   |\n14 |   let max_count_word = \"\"\n   |                          ^ help: add `;` here\n15 |   for i in words {\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `if`\n  --> /tmp/tmp62dii2xh.rs:16:38\n   |\n16 |     let count = count_unique_chars(i)\n   |                                      ^ help: add `;` here\n17 |     if count > max_count {\n   |     -- unexpected token\n\nerror: expected `;`, found `max_count_index`\n  --> /tmp/tmp62dii2xh.rs:18:24\n   |\n18 |       max_count = count\n   |                        ^ help: add `;` here\n19 |       max_count_index = i\n   |       --------------- unexpected token\n\nerror: expected `;`, found `max_count_word`\n  --> /tmp/tmp62dii2xh.rs:19:26\n   |\n19 |       max_count_index = i\n   |                          ^ help: add `;` here\n20 |       max_count_word = i\n   |       -------------- unexpected token\n\nerror[E0425]: cannot find function `count_unique_chars` in this scope\n  --> /tmp/tmp62dii2xh.rs:16:17\n   |\n16 |     let count = count_unique_chars(i)\n   |                 ^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp62dii2xh.rs:19:25\n   |\n13 |   let max_count_index = 0\n   |                         - expected due to this value\n...\n19 |       max_count_index = i\n   |                         ^ expected integer, found struct `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp62dii2xh.rs:20:24\n   |\n14 |   let max_count_word = \"\"\n   |                        -- expected due to this value\n...\n20 |       max_count_word = i\n   |               ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function that accepts a vector of strings.\n/// The vector contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n  let max_count = 0\n  let max_word = \"\"\n  for w in words {\n    let count = count_unique_chars(w)\n    if count > max_count {\n      max_count = count\n      max_word = w\n    }\n  }\n  return max_word\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]), String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]), String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]), String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n}\n",
      "timestamp": 1664292578,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmp095up2vv.rs:12:20\n   |\n12 |   let max_count = 0\n   |                    ^ help: add `;` here\n13 |   let max_word = \"\"\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmp095up2vv.rs:13:20\n   |\n13 |   let max_word = \"\"\n   |                    ^ help: add `;` here\n14 |   for w in words {\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `if`\n  --> /tmp/tmp095up2vv.rs:15:38\n   |\n15 |     let count = count_unique_chars(w)\n   |                                      ^ help: add `;` here\n16 |     if count > max_count {\n   |     -- unexpected token\n\nerror: expected `;`, found `max_word`\n  --> /tmp/tmp095up2vv.rs:17:24\n   |\n17 |       max_count = count\n   |                        ^ help: add `;` here\n18 |       max_word = w\n   |       -------- unexpected token\n\nerror[E0425]: cannot find function `count_unique_chars` in this scope\n  --> /tmp/tmp095up2vv.rs:15:17\n   |\n15 |     let count = count_unique_chars(w)\n   |                 ^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp095up2vv.rs:18:18\n   |\n13 |   let max_word = \"\"\n   |                  -- expected due to this value\n...\n18 |       max_word = w\n   |                  ^\n   |                  |\n   |                  expected `&str`, found struct `String`\n   |                  help: consider borrowing here: `&w`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp095up2vv.rs:21:10\n   |\n11 | fn find_max(words: Vec<String>) -> String {\n   |                                    ------ expected `String` because of return type\n...\n21 |   return max_word\n   |          ^^^^^^^^- help: try using a conversion method: `.to_string()`\n   |          |\n   |          expected struct `String`, found `&str`\n\nerror: aborting due to 7 previous errors\n\nSome errors have detailed explanations: E0308, E0425.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function that accepts a vector of strings.\n/// The vector contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n  let max_count = 0\n  let max_word = \"\"\n  for w in words {\n    let count = w.count(/[a-z]/);\n    if count > max_count {\n      max_count = count\n      max_word = w\n    }\n  }\n  return max_word\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]), String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]), String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]), String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n}\n",
      "timestamp": 1664292578,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmpk6mb5m3s.rs:12:20\n   |\n12 |   let max_count = 0\n   |                    ^ help: add `;` here\n13 |   let max_word = \"\"\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpk6mb5m3s.rs:13:20\n   |\n13 |   let max_word = \"\"\n   |                    ^ help: add `;` here\n14 |   for w in words {\n   |   --- unexpected token\n\nerror: expected expression, found `/`\n  --> /tmp/tmpk6mb5m3s.rs:15:25\n   |\n15 |     let count = w.count(/[a-z]/);\n   |                         ^ expected expression\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpk6mb5m3s.rs:21:10\n   |\n11 | fn find_max(words: Vec<String>) -> String {\n   |                                    ------ expected `String` because of return type\n...\n21 |   return max_word\n   |          ^^^^^^^^- help: try using a conversion method: `.to_string()`\n   |          |\n   |          expected struct `String`, found `&str`\n\nerror: aborting due to 4 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function that accepts a vector of strings.\n/// The vector contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n  let max_count = 0\n  let max_word = \"\"\n  for word in words {\n    let count = word.count(/[a-z]/);\n    if count > max_count {\n      max_count = count\n      max_word = word\n    }\n  }\n  return max_word\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]), String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]), String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]), String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n}\n",
      "timestamp": 1664292578,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmpsfumfyuh.rs:12:20\n   |\n12 |   let max_count = 0\n   |                    ^ help: add `;` here\n13 |   let max_word = \"\"\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpsfumfyuh.rs:13:20\n   |\n13 |   let max_word = \"\"\n   |                    ^ help: add `;` here\n14 |   for word in words {\n   |   --- unexpected token\n\nerror: expected expression, found `/`\n  --> /tmp/tmpsfumfyuh.rs:15:28\n   |\n15 |     let count = word.count(/[a-z]/);\n   |                            ^ expected expression\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpsfumfyuh.rs:21:10\n   |\n11 | fn find_max(words: Vec<String>) -> String {\n   |                                    ------ expected `String` because of return type\n...\n21 |   return max_word\n   |          ^^^^^^^^- help: try using a conversion method: `.to_string()`\n   |          |\n   |          expected struct `String`, found `&str`\n\nerror: aborting due to 4 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function that accepts a vector of strings.\n/// The vector contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n  let max_count = 0\n  let max_word = \"\"\n  for w in words {\n    let count = count_unique_chars(w)\n    if count > max_count {\n      max_count = count\n      max_word = w\n    }\n  }\n  return max_word\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]), String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]), String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]), String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n}\n",
      "timestamp": 1664292578,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmp095up2vv.rs:12:20\n   |\n12 |   let max_count = 0\n   |                    ^ help: add `;` here\n13 |   let max_word = \"\"\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmp095up2vv.rs:13:20\n   |\n13 |   let max_word = \"\"\n   |                    ^ help: add `;` here\n14 |   for w in words {\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `if`\n  --> /tmp/tmp095up2vv.rs:15:38\n   |\n15 |     let count = count_unique_chars(w)\n   |                                      ^ help: add `;` here\n16 |     if count > max_count {\n   |     -- unexpected token\n\nerror: expected `;`, found `max_word`\n  --> /tmp/tmp095up2vv.rs:17:24\n   |\n17 |       max_count = count\n   |                        ^ help: add `;` here\n18 |       max_word = w\n   |       -------- unexpected token\n\nerror[E0425]: cannot find function `count_unique_chars` in this scope\n  --> /tmp/tmp095up2vv.rs:15:17\n   |\n15 |     let count = count_unique_chars(w)\n   |                 ^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp095up2vv.rs:18:18\n   |\n13 |   let max_word = \"\"\n   |                  -- expected due to this value\n...\n18 |       max_word = w\n   |                  ^\n   |                  |\n   |                  expected `&str`, found struct `String`\n   |                  help: consider borrowing here: `&w`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp095up2vv.rs:21:10\n   |\n11 | fn find_max(words: Vec<String>) -> String {\n   |                                    ------ expected `String` because of return type\n...\n21 |   return max_word\n   |          ^^^^^^^^- help: try using a conversion method: `.to_string()`\n   |          |\n   |          expected struct `String`, found `&str`\n\nerror: aborting due to 7 previous errors\n\nSome errors have detailed explanations: E0308, E0425.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function that accepts a vector of strings.\n/// The vector contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n  let max_count = 0\n  let max_word = \"\"\n  for word in words {\n    let count = count_unique_chars(word)\n    if count > max_count {\n      max_count = count\n      max_word = word\n    }\n  }\n  return max_word\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]), String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]), String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]), String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n}\n",
      "timestamp": 1664292578,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmpblowsbak.rs:12:20\n   |\n12 |   let max_count = 0\n   |                    ^ help: add `;` here\n13 |   let max_word = \"\"\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpblowsbak.rs:13:20\n   |\n13 |   let max_word = \"\"\n   |                    ^ help: add `;` here\n14 |   for word in words {\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `if`\n  --> /tmp/tmpblowsbak.rs:15:41\n   |\n15 |     let count = count_unique_chars(word)\n   |                                         ^ help: add `;` here\n16 |     if count > max_count {\n   |     -- unexpected token\n\nerror: expected `;`, found `max_word`\n  --> /tmp/tmpblowsbak.rs:17:24\n   |\n17 |       max_count = count\n   |                        ^ help: add `;` here\n18 |       max_word = word\n   |       -------- unexpected token\n\nerror[E0425]: cannot find function `count_unique_chars` in this scope\n  --> /tmp/tmpblowsbak.rs:15:17\n   |\n15 |     let count = count_unique_chars(word)\n   |                 ^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpblowsbak.rs:18:18\n   |\n13 |   let max_word = \"\"\n   |                  -- expected due to this value\n...\n18 |       max_word = word\n   |                  ^^^^\n   |                  |\n   |                  expected `&str`, found struct `String`\n   |                  help: consider borrowing here: `&word`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpblowsbak.rs:21:10\n   |\n11 | fn find_max(words: Vec<String>) -> String {\n   |                                    ------ expected `String` because of return type\n...\n21 |   return max_word\n   |          ^^^^^^^^- help: try using a conversion method: `.to_string()`\n   |          |\n   |          expected struct `String`, found `&str`\n\nerror: aborting due to 7 previous errors\n\nSome errors have detailed explanations: E0308, E0425.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function that accepts a vector of strings.\n/// The vector contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n  let max_count = 0\n  let max_word = \"\"\n  for word in words {\n    let count = word.count(/[a-z]/);\n    if count > max_count {\n      max_count = count\n      max_word = word\n    }\n  }\n  return max_word\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]), String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]), String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]), String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n}\n",
      "timestamp": 1664292578,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmpsfumfyuh.rs:12:20\n   |\n12 |   let max_count = 0\n   |                    ^ help: add `;` here\n13 |   let max_word = \"\"\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpsfumfyuh.rs:13:20\n   |\n13 |   let max_word = \"\"\n   |                    ^ help: add `;` here\n14 |   for word in words {\n   |   --- unexpected token\n\nerror: expected expression, found `/`\n  --> /tmp/tmpsfumfyuh.rs:15:28\n   |\n15 |     let count = word.count(/[a-z]/);\n   |                            ^ expected expression\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpsfumfyuh.rs:21:10\n   |\n11 | fn find_max(words: Vec<String>) -> String {\n   |                                    ------ expected `String` because of return type\n...\n21 |   return max_word\n   |          ^^^^^^^^- help: try using a conversion method: `.to_string()`\n   |          |\n   |          expected struct `String`, found `&str`\n\nerror: aborting due to 4 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function that accepts a vector of strings.\n/// The vector contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n  let max_count = 0\n  let max_word = \"\"\n  for w in words {\n    let count = w.count(/[a-z]/);\n    if count > max_count {\n      max_count = count\n      max_word = w\n    }\n  }\n  return max_word\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]), String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]), String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]), String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n}\n",
      "timestamp": 1664292578,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmpk6mb5m3s.rs:12:20\n   |\n12 |   let max_count = 0\n   |                    ^ help: add `;` here\n13 |   let max_word = \"\"\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpk6mb5m3s.rs:13:20\n   |\n13 |   let max_word = \"\"\n   |                    ^ help: add `;` here\n14 |   for w in words {\n   |   --- unexpected token\n\nerror: expected expression, found `/`\n  --> /tmp/tmpk6mb5m3s.rs:15:25\n   |\n15 |     let count = w.count(/[a-z]/);\n   |                         ^ expected expression\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpk6mb5m3s.rs:21:10\n   |\n11 | fn find_max(words: Vec<String>) -> String {\n   |                                    ------ expected `String` because of return type\n...\n21 |   return max_word\n   |          ^^^^^^^^- help: try using a conversion method: `.to_string()`\n   |          |\n   |          expected struct `String`, found `&str`\n\nerror: aborting due to 4 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function that accepts a vector of strings.\n/// The vector contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n  let max_count = 0\n  let max_word = \"\"\n  for w in words {\n    let count = count_unique_chars(w)\n    if count > max_count {\n      max_count = count\n      max_word = w\n    }\n  }\n  return max_word\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]), String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]), String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]), String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n}\n",
      "timestamp": 1664292578,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmp095up2vv.rs:12:20\n   |\n12 |   let max_count = 0\n   |                    ^ help: add `;` here\n13 |   let max_word = \"\"\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmp095up2vv.rs:13:20\n   |\n13 |   let max_word = \"\"\n   |                    ^ help: add `;` here\n14 |   for w in words {\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `if`\n  --> /tmp/tmp095up2vv.rs:15:38\n   |\n15 |     let count = count_unique_chars(w)\n   |                                      ^ help: add `;` here\n16 |     if count > max_count {\n   |     -- unexpected token\n\nerror: expected `;`, found `max_word`\n  --> /tmp/tmp095up2vv.rs:17:24\n   |\n17 |       max_count = count\n   |                        ^ help: add `;` here\n18 |       max_word = w\n   |       -------- unexpected token\n\nerror[E0425]: cannot find function `count_unique_chars` in this scope\n  --> /tmp/tmp095up2vv.rs:15:17\n   |\n15 |     let count = count_unique_chars(w)\n   |                 ^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp095up2vv.rs:18:18\n   |\n13 |   let max_word = \"\"\n   |                  -- expected due to this value\n...\n18 |       max_word = w\n   |                  ^\n   |                  |\n   |                  expected `&str`, found struct `String`\n   |                  help: consider borrowing here: `&w`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp095up2vv.rs:21:10\n   |\n11 | fn find_max(words: Vec<String>) -> String {\n   |                                    ------ expected `String` because of return type\n...\n21 |   return max_word\n   |          ^^^^^^^^- help: try using a conversion method: `.to_string()`\n   |          |\n   |          expected struct `String`, found `&str`\n\nerror: aborting due to 7 previous errors\n\nSome errors have detailed explanations: E0308, E0425.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function that accepts a vector of strings.\n/// The vector contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n  let max_count = 0\n  let max_word = \"\"\n  for word in words {\n    let count = word.count(/[a-z]/);\n    if count > max_count {\n      max_count = count\n      max_word = word\n    }\n  }\n  return max_word\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]), String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]), String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]), String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n}\n",
      "timestamp": 1664292578,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmpsfumfyuh.rs:12:20\n   |\n12 |   let max_count = 0\n   |                    ^ help: add `;` here\n13 |   let max_word = \"\"\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpsfumfyuh.rs:13:20\n   |\n13 |   let max_word = \"\"\n   |                    ^ help: add `;` here\n14 |   for word in words {\n   |   --- unexpected token\n\nerror: expected expression, found `/`\n  --> /tmp/tmpsfumfyuh.rs:15:28\n   |\n15 |     let count = word.count(/[a-z]/);\n   |                            ^ expected expression\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpsfumfyuh.rs:21:10\n   |\n11 | fn find_max(words: Vec<String>) -> String {\n   |                                    ------ expected `String` because of return type\n...\n21 |   return max_word\n   |          ^^^^^^^^- help: try using a conversion method: `.to_string()`\n   |          |\n   |          expected struct `String`, found `&str`\n\nerror: aborting due to 4 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function that accepts a vector of strings.\n/// The vector contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n  let max_count = 0\n  let max_word = \"\"\n  for w in words {\n    let count = count_unique_chars(w)\n    if count > max_count {\n      max_count = count\n      max_word = w\n    }\n  }\n  return max_word\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]), String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]), String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]), String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n}\n",
      "timestamp": 1664292578,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmp095up2vv.rs:12:20\n   |\n12 |   let max_count = 0\n   |                    ^ help: add `;` here\n13 |   let max_word = \"\"\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmp095up2vv.rs:13:20\n   |\n13 |   let max_word = \"\"\n   |                    ^ help: add `;` here\n14 |   for w in words {\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `if`\n  --> /tmp/tmp095up2vv.rs:15:38\n   |\n15 |     let count = count_unique_chars(w)\n   |                                      ^ help: add `;` here\n16 |     if count > max_count {\n   |     -- unexpected token\n\nerror: expected `;`, found `max_word`\n  --> /tmp/tmp095up2vv.rs:17:24\n   |\n17 |       max_count = count\n   |                        ^ help: add `;` here\n18 |       max_word = w\n   |       -------- unexpected token\n\nerror[E0425]: cannot find function `count_unique_chars` in this scope\n  --> /tmp/tmp095up2vv.rs:15:17\n   |\n15 |     let count = count_unique_chars(w)\n   |                 ^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp095up2vv.rs:18:18\n   |\n13 |   let max_word = \"\"\n   |                  -- expected due to this value\n...\n18 |       max_word = w\n   |                  ^\n   |                  |\n   |                  expected `&str`, found struct `String`\n   |                  help: consider borrowing here: `&w`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp095up2vv.rs:21:10\n   |\n11 | fn find_max(words: Vec<String>) -> String {\n   |                                    ------ expected `String` because of return type\n...\n21 |   return max_word\n   |          ^^^^^^^^- help: try using a conversion method: `.to_string()`\n   |          |\n   |          expected struct `String`, found `&str`\n\nerror: aborting due to 7 previous errors\n\nSome errors have detailed explanations: E0308, E0425.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function that accepts a vector of strings.\n/// The vector contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n  let max_count = 0\n  let max_word = \"\"\n  for w in words {\n    let count = w.count(/[a-z]/);\n    if count > max_count {\n      max_count = count\n      max_word = w\n    }\n  }\n  return max_word\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]), String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]), String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]), String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n}\n",
      "timestamp": 1664292578,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmpk6mb5m3s.rs:12:20\n   |\n12 |   let max_count = 0\n   |                    ^ help: add `;` here\n13 |   let max_word = \"\"\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpk6mb5m3s.rs:13:20\n   |\n13 |   let max_word = \"\"\n   |                    ^ help: add `;` here\n14 |   for w in words {\n   |   --- unexpected token\n\nerror: expected expression, found `/`\n  --> /tmp/tmpk6mb5m3s.rs:15:25\n   |\n15 |     let count = w.count(/[a-z]/);\n   |                         ^ expected expression\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpk6mb5m3s.rs:21:10\n   |\n11 | fn find_max(words: Vec<String>) -> String {\n   |                                    ------ expected `String` because of return type\n...\n21 |   return max_word\n   |          ^^^^^^^^- help: try using a conversion method: `.to_string()`\n   |          |\n   |          expected struct `String`, found `&str`\n\nerror: aborting due to 4 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function that accepts a vector of strings.\n/// The vector contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n  let max_count = 0\n  let max_word = \"\"\n  for w in words {\n    let count = w.count(/[a-z]/);\n    if count > max_count {\n      max_count = count\n      max_word = w\n    }\n  }\n  return max_word\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]), String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]), String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]), String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n}\n",
      "timestamp": 1664292578,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmpk6mb5m3s.rs:12:20\n   |\n12 |   let max_count = 0\n   |                    ^ help: add `;` here\n13 |   let max_word = \"\"\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpk6mb5m3s.rs:13:20\n   |\n13 |   let max_word = \"\"\n   |                    ^ help: add `;` here\n14 |   for w in words {\n   |   --- unexpected token\n\nerror: expected expression, found `/`\n  --> /tmp/tmpk6mb5m3s.rs:15:25\n   |\n15 |     let count = w.count(/[a-z]/);\n   |                         ^ expected expression\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpk6mb5m3s.rs:21:10\n   |\n11 | fn find_max(words: Vec<String>) -> String {\n   |                                    ------ expected `String` because of return type\n...\n21 |   return max_word\n   |          ^^^^^^^^- help: try using a conversion method: `.to_string()`\n   |          |\n   |          expected struct `String`, found `&str`\n\nerror: aborting due to 4 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function that accepts a vector of strings.\n/// The vector contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n  let max_count = 0\n  let max_word = \"\"\n  for w in words {\n    let count = count_unique_chars(w)\n    if count > max_count {\n      max_count = count\n      max_word = w\n    }\n  }\n  return max_word\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]), String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]), String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]), String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n}\n",
      "timestamp": 1664292578,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmp095up2vv.rs:12:20\n   |\n12 |   let max_count = 0\n   |                    ^ help: add `;` here\n13 |   let max_word = \"\"\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmp095up2vv.rs:13:20\n   |\n13 |   let max_word = \"\"\n   |                    ^ help: add `;` here\n14 |   for w in words {\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `if`\n  --> /tmp/tmp095up2vv.rs:15:38\n   |\n15 |     let count = count_unique_chars(w)\n   |                                      ^ help: add `;` here\n16 |     if count > max_count {\n   |     -- unexpected token\n\nerror: expected `;`, found `max_word`\n  --> /tmp/tmp095up2vv.rs:17:24\n   |\n17 |       max_count = count\n   |                        ^ help: add `;` here\n18 |       max_word = w\n   |       -------- unexpected token\n\nerror[E0425]: cannot find function `count_unique_chars` in this scope\n  --> /tmp/tmp095up2vv.rs:15:17\n   |\n15 |     let count = count_unique_chars(w)\n   |                 ^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp095up2vv.rs:18:18\n   |\n13 |   let max_word = \"\"\n   |                  -- expected due to this value\n...\n18 |       max_word = w\n   |                  ^\n   |                  |\n   |                  expected `&str`, found struct `String`\n   |                  help: consider borrowing here: `&w`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp095up2vv.rs:21:10\n   |\n11 | fn find_max(words: Vec<String>) -> String {\n   |                                    ------ expected `String` because of return type\n...\n21 |   return max_word\n   |          ^^^^^^^^- help: try using a conversion method: `.to_string()`\n   |          |\n   |          expected struct `String`, found `&str`\n\nerror: aborting due to 7 previous errors\n\nSome errors have detailed explanations: E0308, E0425.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function that accepts a vector of strings.\n/// The vector contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n  let max_count = 0\n  let max_word = \"\"\n  for w in words {\n    let count = count_unique_chars(w)\n    if count > max_count {\n      max_count = count\n      max_word = w\n    }\n  }\n  return max_word\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]), String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]), String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]), String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n}\n",
      "timestamp": 1664292578,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmp095up2vv.rs:12:20\n   |\n12 |   let max_count = 0\n   |                    ^ help: add `;` here\n13 |   let max_word = \"\"\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmp095up2vv.rs:13:20\n   |\n13 |   let max_word = \"\"\n   |                    ^ help: add `;` here\n14 |   for w in words {\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `if`\n  --> /tmp/tmp095up2vv.rs:15:38\n   |\n15 |     let count = count_unique_chars(w)\n   |                                      ^ help: add `;` here\n16 |     if count > max_count {\n   |     -- unexpected token\n\nerror: expected `;`, found `max_word`\n  --> /tmp/tmp095up2vv.rs:17:24\n   |\n17 |       max_count = count\n   |                        ^ help: add `;` here\n18 |       max_word = w\n   |       -------- unexpected token\n\nerror[E0425]: cannot find function `count_unique_chars` in this scope\n  --> /tmp/tmp095up2vv.rs:15:17\n   |\n15 |     let count = count_unique_chars(w)\n   |                 ^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp095up2vv.rs:18:18\n   |\n13 |   let max_word = \"\"\n   |                  -- expected due to this value\n...\n18 |       max_word = w\n   |                  ^\n   |                  |\n   |                  expected `&str`, found struct `String`\n   |                  help: consider borrowing here: `&w`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp095up2vv.rs:21:10\n   |\n11 | fn find_max(words: Vec<String>) -> String {\n   |                                    ------ expected `String` because of return type\n...\n21 |   return max_word\n   |          ^^^^^^^^- help: try using a conversion method: `.to_string()`\n   |          |\n   |          expected struct `String`, found `&str`\n\nerror: aborting due to 7 previous errors\n\nSome errors have detailed explanations: E0308, E0425.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function that accepts a vector of strings.\n/// The vector contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n  let max_count = 0\n  let max_word = \"\"\n\n  for w in words {\n    let count = w.count(/[a-z]/);\n    if count > max_count {\n      max_count = count\n      max_word = w\n    }\n  }\n\n  return max_word\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]), String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]), String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]), String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n}\n",
      "timestamp": 1664292578,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmpvii03icn.rs:12:20\n   |\n12 |   let max_count = 0\n   |                    ^ help: add `;` here\n13 |   let max_word = \"\"\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpvii03icn.rs:13:20\n   |\n13 |   let max_word = \"\"\n   |                    ^ help: add `;` here\n14 | \n15 |   for w in words {\n   |   --- unexpected token\n\nerror: expected expression, found `/`\n  --> /tmp/tmpvii03icn.rs:16:25\n   |\n16 |     let count = w.count(/[a-z]/);\n   |                         ^ expected expression\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpvii03icn.rs:23:10\n   |\n11 | fn find_max(words: Vec<String>) -> String {\n   |                                    ------ expected `String` because of return type\n...\n23 |   return max_word\n   |          ^^^^^^^^- help: try using a conversion method: `.to_string()`\n   |          |\n   |          expected struct `String`, found `&str`\n\nerror: aborting due to 4 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function that accepts a vector of strings.\n/// The vector contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n  let max_count = 0\n  let max_word = \"\"\n  for w in words {\n    let count = count_unique_chars(w)\n    if count > max_count {\n      max_count = count\n      max_word = w\n    }\n  }\n  return max_word\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]), String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]), String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]), String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n}\n",
      "timestamp": 1664292578,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmp095up2vv.rs:12:20\n   |\n12 |   let max_count = 0\n   |                    ^ help: add `;` here\n13 |   let max_word = \"\"\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmp095up2vv.rs:13:20\n   |\n13 |   let max_word = \"\"\n   |                    ^ help: add `;` here\n14 |   for w in words {\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `if`\n  --> /tmp/tmp095up2vv.rs:15:38\n   |\n15 |     let count = count_unique_chars(w)\n   |                                      ^ help: add `;` here\n16 |     if count > max_count {\n   |     -- unexpected token\n\nerror: expected `;`, found `max_word`\n  --> /tmp/tmp095up2vv.rs:17:24\n   |\n17 |       max_count = count\n   |                        ^ help: add `;` here\n18 |       max_word = w\n   |       -------- unexpected token\n\nerror[E0425]: cannot find function `count_unique_chars` in this scope\n  --> /tmp/tmp095up2vv.rs:15:17\n   |\n15 |     let count = count_unique_chars(w)\n   |                 ^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp095up2vv.rs:18:18\n   |\n13 |   let max_word = \"\"\n   |                  -- expected due to this value\n...\n18 |       max_word = w\n   |                  ^\n   |                  |\n   |                  expected `&str`, found struct `String`\n   |                  help: consider borrowing here: `&w`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp095up2vv.rs:21:10\n   |\n11 | fn find_max(words: Vec<String>) -> String {\n   |                                    ------ expected `String` because of return type\n...\n21 |   return max_word\n   |          ^^^^^^^^- help: try using a conversion method: `.to_string()`\n   |          |\n   |          expected struct `String`, found `&str`\n\nerror: aborting due to 7 previous errors\n\nSome errors have detailed explanations: E0308, E0425.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function that accepts a vector of strings.\n/// The vector contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n  let max_count = 0\n  let max_word = \"\"\n  for w in words {\n    let count = count_unique_chars(w)\n    if count > max_count {\n      max_count = count\n      max_word = w\n    }\n  }\n  return max_word\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]), String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]), String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]), String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n}\n",
      "timestamp": 1664292578,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmp095up2vv.rs:12:20\n   |\n12 |   let max_count = 0\n   |                    ^ help: add `;` here\n13 |   let max_word = \"\"\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmp095up2vv.rs:13:20\n   |\n13 |   let max_word = \"\"\n   |                    ^ help: add `;` here\n14 |   for w in words {\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `if`\n  --> /tmp/tmp095up2vv.rs:15:38\n   |\n15 |     let count = count_unique_chars(w)\n   |                                      ^ help: add `;` here\n16 |     if count > max_count {\n   |     -- unexpected token\n\nerror: expected `;`, found `max_word`\n  --> /tmp/tmp095up2vv.rs:17:24\n   |\n17 |       max_count = count\n   |                        ^ help: add `;` here\n18 |       max_word = w\n   |       -------- unexpected token\n\nerror[E0425]: cannot find function `count_unique_chars` in this scope\n  --> /tmp/tmp095up2vv.rs:15:17\n   |\n15 |     let count = count_unique_chars(w)\n   |                 ^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp095up2vv.rs:18:18\n   |\n13 |   let max_word = \"\"\n   |                  -- expected due to this value\n...\n18 |       max_word = w\n   |                  ^\n   |                  |\n   |                  expected `&str`, found struct `String`\n   |                  help: consider borrowing here: `&w`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp095up2vv.rs:21:10\n   |\n11 | fn find_max(words: Vec<String>) -> String {\n   |                                    ------ expected `String` because of return type\n...\n21 |   return max_word\n   |          ^^^^^^^^- help: try using a conversion method: `.to_string()`\n   |          |\n   |          expected struct `String`, found `&str`\n\nerror: aborting due to 7 previous errors\n\nSome errors have detailed explanations: E0308, E0425.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function that accepts a vector of strings.\n/// The vector contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n  let max_count = 0\n  let max_word = \"\"\n  for word in words {\n    let count = word.count(/[a-z]/)\n    if count > max_count {\n      max_count = count\n      max_word = word\n    }\n  }\n  return max_word\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]), String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]), String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]), String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n}\n",
      "timestamp": 1664292578,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmplz_du44f.rs:12:20\n   |\n12 |   let max_count = 0\n   |                    ^ help: add `;` here\n13 |   let max_word = \"\"\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmplz_du44f.rs:13:20\n   |\n13 |   let max_word = \"\"\n   |                    ^ help: add `;` here\n14 |   for word in words {\n   |   --- unexpected token\n\nerror: expected expression, found `/`\n  --> /tmp/tmplz_du44f.rs:15:28\n   |\n15 |     let count = word.count(/[a-z]/)\n   |                            ^ expected expression\n\nerror[E0308]: mismatched types\n  --> /tmp/tmplz_du44f.rs:21:10\n   |\n11 | fn find_max(words: Vec<String>) -> String {\n   |                                    ------ expected `String` because of return type\n...\n21 |   return max_word\n   |          ^^^^^^^^- help: try using a conversion method: `.to_string()`\n   |          |\n   |          expected struct `String`, found `&str`\n\nerror: aborting due to 4 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function that accepts a vector of strings.\n/// The vector contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n  let max_count = 0\n  let max_count_index = 0\n  let max_count_word = \"\"\n  for i in 0..words.len() {\n    let count = words[i].count_unique_chars()\n    if count > max_count {\n      max_count = count\n      max_count_index = i\n      max_count_word = words[i]\n    }\n  }\n  return max_count_word\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]), String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]), String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]), String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n}\n",
      "timestamp": 1664292578,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmp24evb004.rs:12:20\n   |\n12 |   let max_count = 0\n   |                    ^ help: add `;` here\n13 |   let max_count_index = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmp24evb004.rs:13:26\n   |\n13 |   let max_count_index = 0\n   |                          ^ help: add `;` here\n14 |   let max_count_word = \"\"\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmp24evb004.rs:14:26\n   |\n14 |   let max_count_word = \"\"\n   |                          ^ help: add `;` here\n15 |   for i in 0..words.len() {\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `if`\n  --> /tmp/tmp24evb004.rs:16:46\n   |\n16 |     let count = words[i].count_unique_chars()\n   |                                              ^ help: add `;` here\n17 |     if count > max_count {\n   |     -- unexpected token\n\nerror: expected `;`, found `max_count_index`\n  --> /tmp/tmp24evb004.rs:18:24\n   |\n18 |       max_count = count\n   |                        ^ help: add `;` here\n19 |       max_count_index = i\n   |       --------------- unexpected token\n\nerror: expected `;`, found `max_count_word`\n  --> /tmp/tmp24evb004.rs:19:26\n   |\n19 |       max_count_index = i\n   |                          ^ help: add `;` here\n20 |       max_count_word = words[i]\n   |       -------------- unexpected token\n\nerror[E0599]: no method named `count_unique_chars` found for struct `String` in the current scope\n  --> /tmp/tmp24evb004.rs:16:26\n   |\n16 |     let count = words[i].count_unique_chars()\n   |                          ^^^^^^^^^^^^^^^^^^ method not found in `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp24evb004.rs:20:24\n   |\n14 |   let max_count_word = \"\"\n   |                        -- expected due to this value\n...\n20 |       max_count_word = words[i]\n   |                        ^^^^^^^^\n   |                        |\n   |                        expected `&str`, found struct `String`\n   |                        help: consider borrowing here: `",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function that accepts a vector of strings.\n/// The vector contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n  let max_count = 0\n  let max_word = \"\"\n  for w in words {\n    let count = w.count(/[a-z]/);\n    if count > max_count {\n      max_count = count\n      max_word = w\n    }\n  }\n  return max_word\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]), String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]), String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]), String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n}\n",
      "timestamp": 1664292578,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmpk6mb5m3s.rs:12:20\n   |\n12 |   let max_count = 0\n   |                    ^ help: add `;` here\n13 |   let max_word = \"\"\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpk6mb5m3s.rs:13:20\n   |\n13 |   let max_word = \"\"\n   |                    ^ help: add `;` here\n14 |   for w in words {\n   |   --- unexpected token\n\nerror: expected expression, found `/`\n  --> /tmp/tmpk6mb5m3s.rs:15:25\n   |\n15 |     let count = w.count(/[a-z]/);\n   |                         ^ expected expression\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpk6mb5m3s.rs:21:10\n   |\n11 | fn find_max(words: Vec<String>) -> String {\n   |                                    ------ expected `String` because of return type\n...\n21 |   return max_word\n   |          ^^^^^^^^- help: try using a conversion method: `.to_string()`\n   |          |\n   |          expected struct `String`, found `&str`\n\nerror: aborting due to 4 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function that accepts a vector of strings.\n/// The vector contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n  let max_count = 0\n  let max_word = String::from(\"\")\n  for w in words {\n    let count = w.count_unique()\n    if count > max_count {\n      max_count = count\n      max_word = w\n    }\n  }\n  return max_word\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]), String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]), String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]), String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n}\n",
      "timestamp": 1664292578,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmp9oofn4eu.rs:12:20\n   |\n12 |   let max_count = 0\n   |                    ^ help: add `;` here\n13 |   let max_word = String::from(\"\")\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmp9oofn4eu.rs:13:34\n   |\n13 |   let max_word = String::from(\"\")\n   |                                  ^ help: add `;` here\n14 |   for w in words {\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `if`\n  --> /tmp/tmp9oofn4eu.rs:15:33\n   |\n15 |     let count = w.count_unique()\n   |                                 ^ help: add `;` here\n16 |     if count > max_count {\n   |     -- unexpected token\n\nerror: expected `;`, found `max_word`\n  --> /tmp/tmp9oofn4eu.rs:17:24\n   |\n17 |       max_count = count\n   |                        ^ help: add `;` here\n18 |       max_word = w\n   |       -------- unexpected token\n\nerror[E0599]: no method named `count_unique` found for struct `String` in the current scope\n  --> /tmp/tmp9oofn4eu.rs:15:19\n   |\n15 |     let count = w.count_unique()\n   |                   ^^^^^^^^^^^^ method not found in `String`\n\nerror: aborting due to 5 previous errors\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function that accepts a vector of strings.\n/// The vector contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n  let max_count = 0\n  let max_word = \"\"\n  for w in words {\n    let count = w.count(/[a-z]/)\n    if count > max_count {\n      max_count = count\n      max_word = w\n    }\n  }\n  return max_word\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]), String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]), String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]), String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n}\n",
      "timestamp": 1664292578,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmpjn5c1gme.rs:12:20\n   |\n12 |   let max_count = 0\n   |                    ^ help: add `;` here\n13 |   let max_word = \"\"\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpjn5c1gme.rs:13:20\n   |\n13 |   let max_word = \"\"\n   |                    ^ help: add `;` here\n14 |   for w in words {\n   |   --- unexpected token\n\nerror: expected expression, found `/`\n  --> /tmp/tmpjn5c1gme.rs:15:25\n   |\n15 |     let count = w.count(/[a-z]/)\n   |                         ^ expected expression\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpjn5c1gme.rs:21:10\n   |\n11 | fn find_max(words: Vec<String>) -> String {\n   |                                    ------ expected `String` because of return type\n...\n21 |   return max_word\n   |          ^^^^^^^^- help: try using a conversion method: `.to_string()`\n   |          |\n   |          expected struct `String`, found `&str`\n\nerror: aborting due to 4 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function that accepts a vector of strings.\n/// The vector contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n  let max_count = 0\n  let max_word = \"\"\n  for w in words {\n    let count = count_unique_chars(w)\n    if count > max_count {\n      max_count = count\n      max_word = w\n    }\n  }\n  return max_word\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]), String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]), String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]), String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n}\n",
      "timestamp": 1664292578,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmp095up2vv.rs:12:20\n   |\n12 |   let max_count = 0\n   |                    ^ help: add `;` here\n13 |   let max_word = \"\"\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmp095up2vv.rs:13:20\n   |\n13 |   let max_word = \"\"\n   |                    ^ help: add `;` here\n14 |   for w in words {\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `if`\n  --> /tmp/tmp095up2vv.rs:15:38\n   |\n15 |     let count = count_unique_chars(w)\n   |                                      ^ help: add `;` here\n16 |     if count > max_count {\n   |     -- unexpected token\n\nerror: expected `;`, found `max_word`\n  --> /tmp/tmp095up2vv.rs:17:24\n   |\n17 |       max_count = count\n   |                        ^ help: add `;` here\n18 |       max_word = w\n   |       -------- unexpected token\n\nerror[E0425]: cannot find function `count_unique_chars` in this scope\n  --> /tmp/tmp095up2vv.rs:15:17\n   |\n15 |     let count = count_unique_chars(w)\n   |                 ^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp095up2vv.rs:18:18\n   |\n13 |   let max_word = \"\"\n   |                  -- expected due to this value\n...\n18 |       max_word = w\n   |                  ^\n   |                  |\n   |                  expected `&str`, found struct `String`\n   |                  help: consider borrowing here: `&w`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp095up2vv.rs:21:10\n   |\n11 | fn find_max(words: Vec<String>) -> String {\n   |                                    ------ expected `String` because of return type\n...\n21 |   return max_word\n   |          ^^^^^^^^- help: try using a conversion method: `.to_string()`\n   |          |\n   |          expected struct `String`, found `&str`\n\nerror: aborting due to 7 previous errors\n\nSome errors have detailed explanations: E0308, E0425.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function that accepts a vector of strings.\n/// The vector contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n  let max_count = 0\n  let max_word = \"\"\n  for w in words {\n    let count = w.count_unique_chars()\n    if count > max_count {\n      max_count = count\n      max_word = w\n    }\n  }\n  return max_word\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]), String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]), String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]), String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n}\n",
      "timestamp": 1664292578,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmp83xgxfl_.rs:12:20\n   |\n12 |   let max_count = 0\n   |                    ^ help: add `;` here\n13 |   let max_word = \"\"\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmp83xgxfl_.rs:13:20\n   |\n13 |   let max_word = \"\"\n   |                    ^ help: add `;` here\n14 |   for w in words {\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `if`\n  --> /tmp/tmp83xgxfl_.rs:15:39\n   |\n15 |     let count = w.count_unique_chars()\n   |                                       ^ help: add `;` here\n16 |     if count > max_count {\n   |     -- unexpected token\n\nerror: expected `;`, found `max_word`\n  --> /tmp/tmp83xgxfl_.rs:17:24\n   |\n17 |       max_count = count\n   |                        ^ help: add `;` here\n18 |       max_word = w\n   |       -------- unexpected token\n\nerror[E0599]: no method named `count_unique_chars` found for struct `String` in the current scope\n  --> /tmp/tmp83xgxfl_.rs:15:19\n   |\n15 |     let count = w.count_unique_chars()\n   |                   ^^^^^^^^^^^^^^^^^^ method not found in `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp83xgxfl_.rs:18:18\n   |\n13 |   let max_word = \"\"\n   |                  -- expected due to this value\n...\n18 |       max_word = w\n   |                  ^\n   |                  |\n   |                  expected `&str`, found struct `String`\n   |                  help: consider borrowing here: `&w`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp83xgxfl_.rs:21:10\n   |\n11 | fn find_max(words: Vec<String>) -> String {\n   |                                    ------ expected `String` because of return type\n...\n21 |   return max_word\n   |          ^^^^^^^^- help: try using a conversion method: `.to_string()`\n   |          |\n   |          expected struct `String`, found `&str`\n\nerror: aborting due to 7 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function that accepts a vector of strings.\n/// The vector contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n  let max_count = 0\n  let max_word = \"\"\n  for w in words {\n    let count = count_unique_chars(w)\n    if count > max_count {\n      max_count = count\n      max_word = w\n    }\n  }\n  return max_word\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]), String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]), String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]), String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n}\n",
      "timestamp": 1664292578,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmp095up2vv.rs:12:20\n   |\n12 |   let max_count = 0\n   |                    ^ help: add `;` here\n13 |   let max_word = \"\"\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmp095up2vv.rs:13:20\n   |\n13 |   let max_word = \"\"\n   |                    ^ help: add `;` here\n14 |   for w in words {\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `if`\n  --> /tmp/tmp095up2vv.rs:15:38\n   |\n15 |     let count = count_unique_chars(w)\n   |                                      ^ help: add `;` here\n16 |     if count > max_count {\n   |     -- unexpected token\n\nerror: expected `;`, found `max_word`\n  --> /tmp/tmp095up2vv.rs:17:24\n   |\n17 |       max_count = count\n   |                        ^ help: add `;` here\n18 |       max_word = w\n   |       -------- unexpected token\n\nerror[E0425]: cannot find function `count_unique_chars` in this scope\n  --> /tmp/tmp095up2vv.rs:15:17\n   |\n15 |     let count = count_unique_chars(w)\n   |                 ^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp095up2vv.rs:18:18\n   |\n13 |   let max_word = \"\"\n   |                  -- expected due to this value\n...\n18 |       max_word = w\n   |                  ^\n   |                  |\n   |                  expected `&str`, found struct `String`\n   |                  help: consider borrowing here: `&w`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp095up2vv.rs:21:10\n   |\n11 | fn find_max(words: Vec<String>) -> String {\n   |                                    ------ expected `String` because of return type\n...\n21 |   return max_word\n   |          ^^^^^^^^- help: try using a conversion method: `.to_string()`\n   |          |\n   |          expected struct `String`, found `&str`\n\nerror: aborting due to 7 previous errors\n\nSome errors have detailed explanations: E0308, E0425.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function that accepts a vector of strings.\n/// The vector contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n  let max_count = 0\n  let max_word = \"\"\n  for w in words {\n    let count = count_unique_chars(w)\n    if count > max_count {\n      max_count = count\n      max_word = w\n    }\n  }\n  return max_word\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]), String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]), String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]), String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n}\n",
      "timestamp": 1664292578,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmp095up2vv.rs:12:20\n   |\n12 |   let max_count = 0\n   |                    ^ help: add `;` here\n13 |   let max_word = \"\"\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmp095up2vv.rs:13:20\n   |\n13 |   let max_word = \"\"\n   |                    ^ help: add `;` here\n14 |   for w in words {\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `if`\n  --> /tmp/tmp095up2vv.rs:15:38\n   |\n15 |     let count = count_unique_chars(w)\n   |                                      ^ help: add `;` here\n16 |     if count > max_count {\n   |     -- unexpected token\n\nerror: expected `;`, found `max_word`\n  --> /tmp/tmp095up2vv.rs:17:24\n   |\n17 |       max_count = count\n   |                        ^ help: add `;` here\n18 |       max_word = w\n   |       -------- unexpected token\n\nerror[E0425]: cannot find function `count_unique_chars` in this scope\n  --> /tmp/tmp095up2vv.rs:15:17\n   |\n15 |     let count = count_unique_chars(w)\n   |                 ^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp095up2vv.rs:18:18\n   |\n13 |   let max_word = \"\"\n   |                  -- expected due to this value\n...\n18 |       max_word = w\n   |                  ^\n   |                  |\n   |                  expected `&str`, found struct `String`\n   |                  help: consider borrowing here: `&w`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp095up2vv.rs:21:10\n   |\n11 | fn find_max(words: Vec<String>) -> String {\n   |                                    ------ expected `String` because of return type\n...\n21 |   return max_word\n   |          ^^^^^^^^- help: try using a conversion method: `.to_string()`\n   |          |\n   |          expected struct `String`, found `&str`\n\nerror: aborting due to 7 previous errors\n\nSome errors have detailed explanations: E0308, E0425.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function that accepts a vector of strings.\n/// The vector contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n  let max_count = 0\n  let max_word = \"\"\n  for w in words {\n    let count = w.count_unique()\n    if count > max_count {\n      max_count = count\n      max_word = w\n    }\n  }\n  return max_word\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]), String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]), String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]), String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n}\n",
      "timestamp": 1664292578,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmp5vp_ies0.rs:12:20\n   |\n12 |   let max_count = 0\n   |                    ^ help: add `;` here\n13 |   let max_word = \"\"\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmp5vp_ies0.rs:13:20\n   |\n13 |   let max_word = \"\"\n   |                    ^ help: add `;` here\n14 |   for w in words {\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `if`\n  --> /tmp/tmp5vp_ies0.rs:15:33\n   |\n15 |     let count = w.count_unique()\n   |                                 ^ help: add `;` here\n16 |     if count > max_count {\n   |     -- unexpected token\n\nerror: expected `;`, found `max_word`\n  --> /tmp/tmp5vp_ies0.rs:17:24\n   |\n17 |       max_count = count\n   |                        ^ help: add `;` here\n18 |       max_word = w\n   |       -------- unexpected token\n\nerror[E0599]: no method named `count_unique` found for struct `String` in the current scope\n  --> /tmp/tmp5vp_ies0.rs:15:19\n   |\n15 |     let count = w.count_unique()\n   |                   ^^^^^^^^^^^^ method not found in `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp5vp_ies0.rs:18:18\n   |\n13 |   let max_word = \"\"\n   |                  -- expected due to this value\n...\n18 |       max_word = w\n   |                  ^\n   |                  |\n   |                  expected `&str`, found struct `String`\n   |                  help: consider borrowing here: `&w`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp5vp_ies0.rs:21:10\n   |\n11 | fn find_max(words: Vec<String>) -> String {\n   |                                    ------ expected `String` because of return type\n...\n21 |   return max_word\n   |          ^^^^^^^^- help: try using a conversion method: `.to_string()`\n   |          |\n   |          expected struct `String`, found `&str`\n\nerror: aborting due to 7 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function that accepts a vector of strings.\n/// The vector contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n  let max_count = 0\n  let max_word = \"\"\n  for word in words {\n    let count = count_unique_chars(word)\n    if count > max_count {\n      max_count = count\n      max_word = word\n    }\n  }\n  return max_word\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]), String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]), String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]), String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n}\n",
      "timestamp": 1664292578,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmpblowsbak.rs:12:20\n   |\n12 |   let max_count = 0\n   |                    ^ help: add `;` here\n13 |   let max_word = \"\"\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpblowsbak.rs:13:20\n   |\n13 |   let max_word = \"\"\n   |                    ^ help: add `;` here\n14 |   for word in words {\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `if`\n  --> /tmp/tmpblowsbak.rs:15:41\n   |\n15 |     let count = count_unique_chars(word)\n   |                                         ^ help: add `;` here\n16 |     if count > max_count {\n   |     -- unexpected token\n\nerror: expected `;`, found `max_word`\n  --> /tmp/tmpblowsbak.rs:17:24\n   |\n17 |       max_count = count\n   |                        ^ help: add `;` here\n18 |       max_word = word\n   |       -------- unexpected token\n\nerror[E0425]: cannot find function `count_unique_chars` in this scope\n  --> /tmp/tmpblowsbak.rs:15:17\n   |\n15 |     let count = count_unique_chars(word)\n   |                 ^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpblowsbak.rs:18:18\n   |\n13 |   let max_word = \"\"\n   |                  -- expected due to this value\n...\n18 |       max_word = word\n   |                  ^^^^\n   |                  |\n   |                  expected `&str`, found struct `String`\n   |                  help: consider borrowing here: `&word`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpblowsbak.rs:21:10\n   |\n11 | fn find_max(words: Vec<String>) -> String {\n   |                                    ------ expected `String` because of return type\n...\n21 |   return max_word\n   |          ^^^^^^^^- help: try using a conversion method: `.to_string()`\n   |          |\n   |          expected struct `String`, found `&str`\n\nerror: aborting due to 7 previous errors\n\nSome errors have detailed explanations: E0308, E0425.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function that accepts a vector of strings.\n/// The vector contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n  let max_count = 0\n  let max_word = String::from(\"\")\n  for w in words {\n    let count = w.count_unique()\n    if count > max_count {\n      max_count = count\n      max_word = w\n    }\n  }\n  return max_word\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]), String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]), String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]), String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n}\n",
      "timestamp": 1664292578,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmp9oofn4eu.rs:12:20\n   |\n12 |   let max_count = 0\n   |                    ^ help: add `;` here\n13 |   let max_word = String::from(\"\")\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmp9oofn4eu.rs:13:34\n   |\n13 |   let max_word = String::from(\"\")\n   |                                  ^ help: add `;` here\n14 |   for w in words {\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `if`\n  --> /tmp/tmp9oofn4eu.rs:15:33\n   |\n15 |     let count = w.count_unique()\n   |                                 ^ help: add `;` here\n16 |     if count > max_count {\n   |     -- unexpected token\n\nerror: expected `;`, found `max_word`\n  --> /tmp/tmp9oofn4eu.rs:17:24\n   |\n17 |       max_count = count\n   |                        ^ help: add `;` here\n18 |       max_word = w\n   |       -------- unexpected token\n\nerror[E0599]: no method named `count_unique` found for struct `String` in the current scope\n  --> /tmp/tmp9oofn4eu.rs:15:19\n   |\n15 |     let count = w.count_unique()\n   |                   ^^^^^^^^^^^^ method not found in `String`\n\nerror: aborting due to 5 previous errors\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function that accepts a vector of strings.\n/// The vector contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n  let max_count = 0\n  let max_word = \"\"\n  for w in words {\n    let count = count_unique_chars(w)\n    if count > max_count {\n      max_count = count\n      max_word = w\n    }\n  }\n  return max_word\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]), String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]), String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]), String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n}\n",
      "timestamp": 1664292578,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmp095up2vv.rs:12:20\n   |\n12 |   let max_count = 0\n   |                    ^ help: add `;` here\n13 |   let max_word = \"\"\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmp095up2vv.rs:13:20\n   |\n13 |   let max_word = \"\"\n   |                    ^ help: add `;` here\n14 |   for w in words {\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `if`\n  --> /tmp/tmp095up2vv.rs:15:38\n   |\n15 |     let count = count_unique_chars(w)\n   |                                      ^ help: add `;` here\n16 |     if count > max_count {\n   |     -- unexpected token\n\nerror: expected `;`, found `max_word`\n  --> /tmp/tmp095up2vv.rs:17:24\n   |\n17 |       max_count = count\n   |                        ^ help: add `;` here\n18 |       max_word = w\n   |       -------- unexpected token\n\nerror[E0425]: cannot find function `count_unique_chars` in this scope\n  --> /tmp/tmp095up2vv.rs:15:17\n   |\n15 |     let count = count_unique_chars(w)\n   |                 ^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp095up2vv.rs:18:18\n   |\n13 |   let max_word = \"\"\n   |                  -- expected due to this value\n...\n18 |       max_word = w\n   |                  ^\n   |                  |\n   |                  expected `&str`, found struct `String`\n   |                  help: consider borrowing here: `&w`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp095up2vv.rs:21:10\n   |\n11 | fn find_max(words: Vec<String>) -> String {\n   |                                    ------ expected `String` because of return type\n...\n21 |   return max_word\n   |          ^^^^^^^^- help: try using a conversion method: `.to_string()`\n   |          |\n   |          expected struct `String`, found `&str`\n\nerror: aborting due to 7 previous errors\n\nSome errors have detailed explanations: E0308, E0425.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function that accepts a vector of strings.\n/// The vector contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n  let max_count = 0\n  let max_word = \"\"\n  for w in words {\n    let count = count_unique_chars(w)\n    if count > max_count {\n      max_count = count\n      max_word = w\n    }\n  }\n  return max_word\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]), String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]), String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]), String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n}\n",
      "timestamp": 1664292578,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmp095up2vv.rs:12:20\n   |\n12 |   let max_count = 0\n   |                    ^ help: add `;` here\n13 |   let max_word = \"\"\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmp095up2vv.rs:13:20\n   |\n13 |   let max_word = \"\"\n   |                    ^ help: add `;` here\n14 |   for w in words {\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `if`\n  --> /tmp/tmp095up2vv.rs:15:38\n   |\n15 |     let count = count_unique_chars(w)\n   |                                      ^ help: add `;` here\n16 |     if count > max_count {\n   |     -- unexpected token\n\nerror: expected `;`, found `max_word`\n  --> /tmp/tmp095up2vv.rs:17:24\n   |\n17 |       max_count = count\n   |                        ^ help: add `;` here\n18 |       max_word = w\n   |       -------- unexpected token\n\nerror[E0425]: cannot find function `count_unique_chars` in this scope\n  --> /tmp/tmp095up2vv.rs:15:17\n   |\n15 |     let count = count_unique_chars(w)\n   |                 ^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp095up2vv.rs:18:18\n   |\n13 |   let max_word = \"\"\n   |                  -- expected due to this value\n...\n18 |       max_word = w\n   |                  ^\n   |                  |\n   |                  expected `&str`, found struct `String`\n   |                  help: consider borrowing here: `&w`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp095up2vv.rs:21:10\n   |\n11 | fn find_max(words: Vec<String>) -> String {\n   |                                    ------ expected `String` because of return type\n...\n21 |   return max_word\n   |          ^^^^^^^^- help: try using a conversion method: `.to_string()`\n   |          |\n   |          expected struct `String`, found `&str`\n\nerror: aborting due to 7 previous errors\n\nSome errors have detailed explanations: E0308, E0425.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function that accepts a vector of strings.\n/// The vector contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n  let max_count = 0\n  let max_word = \"\"\n  for w in words {\n    let count = w.count(/[a-z]/);\n    if count > max_count {\n      max_count = count\n      max_word = w\n    }\n  }\n  return max_word\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]), String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]), String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]), String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n}\n",
      "timestamp": 1664292578,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmpk6mb5m3s.rs:12:20\n   |\n12 |   let max_count = 0\n   |                    ^ help: add `;` here\n13 |   let max_word = \"\"\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpk6mb5m3s.rs:13:20\n   |\n13 |   let max_word = \"\"\n   |                    ^ help: add `;` here\n14 |   for w in words {\n   |   --- unexpected token\n\nerror: expected expression, found `/`\n  --> /tmp/tmpk6mb5m3s.rs:15:25\n   |\n15 |     let count = w.count(/[a-z]/);\n   |                         ^ expected expression\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpk6mb5m3s.rs:21:10\n   |\n11 | fn find_max(words: Vec<String>) -> String {\n   |                                    ------ expected `String` because of return type\n...\n21 |   return max_word\n   |          ^^^^^^^^- help: try using a conversion method: `.to_string()`\n   |          |\n   |          expected struct `String`, found `&str`\n\nerror: aborting due to 4 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function that accepts a vector of strings.\n/// The vector contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n  let max_count = 0\n  let max_count_index = 0\n  for i in 0..words.len() {\n    let count = words[i].count()\n    if count > max_count {\n      max_count = count\n      max_count_index = i\n    }\n  }\n  return words[max_count_index]\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]), String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]), String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]), String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n}\n",
      "timestamp": 1664292578,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmpk4r110a1.rs:12:20\n   |\n12 |   let max_count = 0\n   |                    ^ help: add `;` here\n13 |   let max_count_index = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpk4r110a1.rs:13:26\n   |\n13 |   let max_count_index = 0\n   |                          ^ help: add `;` here\n14 |   for i in 0..words.len() {\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `if`\n  --> /tmp/tmpk4r110a1.rs:15:33\n   |\n15 |     let count = words[i].count()\n   |                                 ^ help: add `;` here\n16 |     if count > max_count {\n   |     -- unexpected token\n\nerror: expected `;`, found `max_count_index`\n  --> /tmp/tmpk4r110a1.rs:17:24\n   |\n17 |       max_count = count\n   |                        ^ help: add `;` here\n18 |       max_count_index = i\n   |       --------------- unexpected token\n\nerror[E0599]: `String` is not an iterator\n   --> /tmp/tmpk4r110a1.rs:15:26\n    |\n15  |       let count = words[i].count()\n    |                            ^^^^^ `String` is not an iterator; try calling `.chars()` or `.bytes()`\n    |\n    = note: the following trait bounds were not satisfied:\n            `String: Iterator`\n            which is required by `&mut String: Iterator`\n            `str: Iterator`\n            which is required by `&mut str: Iterator`\n\nerror: aborting due to 5 previous errors\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function that accepts a vector of strings.\n/// The vector contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n  let max_count = 0\n  let max_word = \"\"\n  for word in words {\n    let count = count_unique_chars(word)\n    if count > max_count {\n      max_count = count\n      max_word = word\n    }\n  }\n  return max_word\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]), String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]), String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]), String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n}\n",
      "timestamp": 1664292578,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmpblowsbak.rs:12:20\n   |\n12 |   let max_count = 0\n   |                    ^ help: add `;` here\n13 |   let max_word = \"\"\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpblowsbak.rs:13:20\n   |\n13 |   let max_word = \"\"\n   |                    ^ help: add `;` here\n14 |   for word in words {\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `if`\n  --> /tmp/tmpblowsbak.rs:15:41\n   |\n15 |     let count = count_unique_chars(word)\n   |                                         ^ help: add `;` here\n16 |     if count > max_count {\n   |     -- unexpected token\n\nerror: expected `;`, found `max_word`\n  --> /tmp/tmpblowsbak.rs:17:24\n   |\n17 |       max_count = count\n   |                        ^ help: add `;` here\n18 |       max_word = word\n   |       -------- unexpected token\n\nerror[E0425]: cannot find function `count_unique_chars` in this scope\n  --> /tmp/tmpblowsbak.rs:15:17\n   |\n15 |     let count = count_unique_chars(word)\n   |                 ^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpblowsbak.rs:18:18\n   |\n13 |   let max_word = \"\"\n   |                  -- expected due to this value\n...\n18 |       max_word = word\n   |                  ^^^^\n   |                  |\n   |                  expected `&str`, found struct `String`\n   |                  help: consider borrowing here: `&word`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpblowsbak.rs:21:10\n   |\n11 | fn find_max(words: Vec<String>) -> String {\n   |                                    ------ expected `String` because of return type\n...\n21 |   return max_word\n   |          ^^^^^^^^- help: try using a conversion method: `.to_string()`\n   |          |\n   |          expected struct `String`, found `&str`\n\nerror: aborting due to 7 previous errors\n\nSome errors have detailed explanations: E0308, E0425.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function that accepts a vector of strings.\n/// The vector contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n  let max_count = 0\n  let max_word = \"\"\n  for w in words {\n    let count = count_unique_chars(w)\n    if count > max_count {\n      max_count = count\n      max_word = w\n    }\n  }\n  return max_word\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]), String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]), String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]), String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n}\n",
      "timestamp": 1664292578,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmp095up2vv.rs:12:20\n   |\n12 |   let max_count = 0\n   |                    ^ help: add `;` here\n13 |   let max_word = \"\"\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmp095up2vv.rs:13:20\n   |\n13 |   let max_word = \"\"\n   |                    ^ help: add `;` here\n14 |   for w in words {\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `if`\n  --> /tmp/tmp095up2vv.rs:15:38\n   |\n15 |     let count = count_unique_chars(w)\n   |                                      ^ help: add `;` here\n16 |     if count > max_count {\n   |     -- unexpected token\n\nerror: expected `;`, found `max_word`\n  --> /tmp/tmp095up2vv.rs:17:24\n   |\n17 |       max_count = count\n   |                        ^ help: add `;` here\n18 |       max_word = w\n   |       -------- unexpected token\n\nerror[E0425]: cannot find function `count_unique_chars` in this scope\n  --> /tmp/tmp095up2vv.rs:15:17\n   |\n15 |     let count = count_unique_chars(w)\n   |                 ^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp095up2vv.rs:18:18\n   |\n13 |   let max_word = \"\"\n   |                  -- expected due to this value\n...\n18 |       max_word = w\n   |                  ^\n   |                  |\n   |                  expected `&str`, found struct `String`\n   |                  help: consider borrowing here: `&w`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp095up2vv.rs:21:10\n   |\n11 | fn find_max(words: Vec<String>) -> String {\n   |                                    ------ expected `String` because of return type\n...\n21 |   return max_word\n   |          ^^^^^^^^- help: try using a conversion method: `.to_string()`\n   |          |\n   |          expected struct `String`, found `&str`\n\nerror: aborting due to 7 previous errors\n\nSome errors have detailed explanations: E0308, E0425.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function that accepts a vector of strings.\n/// The vector contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n  let max_count = 0\n  let max_word = \"\"\n  for w in words {\n    let count = count_unique_chars(w)\n    if count > max_count {\n      max_count = count\n      max_word = w\n    }\n  }\n  return max_word\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]), String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]), String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]), String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n}\n",
      "timestamp": 1664292578,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmp095up2vv.rs:12:20\n   |\n12 |   let max_count = 0\n   |                    ^ help: add `;` here\n13 |   let max_word = \"\"\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmp095up2vv.rs:13:20\n   |\n13 |   let max_word = \"\"\n   |                    ^ help: add `;` here\n14 |   for w in words {\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `if`\n  --> /tmp/tmp095up2vv.rs:15:38\n   |\n15 |     let count = count_unique_chars(w)\n   |                                      ^ help: add `;` here\n16 |     if count > max_count {\n   |     -- unexpected token\n\nerror: expected `;`, found `max_word`\n  --> /tmp/tmp095up2vv.rs:17:24\n   |\n17 |       max_count = count\n   |                        ^ help: add `;` here\n18 |       max_word = w\n   |       -------- unexpected token\n\nerror[E0425]: cannot find function `count_unique_chars` in this scope\n  --> /tmp/tmp095up2vv.rs:15:17\n   |\n15 |     let count = count_unique_chars(w)\n   |                 ^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp095up2vv.rs:18:18\n   |\n13 |   let max_word = \"\"\n   |                  -- expected due to this value\n...\n18 |       max_word = w\n   |                  ^\n   |                  |\n   |                  expected `&str`, found struct `String`\n   |                  help: consider borrowing here: `&w`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp095up2vv.rs:21:10\n   |\n11 | fn find_max(words: Vec<String>) -> String {\n   |                                    ------ expected `String` because of return type\n...\n21 |   return max_word\n   |          ^^^^^^^^- help: try using a conversion method: `.to_string()`\n   |          |\n   |          expected struct `String`, found `&str`\n\nerror: aborting due to 7 previous errors\n\nSome errors have detailed explanations: E0308, E0425.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function that accepts a vector of strings.\n/// The vector contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n  let max_count = 0\n  let max_word = \"\"\n  for w in words {\n    let count = count_unique_chars(w)\n    if count > max_count {\n      max_count = count\n      max_word = w\n    }\n  }\n  return max_word\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]), String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]), String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]), String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n}\n",
      "timestamp": 1664292578,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmp095up2vv.rs:12:20\n   |\n12 |   let max_count = 0\n   |                    ^ help: add `;` here\n13 |   let max_word = \"\"\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmp095up2vv.rs:13:20\n   |\n13 |   let max_word = \"\"\n   |                    ^ help: add `;` here\n14 |   for w in words {\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `if`\n  --> /tmp/tmp095up2vv.rs:15:38\n   |\n15 |     let count = count_unique_chars(w)\n   |                                      ^ help: add `;` here\n16 |     if count > max_count {\n   |     -- unexpected token\n\nerror: expected `;`, found `max_word`\n  --> /tmp/tmp095up2vv.rs:17:24\n   |\n17 |       max_count = count\n   |                        ^ help: add `;` here\n18 |       max_word = w\n   |       -------- unexpected token\n\nerror[E0425]: cannot find function `count_unique_chars` in this scope\n  --> /tmp/tmp095up2vv.rs:15:17\n   |\n15 |     let count = count_unique_chars(w)\n   |                 ^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp095up2vv.rs:18:18\n   |\n13 |   let max_word = \"\"\n   |                  -- expected due to this value\n...\n18 |       max_word = w\n   |                  ^\n   |                  |\n   |                  expected `&str`, found struct `String`\n   |                  help: consider borrowing here: `&w`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp095up2vv.rs:21:10\n   |\n11 | fn find_max(words: Vec<String>) -> String {\n   |                                    ------ expected `String` because of return type\n...\n21 |   return max_word\n   |          ^^^^^^^^- help: try using a conversion method: `.to_string()`\n   |          |\n   |          expected struct `String`, found `&str`\n\nerror: aborting due to 7 previous errors\n\nSome errors have detailed explanations: E0308, E0425.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function that accepts a vector of strings.\n/// The vector contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n  let max_count = 0\n  let max_word = \"\"\n  for w in words {\n    let count = count_unique_chars(w)\n    if count > max_count {\n      max_count = count\n      max_word = w\n    }\n  }\n  return max_word\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]), String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]), String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]), String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n}\n",
      "timestamp": 1664292578,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmp095up2vv.rs:12:20\n   |\n12 |   let max_count = 0\n   |                    ^ help: add `;` here\n13 |   let max_word = \"\"\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmp095up2vv.rs:13:20\n   |\n13 |   let max_word = \"\"\n   |                    ^ help: add `;` here\n14 |   for w in words {\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `if`\n  --> /tmp/tmp095up2vv.rs:15:38\n   |\n15 |     let count = count_unique_chars(w)\n   |                                      ^ help: add `;` here\n16 |     if count > max_count {\n   |     -- unexpected token\n\nerror: expected `;`, found `max_word`\n  --> /tmp/tmp095up2vv.rs:17:24\n   |\n17 |       max_count = count\n   |                        ^ help: add `;` here\n18 |       max_word = w\n   |       -------- unexpected token\n\nerror[E0425]: cannot find function `count_unique_chars` in this scope\n  --> /tmp/tmp095up2vv.rs:15:17\n   |\n15 |     let count = count_unique_chars(w)\n   |                 ^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp095up2vv.rs:18:18\n   |\n13 |   let max_word = \"\"\n   |                  -- expected due to this value\n...\n18 |       max_word = w\n   |                  ^\n   |                  |\n   |                  expected `&str`, found struct `String`\n   |                  help: consider borrowing here: `&w`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp095up2vv.rs:21:10\n   |\n11 | fn find_max(words: Vec<String>) -> String {\n   |                                    ------ expected `String` because of return type\n...\n21 |   return max_word\n   |          ^^^^^^^^- help: try using a conversion method: `.to_string()`\n   |          |\n   |          expected struct `String`, found `&str`\n\nerror: aborting due to 7 previous errors\n\nSome errors have detailed explanations: E0308, E0425.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function that accepts a vector of strings.\n/// The vector contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n  let max_count = 0\n  let max_word = String::from(\"\")\n  for word in words {\n    let count = count_unique_chars(word)\n    if count > max_count {\n      max_count = count\n      max_word = word\n    }\n  }\n  return max_word\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]), String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]), String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]), String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n}\n",
      "timestamp": 1664292578,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmpxpe2iddk.rs:12:20\n   |\n12 |   let max_count = 0\n   |                    ^ help: add `;` here\n13 |   let max_word = String::from(\"\")\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpxpe2iddk.rs:13:34\n   |\n13 |   let max_word = String::from(\"\")\n   |                                  ^ help: add `;` here\n14 |   for word in words {\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `if`\n  --> /tmp/tmpxpe2iddk.rs:15:41\n   |\n15 |     let count = count_unique_chars(word)\n   |                                         ^ help: add `;` here\n16 |     if count > max_count {\n   |     -- unexpected token\n\nerror: expected `;`, found `max_word`\n  --> /tmp/tmpxpe2iddk.rs:17:24\n   |\n17 |       max_count = count\n   |                        ^ help: add `;` here\n18 |       max_word = word\n   |       -------- unexpected token\n\nerror[E0425]: cannot find function `count_unique_chars` in this scope\n  --> /tmp/tmpxpe2iddk.rs:15:17\n   |\n15 |     let count = count_unique_chars(word)\n   |                 ^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to 5 previous errors\n\nFor more information about this error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function that accepts a vector of strings.\n/// The vector contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n  let max_count = 0\n  let max_word = \"\"\n  for w in words {\n    let count = w.count_unique_chars()\n    if count > max_count {\n      max_count = count\n      max_word = w\n    }\n  }\n  return max_word\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]), String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]), String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]), String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n}\n",
      "timestamp": 1664292578,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmp83xgxfl_.rs:12:20\n   |\n12 |   let max_count = 0\n   |                    ^ help: add `;` here\n13 |   let max_word = \"\"\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmp83xgxfl_.rs:13:20\n   |\n13 |   let max_word = \"\"\n   |                    ^ help: add `;` here\n14 |   for w in words {\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `if`\n  --> /tmp/tmp83xgxfl_.rs:15:39\n   |\n15 |     let count = w.count_unique_chars()\n   |                                       ^ help: add `;` here\n16 |     if count > max_count {\n   |     -- unexpected token\n\nerror: expected `;`, found `max_word`\n  --> /tmp/tmp83xgxfl_.rs:17:24\n   |\n17 |       max_count = count\n   |                        ^ help: add `;` here\n18 |       max_word = w\n   |       -------- unexpected token\n\nerror[E0599]: no method named `count_unique_chars` found for struct `String` in the current scope\n  --> /tmp/tmp83xgxfl_.rs:15:19\n   |\n15 |     let count = w.count_unique_chars()\n   |                   ^^^^^^^^^^^^^^^^^^ method not found in `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp83xgxfl_.rs:18:18\n   |\n13 |   let max_word = \"\"\n   |                  -- expected due to this value\n...\n18 |       max_word = w\n   |                  ^\n   |                  |\n   |                  expected `&str`, found struct `String`\n   |                  help: consider borrowing here: `&w`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp83xgxfl_.rs:21:10\n   |\n11 | fn find_max(words: Vec<String>) -> String {\n   |                                    ------ expected `String` because of return type\n...\n21 |   return max_word\n   |          ^^^^^^^^- help: try using a conversion method: `.to_string()`\n   |          |\n   |          expected struct `String`, found `&str`\n\nerror: aborting due to 7 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function that accepts a vector of strings.\n/// The vector contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n  let max_count = 0\n  let max_word = \"\"\n  for w in words {\n    let count = w.count(/[a-z]/);\n    if count > max_count {\n      max_count = count\n      max_word = w\n    }\n  }\n  return max_word\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]), String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]), String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]), String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n}\n",
      "timestamp": 1664292578,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmpk6mb5m3s.rs:12:20\n   |\n12 |   let max_count = 0\n   |                    ^ help: add `;` here\n13 |   let max_word = \"\"\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpk6mb5m3s.rs:13:20\n   |\n13 |   let max_word = \"\"\n   |                    ^ help: add `;` here\n14 |   for w in words {\n   |   --- unexpected token\n\nerror: expected expression, found `/`\n  --> /tmp/tmpk6mb5m3s.rs:15:25\n   |\n15 |     let count = w.count(/[a-z]/);\n   |                         ^ expected expression\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpk6mb5m3s.rs:21:10\n   |\n11 | fn find_max(words: Vec<String>) -> String {\n   |                                    ------ expected `String` because of return type\n...\n21 |   return max_word\n   |          ^^^^^^^^- help: try using a conversion method: `.to_string()`\n   |          |\n   |          expected struct `String`, found `&str`\n\nerror: aborting due to 4 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function that accepts a vector of strings.\n/// The vector contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n  let max_count = 0\n  let max_word = \"\"\n  for w in words {\n    let count = w.count(/[a-z]/)\n    if count > max_count {\n      max_count = count\n      max_word = w\n    }\n  }\n  return max_word\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]), String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]), String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]), String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n}\n",
      "timestamp": 1664292578,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmpjn5c1gme.rs:12:20\n   |\n12 |   let max_count = 0\n   |                    ^ help: add `;` here\n13 |   let max_word = \"\"\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpjn5c1gme.rs:13:20\n   |\n13 |   let max_word = \"\"\n   |                    ^ help: add `;` here\n14 |   for w in words {\n   |   --- unexpected token\n\nerror: expected expression, found `/`\n  --> /tmp/tmpjn5c1gme.rs:15:25\n   |\n15 |     let count = w.count(/[a-z]/)\n   |                         ^ expected expression\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpjn5c1gme.rs:21:10\n   |\n11 | fn find_max(words: Vec<String>) -> String {\n   |                                    ------ expected `String` because of return type\n...\n21 |   return max_word\n   |          ^^^^^^^^- help: try using a conversion method: `.to_string()`\n   |          |\n   |          expected struct `String`, found `&str`\n\nerror: aborting due to 4 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function that accepts a vector of strings.\n/// The vector contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n  let max_count = 0\n  let max_word = String::from(\"\")\n  for w in words {\n    let count = w.count_of_unique_chars()\n    if count > max_count {\n      max_count = count\n      max_word = w\n    }\n  }\n  return max_word\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]), String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]), String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]), String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n}\n",
      "timestamp": 1664292578,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmpo_pbdexl.rs:12:20\n   |\n12 |   let max_count = 0\n   |                    ^ help: add `;` here\n13 |   let max_word = String::from(\"\")\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpo_pbdexl.rs:13:34\n   |\n13 |   let max_word = String::from(\"\")\n   |                                  ^ help: add `;` here\n14 |   for w in words {\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `if`\n  --> /tmp/tmpo_pbdexl.rs:15:42\n   |\n15 |     let count = w.count_of_unique_chars()\n   |                                          ^ help: add `;` here\n16 |     if count > max_count {\n   |     -- unexpected token\n\nerror: expected `;`, found `max_word`\n  --> /tmp/tmpo_pbdexl.rs:17:24\n   |\n17 |       max_count = count\n   |                        ^ help: add `;` here\n18 |       max_word = w\n   |       -------- unexpected token\n\nerror[E0599]: no method named `count_of_unique_chars` found for struct `String` in the current scope\n  --> /tmp/tmpo_pbdexl.rs:15:19\n   |\n15 |     let count = w.count_of_unique_chars()\n   |                   ^^^^^^^^^^^^^^^^^^^^^ method not found in `String`\n\nerror: aborting due to 5 previous errors\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function that accepts a vector of strings.\n/// The vector contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n  let max_count = 0\n  let max_word = \"\"\n  for w in words {\n    let count = count_unique_chars(w)\n    if count > max_count {\n      max_count = count\n      max_word = w\n    }\n  }\n  return max_word\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]), String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]), String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]), String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n}\n",
      "timestamp": 1664292578,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmp095up2vv.rs:12:20\n   |\n12 |   let max_count = 0\n   |                    ^ help: add `;` here\n13 |   let max_word = \"\"\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmp095up2vv.rs:13:20\n   |\n13 |   let max_word = \"\"\n   |                    ^ help: add `;` here\n14 |   for w in words {\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `if`\n  --> /tmp/tmp095up2vv.rs:15:38\n   |\n15 |     let count = count_unique_chars(w)\n   |                                      ^ help: add `;` here\n16 |     if count > max_count {\n   |     -- unexpected token\n\nerror: expected `;`, found `max_word`\n  --> /tmp/tmp095up2vv.rs:17:24\n   |\n17 |       max_count = count\n   |                        ^ help: add `;` here\n18 |       max_word = w\n   |       -------- unexpected token\n\nerror[E0425]: cannot find function `count_unique_chars` in this scope\n  --> /tmp/tmp095up2vv.rs:15:17\n   |\n15 |     let count = count_unique_chars(w)\n   |                 ^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp095up2vv.rs:18:18\n   |\n13 |   let max_word = \"\"\n   |                  -- expected due to this value\n...\n18 |       max_word = w\n   |                  ^\n   |                  |\n   |                  expected `&str`, found struct `String`\n   |                  help: consider borrowing here: `&w`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp095up2vv.rs:21:10\n   |\n11 | fn find_max(words: Vec<String>) -> String {\n   |                                    ------ expected `String` because of return type\n...\n21 |   return max_word\n   |          ^^^^^^^^- help: try using a conversion method: `.to_string()`\n   |          |\n   |          expected struct `String`, found `&str`\n\nerror: aborting due to 7 previous errors\n\nSome errors have detailed explanations: E0308, E0425.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function that accepts a vector of strings.\n/// The vector contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n  let max_count = 0\n  let max_word = \"\"\n  for w in words {\n    let count = w.count(/[a-z]/);\n    if count > max_count {\n      max_count = count\n      max_word = w\n    }\n  }\n  return max_word\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]), String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]), String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]), String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n}\n",
      "timestamp": 1664292578,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmpk6mb5m3s.rs:12:20\n   |\n12 |   let max_count = 0\n   |                    ^ help: add `;` here\n13 |   let max_word = \"\"\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpk6mb5m3s.rs:13:20\n   |\n13 |   let max_word = \"\"\n   |                    ^ help: add `;` here\n14 |   for w in words {\n   |   --- unexpected token\n\nerror: expected expression, found `/`\n  --> /tmp/tmpk6mb5m3s.rs:15:25\n   |\n15 |     let count = w.count(/[a-z]/);\n   |                         ^ expected expression\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpk6mb5m3s.rs:21:10\n   |\n11 | fn find_max(words: Vec<String>) -> String {\n   |                                    ------ expected `String` because of return type\n...\n21 |   return max_word\n   |          ^^^^^^^^- help: try using a conversion method: `.to_string()`\n   |          |\n   |          expected struct `String`, found `&str`\n\nerror: aborting due to 4 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function that accepts a vector of strings.\n/// The vector contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n  let max_count = 0\n  let max_word = \"\"\n  for word in words {\n    let count = count_unique_chars(word)\n    if count > max_count {\n      max_count = count\n      max_word = word\n    }\n  }\n  return max_word\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]), String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]), String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]), String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n}\n",
      "timestamp": 1664292578,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmpblowsbak.rs:12:20\n   |\n12 |   let max_count = 0\n   |                    ^ help: add `;` here\n13 |   let max_word = \"\"\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpblowsbak.rs:13:20\n   |\n13 |   let max_word = \"\"\n   |                    ^ help: add `;` here\n14 |   for word in words {\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `if`\n  --> /tmp/tmpblowsbak.rs:15:41\n   |\n15 |     let count = count_unique_chars(word)\n   |                                         ^ help: add `;` here\n16 |     if count > max_count {\n   |     -- unexpected token\n\nerror: expected `;`, found `max_word`\n  --> /tmp/tmpblowsbak.rs:17:24\n   |\n17 |       max_count = count\n   |                        ^ help: add `;` here\n18 |       max_word = word\n   |       -------- unexpected token\n\nerror[E0425]: cannot find function `count_unique_chars` in this scope\n  --> /tmp/tmpblowsbak.rs:15:17\n   |\n15 |     let count = count_unique_chars(word)\n   |                 ^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpblowsbak.rs:18:18\n   |\n13 |   let max_word = \"\"\n   |                  -- expected due to this value\n...\n18 |       max_word = word\n   |                  ^^^^\n   |                  |\n   |                  expected `&str`, found struct `String`\n   |                  help: consider borrowing here: `&word`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpblowsbak.rs:21:10\n   |\n11 | fn find_max(words: Vec<String>) -> String {\n   |                                    ------ expected `String` because of return type\n...\n21 |   return max_word\n   |          ^^^^^^^^- help: try using a conversion method: `.to_string()`\n   |          |\n   |          expected struct `String`, found `&str`\n\nerror: aborting due to 7 previous errors\n\nSome errors have detailed explanations: E0308, E0425.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function that accepts a vector of strings.\n/// The vector contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n  let max_count = 0\n  let max_word = \"\"\n  for w in words {\n    let count = w.count_unique_chars()\n    if count > max_count {\n      max_count = count\n      max_word = w\n    }\n  }\n  return max_word\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]), String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]), String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]), String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n}\n",
      "timestamp": 1664292578,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmp83xgxfl_.rs:12:20\n   |\n12 |   let max_count = 0\n   |                    ^ help: add `;` here\n13 |   let max_word = \"\"\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmp83xgxfl_.rs:13:20\n   |\n13 |   let max_word = \"\"\n   |                    ^ help: add `;` here\n14 |   for w in words {\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `if`\n  --> /tmp/tmp83xgxfl_.rs:15:39\n   |\n15 |     let count = w.count_unique_chars()\n   |                                       ^ help: add `;` here\n16 |     if count > max_count {\n   |     -- unexpected token\n\nerror: expected `;`, found `max_word`\n  --> /tmp/tmp83xgxfl_.rs:17:24\n   |\n17 |       max_count = count\n   |                        ^ help: add `;` here\n18 |       max_word = w\n   |       -------- unexpected token\n\nerror[E0599]: no method named `count_unique_chars` found for struct `String` in the current scope\n  --> /tmp/tmp83xgxfl_.rs:15:19\n   |\n15 |     let count = w.count_unique_chars()\n   |                   ^^^^^^^^^^^^^^^^^^ method not found in `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp83xgxfl_.rs:18:18\n   |\n13 |   let max_word = \"\"\n   |                  -- expected due to this value\n...\n18 |       max_word = w\n   |                  ^\n   |                  |\n   |                  expected `&str`, found struct `String`\n   |                  help: consider borrowing here: `&w`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp83xgxfl_.rs:21:10\n   |\n11 | fn find_max(words: Vec<String>) -> String {\n   |                                    ------ expected `String` because of return type\n...\n21 |   return max_word\n   |          ^^^^^^^^- help: try using a conversion method: `.to_string()`\n   |          |\n   |          expected struct `String`, found `&str`\n\nerror: aborting due to 7 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function that accepts a vector of strings.\n/// The vector contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n  let max_count = 0\n  let max_word = String::from(\"\")\n  for w in words {\n    let count = count_unique_chars(w)\n    if count > max_count {\n      max_count = count\n      max_word = w\n    }\n  }\n  return max_word\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]), String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]), String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]), String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n}\n",
      "timestamp": 1664292578,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmp32tkhvu9.rs:12:20\n   |\n12 |   let max_count = 0\n   |                    ^ help: add `;` here\n13 |   let max_word = String::from(\"\")\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmp32tkhvu9.rs:13:34\n   |\n13 |   let max_word = String::from(\"\")\n   |                                  ^ help: add `;` here\n14 |   for w in words {\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `if`\n  --> /tmp/tmp32tkhvu9.rs:15:38\n   |\n15 |     let count = count_unique_chars(w)\n   |                                      ^ help: add `;` here\n16 |     if count > max_count {\n   |     -- unexpected token\n\nerror: expected `;`, found `max_word`\n  --> /tmp/tmp32tkhvu9.rs:17:24\n   |\n17 |       max_count = count\n   |                        ^ help: add `;` here\n18 |       max_word = w\n   |       -------- unexpected token\n\nerror[E0425]: cannot find function `count_unique_chars` in this scope\n  --> /tmp/tmp32tkhvu9.rs:15:17\n   |\n15 |     let count = count_unique_chars(w)\n   |                 ^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to 5 previous errors\n\nFor more information about this error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function that accepts a vector of strings.\n/// The vector contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n  let max_count = 0\n  let max_word = \"\"\n\n  for w in words {\n    let count = count_unique_chars(w)\n    if count > max_count {\n      max_count = count\n      max_word = w\n    }\n  }\n\n  return max_word\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]), String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]), String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]), String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n}\n",
      "timestamp": 1664292578,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmpbg23g2ic.rs:12:20\n   |\n12 |   let max_count = 0\n   |                    ^ help: add `;` here\n13 |   let max_word = \"\"\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpbg23g2ic.rs:13:20\n   |\n13 |   let max_word = \"\"\n   |                    ^ help: add `;` here\n14 | \n15 |   for w in words {\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `if`\n  --> /tmp/tmpbg23g2ic.rs:16:38\n   |\n16 |     let count = count_unique_chars(w)\n   |                                      ^ help: add `;` here\n17 |     if count > max_count {\n   |     -- unexpected token\n\nerror: expected `;`, found `max_word`\n  --> /tmp/tmpbg23g2ic.rs:18:24\n   |\n18 |       max_count = count\n   |                        ^ help: add `;` here\n19 |       max_word = w\n   |       -------- unexpected token\n\nerror[E0425]: cannot find function `count_unique_chars` in this scope\n  --> /tmp/tmpbg23g2ic.rs:16:17\n   |\n16 |     let count = count_unique_chars(w)\n   |                 ^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpbg23g2ic.rs:19:18\n   |\n13 |   let max_word = \"\"\n   |                  -- expected due to this value\n...\n19 |       max_word = w\n   |                  ^\n   |                  |\n   |                  expected `&str`, found struct `String`\n   |                  help: consider borrowing here: `&w`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpbg23g2ic.rs:23:10\n   |\n11 | fn find_max(words: Vec<String>) -> String {\n   |                                    ------ expected `String` because of return type\n...\n23 |   return max_word\n   |          ^^^^^^^^- help: try using a conversion method: `.to_string()`\n   |          |\n   |          expected struct `String`, found `&str`\n\nerror: aborting due to 7 previous errors\n\nSome errors have detailed explanations: E0308, E0425.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function that accepts a vector of strings.\n/// The vector contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n  let max_count = 0\n  let max_word = String::from(\"\")\n  for word in words {\n    let count = count_unique_chars(word)\n    if count > max_count {\n      max_count = count\n      max_word = word\n    }\n  }\n  return max_word\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]), String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]), String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]), String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n}\n",
      "timestamp": 1664292578,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmpxpe2iddk.rs:12:20\n   |\n12 |   let max_count = 0\n   |                    ^ help: add `;` here\n13 |   let max_word = String::from(\"\")\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpxpe2iddk.rs:13:34\n   |\n13 |   let max_word = String::from(\"\")\n   |                                  ^ help: add `;` here\n14 |   for word in words {\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `if`\n  --> /tmp/tmpxpe2iddk.rs:15:41\n   |\n15 |     let count = count_unique_chars(word)\n   |                                         ^ help: add `;` here\n16 |     if count > max_count {\n   |     -- unexpected token\n\nerror: expected `;`, found `max_word`\n  --> /tmp/tmpxpe2iddk.rs:17:24\n   |\n17 |       max_count = count\n   |                        ^ help: add `;` here\n18 |       max_word = word\n   |       -------- unexpected token\n\nerror[E0425]: cannot find function `count_unique_chars` in this scope\n  --> /tmp/tmpxpe2iddk.rs:15:17\n   |\n15 |     let count = count_unique_chars(word)\n   |                 ^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to 5 previous errors\n\nFor more information about this error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function that accepts a vector of strings.\n/// The vector contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n  let max_count = 0\n  let max_word = \"\"\n  for w in words {\n    let count = count_unique_chars(w)\n    if count > max_count {\n      max_count = count\n      max_word = w\n    }\n  }\n  return max_word\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]), String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]), String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]), String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n}\n",
      "timestamp": 1664292578,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmp095up2vv.rs:12:20\n   |\n12 |   let max_count = 0\n   |                    ^ help: add `;` here\n13 |   let max_word = \"\"\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmp095up2vv.rs:13:20\n   |\n13 |   let max_word = \"\"\n   |                    ^ help: add `;` here\n14 |   for w in words {\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `if`\n  --> /tmp/tmp095up2vv.rs:15:38\n   |\n15 |     let count = count_unique_chars(w)\n   |                                      ^ help: add `;` here\n16 |     if count > max_count {\n   |     -- unexpected token\n\nerror: expected `;`, found `max_word`\n  --> /tmp/tmp095up2vv.rs:17:24\n   |\n17 |       max_count = count\n   |                        ^ help: add `;` here\n18 |       max_word = w\n   |       -------- unexpected token\n\nerror[E0425]: cannot find function `count_unique_chars` in this scope\n  --> /tmp/tmp095up2vv.rs:15:17\n   |\n15 |     let count = count_unique_chars(w)\n   |                 ^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp095up2vv.rs:18:18\n   |\n13 |   let max_word = \"\"\n   |                  -- expected due to this value\n...\n18 |       max_word = w\n   |                  ^\n   |                  |\n   |                  expected `&str`, found struct `String`\n   |                  help: consider borrowing here: `&w`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp095up2vv.rs:21:10\n   |\n11 | fn find_max(words: Vec<String>) -> String {\n   |                                    ------ expected `String` because of return type\n...\n21 |   return max_word\n   |          ^^^^^^^^- help: try using a conversion method: `.to_string()`\n   |          |\n   |          expected struct `String`, found `&str`\n\nerror: aborting due to 7 previous errors\n\nSome errors have detailed explanations: E0308, E0425.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function that accepts a vector of strings.\n/// The vector contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n  let max_count = 0\n  let max_word = \"\"\n  for w in words {\n    let count = count_unique_chars(w)\n    if count > max_count {\n      max_count = count\n      max_word = w\n    }\n  }\n  return max_word\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]), String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]), String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]), String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n}\n",
      "timestamp": 1664292578,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmp095up2vv.rs:12:20\n   |\n12 |   let max_count = 0\n   |                    ^ help: add `;` here\n13 |   let max_word = \"\"\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmp095up2vv.rs:13:20\n   |\n13 |   let max_word = \"\"\n   |                    ^ help: add `;` here\n14 |   for w in words {\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `if`\n  --> /tmp/tmp095up2vv.rs:15:38\n   |\n15 |     let count = count_unique_chars(w)\n   |                                      ^ help: add `;` here\n16 |     if count > max_count {\n   |     -- unexpected token\n\nerror: expected `;`, found `max_word`\n  --> /tmp/tmp095up2vv.rs:17:24\n   |\n17 |       max_count = count\n   |                        ^ help: add `;` here\n18 |       max_word = w\n   |       -------- unexpected token\n\nerror[E0425]: cannot find function `count_unique_chars` in this scope\n  --> /tmp/tmp095up2vv.rs:15:17\n   |\n15 |     let count = count_unique_chars(w)\n   |                 ^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp095up2vv.rs:18:18\n   |\n13 |   let max_word = \"\"\n   |                  -- expected due to this value\n...\n18 |       max_word = w\n   |                  ^\n   |                  |\n   |                  expected `&str`, found struct `String`\n   |                  help: consider borrowing here: `&w`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp095up2vv.rs:21:10\n   |\n11 | fn find_max(words: Vec<String>) -> String {\n   |                                    ------ expected `String` because of return type\n...\n21 |   return max_word\n   |          ^^^^^^^^- help: try using a conversion method: `.to_string()`\n   |          |\n   |          expected struct `String`, found `&str`\n\nerror: aborting due to 7 previous errors\n\nSome errors have detailed explanations: E0308, E0425.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function that accepts a vector of strings.\n/// The vector contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n  let max_count = 0\n  let max_word = \"\"\n  for w in words {\n    let count = count_unique_chars(w)\n    if count > max_count {\n      max_count = count\n      max_word = w\n    }\n  }\n  return max_word\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]), String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]), String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]), String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n}\n",
      "timestamp": 1664292578,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmp095up2vv.rs:12:20\n   |\n12 |   let max_count = 0\n   |                    ^ help: add `;` here\n13 |   let max_word = \"\"\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmp095up2vv.rs:13:20\n   |\n13 |   let max_word = \"\"\n   |                    ^ help: add `;` here\n14 |   for w in words {\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `if`\n  --> /tmp/tmp095up2vv.rs:15:38\n   |\n15 |     let count = count_unique_chars(w)\n   |                                      ^ help: add `;` here\n16 |     if count > max_count {\n   |     -- unexpected token\n\nerror: expected `;`, found `max_word`\n  --> /tmp/tmp095up2vv.rs:17:24\n   |\n17 |       max_count = count\n   |                        ^ help: add `;` here\n18 |       max_word = w\n   |       -------- unexpected token\n\nerror[E0425]: cannot find function `count_unique_chars` in this scope\n  --> /tmp/tmp095up2vv.rs:15:17\n   |\n15 |     let count = count_unique_chars(w)\n   |                 ^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp095up2vv.rs:18:18\n   |\n13 |   let max_word = \"\"\n   |                  -- expected due to this value\n...\n18 |       max_word = w\n   |                  ^\n   |                  |\n   |                  expected `&str`, found struct `String`\n   |                  help: consider borrowing here: `&w`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp095up2vv.rs:21:10\n   |\n11 | fn find_max(words: Vec<String>) -> String {\n   |                                    ------ expected `String` because of return type\n...\n21 |   return max_word\n   |          ^^^^^^^^- help: try using a conversion method: `.to_string()`\n   |          |\n   |          expected struct `String`, found `&str`\n\nerror: aborting due to 7 previous errors\n\nSome errors have detailed explanations: E0308, E0425.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function that accepts a vector of strings.\n/// The vector contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n  let max_count = 0\n  let max_word = \"\"\n  for w in words {\n    let count = count_unique_chars(w)\n    if count > max_count {\n      max_count = count\n      max_word = w\n    }\n  }\n  return max_word\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]), String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]), String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]), String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n}\n",
      "timestamp": 1664292578,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmp095up2vv.rs:12:20\n   |\n12 |   let max_count = 0\n   |                    ^ help: add `;` here\n13 |   let max_word = \"\"\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmp095up2vv.rs:13:20\n   |\n13 |   let max_word = \"\"\n   |                    ^ help: add `;` here\n14 |   for w in words {\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `if`\n  --> /tmp/tmp095up2vv.rs:15:38\n   |\n15 |     let count = count_unique_chars(w)\n   |                                      ^ help: add `;` here\n16 |     if count > max_count {\n   |     -- unexpected token\n\nerror: expected `;`, found `max_word`\n  --> /tmp/tmp095up2vv.rs:17:24\n   |\n17 |       max_count = count\n   |                        ^ help: add `;` here\n18 |       max_word = w\n   |       -------- unexpected token\n\nerror[E0425]: cannot find function `count_unique_chars` in this scope\n  --> /tmp/tmp095up2vv.rs:15:17\n   |\n15 |     let count = count_unique_chars(w)\n   |                 ^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp095up2vv.rs:18:18\n   |\n13 |   let max_word = \"\"\n   |                  -- expected due to this value\n...\n18 |       max_word = w\n   |                  ^\n   |                  |\n   |                  expected `&str`, found struct `String`\n   |                  help: consider borrowing here: `&w`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp095up2vv.rs:21:10\n   |\n11 | fn find_max(words: Vec<String>) -> String {\n   |                                    ------ expected `String` because of return type\n...\n21 |   return max_word\n   |          ^^^^^^^^- help: try using a conversion method: `.to_string()`\n   |          |\n   |          expected struct `String`, found `&str`\n\nerror: aborting due to 7 previous errors\n\nSome errors have detailed explanations: E0308, E0425.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function that accepts a vector of strings.\n/// The vector contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n  let max_count = 0\n  let max_word = \"\"\n  for w in words {\n    let count = count_unique_chars(w)\n    if count > max_count {\n      max_count = count\n      max_word = w\n    }\n  }\n  return max_word\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]), String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]), String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]), String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n}\n",
      "timestamp": 1664292578,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmp095up2vv.rs:12:20\n   |\n12 |   let max_count = 0\n   |                    ^ help: add `;` here\n13 |   let max_word = \"\"\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmp095up2vv.rs:13:20\n   |\n13 |   let max_word = \"\"\n   |                    ^ help: add `;` here\n14 |   for w in words {\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `if`\n  --> /tmp/tmp095up2vv.rs:15:38\n   |\n15 |     let count = count_unique_chars(w)\n   |                                      ^ help: add `;` here\n16 |     if count > max_count {\n   |     -- unexpected token\n\nerror: expected `;`, found `max_word`\n  --> /tmp/tmp095up2vv.rs:17:24\n   |\n17 |       max_count = count\n   |                        ^ help: add `;` here\n18 |       max_word = w\n   |       -------- unexpected token\n\nerror[E0425]: cannot find function `count_unique_chars` in this scope\n  --> /tmp/tmp095up2vv.rs:15:17\n   |\n15 |     let count = count_unique_chars(w)\n   |                 ^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp095up2vv.rs:18:18\n   |\n13 |   let max_word = \"\"\n   |                  -- expected due to this value\n...\n18 |       max_word = w\n   |                  ^\n   |                  |\n   |                  expected `&str`, found struct `String`\n   |                  help: consider borrowing here: `&w`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp095up2vv.rs:21:10\n   |\n11 | fn find_max(words: Vec<String>) -> String {\n   |                                    ------ expected `String` because of return type\n...\n21 |   return max_word\n   |          ^^^^^^^^- help: try using a conversion method: `.to_string()`\n   |          |\n   |          expected struct `String`, found `&str`\n\nerror: aborting due to 7 previous errors\n\nSome errors have detailed explanations: E0308, E0425.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function that accepts a vector of strings.\n/// The vector contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n  let max_count = 0\n  let max_word = \"\"\n  for w in words {\n    let count = count_unique_chars(w)\n    if count > max_count {\n      max_count = count\n      max_word = w\n    }\n  }\n  return max_word\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]), String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]), String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]), String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n}\n",
      "timestamp": 1664292578,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmp095up2vv.rs:12:20\n   |\n12 |   let max_count = 0\n   |                    ^ help: add `;` here\n13 |   let max_word = \"\"\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmp095up2vv.rs:13:20\n   |\n13 |   let max_word = \"\"\n   |                    ^ help: add `;` here\n14 |   for w in words {\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `if`\n  --> /tmp/tmp095up2vv.rs:15:38\n   |\n15 |     let count = count_unique_chars(w)\n   |                                      ^ help: add `;` here\n16 |     if count > max_count {\n   |     -- unexpected token\n\nerror: expected `;`, found `max_word`\n  --> /tmp/tmp095up2vv.rs:17:24\n   |\n17 |       max_count = count\n   |                        ^ help: add `;` here\n18 |       max_word = w\n   |       -------- unexpected token\n\nerror[E0425]: cannot find function `count_unique_chars` in this scope\n  --> /tmp/tmp095up2vv.rs:15:17\n   |\n15 |     let count = count_unique_chars(w)\n   |                 ^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp095up2vv.rs:18:18\n   |\n13 |   let max_word = \"\"\n   |                  -- expected due to this value\n...\n18 |       max_word = w\n   |                  ^\n   |                  |\n   |                  expected `&str`, found struct `String`\n   |                  help: consider borrowing here: `&w`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp095up2vv.rs:21:10\n   |\n11 | fn find_max(words: Vec<String>) -> String {\n   |                                    ------ expected `String` because of return type\n...\n21 |   return max_word\n   |          ^^^^^^^^- help: try using a conversion method: `.to_string()`\n   |          |\n   |          expected struct `String`, found `&str`\n\nerror: aborting due to 7 previous errors\n\nSome errors have detailed explanations: E0308, E0425.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function that accepts a vector of strings.\n/// The vector contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n  let max_count = 0\n  let max_word = \"\"\n  for w in words {\n    let count = w.count(/[a-z]/)\n    if count > max_count {\n      max_count = count\n      max_word = w\n    }\n  }\n  return max_word\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]), String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]), String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]), String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n}\n",
      "timestamp": 1664292578,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmpjn5c1gme.rs:12:20\n   |\n12 |   let max_count = 0\n   |                    ^ help: add `;` here\n13 |   let max_word = \"\"\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpjn5c1gme.rs:13:20\n   |\n13 |   let max_word = \"\"\n   |                    ^ help: add `;` here\n14 |   for w in words {\n   |   --- unexpected token\n\nerror: expected expression, found `/`\n  --> /tmp/tmpjn5c1gme.rs:15:25\n   |\n15 |     let count = w.count(/[a-z]/)\n   |                         ^ expected expression\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpjn5c1gme.rs:21:10\n   |\n11 | fn find_max(words: Vec<String>) -> String {\n   |                                    ------ expected `String` because of return type\n...\n21 |   return max_word\n   |          ^^^^^^^^- help: try using a conversion method: `.to_string()`\n   |          |\n   |          expected struct `String`, found `&str`\n\nerror: aborting due to 4 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function that accepts a vector of strings.\n/// The vector contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n  let max_count = 0\n  let max_count_index = 0\n  let max_count_word = \"\"\n  for i in 0..words.len() {\n    let count = words[i].count_unique()\n    if count > max_count {\n      max_count = count\n      max_count_index = i\n      max_count_word = words[i]\n    }\n  }\n  return max_count_word\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]), String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]), String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]), String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n}\n",
      "timestamp": 1664292578,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmpxmsd1x4n.rs:12:20\n   |\n12 |   let max_count = 0\n   |                    ^ help: add `;` here\n13 |   let max_count_index = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmpxmsd1x4n.rs:13:26\n   |\n13 |   let max_count_index = 0\n   |                          ^ help: add `;` here\n14 |   let max_count_word = \"\"\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpxmsd1x4n.rs:14:26\n   |\n14 |   let max_count_word = \"\"\n   |                          ^ help: add `;` here\n15 |   for i in 0..words.len() {\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `if`\n  --> /tmp/tmpxmsd1x4n.rs:16:40\n   |\n16 |     let count = words[i].count_unique()\n   |                                        ^ help: add `;` here\n17 |     if count > max_count {\n   |     -- unexpected token\n\nerror: expected `;`, found `max_count_index`\n  --> /tmp/tmpxmsd1x4n.rs:18:24\n   |\n18 |       max_count = count\n   |                        ^ help: add `;` here\n19 |       max_count_index = i\n   |       --------------- unexpected token\n\nerror: expected `;`, found `max_count_word`\n  --> /tmp/tmpxmsd1x4n.rs:19:26\n   |\n19 |       max_count_index = i\n   |                          ^ help: add `;` here\n20 |       max_count_word = words[i]\n   |       -------------- unexpected token\n\nerror[E0599]: no method named `count_unique` found for struct `String` in the current scope\n  --> /tmp/tmpxmsd1x4n.rs:16:26\n   |\n16 |     let count = words[i].count_unique()\n   |                          ^^^^^^^^^^^^ method not found in `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpxmsd1x4n.rs:20:24\n   |\n14 |   let max_count_word = \"\"\n   |                        -- expected due to this value\n...\n20 |       max_count_word = words[i]\n   |                        ^^^^^^^^\n   |                        |\n   |                        expected `&str`, found struct `String`\n   |                        help: consider borrowing here: `&words[i]`\n\nerror[E0308]: mism",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function that accepts a vector of strings.\n/// The vector contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n  let max_count = 0\n  let max_word = \"\"\n  for w in words {\n    let count = w.count(/[a-z]/)\n    if count > max_count {\n      max_count = count\n      max_word = w\n    }\n  }\n  return max_word\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]), String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]), String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]), String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n}\n",
      "timestamp": 1664292578,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmpjn5c1gme.rs:12:20\n   |\n12 |   let max_count = 0\n   |                    ^ help: add `;` here\n13 |   let max_word = \"\"\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpjn5c1gme.rs:13:20\n   |\n13 |   let max_word = \"\"\n   |                    ^ help: add `;` here\n14 |   for w in words {\n   |   --- unexpected token\n\nerror: expected expression, found `/`\n  --> /tmp/tmpjn5c1gme.rs:15:25\n   |\n15 |     let count = w.count(/[a-z]/)\n   |                         ^ expected expression\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpjn5c1gme.rs:21:10\n   |\n11 | fn find_max(words: Vec<String>) -> String {\n   |                                    ------ expected `String` because of return type\n...\n21 |   return max_word\n   |          ^^^^^^^^- help: try using a conversion method: `.to_string()`\n   |          |\n   |          expected struct `String`, found `&str`\n\nerror: aborting due to 4 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function that accepts a vector of strings.\n/// The vector contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n  let max_count = 0\n  let max_word = \"\"\n  for w in words {\n    let count = w.count_unique()\n    if count > max_count {\n      max_count = count\n      max_word = w\n    }\n  }\n  return max_word\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]), String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]), String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]), String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n}\n",
      "timestamp": 1664292578,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmp5vp_ies0.rs:12:20\n   |\n12 |   let max_count = 0\n   |                    ^ help: add `;` here\n13 |   let max_word = \"\"\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmp5vp_ies0.rs:13:20\n   |\n13 |   let max_word = \"\"\n   |                    ^ help: add `;` here\n14 |   for w in words {\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `if`\n  --> /tmp/tmp5vp_ies0.rs:15:33\n   |\n15 |     let count = w.count_unique()\n   |                                 ^ help: add `;` here\n16 |     if count > max_count {\n   |     -- unexpected token\n\nerror: expected `;`, found `max_word`\n  --> /tmp/tmp5vp_ies0.rs:17:24\n   |\n17 |       max_count = count\n   |                        ^ help: add `;` here\n18 |       max_word = w\n   |       -------- unexpected token\n\nerror[E0599]: no method named `count_unique` found for struct `String` in the current scope\n  --> /tmp/tmp5vp_ies0.rs:15:19\n   |\n15 |     let count = w.count_unique()\n   |                   ^^^^^^^^^^^^ method not found in `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp5vp_ies0.rs:18:18\n   |\n13 |   let max_word = \"\"\n   |                  -- expected due to this value\n...\n18 |       max_word = w\n   |                  ^\n   |                  |\n   |                  expected `&str`, found struct `String`\n   |                  help: consider borrowing here: `&w`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp5vp_ies0.rs:21:10\n   |\n11 | fn find_max(words: Vec<String>) -> String {\n   |                                    ------ expected `String` because of return type\n...\n21 |   return max_word\n   |          ^^^^^^^^- help: try using a conversion method: `.to_string()`\n   |          |\n   |          expected struct `String`, found `&str`\n\nerror: aborting due to 7 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function that accepts a vector of strings.\n/// The vector contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n  let max_count = 0\n  let max_word = \"\"\n  for w in words {\n    let count = w.count(/[a-z]/);\n    if count > max_count {\n      max_count = count\n      max_word = w\n    }\n  }\n  return max_word\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]), String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]), String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]), String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n}\n",
      "timestamp": 1664292578,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmpk6mb5m3s.rs:12:20\n   |\n12 |   let max_count = 0\n   |                    ^ help: add `;` here\n13 |   let max_word = \"\"\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpk6mb5m3s.rs:13:20\n   |\n13 |   let max_word = \"\"\n   |                    ^ help: add `;` here\n14 |   for w in words {\n   |   --- unexpected token\n\nerror: expected expression, found `/`\n  --> /tmp/tmpk6mb5m3s.rs:15:25\n   |\n15 |     let count = w.count(/[a-z]/);\n   |                         ^ expected expression\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpk6mb5m3s.rs:21:10\n   |\n11 | fn find_max(words: Vec<String>) -> String {\n   |                                    ------ expected `String` because of return type\n...\n21 |   return max_word\n   |          ^^^^^^^^- help: try using a conversion method: `.to_string()`\n   |          |\n   |          expected struct `String`, found `&str`\n\nerror: aborting due to 4 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function that accepts a vector of strings.\n/// The vector contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n  let max_count = 0\n  let max_count_index = 0\n  let max_count_word = \"\"\n  for i in 0..words.len() {\n    let count = words[i].count_unique_chars()\n    if count > max_count {\n      max_count = count\n      max_count_index = i\n      max_count_word = words[i]\n    }\n  }\n  return max_count_word\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]), String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]), String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]), String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n}\n",
      "timestamp": 1664292578,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmp24evb004.rs:12:20\n   |\n12 |   let max_count = 0\n   |                    ^ help: add `;` here\n13 |   let max_count_index = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmp24evb004.rs:13:26\n   |\n13 |   let max_count_index = 0\n   |                          ^ help: add `;` here\n14 |   let max_count_word = \"\"\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmp24evb004.rs:14:26\n   |\n14 |   let max_count_word = \"\"\n   |                          ^ help: add `;` here\n15 |   for i in 0..words.len() {\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `if`\n  --> /tmp/tmp24evb004.rs:16:46\n   |\n16 |     let count = words[i].count_unique_chars()\n   |                                              ^ help: add `;` here\n17 |     if count > max_count {\n   |     -- unexpected token\n\nerror: expected `;`, found `max_count_index`\n  --> /tmp/tmp24evb004.rs:18:24\n   |\n18 |       max_count = count\n   |                        ^ help: add `;` here\n19 |       max_count_index = i\n   |       --------------- unexpected token\n\nerror: expected `;`, found `max_count_word`\n  --> /tmp/tmp24evb004.rs:19:26\n   |\n19 |       max_count_index = i\n   |                          ^ help: add `;` here\n20 |       max_count_word = words[i]\n   |       -------------- unexpected token\n\nerror[E0599]: no method named `count_unique_chars` found for struct `String` in the current scope\n  --> /tmp/tmp24evb004.rs:16:26\n   |\n16 |     let count = words[i].count_unique_chars()\n   |                          ^^^^^^^^^^^^^^^^^^ method not found in `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp24evb004.rs:20:24\n   |\n14 |   let max_count_word = \"\"\n   |                        -- expected due to this value\n...\n20 |       max_count_word = words[i]\n   |                        ^^^^^^^^\n   |                        |\n   |                        expected `&str`, found struct `String`\n   |                        help: consider borrowing here: `",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function that accepts a vector of strings.\n/// The vector contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n  let max_count = 0\n  let max_word = String::from(\"\")\n  for w in words {\n    let count = w.count(/[a-z]/);\n    if count > max_count {\n      max_count = count\n      max_word = w\n    }\n  }\n  return max_word\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]), String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]), String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]), String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n}\n",
      "timestamp": 1664292578,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmppewkjxfa.rs:12:20\n   |\n12 |   let max_count = 0\n   |                    ^ help: add `;` here\n13 |   let max_word = String::from(\"\")\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmppewkjxfa.rs:13:34\n   |\n13 |   let max_word = String::from(\"\")\n   |                                  ^ help: add `;` here\n14 |   for w in words {\n   |   --- unexpected token\n\nerror: expected expression, found `/`\n  --> /tmp/tmppewkjxfa.rs:15:25\n   |\n15 |     let count = w.count(/[a-z]/);\n   |                         ^ expected expression\n\nerror: aborting due to 3 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function that accepts a vector of strings.\n/// The vector contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n  let max_count = 0\n  let max_word = \"\"\n  for w in words {\n    let count = w.count(/[a-z]/)\n    if count > max_count {\n      max_count = count\n      max_word = w\n    }\n  }\n  return max_word\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]), String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]), String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]), String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n}\n",
      "timestamp": 1664292578,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmpjn5c1gme.rs:12:20\n   |\n12 |   let max_count = 0\n   |                    ^ help: add `;` here\n13 |   let max_word = \"\"\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpjn5c1gme.rs:13:20\n   |\n13 |   let max_word = \"\"\n   |                    ^ help: add `;` here\n14 |   for w in words {\n   |   --- unexpected token\n\nerror: expected expression, found `/`\n  --> /tmp/tmpjn5c1gme.rs:15:25\n   |\n15 |     let count = w.count(/[a-z]/)\n   |                         ^ expected expression\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpjn5c1gme.rs:21:10\n   |\n11 | fn find_max(words: Vec<String>) -> String {\n   |                                    ------ expected `String` because of return type\n...\n21 |   return max_word\n   |          ^^^^^^^^- help: try using a conversion method: `.to_string()`\n   |          |\n   |          expected struct `String`, found `&str`\n\nerror: aborting due to 4 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function that accepts a vector of strings.\n/// The vector contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n  let max_count = 0\n  let max_word = \"\"\n  for w in words {\n    let count = count_unique_chars(w)\n    if count > max_count {\n      max_count = count\n      max_word = w\n    }\n  }\n  return max_word\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]), String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]), String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]), String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n}\n",
      "timestamp": 1664292578,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmp095up2vv.rs:12:20\n   |\n12 |   let max_count = 0\n   |                    ^ help: add `;` here\n13 |   let max_word = \"\"\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmp095up2vv.rs:13:20\n   |\n13 |   let max_word = \"\"\n   |                    ^ help: add `;` here\n14 |   for w in words {\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `if`\n  --> /tmp/tmp095up2vv.rs:15:38\n   |\n15 |     let count = count_unique_chars(w)\n   |                                      ^ help: add `;` here\n16 |     if count > max_count {\n   |     -- unexpected token\n\nerror: expected `;`, found `max_word`\n  --> /tmp/tmp095up2vv.rs:17:24\n   |\n17 |       max_count = count\n   |                        ^ help: add `;` here\n18 |       max_word = w\n   |       -------- unexpected token\n\nerror[E0425]: cannot find function `count_unique_chars` in this scope\n  --> /tmp/tmp095up2vv.rs:15:17\n   |\n15 |     let count = count_unique_chars(w)\n   |                 ^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp095up2vv.rs:18:18\n   |\n13 |   let max_word = \"\"\n   |                  -- expected due to this value\n...\n18 |       max_word = w\n   |                  ^\n   |                  |\n   |                  expected `&str`, found struct `String`\n   |                  help: consider borrowing here: `&w`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp095up2vv.rs:21:10\n   |\n11 | fn find_max(words: Vec<String>) -> String {\n   |                                    ------ expected `String` because of return type\n...\n21 |   return max_word\n   |          ^^^^^^^^- help: try using a conversion method: `.to_string()`\n   |          |\n   |          expected struct `String`, found `&str`\n\nerror: aborting due to 7 previous errors\n\nSome errors have detailed explanations: E0308, E0425.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function that accepts a vector of strings.\n/// The vector contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n  let max_count = 0\n  let max_word = \"\"\n  for w in words {\n    let count = count_unique_chars(w)\n    if count > max_count {\n      max_count = count\n      max_word = w\n    }\n  }\n  return max_word\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]), String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]), String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]), String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n}\n",
      "timestamp": 1664292578,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmp095up2vv.rs:12:20\n   |\n12 |   let max_count = 0\n   |                    ^ help: add `;` here\n13 |   let max_word = \"\"\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmp095up2vv.rs:13:20\n   |\n13 |   let max_word = \"\"\n   |                    ^ help: add `;` here\n14 |   for w in words {\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `if`\n  --> /tmp/tmp095up2vv.rs:15:38\n   |\n15 |     let count = count_unique_chars(w)\n   |                                      ^ help: add `;` here\n16 |     if count > max_count {\n   |     -- unexpected token\n\nerror: expected `;`, found `max_word`\n  --> /tmp/tmp095up2vv.rs:17:24\n   |\n17 |       max_count = count\n   |                        ^ help: add `;` here\n18 |       max_word = w\n   |       -------- unexpected token\n\nerror[E0425]: cannot find function `count_unique_chars` in this scope\n  --> /tmp/tmp095up2vv.rs:15:17\n   |\n15 |     let count = count_unique_chars(w)\n   |                 ^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp095up2vv.rs:18:18\n   |\n13 |   let max_word = \"\"\n   |                  -- expected due to this value\n...\n18 |       max_word = w\n   |                  ^\n   |                  |\n   |                  expected `&str`, found struct `String`\n   |                  help: consider borrowing here: `&w`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp095up2vv.rs:21:10\n   |\n11 | fn find_max(words: Vec<String>) -> String {\n   |                                    ------ expected `String` because of return type\n...\n21 |   return max_word\n   |          ^^^^^^^^- help: try using a conversion method: `.to_string()`\n   |          |\n   |          expected struct `String`, found `&str`\n\nerror: aborting due to 7 previous errors\n\nSome errors have detailed explanations: E0308, E0425.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function that accepts a vector of strings.\n/// The vector contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n  let max_count = 0\n  let max_word = \"\"\n  for w in words {\n    let count = count_unique_chars(w)\n    if count > max_count {\n      max_count = count\n      max_word = w\n    }\n  }\n  return max_word\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]), String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]), String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]), String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n}\n",
      "timestamp": 1664292578,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmp095up2vv.rs:12:20\n   |\n12 |   let max_count = 0\n   |                    ^ help: add `;` here\n13 |   let max_word = \"\"\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmp095up2vv.rs:13:20\n   |\n13 |   let max_word = \"\"\n   |                    ^ help: add `;` here\n14 |   for w in words {\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `if`\n  --> /tmp/tmp095up2vv.rs:15:38\n   |\n15 |     let count = count_unique_chars(w)\n   |                                      ^ help: add `;` here\n16 |     if count > max_count {\n   |     -- unexpected token\n\nerror: expected `;`, found `max_word`\n  --> /tmp/tmp095up2vv.rs:17:24\n   |\n17 |       max_count = count\n   |                        ^ help: add `;` here\n18 |       max_word = w\n   |       -------- unexpected token\n\nerror[E0425]: cannot find function `count_unique_chars` in this scope\n  --> /tmp/tmp095up2vv.rs:15:17\n   |\n15 |     let count = count_unique_chars(w)\n   |                 ^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp095up2vv.rs:18:18\n   |\n13 |   let max_word = \"\"\n   |                  -- expected due to this value\n...\n18 |       max_word = w\n   |                  ^\n   |                  |\n   |                  expected `&str`, found struct `String`\n   |                  help: consider borrowing here: `&w`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp095up2vv.rs:21:10\n   |\n11 | fn find_max(words: Vec<String>) -> String {\n   |                                    ------ expected `String` because of return type\n...\n21 |   return max_word\n   |          ^^^^^^^^- help: try using a conversion method: `.to_string()`\n   |          |\n   |          expected struct `String`, found `&str`\n\nerror: aborting due to 7 previous errors\n\nSome errors have detailed explanations: E0308, E0425.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function that accepts a vector of strings.\n/// The vector contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n  let max_count = 0\n  let max_word = \"\"\n  for w in words {\n    let count = count_unique_chars(w)\n    if count > max_count {\n      max_count = count\n      max_word = w\n    }\n  }\n  return max_word\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]), String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]), String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]), String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n}\n",
      "timestamp": 1664292578,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmp095up2vv.rs:12:20\n   |\n12 |   let max_count = 0\n   |                    ^ help: add `;` here\n13 |   let max_word = \"\"\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmp095up2vv.rs:13:20\n   |\n13 |   let max_word = \"\"\n   |                    ^ help: add `;` here\n14 |   for w in words {\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `if`\n  --> /tmp/tmp095up2vv.rs:15:38\n   |\n15 |     let count = count_unique_chars(w)\n   |                                      ^ help: add `;` here\n16 |     if count > max_count {\n   |     -- unexpected token\n\nerror: expected `;`, found `max_word`\n  --> /tmp/tmp095up2vv.rs:17:24\n   |\n17 |       max_count = count\n   |                        ^ help: add `;` here\n18 |       max_word = w\n   |       -------- unexpected token\n\nerror[E0425]: cannot find function `count_unique_chars` in this scope\n  --> /tmp/tmp095up2vv.rs:15:17\n   |\n15 |     let count = count_unique_chars(w)\n   |                 ^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp095up2vv.rs:18:18\n   |\n13 |   let max_word = \"\"\n   |                  -- expected due to this value\n...\n18 |       max_word = w\n   |                  ^\n   |                  |\n   |                  expected `&str`, found struct `String`\n   |                  help: consider borrowing here: `&w`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp095up2vv.rs:21:10\n   |\n11 | fn find_max(words: Vec<String>) -> String {\n   |                                    ------ expected `String` because of return type\n...\n21 |   return max_word\n   |          ^^^^^^^^- help: try using a conversion method: `.to_string()`\n   |          |\n   |          expected struct `String`, found `&str`\n\nerror: aborting due to 7 previous errors\n\nSome errors have detailed explanations: E0308, E0425.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function that accepts a vector of strings.\n/// The vector contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n  let max_count = 0\n  let max_word = \"\"\n  for w in words {\n    let count = w.count_unique_chars()\n    if count > max_count {\n      max_count = count\n      max_word = w\n    }\n  }\n  return max_word\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]), String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]), String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]), String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n}\n",
      "timestamp": 1664292578,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmp83xgxfl_.rs:12:20\n   |\n12 |   let max_count = 0\n   |                    ^ help: add `;` here\n13 |   let max_word = \"\"\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmp83xgxfl_.rs:13:20\n   |\n13 |   let max_word = \"\"\n   |                    ^ help: add `;` here\n14 |   for w in words {\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `if`\n  --> /tmp/tmp83xgxfl_.rs:15:39\n   |\n15 |     let count = w.count_unique_chars()\n   |                                       ^ help: add `;` here\n16 |     if count > max_count {\n   |     -- unexpected token\n\nerror: expected `;`, found `max_word`\n  --> /tmp/tmp83xgxfl_.rs:17:24\n   |\n17 |       max_count = count\n   |                        ^ help: add `;` here\n18 |       max_word = w\n   |       -------- unexpected token\n\nerror[E0599]: no method named `count_unique_chars` found for struct `String` in the current scope\n  --> /tmp/tmp83xgxfl_.rs:15:19\n   |\n15 |     let count = w.count_unique_chars()\n   |                   ^^^^^^^^^^^^^^^^^^ method not found in `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp83xgxfl_.rs:18:18\n   |\n13 |   let max_word = \"\"\n   |                  -- expected due to this value\n...\n18 |       max_word = w\n   |                  ^\n   |                  |\n   |                  expected `&str`, found struct `String`\n   |                  help: consider borrowing here: `&w`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp83xgxfl_.rs:21:10\n   |\n11 | fn find_max(words: Vec<String>) -> String {\n   |                                    ------ expected `String` because of return type\n...\n21 |   return max_word\n   |          ^^^^^^^^- help: try using a conversion method: `.to_string()`\n   |          |\n   |          expected struct `String`, found `&str`\n\nerror: aborting due to 7 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function that accepts a vector of strings.\n/// The vector contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n  let max_count = 0\n  let max_word = \"\"\n  for w in words {\n    let count = count_unique_chars(w)\n    if count > max_count {\n      max_count = count\n      max_word = w\n    }\n  }\n  return max_word\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]), String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]), String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]), String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n}\n",
      "timestamp": 1664292578,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmp095up2vv.rs:12:20\n   |\n12 |   let max_count = 0\n   |                    ^ help: add `;` here\n13 |   let max_word = \"\"\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmp095up2vv.rs:13:20\n   |\n13 |   let max_word = \"\"\n   |                    ^ help: add `;` here\n14 |   for w in words {\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `if`\n  --> /tmp/tmp095up2vv.rs:15:38\n   |\n15 |     let count = count_unique_chars(w)\n   |                                      ^ help: add `;` here\n16 |     if count > max_count {\n   |     -- unexpected token\n\nerror: expected `;`, found `max_word`\n  --> /tmp/tmp095up2vv.rs:17:24\n   |\n17 |       max_count = count\n   |                        ^ help: add `;` here\n18 |       max_word = w\n   |       -------- unexpected token\n\nerror[E0425]: cannot find function `count_unique_chars` in this scope\n  --> /tmp/tmp095up2vv.rs:15:17\n   |\n15 |     let count = count_unique_chars(w)\n   |                 ^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp095up2vv.rs:18:18\n   |\n13 |   let max_word = \"\"\n   |                  -- expected due to this value\n...\n18 |       max_word = w\n   |                  ^\n   |                  |\n   |                  expected `&str`, found struct `String`\n   |                  help: consider borrowing here: `&w`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp095up2vv.rs:21:10\n   |\n11 | fn find_max(words: Vec<String>) -> String {\n   |                                    ------ expected `String` because of return type\n...\n21 |   return max_word\n   |          ^^^^^^^^- help: try using a conversion method: `.to_string()`\n   |          |\n   |          expected struct `String`, found `&str`\n\nerror: aborting due to 7 previous errors\n\nSome errors have detailed explanations: E0308, E0425.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function that accepts a vector of strings.\n/// The vector contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n  let max_count = 0\n  let max_word = \"\"\n  for word in words {\n    let count = count_unique_chars(word)\n    if count > max_count {\n      max_count = count\n      max_word = word\n    }\n  }\n  return max_word\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]), String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]), String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]), String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n}\n",
      "timestamp": 1664292578,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmpblowsbak.rs:12:20\n   |\n12 |   let max_count = 0\n   |                    ^ help: add `;` here\n13 |   let max_word = \"\"\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpblowsbak.rs:13:20\n   |\n13 |   let max_word = \"\"\n   |                    ^ help: add `;` here\n14 |   for word in words {\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `if`\n  --> /tmp/tmpblowsbak.rs:15:41\n   |\n15 |     let count = count_unique_chars(word)\n   |                                         ^ help: add `;` here\n16 |     if count > max_count {\n   |     -- unexpected token\n\nerror: expected `;`, found `max_word`\n  --> /tmp/tmpblowsbak.rs:17:24\n   |\n17 |       max_count = count\n   |                        ^ help: add `;` here\n18 |       max_word = word\n   |       -------- unexpected token\n\nerror[E0425]: cannot find function `count_unique_chars` in this scope\n  --> /tmp/tmpblowsbak.rs:15:17\n   |\n15 |     let count = count_unique_chars(word)\n   |                 ^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpblowsbak.rs:18:18\n   |\n13 |   let max_word = \"\"\n   |                  -- expected due to this value\n...\n18 |       max_word = word\n   |                  ^^^^\n   |                  |\n   |                  expected `&str`, found struct `String`\n   |                  help: consider borrowing here: `&word`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpblowsbak.rs:21:10\n   |\n11 | fn find_max(words: Vec<String>) -> String {\n   |                                    ------ expected `String` because of return type\n...\n21 |   return max_word\n   |          ^^^^^^^^- help: try using a conversion method: `.to_string()`\n   |          |\n   |          expected struct `String`, found `&str`\n\nerror: aborting due to 7 previous errors\n\nSome errors have detailed explanations: E0308, E0425.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function that accepts a vector of strings.\n/// The vector contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n  let max_count = 0\n  let max_word = \"\"\n  for w in words {\n    let count = w.count_unique()\n    if count > max_count {\n      max_count = count\n      max_word = w\n    }\n  }\n  return max_word\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]), String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]), String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]), String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n}\n",
      "timestamp": 1664292578,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmp5vp_ies0.rs:12:20\n   |\n12 |   let max_count = 0\n   |                    ^ help: add `;` here\n13 |   let max_word = \"\"\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmp5vp_ies0.rs:13:20\n   |\n13 |   let max_word = \"\"\n   |                    ^ help: add `;` here\n14 |   for w in words {\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `if`\n  --> /tmp/tmp5vp_ies0.rs:15:33\n   |\n15 |     let count = w.count_unique()\n   |                                 ^ help: add `;` here\n16 |     if count > max_count {\n   |     -- unexpected token\n\nerror: expected `;`, found `max_word`\n  --> /tmp/tmp5vp_ies0.rs:17:24\n   |\n17 |       max_count = count\n   |                        ^ help: add `;` here\n18 |       max_word = w\n   |       -------- unexpected token\n\nerror[E0599]: no method named `count_unique` found for struct `String` in the current scope\n  --> /tmp/tmp5vp_ies0.rs:15:19\n   |\n15 |     let count = w.count_unique()\n   |                   ^^^^^^^^^^^^ method not found in `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp5vp_ies0.rs:18:18\n   |\n13 |   let max_word = \"\"\n   |                  -- expected due to this value\n...\n18 |       max_word = w\n   |                  ^\n   |                  |\n   |                  expected `&str`, found struct `String`\n   |                  help: consider borrowing here: `&w`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp5vp_ies0.rs:21:10\n   |\n11 | fn find_max(words: Vec<String>) -> String {\n   |                                    ------ expected `String` because of return type\n...\n21 |   return max_word\n   |          ^^^^^^^^- help: try using a conversion method: `.to_string()`\n   |          |\n   |          expected struct `String`, found `&str`\n\nerror: aborting due to 7 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function that accepts a vector of strings.\n/// The vector contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n  let max_count = 0\n  let max_word = \"\"\n  for w in words {\n    let count = count_unique_chars(w)\n    if count > max_count {\n      max_count = count\n      max_word = w\n    }\n  }\n  return max_word\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]), String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]), String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]), String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n}\n",
      "timestamp": 1664292578,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmp095up2vv.rs:12:20\n   |\n12 |   let max_count = 0\n   |                    ^ help: add `;` here\n13 |   let max_word = \"\"\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmp095up2vv.rs:13:20\n   |\n13 |   let max_word = \"\"\n   |                    ^ help: add `;` here\n14 |   for w in words {\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `if`\n  --> /tmp/tmp095up2vv.rs:15:38\n   |\n15 |     let count = count_unique_chars(w)\n   |                                      ^ help: add `;` here\n16 |     if count > max_count {\n   |     -- unexpected token\n\nerror: expected `;`, found `max_word`\n  --> /tmp/tmp095up2vv.rs:17:24\n   |\n17 |       max_count = count\n   |                        ^ help: add `;` here\n18 |       max_word = w\n   |       -------- unexpected token\n\nerror[E0425]: cannot find function `count_unique_chars` in this scope\n  --> /tmp/tmp095up2vv.rs:15:17\n   |\n15 |     let count = count_unique_chars(w)\n   |                 ^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp095up2vv.rs:18:18\n   |\n13 |   let max_word = \"\"\n   |                  -- expected due to this value\n...\n18 |       max_word = w\n   |                  ^\n   |                  |\n   |                  expected `&str`, found struct `String`\n   |                  help: consider borrowing here: `&w`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp095up2vv.rs:21:10\n   |\n11 | fn find_max(words: Vec<String>) -> String {\n   |                                    ------ expected `String` because of return type\n...\n21 |   return max_word\n   |          ^^^^^^^^- help: try using a conversion method: `.to_string()`\n   |          |\n   |          expected struct `String`, found `&str`\n\nerror: aborting due to 7 previous errors\n\nSome errors have detailed explanations: E0308, E0425.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function that accepts a vector of strings.\n/// The vector contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n  let max_count = 0\n  let max_count_index = 0\n  let max_count_word = \"\"\n\n  for i in words {\n    let count = count_unique_chars(i)\n    if count > max_count {\n      max_count = count\n      max_count_index = i\n      max_count_word = i\n    }\n  }\n\n  return max_count_word\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]), String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]), String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]), String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n}\n",
      "timestamp": 1664292578,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmpfq464zad.rs:12:20\n   |\n12 |   let max_count = 0\n   |                    ^ help: add `;` here\n13 |   let max_count_index = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmpfq464zad.rs:13:26\n   |\n13 |   let max_count_index = 0\n   |                          ^ help: add `;` here\n14 |   let max_count_word = \"\"\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpfq464zad.rs:14:26\n   |\n14 |   let max_count_word = \"\"\n   |                          ^ help: add `;` here\n15 | \n16 |   for i in words {\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `if`\n  --> /tmp/tmpfq464zad.rs:17:38\n   |\n17 |     let count = count_unique_chars(i)\n   |                                      ^ help: add `;` here\n18 |     if count > max_count {\n   |     -- unexpected token\n\nerror: expected `;`, found `max_count_index`\n  --> /tmp/tmpfq464zad.rs:19:24\n   |\n19 |       max_count = count\n   |                        ^ help: add `;` here\n20 |       max_count_index = i\n   |       --------------- unexpected token\n\nerror: expected `;`, found `max_count_word`\n  --> /tmp/tmpfq464zad.rs:20:26\n   |\n20 |       max_count_index = i\n   |                          ^ help: add `;` here\n21 |       max_count_word = i\n   |       -------------- unexpected token\n\nerror[E0425]: cannot find function `count_unique_chars` in this scope\n  --> /tmp/tmpfq464zad.rs:17:17\n   |\n17 |     let count = count_unique_chars(i)\n   |                 ^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpfq464zad.rs:20:25\n   |\n13 |   let max_count_index = 0\n   |                         - expected due to this value\n...\n20 |       max_count_index = i\n   |                         ^ expected integer, found struct `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpfq464zad.rs:21:24\n   |\n14 |   let max_count_word = \"\"\n   |                        -- expected due to this value\n...\n21 |       max_count_word = i\n   |         ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function that accepts a vector of strings.\n/// The vector contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n  let max_count = 0;\n  let max_word = String::from(\"\");\n  for word in words {\n    let count = count_unique_chars(word);\n    if count > max_count {\n      max_count = count;\n      max_word = word;\n    }\n  }\n  return max_word;\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]), String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]), String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]), String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n}\n",
      "timestamp": 1664292578,
      "stdout": "",
      "stderr": "error[E0425]: cannot find function `count_unique_chars` in this scope\n  --> /tmp/tmp7umry43m.rs:15:17\n   |\n15 |     let count = count_unique_chars(word);\n   |                 ^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function that accepts a vector of strings.\n/// The vector contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n  let max_count = 0\n  let max_word = \"\"\n  for w in words {\n    let count = w.count(/[a-z]/)\n    if count > max_count {\n      max_count = count\n      max_word = w\n    }\n  }\n  return max_word\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]), String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]), String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]), String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n}\n",
      "timestamp": 1664292578,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmpjn5c1gme.rs:12:20\n   |\n12 |   let max_count = 0\n   |                    ^ help: add `;` here\n13 |   let max_word = \"\"\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpjn5c1gme.rs:13:20\n   |\n13 |   let max_word = \"\"\n   |                    ^ help: add `;` here\n14 |   for w in words {\n   |   --- unexpected token\n\nerror: expected expression, found `/`\n  --> /tmp/tmpjn5c1gme.rs:15:25\n   |\n15 |     let count = w.count(/[a-z]/)\n   |                         ^ expected expression\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpjn5c1gme.rs:21:10\n   |\n11 | fn find_max(words: Vec<String>) -> String {\n   |                                    ------ expected `String` because of return type\n...\n21 |   return max_word\n   |          ^^^^^^^^- help: try using a conversion method: `.to_string()`\n   |          |\n   |          expected struct `String`, found `&str`\n\nerror: aborting due to 4 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function that accepts a vector of strings.\n/// The vector contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n  let max_count = 0\n  let max_word = String::from(\"\")\n  for w in words {\n    let count = w.count(/[a-z]/)\n    if count > max_count {\n      max_count = count\n      max_word = w\n    }\n  }\n  return max_word\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]), String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]), String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]), String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n}\n",
      "timestamp": 1664292578,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmpk2uxpx2c.rs:12:20\n   |\n12 |   let max_count = 0\n   |                    ^ help: add `;` here\n13 |   let max_word = String::from(\"\")\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpk2uxpx2c.rs:13:34\n   |\n13 |   let max_word = String::from(\"\")\n   |                                  ^ help: add `;` here\n14 |   for w in words {\n   |   --- unexpected token\n\nerror: expected expression, found `/`\n  --> /tmp/tmpk2uxpx2c.rs:15:25\n   |\n15 |     let count = w.count(/[a-z]/)\n   |                         ^ expected expression\n\nerror: aborting due to 3 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function that accepts a vector of strings.\n/// The vector contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n  let max_count = 0\n  let max_word = \"\"\n  for w in words {\n    let count = count_unique_chars(w)\n    if count > max_count {\n      max_count = count\n      max_word = w\n    }\n  }\n  return max_word\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]), String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]), String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]), String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n}\n",
      "timestamp": 1664292578,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmp095up2vv.rs:12:20\n   |\n12 |   let max_count = 0\n   |                    ^ help: add `;` here\n13 |   let max_word = \"\"\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmp095up2vv.rs:13:20\n   |\n13 |   let max_word = \"\"\n   |                    ^ help: add `;` here\n14 |   for w in words {\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `if`\n  --> /tmp/tmp095up2vv.rs:15:38\n   |\n15 |     let count = count_unique_chars(w)\n   |                                      ^ help: add `;` here\n16 |     if count > max_count {\n   |     -- unexpected token\n\nerror: expected `;`, found `max_word`\n  --> /tmp/tmp095up2vv.rs:17:24\n   |\n17 |       max_count = count\n   |                        ^ help: add `;` here\n18 |       max_word = w\n   |       -------- unexpected token\n\nerror[E0425]: cannot find function `count_unique_chars` in this scope\n  --> /tmp/tmp095up2vv.rs:15:17\n   |\n15 |     let count = count_unique_chars(w)\n   |                 ^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp095up2vv.rs:18:18\n   |\n13 |   let max_word = \"\"\n   |                  -- expected due to this value\n...\n18 |       max_word = w\n   |                  ^\n   |                  |\n   |                  expected `&str`, found struct `String`\n   |                  help: consider borrowing here: `&w`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp095up2vv.rs:21:10\n   |\n11 | fn find_max(words: Vec<String>) -> String {\n   |                                    ------ expected `String` because of return type\n...\n21 |   return max_word\n   |          ^^^^^^^^- help: try using a conversion method: `.to_string()`\n   |          |\n   |          expected struct `String`, found `&str`\n\nerror: aborting due to 7 previous errors\n\nSome errors have detailed explanations: E0308, E0425.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function that accepts a vector of strings.\n/// The vector contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n  let max_count = 0\n  let max_word = \"\"\n  for w in words {\n    let count = count_unique_chars(w)\n    if count > max_count {\n      max_count = count\n      max_word = w\n    }\n  }\n  return max_word\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]), String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]), String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]), String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n}\n",
      "timestamp": 1664292578,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmp095up2vv.rs:12:20\n   |\n12 |   let max_count = 0\n   |                    ^ help: add `;` here\n13 |   let max_word = \"\"\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmp095up2vv.rs:13:20\n   |\n13 |   let max_word = \"\"\n   |                    ^ help: add `;` here\n14 |   for w in words {\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `if`\n  --> /tmp/tmp095up2vv.rs:15:38\n   |\n15 |     let count = count_unique_chars(w)\n   |                                      ^ help: add `;` here\n16 |     if count > max_count {\n   |     -- unexpected token\n\nerror: expected `;`, found `max_word`\n  --> /tmp/tmp095up2vv.rs:17:24\n   |\n17 |       max_count = count\n   |                        ^ help: add `;` here\n18 |       max_word = w\n   |       -------- unexpected token\n\nerror[E0425]: cannot find function `count_unique_chars` in this scope\n  --> /tmp/tmp095up2vv.rs:15:17\n   |\n15 |     let count = count_unique_chars(w)\n   |                 ^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp095up2vv.rs:18:18\n   |\n13 |   let max_word = \"\"\n   |                  -- expected due to this value\n...\n18 |       max_word = w\n   |                  ^\n   |                  |\n   |                  expected `&str`, found struct `String`\n   |                  help: consider borrowing here: `&w`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp095up2vv.rs:21:10\n   |\n11 | fn find_max(words: Vec<String>) -> String {\n   |                                    ------ expected `String` because of return type\n...\n21 |   return max_word\n   |          ^^^^^^^^- help: try using a conversion method: `.to_string()`\n   |          |\n   |          expected struct `String`, found `&str`\n\nerror: aborting due to 7 previous errors\n\nSome errors have detailed explanations: E0308, E0425.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function that accepts a vector of strings.\n/// The vector contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n  let max_count = 0\n  let max_word = \"\"\n  for w in words {\n    let count = w.count(/[a-z]/);\n    if count > max_count {\n      max_count = count\n      max_word = w\n    }\n  }\n  return max_word\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]), String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]), String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]), String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n}\n",
      "timestamp": 1664292578,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmpk6mb5m3s.rs:12:20\n   |\n12 |   let max_count = 0\n   |                    ^ help: add `;` here\n13 |   let max_word = \"\"\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpk6mb5m3s.rs:13:20\n   |\n13 |   let max_word = \"\"\n   |                    ^ help: add `;` here\n14 |   for w in words {\n   |   --- unexpected token\n\nerror: expected expression, found `/`\n  --> /tmp/tmpk6mb5m3s.rs:15:25\n   |\n15 |     let count = w.count(/[a-z]/);\n   |                         ^ expected expression\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpk6mb5m3s.rs:21:10\n   |\n11 | fn find_max(words: Vec<String>) -> String {\n   |                                    ------ expected `String` because of return type\n...\n21 |   return max_word\n   |          ^^^^^^^^- help: try using a conversion method: `.to_string()`\n   |          |\n   |          expected struct `String`, found `&str`\n\nerror: aborting due to 4 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function that accepts a vector of strings.\n/// The vector contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n  let max_count = 0\n  let max_word = \"\"\n  for w in words {\n    let count = count_unique_chars(w)\n    if count > max_count {\n      max_count = count\n      max_word = w\n    }\n  }\n  return max_word\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]), String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]), String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]), String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n}\n",
      "timestamp": 1664292578,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmp095up2vv.rs:12:20\n   |\n12 |   let max_count = 0\n   |                    ^ help: add `;` here\n13 |   let max_word = \"\"\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmp095up2vv.rs:13:20\n   |\n13 |   let max_word = \"\"\n   |                    ^ help: add `;` here\n14 |   for w in words {\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `if`\n  --> /tmp/tmp095up2vv.rs:15:38\n   |\n15 |     let count = count_unique_chars(w)\n   |                                      ^ help: add `;` here\n16 |     if count > max_count {\n   |     -- unexpected token\n\nerror: expected `;`, found `max_word`\n  --> /tmp/tmp095up2vv.rs:17:24\n   |\n17 |       max_count = count\n   |                        ^ help: add `;` here\n18 |       max_word = w\n   |       -------- unexpected token\n\nerror[E0425]: cannot find function `count_unique_chars` in this scope\n  --> /tmp/tmp095up2vv.rs:15:17\n   |\n15 |     let count = count_unique_chars(w)\n   |                 ^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp095up2vv.rs:18:18\n   |\n13 |   let max_word = \"\"\n   |                  -- expected due to this value\n...\n18 |       max_word = w\n   |                  ^\n   |                  |\n   |                  expected `&str`, found struct `String`\n   |                  help: consider borrowing here: `&w`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp095up2vv.rs:21:10\n   |\n11 | fn find_max(words: Vec<String>) -> String {\n   |                                    ------ expected `String` because of return type\n...\n21 |   return max_word\n   |          ^^^^^^^^- help: try using a conversion method: `.to_string()`\n   |          |\n   |          expected struct `String`, found `&str`\n\nerror: aborting due to 7 previous errors\n\nSome errors have detailed explanations: E0308, E0425.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function that accepts a vector of strings.\n/// The vector contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n  let max_count = 0\n  let max_word = \"\"\n  for word in words {\n    let count = word.count(/[a-z]/)\n    if count > max_count {\n      max_count = count\n      max_word = word\n    }\n  }\n  return max_word\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]), String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]), String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]), String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n}\n",
      "timestamp": 1664292578,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmplz_du44f.rs:12:20\n   |\n12 |   let max_count = 0\n   |                    ^ help: add `;` here\n13 |   let max_word = \"\"\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmplz_du44f.rs:13:20\n   |\n13 |   let max_word = \"\"\n   |                    ^ help: add `;` here\n14 |   for word in words {\n   |   --- unexpected token\n\nerror: expected expression, found `/`\n  --> /tmp/tmplz_du44f.rs:15:28\n   |\n15 |     let count = word.count(/[a-z]/)\n   |                            ^ expected expression\n\nerror[E0308]: mismatched types\n  --> /tmp/tmplz_du44f.rs:21:10\n   |\n11 | fn find_max(words: Vec<String>) -> String {\n   |                                    ------ expected `String` because of return type\n...\n21 |   return max_word\n   |          ^^^^^^^^- help: try using a conversion method: `.to_string()`\n   |          |\n   |          expected struct `String`, found `&str`\n\nerror: aborting due to 4 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function that accepts a vector of strings.\n/// The vector contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n  let max_count = 0\n  let max_word = \"\"\n  for w in words {\n    let count = w.count(/[a-z]/);\n    if count > max_count {\n      max_count = count\n      max_word = w\n    }\n  }\n  return max_word\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]), String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]), String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]), String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n}\n",
      "timestamp": 1664292578,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmpk6mb5m3s.rs:12:20\n   |\n12 |   let max_count = 0\n   |                    ^ help: add `;` here\n13 |   let max_word = \"\"\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpk6mb5m3s.rs:13:20\n   |\n13 |   let max_word = \"\"\n   |                    ^ help: add `;` here\n14 |   for w in words {\n   |   --- unexpected token\n\nerror: expected expression, found `/`\n  --> /tmp/tmpk6mb5m3s.rs:15:25\n   |\n15 |     let count = w.count(/[a-z]/);\n   |                         ^ expected expression\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpk6mb5m3s.rs:21:10\n   |\n11 | fn find_max(words: Vec<String>) -> String {\n   |                                    ------ expected `String` because of return type\n...\n21 |   return max_word\n   |          ^^^^^^^^- help: try using a conversion method: `.to_string()`\n   |          |\n   |          expected struct `String`, found `&str`\n\nerror: aborting due to 4 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function that accepts a vector of strings.\n/// The vector contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n  let max_count = 0;\n  let max_word = String::from(\"\");\n  for (let word of words) {\n    let count = word.count(/[a-z]/);\n    if (count > max_count) {\n      max_count = count;\n      max_word = word;\n    }\n  }\n  return max_word;\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]), String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]), String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]), String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n}\n",
      "timestamp": 1664292578,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmp095_tiv3.rs:14:8\n   |\n14 |   for (let word of words) {\n   |        ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `word`\n  --> /tmp/tmp095_tiv3.rs:14:12\n   |\n14 |   for (let word of words) {\n   |           -^^^^ expected one of `)`, `,`, `@`, or `|`\n   |           |\n   |           help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `of`\n  --> /tmp/tmp095_tiv3.rs:14:17\n   |\n14 |   for (let word of words) {\n   |                -^^ expected one of `)`, `,`, `@`, or `|`\n   |                |\n   |                help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `words`\n  --> /tmp/tmp095_tiv3.rs:14:20\n   |\n14 |   for (let word of words) {\n   |                   -^^^^^ expected one of `)`, `,`, `@`, or `|`\n   |                   |\n   |                   help: missing `,`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmp095_tiv3.rs:14:26\n   |\n14 |   for (let word of words) {\n   |                          ^ help: try adding `in` here\n\nerror: expected expression, found `/`\n  --> /tmp/tmp095_tiv3.rs:15:28\n   |\n15 |     let count = word.count(/[a-z]/);\n   |                            ^ expected expression\n\nerror: expected `{`, found keyword `return`\n  --> /tmp/tmp095_tiv3.rs:21:3\n   |\n21 |   return max_word;\n   |   ^^^^^^ expected `{`\n   |\nhelp: try placing this code inside a block\n   |\n21 |   { return max_word; }\n   |   +                  +\n\nerror: aborting due to 7 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function that accepts a vector of strings.\n/// The vector contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n  let max_count = 0\n  let max_word = \"\"\n  for w in words {\n    let count = count_unique_chars(w)\n    if count > max_count {\n      max_count = count\n      max_word = w\n    }\n  }\n  return max_word\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]), String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]), String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]), String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n}\n",
      "timestamp": 1664292578,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmp095up2vv.rs:12:20\n   |\n12 |   let max_count = 0\n   |                    ^ help: add `;` here\n13 |   let max_word = \"\"\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmp095up2vv.rs:13:20\n   |\n13 |   let max_word = \"\"\n   |                    ^ help: add `;` here\n14 |   for w in words {\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `if`\n  --> /tmp/tmp095up2vv.rs:15:38\n   |\n15 |     let count = count_unique_chars(w)\n   |                                      ^ help: add `;` here\n16 |     if count > max_count {\n   |     -- unexpected token\n\nerror: expected `;`, found `max_word`\n  --> /tmp/tmp095up2vv.rs:17:24\n   |\n17 |       max_count = count\n   |                        ^ help: add `;` here\n18 |       max_word = w\n   |       -------- unexpected token\n\nerror[E0425]: cannot find function `count_unique_chars` in this scope\n  --> /tmp/tmp095up2vv.rs:15:17\n   |\n15 |     let count = count_unique_chars(w)\n   |                 ^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp095up2vv.rs:18:18\n   |\n13 |   let max_word = \"\"\n   |                  -- expected due to this value\n...\n18 |       max_word = w\n   |                  ^\n   |                  |\n   |                  expected `&str`, found struct `String`\n   |                  help: consider borrowing here: `&w`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp095up2vv.rs:21:10\n   |\n11 | fn find_max(words: Vec<String>) -> String {\n   |                                    ------ expected `String` because of return type\n...\n21 |   return max_word\n   |          ^^^^^^^^- help: try using a conversion method: `.to_string()`\n   |          |\n   |          expected struct `String`, found `&str`\n\nerror: aborting due to 7 previous errors\n\nSome errors have detailed explanations: E0308, E0425.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function that accepts a vector of strings.\n/// The vector contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n  let max_count = 0\n  let max_word = String::from(\"\")\n  for w in words {\n    let count = w.count(/[a-z]/);\n    if count > max_count {\n      max_count = count\n      max_word = w\n    }\n  }\n  return max_word\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]), String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]), String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]), String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n}\n",
      "timestamp": 1664292578,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmppewkjxfa.rs:12:20\n   |\n12 |   let max_count = 0\n   |                    ^ help: add `;` here\n13 |   let max_word = String::from(\"\")\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmppewkjxfa.rs:13:34\n   |\n13 |   let max_word = String::from(\"\")\n   |                                  ^ help: add `;` here\n14 |   for w in words {\n   |   --- unexpected token\n\nerror: expected expression, found `/`\n  --> /tmp/tmppewkjxfa.rs:15:25\n   |\n15 |     let count = w.count(/[a-z]/);\n   |                         ^ expected expression\n\nerror: aborting due to 3 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function that accepts a vector of strings.\n/// The vector contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n  let max_count = 0\n  let max_word = \"\"\n  for word in words {\n    let count = word.count(/[a-z]/)\n    if count > max_count {\n      max_count = count\n      max_word = word\n    }\n  }\n  return max_word\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]), String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]), String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]), String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n}\n",
      "timestamp": 1664292578,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmplz_du44f.rs:12:20\n   |\n12 |   let max_count = 0\n   |                    ^ help: add `;` here\n13 |   let max_word = \"\"\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmplz_du44f.rs:13:20\n   |\n13 |   let max_word = \"\"\n   |                    ^ help: add `;` here\n14 |   for word in words {\n   |   --- unexpected token\n\nerror: expected expression, found `/`\n  --> /tmp/tmplz_du44f.rs:15:28\n   |\n15 |     let count = word.count(/[a-z]/)\n   |                            ^ expected expression\n\nerror[E0308]: mismatched types\n  --> /tmp/tmplz_du44f.rs:21:10\n   |\n11 | fn find_max(words: Vec<String>) -> String {\n   |                                    ------ expected `String` because of return type\n...\n21 |   return max_word\n   |          ^^^^^^^^- help: try using a conversion method: `.to_string()`\n   |          |\n   |          expected struct `String`, found `&str`\n\nerror: aborting due to 4 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function that accepts a vector of strings.\n/// The vector contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n  let max_count = 0\n  let max_word = \"\"\n  for w in words {\n    let count = w.count(/[a-z]/)\n    if count > max_count {\n      max_count = count\n      max_word = w\n    }\n  }\n  return max_word\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]), String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]), String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]), String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n}\n",
      "timestamp": 1664292578,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmpjn5c1gme.rs:12:20\n   |\n12 |   let max_count = 0\n   |                    ^ help: add `;` here\n13 |   let max_word = \"\"\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpjn5c1gme.rs:13:20\n   |\n13 |   let max_word = \"\"\n   |                    ^ help: add `;` here\n14 |   for w in words {\n   |   --- unexpected token\n\nerror: expected expression, found `/`\n  --> /tmp/tmpjn5c1gme.rs:15:25\n   |\n15 |     let count = w.count(/[a-z]/)\n   |                         ^ expected expression\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpjn5c1gme.rs:21:10\n   |\n11 | fn find_max(words: Vec<String>) -> String {\n   |                                    ------ expected `String` because of return type\n...\n21 |   return max_word\n   |          ^^^^^^^^- help: try using a conversion method: `.to_string()`\n   |          |\n   |          expected struct `String`, found `&str`\n\nerror: aborting due to 4 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function that accepts a vector of strings.\n/// The vector contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n  let max_count = 0\n  let max_word = \"\"\n  for w in words {\n    let count = count_unique_chars(w)\n    if count > max_count {\n      max_count = count\n      max_word = w\n    }\n  }\n  return max_word\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]), String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]), String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]), String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n}\n",
      "timestamp": 1664292578,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmp095up2vv.rs:12:20\n   |\n12 |   let max_count = 0\n   |                    ^ help: add `;` here\n13 |   let max_word = \"\"\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmp095up2vv.rs:13:20\n   |\n13 |   let max_word = \"\"\n   |                    ^ help: add `;` here\n14 |   for w in words {\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `if`\n  --> /tmp/tmp095up2vv.rs:15:38\n   |\n15 |     let count = count_unique_chars(w)\n   |                                      ^ help: add `;` here\n16 |     if count > max_count {\n   |     -- unexpected token\n\nerror: expected `;`, found `max_word`\n  --> /tmp/tmp095up2vv.rs:17:24\n   |\n17 |       max_count = count\n   |                        ^ help: add `;` here\n18 |       max_word = w\n   |       -------- unexpected token\n\nerror[E0425]: cannot find function `count_unique_chars` in this scope\n  --> /tmp/tmp095up2vv.rs:15:17\n   |\n15 |     let count = count_unique_chars(w)\n   |                 ^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp095up2vv.rs:18:18\n   |\n13 |   let max_word = \"\"\n   |                  -- expected due to this value\n...\n18 |       max_word = w\n   |                  ^\n   |                  |\n   |                  expected `&str`, found struct `String`\n   |                  help: consider borrowing here: `&w`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp095up2vv.rs:21:10\n   |\n11 | fn find_max(words: Vec<String>) -> String {\n   |                                    ------ expected `String` because of return type\n...\n21 |   return max_word\n   |          ^^^^^^^^- help: try using a conversion method: `.to_string()`\n   |          |\n   |          expected struct `String`, found `&str`\n\nerror: aborting due to 7 previous errors\n\nSome errors have detailed explanations: E0308, E0425.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function that accepts a vector of strings.\n/// The vector contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n  let max_count = 0\n  let max_word = \"\"\n  for w in words {\n    let count = count_unique_chars(w)\n    if count > max_count {\n      max_count = count\n      max_word = w\n    }\n  }\n  return max_word\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]), String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]), String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]), String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n}\n",
      "timestamp": 1664292578,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmp095up2vv.rs:12:20\n   |\n12 |   let max_count = 0\n   |                    ^ help: add `;` here\n13 |   let max_word = \"\"\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmp095up2vv.rs:13:20\n   |\n13 |   let max_word = \"\"\n   |                    ^ help: add `;` here\n14 |   for w in words {\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `if`\n  --> /tmp/tmp095up2vv.rs:15:38\n   |\n15 |     let count = count_unique_chars(w)\n   |                                      ^ help: add `;` here\n16 |     if count > max_count {\n   |     -- unexpected token\n\nerror: expected `;`, found `max_word`\n  --> /tmp/tmp095up2vv.rs:17:24\n   |\n17 |       max_count = count\n   |                        ^ help: add `;` here\n18 |       max_word = w\n   |       -------- unexpected token\n\nerror[E0425]: cannot find function `count_unique_chars` in this scope\n  --> /tmp/tmp095up2vv.rs:15:17\n   |\n15 |     let count = count_unique_chars(w)\n   |                 ^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp095up2vv.rs:18:18\n   |\n13 |   let max_word = \"\"\n   |                  -- expected due to this value\n...\n18 |       max_word = w\n   |                  ^\n   |                  |\n   |                  expected `&str`, found struct `String`\n   |                  help: consider borrowing here: `&w`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp095up2vv.rs:21:10\n   |\n11 | fn find_max(words: Vec<String>) -> String {\n   |                                    ------ expected `String` because of return type\n...\n21 |   return max_word\n   |          ^^^^^^^^- help: try using a conversion method: `.to_string()`\n   |          |\n   |          expected struct `String`, found `&str`\n\nerror: aborting due to 7 previous errors\n\nSome errors have detailed explanations: E0308, E0425.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function that accepts a vector of strings.\n/// The vector contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n  let max_count = 0\n  let max_word = String::from(\"\")\n  for w in words {\n    let count = w.count(/[a-z]/);\n    if count > max_count {\n      max_count = count\n      max_word = w\n    }\n  }\n  return max_word\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]), String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]), String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]), String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n}\n",
      "timestamp": 1664292578,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmppewkjxfa.rs:12:20\n   |\n12 |   let max_count = 0\n   |                    ^ help: add `;` here\n13 |   let max_word = String::from(\"\")\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmppewkjxfa.rs:13:34\n   |\n13 |   let max_word = String::from(\"\")\n   |                                  ^ help: add `;` here\n14 |   for w in words {\n   |   --- unexpected token\n\nerror: expected expression, found `/`\n  --> /tmp/tmppewkjxfa.rs:15:25\n   |\n15 |     let count = w.count(/[a-z]/);\n   |                         ^ expected expression\n\nerror: aborting due to 3 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function that accepts a vector of strings.\n/// The vector contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n  let max_count = 0\n  let max_word = \"\"\n  for w in words {\n    let count = w.count(/[a-z]/);\n    if count > max_count {\n      max_count = count\n      max_word = w\n    }\n  }\n  return max_word\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]), String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]), String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]), String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n}\n",
      "timestamp": 1664292578,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmpk6mb5m3s.rs:12:20\n   |\n12 |   let max_count = 0\n   |                    ^ help: add `;` here\n13 |   let max_word = \"\"\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpk6mb5m3s.rs:13:20\n   |\n13 |   let max_word = \"\"\n   |                    ^ help: add `;` here\n14 |   for w in words {\n   |   --- unexpected token\n\nerror: expected expression, found `/`\n  --> /tmp/tmpk6mb5m3s.rs:15:25\n   |\n15 |     let count = w.count(/[a-z]/);\n   |                         ^ expected expression\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpk6mb5m3s.rs:21:10\n   |\n11 | fn find_max(words: Vec<String>) -> String {\n   |                                    ------ expected `String` because of return type\n...\n21 |   return max_word\n   |          ^^^^^^^^- help: try using a conversion method: `.to_string()`\n   |          |\n   |          expected struct `String`, found `&str`\n\nerror: aborting due to 4 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function that accepts a vector of strings.\n/// The vector contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n  let max_count = 0\n  let max_word = \"\"\n  for w in words {\n    let count = w.count(/[a-z]/);\n    if count > max_count {\n      max_count = count\n      max_word = w\n    }\n  }\n  return max_word\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]), String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]), String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]), String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n}\n",
      "timestamp": 1664292578,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmpk6mb5m3s.rs:12:20\n   |\n12 |   let max_count = 0\n   |                    ^ help: add `;` here\n13 |   let max_word = \"\"\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpk6mb5m3s.rs:13:20\n   |\n13 |   let max_word = \"\"\n   |                    ^ help: add `;` here\n14 |   for w in words {\n   |   --- unexpected token\n\nerror: expected expression, found `/`\n  --> /tmp/tmpk6mb5m3s.rs:15:25\n   |\n15 |     let count = w.count(/[a-z]/);\n   |                         ^ expected expression\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpk6mb5m3s.rs:21:10\n   |\n11 | fn find_max(words: Vec<String>) -> String {\n   |                                    ------ expected `String` because of return type\n...\n21 |   return max_word\n   |          ^^^^^^^^- help: try using a conversion method: `.to_string()`\n   |          |\n   |          expected struct `String`, found `&str`\n\nerror: aborting due to 4 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function that accepts a vector of strings.\n/// The vector contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n  let max_count = 0\n  let max_word = \"\"\n  for w in words {\n    let count = count_unique_chars(w)\n    if count > max_count {\n      max_count = count\n      max_word = w\n    }\n  }\n  return max_word\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]), String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]), String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]), String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n}\n",
      "timestamp": 1664292578,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmp095up2vv.rs:12:20\n   |\n12 |   let max_count = 0\n   |                    ^ help: add `;` here\n13 |   let max_word = \"\"\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmp095up2vv.rs:13:20\n   |\n13 |   let max_word = \"\"\n   |                    ^ help: add `;` here\n14 |   for w in words {\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `if`\n  --> /tmp/tmp095up2vv.rs:15:38\n   |\n15 |     let count = count_unique_chars(w)\n   |                                      ^ help: add `;` here\n16 |     if count > max_count {\n   |     -- unexpected token\n\nerror: expected `;`, found `max_word`\n  --> /tmp/tmp095up2vv.rs:17:24\n   |\n17 |       max_count = count\n   |                        ^ help: add `;` here\n18 |       max_word = w\n   |       -------- unexpected token\n\nerror[E0425]: cannot find function `count_unique_chars` in this scope\n  --> /tmp/tmp095up2vv.rs:15:17\n   |\n15 |     let count = count_unique_chars(w)\n   |                 ^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp095up2vv.rs:18:18\n   |\n13 |   let max_word = \"\"\n   |                  -- expected due to this value\n...\n18 |       max_word = w\n   |                  ^\n   |                  |\n   |                  expected `&str`, found struct `String`\n   |                  help: consider borrowing here: `&w`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp095up2vv.rs:21:10\n   |\n11 | fn find_max(words: Vec<String>) -> String {\n   |                                    ------ expected `String` because of return type\n...\n21 |   return max_word\n   |          ^^^^^^^^- help: try using a conversion method: `.to_string()`\n   |          |\n   |          expected struct `String`, found `&str`\n\nerror: aborting due to 7 previous errors\n\nSome errors have detailed explanations: E0308, E0425.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function that accepts a vector of strings.\n/// The vector contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n  let max_count = 0\n  let max_word = \"\"\n  for w in words {\n    let count = 0\n    for i in w.chars() {\n      if i.is_upper() {\n        count += 1\n      }\n    }\n    if count > max_count {\n      max_count = count\n      max_word = w\n    }\n  }\n  return max_word\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]), String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]), String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]), String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n}\n",
      "timestamp": 1664292578,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmpy9pf9rlw.rs:12:20\n   |\n12 |   let max_count = 0\n   |                    ^ help: add `;` here\n13 |   let max_word = \"\"\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpy9pf9rlw.rs:13:20\n   |\n13 |   let max_word = \"\"\n   |                    ^ help: add `;` here\n14 |   for w in words {\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpy9pf9rlw.rs:15:18\n   |\n15 |     let count = 0\n   |                  ^ help: add `;` here\n16 |     for i in w.chars() {\n   |     --- unexpected token\n\nerror: expected `;`, found `max_word`\n  --> /tmp/tmpy9pf9rlw.rs:22:24\n   |\n22 |       max_count = count\n   |                        ^ help: add `;` here\n23 |       max_word = w\n   |       -------- unexpected token\n\nerror[E0599]: no method named `is_upper` found for type `char` in the current scope\n  --> /tmp/tmpy9pf9rlw.rs:17:12\n   |\n17 |       if i.is_upper() {\n   |            ^^^^^^^^ help: there is an associated function with a similar name: `is_uppercase`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpy9pf9rlw.rs:23:18\n   |\n13 |   let max_word = \"\"\n   |                  -- expected due to this value\n...\n23 |       max_word = w\n   |                  ^\n   |                  |\n   |                  expected `&str`, found struct `String`\n   |                  help: consider borrowing here: `&w`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpy9pf9rlw.rs:26:10\n   |\n11 | fn find_max(words: Vec<String>) -> String {\n   |                                    ------ expected `String` because of return type\n...\n26 |   return max_word\n   |          ^^^^^^^^- help: try using a conversion method: `.to_string()`\n   |          |\n   |          expected struct `String`, found `&str`\n\nerror: aborting due to 7 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function that accepts a vector of strings.\n/// The vector contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n  let max_count = 0\n  let max_word = \"\"\n  for word in words {\n    let count = count_unique_chars(word)\n    if count > max_count {\n      max_count = count\n      max_word = word\n    }\n  }\n  return max_word\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]), String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]), String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]), String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n}\n",
      "timestamp": 1664292578,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmpblowsbak.rs:12:20\n   |\n12 |   let max_count = 0\n   |                    ^ help: add `;` here\n13 |   let max_word = \"\"\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpblowsbak.rs:13:20\n   |\n13 |   let max_word = \"\"\n   |                    ^ help: add `;` here\n14 |   for word in words {\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `if`\n  --> /tmp/tmpblowsbak.rs:15:41\n   |\n15 |     let count = count_unique_chars(word)\n   |                                         ^ help: add `;` here\n16 |     if count > max_count {\n   |     -- unexpected token\n\nerror: expected `;`, found `max_word`\n  --> /tmp/tmpblowsbak.rs:17:24\n   |\n17 |       max_count = count\n   |                        ^ help: add `;` here\n18 |       max_word = word\n   |       -------- unexpected token\n\nerror[E0425]: cannot find function `count_unique_chars` in this scope\n  --> /tmp/tmpblowsbak.rs:15:17\n   |\n15 |     let count = count_unique_chars(word)\n   |                 ^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpblowsbak.rs:18:18\n   |\n13 |   let max_word = \"\"\n   |                  -- expected due to this value\n...\n18 |       max_word = word\n   |                  ^^^^\n   |                  |\n   |                  expected `&str`, found struct `String`\n   |                  help: consider borrowing here: `&word`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpblowsbak.rs:21:10\n   |\n11 | fn find_max(words: Vec<String>) -> String {\n   |                                    ------ expected `String` because of return type\n...\n21 |   return max_word\n   |          ^^^^^^^^- help: try using a conversion method: `.to_string()`\n   |          |\n   |          expected struct `String`, found `&str`\n\nerror: aborting due to 7 previous errors\n\nSome errors have detailed explanations: E0308, E0425.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function that accepts a vector of strings.\n/// The vector contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n  let max_count = 0\n  let max_word = \"\"\n  for w in words {\n    let count = w.count(/[a-z]/)\n    if count > max_count {\n      max_count = count\n      max_word = w\n    }\n  }\n  return max_word\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]), String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]), String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]), String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n}\n",
      "timestamp": 1664292578,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmpjn5c1gme.rs:12:20\n   |\n12 |   let max_count = 0\n   |                    ^ help: add `;` here\n13 |   let max_word = \"\"\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpjn5c1gme.rs:13:20\n   |\n13 |   let max_word = \"\"\n   |                    ^ help: add `;` here\n14 |   for w in words {\n   |   --- unexpected token\n\nerror: expected expression, found `/`\n  --> /tmp/tmpjn5c1gme.rs:15:25\n   |\n15 |     let count = w.count(/[a-z]/)\n   |                         ^ expected expression\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpjn5c1gme.rs:21:10\n   |\n11 | fn find_max(words: Vec<String>) -> String {\n   |                                    ------ expected `String` because of return type\n...\n21 |   return max_word\n   |          ^^^^^^^^- help: try using a conversion method: `.to_string()`\n   |          |\n   |          expected struct `String`, found `&str`\n\nerror: aborting due to 4 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function that accepts a vector of strings.\n/// The vector contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n  let max_count = 0\n  let max_word = \"\"\n  for word in words {\n    let count = word.count(/[a-z]/)\n    if count > max_count {\n      max_count = count\n      max_word = word\n    }\n  }\n  return max_word\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]), String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]), String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]), String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n}\n",
      "timestamp": 1664292578,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmplz_du44f.rs:12:20\n   |\n12 |   let max_count = 0\n   |                    ^ help: add `;` here\n13 |   let max_word = \"\"\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmplz_du44f.rs:13:20\n   |\n13 |   let max_word = \"\"\n   |                    ^ help: add `;` here\n14 |   for word in words {\n   |   --- unexpected token\n\nerror: expected expression, found `/`\n  --> /tmp/tmplz_du44f.rs:15:28\n   |\n15 |     let count = word.count(/[a-z]/)\n   |                            ^ expected expression\n\nerror[E0308]: mismatched types\n  --> /tmp/tmplz_du44f.rs:21:10\n   |\n11 | fn find_max(words: Vec<String>) -> String {\n   |                                    ------ expected `String` because of return type\n...\n21 |   return max_word\n   |          ^^^^^^^^- help: try using a conversion method: `.to_string()`\n   |          |\n   |          expected struct `String`, found `&str`\n\nerror: aborting due to 4 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function that accepts a vector of strings.\n/// The vector contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n  let max_count = 0\n  let max_word = \"\"\n  for w in words {\n    let count = 0\n    for i in 0..len(w) {\n      if w[i] == w[i+1] {\n        count += 1\n      }\n    }\n    if count > max_count {\n      max_count = count\n      max_word = w\n    }\n  }\n  return max_word\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]), String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]), String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]), String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n}\n",
      "timestamp": 1664292578,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmpj8aqwzv6.rs:12:20\n   |\n12 |   let max_count = 0\n   |                    ^ help: add `;` here\n13 |   let max_word = \"\"\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpj8aqwzv6.rs:13:20\n   |\n13 |   let max_word = \"\"\n   |                    ^ help: add `;` here\n14 |   for w in words {\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpj8aqwzv6.rs:15:18\n   |\n15 |     let count = 0\n   |                  ^ help: add `;` here\n16 |     for i in 0..len(w) {\n   |     --- unexpected token\n\nerror: expected `;`, found `max_word`\n  --> /tmp/tmpj8aqwzv6.rs:22:24\n   |\n22 |       max_count = count\n   |                        ^ help: add `;` here\n23 |       max_word = w\n   |       -------- unexpected token\n\nerror[E0425]: cannot find function `len` in this scope\n  --> /tmp/tmpj8aqwzv6.rs:16:17\n   |\n16 |     for i in 0..len(w) {\n   |                 ^^^ not found in this scope\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmpj8aqwzv6.rs:17:10\n   |\n17 |       if w[i] == w[i+1] {\n   |          ^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmpj8aqwzv6.rs:17:18\n   |\n17 |       if w[i] == w[i+1] {\n   |                  ^^^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<Ra",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function that accepts a vector of strings.\n/// The vector contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n  let max_count = 0\n  let max_word = \"\"\n  for w in words {\n    let count = w.count(/[a-z]/)\n    if count > max_count {\n      max_count = count\n      max_word = w\n    }\n  }\n  return max_word\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]), String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]), String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]), String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n}\n",
      "timestamp": 1664292578,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmpjn5c1gme.rs:12:20\n   |\n12 |   let max_count = 0\n   |                    ^ help: add `;` here\n13 |   let max_word = \"\"\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpjn5c1gme.rs:13:20\n   |\n13 |   let max_word = \"\"\n   |                    ^ help: add `;` here\n14 |   for w in words {\n   |   --- unexpected token\n\nerror: expected expression, found `/`\n  --> /tmp/tmpjn5c1gme.rs:15:25\n   |\n15 |     let count = w.count(/[a-z]/)\n   |                         ^ expected expression\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpjn5c1gme.rs:21:10\n   |\n11 | fn find_max(words: Vec<String>) -> String {\n   |                                    ------ expected `String` because of return type\n...\n21 |   return max_word\n   |          ^^^^^^^^- help: try using a conversion method: `.to_string()`\n   |          |\n   |          expected struct `String`, found `&str`\n\nerror: aborting due to 4 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function that accepts a vector of strings.\n/// The vector contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n  let max_count = 0\n  let max_word = \"\"\n  for word in words {\n    let count = word.count(/[a-z]/);\n    if count > max_count {\n      max_count = count\n      max_word = word\n    }\n  }\n  return max_word\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]), String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]), String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]), String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n}\n",
      "timestamp": 1664292578,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmpsfumfyuh.rs:12:20\n   |\n12 |   let max_count = 0\n   |                    ^ help: add `;` here\n13 |   let max_word = \"\"\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpsfumfyuh.rs:13:20\n   |\n13 |   let max_word = \"\"\n   |                    ^ help: add `;` here\n14 |   for word in words {\n   |   --- unexpected token\n\nerror: expected expression, found `/`\n  --> /tmp/tmpsfumfyuh.rs:15:28\n   |\n15 |     let count = word.count(/[a-z]/);\n   |                            ^ expected expression\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpsfumfyuh.rs:21:10\n   |\n11 | fn find_max(words: Vec<String>) -> String {\n   |                                    ------ expected `String` because of return type\n...\n21 |   return max_word\n   |          ^^^^^^^^- help: try using a conversion method: `.to_string()`\n   |          |\n   |          expected struct `String`, found `&str`\n\nerror: aborting due to 4 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function that accepts a vector of strings.\n/// The vector contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n  let max_count = 0\n  let max_word = String::from(\"\")\n  for word in words {\n    let count = count_unique_chars(word)\n    if count > max_count {\n      max_count = count\n      max_word = word\n    }\n  }\n  return max_word\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]), String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]), String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]), String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n}\n",
      "timestamp": 1664292578,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmpxpe2iddk.rs:12:20\n   |\n12 |   let max_count = 0\n   |                    ^ help: add `;` here\n13 |   let max_word = String::from(\"\")\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpxpe2iddk.rs:13:34\n   |\n13 |   let max_word = String::from(\"\")\n   |                                  ^ help: add `;` here\n14 |   for word in words {\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `if`\n  --> /tmp/tmpxpe2iddk.rs:15:41\n   |\n15 |     let count = count_unique_chars(word)\n   |                                         ^ help: add `;` here\n16 |     if count > max_count {\n   |     -- unexpected token\n\nerror: expected `;`, found `max_word`\n  --> /tmp/tmpxpe2iddk.rs:17:24\n   |\n17 |       max_count = count\n   |                        ^ help: add `;` here\n18 |       max_word = word\n   |       -------- unexpected token\n\nerror[E0425]: cannot find function `count_unique_chars` in this scope\n  --> /tmp/tmpxpe2iddk.rs:15:17\n   |\n15 |     let count = count_unique_chars(word)\n   |                 ^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to 5 previous errors\n\nFor more information about this error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function that accepts a vector of strings.\n/// The vector contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n  let max_count = 0\n  let max_word = String::from(\"\")\n  for word in words {\n    let count = count_unique_chars(word)\n    if count > max_count {\n      max_count = count\n      max_word = word\n    }\n  }\n  return max_word\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]), String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]), String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]), String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n}\n",
      "timestamp": 1664292578,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmpxpe2iddk.rs:12:20\n   |\n12 |   let max_count = 0\n   |                    ^ help: add `;` here\n13 |   let max_word = String::from(\"\")\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpxpe2iddk.rs:13:34\n   |\n13 |   let max_word = String::from(\"\")\n   |                                  ^ help: add `;` here\n14 |   for word in words {\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `if`\n  --> /tmp/tmpxpe2iddk.rs:15:41\n   |\n15 |     let count = count_unique_chars(word)\n   |                                         ^ help: add `;` here\n16 |     if count > max_count {\n   |     -- unexpected token\n\nerror: expected `;`, found `max_word`\n  --> /tmp/tmpxpe2iddk.rs:17:24\n   |\n17 |       max_count = count\n   |                        ^ help: add `;` here\n18 |       max_word = word\n   |       -------- unexpected token\n\nerror[E0425]: cannot find function `count_unique_chars` in this scope\n  --> /tmp/tmpxpe2iddk.rs:15:17\n   |\n15 |     let count = count_unique_chars(word)\n   |                 ^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to 5 previous errors\n\nFor more information about this error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function that accepts a vector of strings.\n/// The vector contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n  let max_count = 0\n  let max_word = \"\"\n  for w in words {\n    let count = w.count_unique_chars()\n    if count > max_count {\n      max_count = count\n      max_word = w\n    }\n  }\n  return max_word\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]), String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]), String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]), String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n}\n",
      "timestamp": 1664292578,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmp83xgxfl_.rs:12:20\n   |\n12 |   let max_count = 0\n   |                    ^ help: add `;` here\n13 |   let max_word = \"\"\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmp83xgxfl_.rs:13:20\n   |\n13 |   let max_word = \"\"\n   |                    ^ help: add `;` here\n14 |   for w in words {\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `if`\n  --> /tmp/tmp83xgxfl_.rs:15:39\n   |\n15 |     let count = w.count_unique_chars()\n   |                                       ^ help: add `;` here\n16 |     if count > max_count {\n   |     -- unexpected token\n\nerror: expected `;`, found `max_word`\n  --> /tmp/tmp83xgxfl_.rs:17:24\n   |\n17 |       max_count = count\n   |                        ^ help: add `;` here\n18 |       max_word = w\n   |       -------- unexpected token\n\nerror[E0599]: no method named `count_unique_chars` found for struct `String` in the current scope\n  --> /tmp/tmp83xgxfl_.rs:15:19\n   |\n15 |     let count = w.count_unique_chars()\n   |                   ^^^^^^^^^^^^^^^^^^ method not found in `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp83xgxfl_.rs:18:18\n   |\n13 |   let max_word = \"\"\n   |                  -- expected due to this value\n...\n18 |       max_word = w\n   |                  ^\n   |                  |\n   |                  expected `&str`, found struct `String`\n   |                  help: consider borrowing here: `&w`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp83xgxfl_.rs:21:10\n   |\n11 | fn find_max(words: Vec<String>) -> String {\n   |                                    ------ expected `String` because of return type\n...\n21 |   return max_word\n   |          ^^^^^^^^- help: try using a conversion method: `.to_string()`\n   |          |\n   |          expected struct `String`, found `&str`\n\nerror: aborting due to 7 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function that accepts a vector of strings.\n/// The vector contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n  let max_count = 0\n  let max_word = \"\"\n  for w in words {\n    let count = w.count(/[a-z]/);\n    if count > max_count {\n      max_count = count\n      max_word = w\n    }\n  }\n  return max_word\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]), String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]), String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]), String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n}\n",
      "timestamp": 1664292578,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmpk6mb5m3s.rs:12:20\n   |\n12 |   let max_count = 0\n   |                    ^ help: add `;` here\n13 |   let max_word = \"\"\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpk6mb5m3s.rs:13:20\n   |\n13 |   let max_word = \"\"\n   |                    ^ help: add `;` here\n14 |   for w in words {\n   |   --- unexpected token\n\nerror: expected expression, found `/`\n  --> /tmp/tmpk6mb5m3s.rs:15:25\n   |\n15 |     let count = w.count(/[a-z]/);\n   |                         ^ expected expression\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpk6mb5m3s.rs:21:10\n   |\n11 | fn find_max(words: Vec<String>) -> String {\n   |                                    ------ expected `String` because of return type\n...\n21 |   return max_word\n   |          ^^^^^^^^- help: try using a conversion method: `.to_string()`\n   |          |\n   |          expected struct `String`, found `&str`\n\nerror: aborting due to 4 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function that accepts a vector of strings.\n/// The vector contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n  let max_count = 0\n  let max_word = \"\"\n  for w in words {\n    let count = w.count(/[a-z]/);\n    if count > max_count {\n      max_count = count\n      max_word = w\n    }\n  }\n  return max_word\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]), String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]), String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]), String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n}\n",
      "timestamp": 1664292578,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmpk6mb5m3s.rs:12:20\n   |\n12 |   let max_count = 0\n   |                    ^ help: add `;` here\n13 |   let max_word = \"\"\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpk6mb5m3s.rs:13:20\n   |\n13 |   let max_word = \"\"\n   |                    ^ help: add `;` here\n14 |   for w in words {\n   |   --- unexpected token\n\nerror: expected expression, found `/`\n  --> /tmp/tmpk6mb5m3s.rs:15:25\n   |\n15 |     let count = w.count(/[a-z]/);\n   |                         ^ expected expression\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpk6mb5m3s.rs:21:10\n   |\n11 | fn find_max(words: Vec<String>) -> String {\n   |                                    ------ expected `String` because of return type\n...\n21 |   return max_word\n   |          ^^^^^^^^- help: try using a conversion method: `.to_string()`\n   |          |\n   |          expected struct `String`, found `&str`\n\nerror: aborting due to 4 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function that accepts a vector of strings.\n/// The vector contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n  let max_count = 0\n  let max_word = \"\"\n  for w in words {\n    let count = count_unique_chars(w)\n    if count > max_count {\n      max_count = count\n      max_word = w\n    }\n  }\n  return max_word\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]), String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]), String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]), String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n}\n",
      "timestamp": 1664292578,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmp095up2vv.rs:12:20\n   |\n12 |   let max_count = 0\n   |                    ^ help: add `;` here\n13 |   let max_word = \"\"\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmp095up2vv.rs:13:20\n   |\n13 |   let max_word = \"\"\n   |                    ^ help: add `;` here\n14 |   for w in words {\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `if`\n  --> /tmp/tmp095up2vv.rs:15:38\n   |\n15 |     let count = count_unique_chars(w)\n   |                                      ^ help: add `;` here\n16 |     if count > max_count {\n   |     -- unexpected token\n\nerror: expected `;`, found `max_word`\n  --> /tmp/tmp095up2vv.rs:17:24\n   |\n17 |       max_count = count\n   |                        ^ help: add `;` here\n18 |       max_word = w\n   |       -------- unexpected token\n\nerror[E0425]: cannot find function `count_unique_chars` in this scope\n  --> /tmp/tmp095up2vv.rs:15:17\n   |\n15 |     let count = count_unique_chars(w)\n   |                 ^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp095up2vv.rs:18:18\n   |\n13 |   let max_word = \"\"\n   |                  -- expected due to this value\n...\n18 |       max_word = w\n   |                  ^\n   |                  |\n   |                  expected `&str`, found struct `String`\n   |                  help: consider borrowing here: `&w`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp095up2vv.rs:21:10\n   |\n11 | fn find_max(words: Vec<String>) -> String {\n   |                                    ------ expected `String` because of return type\n...\n21 |   return max_word\n   |          ^^^^^^^^- help: try using a conversion method: `.to_string()`\n   |          |\n   |          expected struct `String`, found `&str`\n\nerror: aborting due to 7 previous errors\n\nSome errors have detailed explanations: E0308, E0425.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function that accepts a vector of strings.\n/// The vector contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n  let max_count = 0\n  let max_word = \"\"\n  for w in words {\n    let count = 0\n    for c in w {\n      if c == ' ' {\n        continue\n      }\n      count += 1\n    }\n    if count > max_count {\n      max_count = count\n      max_word = w\n    }\n  }\n  return max_word\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]), String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]), String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]), String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n}\n",
      "timestamp": 1664292578,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmpecei6001.rs:12:20\n   |\n12 |   let max_count = 0\n   |                    ^ help: add `;` here\n13 |   let max_word = \"\"\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpecei6001.rs:13:20\n   |\n13 |   let max_word = \"\"\n   |                    ^ help: add `;` here\n14 |   for w in words {\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpecei6001.rs:15:18\n   |\n15 |     let count = 0\n   |                  ^ help: add `;` here\n16 |     for c in w {\n   |     --- unexpected token\n\nerror: expected `;`, found `max_word`\n  --> /tmp/tmpecei6001.rs:23:24\n   |\n23 |       max_count = count\n   |                        ^ help: add `;` here\n24 |       max_word = w\n   |       -------- unexpected token\n\nerror[E0277]: `String` is not an iterator\n  --> /tmp/tmpecei6001.rs:16:14\n   |\n16 |     for c in w {\n   |              ^ `String` is not an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait `Iterator` is not implemented for `String`\n   = note: required because of the requirements on the impl of `IntoIterator` for `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpecei6001.rs:24:18\n   |\n13 |   let max_word = \"\"\n   |                  -- expected due to this value\n...\n24 |       max_word = w\n   |                  ^\n   |                  |\n   |                  expected `&str`, found struct `String`\n   |                  help: consider borrowing here: `&w`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpecei6001.rs:27:10\n   |\n11 | fn find_max(words: Vec<String>) -> String {\n   |                                    ------ expected `String` because of return type\n...\n27 |   return max_word\n   |          ^^^^^^^^- help: try using a conversion method: `.to_string()`\n   |          |\n   |          expected struct `String`, found `&str`\n\nerror: aborting due to 7 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function that accepts a vector of strings.\n/// The vector contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n  let max_count = 0\n  let max_word = String::from(\"\")\n  for word in words {\n    let count = count_unique_chars(word)\n    if count > max_count {\n      max_count = count\n      max_word = word\n    }\n  }\n  return max_word\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]), String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]), String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]), String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n}\n",
      "timestamp": 1664292578,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmpxpe2iddk.rs:12:20\n   |\n12 |   let max_count = 0\n   |                    ^ help: add `;` here\n13 |   let max_word = String::from(\"\")\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpxpe2iddk.rs:13:34\n   |\n13 |   let max_word = String::from(\"\")\n   |                                  ^ help: add `;` here\n14 |   for word in words {\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `if`\n  --> /tmp/tmpxpe2iddk.rs:15:41\n   |\n15 |     let count = count_unique_chars(word)\n   |                                         ^ help: add `;` here\n16 |     if count > max_count {\n   |     -- unexpected token\n\nerror: expected `;`, found `max_word`\n  --> /tmp/tmpxpe2iddk.rs:17:24\n   |\n17 |       max_count = count\n   |                        ^ help: add `;` here\n18 |       max_word = word\n   |       -------- unexpected token\n\nerror[E0425]: cannot find function `count_unique_chars` in this scope\n  --> /tmp/tmpxpe2iddk.rs:15:17\n   |\n15 |     let count = count_unique_chars(word)\n   |                 ^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to 5 previous errors\n\nFor more information about this error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function that accepts a vector of strings.\n/// The vector contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n  let max_count = 0\n  let max_word = \"\"\n  for w in words {\n    let count = w.count_unique_chars()\n    if count > max_count {\n      max_count = count\n      max_word = w\n    }\n  }\n  return max_word\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]), String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]), String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]), String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n}\n",
      "timestamp": 1664292578,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmp83xgxfl_.rs:12:20\n   |\n12 |   let max_count = 0\n   |                    ^ help: add `;` here\n13 |   let max_word = \"\"\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmp83xgxfl_.rs:13:20\n   |\n13 |   let max_word = \"\"\n   |                    ^ help: add `;` here\n14 |   for w in words {\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `if`\n  --> /tmp/tmp83xgxfl_.rs:15:39\n   |\n15 |     let count = w.count_unique_chars()\n   |                                       ^ help: add `;` here\n16 |     if count > max_count {\n   |     -- unexpected token\n\nerror: expected `;`, found `max_word`\n  --> /tmp/tmp83xgxfl_.rs:17:24\n   |\n17 |       max_count = count\n   |                        ^ help: add `;` here\n18 |       max_word = w\n   |       -------- unexpected token\n\nerror[E0599]: no method named `count_unique_chars` found for struct `String` in the current scope\n  --> /tmp/tmp83xgxfl_.rs:15:19\n   |\n15 |     let count = w.count_unique_chars()\n   |                   ^^^^^^^^^^^^^^^^^^ method not found in `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp83xgxfl_.rs:18:18\n   |\n13 |   let max_word = \"\"\n   |                  -- expected due to this value\n...\n18 |       max_word = w\n   |                  ^\n   |                  |\n   |                  expected `&str`, found struct `String`\n   |                  help: consider borrowing here: `&w`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp83xgxfl_.rs:21:10\n   |\n11 | fn find_max(words: Vec<String>) -> String {\n   |                                    ------ expected `String` because of return type\n...\n21 |   return max_word\n   |          ^^^^^^^^- help: try using a conversion method: `.to_string()`\n   |          |\n   |          expected struct `String`, found `&str`\n\nerror: aborting due to 7 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function that accepts a vector of strings.\n/// The vector contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n  let max_count = 0\n  let max_word = \"\"\n  for w in words {\n    let count = count_unique_chars(w)\n    if count > max_count {\n      max_count = count\n      max_word = w\n    }\n  }\n  return max_word\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]), String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]), String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]), String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n}\n",
      "timestamp": 1664292578,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmp095up2vv.rs:12:20\n   |\n12 |   let max_count = 0\n   |                    ^ help: add `;` here\n13 |   let max_word = \"\"\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmp095up2vv.rs:13:20\n   |\n13 |   let max_word = \"\"\n   |                    ^ help: add `;` here\n14 |   for w in words {\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `if`\n  --> /tmp/tmp095up2vv.rs:15:38\n   |\n15 |     let count = count_unique_chars(w)\n   |                                      ^ help: add `;` here\n16 |     if count > max_count {\n   |     -- unexpected token\n\nerror: expected `;`, found `max_word`\n  --> /tmp/tmp095up2vv.rs:17:24\n   |\n17 |       max_count = count\n   |                        ^ help: add `;` here\n18 |       max_word = w\n   |       -------- unexpected token\n\nerror[E0425]: cannot find function `count_unique_chars` in this scope\n  --> /tmp/tmp095up2vv.rs:15:17\n   |\n15 |     let count = count_unique_chars(w)\n   |                 ^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp095up2vv.rs:18:18\n   |\n13 |   let max_word = \"\"\n   |                  -- expected due to this value\n...\n18 |       max_word = w\n   |                  ^\n   |                  |\n   |                  expected `&str`, found struct `String`\n   |                  help: consider borrowing here: `&w`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp095up2vv.rs:21:10\n   |\n11 | fn find_max(words: Vec<String>) -> String {\n   |                                    ------ expected `String` because of return type\n...\n21 |   return max_word\n   |          ^^^^^^^^- help: try using a conversion method: `.to_string()`\n   |          |\n   |          expected struct `String`, found `&str`\n\nerror: aborting due to 7 previous errors\n\nSome errors have detailed explanations: E0308, E0425.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function that accepts a vector of strings.\n/// The vector contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n  let max_count = 0\n  let max_word = \"\"\n  for w in words {\n    let count = count_unique_chars(w)\n    if count > max_count {\n      max_count = count\n      max_word = w\n    }\n  }\n  return max_word\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]), String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]), String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]), String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n}\n",
      "timestamp": 1664292578,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmp095up2vv.rs:12:20\n   |\n12 |   let max_count = 0\n   |                    ^ help: add `;` here\n13 |   let max_word = \"\"\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmp095up2vv.rs:13:20\n   |\n13 |   let max_word = \"\"\n   |                    ^ help: add `;` here\n14 |   for w in words {\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `if`\n  --> /tmp/tmp095up2vv.rs:15:38\n   |\n15 |     let count = count_unique_chars(w)\n   |                                      ^ help: add `;` here\n16 |     if count > max_count {\n   |     -- unexpected token\n\nerror: expected `;`, found `max_word`\n  --> /tmp/tmp095up2vv.rs:17:24\n   |\n17 |       max_count = count\n   |                        ^ help: add `;` here\n18 |       max_word = w\n   |       -------- unexpected token\n\nerror[E0425]: cannot find function `count_unique_chars` in this scope\n  --> /tmp/tmp095up2vv.rs:15:17\n   |\n15 |     let count = count_unique_chars(w)\n   |                 ^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp095up2vv.rs:18:18\n   |\n13 |   let max_word = \"\"\n   |                  -- expected due to this value\n...\n18 |       max_word = w\n   |                  ^\n   |                  |\n   |                  expected `&str`, found struct `String`\n   |                  help: consider borrowing here: `&w`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp095up2vv.rs:21:10\n   |\n11 | fn find_max(words: Vec<String>) -> String {\n   |                                    ------ expected `String` because of return type\n...\n21 |   return max_word\n   |          ^^^^^^^^- help: try using a conversion method: `.to_string()`\n   |          |\n   |          expected struct `String`, found `&str`\n\nerror: aborting due to 7 previous errors\n\nSome errors have detailed explanations: E0308, E0425.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function that accepts a vector of strings.\n/// The vector contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n  let max_count = 0\n  let max_word = \"\"\n  for w in words {\n    let count = w.count(/[a-z]/)\n    if count > max_count {\n      max_count = count\n      max_word = w\n    }\n  }\n  return max_word\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]), String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]), String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]), String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n}\n",
      "timestamp": 1664292578,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmpjn5c1gme.rs:12:20\n   |\n12 |   let max_count = 0\n   |                    ^ help: add `;` here\n13 |   let max_word = \"\"\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpjn5c1gme.rs:13:20\n   |\n13 |   let max_word = \"\"\n   |                    ^ help: add `;` here\n14 |   for w in words {\n   |   --- unexpected token\n\nerror: expected expression, found `/`\n  --> /tmp/tmpjn5c1gme.rs:15:25\n   |\n15 |     let count = w.count(/[a-z]/)\n   |                         ^ expected expression\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpjn5c1gme.rs:21:10\n   |\n11 | fn find_max(words: Vec<String>) -> String {\n   |                                    ------ expected `String` because of return type\n...\n21 |   return max_word\n   |          ^^^^^^^^- help: try using a conversion method: `.to_string()`\n   |          |\n   |          expected struct `String`, found `&str`\n\nerror: aborting due to 4 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function that accepts a vector of strings.\n/// The vector contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n  let max_count = 0\n  let max_word = \"\"\n  for word in words {\n    let count = word.count(/[a-z]/);\n    if count > max_count {\n      max_count = count\n      max_word = word\n    }\n  }\n  return max_word\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]), String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]), String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]), String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n}\n",
      "timestamp": 1664292578,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmpsfumfyuh.rs:12:20\n   |\n12 |   let max_count = 0\n   |                    ^ help: add `;` here\n13 |   let max_word = \"\"\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpsfumfyuh.rs:13:20\n   |\n13 |   let max_word = \"\"\n   |                    ^ help: add `;` here\n14 |   for word in words {\n   |   --- unexpected token\n\nerror: expected expression, found `/`\n  --> /tmp/tmpsfumfyuh.rs:15:28\n   |\n15 |     let count = word.count(/[a-z]/);\n   |                            ^ expected expression\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpsfumfyuh.rs:21:10\n   |\n11 | fn find_max(words: Vec<String>) -> String {\n   |                                    ------ expected `String` because of return type\n...\n21 |   return max_word\n   |          ^^^^^^^^- help: try using a conversion method: `.to_string()`\n   |          |\n   |          expected struct `String`, found `&str`\n\nerror: aborting due to 4 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function that accepts a vector of strings.\n/// The vector contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n  let max_count = 0\n  let max_word = \"\"\n  for w in words {\n    let count = count_unique_chars(w)\n    if count > max_count {\n      max_count = count\n      max_word = w\n    }\n  }\n  return max_word\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]), String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]), String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]), String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n}\n",
      "timestamp": 1664292578,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmp095up2vv.rs:12:20\n   |\n12 |   let max_count = 0\n   |                    ^ help: add `;` here\n13 |   let max_word = \"\"\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmp095up2vv.rs:13:20\n   |\n13 |   let max_word = \"\"\n   |                    ^ help: add `;` here\n14 |   for w in words {\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `if`\n  --> /tmp/tmp095up2vv.rs:15:38\n   |\n15 |     let count = count_unique_chars(w)\n   |                                      ^ help: add `;` here\n16 |     if count > max_count {\n   |     -- unexpected token\n\nerror: expected `;`, found `max_word`\n  --> /tmp/tmp095up2vv.rs:17:24\n   |\n17 |       max_count = count\n   |                        ^ help: add `;` here\n18 |       max_word = w\n   |       -------- unexpected token\n\nerror[E0425]: cannot find function `count_unique_chars` in this scope\n  --> /tmp/tmp095up2vv.rs:15:17\n   |\n15 |     let count = count_unique_chars(w)\n   |                 ^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp095up2vv.rs:18:18\n   |\n13 |   let max_word = \"\"\n   |                  -- expected due to this value\n...\n18 |       max_word = w\n   |                  ^\n   |                  |\n   |                  expected `&str`, found struct `String`\n   |                  help: consider borrowing here: `&w`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp095up2vv.rs:21:10\n   |\n11 | fn find_max(words: Vec<String>) -> String {\n   |                                    ------ expected `String` because of return type\n...\n21 |   return max_word\n   |          ^^^^^^^^- help: try using a conversion method: `.to_string()`\n   |          |\n   |          expected struct `String`, found `&str`\n\nerror: aborting due to 7 previous errors\n\nSome errors have detailed explanations: E0308, E0425.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function that accepts a vector of strings.\n/// The vector contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n  let max_count = 0\n  let max_word = \"\"\n  for w in words {\n    let count = count_unique_chars(w)\n    if count > max_count {\n      max_count = count\n      max_word = w\n    }\n  }\n  return max_word\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]), String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]), String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]), String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n}\n",
      "timestamp": 1664292578,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmp095up2vv.rs:12:20\n   |\n12 |   let max_count = 0\n   |                    ^ help: add `;` here\n13 |   let max_word = \"\"\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmp095up2vv.rs:13:20\n   |\n13 |   let max_word = \"\"\n   |                    ^ help: add `;` here\n14 |   for w in words {\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `if`\n  --> /tmp/tmp095up2vv.rs:15:38\n   |\n15 |     let count = count_unique_chars(w)\n   |                                      ^ help: add `;` here\n16 |     if count > max_count {\n   |     -- unexpected token\n\nerror: expected `;`, found `max_word`\n  --> /tmp/tmp095up2vv.rs:17:24\n   |\n17 |       max_count = count\n   |                        ^ help: add `;` here\n18 |       max_word = w\n   |       -------- unexpected token\n\nerror[E0425]: cannot find function `count_unique_chars` in this scope\n  --> /tmp/tmp095up2vv.rs:15:17\n   |\n15 |     let count = count_unique_chars(w)\n   |                 ^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp095up2vv.rs:18:18\n   |\n13 |   let max_word = \"\"\n   |                  -- expected due to this value\n...\n18 |       max_word = w\n   |                  ^\n   |                  |\n   |                  expected `&str`, found struct `String`\n   |                  help: consider borrowing here: `&w`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp095up2vv.rs:21:10\n   |\n11 | fn find_max(words: Vec<String>) -> String {\n   |                                    ------ expected `String` because of return type\n...\n21 |   return max_word\n   |          ^^^^^^^^- help: try using a conversion method: `.to_string()`\n   |          |\n   |          expected struct `String`, found `&str`\n\nerror: aborting due to 7 previous errors\n\nSome errors have detailed explanations: E0308, E0425.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function that accepts a vector of strings.\n/// The vector contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n  let max_count = 0\n  let max_word = String::from(\"\")\n  for word in words {\n    let count = word.count(/[a-z]/);\n    if count > max_count {\n      max_count = count\n      max_word = word\n    }\n  }\n  return max_word\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]), String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]), String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]), String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n}\n",
      "timestamp": 1664292578,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmpxbwct_9g.rs:12:20\n   |\n12 |   let max_count = 0\n   |                    ^ help: add `;` here\n13 |   let max_word = String::from(\"\")\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpxbwct_9g.rs:13:34\n   |\n13 |   let max_word = String::from(\"\")\n   |                                  ^ help: add `;` here\n14 |   for word in words {\n   |   --- unexpected token\n\nerror: expected expression, found `/`\n  --> /tmp/tmpxbwct_9g.rs:15:28\n   |\n15 |     let count = word.count(/[a-z]/);\n   |                            ^ expected expression\n\nerror: aborting due to 3 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function that accepts a vector of strings.\n/// The vector contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n  let max_count = 0\n  let max_word = \"\"\n  for w in words {\n    let count = w.count(/[a-z]/);\n    if count > max_count {\n      max_count = count\n      max_word = w\n    }\n  }\n  return max_word\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]), String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]), String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]), String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n}\n",
      "timestamp": 1664292578,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmpk6mb5m3s.rs:12:20\n   |\n12 |   let max_count = 0\n   |                    ^ help: add `;` here\n13 |   let max_word = \"\"\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpk6mb5m3s.rs:13:20\n   |\n13 |   let max_word = \"\"\n   |                    ^ help: add `;` here\n14 |   for w in words {\n   |   --- unexpected token\n\nerror: expected expression, found `/`\n  --> /tmp/tmpk6mb5m3s.rs:15:25\n   |\n15 |     let count = w.count(/[a-z]/);\n   |                         ^ expected expression\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpk6mb5m3s.rs:21:10\n   |\n11 | fn find_max(words: Vec<String>) -> String {\n   |                                    ------ expected `String` because of return type\n...\n21 |   return max_word\n   |          ^^^^^^^^- help: try using a conversion method: `.to_string()`\n   |          |\n   |          expected struct `String`, found `&str`\n\nerror: aborting due to 4 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function that accepts a vector of strings.\n/// The vector contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n  let max_count = 0;\n  let max_word = String::from(\"\");\n  for word in words {\n    let count = count_unique_chars(word);\n    if count > max_count {\n      max_count = count;\n      max_word = word;\n    }\n  }\n  return max_word;\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]), String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]), String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]), String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n}\n",
      "timestamp": 1664292578,
      "stdout": "",
      "stderr": "error[E0425]: cannot find function `count_unique_chars` in this scope\n  --> /tmp/tmp7umry43m.rs:15:17\n   |\n15 |     let count = count_unique_chars(word);\n   |                 ^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function that accepts a vector of strings.\n/// The vector contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n  let max_count = 0\n  let max_word = \"\"\n  for word in words {\n    let count = word.count(/[a-z]/);\n    if count > max_count {\n      max_count = count\n      max_word = word\n    }\n  }\n  return max_word\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]), String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]), String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]), String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n}\n",
      "timestamp": 1664292578,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmpsfumfyuh.rs:12:20\n   |\n12 |   let max_count = 0\n   |                    ^ help: add `;` here\n13 |   let max_word = \"\"\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpsfumfyuh.rs:13:20\n   |\n13 |   let max_word = \"\"\n   |                    ^ help: add `;` here\n14 |   for word in words {\n   |   --- unexpected token\n\nerror: expected expression, found `/`\n  --> /tmp/tmpsfumfyuh.rs:15:28\n   |\n15 |     let count = word.count(/[a-z]/);\n   |                            ^ expected expression\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpsfumfyuh.rs:21:10\n   |\n11 | fn find_max(words: Vec<String>) -> String {\n   |                                    ------ expected `String` because of return type\n...\n21 |   return max_word\n   |          ^^^^^^^^- help: try using a conversion method: `.to_string()`\n   |          |\n   |          expected struct `String`, found `&str`\n\nerror: aborting due to 4 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function that accepts a vector of strings.\n/// The vector contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n  let max_count = 0\n  let max_count_index = 0\n  let max_count_word = \"\"\n  for i in 0..words.len() {\n    let count = 0\n    for j in 0..words[i].len() {\n      if words[i][j] == words[i][j].to_lower() {\n        count += 1\n      }\n    }\n    if count > max_count {\n      max_count = count\n      max_count_index = i\n      max_count_word = words[i]\n    }\n  }\n  return max_count_word\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]), String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]), String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]), String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n}\n",
      "timestamp": 1664292578,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmpx0uq9x_4.rs:12:20\n   |\n12 |   let max_count = 0\n   |                    ^ help: add `;` here\n13 |   let max_count_index = 0\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `let`\n  --> /tmp/tmpx0uq9x_4.rs:13:26\n   |\n13 |   let max_count_index = 0\n   |                          ^ help: add `;` here\n14 |   let max_count_word = \"\"\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpx0uq9x_4.rs:14:26\n   |\n14 |   let max_count_word = \"\"\n   |                          ^ help: add `;` here\n15 |   for i in 0..words.len() {\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpx0uq9x_4.rs:16:18\n   |\n16 |     let count = 0\n   |                  ^ help: add `;` here\n17 |     for j in 0..words[i].len() {\n   |     --- unexpected token\n\nerror: expected `;`, found `max_count_index`\n  --> /tmp/tmpx0uq9x_4.rs:23:24\n   |\n23 |       max_count = count\n   |                        ^ help: add `;` here\n24 |       max_count_index = i\n   |       --------------- unexpected token\n\nerror: expected `;`, found `max_count_word`\n  --> /tmp/tmpx0uq9x_4.rs:24:26\n   |\n24 |       max_count_index = i\n   |                          ^ help: add `;` here\n25 |       max_count_word = words[i]\n   |       -------------- unexpected token\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpx0uq9x_4.rs:18:10\n   |\n18 |       if words[i][j] == words[i][j].to_lower() {\n   |          ^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]: ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function that accepts a vector of strings.\n/// The vector contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n  let max_count = 0\n  let max_word = \"\"\n  for w in words {\n    let count = w.count(/[a-z]/)\n    if count > max_count {\n      max_count = count\n      max_word = w\n    }\n  }\n  return max_word\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]), String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]), String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]), String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n}\n",
      "timestamp": 1664292578,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmpjn5c1gme.rs:12:20\n   |\n12 |   let max_count = 0\n   |                    ^ help: add `;` here\n13 |   let max_word = \"\"\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpjn5c1gme.rs:13:20\n   |\n13 |   let max_word = \"\"\n   |                    ^ help: add `;` here\n14 |   for w in words {\n   |   --- unexpected token\n\nerror: expected expression, found `/`\n  --> /tmp/tmpjn5c1gme.rs:15:25\n   |\n15 |     let count = w.count(/[a-z]/)\n   |                         ^ expected expression\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpjn5c1gme.rs:21:10\n   |\n11 | fn find_max(words: Vec<String>) -> String {\n   |                                    ------ expected `String` because of return type\n...\n21 |   return max_word\n   |          ^^^^^^^^- help: try using a conversion method: `.to_string()`\n   |          |\n   |          expected struct `String`, found `&str`\n\nerror: aborting due to 4 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function that accepts a vector of strings.\n/// The vector contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n  let max_count = 0\n  let max_word = \"\"\n  for w in words {\n    let count = count_unique_chars(w)\n    if count > max_count {\n      max_count = count\n      max_word = w\n    }\n  }\n  return max_word\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]), String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]), String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]), String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n}\n",
      "timestamp": 1664292578,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmp095up2vv.rs:12:20\n   |\n12 |   let max_count = 0\n   |                    ^ help: add `;` here\n13 |   let max_word = \"\"\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmp095up2vv.rs:13:20\n   |\n13 |   let max_word = \"\"\n   |                    ^ help: add `;` here\n14 |   for w in words {\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `if`\n  --> /tmp/tmp095up2vv.rs:15:38\n   |\n15 |     let count = count_unique_chars(w)\n   |                                      ^ help: add `;` here\n16 |     if count > max_count {\n   |     -- unexpected token\n\nerror: expected `;`, found `max_word`\n  --> /tmp/tmp095up2vv.rs:17:24\n   |\n17 |       max_count = count\n   |                        ^ help: add `;` here\n18 |       max_word = w\n   |       -------- unexpected token\n\nerror[E0425]: cannot find function `count_unique_chars` in this scope\n  --> /tmp/tmp095up2vv.rs:15:17\n   |\n15 |     let count = count_unique_chars(w)\n   |                 ^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp095up2vv.rs:18:18\n   |\n13 |   let max_word = \"\"\n   |                  -- expected due to this value\n...\n18 |       max_word = w\n   |                  ^\n   |                  |\n   |                  expected `&str`, found struct `String`\n   |                  help: consider borrowing here: `&w`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp095up2vv.rs:21:10\n   |\n11 | fn find_max(words: Vec<String>) -> String {\n   |                                    ------ expected `String` because of return type\n...\n21 |   return max_word\n   |          ^^^^^^^^- help: try using a conversion method: `.to_string()`\n   |          |\n   |          expected struct `String`, found `&str`\n\nerror: aborting due to 7 previous errors\n\nSome errors have detailed explanations: E0308, E0425.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function that accepts a vector of strings.\n/// The vector contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n  let max_count = 0;\n  let max_word = String::from(\"\");\n  for word in words {\n    let count = count_unique_chars(word);\n    if count > max_count {\n      max_count = count;\n      max_word = word;\n    }\n  }\n  return max_word;\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]), String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]), String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]), String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n}\n",
      "timestamp": 1664292578,
      "stdout": "",
      "stderr": "error[E0425]: cannot find function `count_unique_chars` in this scope\n  --> /tmp/tmp7umry43m.rs:15:17\n   |\n15 |     let count = count_unique_chars(word);\n   |                 ^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function that accepts a vector of strings.\n/// The vector contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n  let max_count = 0\n  let max_word = \"\"\n  for w in words {\n    let count = w.count(/[a-z]/);\n    if count > max_count {\n      max_count = count\n      max_word = w\n    }\n  }\n  return max_word\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]), String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]), String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]), String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n}\n",
      "timestamp": 1664292578,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmpk6mb5m3s.rs:12:20\n   |\n12 |   let max_count = 0\n   |                    ^ help: add `;` here\n13 |   let max_word = \"\"\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpk6mb5m3s.rs:13:20\n   |\n13 |   let max_word = \"\"\n   |                    ^ help: add `;` here\n14 |   for w in words {\n   |   --- unexpected token\n\nerror: expected expression, found `/`\n  --> /tmp/tmpk6mb5m3s.rs:15:25\n   |\n15 |     let count = w.count(/[a-z]/);\n   |                         ^ expected expression\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpk6mb5m3s.rs:21:10\n   |\n11 | fn find_max(words: Vec<String>) -> String {\n   |                                    ------ expected `String` because of return type\n...\n21 |   return max_word\n   |          ^^^^^^^^- help: try using a conversion method: `.to_string()`\n   |          |\n   |          expected struct `String`, found `&str`\n\nerror: aborting due to 4 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function that accepts a vector of strings.\n/// The vector contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n  let max_count = 0\n  let max_word = \"\"\n  for w in words {\n    let count = count_unique_chars(w)\n    if count > max_count {\n      max_count = count\n      max_word = w\n    }\n  }\n  return max_word\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]), String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]), String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]), String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n}\n",
      "timestamp": 1664292578,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmp095up2vv.rs:12:20\n   |\n12 |   let max_count = 0\n   |                    ^ help: add `;` here\n13 |   let max_word = \"\"\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmp095up2vv.rs:13:20\n   |\n13 |   let max_word = \"\"\n   |                    ^ help: add `;` here\n14 |   for w in words {\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `if`\n  --> /tmp/tmp095up2vv.rs:15:38\n   |\n15 |     let count = count_unique_chars(w)\n   |                                      ^ help: add `;` here\n16 |     if count > max_count {\n   |     -- unexpected token\n\nerror: expected `;`, found `max_word`\n  --> /tmp/tmp095up2vv.rs:17:24\n   |\n17 |       max_count = count\n   |                        ^ help: add `;` here\n18 |       max_word = w\n   |       -------- unexpected token\n\nerror[E0425]: cannot find function `count_unique_chars` in this scope\n  --> /tmp/tmp095up2vv.rs:15:17\n   |\n15 |     let count = count_unique_chars(w)\n   |                 ^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp095up2vv.rs:18:18\n   |\n13 |   let max_word = \"\"\n   |                  -- expected due to this value\n...\n18 |       max_word = w\n   |                  ^\n   |                  |\n   |                  expected `&str`, found struct `String`\n   |                  help: consider borrowing here: `&w`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp095up2vv.rs:21:10\n   |\n11 | fn find_max(words: Vec<String>) -> String {\n   |                                    ------ expected `String` because of return type\n...\n21 |   return max_word\n   |          ^^^^^^^^- help: try using a conversion method: `.to_string()`\n   |          |\n   |          expected struct `String`, found `&str`\n\nerror: aborting due to 7 previous errors\n\nSome errors have detailed explanations: E0308, E0425.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function that accepts a vector of strings.\n/// The vector contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n  let max_count = 0;\n  let max_word = String::from(\"\");\n  for word in words {\n    let count = count_unique_chars(word);\n    if count > max_count {\n      max_count = count;\n      max_word = word;\n    }\n  }\n  return max_word;\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]), String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]), String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]), String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n}\n",
      "timestamp": 1664292578,
      "stdout": "",
      "stderr": "error[E0425]: cannot find function `count_unique_chars` in this scope\n  --> /tmp/tmp7umry43m.rs:15:17\n   |\n15 |     let count = count_unique_chars(word);\n   |                 ^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function that accepts a vector of strings.\n/// The vector contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n  let max_count = 0\n  let max_word = \"\"\n\n  for w in words {\n    let count = w.count(/[a-z]/);\n    if count > max_count {\n      max_count = count\n      max_word = w\n    }\n  }\n\n  return max_word\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]), String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]), String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]), String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n}\n",
      "timestamp": 1664292578,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmpvii03icn.rs:12:20\n   |\n12 |   let max_count = 0\n   |                    ^ help: add `;` here\n13 |   let max_word = \"\"\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpvii03icn.rs:13:20\n   |\n13 |   let max_word = \"\"\n   |                    ^ help: add `;` here\n14 | \n15 |   for w in words {\n   |   --- unexpected token\n\nerror: expected expression, found `/`\n  --> /tmp/tmpvii03icn.rs:16:25\n   |\n16 |     let count = w.count(/[a-z]/);\n   |                         ^ expected expression\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpvii03icn.rs:23:10\n   |\n11 | fn find_max(words: Vec<String>) -> String {\n   |                                    ------ expected `String` because of return type\n...\n23 |   return max_word\n   |          ^^^^^^^^- help: try using a conversion method: `.to_string()`\n   |          |\n   |          expected struct `String`, found `&str`\n\nerror: aborting due to 4 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function that accepts a vector of strings.\n/// The vector contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n  let max_count = 0\n  let max_word = \"\"\n  for w in words {\n    let count = w.count_unique()\n    if count > max_count {\n      max_count = count\n      max_word = w\n    }\n  }\n  return max_word\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]), String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]), String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]), String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n}\n",
      "timestamp": 1664292578,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmp5vp_ies0.rs:12:20\n   |\n12 |   let max_count = 0\n   |                    ^ help: add `;` here\n13 |   let max_word = \"\"\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmp5vp_ies0.rs:13:20\n   |\n13 |   let max_word = \"\"\n   |                    ^ help: add `;` here\n14 |   for w in words {\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `if`\n  --> /tmp/tmp5vp_ies0.rs:15:33\n   |\n15 |     let count = w.count_unique()\n   |                                 ^ help: add `;` here\n16 |     if count > max_count {\n   |     -- unexpected token\n\nerror: expected `;`, found `max_word`\n  --> /tmp/tmp5vp_ies0.rs:17:24\n   |\n17 |       max_count = count\n   |                        ^ help: add `;` here\n18 |       max_word = w\n   |       -------- unexpected token\n\nerror[E0599]: no method named `count_unique` found for struct `String` in the current scope\n  --> /tmp/tmp5vp_ies0.rs:15:19\n   |\n15 |     let count = w.count_unique()\n   |                   ^^^^^^^^^^^^ method not found in `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp5vp_ies0.rs:18:18\n   |\n13 |   let max_word = \"\"\n   |                  -- expected due to this value\n...\n18 |       max_word = w\n   |                  ^\n   |                  |\n   |                  expected `&str`, found struct `String`\n   |                  help: consider borrowing here: `&w`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp5vp_ies0.rs:21:10\n   |\n11 | fn find_max(words: Vec<String>) -> String {\n   |                                    ------ expected `String` because of return type\n...\n21 |   return max_word\n   |          ^^^^^^^^- help: try using a conversion method: `.to_string()`\n   |          |\n   |          expected struct `String`, found `&str`\n\nerror: aborting due to 7 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function that accepts a vector of strings.\n/// The vector contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n  let max_count = 0\n  let max_word = \"\"\n  for w in words {\n    let count = count_unique_chars(w)\n    if count > max_count {\n      max_count = count\n      max_word = w\n    }\n  }\n  return max_word\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]), String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]), String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]), String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n}\n",
      "timestamp": 1664292578,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmp095up2vv.rs:12:20\n   |\n12 |   let max_count = 0\n   |                    ^ help: add `;` here\n13 |   let max_word = \"\"\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmp095up2vv.rs:13:20\n   |\n13 |   let max_word = \"\"\n   |                    ^ help: add `;` here\n14 |   for w in words {\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `if`\n  --> /tmp/tmp095up2vv.rs:15:38\n   |\n15 |     let count = count_unique_chars(w)\n   |                                      ^ help: add `;` here\n16 |     if count > max_count {\n   |     -- unexpected token\n\nerror: expected `;`, found `max_word`\n  --> /tmp/tmp095up2vv.rs:17:24\n   |\n17 |       max_count = count\n   |                        ^ help: add `;` here\n18 |       max_word = w\n   |       -------- unexpected token\n\nerror[E0425]: cannot find function `count_unique_chars` in this scope\n  --> /tmp/tmp095up2vv.rs:15:17\n   |\n15 |     let count = count_unique_chars(w)\n   |                 ^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp095up2vv.rs:18:18\n   |\n13 |   let max_word = \"\"\n   |                  -- expected due to this value\n...\n18 |       max_word = w\n   |                  ^\n   |                  |\n   |                  expected `&str`, found struct `String`\n   |                  help: consider borrowing here: `&w`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp095up2vv.rs:21:10\n   |\n11 | fn find_max(words: Vec<String>) -> String {\n   |                                    ------ expected `String` because of return type\n...\n21 |   return max_word\n   |          ^^^^^^^^- help: try using a conversion method: `.to_string()`\n   |          |\n   |          expected struct `String`, found `&str`\n\nerror: aborting due to 7 previous errors\n\nSome errors have detailed explanations: E0308, E0425.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function that accepts a vector of strings.\n/// The vector contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n  let max_count = 0\n  let max_word = \"\"\n  for w in words {\n    let count = count_unique_chars(w)\n    if count > max_count {\n      max_count = count\n      max_word = w\n    }\n  }\n  return max_word\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]), String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]), String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]), String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n}\n",
      "timestamp": 1664292578,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmp095up2vv.rs:12:20\n   |\n12 |   let max_count = 0\n   |                    ^ help: add `;` here\n13 |   let max_word = \"\"\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmp095up2vv.rs:13:20\n   |\n13 |   let max_word = \"\"\n   |                    ^ help: add `;` here\n14 |   for w in words {\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `if`\n  --> /tmp/tmp095up2vv.rs:15:38\n   |\n15 |     let count = count_unique_chars(w)\n   |                                      ^ help: add `;` here\n16 |     if count > max_count {\n   |     -- unexpected token\n\nerror: expected `;`, found `max_word`\n  --> /tmp/tmp095up2vv.rs:17:24\n   |\n17 |       max_count = count\n   |                        ^ help: add `;` here\n18 |       max_word = w\n   |       -------- unexpected token\n\nerror[E0425]: cannot find function `count_unique_chars` in this scope\n  --> /tmp/tmp095up2vv.rs:15:17\n   |\n15 |     let count = count_unique_chars(w)\n   |                 ^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp095up2vv.rs:18:18\n   |\n13 |   let max_word = \"\"\n   |                  -- expected due to this value\n...\n18 |       max_word = w\n   |                  ^\n   |                  |\n   |                  expected `&str`, found struct `String`\n   |                  help: consider borrowing here: `&w`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp095up2vv.rs:21:10\n   |\n11 | fn find_max(words: Vec<String>) -> String {\n   |                                    ------ expected `String` because of return type\n...\n21 |   return max_word\n   |          ^^^^^^^^- help: try using a conversion method: `.to_string()`\n   |          |\n   |          expected struct `String`, found `&str`\n\nerror: aborting due to 7 previous errors\n\nSome errors have detailed explanations: E0308, E0425.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function that accepts a vector of strings.\n/// The vector contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n  let max_count = 0\n  let max_word = \"\"\n  for word in words {\n    let count = word.count(/[a-z]/);\n    if count > max_count {\n      max_count = count\n      max_word = word\n    }\n  }\n  return max_word\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]), String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]), String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]), String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n}\n",
      "timestamp": 1664292578,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmpsfumfyuh.rs:12:20\n   |\n12 |   let max_count = 0\n   |                    ^ help: add `;` here\n13 |   let max_word = \"\"\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpsfumfyuh.rs:13:20\n   |\n13 |   let max_word = \"\"\n   |                    ^ help: add `;` here\n14 |   for word in words {\n   |   --- unexpected token\n\nerror: expected expression, found `/`\n  --> /tmp/tmpsfumfyuh.rs:15:28\n   |\n15 |     let count = word.count(/[a-z]/);\n   |                            ^ expected expression\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpsfumfyuh.rs:21:10\n   |\n11 | fn find_max(words: Vec<String>) -> String {\n   |                                    ------ expected `String` because of return type\n...\n21 |   return max_word\n   |          ^^^^^^^^- help: try using a conversion method: `.to_string()`\n   |          |\n   |          expected struct `String`, found `&str`\n\nerror: aborting due to 4 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function that accepts a vector of strings.\n/// The vector contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n  let max_count = 0\n  let max_word = \"\"\n  for word in words {\n    let count = count_unique_chars(word)\n    if count > max_count {\n      max_count = count\n      max_word = word\n    }\n  }\n  return max_word\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]), String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]), String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]), String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n}\n",
      "timestamp": 1664292578,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmpblowsbak.rs:12:20\n   |\n12 |   let max_count = 0\n   |                    ^ help: add `;` here\n13 |   let max_word = \"\"\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpblowsbak.rs:13:20\n   |\n13 |   let max_word = \"\"\n   |                    ^ help: add `;` here\n14 |   for word in words {\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `if`\n  --> /tmp/tmpblowsbak.rs:15:41\n   |\n15 |     let count = count_unique_chars(word)\n   |                                         ^ help: add `;` here\n16 |     if count > max_count {\n   |     -- unexpected token\n\nerror: expected `;`, found `max_word`\n  --> /tmp/tmpblowsbak.rs:17:24\n   |\n17 |       max_count = count\n   |                        ^ help: add `;` here\n18 |       max_word = word\n   |       -------- unexpected token\n\nerror[E0425]: cannot find function `count_unique_chars` in this scope\n  --> /tmp/tmpblowsbak.rs:15:17\n   |\n15 |     let count = count_unique_chars(word)\n   |                 ^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpblowsbak.rs:18:18\n   |\n13 |   let max_word = \"\"\n   |                  -- expected due to this value\n...\n18 |       max_word = word\n   |                  ^^^^\n   |                  |\n   |                  expected `&str`, found struct `String`\n   |                  help: consider borrowing here: `&word`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpblowsbak.rs:21:10\n   |\n11 | fn find_max(words: Vec<String>) -> String {\n   |                                    ------ expected `String` because of return type\n...\n21 |   return max_word\n   |          ^^^^^^^^- help: try using a conversion method: `.to_string()`\n   |          |\n   |          expected struct `String`, found `&str`\n\nerror: aborting due to 7 previous errors\n\nSome errors have detailed explanations: E0308, E0425.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function that accepts a vector of strings.\n/// The vector contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n  let max_count = 0\n  let max_word = \"\"\n  for w in words {\n    let count = w.count_unique_chars()\n    if count > max_count {\n      max_count = count\n      max_word = w\n    }\n  }\n  return max_word\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]), String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]), String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]), String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n}\n",
      "timestamp": 1664292578,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmp83xgxfl_.rs:12:20\n   |\n12 |   let max_count = 0\n   |                    ^ help: add `;` here\n13 |   let max_word = \"\"\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmp83xgxfl_.rs:13:20\n   |\n13 |   let max_word = \"\"\n   |                    ^ help: add `;` here\n14 |   for w in words {\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `if`\n  --> /tmp/tmp83xgxfl_.rs:15:39\n   |\n15 |     let count = w.count_unique_chars()\n   |                                       ^ help: add `;` here\n16 |     if count > max_count {\n   |     -- unexpected token\n\nerror: expected `;`, found `max_word`\n  --> /tmp/tmp83xgxfl_.rs:17:24\n   |\n17 |       max_count = count\n   |                        ^ help: add `;` here\n18 |       max_word = w\n   |       -------- unexpected token\n\nerror[E0599]: no method named `count_unique_chars` found for struct `String` in the current scope\n  --> /tmp/tmp83xgxfl_.rs:15:19\n   |\n15 |     let count = w.count_unique_chars()\n   |                   ^^^^^^^^^^^^^^^^^^ method not found in `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp83xgxfl_.rs:18:18\n   |\n13 |   let max_word = \"\"\n   |                  -- expected due to this value\n...\n18 |       max_word = w\n   |                  ^\n   |                  |\n   |                  expected `&str`, found struct `String`\n   |                  help: consider borrowing here: `&w`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp83xgxfl_.rs:21:10\n   |\n11 | fn find_max(words: Vec<String>) -> String {\n   |                                    ------ expected `String` because of return type\n...\n21 |   return max_word\n   |          ^^^^^^^^- help: try using a conversion method: `.to_string()`\n   |          |\n   |          expected struct `String`, found `&str`\n\nerror: aborting due to 7 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function that accepts a vector of strings.\n/// The vector contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n  let max_count = 0\n  let max_word = \"\"\n  for w in words {\n    let count = count_unique_chars(w)\n    if count > max_count {\n      max_count = count\n      max_word = w\n    }\n  }\n  return max_word\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]), String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]), String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]), String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n}\n",
      "timestamp": 1664292578,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmp095up2vv.rs:12:20\n   |\n12 |   let max_count = 0\n   |                    ^ help: add `;` here\n13 |   let max_word = \"\"\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmp095up2vv.rs:13:20\n   |\n13 |   let max_word = \"\"\n   |                    ^ help: add `;` here\n14 |   for w in words {\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `if`\n  --> /tmp/tmp095up2vv.rs:15:38\n   |\n15 |     let count = count_unique_chars(w)\n   |                                      ^ help: add `;` here\n16 |     if count > max_count {\n   |     -- unexpected token\n\nerror: expected `;`, found `max_word`\n  --> /tmp/tmp095up2vv.rs:17:24\n   |\n17 |       max_count = count\n   |                        ^ help: add `;` here\n18 |       max_word = w\n   |       -------- unexpected token\n\nerror[E0425]: cannot find function `count_unique_chars` in this scope\n  --> /tmp/tmp095up2vv.rs:15:17\n   |\n15 |     let count = count_unique_chars(w)\n   |                 ^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp095up2vv.rs:18:18\n   |\n13 |   let max_word = \"\"\n   |                  -- expected due to this value\n...\n18 |       max_word = w\n   |                  ^\n   |                  |\n   |                  expected `&str`, found struct `String`\n   |                  help: consider borrowing here: `&w`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp095up2vv.rs:21:10\n   |\n11 | fn find_max(words: Vec<String>) -> String {\n   |                                    ------ expected `String` because of return type\n...\n21 |   return max_word\n   |          ^^^^^^^^- help: try using a conversion method: `.to_string()`\n   |          |\n   |          expected struct `String`, found `&str`\n\nerror: aborting due to 7 previous errors\n\nSome errors have detailed explanations: E0308, E0425.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function that accepts a vector of strings.\n/// The vector contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n  let max_count = 0\n  let max_word = \"\"\n  for w in words {\n    let count = w.count(/[a-z]/);\n    if count > max_count {\n      max_count = count\n      max_word = w\n    }\n  }\n  return max_word\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]), String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]), String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]), String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n}\n",
      "timestamp": 1664292578,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmpk6mb5m3s.rs:12:20\n   |\n12 |   let max_count = 0\n   |                    ^ help: add `;` here\n13 |   let max_word = \"\"\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpk6mb5m3s.rs:13:20\n   |\n13 |   let max_word = \"\"\n   |                    ^ help: add `;` here\n14 |   for w in words {\n   |   --- unexpected token\n\nerror: expected expression, found `/`\n  --> /tmp/tmpk6mb5m3s.rs:15:25\n   |\n15 |     let count = w.count(/[a-z]/);\n   |                         ^ expected expression\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpk6mb5m3s.rs:21:10\n   |\n11 | fn find_max(words: Vec<String>) -> String {\n   |                                    ------ expected `String` because of return type\n...\n21 |   return max_word\n   |          ^^^^^^^^- help: try using a conversion method: `.to_string()`\n   |          |\n   |          expected struct `String`, found `&str`\n\nerror: aborting due to 4 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function that accepts a vector of strings.\n/// The vector contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n  let max_count = 0\n  let max_word = \"\"\n  for w in words {\n    let count = count_unique_chars(w)\n    if count > max_count {\n      max_count = count\n      max_word = w\n    }\n  }\n  return max_word\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]), String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]), String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]), String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n}\n",
      "timestamp": 1664292578,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmp095up2vv.rs:12:20\n   |\n12 |   let max_count = 0\n   |                    ^ help: add `;` here\n13 |   let max_word = \"\"\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmp095up2vv.rs:13:20\n   |\n13 |   let max_word = \"\"\n   |                    ^ help: add `;` here\n14 |   for w in words {\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `if`\n  --> /tmp/tmp095up2vv.rs:15:38\n   |\n15 |     let count = count_unique_chars(w)\n   |                                      ^ help: add `;` here\n16 |     if count > max_count {\n   |     -- unexpected token\n\nerror: expected `;`, found `max_word`\n  --> /tmp/tmp095up2vv.rs:17:24\n   |\n17 |       max_count = count\n   |                        ^ help: add `;` here\n18 |       max_word = w\n   |       -------- unexpected token\n\nerror[E0425]: cannot find function `count_unique_chars` in this scope\n  --> /tmp/tmp095up2vv.rs:15:17\n   |\n15 |     let count = count_unique_chars(w)\n   |                 ^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp095up2vv.rs:18:18\n   |\n13 |   let max_word = \"\"\n   |                  -- expected due to this value\n...\n18 |       max_word = w\n   |                  ^\n   |                  |\n   |                  expected `&str`, found struct `String`\n   |                  help: consider borrowing here: `&w`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp095up2vv.rs:21:10\n   |\n11 | fn find_max(words: Vec<String>) -> String {\n   |                                    ------ expected `String` because of return type\n...\n21 |   return max_word\n   |          ^^^^^^^^- help: try using a conversion method: `.to_string()`\n   |          |\n   |          expected struct `String`, found `&str`\n\nerror: aborting due to 7 previous errors\n\nSome errors have detailed explanations: E0308, E0425.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function that accepts a vector of strings.\n/// The vector contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n  let max_count = 0\n  let max_word = \"\"\n  for word in words {\n    let count = word.count(/[a-z]/);\n    if count > max_count {\n      max_count = count\n      max_word = word\n    }\n  }\n  return max_word\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]), String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]), String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]), String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n}\n",
      "timestamp": 1664292578,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmpsfumfyuh.rs:12:20\n   |\n12 |   let max_count = 0\n   |                    ^ help: add `;` here\n13 |   let max_word = \"\"\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpsfumfyuh.rs:13:20\n   |\n13 |   let max_word = \"\"\n   |                    ^ help: add `;` here\n14 |   for word in words {\n   |   --- unexpected token\n\nerror: expected expression, found `/`\n  --> /tmp/tmpsfumfyuh.rs:15:28\n   |\n15 |     let count = word.count(/[a-z]/);\n   |                            ^ expected expression\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpsfumfyuh.rs:21:10\n   |\n11 | fn find_max(words: Vec<String>) -> String {\n   |                                    ------ expected `String` because of return type\n...\n21 |   return max_word\n   |          ^^^^^^^^- help: try using a conversion method: `.to_string()`\n   |          |\n   |          expected struct `String`, found `&str`\n\nerror: aborting due to 4 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function that accepts a vector of strings.\n/// The vector contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n  let max_count = 0\n  let max_word = \"\"\n  for w in words {\n    let count = w.count(/[a-z]/)\n    if count > max_count {\n      max_count = count\n      max_word = w\n    }\n  }\n  return max_word\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]), String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]), String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]), String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n}\n",
      "timestamp": 1664292578,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmpjn5c1gme.rs:12:20\n   |\n12 |   let max_count = 0\n   |                    ^ help: add `;` here\n13 |   let max_word = \"\"\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpjn5c1gme.rs:13:20\n   |\n13 |   let max_word = \"\"\n   |                    ^ help: add `;` here\n14 |   for w in words {\n   |   --- unexpected token\n\nerror: expected expression, found `/`\n  --> /tmp/tmpjn5c1gme.rs:15:25\n   |\n15 |     let count = w.count(/[a-z]/)\n   |                         ^ expected expression\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpjn5c1gme.rs:21:10\n   |\n11 | fn find_max(words: Vec<String>) -> String {\n   |                                    ------ expected `String` because of return type\n...\n21 |   return max_word\n   |          ^^^^^^^^- help: try using a conversion method: `.to_string()`\n   |          |\n   |          expected struct `String`, found `&str`\n\nerror: aborting due to 4 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function that accepts a vector of strings.\n/// The vector contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n  let max_count = 0;\n  let max_count_index = 0;\n  let max_count_word = String::from(\"\");\n  for (let i = 0; i < words.len(); i++) {\n    let word = words[i];\n    let count = word.count(/[a-z]/);\n    if (count > max_count) {\n      max_count = count;\n      max_count_index = i;\n      max_count_word = word;\n    }\n  }\n  return max_count_word;\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]), String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]), String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]), String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n}\n",
      "timestamp": 1664292578,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmpgpd7tpah.rs:15:8\n   |\n15 |   for (let i = 0; i < words.len(); i++) {\n   |        ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmpgpd7tpah.rs:15:12\n   |\n15 |   for (let i = 0; i < words.len(); i++) {\n   |           -^ expected one of `)`, `,`, `@`, or `|`\n   |           |\n   |           help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmpgpd7tpah.rs:15:14\n   |\n15 |   for (let i = 0; i < words.len(); i++) {\n   |              ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmpgpd7tpah.rs:15:13\n   |\n15 |   for (let i = 0; i < words.len(); i++) {\n   |             ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmpgpd7tpah.rs:15:14\n   |\n15 |   for (let i = 0; i < words.len(); i++) {\n   |              ^ expected expression\n\nerror: aborting due to 5 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function that accepts a vector of strings.\n/// The vector contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n  let max_count = 0\n  let max_word = \"\"\n  for w in words {\n    let count = count_unique_chars(w)\n    if count > max_count {\n      max_count = count\n      max_word = w\n    }\n  }\n  return max_word\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]), String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]), String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]), String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n}\n",
      "timestamp": 1664292578,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmp095up2vv.rs:12:20\n   |\n12 |   let max_count = 0\n   |                    ^ help: add `;` here\n13 |   let max_word = \"\"\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmp095up2vv.rs:13:20\n   |\n13 |   let max_word = \"\"\n   |                    ^ help: add `;` here\n14 |   for w in words {\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `if`\n  --> /tmp/tmp095up2vv.rs:15:38\n   |\n15 |     let count = count_unique_chars(w)\n   |                                      ^ help: add `;` here\n16 |     if count > max_count {\n   |     -- unexpected token\n\nerror: expected `;`, found `max_word`\n  --> /tmp/tmp095up2vv.rs:17:24\n   |\n17 |       max_count = count\n   |                        ^ help: add `;` here\n18 |       max_word = w\n   |       -------- unexpected token\n\nerror[E0425]: cannot find function `count_unique_chars` in this scope\n  --> /tmp/tmp095up2vv.rs:15:17\n   |\n15 |     let count = count_unique_chars(w)\n   |                 ^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp095up2vv.rs:18:18\n   |\n13 |   let max_word = \"\"\n   |                  -- expected due to this value\n...\n18 |       max_word = w\n   |                  ^\n   |                  |\n   |                  expected `&str`, found struct `String`\n   |                  help: consider borrowing here: `&w`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp095up2vv.rs:21:10\n   |\n11 | fn find_max(words: Vec<String>) -> String {\n   |                                    ------ expected `String` because of return type\n...\n21 |   return max_word\n   |          ^^^^^^^^- help: try using a conversion method: `.to_string()`\n   |          |\n   |          expected struct `String`, found `&str`\n\nerror: aborting due to 7 previous errors\n\nSome errors have detailed explanations: E0308, E0425.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function that accepts a vector of strings.\n/// The vector contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n  let max_count = 0\n  let max_word = \"\"\n  for w in words {\n    let count = count_unique_chars(w)\n    if count > max_count {\n      max_count = count\n      max_word = w\n    }\n  }\n  return max_word\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]), String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]), String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]), String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n}\n",
      "timestamp": 1664292578,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmp095up2vv.rs:12:20\n   |\n12 |   let max_count = 0\n   |                    ^ help: add `;` here\n13 |   let max_word = \"\"\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmp095up2vv.rs:13:20\n   |\n13 |   let max_word = \"\"\n   |                    ^ help: add `;` here\n14 |   for w in words {\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `if`\n  --> /tmp/tmp095up2vv.rs:15:38\n   |\n15 |     let count = count_unique_chars(w)\n   |                                      ^ help: add `;` here\n16 |     if count > max_count {\n   |     -- unexpected token\n\nerror: expected `;`, found `max_word`\n  --> /tmp/tmp095up2vv.rs:17:24\n   |\n17 |       max_count = count\n   |                        ^ help: add `;` here\n18 |       max_word = w\n   |       -------- unexpected token\n\nerror[E0425]: cannot find function `count_unique_chars` in this scope\n  --> /tmp/tmp095up2vv.rs:15:17\n   |\n15 |     let count = count_unique_chars(w)\n   |                 ^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp095up2vv.rs:18:18\n   |\n13 |   let max_word = \"\"\n   |                  -- expected due to this value\n...\n18 |       max_word = w\n   |                  ^\n   |                  |\n   |                  expected `&str`, found struct `String`\n   |                  help: consider borrowing here: `&w`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp095up2vv.rs:21:10\n   |\n11 | fn find_max(words: Vec<String>) -> String {\n   |                                    ------ expected `String` because of return type\n...\n21 |   return max_word\n   |          ^^^^^^^^- help: try using a conversion method: `.to_string()`\n   |          |\n   |          expected struct `String`, found `&str`\n\nerror: aborting due to 7 previous errors\n\nSome errors have detailed explanations: E0308, E0425.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function that accepts a vector of strings.\n/// The vector contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n  let max_count = 0\n  let max_word = \"\"\n  for w in words {\n    let count = count_unique_chars(w)\n    if count > max_count {\n      max_count = count\n      max_word = w\n    }\n  }\n  return max_word\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]), String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]), String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]), String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n}\n",
      "timestamp": 1664292578,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmp095up2vv.rs:12:20\n   |\n12 |   let max_count = 0\n   |                    ^ help: add `;` here\n13 |   let max_word = \"\"\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmp095up2vv.rs:13:20\n   |\n13 |   let max_word = \"\"\n   |                    ^ help: add `;` here\n14 |   for w in words {\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `if`\n  --> /tmp/tmp095up2vv.rs:15:38\n   |\n15 |     let count = count_unique_chars(w)\n   |                                      ^ help: add `;` here\n16 |     if count > max_count {\n   |     -- unexpected token\n\nerror: expected `;`, found `max_word`\n  --> /tmp/tmp095up2vv.rs:17:24\n   |\n17 |       max_count = count\n   |                        ^ help: add `;` here\n18 |       max_word = w\n   |       -------- unexpected token\n\nerror[E0425]: cannot find function `count_unique_chars` in this scope\n  --> /tmp/tmp095up2vv.rs:15:17\n   |\n15 |     let count = count_unique_chars(w)\n   |                 ^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp095up2vv.rs:18:18\n   |\n13 |   let max_word = \"\"\n   |                  -- expected due to this value\n...\n18 |       max_word = w\n   |                  ^\n   |                  |\n   |                  expected `&str`, found struct `String`\n   |                  help: consider borrowing here: `&w`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp095up2vv.rs:21:10\n   |\n11 | fn find_max(words: Vec<String>) -> String {\n   |                                    ------ expected `String` because of return type\n...\n21 |   return max_word\n   |          ^^^^^^^^- help: try using a conversion method: `.to_string()`\n   |          |\n   |          expected struct `String`, found `&str`\n\nerror: aborting due to 7 previous errors\n\nSome errors have detailed explanations: E0308, E0425.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function that accepts a vector of strings.\n/// The vector contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n  let max_count = 0\n  let max_word = \"\"\n  for w in words {\n    let count = count_unique_chars(w)\n    if count > max_count {\n      max_count = count\n      max_word = w\n    }\n  }\n  return max_word\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]), String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]), String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]), String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n}\n",
      "timestamp": 1664292578,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmp095up2vv.rs:12:20\n   |\n12 |   let max_count = 0\n   |                    ^ help: add `;` here\n13 |   let max_word = \"\"\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmp095up2vv.rs:13:20\n   |\n13 |   let max_word = \"\"\n   |                    ^ help: add `;` here\n14 |   for w in words {\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `if`\n  --> /tmp/tmp095up2vv.rs:15:38\n   |\n15 |     let count = count_unique_chars(w)\n   |                                      ^ help: add `;` here\n16 |     if count > max_count {\n   |     -- unexpected token\n\nerror: expected `;`, found `max_word`\n  --> /tmp/tmp095up2vv.rs:17:24\n   |\n17 |       max_count = count\n   |                        ^ help: add `;` here\n18 |       max_word = w\n   |       -------- unexpected token\n\nerror[E0425]: cannot find function `count_unique_chars` in this scope\n  --> /tmp/tmp095up2vv.rs:15:17\n   |\n15 |     let count = count_unique_chars(w)\n   |                 ^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp095up2vv.rs:18:18\n   |\n13 |   let max_word = \"\"\n   |                  -- expected due to this value\n...\n18 |       max_word = w\n   |                  ^\n   |                  |\n   |                  expected `&str`, found struct `String`\n   |                  help: consider borrowing here: `&w`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp095up2vv.rs:21:10\n   |\n11 | fn find_max(words: Vec<String>) -> String {\n   |                                    ------ expected `String` because of return type\n...\n21 |   return max_word\n   |          ^^^^^^^^- help: try using a conversion method: `.to_string()`\n   |          |\n   |          expected struct `String`, found `&str`\n\nerror: aborting due to 7 previous errors\n\nSome errors have detailed explanations: E0308, E0425.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function that accepts a vector of strings.\n/// The vector contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n  let max_count = 0\n  let max_word = String::from(\"\")\n  for w in words {\n    let count = w.count(/[a-z]/);\n    if count > max_count {\n      max_count = count\n      max_word = w\n    }\n  }\n  return max_word\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]), String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]), String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]), String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n}\n",
      "timestamp": 1664292578,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmppewkjxfa.rs:12:20\n   |\n12 |   let max_count = 0\n   |                    ^ help: add `;` here\n13 |   let max_word = String::from(\"\")\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmppewkjxfa.rs:13:34\n   |\n13 |   let max_word = String::from(\"\")\n   |                                  ^ help: add `;` here\n14 |   for w in words {\n   |   --- unexpected token\n\nerror: expected expression, found `/`\n  --> /tmp/tmppewkjxfa.rs:15:25\n   |\n15 |     let count = w.count(/[a-z]/);\n   |                         ^ expected expression\n\nerror: aborting due to 3 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function that accepts a vector of strings.\n/// The vector contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n  let max_count = 0\n  let max_word = \"\"\n  for w in words {\n    let count = count_unique_chars(w)\n    if count > max_count {\n      max_count = count\n      max_word = w\n    }\n  }\n  return max_word\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]), String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]), String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]), String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n}\n",
      "timestamp": 1664292578,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmp095up2vv.rs:12:20\n   |\n12 |   let max_count = 0\n   |                    ^ help: add `;` here\n13 |   let max_word = \"\"\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmp095up2vv.rs:13:20\n   |\n13 |   let max_word = \"\"\n   |                    ^ help: add `;` here\n14 |   for w in words {\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `if`\n  --> /tmp/tmp095up2vv.rs:15:38\n   |\n15 |     let count = count_unique_chars(w)\n   |                                      ^ help: add `;` here\n16 |     if count > max_count {\n   |     -- unexpected token\n\nerror: expected `;`, found `max_word`\n  --> /tmp/tmp095up2vv.rs:17:24\n   |\n17 |       max_count = count\n   |                        ^ help: add `;` here\n18 |       max_word = w\n   |       -------- unexpected token\n\nerror[E0425]: cannot find function `count_unique_chars` in this scope\n  --> /tmp/tmp095up2vv.rs:15:17\n   |\n15 |     let count = count_unique_chars(w)\n   |                 ^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp095up2vv.rs:18:18\n   |\n13 |   let max_word = \"\"\n   |                  -- expected due to this value\n...\n18 |       max_word = w\n   |                  ^\n   |                  |\n   |                  expected `&str`, found struct `String`\n   |                  help: consider borrowing here: `&w`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp095up2vv.rs:21:10\n   |\n11 | fn find_max(words: Vec<String>) -> String {\n   |                                    ------ expected `String` because of return type\n...\n21 |   return max_word\n   |          ^^^^^^^^- help: try using a conversion method: `.to_string()`\n   |          |\n   |          expected struct `String`, found `&str`\n\nerror: aborting due to 7 previous errors\n\nSome errors have detailed explanations: E0308, E0425.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function that accepts a vector of strings.\n/// The vector contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n  let max_count = 0\n  let max_word = \"\"\n  for w in words {\n    let count = w.count(/[a-z]/);\n    if count > max_count {\n      max_count = count\n      max_word = w\n    }\n  }\n  return max_word\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]), String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]), String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]), String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n}\n",
      "timestamp": 1664292578,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmpk6mb5m3s.rs:12:20\n   |\n12 |   let max_count = 0\n   |                    ^ help: add `;` here\n13 |   let max_word = \"\"\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpk6mb5m3s.rs:13:20\n   |\n13 |   let max_word = \"\"\n   |                    ^ help: add `;` here\n14 |   for w in words {\n   |   --- unexpected token\n\nerror: expected expression, found `/`\n  --> /tmp/tmpk6mb5m3s.rs:15:25\n   |\n15 |     let count = w.count(/[a-z]/);\n   |                         ^ expected expression\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpk6mb5m3s.rs:21:10\n   |\n11 | fn find_max(words: Vec<String>) -> String {\n   |                                    ------ expected `String` because of return type\n...\n21 |   return max_word\n   |          ^^^^^^^^- help: try using a conversion method: `.to_string()`\n   |          |\n   |          expected struct `String`, found `&str`\n\nerror: aborting due to 4 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function that accepts a vector of strings.\n/// The vector contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n  let max_count = 0\n  let max_word = \"\"\n  for w in words {\n    let count = w.count(/[a-z]/);\n    if count > max_count {\n      max_count = count\n      max_word = w\n    }\n  }\n  return max_word\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]), String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]), String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]), String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n}\n",
      "timestamp": 1664292578,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmpk6mb5m3s.rs:12:20\n   |\n12 |   let max_count = 0\n   |                    ^ help: add `;` here\n13 |   let max_word = \"\"\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpk6mb5m3s.rs:13:20\n   |\n13 |   let max_word = \"\"\n   |                    ^ help: add `;` here\n14 |   for w in words {\n   |   --- unexpected token\n\nerror: expected expression, found `/`\n  --> /tmp/tmpk6mb5m3s.rs:15:25\n   |\n15 |     let count = w.count(/[a-z]/);\n   |                         ^ expected expression\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpk6mb5m3s.rs:21:10\n   |\n11 | fn find_max(words: Vec<String>) -> String {\n   |                                    ------ expected `String` because of return type\n...\n21 |   return max_word\n   |          ^^^^^^^^- help: try using a conversion method: `.to_string()`\n   |          |\n   |          expected struct `String`, found `&str`\n\nerror: aborting due to 4 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function that accepts a vector of strings.\n/// The vector contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n  let max_count = 0\n  let max_word = \"\"\n  for w in words {\n    let count = w.count(/[a-z]/);\n    if count > max_count {\n      max_count = count\n      max_word = w\n    }\n  }\n  return max_word\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]), String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]), String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]), String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n}\n",
      "timestamp": 1664292578,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmpk6mb5m3s.rs:12:20\n   |\n12 |   let max_count = 0\n   |                    ^ help: add `;` here\n13 |   let max_word = \"\"\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpk6mb5m3s.rs:13:20\n   |\n13 |   let max_word = \"\"\n   |                    ^ help: add `;` here\n14 |   for w in words {\n   |   --- unexpected token\n\nerror: expected expression, found `/`\n  --> /tmp/tmpk6mb5m3s.rs:15:25\n   |\n15 |     let count = w.count(/[a-z]/);\n   |                         ^ expected expression\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpk6mb5m3s.rs:21:10\n   |\n11 | fn find_max(words: Vec<String>) -> String {\n   |                                    ------ expected `String` because of return type\n...\n21 |   return max_word\n   |          ^^^^^^^^- help: try using a conversion method: `.to_string()`\n   |          |\n   |          expected struct `String`, found `&str`\n\nerror: aborting due to 4 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function that accepts a vector of strings.\n/// The vector contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n  let max_count = 0\n  let max_word = \"\"\n  for w in words {\n    let count = count_unique_chars(w)\n    if count > max_count {\n      max_count = count\n      max_word = w\n    }\n  }\n  return max_word\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]), String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]), String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]), String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n}\n",
      "timestamp": 1664292578,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmp095up2vv.rs:12:20\n   |\n12 |   let max_count = 0\n   |                    ^ help: add `;` here\n13 |   let max_word = \"\"\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmp095up2vv.rs:13:20\n   |\n13 |   let max_word = \"\"\n   |                    ^ help: add `;` here\n14 |   for w in words {\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `if`\n  --> /tmp/tmp095up2vv.rs:15:38\n   |\n15 |     let count = count_unique_chars(w)\n   |                                      ^ help: add `;` here\n16 |     if count > max_count {\n   |     -- unexpected token\n\nerror: expected `;`, found `max_word`\n  --> /tmp/tmp095up2vv.rs:17:24\n   |\n17 |       max_count = count\n   |                        ^ help: add `;` here\n18 |       max_word = w\n   |       -------- unexpected token\n\nerror[E0425]: cannot find function `count_unique_chars` in this scope\n  --> /tmp/tmp095up2vv.rs:15:17\n   |\n15 |     let count = count_unique_chars(w)\n   |                 ^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp095up2vv.rs:18:18\n   |\n13 |   let max_word = \"\"\n   |                  -- expected due to this value\n...\n18 |       max_word = w\n   |                  ^\n   |                  |\n   |                  expected `&str`, found struct `String`\n   |                  help: consider borrowing here: `&w`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp095up2vv.rs:21:10\n   |\n11 | fn find_max(words: Vec<String>) -> String {\n   |                                    ------ expected `String` because of return type\n...\n21 |   return max_word\n   |          ^^^^^^^^- help: try using a conversion method: `.to_string()`\n   |          |\n   |          expected struct `String`, found `&str`\n\nerror: aborting due to 7 previous errors\n\nSome errors have detailed explanations: E0308, E0425.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function that accepts a vector of strings.\n/// The vector contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n  let max_count = 0\n  let max_word = \"\"\n\n  for w in words {\n    let count = count_unique_chars(w)\n    if count > max_count {\n      max_count = count\n      max_word = w\n    }\n  }\n\n  return max_word\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]), String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]), String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]), String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n}\n",
      "timestamp": 1664292578,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmpbg23g2ic.rs:12:20\n   |\n12 |   let max_count = 0\n   |                    ^ help: add `;` here\n13 |   let max_word = \"\"\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpbg23g2ic.rs:13:20\n   |\n13 |   let max_word = \"\"\n   |                    ^ help: add `;` here\n14 | \n15 |   for w in words {\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `if`\n  --> /tmp/tmpbg23g2ic.rs:16:38\n   |\n16 |     let count = count_unique_chars(w)\n   |                                      ^ help: add `;` here\n17 |     if count > max_count {\n   |     -- unexpected token\n\nerror: expected `;`, found `max_word`\n  --> /tmp/tmpbg23g2ic.rs:18:24\n   |\n18 |       max_count = count\n   |                        ^ help: add `;` here\n19 |       max_word = w\n   |       -------- unexpected token\n\nerror[E0425]: cannot find function `count_unique_chars` in this scope\n  --> /tmp/tmpbg23g2ic.rs:16:17\n   |\n16 |     let count = count_unique_chars(w)\n   |                 ^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpbg23g2ic.rs:19:18\n   |\n13 |   let max_word = \"\"\n   |                  -- expected due to this value\n...\n19 |       max_word = w\n   |                  ^\n   |                  |\n   |                  expected `&str`, found struct `String`\n   |                  help: consider borrowing here: `&w`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpbg23g2ic.rs:23:10\n   |\n11 | fn find_max(words: Vec<String>) -> String {\n   |                                    ------ expected `String` because of return type\n...\n23 |   return max_word\n   |          ^^^^^^^^- help: try using a conversion method: `.to_string()`\n   |          |\n   |          expected struct `String`, found `&str`\n\nerror: aborting due to 7 previous errors\n\nSome errors have detailed explanations: E0308, E0425.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function that accepts a vector of strings.\n/// The vector contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n  let max_count = 0\n  let max_word = String::from(\"\")\n  for w in words {\n    let count = w.count(/[a-z]/)\n    if count > max_count {\n      max_count = count\n      max_word = w\n    }\n  }\n  return max_word\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]), String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]), String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]), String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n}\n",
      "timestamp": 1664292578,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmpk2uxpx2c.rs:12:20\n   |\n12 |   let max_count = 0\n   |                    ^ help: add `;` here\n13 |   let max_word = String::from(\"\")\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpk2uxpx2c.rs:13:34\n   |\n13 |   let max_word = String::from(\"\")\n   |                                  ^ help: add `;` here\n14 |   for w in words {\n   |   --- unexpected token\n\nerror: expected expression, found `/`\n  --> /tmp/tmpk2uxpx2c.rs:15:25\n   |\n15 |     let count = w.count(/[a-z]/)\n   |                         ^ expected expression\n\nerror: aborting due to 3 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function that accepts a vector of strings.\n/// The vector contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n  let max_count = 0\n  let max_word = \"\"\n  for w in words {\n    let count = count_unique_chars(w)\n    if count > max_count {\n      max_count = count\n      max_word = w\n    }\n  }\n  return max_word\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]), String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]), String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]), String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n}\n",
      "timestamp": 1664292578,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmp095up2vv.rs:12:20\n   |\n12 |   let max_count = 0\n   |                    ^ help: add `;` here\n13 |   let max_word = \"\"\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmp095up2vv.rs:13:20\n   |\n13 |   let max_word = \"\"\n   |                    ^ help: add `;` here\n14 |   for w in words {\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `if`\n  --> /tmp/tmp095up2vv.rs:15:38\n   |\n15 |     let count = count_unique_chars(w)\n   |                                      ^ help: add `;` here\n16 |     if count > max_count {\n   |     -- unexpected token\n\nerror: expected `;`, found `max_word`\n  --> /tmp/tmp095up2vv.rs:17:24\n   |\n17 |       max_count = count\n   |                        ^ help: add `;` here\n18 |       max_word = w\n   |       -------- unexpected token\n\nerror[E0425]: cannot find function `count_unique_chars` in this scope\n  --> /tmp/tmp095up2vv.rs:15:17\n   |\n15 |     let count = count_unique_chars(w)\n   |                 ^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp095up2vv.rs:18:18\n   |\n13 |   let max_word = \"\"\n   |                  -- expected due to this value\n...\n18 |       max_word = w\n   |                  ^\n   |                  |\n   |                  expected `&str`, found struct `String`\n   |                  help: consider borrowing here: `&w`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp095up2vv.rs:21:10\n   |\n11 | fn find_max(words: Vec<String>) -> String {\n   |                                    ------ expected `String` because of return type\n...\n21 |   return max_word\n   |          ^^^^^^^^- help: try using a conversion method: `.to_string()`\n   |          |\n   |          expected struct `String`, found `&str`\n\nerror: aborting due to 7 previous errors\n\nSome errors have detailed explanations: E0308, E0425.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function that accepts a vector of strings.\n/// The vector contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n  let max_count = 0\n  let max_word = \"\"\n\n  for w in words {\n    let count = count_unique_chars(w)\n    if count > max_count {\n      max_count = count\n      max_word = w\n    }\n  }\n\n  return max_word\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]), String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]), String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]), String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n}\n",
      "timestamp": 1664292578,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmpbg23g2ic.rs:12:20\n   |\n12 |   let max_count = 0\n   |                    ^ help: add `;` here\n13 |   let max_word = \"\"\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpbg23g2ic.rs:13:20\n   |\n13 |   let max_word = \"\"\n   |                    ^ help: add `;` here\n14 | \n15 |   for w in words {\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `if`\n  --> /tmp/tmpbg23g2ic.rs:16:38\n   |\n16 |     let count = count_unique_chars(w)\n   |                                      ^ help: add `;` here\n17 |     if count > max_count {\n   |     -- unexpected token\n\nerror: expected `;`, found `max_word`\n  --> /tmp/tmpbg23g2ic.rs:18:24\n   |\n18 |       max_count = count\n   |                        ^ help: add `;` here\n19 |       max_word = w\n   |       -------- unexpected token\n\nerror[E0425]: cannot find function `count_unique_chars` in this scope\n  --> /tmp/tmpbg23g2ic.rs:16:17\n   |\n16 |     let count = count_unique_chars(w)\n   |                 ^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpbg23g2ic.rs:19:18\n   |\n13 |   let max_word = \"\"\n   |                  -- expected due to this value\n...\n19 |       max_word = w\n   |                  ^\n   |                  |\n   |                  expected `&str`, found struct `String`\n   |                  help: consider borrowing here: `&w`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpbg23g2ic.rs:23:10\n   |\n11 | fn find_max(words: Vec<String>) -> String {\n   |                                    ------ expected `String` because of return type\n...\n23 |   return max_word\n   |          ^^^^^^^^- help: try using a conversion method: `.to_string()`\n   |          |\n   |          expected struct `String`, found `&str`\n\nerror: aborting due to 7 previous errors\n\nSome errors have detailed explanations: E0308, E0425.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function that accepts a vector of strings.\n/// The vector contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n  let max_count = 0\n  let max_word = \"\"\n  for w in words {\n    let count = count_unique_chars(w)\n    if count > max_count {\n      max_count = count\n      max_word = w\n    }\n  }\n  return max_word\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]), String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]), String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]), String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n}\n",
      "timestamp": 1664292578,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmp095up2vv.rs:12:20\n   |\n12 |   let max_count = 0\n   |                    ^ help: add `;` here\n13 |   let max_word = \"\"\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmp095up2vv.rs:13:20\n   |\n13 |   let max_word = \"\"\n   |                    ^ help: add `;` here\n14 |   for w in words {\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `if`\n  --> /tmp/tmp095up2vv.rs:15:38\n   |\n15 |     let count = count_unique_chars(w)\n   |                                      ^ help: add `;` here\n16 |     if count > max_count {\n   |     -- unexpected token\n\nerror: expected `;`, found `max_word`\n  --> /tmp/tmp095up2vv.rs:17:24\n   |\n17 |       max_count = count\n   |                        ^ help: add `;` here\n18 |       max_word = w\n   |       -------- unexpected token\n\nerror[E0425]: cannot find function `count_unique_chars` in this scope\n  --> /tmp/tmp095up2vv.rs:15:17\n   |\n15 |     let count = count_unique_chars(w)\n   |                 ^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp095up2vv.rs:18:18\n   |\n13 |   let max_word = \"\"\n   |                  -- expected due to this value\n...\n18 |       max_word = w\n   |                  ^\n   |                  |\n   |                  expected `&str`, found struct `String`\n   |                  help: consider borrowing here: `&w`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp095up2vv.rs:21:10\n   |\n11 | fn find_max(words: Vec<String>) -> String {\n   |                                    ------ expected `String` because of return type\n...\n21 |   return max_word\n   |          ^^^^^^^^- help: try using a conversion method: `.to_string()`\n   |          |\n   |          expected struct `String`, found `&str`\n\nerror: aborting due to 7 previous errors\n\nSome errors have detailed explanations: E0308, E0425.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function that accepts a vector of strings.\n/// The vector contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n  let max_count = 0\n  let max_word = String::from(\"\")\n  for w in words {\n    let count = w.count(/[a-z]/);\n    if count > max_count {\n      max_count = count\n      max_word = w\n    }\n  }\n  return max_word\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]), String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]), String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]), String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n}\n",
      "timestamp": 1664292578,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmppewkjxfa.rs:12:20\n   |\n12 |   let max_count = 0\n   |                    ^ help: add `;` here\n13 |   let max_word = String::from(\"\")\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmppewkjxfa.rs:13:34\n   |\n13 |   let max_word = String::from(\"\")\n   |                                  ^ help: add `;` here\n14 |   for w in words {\n   |   --- unexpected token\n\nerror: expected expression, found `/`\n  --> /tmp/tmppewkjxfa.rs:15:25\n   |\n15 |     let count = w.count(/[a-z]/);\n   |                         ^ expected expression\n\nerror: aborting due to 3 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function that accepts a vector of strings.\n/// The vector contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n  let max_count = 0\n  let max_word = \"\"\n  for w in words {\n    let count = w.count_unique_chars()\n    if count > max_count {\n      max_count = count\n      max_word = w\n    }\n  }\n  return max_word\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]), String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]), String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]), String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n}\n",
      "timestamp": 1664292578,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmp83xgxfl_.rs:12:20\n   |\n12 |   let max_count = 0\n   |                    ^ help: add `;` here\n13 |   let max_word = \"\"\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmp83xgxfl_.rs:13:20\n   |\n13 |   let max_word = \"\"\n   |                    ^ help: add `;` here\n14 |   for w in words {\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `if`\n  --> /tmp/tmp83xgxfl_.rs:15:39\n   |\n15 |     let count = w.count_unique_chars()\n   |                                       ^ help: add `;` here\n16 |     if count > max_count {\n   |     -- unexpected token\n\nerror: expected `;`, found `max_word`\n  --> /tmp/tmp83xgxfl_.rs:17:24\n   |\n17 |       max_count = count\n   |                        ^ help: add `;` here\n18 |       max_word = w\n   |       -------- unexpected token\n\nerror[E0599]: no method named `count_unique_chars` found for struct `String` in the current scope\n  --> /tmp/tmp83xgxfl_.rs:15:19\n   |\n15 |     let count = w.count_unique_chars()\n   |                   ^^^^^^^^^^^^^^^^^^ method not found in `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp83xgxfl_.rs:18:18\n   |\n13 |   let max_word = \"\"\n   |                  -- expected due to this value\n...\n18 |       max_word = w\n   |                  ^\n   |                  |\n   |                  expected `&str`, found struct `String`\n   |                  help: consider borrowing here: `&w`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp83xgxfl_.rs:21:10\n   |\n11 | fn find_max(words: Vec<String>) -> String {\n   |                                    ------ expected `String` because of return type\n...\n21 |   return max_word\n   |          ^^^^^^^^- help: try using a conversion method: `.to_string()`\n   |          |\n   |          expected struct `String`, found `&str`\n\nerror: aborting due to 7 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function that accepts a vector of strings.\n/// The vector contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n  let max_count = 0\n  let max_word = \"\"\n  for w in words {\n    let count = w.count(/[a-z]/);\n    if count > max_count {\n      max_count = count\n      max_word = w\n    }\n  }\n  return max_word\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]), String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]), String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]), String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n}\n",
      "timestamp": 1664292578,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmpk6mb5m3s.rs:12:20\n   |\n12 |   let max_count = 0\n   |                    ^ help: add `;` here\n13 |   let max_word = \"\"\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpk6mb5m3s.rs:13:20\n   |\n13 |   let max_word = \"\"\n   |                    ^ help: add `;` here\n14 |   for w in words {\n   |   --- unexpected token\n\nerror: expected expression, found `/`\n  --> /tmp/tmpk6mb5m3s.rs:15:25\n   |\n15 |     let count = w.count(/[a-z]/);\n   |                         ^ expected expression\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpk6mb5m3s.rs:21:10\n   |\n11 | fn find_max(words: Vec<String>) -> String {\n   |                                    ------ expected `String` because of return type\n...\n21 |   return max_word\n   |          ^^^^^^^^- help: try using a conversion method: `.to_string()`\n   |          |\n   |          expected struct `String`, found `&str`\n\nerror: aborting due to 4 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function that accepts a vector of strings.\n/// The vector contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n  let max_count = 0;\n  let max_word = String::from(\"\");\n  for w in words {\n    let count = w.count_unique();\n    if count > max_count {\n      max_count = count;\n      max_word = w;\n    }\n  }\n  return max_word;\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]), String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]), String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]), String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n}\n",
      "timestamp": 1664292578,
      "stdout": "",
      "stderr": "error[E0599]: no method named `count_unique` found for struct `String` in the current scope\n  --> /tmp/tmp71nqoyt4.rs:15:19\n   |\n15 |     let count = w.count_unique();\n   |                   ^^^^^^^^^^^^ method not found in `String`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Write a function that accepts a vector of strings.\n/// The vector contains different words. Return the word with maximum number\n/// of unique characters. If multiple strings have maximum number of unique\n/// characters, return the one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"string\")\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"aaaaaaa\")\nfn find_max(words: Vec<String>) -> String {\n  let max_count = 0\n  let max_word = \"\"\n\n  for word in words {\n    let count = word.count(/[a-z]/);\n    if count > max_count {\n      max_count = count\n      max_word = word\n    }\n  }\n\n  return max_word\n}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\")]), String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]), String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"), String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]), String::from(\"this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]), String::from(\"b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"play\"), String::from(\"play\")]), String::from(\"play\"));\n}\n",
      "timestamp": 1664292578,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmpq4pa7_ob.rs:12:20\n   |\n12 |   let max_count = 0\n   |                    ^ help: add `;` here\n13 |   let max_word = \"\"\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpq4pa7_ob.rs:13:20\n   |\n13 |   let max_word = \"\"\n   |                    ^ help: add `;` here\n14 | \n15 |   for word in words {\n   |   --- unexpected token\n\nerror: expected expression, found `/`\n  --> /tmp/tmpq4pa7_ob.rs:16:28\n   |\n16 |     let count = word.count(/[a-z]/);\n   |                            ^ expected expression\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpq4pa7_ob.rs:23:10\n   |\n11 | fn find_max(words: Vec<String>) -> String {\n   |                                    ------ expected `String` because of return type\n...\n23 |   return max_word\n   |          ^^^^^^^^- help: try using a conversion method: `.to_string()`\n   |          |\n   |          expected struct `String`, found `&str`\n\nerror: aborting due to 4 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    }
  ]
}