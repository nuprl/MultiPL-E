{
  "name": "HumanEval_135_can_arrange",
  "language": "rs",
  "prompt": "/// Create a function which returns the largest index of an element which\n/// is not greater than or equal to the element immediately preceding it. If\n/// no such element exists then return -1. The given vector will not contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>) -> isize {\n",
  "tests": "}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n",
  "stop_tokens": [
    "\n}"
  ],
  "results": [
    {
      "program": "/// Create a function which returns the largest index of an element which\n/// is not greater than or equal to the element immediately preceding it. If\n/// no such element exists then return -1. The given vector will not contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>) -> isize {\n  let max_index = -1;\n  let max_value = -1;\n  for i in arr {\n    if max_value < i {\n      max_value = i;\n      max_index = i;\n    }\n  }\n  return max_index;\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n",
      "timestamp": 1664293282,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max_value`\n  --> /tmp/tmphny9rh5r.rs:15:7\n   |\n12 |   let max_value = -1;\n   |       ---------\n   |       |\n   |       first assignment to `max_value`\n   |       help: consider making this binding mutable: `mut max_value`\n...\n15 |       max_value = i;\n   |       ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `max_index`\n  --> /tmp/tmphny9rh5r.rs:16:7\n   |\n11 |   let max_index = -1;\n   |       ---------\n   |       |\n   |       first assignment to `max_index`\n   |       help: consider making this binding mutable: `mut max_index`\n...\n16 |       max_index = i;\n   |       ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Create a function which returns the largest index of an element which\n/// is not greater than or equal to the element immediately preceding it. If\n/// no such element exists then return -1. The given vector will not contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>) -> isize {\n  let max_index = -1;\n  for i in 0..arr.len() {\n    if arr[i] > arr[i - 1] {\n      max_index = i;\n    }\n  }\n  return max_index;\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n",
      "timestamp": 1664293282,
      "stdout": "",
      "stderr": "error[E0277]: the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmp52a60guj.rs:11:19\n   |\n11 |   let max_index = -1;\n   |                   ^^ the trait `Neg` is not implemented for `usize`\n   |\n   = help: the following other types implement trait `Neg`:\n             &f32\n             &f64\n             &i128\n             &i16\n             &i32\n             &i64\n             &i8\n             &isize\n           and 8 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp52a60guj.rs:17:10\n   |\n10 | fn can_arrange(arr: Vec<isize>) -> isize {\n   |                                    ----- expected `isize` because of return type\n...\n17 |   return max_index;\n   |          ^^^^^^^^^ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the converted value doesn't fit\n   |\n17 |   return max_index.try_into().unwrap();\n   |                   ++++++++++++++++++++\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Create a function which returns the largest index of an element which\n/// is not greater than or equal to the element immediately preceding it. If\n/// no such element exists then return -1. The given vector will not contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>) -> isize {\n  let max_index = -1;\n  for i in 0..arr.len() - 1 {\n    if arr[i] <= arr[i + 1] {\n      max_index = i;\n      break;\n    }\n  }\n  return max_index;\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n",
      "timestamp": 1664293282,
      "stdout": "",
      "stderr": "error[E0277]: the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmp50pk2kij.rs:11:19\n   |\n11 |   let max_index = -1;\n   |                   ^^ the trait `Neg` is not implemented for `usize`\n   |\n   = help: the following other types implement trait `Neg`:\n             &f32\n             &f64\n             &i128\n             &i16\n             &i32\n             &i64\n             &i8\n             &isize\n           and 8 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp50pk2kij.rs:18:10\n   |\n10 | fn can_arrange(arr: Vec<isize>) -> isize {\n   |                                    ----- expected `isize` because of return type\n...\n18 |   return max_index;\n   |          ^^^^^^^^^ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the converted value doesn't fit\n   |\n18 |   return max_index.try_into().unwrap();\n   |                   ++++++++++++++++++++\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Create a function which returns the largest index of an element which\n/// is not greater than or equal to the element immediately preceding it. If\n/// no such element exists then return -1. The given vector will not contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>) -> isize {\n  let max_index = -1;\n  for i in arr {\n    if i > max_index {\n      max_index = i;\n    }\n  }\n  return max_index;\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n",
      "timestamp": 1664293282,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max_index`\n  --> /tmp/tmpkwi327od.rs:14:7\n   |\n11 |   let max_index = -1;\n   |       ---------\n   |       |\n   |       first assignment to `max_index`\n   |       help: consider making this binding mutable: `mut max_index`\n...\n14 |       max_index = i;\n   |       ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Create a function which returns the largest index of an element which\n/// is not greater than or equal to the element immediately preceding it. If\n/// no such element exists then return -1. The given vector will not contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>) -> isize {\n  let max_index = 0\n  for i in arr {\n    if i > max_index {\n      max_index = i\n    }\n  }\n  if max_index == 0 {\n    return -1\n  }\n  return max_index\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n",
      "timestamp": 1664293282,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `for`\n  --> /tmp/tmpudycxnrf.rs:11:20\n   |\n11 |   let max_index = 0\n   |                    ^ help: add `;` here\n12 |   for i in arr {\n   |   --- unexpected token\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Create a function which returns the largest index of an element which\n/// is not greater than or equal to the element immediately preceding it. If\n/// no such element exists then return -1. The given vector will not contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>) -> isize {\n  let i = 0;\n  for i in arr.iter().next() {\n    if arr[i] > arr[i - 1] {\n      return i - 1;\n    }\n  }\n  return -1;\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n",
      "timestamp": 1664293282,
      "stdout": "",
      "stderr": "error[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmpknr__r3m.rs:13:8\n   |\n13 |     if arr[i] > arr[i - 1] {\n   |        ^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpknr__r3m.rs:13:17\n   |\n13 |     if arr[i] > arr[i - 1] {\n   |                 ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Create a function which returns the largest index of an element which\n/// is not greater than or equal to the element immediately preceding it. If\n/// no such element exists then return -1. The given vector will not contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>) -> isize {\n  let i = 0;\n  let j = arr.len - 1;\n  while (i < j) {\n    if (arr[i] < arr[j]) {\n      j -= 1;\n    } else {\n      i += 1;\n    }\n  }\n  if (i == j) {\n    return -1;\n  } else {\n    return i;\n  }\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n",
      "timestamp": 1664293282,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpkzzmcl12.rs:13:9\n   |\n13 |   while (i < j) {\n   |         ^     ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -   while (i < j) {\n13 +   while i < j {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpkzzmcl12.rs:14:8\n   |\n14 |     if (arr[i] < arr[j]) {\n   |        ^               ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (arr[i] < arr[j]) {\n14 +     if arr[i] < arr[j] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpkzzmcl12.rs:20:6\n   |\n20 |   if (i == j) {\n   |      ^      ^\n   |\nhelp: remove these parentheses\n   |\n20 -   if (i == j) {\n20 +   if i == j {\n   | \n\nerror[E0616]: field `len` of struct `Vec` is private\n  --> /tmp/tmpkzzmcl12.rs:12:15\n   |\n12 |   let j = arr.len - 1;\n   |               ^^^ private field\n   |\nhelp: a method `len` also exists, call it with parentheses\n   |\n12 |   let j = arr.len() - 1;\n   |                  ++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpkzzmcl12.rs:23:12\n   |\n10 | fn can_arrange(arr: Vec<isize>) -> isize {\n   |                                    ----- expected `isize` because of return type\n...\n23 |     return i;\n   |            ^ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the converted value doesn't fit\n   |\n23 |     return i.try_into().unwrap();\n   |             ++++++++++++++++++++\n\nerror: aborting due to 2 previous errors; 3 warnings emitted\n\nSome errors have detailed explanations: E0308, E0616.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Create a function which returns the largest index of an element which\n/// is not greater than or equal to the element immediately preceding it. If\n/// no such element exists then return -1. The given vector will not contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>) -> isize {\n  let max_index = -1;\n  let max_value = -1;\n  for i in arr {\n    if i > max_value {\n      max_index = i;\n      max_value = i;\n    }\n  }\n  return max_index;\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n",
      "timestamp": 1664293282,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max_index`\n  --> /tmp/tmpnfmbev2i.rs:15:7\n   |\n11 |   let max_index = -1;\n   |       ---------\n   |       |\n   |       first assignment to `max_index`\n   |       help: consider making this binding mutable: `mut max_index`\n...\n15 |       max_index = i;\n   |       ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `max_value`\n  --> /tmp/tmpnfmbev2i.rs:16:7\n   |\n12 |   let max_value = -1;\n   |       ---------\n   |       |\n   |       first assignment to `max_value`\n   |       help: consider making this binding mutable: `mut max_value`\n...\n16 |       max_value = i;\n   |       ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Create a function which returns the largest index of an element which\n/// is not greater than or equal to the element immediately preceding it. If\n/// no such element exists then return -1. The given vector will not contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>) -> isize {\n  let max_index = 0\n  for i in 0..arr.len() {\n    if arr[i] > arr[max_index] {\n      max_index = i\n    }\n  }\n  if max_index == 0 {\n    return -1\n  } else {\n    return max_index\n  }\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n",
      "timestamp": 1664293282,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `for`\n  --> /tmp/tmppyvdrxgc.rs:11:20\n   |\n11 |   let max_index = 0\n   |                    ^ help: add `;` here\n12 |   for i in 0..arr.len() {\n   |   --- unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmppyvdrxgc.rs:20:12\n   |\n10 | fn can_arrange(arr: Vec<isize>) -> isize {\n   |                                    ----- expected `isize` because of return type\n...\n20 |     return max_index\n   |            ^^^^^^^^^ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the converted value doesn't fit\n   |\n20 |     return max_index.try_into().unwrap()\n   |                     ++++++++++++++++++++\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Create a function which returns the largest index of an element which\n/// is not greater than or equal to the element immediately preceding it. If\n/// no such element exists then return -1. The given vector will not contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>) -> isize {\n  let i = 0;\n  let j = arr.len() - 1;\n  while (i < j) {\n    if (arr[i] < arr[j]) {\n      j -= 1;\n    } else {\n      return i;\n    }\n  }\n  return -1;\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n",
      "timestamp": 1664293282,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmprrwh5kur.rs:13:9\n   |\n13 |   while (i < j) {\n   |         ^     ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -   while (i < j) {\n13 +   while i < j {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmprrwh5kur.rs:14:8\n   |\n14 |     if (arr[i] < arr[j]) {\n   |        ^               ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (arr[i] < arr[j]) {\n14 +     if arr[i] < arr[j] {\n   | \n\nerror[E0308]: mismatched types\n  --> /tmp/tmprrwh5kur.rs:17:14\n   |\n17 |       return i;\n   |              ^ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the converted value doesn't fit\n   |\n17 |       return i.try_into().unwrap();\n   |               ++++++++++++++++++++\n\nerror: aborting due to previous error; 2 warnings emitted\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Create a function which returns the largest index of an element which\n/// is not greater than or equal to the element immediately preceding it. If\n/// no such element exists then return -1. The given vector will not contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>) -> isize {\n  let max_index = 0\n  let max_value = arr[0]\n  for i in arr {\n    if i > max_value {\n      max_index = i\n      max_value = i\n    }\n  }\n  if max_index == 0 {\n    return -1\n  }\n  return max_index\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n",
      "timestamp": 1664293282,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmpbqt6m493.rs:11:20\n   |\n11 |   let max_index = 0\n   |                    ^ help: add `;` here\n12 |   let max_value = arr[0]\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpbqt6m493.rs:12:25\n   |\n12 |   let max_value = arr[0]\n   |                         ^ help: add `;` here\n13 |   for i in arr {\n   |   --- unexpected token\n\nerror: expected `;`, found `max_value`\n  --> /tmp/tmpbqt6m493.rs:15:20\n   |\n15 |       max_index = i\n   |                    ^ help: add `;` here\n16 |       max_value = i\n   |       --------- unexpected token\n\nerror: aborting due to 3 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Create a function which returns the largest index of an element which\n/// is not greater than or equal to the element immediately preceding it. If\n/// no such element exists then return -1. The given vector will not contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>) -> isize {\n  let max_index = 0\n  let max_value = arr[0]\n  for i in arr {\n    if i <= max_value {\n      max_index = i\n      max_value = i\n    }\n  }\n  if max_index == 0 {\n    return -1\n  }\n  return max_index\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n",
      "timestamp": 1664293282,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmp7nav3yor.rs:11:20\n   |\n11 |   let max_index = 0\n   |                    ^ help: add `;` here\n12 |   let max_value = arr[0]\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmp7nav3yor.rs:12:25\n   |\n12 |   let max_value = arr[0]\n   |                         ^ help: add `;` here\n13 |   for i in arr {\n   |   --- unexpected token\n\nerror: expected `;`, found `max_value`\n  --> /tmp/tmp7nav3yor.rs:15:20\n   |\n15 |       max_index = i\n   |                    ^ help: add `;` here\n16 |       max_value = i\n   |       --------- unexpected token\n\nerror: aborting due to 3 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Create a function which returns the largest index of an element which\n/// is not greater than or equal to the element immediately preceding it. If\n/// no such element exists then return -1. The given vector will not contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>) -> isize {\n  let max_index = -1;\n  let max_value = -1;\n  for i in arr {\n    if i > max_value {\n      max_index = i;\n      max_value = i;\n    }\n  }\n  return max_index;\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n",
      "timestamp": 1664293282,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max_index`\n  --> /tmp/tmpnfmbev2i.rs:15:7\n   |\n11 |   let max_index = -1;\n   |       ---------\n   |       |\n   |       first assignment to `max_index`\n   |       help: consider making this binding mutable: `mut max_index`\n...\n15 |       max_index = i;\n   |       ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `max_value`\n  --> /tmp/tmpnfmbev2i.rs:16:7\n   |\n12 |   let max_value = -1;\n   |       ---------\n   |       |\n   |       first assignment to `max_value`\n   |       help: consider making this binding mutable: `mut max_value`\n...\n16 |       max_value = i;\n   |       ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Create a function which returns the largest index of an element which\n/// is not greater than or equal to the element immediately preceding it. If\n/// no such element exists then return -1. The given vector will not contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>) -> isize {\n    let max_index = 0\n    let max_value = arr[0]\n    for i in arr {\n        if i > max_value {\n            max_value = i\n            max_index = i\n        }\n    }\n    return max_index\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n",
      "timestamp": 1664293282,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmplwp3ppm9.rs:11:22\n   |\n11 |     let max_index = 0\n   |                      ^ help: add `;` here\n12 |     let max_value = arr[0]\n   |     --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmplwp3ppm9.rs:12:27\n   |\n12 |     let max_value = arr[0]\n   |                           ^ help: add `;` here\n13 |     for i in arr {\n   |     --- unexpected token\n\nerror: expected `;`, found `max_index`\n  --> /tmp/tmplwp3ppm9.rs:15:26\n   |\n15 |             max_value = i\n   |                          ^ help: add `;` here\n16 |             max_index = i\n   |             --------- unexpected token\n\nerror: aborting due to 3 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Create a function which returns the largest index of an element which\n/// is not greater than or equal to the element immediately preceding it. If\n/// no such element exists then return -1. The given vector will not contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>) -> isize {\n  let max_index = -1;\n  let max_value = -1;\n  for i in arr {\n    if i > max_value {\n      max_index = i;\n      max_value = i;\n    }\n  }\n  return max_index;\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n",
      "timestamp": 1664293282,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max_index`\n  --> /tmp/tmpnfmbev2i.rs:15:7\n   |\n11 |   let max_index = -1;\n   |       ---------\n   |       |\n   |       first assignment to `max_index`\n   |       help: consider making this binding mutable: `mut max_index`\n...\n15 |       max_index = i;\n   |       ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `max_value`\n  --> /tmp/tmpnfmbev2i.rs:16:7\n   |\n12 |   let max_value = -1;\n   |       ---------\n   |       |\n   |       first assignment to `max_value`\n   |       help: consider making this binding mutable: `mut max_value`\n...\n16 |       max_value = i;\n   |       ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Create a function which returns the largest index of an element which\n/// is not greater than or equal to the element immediately preceding it. If\n/// no such element exists then return -1. The given vector will not contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>) -> isize {\n  let i = 0;\n  let j = arr.len() - 1;\n  while (i < j) {\n    if (arr[i] < arr[j]) {\n      j -= 1;\n    } else {\n      return i;\n    }\n  }\n  return -1;\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n",
      "timestamp": 1664293282,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmprrwh5kur.rs:13:9\n   |\n13 |   while (i < j) {\n   |         ^     ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -   while (i < j) {\n13 +   while i < j {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmprrwh5kur.rs:14:8\n   |\n14 |     if (arr[i] < arr[j]) {\n   |        ^               ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (arr[i] < arr[j]) {\n14 +     if arr[i] < arr[j] {\n   | \n\nerror[E0308]: mismatched types\n  --> /tmp/tmprrwh5kur.rs:17:14\n   |\n17 |       return i;\n   |              ^ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the converted value doesn't fit\n   |\n17 |       return i.try_into().unwrap();\n   |               ++++++++++++++++++++\n\nerror: aborting due to previous error; 2 warnings emitted\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Create a function which returns the largest index of an element which\n/// is not greater than or equal to the element immediately preceding it. If\n/// no such element exists then return -1. The given vector will not contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>) -> isize {\n  let max_index = -1;\n  let max_value = -1;\n  for i in arr {\n    if i > max_value {\n      max_value = i;\n      max_index = i - 1;\n    }\n  }\n  return max_index;\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n",
      "timestamp": 1664293282,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max_value`\n  --> /tmp/tmpk6s8eeav.rs:15:7\n   |\n12 |   let max_value = -1;\n   |       ---------\n   |       |\n   |       first assignment to `max_value`\n   |       help: consider making this binding mutable: `mut max_value`\n...\n15 |       max_value = i;\n   |       ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `max_index`\n  --> /tmp/tmpk6s8eeav.rs:16:7\n   |\n11 |   let max_index = -1;\n   |       ---------\n   |       |\n   |       first assignment to `max_index`\n   |       help: consider making this binding mutable: `mut max_index`\n...\n16 |       max_index = i - 1;\n   |       ^^^^^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Create a function which returns the largest index of an element which\n/// is not greater than or equal to the element immediately preceding it. If\n/// no such element exists then return -1. The given vector will not contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>) -> isize {\n  let max_index = -1;\n  let max_value = -1;\n  for i in arr {\n    if i > max_value {\n      max_value = i;\n      max_index = i - 1;\n    }\n  }\n  return max_index;\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n",
      "timestamp": 1664293282,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max_value`\n  --> /tmp/tmpk6s8eeav.rs:15:7\n   |\n12 |   let max_value = -1;\n   |       ---------\n   |       |\n   |       first assignment to `max_value`\n   |       help: consider making this binding mutable: `mut max_value`\n...\n15 |       max_value = i;\n   |       ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `max_index`\n  --> /tmp/tmpk6s8eeav.rs:16:7\n   |\n11 |   let max_index = -1;\n   |       ---------\n   |       |\n   |       first assignment to `max_index`\n   |       help: consider making this binding mutable: `mut max_index`\n...\n16 |       max_index = i - 1;\n   |       ^^^^^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Create a function which returns the largest index of an element which\n/// is not greater than or equal to the element immediately preceding it. If\n/// no such element exists then return -1. The given vector will not contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>) -> isize {\n  let max_index = -1;\n  let max_value = -1;\n  for i in arr {\n    if i > max_value {\n      max_value = i;\n      max_index = i - 1;\n    }\n  }\n  return max_index;\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n",
      "timestamp": 1664293282,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max_value`\n  --> /tmp/tmpk6s8eeav.rs:15:7\n   |\n12 |   let max_value = -1;\n   |       ---------\n   |       |\n   |       first assignment to `max_value`\n   |       help: consider making this binding mutable: `mut max_value`\n...\n15 |       max_value = i;\n   |       ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `max_index`\n  --> /tmp/tmpk6s8eeav.rs:16:7\n   |\n11 |   let max_index = -1;\n   |       ---------\n   |       |\n   |       first assignment to `max_index`\n   |       help: consider making this binding mutable: `mut max_index`\n...\n16 |       max_index = i - 1;\n   |       ^^^^^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Create a function which returns the largest index of an element which\n/// is not greater than or equal to the element immediately preceding it. If\n/// no such element exists then return -1. The given vector will not contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>) -> isize {\n  let i = 0;\n  for i in arr.iter() {\n    if arr[i] > arr[i - 1] {\n      return i - 1;\n    }\n  }\n  return -1;\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n",
      "timestamp": 1664293282,
      "stdout": "",
      "stderr": "error[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmp3eikhltl.rs:13:8\n   |\n13 |     if arr[i] > arr[i - 1] {\n   |        ^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmp3eikhltl.rs:13:17\n   |\n13 |     if arr[i] > arr[i - 1] {\n   |                 ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Create a function which returns the largest index of an element which\n/// is not greater than or equal to the element immediately preceding it. If\n/// no such element exists then return -1. The given vector will not contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>) -> isize {\n  let max_index = 0\n  let max_value = arr[0]\n  for i in arr {\n    if i > max_value {\n      max_value = i\n      max_index = i\n    }\n  }\n  if max_value == arr[0] {\n    return -1\n  }\n  return max_index\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n",
      "timestamp": 1664293282,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmpm4vx2tfa.rs:11:20\n   |\n11 |   let max_index = 0\n   |                    ^ help: add `;` here\n12 |   let max_value = arr[0]\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpm4vx2tfa.rs:12:25\n   |\n12 |   let max_value = arr[0]\n   |                         ^ help: add `;` here\n13 |   for i in arr {\n   |   --- unexpected token\n\nerror: expected `;`, found `max_index`\n  --> /tmp/tmpm4vx2tfa.rs:15:20\n   |\n15 |       max_value = i\n   |                    ^ help: add `;` here\n16 |       max_index = i\n   |       --------- unexpected token\n\nerror: aborting due to 3 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Create a function which returns the largest index of an element which\n/// is not greater than or equal to the element immediately preceding it. If\n/// no such element exists then return -1. The given vector will not contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>) -> isize {\n    let max_index = 0;\n    let max_value = arr[0];\n    for i in arr {\n        if i > max_value {\n            max_value = i;\n            max_index = i;\n        }\n    }\n    if max_value == arr[max_index] {\n        return -1;\n    }\n    return max_index;\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n",
      "timestamp": 1664293282,
      "stdout": "",
      "stderr": "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpzdyegb5h.rs:19:21\n   |\n19 |     if max_value == arr[max_index] {\n   |                     ^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Create a function which returns the largest index of an element which\n/// is not greater than or equal to the element immediately preceding it. If\n/// no such element exists then return -1. The given vector will not contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>) -> isize {\n  let last = arr.len - 1;\n  let i = 0;\n  for i in arr.iter() {\n    if arr[i] > arr[i + 1] {\n      return i;\n    }\n  }\n  return -1;\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n",
      "timestamp": 1664293282,
      "stdout": "",
      "stderr": "error[E0616]: field `len` of struct `Vec` is private\n  --> /tmp/tmpsf420v30.rs:11:18\n   |\n11 |   let last = arr.len - 1;\n   |                  ^^^ private field\n   |\nhelp: a method `len` also exists, call it with parentheses\n   |\n11 |   let last = arr.len() - 1;\n   |                     ++\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmpsf420v30.rs:14:8\n   |\n14 |     if arr[i] > arr[i + 1] {\n   |        ^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpsf420v30.rs:14:17\n   |\n14 |     if arr[i] > arr[i + 1] {\n   |                 ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpsf420v30.rs:15:14\n   |\n15 |       return i;\n   |              ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n15 |       return *i;\n   |              +\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations: E0277, E0308, E0616.\nFor more information about an error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Create a function which returns the largest index of an element which\n/// is not greater than or equal to the element immediately preceding it. If\n/// no such element exists then return -1. The given vector will not contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>) -> isize {\n  let max_index = -1;\n  let max_value = -1;\n  let i = 0;\n  for v in arr {\n    if v > max_value {\n      max_value = v;\n      max_index = i;\n    }\n    i += 1;\n  }\n  return max_index;\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n",
      "timestamp": 1664293282,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max_value`\n  --> /tmp/tmpwtej4ens.rs:16:7\n   |\n12 |   let max_value = -1;\n   |       ---------\n   |       |\n   |       first assignment to `max_value`\n   |       help: consider making this binding mutable: `mut max_value`\n...\n16 |       max_value = v;\n   |       ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `max_index`\n  --> /tmp/tmpwtej4ens.rs:17:7\n   |\n11 |   let max_index = -1;\n   |       ---------\n   |       |\n   |       first assignment to `max_index`\n   |       help: consider making this binding mutable: `mut max_index`\n...\n17 |       max_index = i;\n   |       ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `i`\n  --> /tmp/tmpwtej4ens.rs:19:5\n   |\n13 |   let i = 0;\n   |       -\n   |       |\n   |       first assignment to `i`\n   |       help: consider making this binding mutable: `mut i`\n...\n19 |     i += 1;\n   |     ^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 3 previous errors\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Create a function which returns the largest index of an element which\n/// is not greater than or equal to the element immediately preceding it. If\n/// no such element exists then return -1. The given vector will not contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>) -> isize {\n    let max_index = -1;\n    let max_value = -1;\n    for i in arr {\n        if max_value < i {\n            max_value = i;\n            max_index = i - 1;\n        }\n    }\n    return max_index;\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n",
      "timestamp": 1664293282,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max_value`\n  --> /tmp/tmpql19qvun.rs:15:13\n   |\n12 |     let max_value = -1;\n   |         ---------\n   |         |\n   |         first assignment to `max_value`\n   |         help: consider making this binding mutable: `mut max_value`\n...\n15 |             max_value = i;\n   |             ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `max_index`\n  --> /tmp/tmpql19qvun.rs:16:13\n   |\n11 |     let max_index = -1;\n   |         ---------\n   |         |\n   |         first assignment to `max_index`\n   |         help: consider making this binding mutable: `mut max_index`\n...\n16 |             max_index = i - 1;\n   |             ^^^^^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Create a function which returns the largest index of an element which\n/// is not greater than or equal to the element immediately preceding it. If\n/// no such element exists then return -1. The given vector will not contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>) -> isize {\n  let max_index = -1;\n  for i in 0..arr.len() {\n    if arr[i] > arr[i - 1] {\n      max_index = i;\n    }\n  }\n  return max_index;\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n",
      "timestamp": 1664293282,
      "stdout": "",
      "stderr": "error[E0277]: the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmp52a60guj.rs:11:19\n   |\n11 |   let max_index = -1;\n   |                   ^^ the trait `Neg` is not implemented for `usize`\n   |\n   = help: the following other types implement trait `Neg`:\n             &f32\n             &f64\n             &i128\n             &i16\n             &i32\n             &i64\n             &i8\n             &isize\n           and 8 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp52a60guj.rs:17:10\n   |\n10 | fn can_arrange(arr: Vec<isize>) -> isize {\n   |                                    ----- expected `isize` because of return type\n...\n17 |   return max_index;\n   |          ^^^^^^^^^ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the converted value doesn't fit\n   |\n17 |   return max_index.try_into().unwrap();\n   |                   ++++++++++++++++++++\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Create a function which returns the largest index of an element which\n/// is not greater than or equal to the element immediately preceding it. If\n/// no such element exists then return -1. The given vector will not contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>) -> isize {\n  let i = 0;\n  for j in arr {\n    if j > i {\n      return i;\n    }\n    i = j;\n  }\n  return -1;\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n",
      "timestamp": 1664293282,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `i`\n  --> /tmp/tmpcbla90l_.rs:16:5\n   |\n11 |   let i = 0;\n   |       -\n   |       |\n   |       first assignment to `i`\n   |       help: consider making this binding mutable: `mut i`\n...\n16 |     i = j;\n   |     ^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Create a function which returns the largest index of an element which\n/// is not greater than or equal to the element immediately preceding it. If\n/// no such element exists then return -1. The given vector will not contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>) -> isize {\n  let max_index = -1;\n  let max_value = 0;\n  for i in arr {\n    if i > max_value {\n      max_index = i;\n      max_value = i;\n    }\n  }\n  return max_index;\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n",
      "timestamp": 1664293282,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max_index`\n  --> /tmp/tmpp_na9_pg.rs:15:7\n   |\n11 |   let max_index = -1;\n   |       ---------\n   |       |\n   |       first assignment to `max_index`\n   |       help: consider making this binding mutable: `mut max_index`\n...\n15 |       max_index = i;\n   |       ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `max_value`\n  --> /tmp/tmpp_na9_pg.rs:16:7\n   |\n12 |   let max_value = 0;\n   |       ---------\n   |       |\n   |       first assignment to `max_value`\n   |       help: consider making this binding mutable: `mut max_value`\n...\n16 |       max_value = i;\n   |       ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Create a function which returns the largest index of an element which\n/// is not greater than or equal to the element immediately preceding it. If\n/// no such element exists then return -1. The given vector will not contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>) -> isize {\n  let max_index = -1;\n  let max_value = -1;\n  for i in arr {\n    if i > max_value {\n      max_index = i;\n      max_value = i;\n    }\n  }\n  return max_index;\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n",
      "timestamp": 1664293282,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max_index`\n  --> /tmp/tmpnfmbev2i.rs:15:7\n   |\n11 |   let max_index = -1;\n   |       ---------\n   |       |\n   |       first assignment to `max_index`\n   |       help: consider making this binding mutable: `mut max_index`\n...\n15 |       max_index = i;\n   |       ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `max_value`\n  --> /tmp/tmpnfmbev2i.rs:16:7\n   |\n12 |   let max_value = -1;\n   |       ---------\n   |       |\n   |       first assignment to `max_value`\n   |       help: consider making this binding mutable: `mut max_value`\n...\n16 |       max_value = i;\n   |       ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Create a function which returns the largest index of an element which\n/// is not greater than or equal to the element immediately preceding it. If\n/// no such element exists then return -1. The given vector will not contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>) -> isize {\n  let max_index = -1;\n  let max_value = -1;\n  let max_value_index = -1;\n  for i in arr {\n    if max_value < i {\n      max_value = i;\n      max_value_index = i;\n    }\n    if max_index < i {\n      max_index = i;\n    }\n  }\n  if max_value == max_value_index {\n    return -1\n  }\n  return max_index\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n",
      "timestamp": 1664293282,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max_value`\n  --> /tmp/tmp2cslh38v.rs:16:7\n   |\n12 |   let max_value = -1;\n   |       ---------\n   |       |\n   |       first assignment to `max_value`\n   |       help: consider making this binding mutable: `mut max_value`\n...\n16 |       max_value = i;\n   |       ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `max_value_index`\n  --> /tmp/tmp2cslh38v.rs:17:7\n   |\n13 |   let max_value_index = -1;\n   |       ---------------\n   |       |\n   |       first assignment to `max_value_index`\n   |       help: consider making this binding mutable: `mut max_value_index`\n...\n17 |       max_value_index = i;\n   |       ^^^^^^^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `max_index`\n  --> /tmp/tmp2cslh38v.rs:20:7\n   |\n11 |   let max_index = -1;\n   |       ---------\n   |       |\n   |       first assignment to `max_index`\n   |       help: consider making this binding mutable: `mut max_index`\n...\n20 |       max_index = i;\n   |       ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 3 previous errors\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Create a function which returns the largest index of an element which\n/// is not greater than or equal to the element immediately preceding it. If\n/// no such element exists then return -1. The given vector will not contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>) -> isize {\n  let max_index = -1;\n  let max_value = -1;\n  for i in arr {\n    if i > max_value {\n      max_index = i;\n      max_value = i;\n    }\n  }\n  return max_index;\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n",
      "timestamp": 1664293282,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max_index`\n  --> /tmp/tmpnfmbev2i.rs:15:7\n   |\n11 |   let max_index = -1;\n   |       ---------\n   |       |\n   |       first assignment to `max_index`\n   |       help: consider making this binding mutable: `mut max_index`\n...\n15 |       max_index = i;\n   |       ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `max_value`\n  --> /tmp/tmpnfmbev2i.rs:16:7\n   |\n12 |   let max_value = -1;\n   |       ---------\n   |       |\n   |       first assignment to `max_value`\n   |       help: consider making this binding mutable: `mut max_value`\n...\n16 |       max_value = i;\n   |       ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Create a function which returns the largest index of an element which\n/// is not greater than or equal to the element immediately preceding it. If\n/// no such element exists then return -1. The given vector will not contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>) -> isize {\n  let max_index = -1;\n  let max_value = -1;\n  for i in arr {\n    if i > max_value {\n      max_value = i;\n      max_index = i - 1;\n    }\n  }\n  return max_index;\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n",
      "timestamp": 1664293282,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max_value`\n  --> /tmp/tmpk6s8eeav.rs:15:7\n   |\n12 |   let max_value = -1;\n   |       ---------\n   |       |\n   |       first assignment to `max_value`\n   |       help: consider making this binding mutable: `mut max_value`\n...\n15 |       max_value = i;\n   |       ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `max_index`\n  --> /tmp/tmpk6s8eeav.rs:16:7\n   |\n11 |   let max_index = -1;\n   |       ---------\n   |       |\n   |       first assignment to `max_index`\n   |       help: consider making this binding mutable: `mut max_index`\n...\n16 |       max_index = i - 1;\n   |       ^^^^^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Create a function which returns the largest index of an element which\n/// is not greater than or equal to the element immediately preceding it. If\n/// no such element exists then return -1. The given vector will not contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>) -> isize {\n  let max_index = -1;\n  for i in arr {\n    if i > max_index {\n      max_index = i;\n    }\n  }\n  return max_index;\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n",
      "timestamp": 1664293282,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max_index`\n  --> /tmp/tmpkwi327od.rs:14:7\n   |\n11 |   let max_index = -1;\n   |       ---------\n   |       |\n   |       first assignment to `max_index`\n   |       help: consider making this binding mutable: `mut max_index`\n...\n14 |       max_index = i;\n   |       ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Create a function which returns the largest index of an element which\n/// is not greater than or equal to the element immediately preceding it. If\n/// no such element exists then return -1. The given vector will not contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>) -> isize {\n  let max_index = -1;\n  for i in arr {\n    if i > max_index {\n      max_index = i;\n    }\n  }\n  return max_index;\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n",
      "timestamp": 1664293282,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max_index`\n  --> /tmp/tmpkwi327od.rs:14:7\n   |\n11 |   let max_index = -1;\n   |       ---------\n   |       |\n   |       first assignment to `max_index`\n   |       help: consider making this binding mutable: `mut max_index`\n...\n14 |       max_index = i;\n   |       ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Create a function which returns the largest index of an element which\n/// is not greater than or equal to the element immediately preceding it. If\n/// no such element exists then return -1. The given vector will not contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>) -> isize {\n  let last = -1\n  for i in arr {\n    if i > last {\n      last = i\n    }\n  }\n  if last == -1 {\n    return -1\n  }\n  return last\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n",
      "timestamp": 1664293282,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `for`\n  --> /tmp/tmpo9wps_dq.rs:11:16\n   |\n11 |   let last = -1\n   |                ^ help: add `;` here\n12 |   for i in arr {\n   |   --- unexpected token\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Create a function which returns the largest index of an element which\n/// is not greater than or equal to the element immediately preceding it. If\n/// no such element exists then return -1. The given vector will not contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>) -> isize {\n  let max_index = -1;\n  let max_value = -1;\n  for i in arr {\n    if i > max_value {\n      max_value = i;\n      max_index = i - 1;\n    }\n  }\n  return max_index;\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n",
      "timestamp": 1664293282,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max_value`\n  --> /tmp/tmpk6s8eeav.rs:15:7\n   |\n12 |   let max_value = -1;\n   |       ---------\n   |       |\n   |       first assignment to `max_value`\n   |       help: consider making this binding mutable: `mut max_value`\n...\n15 |       max_value = i;\n   |       ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `max_index`\n  --> /tmp/tmpk6s8eeav.rs:16:7\n   |\n11 |   let max_index = -1;\n   |       ---------\n   |       |\n   |       first assignment to `max_index`\n   |       help: consider making this binding mutable: `mut max_index`\n...\n16 |       max_index = i - 1;\n   |       ^^^^^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Create a function which returns the largest index of an element which\n/// is not greater than or equal to the element immediately preceding it. If\n/// no such element exists then return -1. The given vector will not contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>) -> isize {\n  let i = 0;\n  for i in arr.iter().next() {\n    if arr[i] > arr[i - 1] {\n      return i - 1;\n    }\n  }\n  return -1;\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n",
      "timestamp": 1664293282,
      "stdout": "",
      "stderr": "error[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmpknr__r3m.rs:13:8\n   |\n13 |     if arr[i] > arr[i - 1] {\n   |        ^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpknr__r3m.rs:13:17\n   |\n13 |     if arr[i] > arr[i - 1] {\n   |                 ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Create a function which returns the largest index of an element which\n/// is not greater than or equal to the element immediately preceding it. If\n/// no such element exists then return -1. The given vector will not contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>) -> isize {\n  let max_index = -1;\n  let max_value = -1;\n  let max_value_index = -1;\n  for i in arr {\n    if i > max_value {\n      max_value = i;\n      max_value_index = i;\n    }\n    if i >= max_value {\n      max_index = i;\n    }\n  }\n  if max_index == -1 {\n    return -1;\n  }\n  return max_index;\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n",
      "timestamp": 1664293282,
      "stdout": "",
      "stderr": "warning: variable `max_value_index` is assigned to, but never used\n  --> /tmp/tmpuqhhpi0x.rs:13:7\n   |\n13 |   let max_value_index = -1;\n   |       ^^^^^^^^^^^^^^^\n   |\n   = note: `#[warn(unused_variables)]` on by default\n   = note: consider using `_max_value_index` instead\n\nwarning: value assigned to `max_value_index` is never read\n  --> /tmp/tmpuqhhpi0x.rs:17:7\n   |\n17 |       max_value_index = i;\n   |       ^^^^^^^^^^^^^^^\n   |\n   = note: `#[warn(unused_assignments)]` on by default\n   = help: maybe it is overwritten before being read?\n\nerror[E0384]: cannot assign twice to immutable variable `max_value`\n  --> /tmp/tmpuqhhpi0x.rs:16:7\n   |\n12 |   let max_value = -1;\n   |       ---------\n   |       |\n   |       first assignment to `max_value`\n   |       help: consider making this binding mutable: `mut max_value`\n...\n16 |       max_value = i;\n   |       ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `max_value_index`\n  --> /tmp/tmpuqhhpi0x.rs:17:7\n   |\n13 |   let max_value_index = -1;\n   |       ---------------\n   |       |\n   |       first assignment to `max_value_index`\n   |       help: consider making this binding mutable: `mut max_value_index`\n...\n17 |       max_value_index = i;\n   |       ^^^^^^^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `max_index`\n  --> /tmp/tmpuqhhpi0x.rs:20:7\n   |\n11 |   let max_index = -1;\n   |       ---------\n   |       |\n   |       first assignment to `max_index`\n   |       help: consider making this binding mutable: `mut max_index`\n...\n20 |       max_index = i;\n   |       ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 3 previous errors; 2 warnings emitted\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Create a function which returns the largest index of an element which\n/// is not greater than or equal to the element immediately preceding it. If\n/// no such element exists then return -1. The given vector will not contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>) -> isize {\n    let max_index = 0;\n    let max_value = arr[0];\n    for i in arr {\n        if i > max_value {\n            max_value = i;\n            max_index = i;\n        }\n    }\n    return max_index;\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n",
      "timestamp": 1664293282,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max_value`\n  --> /tmp/tmpmz7zmy3g.rs:15:13\n   |\n12 |     let max_value = arr[0];\n   |         ---------\n   |         |\n   |         first assignment to `max_value`\n   |         help: consider making this binding mutable: `mut max_value`\n...\n15 |             max_value = i;\n   |             ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `max_index`\n  --> /tmp/tmpmz7zmy3g.rs:16:13\n   |\n11 |     let max_index = 0;\n   |         ---------\n   |         |\n   |         first assignment to `max_index`\n   |         help: consider making this binding mutable: `mut max_index`\n...\n16 |             max_index = i;\n   |             ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Create a function which returns the largest index of an element which\n/// is not greater than or equal to the element immediately preceding it. If\n/// no such element exists then return -1. The given vector will not contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>) -> isize {\n  let i = 0;\n  for i in arr.iter().next() {\n    if arr[i] > arr[i - 1] {\n      return i - 1;\n    }\n  }\n  return -1;\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n",
      "timestamp": 1664293282,
      "stdout": "",
      "stderr": "error[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmpknr__r3m.rs:13:8\n   |\n13 |     if arr[i] > arr[i - 1] {\n   |        ^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpknr__r3m.rs:13:17\n   |\n13 |     if arr[i] > arr[i - 1] {\n   |                 ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Create a function which returns the largest index of an element which\n/// is not greater than or equal to the element immediately preceding it. If\n/// no such element exists then return -1. The given vector will not contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>) -> isize {\n    let max_index = 0\n    for i in arr {\n        if i > max_index {\n            max_index = i\n        }\n    }\n    if max_index == 0 {\n        return -1\n    }\n    return max_index\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n",
      "timestamp": 1664293282,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `for`\n  --> /tmp/tmpfm2jog85.rs:11:22\n   |\n11 |     let max_index = 0\n   |                      ^ help: add `;` here\n12 |     for i in arr {\n   |     --- unexpected token\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Create a function which returns the largest index of an element which\n/// is not greater than or equal to the element immediately preceding it. If\n/// no such element exists then return -1. The given vector will not contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>) -> isize {\n  let max_index = -1;\n  for i in arr {\n    if i > max_index {\n      max_index = i;\n    }\n  }\n  return max_index;\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n",
      "timestamp": 1664293282,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max_index`\n  --> /tmp/tmpkwi327od.rs:14:7\n   |\n11 |   let max_index = -1;\n   |       ---------\n   |       |\n   |       first assignment to `max_index`\n   |       help: consider making this binding mutable: `mut max_index`\n...\n14 |       max_index = i;\n   |       ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Create a function which returns the largest index of an element which\n/// is not greater than or equal to the element immediately preceding it. If\n/// no such element exists then return -1. The given vector will not contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>) -> isize {\n  let max_index = -1;\n  for i in arr {\n    if i > max_index {\n      max_index = i;\n    }\n  }\n  return max_index;\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n",
      "timestamp": 1664293282,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max_index`\n  --> /tmp/tmpkwi327od.rs:14:7\n   |\n11 |   let max_index = -1;\n   |       ---------\n   |       |\n   |       first assignment to `max_index`\n   |       help: consider making this binding mutable: `mut max_index`\n...\n14 |       max_index = i;\n   |       ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Create a function which returns the largest index of an element which\n/// is not greater than or equal to the element immediately preceding it. If\n/// no such element exists then return -1. The given vector will not contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>) -> isize {\n  let max_index = -1;\n  for i in 0..arr.len() - 1 {\n    if arr[i] <= arr[i + 1] {\n      max_index = i;\n    }\n  }\n  return max_index;\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n",
      "timestamp": 1664293282,
      "stdout": "",
      "stderr": "error[E0277]: the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmpx7m93gwt.rs:11:19\n   |\n11 |   let max_index = -1;\n   |                   ^^ the trait `Neg` is not implemented for `usize`\n   |\n   = help: the following other types implement trait `Neg`:\n             &f32\n             &f64\n             &i128\n             &i16\n             &i32\n             &i64\n             &i8\n             &isize\n           and 8 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpx7m93gwt.rs:17:10\n   |\n10 | fn can_arrange(arr: Vec<isize>) -> isize {\n   |                                    ----- expected `isize` because of return type\n...\n17 |   return max_index;\n   |          ^^^^^^^^^ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the converted value doesn't fit\n   |\n17 |   return max_index.try_into().unwrap();\n   |                   ++++++++++++++++++++\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Create a function which returns the largest index of an element which\n/// is not greater than or equal to the element immediately preceding it. If\n/// no such element exists then return -1. The given vector will not contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>) -> isize {\n  let max_index = 0\n  let max_value = arr[0]\n  for i in arr {\n    if i > max_value {\n      max_value = i\n      max_index = i\n    }\n  }\n  return max_index\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n",
      "timestamp": 1664293282,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmphvlnfd_b.rs:11:20\n   |\n11 |   let max_index = 0\n   |                    ^ help: add `;` here\n12 |   let max_value = arr[0]\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmphvlnfd_b.rs:12:25\n   |\n12 |   let max_value = arr[0]\n   |                         ^ help: add `;` here\n13 |   for i in arr {\n   |   --- unexpected token\n\nerror: expected `;`, found `max_index`\n  --> /tmp/tmphvlnfd_b.rs:15:20\n   |\n15 |       max_value = i\n   |                    ^ help: add `;` here\n16 |       max_index = i\n   |       --------- unexpected token\n\nerror: aborting due to 3 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Create a function which returns the largest index of an element which\n/// is not greater than or equal to the element immediately preceding it. If\n/// no such element exists then return -1. The given vector will not contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>) -> isize {\n  let max_index = -1;\n  let max_value = -1;\n  let max_value_index = -1;\n  for i in arr {\n    if max_value < i {\n      max_value = i;\n      max_value_index = i;\n    }\n    if max_value >= i {\n      max_index = i;\n      break;\n    }\n  }\n  return max_index;\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n",
      "timestamp": 1664293282,
      "stdout": "",
      "stderr": "warning: variable `max_value_index` is assigned to, but never used\n  --> /tmp/tmpvuialp6o.rs:13:7\n   |\n13 |   let max_value_index = -1;\n   |       ^^^^^^^^^^^^^^^\n   |\n   = note: `#[warn(unused_variables)]` on by default\n   = note: consider using `_max_value_index` instead\n\nwarning: value assigned to `max_value_index` is never read\n  --> /tmp/tmpvuialp6o.rs:17:7\n   |\n17 |       max_value_index = i;\n   |       ^^^^^^^^^^^^^^^\n   |\n   = note: `#[warn(unused_assignments)]` on by default\n   = help: maybe it is overwritten before being read?\n\nerror[E0384]: cannot assign twice to immutable variable `max_value`\n  --> /tmp/tmpvuialp6o.rs:16:7\n   |\n12 |   let max_value = -1;\n   |       ---------\n   |       |\n   |       first assignment to `max_value`\n   |       help: consider making this binding mutable: `mut max_value`\n...\n16 |       max_value = i;\n   |       ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `max_value_index`\n  --> /tmp/tmpvuialp6o.rs:17:7\n   |\n13 |   let max_value_index = -1;\n   |       ---------------\n   |       |\n   |       first assignment to `max_value_index`\n   |       help: consider making this binding mutable: `mut max_value_index`\n...\n17 |       max_value_index = i;\n   |       ^^^^^^^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `max_index`\n  --> /tmp/tmpvuialp6o.rs:20:7\n   |\n11 |   let max_index = -1;\n   |       ---------\n   |       |\n   |       first assignment to `max_index`\n   |       help: consider making this binding mutable: `mut max_index`\n...\n20 |       max_index = i;\n   |       ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 3 previous errors; 2 warnings emitted\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Create a function which returns the largest index of an element which\n/// is not greater than or equal to the element immediately preceding it. If\n/// no such element exists then return -1. The given vector will not contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>) -> isize {\n  let max_index = -1;\n  for i in arr {\n    if i > max_index {\n      max_index = i;\n    }\n  }\n  return max_index;\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n",
      "timestamp": 1664293282,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max_index`\n  --> /tmp/tmpkwi327od.rs:14:7\n   |\n11 |   let max_index = -1;\n   |       ---------\n   |       |\n   |       first assignment to `max_index`\n   |       help: consider making this binding mutable: `mut max_index`\n...\n14 |       max_index = i;\n   |       ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Create a function which returns the largest index of an element which\n/// is not greater than or equal to the element immediately preceding it. If\n/// no such element exists then return -1. The given vector will not contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>) -> isize {\n  let max_index = -1;\n  let max_value = -1;\n  for i in arr {\n    if i > max_value {\n      max_index = i;\n      max_value = i;\n    }\n  }\n  return max_index;\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n",
      "timestamp": 1664293282,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max_index`\n  --> /tmp/tmpnfmbev2i.rs:15:7\n   |\n11 |   let max_index = -1;\n   |       ---------\n   |       |\n   |       first assignment to `max_index`\n   |       help: consider making this binding mutable: `mut max_index`\n...\n15 |       max_index = i;\n   |       ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `max_value`\n  --> /tmp/tmpnfmbev2i.rs:16:7\n   |\n12 |   let max_value = -1;\n   |       ---------\n   |       |\n   |       first assignment to `max_value`\n   |       help: consider making this binding mutable: `mut max_value`\n...\n16 |       max_value = i;\n   |       ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Create a function which returns the largest index of an element which\n/// is not greater than or equal to the element immediately preceding it. If\n/// no such element exists then return -1. The given vector will not contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>) -> isize {\n  let i = 0;\n  let j = arr.len - 1;\n  while (i < j) {\n    if (arr[i] < arr[j]) {\n      j -= 1;\n    } else {\n      i += 1;\n    }\n  }\n  if (i == j) {\n    return -1;\n  } else {\n    return i;\n  }\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n",
      "timestamp": 1664293282,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpkzzmcl12.rs:13:9\n   |\n13 |   while (i < j) {\n   |         ^     ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -   while (i < j) {\n13 +   while i < j {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpkzzmcl12.rs:14:8\n   |\n14 |     if (arr[i] < arr[j]) {\n   |        ^               ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (arr[i] < arr[j]) {\n14 +     if arr[i] < arr[j] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpkzzmcl12.rs:20:6\n   |\n20 |   if (i == j) {\n   |      ^      ^\n   |\nhelp: remove these parentheses\n   |\n20 -   if (i == j) {\n20 +   if i == j {\n   | \n\nerror[E0616]: field `len` of struct `Vec` is private\n  --> /tmp/tmpkzzmcl12.rs:12:15\n   |\n12 |   let j = arr.len - 1;\n   |               ^^^ private field\n   |\nhelp: a method `len` also exists, call it with parentheses\n   |\n12 |   let j = arr.len() - 1;\n   |                  ++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpkzzmcl12.rs:23:12\n   |\n10 | fn can_arrange(arr: Vec<isize>) -> isize {\n   |                                    ----- expected `isize` because of return type\n...\n23 |     return i;\n   |            ^ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the converted value doesn't fit\n   |\n23 |     return i.try_into().unwrap();\n   |             ++++++++++++++++++++\n\nerror: aborting due to 2 previous errors; 3 warnings emitted\n\nSome errors have detailed explanations: E0308, E0616.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Create a function which returns the largest index of an element which\n/// is not greater than or equal to the element immediately preceding it. If\n/// no such element exists then return -1. The given vector will not contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>) -> isize {\n  let max_index = -1;\n  let max_value = -1;\n  for i in arr {\n    if i > max_value {\n      max_value = i;\n      max_index = i - 1;\n    }\n  }\n  return max_index;\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n",
      "timestamp": 1664293282,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max_value`\n  --> /tmp/tmpk6s8eeav.rs:15:7\n   |\n12 |   let max_value = -1;\n   |       ---------\n   |       |\n   |       first assignment to `max_value`\n   |       help: consider making this binding mutable: `mut max_value`\n...\n15 |       max_value = i;\n   |       ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `max_index`\n  --> /tmp/tmpk6s8eeav.rs:16:7\n   |\n11 |   let max_index = -1;\n   |       ---------\n   |       |\n   |       first assignment to `max_index`\n   |       help: consider making this binding mutable: `mut max_index`\n...\n16 |       max_index = i - 1;\n   |       ^^^^^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Create a function which returns the largest index of an element which\n/// is not greater than or equal to the element immediately preceding it. If\n/// no such element exists then return -1. The given vector will not contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>) -> isize {\n  let i = 0;\n  for i in arr.iter() {\n    if arr[i] > arr[i - 1] {\n      return i - 1;\n    }\n  }\n  return -1;\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n",
      "timestamp": 1664293282,
      "stdout": "",
      "stderr": "error[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmp3eikhltl.rs:13:8\n   |\n13 |     if arr[i] > arr[i - 1] {\n   |        ^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmp3eikhltl.rs:13:17\n   |\n13 |     if arr[i] > arr[i - 1] {\n   |                 ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Create a function which returns the largest index of an element which\n/// is not greater than or equal to the element immediately preceding it. If\n/// no such element exists then return -1. The given vector will not contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>) -> isize {\n  let max_index = -1;\n  let max_value = -1;\n  let max_value_index = -1;\n  for i in arr {\n    if max_value < i {\n      max_value = i;\n      max_value_index = i;\n    }\n    if max_index < i {\n      max_index = i;\n    }\n  }\n  if max_value == max_value_index {\n    return -1\n  }\n  return max_index\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n",
      "timestamp": 1664293282,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max_value`\n  --> /tmp/tmp2cslh38v.rs:16:7\n   |\n12 |   let max_value = -1;\n   |       ---------\n   |       |\n   |       first assignment to `max_value`\n   |       help: consider making this binding mutable: `mut max_value`\n...\n16 |       max_value = i;\n   |       ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `max_value_index`\n  --> /tmp/tmp2cslh38v.rs:17:7\n   |\n13 |   let max_value_index = -1;\n   |       ---------------\n   |       |\n   |       first assignment to `max_value_index`\n   |       help: consider making this binding mutable: `mut max_value_index`\n...\n17 |       max_value_index = i;\n   |       ^^^^^^^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `max_index`\n  --> /tmp/tmp2cslh38v.rs:20:7\n   |\n11 |   let max_index = -1;\n   |       ---------\n   |       |\n   |       first assignment to `max_index`\n   |       help: consider making this binding mutable: `mut max_index`\n...\n20 |       max_index = i;\n   |       ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 3 previous errors\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Create a function which returns the largest index of an element which\n/// is not greater than or equal to the element immediately preceding it. If\n/// no such element exists then return -1. The given vector will not contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>) -> isize {\n  let max_index = -1;\n  let max_value = -1;\n  for i in arr {\n    if i > max_value {\n      max_value = i;\n      max_index = i - 1;\n    }\n  }\n  return max_index;\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n",
      "timestamp": 1664293282,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max_value`\n  --> /tmp/tmpk6s8eeav.rs:15:7\n   |\n12 |   let max_value = -1;\n   |       ---------\n   |       |\n   |       first assignment to `max_value`\n   |       help: consider making this binding mutable: `mut max_value`\n...\n15 |       max_value = i;\n   |       ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `max_index`\n  --> /tmp/tmpk6s8eeav.rs:16:7\n   |\n11 |   let max_index = -1;\n   |       ---------\n   |       |\n   |       first assignment to `max_index`\n   |       help: consider making this binding mutable: `mut max_index`\n...\n16 |       max_index = i - 1;\n   |       ^^^^^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Create a function which returns the largest index of an element which\n/// is not greater than or equal to the element immediately preceding it. If\n/// no such element exists then return -1. The given vector will not contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>) -> isize {\n  let i = 0;\n  for i in arr.iter() {\n    if i < arr.len() - 1 && arr[i] >= arr[i + 1] {\n      return -1;\n    }\n  }\n  return i;\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n",
      "timestamp": 1664293282,
      "stdout": "",
      "stderr": "error[E0308]: mismatched types\n  --> /tmp/tmp3rpoprwa.rs:13:12\n   |\n13 |     if i < arr.len() - 1 && arr[i] >= arr[i + 1] {\n   |            ^^^^^^^^^^^^^ expected `&isize`, found `usize`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmp3rpoprwa.rs:13:29\n   |\n13 |     if i < arr.len() - 1 && arr[i] >= arr[i + 1] {\n   |                             ^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmp3rpoprwa.rs:13:39\n   |\n13 |     if i < arr.len() - 1 && arr[i] >= arr[i + 1] {\n   |                                       ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Create a function which returns the largest index of an element which\n/// is not greater than or equal to the element immediately preceding it. If\n/// no such element exists then return -1. The given vector will not contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>) -> isize {\n  let max_index = -1;\n  let max_value = -1;\n  for i in arr {\n    if i > max_value {\n      max_value = i;\n      max_index = i - 1;\n    }\n  }\n  return max_index;\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n",
      "timestamp": 1664293282,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max_value`\n  --> /tmp/tmpk6s8eeav.rs:15:7\n   |\n12 |   let max_value = -1;\n   |       ---------\n   |       |\n   |       first assignment to `max_value`\n   |       help: consider making this binding mutable: `mut max_value`\n...\n15 |       max_value = i;\n   |       ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `max_index`\n  --> /tmp/tmpk6s8eeav.rs:16:7\n   |\n11 |   let max_index = -1;\n   |       ---------\n   |       |\n   |       first assignment to `max_index`\n   |       help: consider making this binding mutable: `mut max_index`\n...\n16 |       max_index = i - 1;\n   |       ^^^^^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Create a function which returns the largest index of an element which\n/// is not greater than or equal to the element immediately preceding it. If\n/// no such element exists then return -1. The given vector will not contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>) -> isize {\n  let i = 0;\n  for i in arr.iter() {\n    if arr[i] > arr[i - 1] {\n      return i - 1;\n    }\n  }\n  return -1;\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n",
      "timestamp": 1664293282,
      "stdout": "",
      "stderr": "error[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmp3eikhltl.rs:13:8\n   |\n13 |     if arr[i] > arr[i - 1] {\n   |        ^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmp3eikhltl.rs:13:17\n   |\n13 |     if arr[i] > arr[i - 1] {\n   |                 ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Create a function which returns the largest index of an element which\n/// is not greater than or equal to the element immediately preceding it. If\n/// no such element exists then return -1. The given vector will not contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>) -> isize {\n  let i = 0;\n  let max = 0;\n  for i in arr {\n    if i > max {\n      max = i;\n    }\n  }\n  if max == 0 {\n    return -1;\n  }\n  return max;\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n",
      "timestamp": 1664293282,
      "stdout": "",
      "stderr": "warning: unused variable: `i`\n  --> /tmp/tmpknwwg41k.rs:11:7\n   |\n11 |   let i = 0;\n   |       ^ help: if this is intentional, prefix it with an underscore: `_i`\n   |\n   = note: `#[warn(unused_variables)]` on by default\n\nerror[E0384]: cannot assign twice to immutable variable `max`\n  --> /tmp/tmpknwwg41k.rs:15:7\n   |\n12 |   let max = 0;\n   |       ---\n   |       |\n   |       first assignment to `max`\n   |       help: consider making this binding mutable: `mut max`\n...\n15 |       max = i;\n   |       ^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error; 1 warning emitted\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Create a function which returns the largest index of an element which\n/// is not greater than or equal to the element immediately preceding it. If\n/// no such element exists then return -1. The given vector will not contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>) -> isize {\n  let max_index = -1;\n  let max_value = -1;\n  for i in arr {\n    if i > max_value {\n      max_value = i;\n      max_index = i - 1;\n    }\n  }\n  return max_index;\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n",
      "timestamp": 1664293282,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max_value`\n  --> /tmp/tmpk6s8eeav.rs:15:7\n   |\n12 |   let max_value = -1;\n   |       ---------\n   |       |\n   |       first assignment to `max_value`\n   |       help: consider making this binding mutable: `mut max_value`\n...\n15 |       max_value = i;\n   |       ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `max_index`\n  --> /tmp/tmpk6s8eeav.rs:16:7\n   |\n11 |   let max_index = -1;\n   |       ---------\n   |       |\n   |       first assignment to `max_index`\n   |       help: consider making this binding mutable: `mut max_index`\n...\n16 |       max_index = i - 1;\n   |       ^^^^^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Create a function which returns the largest index of an element which\n/// is not greater than or equal to the element immediately preceding it. If\n/// no such element exists then return -1. The given vector will not contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>) -> isize {\n  let max_index = -1;\n  let max_value = -1;\n  for i in arr {\n    if i > max_value {\n      max_value = i;\n      max_index = i - 1;\n    }\n  }\n  return max_index;\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n",
      "timestamp": 1664293282,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max_value`\n  --> /tmp/tmpk6s8eeav.rs:15:7\n   |\n12 |   let max_value = -1;\n   |       ---------\n   |       |\n   |       first assignment to `max_value`\n   |       help: consider making this binding mutable: `mut max_value`\n...\n15 |       max_value = i;\n   |       ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `max_index`\n  --> /tmp/tmpk6s8eeav.rs:16:7\n   |\n11 |   let max_index = -1;\n   |       ---------\n   |       |\n   |       first assignment to `max_index`\n   |       help: consider making this binding mutable: `mut max_index`\n...\n16 |       max_index = i - 1;\n   |       ^^^^^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Create a function which returns the largest index of an element which\n/// is not greater than or equal to the element immediately preceding it. If\n/// no such element exists then return -1. The given vector will not contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>) -> isize {\n  let max_index = -1;\n  for i in arr {\n    if i > max_index {\n      max_index = i;\n    }\n  }\n  return max_index;\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n",
      "timestamp": 1664293282,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max_index`\n  --> /tmp/tmpkwi327od.rs:14:7\n   |\n11 |   let max_index = -1;\n   |       ---------\n   |       |\n   |       first assignment to `max_index`\n   |       help: consider making this binding mutable: `mut max_index`\n...\n14 |       max_index = i;\n   |       ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Create a function which returns the largest index of an element which\n/// is not greater than or equal to the element immediately preceding it. If\n/// no such element exists then return -1. The given vector will not contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>) -> isize {\n  let max_index = -1;\n  let max_value = -1;\n  for i in arr {\n    if i > max_value {\n      max_index = i;\n      max_value = i;\n    }\n  }\n  return max_index;\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n",
      "timestamp": 1664293282,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max_index`\n  --> /tmp/tmpnfmbev2i.rs:15:7\n   |\n11 |   let max_index = -1;\n   |       ---------\n   |       |\n   |       first assignment to `max_index`\n   |       help: consider making this binding mutable: `mut max_index`\n...\n15 |       max_index = i;\n   |       ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `max_value`\n  --> /tmp/tmpnfmbev2i.rs:16:7\n   |\n12 |   let max_value = -1;\n   |       ---------\n   |       |\n   |       first assignment to `max_value`\n   |       help: consider making this binding mutable: `mut max_value`\n...\n16 |       max_value = i;\n   |       ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Create a function which returns the largest index of an element which\n/// is not greater than or equal to the element immediately preceding it. If\n/// no such element exists then return -1. The given vector will not contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>) -> isize {\n  let max_index = 0\n  let max_value = arr[0]\n  for i in arr {\n    if i > max_value {\n      max_value = i\n      max_index = i\n    }\n  }\n  return max_index\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n",
      "timestamp": 1664293282,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmphvlnfd_b.rs:11:20\n   |\n11 |   let max_index = 0\n   |                    ^ help: add `;` here\n12 |   let max_value = arr[0]\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmphvlnfd_b.rs:12:25\n   |\n12 |   let max_value = arr[0]\n   |                         ^ help: add `;` here\n13 |   for i in arr {\n   |   --- unexpected token\n\nerror: expected `;`, found `max_index`\n  --> /tmp/tmphvlnfd_b.rs:15:20\n   |\n15 |       max_value = i\n   |                    ^ help: add `;` here\n16 |       max_index = i\n   |       --------- unexpected token\n\nerror: aborting due to 3 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Create a function which returns the largest index of an element which\n/// is not greater than or equal to the element immediately preceding it. If\n/// no such element exists then return -1. The given vector will not contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>) -> isize {\n  let max_index = -1;\n  let max_value = -1;\n  let i = 0;\n  for v in arr {\n    if v > max_value {\n      max_index = i;\n      max_value = v;\n    }\n    i += 1;\n  }\n  return max_index;\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n",
      "timestamp": 1664293282,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max_index`\n  --> /tmp/tmpssbqtiex.rs:16:7\n   |\n11 |   let max_index = -1;\n   |       ---------\n   |       |\n   |       first assignment to `max_index`\n   |       help: consider making this binding mutable: `mut max_index`\n...\n16 |       max_index = i;\n   |       ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `max_value`\n  --> /tmp/tmpssbqtiex.rs:17:7\n   |\n12 |   let max_value = -1;\n   |       ---------\n   |       |\n   |       first assignment to `max_value`\n   |       help: consider making this binding mutable: `mut max_value`\n...\n17 |       max_value = v;\n   |       ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `i`\n  --> /tmp/tmpssbqtiex.rs:19:5\n   |\n13 |   let i = 0;\n   |       -\n   |       |\n   |       first assignment to `i`\n   |       help: consider making this binding mutable: `mut i`\n...\n19 |     i += 1;\n   |     ^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 3 previous errors\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Create a function which returns the largest index of an element which\n/// is not greater than or equal to the element immediately preceding it. If\n/// no such element exists then return -1. The given vector will not contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>) -> isize {\n    let max_index = 0\n    let max_value = arr[0]\n    for i in arr {\n        if i > max_value {\n            max_value = i\n            max_index = i\n        }\n    }\n    return max_index\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n",
      "timestamp": 1664293282,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmplwp3ppm9.rs:11:22\n   |\n11 |     let max_index = 0\n   |                      ^ help: add `;` here\n12 |     let max_value = arr[0]\n   |     --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmplwp3ppm9.rs:12:27\n   |\n12 |     let max_value = arr[0]\n   |                           ^ help: add `;` here\n13 |     for i in arr {\n   |     --- unexpected token\n\nerror: expected `;`, found `max_index`\n  --> /tmp/tmplwp3ppm9.rs:15:26\n   |\n15 |             max_value = i\n   |                          ^ help: add `;` here\n16 |             max_index = i\n   |             --------- unexpected token\n\nerror: aborting due to 3 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Create a function which returns the largest index of an element which\n/// is not greater than or equal to the element immediately preceding it. If\n/// no such element exists then return -1. The given vector will not contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>) -> isize {\n  let max_index = -1;\n  let max_value = -1;\n  for i in arr {\n    if max_value < i {\n      max_value = i;\n      max_index = i - 1;\n    }\n  }\n  return max_index;\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n",
      "timestamp": 1664293282,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max_value`\n  --> /tmp/tmp79cu3cor.rs:15:7\n   |\n12 |   let max_value = -1;\n   |       ---------\n   |       |\n   |       first assignment to `max_value`\n   |       help: consider making this binding mutable: `mut max_value`\n...\n15 |       max_value = i;\n   |       ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `max_index`\n  --> /tmp/tmp79cu3cor.rs:16:7\n   |\n11 |   let max_index = -1;\n   |       ---------\n   |       |\n   |       first assignment to `max_index`\n   |       help: consider making this binding mutable: `mut max_index`\n...\n16 |       max_index = i - 1;\n   |       ^^^^^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Create a function which returns the largest index of an element which\n/// is not greater than or equal to the element immediately preceding it. If\n/// no such element exists then return -1. The given vector will not contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>) -> isize {\n  let max_index = -1;\n  let max_value = -1;\n  for i in arr {\n    if i > max_value {\n      max_index = i;\n      max_value = i;\n    }\n  }\n  return max_index;\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n",
      "timestamp": 1664293282,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max_index`\n  --> /tmp/tmpnfmbev2i.rs:15:7\n   |\n11 |   let max_index = -1;\n   |       ---------\n   |       |\n   |       first assignment to `max_index`\n   |       help: consider making this binding mutable: `mut max_index`\n...\n15 |       max_index = i;\n   |       ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `max_value`\n  --> /tmp/tmpnfmbev2i.rs:16:7\n   |\n12 |   let max_value = -1;\n   |       ---------\n   |       |\n   |       first assignment to `max_value`\n   |       help: consider making this binding mutable: `mut max_value`\n...\n16 |       max_value = i;\n   |       ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Create a function which returns the largest index of an element which\n/// is not greater than or equal to the element immediately preceding it. If\n/// no such element exists then return -1. The given vector will not contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>) -> isize {\n  let max_index = -1;\n  let max_value = -1;\n  for i in arr {\n    if i > max_value {\n      max_value = i;\n      max_index = i - 1;\n    }\n  }\n  return max_index;\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n",
      "timestamp": 1664293282,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max_value`\n  --> /tmp/tmpk6s8eeav.rs:15:7\n   |\n12 |   let max_value = -1;\n   |       ---------\n   |       |\n   |       first assignment to `max_value`\n   |       help: consider making this binding mutable: `mut max_value`\n...\n15 |       max_value = i;\n   |       ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `max_index`\n  --> /tmp/tmpk6s8eeav.rs:16:7\n   |\n11 |   let max_index = -1;\n   |       ---------\n   |       |\n   |       first assignment to `max_index`\n   |       help: consider making this binding mutable: `mut max_index`\n...\n16 |       max_index = i - 1;\n   |       ^^^^^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Create a function which returns the largest index of an element which\n/// is not greater than or equal to the element immediately preceding it. If\n/// no such element exists then return -1. The given vector will not contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>) -> isize {\n  let max_index = -1;\n  for i in arr {\n    if i > max_index {\n      max_index = i;\n    }\n  }\n  return max_index;\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n",
      "timestamp": 1664293282,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max_index`\n  --> /tmp/tmpkwi327od.rs:14:7\n   |\n11 |   let max_index = -1;\n   |       ---------\n   |       |\n   |       first assignment to `max_index`\n   |       help: consider making this binding mutable: `mut max_index`\n...\n14 |       max_index = i;\n   |       ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Create a function which returns the largest index of an element which\n/// is not greater than or equal to the element immediately preceding it. If\n/// no such element exists then return -1. The given vector will not contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>) -> isize {\n  let i = 0;\n  for i in arr.iter() {\n    if arr[i] > arr[i - 1] {\n      return i - 1;\n    }\n  }\n  return -1;\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n",
      "timestamp": 1664293282,
      "stdout": "",
      "stderr": "error[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmp3eikhltl.rs:13:8\n   |\n13 |     if arr[i] > arr[i - 1] {\n   |        ^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmp3eikhltl.rs:13:17\n   |\n13 |     if arr[i] > arr[i - 1] {\n   |                 ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Create a function which returns the largest index of an element which\n/// is not greater than or equal to the element immediately preceding it. If\n/// no such element exists then return -1. The given vector will not contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>) -> isize {\n  let max_index = -1;\n  for i in 0..arr.len() {\n    if arr[i] > arr[i - 1] {\n      max_index = i;\n    }\n  }\n  return max_index;\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n",
      "timestamp": 1664293282,
      "stdout": "",
      "stderr": "error[E0277]: the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmp52a60guj.rs:11:19\n   |\n11 |   let max_index = -1;\n   |                   ^^ the trait `Neg` is not implemented for `usize`\n   |\n   = help: the following other types implement trait `Neg`:\n             &f32\n             &f64\n             &i128\n             &i16\n             &i32\n             &i64\n             &i8\n             &isize\n           and 8 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp52a60guj.rs:17:10\n   |\n10 | fn can_arrange(arr: Vec<isize>) -> isize {\n   |                                    ----- expected `isize` because of return type\n...\n17 |   return max_index;\n   |          ^^^^^^^^^ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the converted value doesn't fit\n   |\n17 |   return max_index.try_into().unwrap();\n   |                   ++++++++++++++++++++\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Create a function which returns the largest index of an element which\n/// is not greater than or equal to the element immediately preceding it. If\n/// no such element exists then return -1. The given vector will not contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>) -> isize {\n  let i = 0;\n  let j = arr.len - 1;\n  while (i < j) {\n    if (arr[i] < arr[j]) {\n      j -= 1;\n    } else {\n      i += 1;\n    }\n  }\n  if (i == j) {\n    return -1;\n  } else {\n    return i;\n  }\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n",
      "timestamp": 1664293282,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpkzzmcl12.rs:13:9\n   |\n13 |   while (i < j) {\n   |         ^     ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -   while (i < j) {\n13 +   while i < j {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpkzzmcl12.rs:14:8\n   |\n14 |     if (arr[i] < arr[j]) {\n   |        ^               ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (arr[i] < arr[j]) {\n14 +     if arr[i] < arr[j] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpkzzmcl12.rs:20:6\n   |\n20 |   if (i == j) {\n   |      ^      ^\n   |\nhelp: remove these parentheses\n   |\n20 -   if (i == j) {\n20 +   if i == j {\n   | \n\nerror[E0616]: field `len` of struct `Vec` is private\n  --> /tmp/tmpkzzmcl12.rs:12:15\n   |\n12 |   let j = arr.len - 1;\n   |               ^^^ private field\n   |\nhelp: a method `len` also exists, call it with parentheses\n   |\n12 |   let j = arr.len() - 1;\n   |                  ++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpkzzmcl12.rs:23:12\n   |\n10 | fn can_arrange(arr: Vec<isize>) -> isize {\n   |                                    ----- expected `isize` because of return type\n...\n23 |     return i;\n   |            ^ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the converted value doesn't fit\n   |\n23 |     return i.try_into().unwrap();\n   |             ++++++++++++++++++++\n\nerror: aborting due to 2 previous errors; 3 warnings emitted\n\nSome errors have detailed explanations: E0308, E0616.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Create a function which returns the largest index of an element which\n/// is not greater than or equal to the element immediately preceding it. If\n/// no such element exists then return -1. The given vector will not contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>) -> isize {\n  let i = 0;\n  let j = arr.len - 1;\n  while (i < j) {\n    if (arr[i] < arr[j]) {\n      j -= 1;\n    } else {\n      i += 1;\n    }\n  }\n  if (i == j) {\n    return -1;\n  } else {\n    return i;\n  }\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n",
      "timestamp": 1664293282,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpkzzmcl12.rs:13:9\n   |\n13 |   while (i < j) {\n   |         ^     ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -   while (i < j) {\n13 +   while i < j {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpkzzmcl12.rs:14:8\n   |\n14 |     if (arr[i] < arr[j]) {\n   |        ^               ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (arr[i] < arr[j]) {\n14 +     if arr[i] < arr[j] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpkzzmcl12.rs:20:6\n   |\n20 |   if (i == j) {\n   |      ^      ^\n   |\nhelp: remove these parentheses\n   |\n20 -   if (i == j) {\n20 +   if i == j {\n   | \n\nerror[E0616]: field `len` of struct `Vec` is private\n  --> /tmp/tmpkzzmcl12.rs:12:15\n   |\n12 |   let j = arr.len - 1;\n   |               ^^^ private field\n   |\nhelp: a method `len` also exists, call it with parentheses\n   |\n12 |   let j = arr.len() - 1;\n   |                  ++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpkzzmcl12.rs:23:12\n   |\n10 | fn can_arrange(arr: Vec<isize>) -> isize {\n   |                                    ----- expected `isize` because of return type\n...\n23 |     return i;\n   |            ^ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the converted value doesn't fit\n   |\n23 |     return i.try_into().unwrap();\n   |             ++++++++++++++++++++\n\nerror: aborting due to 2 previous errors; 3 warnings emitted\n\nSome errors have detailed explanations: E0308, E0616.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Create a function which returns the largest index of an element which\n/// is not greater than or equal to the element immediately preceding it. If\n/// no such element exists then return -1. The given vector will not contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>) -> isize {\n  let max_index = -1;\n  let max_value = -1;\n  let max_index_value = -1;\n  let max_value_index = -1;\n  for i in arr {\n    if max_value < i {\n      max_value = i;\n      max_value_index = i;\n      max_index = i;\n    } else if max_value == i {\n      max_index = i;\n    }\n  }\n  return max_index;\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n",
      "timestamp": 1664293282,
      "stdout": "",
      "stderr": "warning: unused variable: `max_index_value`\n  --> /tmp/tmp0eu9myls.rs:13:7\n   |\n13 |   let max_index_value = -1;\n   |       ^^^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_max_index_value`\n   |\n   = note: `#[warn(unused_variables)]` on by default\n\nwarning: variable `max_value_index` is assigned to, but never used\n  --> /tmp/tmp0eu9myls.rs:14:7\n   |\n14 |   let max_value_index = -1;\n   |       ^^^^^^^^^^^^^^^\n   |\n   = note: consider using `_max_value_index` instead\n\nwarning: value assigned to `max_value_index` is never read\n  --> /tmp/tmp0eu9myls.rs:18:7\n   |\n18 |       max_value_index = i;\n   |       ^^^^^^^^^^^^^^^\n   |\n   = note: `#[warn(unused_assignments)]` on by default\n   = help: maybe it is overwritten before being read?\n\nerror[E0384]: cannot assign twice to immutable variable `max_value`\n  --> /tmp/tmp0eu9myls.rs:17:7\n   |\n12 |   let max_value = -1;\n   |       ---------\n   |       |\n   |       first assignment to `max_value`\n   |       help: consider making this binding mutable: `mut max_value`\n...\n17 |       max_value = i;\n   |       ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `max_value_index`\n  --> /tmp/tmp0eu9myls.rs:18:7\n   |\n14 |   let max_value_index = -1;\n   |       ---------------\n   |       |\n   |       first assignment to `max_value_index`\n   |       help: consider making this binding mutable: `mut max_value_index`\n...\n18 |       max_value_index = i;\n   |       ^^^^^^^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `max_index`\n  --> /tmp/tmp0eu9myls.rs:19:7\n   |\n11 |   let max_index = -1;\n   |       ---------\n   |       |\n   |       first assignment to `max_index`\n   |       help: consider making this binding mutable: `mut max_index`\n...\n19 |       max_index = i;\n   |       ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `max_index`\n  --> /tmp/tmp0eu9myls.rs:21:7\n   |\n11",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Create a function which returns the largest index of an element which\n/// is not greater than or equal to the element immediately preceding it. If\n/// no such element exists then return -1. The given vector will not contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>) -> isize {\n  let i = 0;\n  let j = arr.len - 1;\n  while (i < j) {\n    if (arr[i] <= arr[j]) {\n      i += 1;\n    } else {\n      j -= 1;\n    }\n  }\n  if (i == j) {\n    return -1;\n  } else {\n    return i;\n  }\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n",
      "timestamp": 1664293282,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpbuc7w09x.rs:13:9\n   |\n13 |   while (i < j) {\n   |         ^     ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -   while (i < j) {\n13 +   while i < j {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpbuc7w09x.rs:14:8\n   |\n14 |     if (arr[i] <= arr[j]) {\n   |        ^                ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (arr[i] <= arr[j]) {\n14 +     if arr[i] <= arr[j] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpbuc7w09x.rs:20:6\n   |\n20 |   if (i == j) {\n   |      ^      ^\n   |\nhelp: remove these parentheses\n   |\n20 -   if (i == j) {\n20 +   if i == j {\n   | \n\nerror[E0616]: field `len` of struct `Vec` is private\n  --> /tmp/tmpbuc7w09x.rs:12:15\n   |\n12 |   let j = arr.len - 1;\n   |               ^^^ private field\n   |\nhelp: a method `len` also exists, call it with parentheses\n   |\n12 |   let j = arr.len() - 1;\n   |                  ++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpbuc7w09x.rs:23:12\n   |\n10 | fn can_arrange(arr: Vec<isize>) -> isize {\n   |                                    ----- expected `isize` because of return type\n...\n23 |     return i;\n   |            ^ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the converted value doesn't fit\n   |\n23 |     return i.try_into().unwrap();\n   |             ++++++++++++++++++++\n\nerror: aborting due to 2 previous errors; 3 warnings emitted\n\nSome errors have detailed explanations: E0308, E0616.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Create a function which returns the largest index of an element which\n/// is not greater than or equal to the element immediately preceding it. If\n/// no such element exists then return -1. The given vector will not contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>) -> isize {\n  let max_index = 0\n  let max_value = arr[0]\n  for i in arr {\n    if i > max_value {\n      max_value = i\n      max_index = i\n    }\n  }\n  if max_value == arr[0] {\n    return -1\n  }\n  return max_index\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n",
      "timestamp": 1664293282,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmpm4vx2tfa.rs:11:20\n   |\n11 |   let max_index = 0\n   |                    ^ help: add `;` here\n12 |   let max_value = arr[0]\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpm4vx2tfa.rs:12:25\n   |\n12 |   let max_value = arr[0]\n   |                         ^ help: add `;` here\n13 |   for i in arr {\n   |   --- unexpected token\n\nerror: expected `;`, found `max_index`\n  --> /tmp/tmpm4vx2tfa.rs:15:20\n   |\n15 |       max_value = i\n   |                    ^ help: add `;` here\n16 |       max_index = i\n   |       --------- unexpected token\n\nerror: aborting due to 3 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Create a function which returns the largest index of an element which\n/// is not greater than or equal to the element immediately preceding it. If\n/// no such element exists then return -1. The given vector will not contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>) -> isize {\n  let i = 0;\n  for i in arr.iter() {\n    if arr[i] > arr[i - 1] {\n      break;\n    }\n  }\n  if i == 0 {\n    return -1;\n  }\n  return i - 1;\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n",
      "timestamp": 1664293282,
      "stdout": "",
      "stderr": "error[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmpqsofw94g.rs:13:8\n   |\n13 |     if arr[i] > arr[i - 1] {\n   |        ^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpqsofw94g.rs:13:17\n   |\n13 |     if arr[i] > arr[i - 1] {\n   |                 ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Create a function which returns the largest index of an element which\n/// is not greater than or equal to the element immediately preceding it. If\n/// no such element exists then return -1. The given vector will not contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>) -> isize {\n  let max_index = -1;\n  for i in arr {\n    if i > max_index {\n      max_index = i;\n    }\n  }\n  return max_index;\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n",
      "timestamp": 1664293282,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max_index`\n  --> /tmp/tmpkwi327od.rs:14:7\n   |\n11 |   let max_index = -1;\n   |       ---------\n   |       |\n   |       first assignment to `max_index`\n   |       help: consider making this binding mutable: `mut max_index`\n...\n14 |       max_index = i;\n   |       ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Create a function which returns the largest index of an element which\n/// is not greater than or equal to the element immediately preceding it. If\n/// no such element exists then return -1. The given vector will not contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>) -> isize {\n  let max_index = -1;\n  let max_value = -1;\n  for i in arr {\n    if i > max_value {\n      max_value = i;\n      max_index = i - 1;\n    }\n  }\n  return max_index;\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n",
      "timestamp": 1664293282,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max_value`\n  --> /tmp/tmpk6s8eeav.rs:15:7\n   |\n12 |   let max_value = -1;\n   |       ---------\n   |       |\n   |       first assignment to `max_value`\n   |       help: consider making this binding mutable: `mut max_value`\n...\n15 |       max_value = i;\n   |       ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `max_index`\n  --> /tmp/tmpk6s8eeav.rs:16:7\n   |\n11 |   let max_index = -1;\n   |       ---------\n   |       |\n   |       first assignment to `max_index`\n   |       help: consider making this binding mutable: `mut max_index`\n...\n16 |       max_index = i - 1;\n   |       ^^^^^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Create a function which returns the largest index of an element which\n/// is not greater than or equal to the element immediately preceding it. If\n/// no such element exists then return -1. The given vector will not contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>) -> isize {\n  let max_index = 0\n  for i in arr {\n    if i > max_index {\n      max_index = i\n    }\n  }\n  if max_index == 0 {\n    return -1\n  }\n  return max_index\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n",
      "timestamp": 1664293282,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `for`\n  --> /tmp/tmpudycxnrf.rs:11:20\n   |\n11 |   let max_index = 0\n   |                    ^ help: add `;` here\n12 |   for i in arr {\n   |   --- unexpected token\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Create a function which returns the largest index of an element which\n/// is not greater than or equal to the element immediately preceding it. If\n/// no such element exists then return -1. The given vector will not contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>) -> isize {\n  let max_index = -1;\n  for i in arr {\n    if i > max_index {\n      max_index = i;\n    }\n  }\n  return max_index;\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n",
      "timestamp": 1664293282,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max_index`\n  --> /tmp/tmpkwi327od.rs:14:7\n   |\n11 |   let max_index = -1;\n   |       ---------\n   |       |\n   |       first assignment to `max_index`\n   |       help: consider making this binding mutable: `mut max_index`\n...\n14 |       max_index = i;\n   |       ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Create a function which returns the largest index of an element which\n/// is not greater than or equal to the element immediately preceding it. If\n/// no such element exists then return -1. The given vector will not contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>) -> isize {\n  let max_index = -1;\n  for i in arr {\n    if i > max_index {\n      max_index = i;\n    }\n  }\n  return max_index;\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n",
      "timestamp": 1664293282,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max_index`\n  --> /tmp/tmpkwi327od.rs:14:7\n   |\n11 |   let max_index = -1;\n   |       ---------\n   |       |\n   |       first assignment to `max_index`\n   |       help: consider making this binding mutable: `mut max_index`\n...\n14 |       max_index = i;\n   |       ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Create a function which returns the largest index of an element which\n/// is not greater than or equal to the element immediately preceding it. If\n/// no such element exists then return -1. The given vector will not contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>) -> isize {\n  let max_index = -1;\n  let max_value = -1;\n  for i in arr {\n    if i > max_value {\n      max_value = i;\n      max_index = i - 1;\n    }\n  }\n  return max_index;\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n",
      "timestamp": 1664293282,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max_value`\n  --> /tmp/tmpk6s8eeav.rs:15:7\n   |\n12 |   let max_value = -1;\n   |       ---------\n   |       |\n   |       first assignment to `max_value`\n   |       help: consider making this binding mutable: `mut max_value`\n...\n15 |       max_value = i;\n   |       ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `max_index`\n  --> /tmp/tmpk6s8eeav.rs:16:7\n   |\n11 |   let max_index = -1;\n   |       ---------\n   |       |\n   |       first assignment to `max_index`\n   |       help: consider making this binding mutable: `mut max_index`\n...\n16 |       max_index = i - 1;\n   |       ^^^^^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Create a function which returns the largest index of an element which\n/// is not greater than or equal to the element immediately preceding it. If\n/// no such element exists then return -1. The given vector will not contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>) -> isize {\n  let max_index = -1;\n  let max_value = -1;\n  for i in arr {\n    if max_value < i {\n      max_value = i;\n      max_index = i - 1;\n    }\n  }\n  return max_index;\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n",
      "timestamp": 1664293282,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max_value`\n  --> /tmp/tmp79cu3cor.rs:15:7\n   |\n12 |   let max_value = -1;\n   |       ---------\n   |       |\n   |       first assignment to `max_value`\n   |       help: consider making this binding mutable: `mut max_value`\n...\n15 |       max_value = i;\n   |       ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `max_index`\n  --> /tmp/tmp79cu3cor.rs:16:7\n   |\n11 |   let max_index = -1;\n   |       ---------\n   |       |\n   |       first assignment to `max_index`\n   |       help: consider making this binding mutable: `mut max_index`\n...\n16 |       max_index = i - 1;\n   |       ^^^^^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Create a function which returns the largest index of an element which\n/// is not greater than or equal to the element immediately preceding it. If\n/// no such element exists then return -1. The given vector will not contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>) -> isize {\n  let max_index = -1;\n  let max_value = -1;\n  let max_value_index = -1;\n  for i in arr {\n    if max_value < i {\n      max_value = i;\n      max_value_index = i;\n    }\n    if max_index < i {\n      max_index = i;\n    }\n  }\n  if max_value == max_value_index {\n    return -1\n  }\n  return max_index\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n",
      "timestamp": 1664293282,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max_value`\n  --> /tmp/tmp2cslh38v.rs:16:7\n   |\n12 |   let max_value = -1;\n   |       ---------\n   |       |\n   |       first assignment to `max_value`\n   |       help: consider making this binding mutable: `mut max_value`\n...\n16 |       max_value = i;\n   |       ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `max_value_index`\n  --> /tmp/tmp2cslh38v.rs:17:7\n   |\n13 |   let max_value_index = -1;\n   |       ---------------\n   |       |\n   |       first assignment to `max_value_index`\n   |       help: consider making this binding mutable: `mut max_value_index`\n...\n17 |       max_value_index = i;\n   |       ^^^^^^^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `max_index`\n  --> /tmp/tmp2cslh38v.rs:20:7\n   |\n11 |   let max_index = -1;\n   |       ---------\n   |       |\n   |       first assignment to `max_index`\n   |       help: consider making this binding mutable: `mut max_index`\n...\n20 |       max_index = i;\n   |       ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 3 previous errors\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Create a function which returns the largest index of an element which\n/// is not greater than or equal to the element immediately preceding it. If\n/// no such element exists then return -1. The given vector will not contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>) -> isize {\n  let max_index = -1;\n  let max_value = -1;\n  for i in arr {\n    if i > max_value {\n      max_value = i;\n      max_index = i - 1;\n    }\n  }\n  return max_index;\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n",
      "timestamp": 1664293282,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max_value`\n  --> /tmp/tmpk6s8eeav.rs:15:7\n   |\n12 |   let max_value = -1;\n   |       ---------\n   |       |\n   |       first assignment to `max_value`\n   |       help: consider making this binding mutable: `mut max_value`\n...\n15 |       max_value = i;\n   |       ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `max_index`\n  --> /tmp/tmpk6s8eeav.rs:16:7\n   |\n11 |   let max_index = -1;\n   |       ---------\n   |       |\n   |       first assignment to `max_index`\n   |       help: consider making this binding mutable: `mut max_index`\n...\n16 |       max_index = i - 1;\n   |       ^^^^^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Create a function which returns the largest index of an element which\n/// is not greater than or equal to the element immediately preceding it. If\n/// no such element exists then return -1. The given vector will not contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>) -> isize {\n  let max_index = -1;\n  for i in arr {\n    if i > max_index {\n      max_index = i;\n    }\n  }\n  return max_index;\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n",
      "timestamp": 1664293282,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max_index`\n  --> /tmp/tmpkwi327od.rs:14:7\n   |\n11 |   let max_index = -1;\n   |       ---------\n   |       |\n   |       first assignment to `max_index`\n   |       help: consider making this binding mutable: `mut max_index`\n...\n14 |       max_index = i;\n   |       ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Create a function which returns the largest index of an element which\n/// is not greater than or equal to the element immediately preceding it. If\n/// no such element exists then return -1. The given vector will not contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>) -> isize {\n    let max_index = 0\n    for i in arr {\n        if i > max_index {\n            max_index = i\n        }\n    }\n    if max_index == 0 {\n        return -1\n    }\n    return max_index\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n",
      "timestamp": 1664293282,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `for`\n  --> /tmp/tmpfm2jog85.rs:11:22\n   |\n11 |     let max_index = 0\n   |                      ^ help: add `;` here\n12 |     for i in arr {\n   |     --- unexpected token\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Create a function which returns the largest index of an element which\n/// is not greater than or equal to the element immediately preceding it. If\n/// no such element exists then return -1. The given vector will not contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>) -> isize {\n  let i = 0;\n  for i in arr.iter().next() {\n    if arr[i] > arr[i - 1] {\n      return i - 1;\n    }\n  }\n  return -1;\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n",
      "timestamp": 1664293282,
      "stdout": "",
      "stderr": "error[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmpknr__r3m.rs:13:8\n   |\n13 |     if arr[i] > arr[i - 1] {\n   |        ^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpknr__r3m.rs:13:17\n   |\n13 |     if arr[i] > arr[i - 1] {\n   |                 ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Create a function which returns the largest index of an element which\n/// is not greater than or equal to the element immediately preceding it. If\n/// no such element exists then return -1. The given vector will not contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>) -> isize {\n  let max_index = -1;\n  let max_value = -1;\n  for i in arr {\n    if i > max_value {\n      max_value = i;\n      max_index = i - 1;\n    }\n  }\n  return max_index;\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n",
      "timestamp": 1664293282,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max_value`\n  --> /tmp/tmpk6s8eeav.rs:15:7\n   |\n12 |   let max_value = -1;\n   |       ---------\n   |       |\n   |       first assignment to `max_value`\n   |       help: consider making this binding mutable: `mut max_value`\n...\n15 |       max_value = i;\n   |       ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `max_index`\n  --> /tmp/tmpk6s8eeav.rs:16:7\n   |\n11 |   let max_index = -1;\n   |       ---------\n   |       |\n   |       first assignment to `max_index`\n   |       help: consider making this binding mutable: `mut max_index`\n...\n16 |       max_index = i - 1;\n   |       ^^^^^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Create a function which returns the largest index of an element which\n/// is not greater than or equal to the element immediately preceding it. If\n/// no such element exists then return -1. The given vector will not contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>) -> isize {\n  let i = 0;\n  let j = arr.len - 1;\n  while (i < j) {\n    if (arr[i] < arr[j]) {\n      j -= 1;\n    } else {\n      i += 1;\n    }\n  }\n  if (i == j) {\n    return -1;\n  } else {\n    return i;\n  }\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n",
      "timestamp": 1664293282,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpkzzmcl12.rs:13:9\n   |\n13 |   while (i < j) {\n   |         ^     ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -   while (i < j) {\n13 +   while i < j {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpkzzmcl12.rs:14:8\n   |\n14 |     if (arr[i] < arr[j]) {\n   |        ^               ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (arr[i] < arr[j]) {\n14 +     if arr[i] < arr[j] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpkzzmcl12.rs:20:6\n   |\n20 |   if (i == j) {\n   |      ^      ^\n   |\nhelp: remove these parentheses\n   |\n20 -   if (i == j) {\n20 +   if i == j {\n   | \n\nerror[E0616]: field `len` of struct `Vec` is private\n  --> /tmp/tmpkzzmcl12.rs:12:15\n   |\n12 |   let j = arr.len - 1;\n   |               ^^^ private field\n   |\nhelp: a method `len` also exists, call it with parentheses\n   |\n12 |   let j = arr.len() - 1;\n   |                  ++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpkzzmcl12.rs:23:12\n   |\n10 | fn can_arrange(arr: Vec<isize>) -> isize {\n   |                                    ----- expected `isize` because of return type\n...\n23 |     return i;\n   |            ^ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the converted value doesn't fit\n   |\n23 |     return i.try_into().unwrap();\n   |             ++++++++++++++++++++\n\nerror: aborting due to 2 previous errors; 3 warnings emitted\n\nSome errors have detailed explanations: E0308, E0616.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Create a function which returns the largest index of an element which\n/// is not greater than or equal to the element immediately preceding it. If\n/// no such element exists then return -1. The given vector will not contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>) -> isize {\n    let max_index = 0\n    for i in arr {\n        if i > max_index {\n            max_index = i\n        }\n    }\n    if max_index == 0 {\n        return -1\n    }\n    return max_index\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n",
      "timestamp": 1664293282,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `for`\n  --> /tmp/tmpfm2jog85.rs:11:22\n   |\n11 |     let max_index = 0\n   |                      ^ help: add `;` here\n12 |     for i in arr {\n   |     --- unexpected token\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Create a function which returns the largest index of an element which\n/// is not greater than or equal to the element immediately preceding it. If\n/// no such element exists then return -1. The given vector will not contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>) -> isize {\n  let max_index = -1;\n  let max_value = -1;\n  for i in arr {\n    if i > max_value {\n      max_value = i;\n      max_index = i - 1;\n    }\n  }\n  return max_index;\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n",
      "timestamp": 1664293282,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max_value`\n  --> /tmp/tmpk6s8eeav.rs:15:7\n   |\n12 |   let max_value = -1;\n   |       ---------\n   |       |\n   |       first assignment to `max_value`\n   |       help: consider making this binding mutable: `mut max_value`\n...\n15 |       max_value = i;\n   |       ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `max_index`\n  --> /tmp/tmpk6s8eeav.rs:16:7\n   |\n11 |   let max_index = -1;\n   |       ---------\n   |       |\n   |       first assignment to `max_index`\n   |       help: consider making this binding mutable: `mut max_index`\n...\n16 |       max_index = i - 1;\n   |       ^^^^^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Create a function which returns the largest index of an element which\n/// is not greater than or equal to the element immediately preceding it. If\n/// no such element exists then return -1. The given vector will not contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>) -> isize {\n  let max_index = 0\n  let max_value = arr[0]\n  for i in arr {\n    if i > max_value {\n      max_value = i\n      max_index = i\n    }\n  }\n  return max_index\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n",
      "timestamp": 1664293282,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmphvlnfd_b.rs:11:20\n   |\n11 |   let max_index = 0\n   |                    ^ help: add `;` here\n12 |   let max_value = arr[0]\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmphvlnfd_b.rs:12:25\n   |\n12 |   let max_value = arr[0]\n   |                         ^ help: add `;` here\n13 |   for i in arr {\n   |   --- unexpected token\n\nerror: expected `;`, found `max_index`\n  --> /tmp/tmphvlnfd_b.rs:15:20\n   |\n15 |       max_value = i\n   |                    ^ help: add `;` here\n16 |       max_index = i\n   |       --------- unexpected token\n\nerror: aborting due to 3 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Create a function which returns the largest index of an element which\n/// is not greater than or equal to the element immediately preceding it. If\n/// no such element exists then return -1. The given vector will not contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>) -> isize {\n  let max_index = -1;\n  let max_value = -1;\n  for i in arr {\n    if i > max_value {\n      max_index = i;\n      max_value = i;\n    }\n  }\n  return max_index;\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n",
      "timestamp": 1664293282,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max_index`\n  --> /tmp/tmpnfmbev2i.rs:15:7\n   |\n11 |   let max_index = -1;\n   |       ---------\n   |       |\n   |       first assignment to `max_index`\n   |       help: consider making this binding mutable: `mut max_index`\n...\n15 |       max_index = i;\n   |       ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `max_value`\n  --> /tmp/tmpnfmbev2i.rs:16:7\n   |\n12 |   let max_value = -1;\n   |       ---------\n   |       |\n   |       first assignment to `max_value`\n   |       help: consider making this binding mutable: `mut max_value`\n...\n16 |       max_value = i;\n   |       ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Create a function which returns the largest index of an element which\n/// is not greater than or equal to the element immediately preceding it. If\n/// no such element exists then return -1. The given vector will not contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>) -> isize {\n  let i = 0;\n  let j = arr.len - 1;\n  while (i < j) {\n    if (arr[i] <= arr[j]) {\n      i += 1;\n    } else {\n      j -= 1;\n    }\n  }\n  if (i == j) {\n    return -1;\n  } else {\n    return i;\n  }\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n",
      "timestamp": 1664293282,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpbuc7w09x.rs:13:9\n   |\n13 |   while (i < j) {\n   |         ^     ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -   while (i < j) {\n13 +   while i < j {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpbuc7w09x.rs:14:8\n   |\n14 |     if (arr[i] <= arr[j]) {\n   |        ^                ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (arr[i] <= arr[j]) {\n14 +     if arr[i] <= arr[j] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpbuc7w09x.rs:20:6\n   |\n20 |   if (i == j) {\n   |      ^      ^\n   |\nhelp: remove these parentheses\n   |\n20 -   if (i == j) {\n20 +   if i == j {\n   | \n\nerror[E0616]: field `len` of struct `Vec` is private\n  --> /tmp/tmpbuc7w09x.rs:12:15\n   |\n12 |   let j = arr.len - 1;\n   |               ^^^ private field\n   |\nhelp: a method `len` also exists, call it with parentheses\n   |\n12 |   let j = arr.len() - 1;\n   |                  ++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpbuc7w09x.rs:23:12\n   |\n10 | fn can_arrange(arr: Vec<isize>) -> isize {\n   |                                    ----- expected `isize` because of return type\n...\n23 |     return i;\n   |            ^ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the converted value doesn't fit\n   |\n23 |     return i.try_into().unwrap();\n   |             ++++++++++++++++++++\n\nerror: aborting due to 2 previous errors; 3 warnings emitted\n\nSome errors have detailed explanations: E0308, E0616.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Create a function which returns the largest index of an element which\n/// is not greater than or equal to the element immediately preceding it. If\n/// no such element exists then return -1. The given vector will not contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>) -> isize {\n  let max_index = 0\n  let max_value = arr[0]\n  for i in arr {\n    if i > max_value {\n      max_value = i\n      max_index = i\n    }\n  }\n  return max_index\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n",
      "timestamp": 1664293282,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmphvlnfd_b.rs:11:20\n   |\n11 |   let max_index = 0\n   |                    ^ help: add `;` here\n12 |   let max_value = arr[0]\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmphvlnfd_b.rs:12:25\n   |\n12 |   let max_value = arr[0]\n   |                         ^ help: add `;` here\n13 |   for i in arr {\n   |   --- unexpected token\n\nerror: expected `;`, found `max_index`\n  --> /tmp/tmphvlnfd_b.rs:15:20\n   |\n15 |       max_value = i\n   |                    ^ help: add `;` here\n16 |       max_index = i\n   |       --------- unexpected token\n\nerror: aborting due to 3 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Create a function which returns the largest index of an element which\n/// is not greater than or equal to the element immediately preceding it. If\n/// no such element exists then return -1. The given vector will not contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>) -> isize {\n  let max_index = -1;\n  for i in arr {\n    if i > max_index {\n      max_index = i;\n    }\n  }\n  return max_index;\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n",
      "timestamp": 1664293282,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max_index`\n  --> /tmp/tmpkwi327od.rs:14:7\n   |\n11 |   let max_index = -1;\n   |       ---------\n   |       |\n   |       first assignment to `max_index`\n   |       help: consider making this binding mutable: `mut max_index`\n...\n14 |       max_index = i;\n   |       ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Create a function which returns the largest index of an element which\n/// is not greater than or equal to the element immediately preceding it. If\n/// no such element exists then return -1. The given vector will not contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>) -> isize {\n  let max_index = -1;\n  for i in arr {\n    if i > max_index {\n      max_index = i;\n    }\n  }\n  return max_index;\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n",
      "timestamp": 1664293282,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max_index`\n  --> /tmp/tmpkwi327od.rs:14:7\n   |\n11 |   let max_index = -1;\n   |       ---------\n   |       |\n   |       first assignment to `max_index`\n   |       help: consider making this binding mutable: `mut max_index`\n...\n14 |       max_index = i;\n   |       ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Create a function which returns the largest index of an element which\n/// is not greater than or equal to the element immediately preceding it. If\n/// no such element exists then return -1. The given vector will not contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>) -> isize {\n  let max_index = -1;\n  for i in arr {\n    if i > max_index {\n      max_index = i;\n    }\n  }\n  return max_index;\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n",
      "timestamp": 1664293282,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max_index`\n  --> /tmp/tmpkwi327od.rs:14:7\n   |\n11 |   let max_index = -1;\n   |       ---------\n   |       |\n   |       first assignment to `max_index`\n   |       help: consider making this binding mutable: `mut max_index`\n...\n14 |       max_index = i;\n   |       ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Create a function which returns the largest index of an element which\n/// is not greater than or equal to the element immediately preceding it. If\n/// no such element exists then return -1. The given vector will not contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>) -> isize {\n  let max_index = -1;\n  let max_value = -1;\n  let max_value_index = -1;\n  for i in arr {\n    if max_value < i {\n      max_value = i;\n      max_value_index = i;\n    }\n    if max_value == i {\n      continue;\n    }\n    max_index = i;\n    break;\n  }\n  return max_index;\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n",
      "timestamp": 1664293282,
      "stdout": "",
      "stderr": "warning: variable `max_value_index` is assigned to, but never used\n  --> /tmp/tmphp4hwn9u.rs:13:7\n   |\n13 |   let max_value_index = -1;\n   |       ^^^^^^^^^^^^^^^\n   |\n   = note: `#[warn(unused_variables)]` on by default\n   = note: consider using `_max_value_index` instead\n\nwarning: value assigned to `max_value_index` is never read\n  --> /tmp/tmphp4hwn9u.rs:17:7\n   |\n17 |       max_value_index = i;\n   |       ^^^^^^^^^^^^^^^\n   |\n   = note: `#[warn(unused_assignments)]` on by default\n   = help: maybe it is overwritten before being read?\n\nerror[E0384]: cannot assign twice to immutable variable `max_value`\n  --> /tmp/tmphp4hwn9u.rs:16:7\n   |\n12 |   let max_value = -1;\n   |       ---------\n   |       |\n   |       first assignment to `max_value`\n   |       help: consider making this binding mutable: `mut max_value`\n...\n16 |       max_value = i;\n   |       ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `max_value_index`\n  --> /tmp/tmphp4hwn9u.rs:17:7\n   |\n13 |   let max_value_index = -1;\n   |       ---------------\n   |       |\n   |       first assignment to `max_value_index`\n   |       help: consider making this binding mutable: `mut max_value_index`\n...\n17 |       max_value_index = i;\n   |       ^^^^^^^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `max_index`\n  --> /tmp/tmphp4hwn9u.rs:22:5\n   |\n11 |   let max_index = -1;\n   |       ---------\n   |       |\n   |       first assignment to `max_index`\n   |       help: consider making this binding mutable: `mut max_index`\n...\n22 |     max_index = i;\n   |     ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 3 previous errors; 2 warnings emitted\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Create a function which returns the largest index of an element which\n/// is not greater than or equal to the element immediately preceding it. If\n/// no such element exists then return -1. The given vector will not contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>) -> isize {\n  let max_index = -1;\n  for i in arr {\n    if i > max_index {\n      max_index = i;\n    }\n  }\n  return max_index;\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n",
      "timestamp": 1664293282,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max_index`\n  --> /tmp/tmpkwi327od.rs:14:7\n   |\n11 |   let max_index = -1;\n   |       ---------\n   |       |\n   |       first assignment to `max_index`\n   |       help: consider making this binding mutable: `mut max_index`\n...\n14 |       max_index = i;\n   |       ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Create a function which returns the largest index of an element which\n/// is not greater than or equal to the element immediately preceding it. If\n/// no such element exists then return -1. The given vector will not contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>) -> isize {\n  let max_index = -1;\n  let max_value = -1;\n  for i in arr {\n    if i > max_value {\n      max_index = i;\n      max_value = i;\n    }\n  }\n  return max_index;\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n",
      "timestamp": 1664293282,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max_index`\n  --> /tmp/tmpnfmbev2i.rs:15:7\n   |\n11 |   let max_index = -1;\n   |       ---------\n   |       |\n   |       first assignment to `max_index`\n   |       help: consider making this binding mutable: `mut max_index`\n...\n15 |       max_index = i;\n   |       ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `max_value`\n  --> /tmp/tmpnfmbev2i.rs:16:7\n   |\n12 |   let max_value = -1;\n   |       ---------\n   |       |\n   |       first assignment to `max_value`\n   |       help: consider making this binding mutable: `mut max_value`\n...\n16 |       max_value = i;\n   |       ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Create a function which returns the largest index of an element which\n/// is not greater than or equal to the element immediately preceding it. If\n/// no such element exists then return -1. The given vector will not contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>) -> isize {\n  let max_index = -1;\n  for i in arr {\n    if i > max_index {\n      max_index = i;\n    }\n  }\n  return max_index;\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n",
      "timestamp": 1664293282,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max_index`\n  --> /tmp/tmpkwi327od.rs:14:7\n   |\n11 |   let max_index = -1;\n   |       ---------\n   |       |\n   |       first assignment to `max_index`\n   |       help: consider making this binding mutable: `mut max_index`\n...\n14 |       max_index = i;\n   |       ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Create a function which returns the largest index of an element which\n/// is not greater than or equal to the element immediately preceding it. If\n/// no such element exists then return -1. The given vector will not contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>) -> isize {\n  let max_index = -1;\n  let max_value = -1;\n  for i in arr {\n    if i > max_value {\n      max_value = i;\n      max_index = i - 1;\n    }\n  }\n  return max_index;\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n",
      "timestamp": 1664293282,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max_value`\n  --> /tmp/tmpk6s8eeav.rs:15:7\n   |\n12 |   let max_value = -1;\n   |       ---------\n   |       |\n   |       first assignment to `max_value`\n   |       help: consider making this binding mutable: `mut max_value`\n...\n15 |       max_value = i;\n   |       ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `max_index`\n  --> /tmp/tmpk6s8eeav.rs:16:7\n   |\n11 |   let max_index = -1;\n   |       ---------\n   |       |\n   |       first assignment to `max_index`\n   |       help: consider making this binding mutable: `mut max_index`\n...\n16 |       max_index = i - 1;\n   |       ^^^^^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Create a function which returns the largest index of an element which\n/// is not greater than or equal to the element immediately preceding it. If\n/// no such element exists then return -1. The given vector will not contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>) -> isize {\n  let max_index = -1;\n  let max_value = -1;\n  for i in arr {\n    if i > max_value {\n      max_value = i;\n      max_index = i - 1;\n    }\n  }\n  return max_index;\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n",
      "timestamp": 1664293282,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max_value`\n  --> /tmp/tmpk6s8eeav.rs:15:7\n   |\n12 |   let max_value = -1;\n   |       ---------\n   |       |\n   |       first assignment to `max_value`\n   |       help: consider making this binding mutable: `mut max_value`\n...\n15 |       max_value = i;\n   |       ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `max_index`\n  --> /tmp/tmpk6s8eeav.rs:16:7\n   |\n11 |   let max_index = -1;\n   |       ---------\n   |       |\n   |       first assignment to `max_index`\n   |       help: consider making this binding mutable: `mut max_index`\n...\n16 |       max_index = i - 1;\n   |       ^^^^^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Create a function which returns the largest index of an element which\n/// is not greater than or equal to the element immediately preceding it. If\n/// no such element exists then return -1. The given vector will not contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>) -> isize {\n    let max_index = -1;\n    let max_value = -1;\n    for i in arr {\n        if i > max_value {\n            max_value = i;\n            max_index = i - 1;\n        }\n    }\n    return max_index;\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n",
      "timestamp": 1664293282,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max_value`\n  --> /tmp/tmpn_avckop.rs:15:13\n   |\n12 |     let max_value = -1;\n   |         ---------\n   |         |\n   |         first assignment to `max_value`\n   |         help: consider making this binding mutable: `mut max_value`\n...\n15 |             max_value = i;\n   |             ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `max_index`\n  --> /tmp/tmpn_avckop.rs:16:13\n   |\n11 |     let max_index = -1;\n   |         ---------\n   |         |\n   |         first assignment to `max_index`\n   |         help: consider making this binding mutable: `mut max_index`\n...\n16 |             max_index = i - 1;\n   |             ^^^^^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Create a function which returns the largest index of an element which\n/// is not greater than or equal to the element immediately preceding it. If\n/// no such element exists then return -1. The given vector will not contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>) -> isize {\n  let max_index = -1;\n  let max_value = -1;\n  for i in arr {\n    if i > max_value {\n      max_value = i;\n      max_index = i - 1;\n    }\n  }\n  return max_index;\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n",
      "timestamp": 1664293282,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max_value`\n  --> /tmp/tmpk6s8eeav.rs:15:7\n   |\n12 |   let max_value = -1;\n   |       ---------\n   |       |\n   |       first assignment to `max_value`\n   |       help: consider making this binding mutable: `mut max_value`\n...\n15 |       max_value = i;\n   |       ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `max_index`\n  --> /tmp/tmpk6s8eeav.rs:16:7\n   |\n11 |   let max_index = -1;\n   |       ---------\n   |       |\n   |       first assignment to `max_index`\n   |       help: consider making this binding mutable: `mut max_index`\n...\n16 |       max_index = i - 1;\n   |       ^^^^^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Create a function which returns the largest index of an element which\n/// is not greater than or equal to the element immediately preceding it. If\n/// no such element exists then return -1. The given vector will not contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>) -> isize {\n  let max_index = -1;\n  let max_value = -1;\n  let i = 0;\n  for v in arr {\n    if v > max_value {\n      max_value = v;\n      max_index = i;\n    }\n    i += 1;\n  }\n  return max_index;\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n",
      "timestamp": 1664293282,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max_value`\n  --> /tmp/tmpwtej4ens.rs:16:7\n   |\n12 |   let max_value = -1;\n   |       ---------\n   |       |\n   |       first assignment to `max_value`\n   |       help: consider making this binding mutable: `mut max_value`\n...\n16 |       max_value = v;\n   |       ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `max_index`\n  --> /tmp/tmpwtej4ens.rs:17:7\n   |\n11 |   let max_index = -1;\n   |       ---------\n   |       |\n   |       first assignment to `max_index`\n   |       help: consider making this binding mutable: `mut max_index`\n...\n17 |       max_index = i;\n   |       ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `i`\n  --> /tmp/tmpwtej4ens.rs:19:5\n   |\n13 |   let i = 0;\n   |       -\n   |       |\n   |       first assignment to `i`\n   |       help: consider making this binding mutable: `mut i`\n...\n19 |     i += 1;\n   |     ^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 3 previous errors\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Create a function which returns the largest index of an element which\n/// is not greater than or equal to the element immediately preceding it. If\n/// no such element exists then return -1. The given vector will not contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>) -> isize {\n  let max_index = 0\n  let max_value = arr[0]\n  for i in arr {\n    if i > max_value {\n      max_value = i\n      max_index = i\n    }\n  }\n  return max_index\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n",
      "timestamp": 1664293282,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmphvlnfd_b.rs:11:20\n   |\n11 |   let max_index = 0\n   |                    ^ help: add `;` here\n12 |   let max_value = arr[0]\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmphvlnfd_b.rs:12:25\n   |\n12 |   let max_value = arr[0]\n   |                         ^ help: add `;` here\n13 |   for i in arr {\n   |   --- unexpected token\n\nerror: expected `;`, found `max_index`\n  --> /tmp/tmphvlnfd_b.rs:15:20\n   |\n15 |       max_value = i\n   |                    ^ help: add `;` here\n16 |       max_index = i\n   |       --------- unexpected token\n\nerror: aborting due to 3 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Create a function which returns the largest index of an element which\n/// is not greater than or equal to the element immediately preceding it. If\n/// no such element exists then return -1. The given vector will not contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>) -> isize {\n  let i = 0;\n  let max = -1;\n  for v in arr {\n    if v > arr[i] {\n      max = i;\n    }\n    i = i + 1;\n  }\n  return max;\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n",
      "timestamp": 1664293282,
      "stdout": "",
      "stderr": "error[E0277]: the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmpjxbtqo0o.rs:12:13\n   |\n12 |   let max = -1;\n   |             ^^ the trait `Neg` is not implemented for `usize`\n   |\n   = help: the following other types implement trait `Neg`:\n             &f32\n             &f64\n             &i128\n             &i16\n             &i32\n             &i64\n             &i8\n             &isize\n           and 8 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpjxbtqo0o.rs:19:10\n   |\n10 | fn can_arrange(arr: Vec<isize>) -> isize {\n   |                                    ----- expected `isize` because of return type\n...\n19 |   return max;\n   |          ^^^ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the converted value doesn't fit\n   |\n19 |   return max.try_into().unwrap();\n   |             ++++++++++++++++++++\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Create a function which returns the largest index of an element which\n/// is not greater than or equal to the element immediately preceding it. If\n/// no such element exists then return -1. The given vector will not contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>) -> isize {\n  let i = 0;\n  let j = arr.len - 1;\n  while (i < j) {\n    if (arr[i] < arr[j]) {\n      j -= 1;\n    } else {\n      i += 1;\n    }\n  }\n  if (i == j) {\n    return -1;\n  } else {\n    return i;\n  }\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n",
      "timestamp": 1664293282,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpkzzmcl12.rs:13:9\n   |\n13 |   while (i < j) {\n   |         ^     ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -   while (i < j) {\n13 +   while i < j {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpkzzmcl12.rs:14:8\n   |\n14 |     if (arr[i] < arr[j]) {\n   |        ^               ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (arr[i] < arr[j]) {\n14 +     if arr[i] < arr[j] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpkzzmcl12.rs:20:6\n   |\n20 |   if (i == j) {\n   |      ^      ^\n   |\nhelp: remove these parentheses\n   |\n20 -   if (i == j) {\n20 +   if i == j {\n   | \n\nerror[E0616]: field `len` of struct `Vec` is private\n  --> /tmp/tmpkzzmcl12.rs:12:15\n   |\n12 |   let j = arr.len - 1;\n   |               ^^^ private field\n   |\nhelp: a method `len` also exists, call it with parentheses\n   |\n12 |   let j = arr.len() - 1;\n   |                  ++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpkzzmcl12.rs:23:12\n   |\n10 | fn can_arrange(arr: Vec<isize>) -> isize {\n   |                                    ----- expected `isize` because of return type\n...\n23 |     return i;\n   |            ^ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the converted value doesn't fit\n   |\n23 |     return i.try_into().unwrap();\n   |             ++++++++++++++++++++\n\nerror: aborting due to 2 previous errors; 3 warnings emitted\n\nSome errors have detailed explanations: E0308, E0616.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Create a function which returns the largest index of an element which\n/// is not greater than or equal to the element immediately preceding it. If\n/// no such element exists then return -1. The given vector will not contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>) -> isize {\n  let i = 0;\n  for i in arr.iter().next() {\n    if arr[i] > arr[i - 1] {\n      return i - 1;\n    }\n  }\n  return -1;\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n",
      "timestamp": 1664293282,
      "stdout": "",
      "stderr": "error[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmpknr__r3m.rs:13:8\n   |\n13 |     if arr[i] > arr[i - 1] {\n   |        ^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpknr__r3m.rs:13:17\n   |\n13 |     if arr[i] > arr[i - 1] {\n   |                 ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Create a function which returns the largest index of an element which\n/// is not greater than or equal to the element immediately preceding it. If\n/// no such element exists then return -1. The given vector will not contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>) -> isize {\n  let i = 0;\n  for i in arr.iter() {\n    if arr[i] > arr[i - 1] {\n      return i - 1;\n    }\n  }\n  return -1;\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n",
      "timestamp": 1664293282,
      "stdout": "",
      "stderr": "error[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmp3eikhltl.rs:13:8\n   |\n13 |     if arr[i] > arr[i - 1] {\n   |        ^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmp3eikhltl.rs:13:17\n   |\n13 |     if arr[i] > arr[i - 1] {\n   |                 ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Create a function which returns the largest index of an element which\n/// is not greater than or equal to the element immediately preceding it. If\n/// no such element exists then return -1. The given vector will not contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>) -> isize {\n  let max_index = -1;\n  let max_value = -1;\n  for i in arr {\n    if i > max_value {\n      max_value = i;\n      max_index = i - 1;\n    }\n  }\n  return max_index;\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n",
      "timestamp": 1664293282,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max_value`\n  --> /tmp/tmpk6s8eeav.rs:15:7\n   |\n12 |   let max_value = -1;\n   |       ---------\n   |       |\n   |       first assignment to `max_value`\n   |       help: consider making this binding mutable: `mut max_value`\n...\n15 |       max_value = i;\n   |       ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `max_index`\n  --> /tmp/tmpk6s8eeav.rs:16:7\n   |\n11 |   let max_index = -1;\n   |       ---------\n   |       |\n   |       first assignment to `max_index`\n   |       help: consider making this binding mutable: `mut max_index`\n...\n16 |       max_index = i - 1;\n   |       ^^^^^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Create a function which returns the largest index of an element which\n/// is not greater than or equal to the element immediately preceding it. If\n/// no such element exists then return -1. The given vector will not contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>) -> isize {\n  let max_index = -1;\n  let max_value = -1;\n  for i in arr {\n    if i > max_value {\n      max_value = i;\n      max_index = i - 1;\n    }\n  }\n  return max_index;\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n",
      "timestamp": 1664293282,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max_value`\n  --> /tmp/tmpk6s8eeav.rs:15:7\n   |\n12 |   let max_value = -1;\n   |       ---------\n   |       |\n   |       first assignment to `max_value`\n   |       help: consider making this binding mutable: `mut max_value`\n...\n15 |       max_value = i;\n   |       ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `max_index`\n  --> /tmp/tmpk6s8eeav.rs:16:7\n   |\n11 |   let max_index = -1;\n   |       ---------\n   |       |\n   |       first assignment to `max_index`\n   |       help: consider making this binding mutable: `mut max_index`\n...\n16 |       max_index = i - 1;\n   |       ^^^^^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Create a function which returns the largest index of an element which\n/// is not greater than or equal to the element immediately preceding it. If\n/// no such element exists then return -1. The given vector will not contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>) -> isize {\n  let max_index = -1;\n  let max_value = -1;\n  let max_value_index = -1;\n  for i in arr {\n    if i > max_value {\n      max_value = i;\n      max_value_index = i;\n    }\n    if i >= max_value {\n      max_index = i;\n    }\n  }\n  if max_index == -1 {\n    return -1;\n  }\n  return max_index;\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n",
      "timestamp": 1664293282,
      "stdout": "",
      "stderr": "warning: variable `max_value_index` is assigned to, but never used\n  --> /tmp/tmpuqhhpi0x.rs:13:7\n   |\n13 |   let max_value_index = -1;\n   |       ^^^^^^^^^^^^^^^\n   |\n   = note: `#[warn(unused_variables)]` on by default\n   = note: consider using `_max_value_index` instead\n\nwarning: value assigned to `max_value_index` is never read\n  --> /tmp/tmpuqhhpi0x.rs:17:7\n   |\n17 |       max_value_index = i;\n   |       ^^^^^^^^^^^^^^^\n   |\n   = note: `#[warn(unused_assignments)]` on by default\n   = help: maybe it is overwritten before being read?\n\nerror[E0384]: cannot assign twice to immutable variable `max_value`\n  --> /tmp/tmpuqhhpi0x.rs:16:7\n   |\n12 |   let max_value = -1;\n   |       ---------\n   |       |\n   |       first assignment to `max_value`\n   |       help: consider making this binding mutable: `mut max_value`\n...\n16 |       max_value = i;\n   |       ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `max_value_index`\n  --> /tmp/tmpuqhhpi0x.rs:17:7\n   |\n13 |   let max_value_index = -1;\n   |       ---------------\n   |       |\n   |       first assignment to `max_value_index`\n   |       help: consider making this binding mutable: `mut max_value_index`\n...\n17 |       max_value_index = i;\n   |       ^^^^^^^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `max_index`\n  --> /tmp/tmpuqhhpi0x.rs:20:7\n   |\n11 |   let max_index = -1;\n   |       ---------\n   |       |\n   |       first assignment to `max_index`\n   |       help: consider making this binding mutable: `mut max_index`\n...\n20 |       max_index = i;\n   |       ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 3 previous errors; 2 warnings emitted\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Create a function which returns the largest index of an element which\n/// is not greater than or equal to the element immediately preceding it. If\n/// no such element exists then return -1. The given vector will not contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>) -> isize {\n    let max_index = 0\n    for i in arr {\n        if i > max_index {\n            max_index = i\n        }\n    }\n    if max_index == 0 {\n        return -1\n    }\n    return max_index\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n",
      "timestamp": 1664293282,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `for`\n  --> /tmp/tmpfm2jog85.rs:11:22\n   |\n11 |     let max_index = 0\n   |                      ^ help: add `;` here\n12 |     for i in arr {\n   |     --- unexpected token\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Create a function which returns the largest index of an element which\n/// is not greater than or equal to the element immediately preceding it. If\n/// no such element exists then return -1. The given vector will not contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>) -> isize {\n  let i = 0;\n  for i in arr.iter().next() {\n    if arr[i] > arr[i - 1] {\n      return i - 1;\n    }\n  }\n  return -1;\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n",
      "timestamp": 1664293282,
      "stdout": "",
      "stderr": "error[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmpknr__r3m.rs:13:8\n   |\n13 |     if arr[i] > arr[i - 1] {\n   |        ^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpknr__r3m.rs:13:17\n   |\n13 |     if arr[i] > arr[i - 1] {\n   |                 ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Create a function which returns the largest index of an element which\n/// is not greater than or equal to the element immediately preceding it. If\n/// no such element exists then return -1. The given vector will not contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>) -> isize {\n  let max_index = -1;\n  let max_value = -1;\n  for i in arr {\n    if i > max_value {\n      max_index = i;\n      max_value = i;\n    }\n  }\n  return max_index;\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n",
      "timestamp": 1664293282,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max_index`\n  --> /tmp/tmpnfmbev2i.rs:15:7\n   |\n11 |   let max_index = -1;\n   |       ---------\n   |       |\n   |       first assignment to `max_index`\n   |       help: consider making this binding mutable: `mut max_index`\n...\n15 |       max_index = i;\n   |       ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `max_value`\n  --> /tmp/tmpnfmbev2i.rs:16:7\n   |\n12 |   let max_value = -1;\n   |       ---------\n   |       |\n   |       first assignment to `max_value`\n   |       help: consider making this binding mutable: `mut max_value`\n...\n16 |       max_value = i;\n   |       ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Create a function which returns the largest index of an element which\n/// is not greater than or equal to the element immediately preceding it. If\n/// no such element exists then return -1. The given vector will not contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>) -> isize {\n  let max_index = -1;\n  let max_value = -1;\n  for i in arr {\n    if i > max_value {\n      max_value = i;\n      max_index = i - 1;\n    }\n  }\n  return max_index;\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n",
      "timestamp": 1664293282,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max_value`\n  --> /tmp/tmpk6s8eeav.rs:15:7\n   |\n12 |   let max_value = -1;\n   |       ---------\n   |       |\n   |       first assignment to `max_value`\n   |       help: consider making this binding mutable: `mut max_value`\n...\n15 |       max_value = i;\n   |       ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `max_index`\n  --> /tmp/tmpk6s8eeav.rs:16:7\n   |\n11 |   let max_index = -1;\n   |       ---------\n   |       |\n   |       first assignment to `max_index`\n   |       help: consider making this binding mutable: `mut max_index`\n...\n16 |       max_index = i - 1;\n   |       ^^^^^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Create a function which returns the largest index of an element which\n/// is not greater than or equal to the element immediately preceding it. If\n/// no such element exists then return -1. The given vector will not contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>) -> isize {\n  let max_index = 0\n  let max_value = arr[0]\n  for i in arr {\n    if i <= max_value {\n      max_value = i\n      max_index = i\n    }\n  }\n  return max_index\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n",
      "timestamp": 1664293282,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmprafqq_5k.rs:11:20\n   |\n11 |   let max_index = 0\n   |                    ^ help: add `;` here\n12 |   let max_value = arr[0]\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmprafqq_5k.rs:12:25\n   |\n12 |   let max_value = arr[0]\n   |                         ^ help: add `;` here\n13 |   for i in arr {\n   |   --- unexpected token\n\nerror: expected `;`, found `max_index`\n  --> /tmp/tmprafqq_5k.rs:15:20\n   |\n15 |       max_value = i\n   |                    ^ help: add `;` here\n16 |       max_index = i\n   |       --------- unexpected token\n\nerror: aborting due to 3 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Create a function which returns the largest index of an element which\n/// is not greater than or equal to the element immediately preceding it. If\n/// no such element exists then return -1. The given vector will not contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>) -> isize {\n  let max_index = -1;\n  for i in 0..arr.len() - 1 {\n    if arr[i] <= arr[i + 1] {\n      max_index = i;\n    }\n  }\n  return max_index;\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n",
      "timestamp": 1664293282,
      "stdout": "",
      "stderr": "error[E0277]: the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmpx7m93gwt.rs:11:19\n   |\n11 |   let max_index = -1;\n   |                   ^^ the trait `Neg` is not implemented for `usize`\n   |\n   = help: the following other types implement trait `Neg`:\n             &f32\n             &f64\n             &i128\n             &i16\n             &i32\n             &i64\n             &i8\n             &isize\n           and 8 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpx7m93gwt.rs:17:10\n   |\n10 | fn can_arrange(arr: Vec<isize>) -> isize {\n   |                                    ----- expected `isize` because of return type\n...\n17 |   return max_index;\n   |          ^^^^^^^^^ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the converted value doesn't fit\n   |\n17 |   return max_index.try_into().unwrap();\n   |                   ++++++++++++++++++++\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Create a function which returns the largest index of an element which\n/// is not greater than or equal to the element immediately preceding it. If\n/// no such element exists then return -1. The given vector will not contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>) -> isize {\n  let i = 0;\n  let j = arr.len - 1;\n  while (i < j) {\n    if (arr[i] <= arr[j]) {\n      i += 1;\n    } else {\n      j -= 1;\n    }\n  }\n  if (i == j) {\n    return -1;\n  } else {\n    return i;\n  }\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n",
      "timestamp": 1664293282,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpbuc7w09x.rs:13:9\n   |\n13 |   while (i < j) {\n   |         ^     ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -   while (i < j) {\n13 +   while i < j {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpbuc7w09x.rs:14:8\n   |\n14 |     if (arr[i] <= arr[j]) {\n   |        ^                ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (arr[i] <= arr[j]) {\n14 +     if arr[i] <= arr[j] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpbuc7w09x.rs:20:6\n   |\n20 |   if (i == j) {\n   |      ^      ^\n   |\nhelp: remove these parentheses\n   |\n20 -   if (i == j) {\n20 +   if i == j {\n   | \n\nerror[E0616]: field `len` of struct `Vec` is private\n  --> /tmp/tmpbuc7w09x.rs:12:15\n   |\n12 |   let j = arr.len - 1;\n   |               ^^^ private field\n   |\nhelp: a method `len` also exists, call it with parentheses\n   |\n12 |   let j = arr.len() - 1;\n   |                  ++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpbuc7w09x.rs:23:12\n   |\n10 | fn can_arrange(arr: Vec<isize>) -> isize {\n   |                                    ----- expected `isize` because of return type\n...\n23 |     return i;\n   |            ^ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the converted value doesn't fit\n   |\n23 |     return i.try_into().unwrap();\n   |             ++++++++++++++++++++\n\nerror: aborting due to 2 previous errors; 3 warnings emitted\n\nSome errors have detailed explanations: E0308, E0616.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Create a function which returns the largest index of an element which\n/// is not greater than or equal to the element immediately preceding it. If\n/// no such element exists then return -1. The given vector will not contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>) -> isize {\n  let max_index = -1;\n  for i in arr {\n    if i > max_index {\n      max_index = i;\n    }\n  }\n  return max_index;\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n",
      "timestamp": 1664293282,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max_index`\n  --> /tmp/tmpkwi327od.rs:14:7\n   |\n11 |   let max_index = -1;\n   |       ---------\n   |       |\n   |       first assignment to `max_index`\n   |       help: consider making this binding mutable: `mut max_index`\n...\n14 |       max_index = i;\n   |       ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Create a function which returns the largest index of an element which\n/// is not greater than or equal to the element immediately preceding it. If\n/// no such element exists then return -1. The given vector will not contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>) -> isize {\n  let max_index = 0\n  for i in arr {\n    if i > max_index {\n      max_index = i\n    }\n  }\n  if max_index == 0 {\n    return -1\n  }\n  return max_index\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n",
      "timestamp": 1664293282,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `for`\n  --> /tmp/tmpudycxnrf.rs:11:20\n   |\n11 |   let max_index = 0\n   |                    ^ help: add `;` here\n12 |   for i in arr {\n   |   --- unexpected token\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Create a function which returns the largest index of an element which\n/// is not greater than or equal to the element immediately preceding it. If\n/// no such element exists then return -1. The given vector will not contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>) -> isize {\n  let i = 0;\n  let j = arr.len - 1;\n  while (i < j) {\n    if (arr[i] < arr[j]) {\n      j -= 1;\n    } else {\n      i += 1;\n    }\n  }\n  if (i == j) {\n    return -1;\n  } else {\n    return i;\n  }\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n",
      "timestamp": 1664293282,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpkzzmcl12.rs:13:9\n   |\n13 |   while (i < j) {\n   |         ^     ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -   while (i < j) {\n13 +   while i < j {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpkzzmcl12.rs:14:8\n   |\n14 |     if (arr[i] < arr[j]) {\n   |        ^               ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (arr[i] < arr[j]) {\n14 +     if arr[i] < arr[j] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpkzzmcl12.rs:20:6\n   |\n20 |   if (i == j) {\n   |      ^      ^\n   |\nhelp: remove these parentheses\n   |\n20 -   if (i == j) {\n20 +   if i == j {\n   | \n\nerror[E0616]: field `len` of struct `Vec` is private\n  --> /tmp/tmpkzzmcl12.rs:12:15\n   |\n12 |   let j = arr.len - 1;\n   |               ^^^ private field\n   |\nhelp: a method `len` also exists, call it with parentheses\n   |\n12 |   let j = arr.len() - 1;\n   |                  ++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpkzzmcl12.rs:23:12\n   |\n10 | fn can_arrange(arr: Vec<isize>) -> isize {\n   |                                    ----- expected `isize` because of return type\n...\n23 |     return i;\n   |            ^ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the converted value doesn't fit\n   |\n23 |     return i.try_into().unwrap();\n   |             ++++++++++++++++++++\n\nerror: aborting due to 2 previous errors; 3 warnings emitted\n\nSome errors have detailed explanations: E0308, E0616.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Create a function which returns the largest index of an element which\n/// is not greater than or equal to the element immediately preceding it. If\n/// no such element exists then return -1. The given vector will not contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>) -> isize {\n  let max_index = -1;\n  let max_value = -1;\n  for i in arr {\n    if i > max_value {\n      max_value = i;\n      max_index = i - 1;\n    }\n  }\n  return max_index;\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n",
      "timestamp": 1664293282,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max_value`\n  --> /tmp/tmpk6s8eeav.rs:15:7\n   |\n12 |   let max_value = -1;\n   |       ---------\n   |       |\n   |       first assignment to `max_value`\n   |       help: consider making this binding mutable: `mut max_value`\n...\n15 |       max_value = i;\n   |       ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `max_index`\n  --> /tmp/tmpk6s8eeav.rs:16:7\n   |\n11 |   let max_index = -1;\n   |       ---------\n   |       |\n   |       first assignment to `max_index`\n   |       help: consider making this binding mutable: `mut max_index`\n...\n16 |       max_index = i - 1;\n   |       ^^^^^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Create a function which returns the largest index of an element which\n/// is not greater than or equal to the element immediately preceding it. If\n/// no such element exists then return -1. The given vector will not contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>) -> isize {\n    let max_index = -1;\n    let max_value = -1;\n    let i = 0;\n    for v in arr {\n        if v > max_value {\n            max_value = v;\n            max_index = i;\n        }\n        i += 1;\n    }\n    return max_index;\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n",
      "timestamp": 1664293282,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max_value`\n  --> /tmp/tmp5l29rvbs.rs:16:13\n   |\n12 |     let max_value = -1;\n   |         ---------\n   |         |\n   |         first assignment to `max_value`\n   |         help: consider making this binding mutable: `mut max_value`\n...\n16 |             max_value = v;\n   |             ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `max_index`\n  --> /tmp/tmp5l29rvbs.rs:17:13\n   |\n11 |     let max_index = -1;\n   |         ---------\n   |         |\n   |         first assignment to `max_index`\n   |         help: consider making this binding mutable: `mut max_index`\n...\n17 |             max_index = i;\n   |             ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `i`\n  --> /tmp/tmp5l29rvbs.rs:19:9\n   |\n13 |     let i = 0;\n   |         -\n   |         |\n   |         first assignment to `i`\n   |         help: consider making this binding mutable: `mut i`\n...\n19 |         i += 1;\n   |         ^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 3 previous errors\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Create a function which returns the largest index of an element which\n/// is not greater than or equal to the element immediately preceding it. If\n/// no such element exists then return -1. The given vector will not contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>) -> isize {\n  let max_index = -1;\n  let max_value = -1;\n  for i in arr {\n    if i > max_value {\n      max_value = i;\n      max_index = i - 1;\n    }\n  }\n  return max_index;\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n",
      "timestamp": 1664293282,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max_value`\n  --> /tmp/tmpk6s8eeav.rs:15:7\n   |\n12 |   let max_value = -1;\n   |       ---------\n   |       |\n   |       first assignment to `max_value`\n   |       help: consider making this binding mutable: `mut max_value`\n...\n15 |       max_value = i;\n   |       ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `max_index`\n  --> /tmp/tmpk6s8eeav.rs:16:7\n   |\n11 |   let max_index = -1;\n   |       ---------\n   |       |\n   |       first assignment to `max_index`\n   |       help: consider making this binding mutable: `mut max_index`\n...\n16 |       max_index = i - 1;\n   |       ^^^^^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Create a function which returns the largest index of an element which\n/// is not greater than or equal to the element immediately preceding it. If\n/// no such element exists then return -1. The given vector will not contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>) -> isize {\n  let max_index = -1;\n  for i in arr {\n    if i > max_index {\n      max_index = i;\n    }\n  }\n  return max_index;\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n",
      "timestamp": 1664293282,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max_index`\n  --> /tmp/tmpkwi327od.rs:14:7\n   |\n11 |   let max_index = -1;\n   |       ---------\n   |       |\n   |       first assignment to `max_index`\n   |       help: consider making this binding mutable: `mut max_index`\n...\n14 |       max_index = i;\n   |       ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Create a function which returns the largest index of an element which\n/// is not greater than or equal to the element immediately preceding it. If\n/// no such element exists then return -1. The given vector will not contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>) -> isize {\n  let max_index = 0\n  let max_value = arr[0]\n  for i in arr {\n    if i > max_value {\n      max_value = i\n      max_index = i\n    }\n  }\n  if max_value == arr[0] {\n    return -1\n  }\n  return max_index\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n",
      "timestamp": 1664293282,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmpm4vx2tfa.rs:11:20\n   |\n11 |   let max_index = 0\n   |                    ^ help: add `;` here\n12 |   let max_value = arr[0]\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpm4vx2tfa.rs:12:25\n   |\n12 |   let max_value = arr[0]\n   |                         ^ help: add `;` here\n13 |   for i in arr {\n   |   --- unexpected token\n\nerror: expected `;`, found `max_index`\n  --> /tmp/tmpm4vx2tfa.rs:15:20\n   |\n15 |       max_value = i\n   |                    ^ help: add `;` here\n16 |       max_index = i\n   |       --------- unexpected token\n\nerror: aborting due to 3 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Create a function which returns the largest index of an element which\n/// is not greater than or equal to the element immediately preceding it. If\n/// no such element exists then return -1. The given vector will not contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>) -> isize {\n  let i = 0;\n  let j = arr.len - 1;\n  while (i < j) {\n    if (arr[i] < arr[j]) {\n      j -= 1;\n    } else {\n      i += 1;\n    }\n  }\n  if (i == j) {\n    return -1;\n  } else {\n    return i;\n  }\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n",
      "timestamp": 1664293282,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpkzzmcl12.rs:13:9\n   |\n13 |   while (i < j) {\n   |         ^     ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -   while (i < j) {\n13 +   while i < j {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpkzzmcl12.rs:14:8\n   |\n14 |     if (arr[i] < arr[j]) {\n   |        ^               ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (arr[i] < arr[j]) {\n14 +     if arr[i] < arr[j] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpkzzmcl12.rs:20:6\n   |\n20 |   if (i == j) {\n   |      ^      ^\n   |\nhelp: remove these parentheses\n   |\n20 -   if (i == j) {\n20 +   if i == j {\n   | \n\nerror[E0616]: field `len` of struct `Vec` is private\n  --> /tmp/tmpkzzmcl12.rs:12:15\n   |\n12 |   let j = arr.len - 1;\n   |               ^^^ private field\n   |\nhelp: a method `len` also exists, call it with parentheses\n   |\n12 |   let j = arr.len() - 1;\n   |                  ++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpkzzmcl12.rs:23:12\n   |\n10 | fn can_arrange(arr: Vec<isize>) -> isize {\n   |                                    ----- expected `isize` because of return type\n...\n23 |     return i;\n   |            ^ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the converted value doesn't fit\n   |\n23 |     return i.try_into().unwrap();\n   |             ++++++++++++++++++++\n\nerror: aborting due to 2 previous errors; 3 warnings emitted\n\nSome errors have detailed explanations: E0308, E0616.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Create a function which returns the largest index of an element which\n/// is not greater than or equal to the element immediately preceding it. If\n/// no such element exists then return -1. The given vector will not contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>) -> isize {\n  let max_index = -1;\n  let max_value = -1;\n  for i in arr {\n    if i > max_value {\n      max_value = i;\n      max_index = i - 1;\n    }\n  }\n  return max_index;\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n",
      "timestamp": 1664293282,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max_value`\n  --> /tmp/tmpk6s8eeav.rs:15:7\n   |\n12 |   let max_value = -1;\n   |       ---------\n   |       |\n   |       first assignment to `max_value`\n   |       help: consider making this binding mutable: `mut max_value`\n...\n15 |       max_value = i;\n   |       ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `max_index`\n  --> /tmp/tmpk6s8eeav.rs:16:7\n   |\n11 |   let max_index = -1;\n   |       ---------\n   |       |\n   |       first assignment to `max_index`\n   |       help: consider making this binding mutable: `mut max_index`\n...\n16 |       max_index = i - 1;\n   |       ^^^^^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Create a function which returns the largest index of an element which\n/// is not greater than or equal to the element immediately preceding it. If\n/// no such element exists then return -1. The given vector will not contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>) -> isize {\n  let max_index = 0\n  let max_value = arr[0]\n  for i in arr {\n    if i > max_value {\n      max_value = i\n      max_index = i\n    }\n  }\n  return max_index\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n",
      "timestamp": 1664293282,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmphvlnfd_b.rs:11:20\n   |\n11 |   let max_index = 0\n   |                    ^ help: add `;` here\n12 |   let max_value = arr[0]\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmphvlnfd_b.rs:12:25\n   |\n12 |   let max_value = arr[0]\n   |                         ^ help: add `;` here\n13 |   for i in arr {\n   |   --- unexpected token\n\nerror: expected `;`, found `max_index`\n  --> /tmp/tmphvlnfd_b.rs:15:20\n   |\n15 |       max_value = i\n   |                    ^ help: add `;` here\n16 |       max_index = i\n   |       --------- unexpected token\n\nerror: aborting due to 3 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Create a function which returns the largest index of an element which\n/// is not greater than or equal to the element immediately preceding it. If\n/// no such element exists then return -1. The given vector will not contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>) -> isize {\n  let max_index = -1;\n  let max_value = -1;\n  for i in arr {\n    if i > max_value {\n      max_value = i;\n      max_index = i - 1;\n    }\n  }\n  return max_index;\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n",
      "timestamp": 1664293282,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max_value`\n  --> /tmp/tmpk6s8eeav.rs:15:7\n   |\n12 |   let max_value = -1;\n   |       ---------\n   |       |\n   |       first assignment to `max_value`\n   |       help: consider making this binding mutable: `mut max_value`\n...\n15 |       max_value = i;\n   |       ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `max_index`\n  --> /tmp/tmpk6s8eeav.rs:16:7\n   |\n11 |   let max_index = -1;\n   |       ---------\n   |       |\n   |       first assignment to `max_index`\n   |       help: consider making this binding mutable: `mut max_index`\n...\n16 |       max_index = i - 1;\n   |       ^^^^^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Create a function which returns the largest index of an element which\n/// is not greater than or equal to the element immediately preceding it. If\n/// no such element exists then return -1. The given vector will not contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>) -> isize {\n  let i = 0;\n  for j in arr {\n    if j > i {\n      return i;\n    }\n    i = j;\n  }\n  return -1;\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n",
      "timestamp": 1664293282,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `i`\n  --> /tmp/tmpcbla90l_.rs:16:5\n   |\n11 |   let i = 0;\n   |       -\n   |       |\n   |       first assignment to `i`\n   |       help: consider making this binding mutable: `mut i`\n...\n16 |     i = j;\n   |     ^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Create a function which returns the largest index of an element which\n/// is not greater than or equal to the element immediately preceding it. If\n/// no such element exists then return -1. The given vector will not contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>) -> isize {\n    let max_index = -1;\n    for i in arr {\n        if i > max_index {\n            max_index = i;\n        }\n    }\n    return max_index;\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n",
      "timestamp": 1664293282,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max_index`\n  --> /tmp/tmpp0b3m15z.rs:14:13\n   |\n11 |     let max_index = -1;\n   |         ---------\n   |         |\n   |         first assignment to `max_index`\n   |         help: consider making this binding mutable: `mut max_index`\n...\n14 |             max_index = i;\n   |             ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Create a function which returns the largest index of an element which\n/// is not greater than or equal to the element immediately preceding it. If\n/// no such element exists then return -1. The given vector will not contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>) -> isize {\n  let max_index = -1;\n  for i in 0..arr.len() - 1 {\n    if arr[i] <= arr[i + 1] {\n      max_index = i;\n      break;\n    }\n  }\n  return max_index;\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n",
      "timestamp": 1664293282,
      "stdout": "",
      "stderr": "error[E0277]: the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmp50pk2kij.rs:11:19\n   |\n11 |   let max_index = -1;\n   |                   ^^ the trait `Neg` is not implemented for `usize`\n   |\n   = help: the following other types implement trait `Neg`:\n             &f32\n             &f64\n             &i128\n             &i16\n             &i32\n             &i64\n             &i8\n             &isize\n           and 8 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp50pk2kij.rs:18:10\n   |\n10 | fn can_arrange(arr: Vec<isize>) -> isize {\n   |                                    ----- expected `isize` because of return type\n...\n18 |   return max_index;\n   |          ^^^^^^^^^ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the converted value doesn't fit\n   |\n18 |   return max_index.try_into().unwrap();\n   |                   ++++++++++++++++++++\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Create a function which returns the largest index of an element which\n/// is not greater than or equal to the element immediately preceding it. If\n/// no such element exists then return -1. The given vector will not contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>) -> isize {\n  let i = 0;\n  let j = arr.len() - 1;\n  while (i < j) {\n    if (arr[i] < arr[j]) {\n      j -= 1;\n    } else {\n      return i;\n    }\n  }\n  return -1;\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n",
      "timestamp": 1664293282,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmprrwh5kur.rs:13:9\n   |\n13 |   while (i < j) {\n   |         ^     ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -   while (i < j) {\n13 +   while i < j {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmprrwh5kur.rs:14:8\n   |\n14 |     if (arr[i] < arr[j]) {\n   |        ^               ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (arr[i] < arr[j]) {\n14 +     if arr[i] < arr[j] {\n   | \n\nerror[E0308]: mismatched types\n  --> /tmp/tmprrwh5kur.rs:17:14\n   |\n17 |       return i;\n   |              ^ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the converted value doesn't fit\n   |\n17 |       return i.try_into().unwrap();\n   |               ++++++++++++++++++++\n\nerror: aborting due to previous error; 2 warnings emitted\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Create a function which returns the largest index of an element which\n/// is not greater than or equal to the element immediately preceding it. If\n/// no such element exists then return -1. The given vector will not contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>) -> isize {\n  let max_index = -1;\n  let max_value = -1;\n  for i in arr {\n    if i > max_value {\n      max_value = i;\n      max_index = i - 1;\n    }\n  }\n  return max_index;\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n",
      "timestamp": 1664293282,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max_value`\n  --> /tmp/tmpk6s8eeav.rs:15:7\n   |\n12 |   let max_value = -1;\n   |       ---------\n   |       |\n   |       first assignment to `max_value`\n   |       help: consider making this binding mutable: `mut max_value`\n...\n15 |       max_value = i;\n   |       ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `max_index`\n  --> /tmp/tmpk6s8eeav.rs:16:7\n   |\n11 |   let max_index = -1;\n   |       ---------\n   |       |\n   |       first assignment to `max_index`\n   |       help: consider making this binding mutable: `mut max_index`\n...\n16 |       max_index = i - 1;\n   |       ^^^^^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Create a function which returns the largest index of an element which\n/// is not greater than or equal to the element immediately preceding it. If\n/// no such element exists then return -1. The given vector will not contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>) -> isize {\n  let i = 0;\n  let j = arr.len - 1;\n  while (i < j) {\n    if (arr[i] < arr[j]) {\n      j -= 1;\n    } else {\n      i += 1;\n    }\n  }\n  if (i == j) {\n    return -1;\n  } else {\n    return i;\n  }\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n",
      "timestamp": 1664293282,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpkzzmcl12.rs:13:9\n   |\n13 |   while (i < j) {\n   |         ^     ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -   while (i < j) {\n13 +   while i < j {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpkzzmcl12.rs:14:8\n   |\n14 |     if (arr[i] < arr[j]) {\n   |        ^               ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (arr[i] < arr[j]) {\n14 +     if arr[i] < arr[j] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpkzzmcl12.rs:20:6\n   |\n20 |   if (i == j) {\n   |      ^      ^\n   |\nhelp: remove these parentheses\n   |\n20 -   if (i == j) {\n20 +   if i == j {\n   | \n\nerror[E0616]: field `len` of struct `Vec` is private\n  --> /tmp/tmpkzzmcl12.rs:12:15\n   |\n12 |   let j = arr.len - 1;\n   |               ^^^ private field\n   |\nhelp: a method `len` also exists, call it with parentheses\n   |\n12 |   let j = arr.len() - 1;\n   |                  ++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpkzzmcl12.rs:23:12\n   |\n10 | fn can_arrange(arr: Vec<isize>) -> isize {\n   |                                    ----- expected `isize` because of return type\n...\n23 |     return i;\n   |            ^ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the converted value doesn't fit\n   |\n23 |     return i.try_into().unwrap();\n   |             ++++++++++++++++++++\n\nerror: aborting due to 2 previous errors; 3 warnings emitted\n\nSome errors have detailed explanations: E0308, E0616.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Create a function which returns the largest index of an element which\n/// is not greater than or equal to the element immediately preceding it. If\n/// no such element exists then return -1. The given vector will not contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>) -> isize {\n  let max_index = -1;\n  let max_value = -1;\n  let i = 0;\n  for v in arr {\n    if v > max_value {\n      max_value = v;\n      max_index = i;\n    }\n    i += 1;\n  }\n  return max_index;\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n",
      "timestamp": 1664293282,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max_value`\n  --> /tmp/tmpwtej4ens.rs:16:7\n   |\n12 |   let max_value = -1;\n   |       ---------\n   |       |\n   |       first assignment to `max_value`\n   |       help: consider making this binding mutable: `mut max_value`\n...\n16 |       max_value = v;\n   |       ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `max_index`\n  --> /tmp/tmpwtej4ens.rs:17:7\n   |\n11 |   let max_index = -1;\n   |       ---------\n   |       |\n   |       first assignment to `max_index`\n   |       help: consider making this binding mutable: `mut max_index`\n...\n17 |       max_index = i;\n   |       ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `i`\n  --> /tmp/tmpwtej4ens.rs:19:5\n   |\n13 |   let i = 0;\n   |       -\n   |       |\n   |       first assignment to `i`\n   |       help: consider making this binding mutable: `mut i`\n...\n19 |     i += 1;\n   |     ^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 3 previous errors\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Create a function which returns the largest index of an element which\n/// is not greater than or equal to the element immediately preceding it. If\n/// no such element exists then return -1. The given vector will not contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>) -> isize {\n  let max_index = -1;\n  for i in arr {\n    if i > max_index {\n      max_index = i;\n    }\n  }\n  return max_index;\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n",
      "timestamp": 1664293282,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max_index`\n  --> /tmp/tmpkwi327od.rs:14:7\n   |\n11 |   let max_index = -1;\n   |       ---------\n   |       |\n   |       first assignment to `max_index`\n   |       help: consider making this binding mutable: `mut max_index`\n...\n14 |       max_index = i;\n   |       ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Create a function which returns the largest index of an element which\n/// is not greater than or equal to the element immediately preceding it. If\n/// no such element exists then return -1. The given vector will not contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>) -> isize {\n    let max_index = -1;\n    let max_value = -1;\n    for i in arr {\n        if max_value < i {\n            max_value = i;\n            max_index = i - 1;\n        }\n    }\n    return max_index;\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n",
      "timestamp": 1664293282,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max_value`\n  --> /tmp/tmpql19qvun.rs:15:13\n   |\n12 |     let max_value = -1;\n   |         ---------\n   |         |\n   |         first assignment to `max_value`\n   |         help: consider making this binding mutable: `mut max_value`\n...\n15 |             max_value = i;\n   |             ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `max_index`\n  --> /tmp/tmpql19qvun.rs:16:13\n   |\n11 |     let max_index = -1;\n   |         ---------\n   |         |\n   |         first assignment to `max_index`\n   |         help: consider making this binding mutable: `mut max_index`\n...\n16 |             max_index = i - 1;\n   |             ^^^^^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Create a function which returns the largest index of an element which\n/// is not greater than or equal to the element immediately preceding it. If\n/// no such element exists then return -1. The given vector will not contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>) -> isize {\n  let max_index = -1;\n  let max_value = -1;\n  for i in arr {\n    if i > max_value {\n      max_value = i;\n      max_index = i - 1;\n    }\n  }\n  return max_index;\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n",
      "timestamp": 1664293282,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max_value`\n  --> /tmp/tmpk6s8eeav.rs:15:7\n   |\n12 |   let max_value = -1;\n   |       ---------\n   |       |\n   |       first assignment to `max_value`\n   |       help: consider making this binding mutable: `mut max_value`\n...\n15 |       max_value = i;\n   |       ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `max_index`\n  --> /tmp/tmpk6s8eeav.rs:16:7\n   |\n11 |   let max_index = -1;\n   |       ---------\n   |       |\n   |       first assignment to `max_index`\n   |       help: consider making this binding mutable: `mut max_index`\n...\n16 |       max_index = i - 1;\n   |       ^^^^^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Create a function which returns the largest index of an element which\n/// is not greater than or equal to the element immediately preceding it. If\n/// no such element exists then return -1. The given vector will not contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>) -> isize {\n  let i = 0;\n  for i in arr.iter() {\n    if arr[i] > arr[i - 1] {\n      return i - 1;\n    }\n  }\n  return -1;\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n",
      "timestamp": 1664293282,
      "stdout": "",
      "stderr": "error[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmp3eikhltl.rs:13:8\n   |\n13 |     if arr[i] > arr[i - 1] {\n   |        ^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmp3eikhltl.rs:13:17\n   |\n13 |     if arr[i] > arr[i - 1] {\n   |                 ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Create a function which returns the largest index of an element which\n/// is not greater than or equal to the element immediately preceding it. If\n/// no such element exists then return -1. The given vector will not contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>) -> isize {\n  let max_index = -1;\n  let max_value = -1;\n  for i in arr {\n    if i > max_value {\n      max_index = i;\n      max_value = i;\n    }\n  }\n  return max_index;\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n",
      "timestamp": 1664293282,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max_index`\n  --> /tmp/tmpnfmbev2i.rs:15:7\n   |\n11 |   let max_index = -1;\n   |       ---------\n   |       |\n   |       first assignment to `max_index`\n   |       help: consider making this binding mutable: `mut max_index`\n...\n15 |       max_index = i;\n   |       ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `max_value`\n  --> /tmp/tmpnfmbev2i.rs:16:7\n   |\n12 |   let max_value = -1;\n   |       ---------\n   |       |\n   |       first assignment to `max_value`\n   |       help: consider making this binding mutable: `mut max_value`\n...\n16 |       max_value = i;\n   |       ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Create a function which returns the largest index of an element which\n/// is not greater than or equal to the element immediately preceding it. If\n/// no such element exists then return -1. The given vector will not contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>) -> isize {\n  let i = 0;\n  for i in arr.iter().next() {\n    if arr[i] > arr[i - 1] {\n      return i - 1;\n    }\n  }\n  return -1;\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n",
      "timestamp": 1664293282,
      "stdout": "",
      "stderr": "error[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmpknr__r3m.rs:13:8\n   |\n13 |     if arr[i] > arr[i - 1] {\n   |        ^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpknr__r3m.rs:13:17\n   |\n13 |     if arr[i] > arr[i - 1] {\n   |                 ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Create a function which returns the largest index of an element which\n/// is not greater than or equal to the element immediately preceding it. If\n/// no such element exists then return -1. The given vector will not contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>) -> isize {\n  let max_index = 0\n  let max_value = arr[0]\n  for i in arr {\n    if i > max_value {\n      max_index = i\n      max_value = i\n    }\n  }\n  if max_index == 0 {\n    return -1\n  }\n  return max_index\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n",
      "timestamp": 1664293282,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmpbqt6m493.rs:11:20\n   |\n11 |   let max_index = 0\n   |                    ^ help: add `;` here\n12 |   let max_value = arr[0]\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpbqt6m493.rs:12:25\n   |\n12 |   let max_value = arr[0]\n   |                         ^ help: add `;` here\n13 |   for i in arr {\n   |   --- unexpected token\n\nerror: expected `;`, found `max_value`\n  --> /tmp/tmpbqt6m493.rs:15:20\n   |\n15 |       max_index = i\n   |                    ^ help: add `;` here\n16 |       max_value = i\n   |       --------- unexpected token\n\nerror: aborting due to 3 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Create a function which returns the largest index of an element which\n/// is not greater than or equal to the element immediately preceding it. If\n/// no such element exists then return -1. The given vector will not contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>) -> isize {\n  let i = 0;\n  let j = arr.len - 1;\n  while (i < j) {\n    if (arr[i] <= arr[j]) {\n      i += 1;\n    } else {\n      j -= 1;\n    }\n  }\n  if (i == j) {\n    return -1;\n  } else {\n    return i;\n  }\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n",
      "timestamp": 1664293282,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpbuc7w09x.rs:13:9\n   |\n13 |   while (i < j) {\n   |         ^     ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -   while (i < j) {\n13 +   while i < j {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpbuc7w09x.rs:14:8\n   |\n14 |     if (arr[i] <= arr[j]) {\n   |        ^                ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (arr[i] <= arr[j]) {\n14 +     if arr[i] <= arr[j] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpbuc7w09x.rs:20:6\n   |\n20 |   if (i == j) {\n   |      ^      ^\n   |\nhelp: remove these parentheses\n   |\n20 -   if (i == j) {\n20 +   if i == j {\n   | \n\nerror[E0616]: field `len` of struct `Vec` is private\n  --> /tmp/tmpbuc7w09x.rs:12:15\n   |\n12 |   let j = arr.len - 1;\n   |               ^^^ private field\n   |\nhelp: a method `len` also exists, call it with parentheses\n   |\n12 |   let j = arr.len() - 1;\n   |                  ++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpbuc7w09x.rs:23:12\n   |\n10 | fn can_arrange(arr: Vec<isize>) -> isize {\n   |                                    ----- expected `isize` because of return type\n...\n23 |     return i;\n   |            ^ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the converted value doesn't fit\n   |\n23 |     return i.try_into().unwrap();\n   |             ++++++++++++++++++++\n\nerror: aborting due to 2 previous errors; 3 warnings emitted\n\nSome errors have detailed explanations: E0308, E0616.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Create a function which returns the largest index of an element which\n/// is not greater than or equal to the element immediately preceding it. If\n/// no such element exists then return -1. The given vector will not contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>) -> isize {\n  let max_index = -1;\n  let max_value = -1;\n  for i in arr {\n    if i > max_value {\n      max_value = i;\n      max_index = i - 1;\n    }\n  }\n  return max_index;\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n",
      "timestamp": 1664293282,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max_value`\n  --> /tmp/tmpk6s8eeav.rs:15:7\n   |\n12 |   let max_value = -1;\n   |       ---------\n   |       |\n   |       first assignment to `max_value`\n   |       help: consider making this binding mutable: `mut max_value`\n...\n15 |       max_value = i;\n   |       ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `max_index`\n  --> /tmp/tmpk6s8eeav.rs:16:7\n   |\n11 |   let max_index = -1;\n   |       ---------\n   |       |\n   |       first assignment to `max_index`\n   |       help: consider making this binding mutable: `mut max_index`\n...\n16 |       max_index = i - 1;\n   |       ^^^^^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Create a function which returns the largest index of an element which\n/// is not greater than or equal to the element immediately preceding it. If\n/// no such element exists then return -1. The given vector will not contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>) -> isize {\n  let i = 0;\n  for j in arr {\n    if j > i {\n      return i;\n    }\n    i = j;\n  }\n  return -1;\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n",
      "timestamp": 1664293282,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `i`\n  --> /tmp/tmpcbla90l_.rs:16:5\n   |\n11 |   let i = 0;\n   |       -\n   |       |\n   |       first assignment to `i`\n   |       help: consider making this binding mutable: `mut i`\n...\n16 |     i = j;\n   |     ^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Create a function which returns the largest index of an element which\n/// is not greater than or equal to the element immediately preceding it. If\n/// no such element exists then return -1. The given vector will not contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>) -> isize {\n  let max_index = -1;\n  let max_value = -1;\n  for i in arr {\n    if i > max_value {\n      max_index = i;\n      max_value = i;\n    }\n  }\n  return max_index;\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n",
      "timestamp": 1664293282,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max_index`\n  --> /tmp/tmpnfmbev2i.rs:15:7\n   |\n11 |   let max_index = -1;\n   |       ---------\n   |       |\n   |       first assignment to `max_index`\n   |       help: consider making this binding mutable: `mut max_index`\n...\n15 |       max_index = i;\n   |       ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `max_value`\n  --> /tmp/tmpnfmbev2i.rs:16:7\n   |\n12 |   let max_value = -1;\n   |       ---------\n   |       |\n   |       first assignment to `max_value`\n   |       help: consider making this binding mutable: `mut max_value`\n...\n16 |       max_value = i;\n   |       ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Create a function which returns the largest index of an element which\n/// is not greater than or equal to the element immediately preceding it. If\n/// no such element exists then return -1. The given vector will not contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>) -> isize {\n  let max_index = -1;\n  let max_value = -1;\n  for i in arr {\n    if i > max_value {\n      max_value = i;\n      max_index = i - 1;\n    }\n  }\n  return max_index;\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n",
      "timestamp": 1664293282,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max_value`\n  --> /tmp/tmpk6s8eeav.rs:15:7\n   |\n12 |   let max_value = -1;\n   |       ---------\n   |       |\n   |       first assignment to `max_value`\n   |       help: consider making this binding mutable: `mut max_value`\n...\n15 |       max_value = i;\n   |       ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `max_index`\n  --> /tmp/tmpk6s8eeav.rs:16:7\n   |\n11 |   let max_index = -1;\n   |       ---------\n   |       |\n   |       first assignment to `max_index`\n   |       help: consider making this binding mutable: `mut max_index`\n...\n16 |       max_index = i - 1;\n   |       ^^^^^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Create a function which returns the largest index of an element which\n/// is not greater than or equal to the element immediately preceding it. If\n/// no such element exists then return -1. The given vector will not contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>) -> isize {\n  let i = 0;\n  let j = arr.len - 1;\n  while (i < j) {\n    if (arr[i] <= arr[j]) {\n      i += 1;\n    } else {\n      j -= 1;\n    }\n  }\n  if (i == j) {\n    return -1;\n  } else {\n    return i;\n  }\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n",
      "timestamp": 1664293282,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpbuc7w09x.rs:13:9\n   |\n13 |   while (i < j) {\n   |         ^     ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -   while (i < j) {\n13 +   while i < j {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpbuc7w09x.rs:14:8\n   |\n14 |     if (arr[i] <= arr[j]) {\n   |        ^                ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (arr[i] <= arr[j]) {\n14 +     if arr[i] <= arr[j] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpbuc7w09x.rs:20:6\n   |\n20 |   if (i == j) {\n   |      ^      ^\n   |\nhelp: remove these parentheses\n   |\n20 -   if (i == j) {\n20 +   if i == j {\n   | \n\nerror[E0616]: field `len` of struct `Vec` is private\n  --> /tmp/tmpbuc7w09x.rs:12:15\n   |\n12 |   let j = arr.len - 1;\n   |               ^^^ private field\n   |\nhelp: a method `len` also exists, call it with parentheses\n   |\n12 |   let j = arr.len() - 1;\n   |                  ++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpbuc7w09x.rs:23:12\n   |\n10 | fn can_arrange(arr: Vec<isize>) -> isize {\n   |                                    ----- expected `isize` because of return type\n...\n23 |     return i;\n   |            ^ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the converted value doesn't fit\n   |\n23 |     return i.try_into().unwrap();\n   |             ++++++++++++++++++++\n\nerror: aborting due to 2 previous errors; 3 warnings emitted\n\nSome errors have detailed explanations: E0308, E0616.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Create a function which returns the largest index of an element which\n/// is not greater than or equal to the element immediately preceding it. If\n/// no such element exists then return -1. The given vector will not contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>) -> isize {\n  let max_index = -1;\n  let max_value = -1;\n  let min_value = -1;\n  let max_value_index = -1;\n  let min_value_index = -1;\n  for i in arr {\n    if i > max_value {\n      max_value = i;\n      max_value_index = i;\n    }\n    if i < min_value {\n      min_value = i;\n      min_value_index = i;\n    }\n  }\n  if max_value_index == min_value_index {\n    return max_value_index;\n  } else {\n    return -1;\n  }\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n",
      "timestamp": 1664293282,
      "stdout": "",
      "stderr": "warning: unused variable: `max_index`\n  --> /tmp/tmpns7ihzux.rs:11:7\n   |\n11 |   let max_index = -1;\n   |       ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_max_index`\n   |\n   = note: `#[warn(unused_variables)]` on by default\n\nerror[E0384]: cannot assign twice to immutable variable `max_value`\n  --> /tmp/tmpns7ihzux.rs:18:7\n   |\n12 |   let max_value = -1;\n   |       ---------\n   |       |\n   |       first assignment to `max_value`\n   |       help: consider making this binding mutable: `mut max_value`\n...\n18 |       max_value = i;\n   |       ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `max_value_index`\n  --> /tmp/tmpns7ihzux.rs:19:7\n   |\n14 |   let max_value_index = -1;\n   |       ---------------\n   |       |\n   |       first assignment to `max_value_index`\n   |       help: consider making this binding mutable: `mut max_value_index`\n...\n19 |       max_value_index = i;\n   |       ^^^^^^^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `min_value`\n  --> /tmp/tmpns7ihzux.rs:22:7\n   |\n13 |   let min_value = -1;\n   |       ---------\n   |       |\n   |       first assignment to `min_value`\n   |       help: consider making this binding mutable: `mut min_value`\n...\n22 |       min_value = i;\n   |       ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `min_value_index`\n  --> /tmp/tmpns7ihzux.rs:23:7\n   |\n15 |   let min_value_index = -1;\n   |       ---------------\n   |       |\n   |       first assignment to `min_value_index`\n   |       help: consider making this binding mutable: `mut min_value_index`\n...\n23 |       min_value_index = i;\n   |       ^^^^^^^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 4 previous errors; 1 warning emitted\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Create a function which returns the largest index of an element which\n/// is not greater than or equal to the element immediately preceding it. If\n/// no such element exists then return -1. The given vector will not contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>) -> isize {\n  let i = 0;\n  let j = arr.len - 1;\n  while (i < j) {\n    if (arr[i] < arr[j]) {\n      j -= 1;\n    } else {\n      i += 1;\n    }\n  }\n  if (i == j) {\n    return -1;\n  } else {\n    return i;\n  }\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n",
      "timestamp": 1664293282,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpkzzmcl12.rs:13:9\n   |\n13 |   while (i < j) {\n   |         ^     ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -   while (i < j) {\n13 +   while i < j {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpkzzmcl12.rs:14:8\n   |\n14 |     if (arr[i] < arr[j]) {\n   |        ^               ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (arr[i] < arr[j]) {\n14 +     if arr[i] < arr[j] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpkzzmcl12.rs:20:6\n   |\n20 |   if (i == j) {\n   |      ^      ^\n   |\nhelp: remove these parentheses\n   |\n20 -   if (i == j) {\n20 +   if i == j {\n   | \n\nerror[E0616]: field `len` of struct `Vec` is private\n  --> /tmp/tmpkzzmcl12.rs:12:15\n   |\n12 |   let j = arr.len - 1;\n   |               ^^^ private field\n   |\nhelp: a method `len` also exists, call it with parentheses\n   |\n12 |   let j = arr.len() - 1;\n   |                  ++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpkzzmcl12.rs:23:12\n   |\n10 | fn can_arrange(arr: Vec<isize>) -> isize {\n   |                                    ----- expected `isize` because of return type\n...\n23 |     return i;\n   |            ^ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the converted value doesn't fit\n   |\n23 |     return i.try_into().unwrap();\n   |             ++++++++++++++++++++\n\nerror: aborting due to 2 previous errors; 3 warnings emitted\n\nSome errors have detailed explanations: E0308, E0616.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Create a function which returns the largest index of an element which\n/// is not greater than or equal to the element immediately preceding it. If\n/// no such element exists then return -1. The given vector will not contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>) -> isize {\n  let i = 0;\n  for i in arr.iter() {\n    if arr[i] > arr[i - 1] {\n      return i - 1;\n    }\n  }\n  return -1;\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n",
      "timestamp": 1664293282,
      "stdout": "",
      "stderr": "error[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmp3eikhltl.rs:13:8\n   |\n13 |     if arr[i] > arr[i - 1] {\n   |        ^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmp3eikhltl.rs:13:17\n   |\n13 |     if arr[i] > arr[i - 1] {\n   |                 ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Create a function which returns the largest index of an element which\n/// is not greater than or equal to the element immediately preceding it. If\n/// no such element exists then return -1. The given vector will not contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>) -> isize {\n  let max_index = 0\n  let max_value = arr[0]\n  for i in arr {\n    if i > max_value {\n      max_value = i\n      max_index = i\n    }\n  }\n  return max_index\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n",
      "timestamp": 1664293282,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmphvlnfd_b.rs:11:20\n   |\n11 |   let max_index = 0\n   |                    ^ help: add `;` here\n12 |   let max_value = arr[0]\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmphvlnfd_b.rs:12:25\n   |\n12 |   let max_value = arr[0]\n   |                         ^ help: add `;` here\n13 |   for i in arr {\n   |   --- unexpected token\n\nerror: expected `;`, found `max_index`\n  --> /tmp/tmphvlnfd_b.rs:15:20\n   |\n15 |       max_value = i\n   |                    ^ help: add `;` here\n16 |       max_index = i\n   |       --------- unexpected token\n\nerror: aborting due to 3 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Create a function which returns the largest index of an element which\n/// is not greater than or equal to the element immediately preceding it. If\n/// no such element exists then return -1. The given vector will not contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>) -> isize {\n  let max_index = -1;\n  let max_value = -1;\n  let max_value_index = -1;\n  for i in arr {\n    if max_value < i {\n      max_value = i;\n      max_value_index = i;\n    }\n    if max_index < i {\n      max_index = i;\n    }\n  }\n  if max_value == max_value_index {\n    return -1\n  } else {\n    return max_index\n  }\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n",
      "timestamp": 1664293282,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max_value`\n  --> /tmp/tmp9agj1hnv.rs:16:7\n   |\n12 |   let max_value = -1;\n   |       ---------\n   |       |\n   |       first assignment to `max_value`\n   |       help: consider making this binding mutable: `mut max_value`\n...\n16 |       max_value = i;\n   |       ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `max_value_index`\n  --> /tmp/tmp9agj1hnv.rs:17:7\n   |\n13 |   let max_value_index = -1;\n   |       ---------------\n   |       |\n   |       first assignment to `max_value_index`\n   |       help: consider making this binding mutable: `mut max_value_index`\n...\n17 |       max_value_index = i;\n   |       ^^^^^^^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `max_index`\n  --> /tmp/tmp9agj1hnv.rs:20:7\n   |\n11 |   let max_index = -1;\n   |       ---------\n   |       |\n   |       first assignment to `max_index`\n   |       help: consider making this binding mutable: `mut max_index`\n...\n20 |       max_index = i;\n   |       ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 3 previous errors\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Create a function which returns the largest index of an element which\n/// is not greater than or equal to the element immediately preceding it. If\n/// no such element exists then return -1. The given vector will not contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>) -> isize {\n    let max_index = -1;\n    let max_value = -1;\n    for i in arr {\n        if i > max_value {\n            max_value = i;\n            max_index = i - 1;\n        }\n    }\n    return max_index;\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n",
      "timestamp": 1664293282,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max_value`\n  --> /tmp/tmpn_avckop.rs:15:13\n   |\n12 |     let max_value = -1;\n   |         ---------\n   |         |\n   |         first assignment to `max_value`\n   |         help: consider making this binding mutable: `mut max_value`\n...\n15 |             max_value = i;\n   |             ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `max_index`\n  --> /tmp/tmpn_avckop.rs:16:13\n   |\n11 |     let max_index = -1;\n   |         ---------\n   |         |\n   |         first assignment to `max_index`\n   |         help: consider making this binding mutable: `mut max_index`\n...\n16 |             max_index = i - 1;\n   |             ^^^^^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Create a function which returns the largest index of an element which\n/// is not greater than or equal to the element immediately preceding it. If\n/// no such element exists then return -1. The given vector will not contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>) -> isize {\n  let i = 0;\n  for i in arr.iter() {\n    if arr[i] > arr[i - 1] {\n      return i - 1;\n    }\n  }\n  return -1;\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n",
      "timestamp": 1664293282,
      "stdout": "",
      "stderr": "error[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmp3eikhltl.rs:13:8\n   |\n13 |     if arr[i] > arr[i - 1] {\n   |        ^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmp3eikhltl.rs:13:17\n   |\n13 |     if arr[i] > arr[i - 1] {\n   |                 ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Create a function which returns the largest index of an element which\n/// is not greater than or equal to the element immediately preceding it. If\n/// no such element exists then return -1. The given vector will not contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>) -> isize {\n  let max_index = -1;\n  let max_value = -1;\n  let max_value_index = -1;\n  for i in arr {\n    if max_value < i {\n      max_value = i;\n      max_value_index = i;\n    }\n    if max_value >= i {\n      max_index = i - 1;\n      break;\n    }\n  }\n  return max_index;\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n",
      "timestamp": 1664293282,
      "stdout": "",
      "stderr": "warning: variable `max_value_index` is assigned to, but never used\n  --> /tmp/tmpefk3mxcd.rs:13:7\n   |\n13 |   let max_value_index = -1;\n   |       ^^^^^^^^^^^^^^^\n   |\n   = note: `#[warn(unused_variables)]` on by default\n   = note: consider using `_max_value_index` instead\n\nwarning: value assigned to `max_value_index` is never read\n  --> /tmp/tmpefk3mxcd.rs:17:7\n   |\n17 |       max_value_index = i;\n   |       ^^^^^^^^^^^^^^^\n   |\n   = note: `#[warn(unused_assignments)]` on by default\n   = help: maybe it is overwritten before being read?\n\nerror[E0384]: cannot assign twice to immutable variable `max_value`\n  --> /tmp/tmpefk3mxcd.rs:16:7\n   |\n12 |   let max_value = -1;\n   |       ---------\n   |       |\n   |       first assignment to `max_value`\n   |       help: consider making this binding mutable: `mut max_value`\n...\n16 |       max_value = i;\n   |       ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `max_value_index`\n  --> /tmp/tmpefk3mxcd.rs:17:7\n   |\n13 |   let max_value_index = -1;\n   |       ---------------\n   |       |\n   |       first assignment to `max_value_index`\n   |       help: consider making this binding mutable: `mut max_value_index`\n...\n17 |       max_value_index = i;\n   |       ^^^^^^^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `max_index`\n  --> /tmp/tmpefk3mxcd.rs:20:7\n   |\n11 |   let max_index = -1;\n   |       ---------\n   |       |\n   |       first assignment to `max_index`\n   |       help: consider making this binding mutable: `mut max_index`\n...\n20 |       max_index = i - 1;\n   |       ^^^^^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 3 previous errors; 2 warnings emitted\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Create a function which returns the largest index of an element which\n/// is not greater than or equal to the element immediately preceding it. If\n/// no such element exists then return -1. The given vector will not contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>) -> isize {\n  let max_index = -1;\n  let max_value = -1;\n  let max_value_index = -1;\n  for i in arr {\n    if max_value < i {\n      max_value = i;\n      max_value_index = i;\n    }\n    if max_index < i {\n      max_index = i;\n    }\n  }\n  if max_value == max_value_index {\n    return max_index;\n  } else {\n    return -1;\n  }\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n",
      "timestamp": 1664293282,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max_value`\n  --> /tmp/tmpe4dc_8tu.rs:16:7\n   |\n12 |   let max_value = -1;\n   |       ---------\n   |       |\n   |       first assignment to `max_value`\n   |       help: consider making this binding mutable: `mut max_value`\n...\n16 |       max_value = i;\n   |       ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `max_value_index`\n  --> /tmp/tmpe4dc_8tu.rs:17:7\n   |\n13 |   let max_value_index = -1;\n   |       ---------------\n   |       |\n   |       first assignment to `max_value_index`\n   |       help: consider making this binding mutable: `mut max_value_index`\n...\n17 |       max_value_index = i;\n   |       ^^^^^^^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `max_index`\n  --> /tmp/tmpe4dc_8tu.rs:20:7\n   |\n11 |   let max_index = -1;\n   |       ---------\n   |       |\n   |       first assignment to `max_index`\n   |       help: consider making this binding mutable: `mut max_index`\n...\n20 |       max_index = i;\n   |       ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 3 previous errors\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Create a function which returns the largest index of an element which\n/// is not greater than or equal to the element immediately preceding it. If\n/// no such element exists then return -1. The given vector will not contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>) -> isize {\n  let max_index = -1;\n  for i in arr {\n    if i > max_index {\n      max_index = i;\n    }\n  }\n  return max_index;\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n",
      "timestamp": 1664293282,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max_index`\n  --> /tmp/tmpkwi327od.rs:14:7\n   |\n11 |   let max_index = -1;\n   |       ---------\n   |       |\n   |       first assignment to `max_index`\n   |       help: consider making this binding mutable: `mut max_index`\n...\n14 |       max_index = i;\n   |       ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Create a function which returns the largest index of an element which\n/// is not greater than or equal to the element immediately preceding it. If\n/// no such element exists then return -1. The given vector will not contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>) -> isize {\n    let max_index = -1;\n    for i in arr {\n        if i > max_index {\n            max_index = i;\n        }\n    }\n    return max_index;\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n",
      "timestamp": 1664293282,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max_index`\n  --> /tmp/tmpp0b3m15z.rs:14:13\n   |\n11 |     let max_index = -1;\n   |         ---------\n   |         |\n   |         first assignment to `max_index`\n   |         help: consider making this binding mutable: `mut max_index`\n...\n14 |             max_index = i;\n   |             ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Create a function which returns the largest index of an element which\n/// is not greater than or equal to the element immediately preceding it. If\n/// no such element exists then return -1. The given vector will not contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>) -> isize {\n  let max_index = -1;\n  let max_value = -1;\n  let max_value_index = -1;\n  let i = 0;\n  for i in arr {\n    if max_value < arr[i] {\n      max_value = arr[i];\n      max_value_index = i;\n    }\n  }\n  if max_value_index == -1 {\n    return -1;\n  }\n  for i in arr {\n    if i != max_value_index {\n      if arr[i] >= max_value {\n        max_index = i;\n        break;\n      }\n    }\n  }\n  return max_index;\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n",
      "timestamp": 1664293282,
      "stdout": "",
      "stderr": "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpw0ddx_ex.rs:16:20\n   |\n16 |     if max_value < arr[i] {\n   |                    ^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpw0ddx_ex.rs:17:19\n   |\n17 |       max_value = arr[i];\n   |                   ^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpw0ddx_ex.rs:26:10\n   |\n26 |       if arr[i] >= max_value {\n   |          ^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\nerror: aborting due to 3 previous errors\n\nFor more information about this error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Create a function which returns the largest index of an element which\n/// is not greater than or equal to the element immediately preceding it. If\n/// no such element exists then return -1. The given vector will not contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>) -> isize {\n  let max_index = -1;\n  for i in arr {\n    if i > max_index {\n      max_index = i;\n    }\n  }\n  return max_index;\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n",
      "timestamp": 1664293282,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max_index`\n  --> /tmp/tmpkwi327od.rs:14:7\n   |\n11 |   let max_index = -1;\n   |       ---------\n   |       |\n   |       first assignment to `max_index`\n   |       help: consider making this binding mutable: `mut max_index`\n...\n14 |       max_index = i;\n   |       ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Create a function which returns the largest index of an element which\n/// is not greater than or equal to the element immediately preceding it. If\n/// no such element exists then return -1. The given vector will not contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>) -> isize {\n  let i = 0;\n  let j = arr.len - 1;\n  while (i < j) {\n    if (arr[i] < arr[j]) {\n      j -= 1;\n    } else {\n      i += 1;\n    }\n  }\n  if (i == j) {\n    return -1;\n  } else {\n    return i;\n  }\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n",
      "timestamp": 1664293282,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpkzzmcl12.rs:13:9\n   |\n13 |   while (i < j) {\n   |         ^     ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -   while (i < j) {\n13 +   while i < j {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpkzzmcl12.rs:14:8\n   |\n14 |     if (arr[i] < arr[j]) {\n   |        ^               ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (arr[i] < arr[j]) {\n14 +     if arr[i] < arr[j] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpkzzmcl12.rs:20:6\n   |\n20 |   if (i == j) {\n   |      ^      ^\n   |\nhelp: remove these parentheses\n   |\n20 -   if (i == j) {\n20 +   if i == j {\n   | \n\nerror[E0616]: field `len` of struct `Vec` is private\n  --> /tmp/tmpkzzmcl12.rs:12:15\n   |\n12 |   let j = arr.len - 1;\n   |               ^^^ private field\n   |\nhelp: a method `len` also exists, call it with parentheses\n   |\n12 |   let j = arr.len() - 1;\n   |                  ++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpkzzmcl12.rs:23:12\n   |\n10 | fn can_arrange(arr: Vec<isize>) -> isize {\n   |                                    ----- expected `isize` because of return type\n...\n23 |     return i;\n   |            ^ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the converted value doesn't fit\n   |\n23 |     return i.try_into().unwrap();\n   |             ++++++++++++++++++++\n\nerror: aborting due to 2 previous errors; 3 warnings emitted\n\nSome errors have detailed explanations: E0308, E0616.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Create a function which returns the largest index of an element which\n/// is not greater than or equal to the element immediately preceding it. If\n/// no such element exists then return -1. The given vector will not contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>) -> isize {\n  let max_index = -1;\n  let max_value = -1;\n  for i in arr {\n    if max_value < i {\n      max_value = i;\n      max_index = i - 1;\n    }\n  }\n  return max_index;\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n",
      "timestamp": 1664293282,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max_value`\n  --> /tmp/tmp79cu3cor.rs:15:7\n   |\n12 |   let max_value = -1;\n   |       ---------\n   |       |\n   |       first assignment to `max_value`\n   |       help: consider making this binding mutable: `mut max_value`\n...\n15 |       max_value = i;\n   |       ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `max_index`\n  --> /tmp/tmp79cu3cor.rs:16:7\n   |\n11 |   let max_index = -1;\n   |       ---------\n   |       |\n   |       first assignment to `max_index`\n   |       help: consider making this binding mutable: `mut max_index`\n...\n16 |       max_index = i - 1;\n   |       ^^^^^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Create a function which returns the largest index of an element which\n/// is not greater than or equal to the element immediately preceding it. If\n/// no such element exists then return -1. The given vector will not contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>) -> isize {\n  let max_index = -1;\n  let max_value = -1;\n  for i in arr {\n    if i > max_value {\n      max_value = i;\n      max_index = i - 1;\n    }\n  }\n  return max_index;\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n",
      "timestamp": 1664293282,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max_value`\n  --> /tmp/tmpk6s8eeav.rs:15:7\n   |\n12 |   let max_value = -1;\n   |       ---------\n   |       |\n   |       first assignment to `max_value`\n   |       help: consider making this binding mutable: `mut max_value`\n...\n15 |       max_value = i;\n   |       ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `max_index`\n  --> /tmp/tmpk6s8eeav.rs:16:7\n   |\n11 |   let max_index = -1;\n   |       ---------\n   |       |\n   |       first assignment to `max_index`\n   |       help: consider making this binding mutable: `mut max_index`\n...\n16 |       max_index = i - 1;\n   |       ^^^^^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Create a function which returns the largest index of an element which\n/// is not greater than or equal to the element immediately preceding it. If\n/// no such element exists then return -1. The given vector will not contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>) -> isize {\n  let i = 0;\n  for i in arr.iter().next() {\n    if arr[i] > arr[i - 1] {\n      return i - 1;\n    }\n  }\n  return -1;\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n",
      "timestamp": 1664293282,
      "stdout": "",
      "stderr": "error[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmpknr__r3m.rs:13:8\n   |\n13 |     if arr[i] > arr[i - 1] {\n   |        ^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpknr__r3m.rs:13:17\n   |\n13 |     if arr[i] > arr[i - 1] {\n   |                 ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Create a function which returns the largest index of an element which\n/// is not greater than or equal to the element immediately preceding it. If\n/// no such element exists then return -1. The given vector will not contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>) -> isize {\n  let max_index = -1;\n  for i in arr {\n    if i > max_index {\n      max_index = i;\n    }\n  }\n  return max_index;\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n",
      "timestamp": 1664293282,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max_index`\n  --> /tmp/tmpkwi327od.rs:14:7\n   |\n11 |   let max_index = -1;\n   |       ---------\n   |       |\n   |       first assignment to `max_index`\n   |       help: consider making this binding mutable: `mut max_index`\n...\n14 |       max_index = i;\n   |       ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Create a function which returns the largest index of an element which\n/// is not greater than or equal to the element immediately preceding it. If\n/// no such element exists then return -1. The given vector will not contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>) -> isize {\n  let i = 0;\n  for i in arr.iter() {\n    if i <= arr.get(i - 1) {\n      break;\n    }\n  }\n  if i == arr.len() {\n    return -1;\n  }\n  return i;\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n",
      "timestamp": 1664293282,
      "stdout": "",
      "stderr": "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n   --> /tmp/tmp8yn6xwvf.rs:13:21\n    |\n13  |     if i <= arr.get(i - 1) {\n    |                 --- ^^^^^ slice indices are of type `usize` or ranges of `usize`\n    |                 |\n    |                 required by a bound introduced by this call\n    |\n    = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n    = help: the trait `SliceIndex<[T]>` is implemented for `usize`\nnote: required by a bound in `core::slice::<impl [T]>::get`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp8yn6xwvf.rs:13:13\n   |\n13 |     if i <= arr.get(i - 1) {\n   |             ^^^^^^^^^^^^^^ expected `&isize`, found enum `Option`\n   |\n   = note: expected reference `&isize`\n                   found enum `Option<&_>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp8yn6xwvf.rs:20:10\n   |\n10 | fn can_arrange(arr: Vec<isize>) -> isize {\n   |                                    ----- expected `isize` because of return type\n...\n20 |   return i;\n   |          ^ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the converted value doesn't fit\n   |\n20 |   return i.try_into().unwrap();\n   |           ++++++++++++++++++++\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Create a function which returns the largest index of an element which\n/// is not greater than or equal to the element immediately preceding it. If\n/// no such element exists then return -1. The given vector will not contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>) -> isize {\n  let i = 0;\n  for i in arr.iter() {\n    if arr[i] > arr[i - 1] {\n      return i - 1;\n    }\n  }\n  return -1;\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n",
      "timestamp": 1664293282,
      "stdout": "",
      "stderr": "error[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmp3eikhltl.rs:13:8\n   |\n13 |     if arr[i] > arr[i - 1] {\n   |        ^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmp3eikhltl.rs:13:17\n   |\n13 |     if arr[i] > arr[i - 1] {\n   |                 ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Create a function which returns the largest index of an element which\n/// is not greater than or equal to the element immediately preceding it. If\n/// no such element exists then return -1. The given vector will not contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>) -> isize {\n  let max_index = -1;\n  let max_value = -1;\n  for i in arr {\n    if i > max_value {\n      max_value = i;\n      max_index = i - 1;\n    }\n  }\n  return max_index;\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n",
      "timestamp": 1664293282,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max_value`\n  --> /tmp/tmpk6s8eeav.rs:15:7\n   |\n12 |   let max_value = -1;\n   |       ---------\n   |       |\n   |       first assignment to `max_value`\n   |       help: consider making this binding mutable: `mut max_value`\n...\n15 |       max_value = i;\n   |       ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `max_index`\n  --> /tmp/tmpk6s8eeav.rs:16:7\n   |\n11 |   let max_index = -1;\n   |       ---------\n   |       |\n   |       first assignment to `max_index`\n   |       help: consider making this binding mutable: `mut max_index`\n...\n16 |       max_index = i - 1;\n   |       ^^^^^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Create a function which returns the largest index of an element which\n/// is not greater than or equal to the element immediately preceding it. If\n/// no such element exists then return -1. The given vector will not contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>) -> isize {\n  let max_index = -1;\n  let max_value = -1;\n  for i in arr {\n    if i > max_value {\n      max_value = i;\n      max_index = i - 1;\n    }\n  }\n  return max_index;\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n",
      "timestamp": 1664293282,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max_value`\n  --> /tmp/tmpk6s8eeav.rs:15:7\n   |\n12 |   let max_value = -1;\n   |       ---------\n   |       |\n   |       first assignment to `max_value`\n   |       help: consider making this binding mutable: `mut max_value`\n...\n15 |       max_value = i;\n   |       ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `max_index`\n  --> /tmp/tmpk6s8eeav.rs:16:7\n   |\n11 |   let max_index = -1;\n   |       ---------\n   |       |\n   |       first assignment to `max_index`\n   |       help: consider making this binding mutable: `mut max_index`\n...\n16 |       max_index = i - 1;\n   |       ^^^^^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Create a function which returns the largest index of an element which\n/// is not greater than or equal to the element immediately preceding it. If\n/// no such element exists then return -1. The given vector will not contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>) -> isize {\n  let max_index = -1;\n  for i in arr {\n    if i > max_index {\n      max_index = i;\n    }\n  }\n  return max_index;\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n",
      "timestamp": 1664293282,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max_index`\n  --> /tmp/tmpkwi327od.rs:14:7\n   |\n11 |   let max_index = -1;\n   |       ---------\n   |       |\n   |       first assignment to `max_index`\n   |       help: consider making this binding mutable: `mut max_index`\n...\n14 |       max_index = i;\n   |       ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Create a function which returns the largest index of an element which\n/// is not greater than or equal to the element immediately preceding it. If\n/// no such element exists then return -1. The given vector will not contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>) -> isize {\n  let max_index = 0\n  let max_value = arr[0]\n  for i in arr {\n    if i > max_value {\n      max_value = i\n      max_index = i\n    }\n  }\n  return max_index\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n",
      "timestamp": 1664293282,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmphvlnfd_b.rs:11:20\n   |\n11 |   let max_index = 0\n   |                    ^ help: add `;` here\n12 |   let max_value = arr[0]\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmphvlnfd_b.rs:12:25\n   |\n12 |   let max_value = arr[0]\n   |                         ^ help: add `;` here\n13 |   for i in arr {\n   |   --- unexpected token\n\nerror: expected `;`, found `max_index`\n  --> /tmp/tmphvlnfd_b.rs:15:20\n   |\n15 |       max_value = i\n   |                    ^ help: add `;` here\n16 |       max_index = i\n   |       --------- unexpected token\n\nerror: aborting due to 3 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Create a function which returns the largest index of an element which\n/// is not greater than or equal to the element immediately preceding it. If\n/// no such element exists then return -1. The given vector will not contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>) -> isize {\n    let max_index = -1;\n    for i in arr {\n        if i > max_index {\n            max_index = i;\n        }\n    }\n    return max_index;\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n",
      "timestamp": 1664293282,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max_index`\n  --> /tmp/tmpp0b3m15z.rs:14:13\n   |\n11 |     let max_index = -1;\n   |         ---------\n   |         |\n   |         first assignment to `max_index`\n   |         help: consider making this binding mutable: `mut max_index`\n...\n14 |             max_index = i;\n   |             ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Create a function which returns the largest index of an element which\n/// is not greater than or equal to the element immediately preceding it. If\n/// no such element exists then return -1. The given vector will not contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>) -> isize {\n  let max_index = 0\n  let max_value = arr[0]\n  for i in arr {\n    if i > max_value {\n      max_value = i\n      max_index = i\n    }\n  }\n  if max_value == arr[max_index] {\n    return -1\n  }\n  return max_index\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n",
      "timestamp": 1664293282,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmpfik5zjyt.rs:11:20\n   |\n11 |   let max_index = 0\n   |                    ^ help: add `;` here\n12 |   let max_value = arr[0]\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpfik5zjyt.rs:12:25\n   |\n12 |   let max_value = arr[0]\n   |                         ^ help: add `;` here\n13 |   for i in arr {\n   |   --- unexpected token\n\nerror: expected `;`, found `max_index`\n  --> /tmp/tmpfik5zjyt.rs:15:20\n   |\n15 |       max_value = i\n   |                    ^ help: add `;` here\n16 |       max_index = i\n   |       --------- unexpected token\n\nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpfik5zjyt.rs:19:19\n   |\n19 |   if max_value == arr[max_index] {\n   |                   ^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\nerror: aborting due to 4 previous errors\n\nFor more information about this error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Create a function which returns the largest index of an element which\n/// is not greater than or equal to the element immediately preceding it. If\n/// no such element exists then return -1. The given vector will not contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>) -> isize {\n  let max_index = 0\n  let max_value = arr[0]\n  for i in arr {\n    if i > max_value {\n      max_value = i\n      max_index = i\n    }\n  }\n  return max_index\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n",
      "timestamp": 1664293282,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmphvlnfd_b.rs:11:20\n   |\n11 |   let max_index = 0\n   |                    ^ help: add `;` here\n12 |   let max_value = arr[0]\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmphvlnfd_b.rs:12:25\n   |\n12 |   let max_value = arr[0]\n   |                         ^ help: add `;` here\n13 |   for i in arr {\n   |   --- unexpected token\n\nerror: expected `;`, found `max_index`\n  --> /tmp/tmphvlnfd_b.rs:15:20\n   |\n15 |       max_value = i\n   |                    ^ help: add `;` here\n16 |       max_index = i\n   |       --------- unexpected token\n\nerror: aborting due to 3 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Create a function which returns the largest index of an element which\n/// is not greater than or equal to the element immediately preceding it. If\n/// no such element exists then return -1. The given vector will not contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>) -> isize {\n  let max_index = -1;\n  let max_value = -1;\n  let max_value_index = -1;\n  for i in arr {\n    if i > max_value {\n      max_value = i;\n      max_value_index = i;\n    }\n    if i >= max_value {\n      max_index = i;\n    }\n  }\n  if max_index == -1 {\n    return -1;\n  }\n  return max_index;\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n",
      "timestamp": 1664293282,
      "stdout": "",
      "stderr": "warning: variable `max_value_index` is assigned to, but never used\n  --> /tmp/tmpuqhhpi0x.rs:13:7\n   |\n13 |   let max_value_index = -1;\n   |       ^^^^^^^^^^^^^^^\n   |\n   = note: `#[warn(unused_variables)]` on by default\n   = note: consider using `_max_value_index` instead\n\nwarning: value assigned to `max_value_index` is never read\n  --> /tmp/tmpuqhhpi0x.rs:17:7\n   |\n17 |       max_value_index = i;\n   |       ^^^^^^^^^^^^^^^\n   |\n   = note: `#[warn(unused_assignments)]` on by default\n   = help: maybe it is overwritten before being read?\n\nerror[E0384]: cannot assign twice to immutable variable `max_value`\n  --> /tmp/tmpuqhhpi0x.rs:16:7\n   |\n12 |   let max_value = -1;\n   |       ---------\n   |       |\n   |       first assignment to `max_value`\n   |       help: consider making this binding mutable: `mut max_value`\n...\n16 |       max_value = i;\n   |       ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `max_value_index`\n  --> /tmp/tmpuqhhpi0x.rs:17:7\n   |\n13 |   let max_value_index = -1;\n   |       ---------------\n   |       |\n   |       first assignment to `max_value_index`\n   |       help: consider making this binding mutable: `mut max_value_index`\n...\n17 |       max_value_index = i;\n   |       ^^^^^^^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `max_index`\n  --> /tmp/tmpuqhhpi0x.rs:20:7\n   |\n11 |   let max_index = -1;\n   |       ---------\n   |       |\n   |       first assignment to `max_index`\n   |       help: consider making this binding mutable: `mut max_index`\n...\n20 |       max_index = i;\n   |       ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 3 previous errors; 2 warnings emitted\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Create a function which returns the largest index of an element which\n/// is not greater than or equal to the element immediately preceding it. If\n/// no such element exists then return -1. The given vector will not contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>) -> isize {\n  let max_index = -1;\n  let max_value = -1;\n  for i in arr {\n    if i > max_value {\n      max_value = i;\n      max_index = i - 1;\n    }\n  }\n  return max_index;\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n",
      "timestamp": 1664293282,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max_value`\n  --> /tmp/tmpk6s8eeav.rs:15:7\n   |\n12 |   let max_value = -1;\n   |       ---------\n   |       |\n   |       first assignment to `max_value`\n   |       help: consider making this binding mutable: `mut max_value`\n...\n15 |       max_value = i;\n   |       ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `max_index`\n  --> /tmp/tmpk6s8eeav.rs:16:7\n   |\n11 |   let max_index = -1;\n   |       ---------\n   |       |\n   |       first assignment to `max_index`\n   |       help: consider making this binding mutable: `mut max_index`\n...\n16 |       max_index = i - 1;\n   |       ^^^^^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Create a function which returns the largest index of an element which\n/// is not greater than or equal to the element immediately preceding it. If\n/// no such element exists then return -1. The given vector will not contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>) -> isize {\n  let max_index = -1;\n  let max_value = -1;\n  for i in arr {\n    if i > max_value {\n      max_value = i;\n      max_index = i;\n    }\n  }\n  return max_index;\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n",
      "timestamp": 1664293282,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max_value`\n  --> /tmp/tmpu808xrtu.rs:15:7\n   |\n12 |   let max_value = -1;\n   |       ---------\n   |       |\n   |       first assignment to `max_value`\n   |       help: consider making this binding mutable: `mut max_value`\n...\n15 |       max_value = i;\n   |       ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `max_index`\n  --> /tmp/tmpu808xrtu.rs:16:7\n   |\n11 |   let max_index = -1;\n   |       ---------\n   |       |\n   |       first assignment to `max_index`\n   |       help: consider making this binding mutable: `mut max_index`\n...\n16 |       max_index = i;\n   |       ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Create a function which returns the largest index of an element which\n/// is not greater than or equal to the element immediately preceding it. If\n/// no such element exists then return -1. The given vector will not contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>) -> isize {\n  let max_index = -1;\n  let max_value = -1;\n  let max_value_index = -1;\n  for i in arr {\n    if max_value < i {\n      max_value = i;\n      max_value_index = i;\n    }\n    if max_value == i {\n      max_index = max_value_index;\n    }\n  }\n  max_index\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n",
      "timestamp": 1664293282,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max_value`\n  --> /tmp/tmp67h_r1wr.rs:16:7\n   |\n12 |   let max_value = -1;\n   |       ---------\n   |       |\n   |       first assignment to `max_value`\n   |       help: consider making this binding mutable: `mut max_value`\n...\n16 |       max_value = i;\n   |       ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `max_value_index`\n  --> /tmp/tmp67h_r1wr.rs:17:7\n   |\n13 |   let max_value_index = -1;\n   |       ---------------\n   |       |\n   |       first assignment to `max_value_index`\n   |       help: consider making this binding mutable: `mut max_value_index`\n...\n17 |       max_value_index = i;\n   |       ^^^^^^^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `max_index`\n  --> /tmp/tmp67h_r1wr.rs:20:7\n   |\n11 |   let max_index = -1;\n   |       ---------\n   |       |\n   |       first assignment to `max_index`\n   |       help: consider making this binding mutable: `mut max_index`\n...\n20 |       max_index = max_value_index;\n   |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 3 previous errors\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Create a function which returns the largest index of an element which\n/// is not greater than or equal to the element immediately preceding it. If\n/// no such element exists then return -1. The given vector will not contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>) -> isize {\n  let max_index = 0\n  for i in arr {\n    if i > max_index {\n      max_index = i\n    }\n  }\n  if max_index == 0 {\n    return -1\n  }\n  return max_index\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n",
      "timestamp": 1664293282,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `for`\n  --> /tmp/tmpudycxnrf.rs:11:20\n   |\n11 |   let max_index = 0\n   |                    ^ help: add `;` here\n12 |   for i in arr {\n   |   --- unexpected token\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Create a function which returns the largest index of an element which\n/// is not greater than or equal to the element immediately preceding it. If\n/// no such element exists then return -1. The given vector will not contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>) -> isize {\n  let max_index = -1;\n  for i in arr {\n    if i > max_index {\n      max_index = i;\n    }\n  }\n  return max_index;\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n",
      "timestamp": 1664293282,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max_index`\n  --> /tmp/tmpkwi327od.rs:14:7\n   |\n11 |   let max_index = -1;\n   |       ---------\n   |       |\n   |       first assignment to `max_index`\n   |       help: consider making this binding mutable: `mut max_index`\n...\n14 |       max_index = i;\n   |       ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Create a function which returns the largest index of an element which\n/// is not greater than or equal to the element immediately preceding it. If\n/// no such element exists then return -1. The given vector will not contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>) -> isize {\n  let i = 0;\n  let j = arr.len() - 1;\n  while (i < j) {\n    if (arr[i] < arr[j]) {\n      j -= 1;\n    } else {\n      return i;\n    }\n  }\n  return -1;\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n",
      "timestamp": 1664293282,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmprrwh5kur.rs:13:9\n   |\n13 |   while (i < j) {\n   |         ^     ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -   while (i < j) {\n13 +   while i < j {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmprrwh5kur.rs:14:8\n   |\n14 |     if (arr[i] < arr[j]) {\n   |        ^               ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (arr[i] < arr[j]) {\n14 +     if arr[i] < arr[j] {\n   | \n\nerror[E0308]: mismatched types\n  --> /tmp/tmprrwh5kur.rs:17:14\n   |\n17 |       return i;\n   |              ^ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the converted value doesn't fit\n   |\n17 |       return i.try_into().unwrap();\n   |               ++++++++++++++++++++\n\nerror: aborting due to previous error; 2 warnings emitted\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Create a function which returns the largest index of an element which\n/// is not greater than or equal to the element immediately preceding it. If\n/// no such element exists then return -1. The given vector will not contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>) -> isize {\n  let i = 0;\n  for i in 0..arr.len() - 1 {\n    if arr[i] > arr[i + 1] {\n      return i;\n    }\n  }\n  return -1;\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n",
      "timestamp": 1664293282,
      "stdout": "",
      "stderr": "error[E0308]: mismatched types\n  --> /tmp/tmpm5zko4u3.rs:14:14\n   |\n14 |       return i;\n   |              ^ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the converted value doesn't fit\n   |\n14 |       return i.try_into().unwrap();\n   |               ++++++++++++++++++++\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Create a function which returns the largest index of an element which\n/// is not greater than or equal to the element immediately preceding it. If\n/// no such element exists then return -1. The given vector will not contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>) -> isize {\n    let max_index = -1;\n    for i in arr {\n        if i > max_index {\n            max_index = i;\n        }\n    }\n    return max_index;\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n",
      "timestamp": 1664293282,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max_index`\n  --> /tmp/tmpp0b3m15z.rs:14:13\n   |\n11 |     let max_index = -1;\n   |         ---------\n   |         |\n   |         first assignment to `max_index`\n   |         help: consider making this binding mutable: `mut max_index`\n...\n14 |             max_index = i;\n   |             ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Create a function which returns the largest index of an element which\n/// is not greater than or equal to the element immediately preceding it. If\n/// no such element exists then return -1. The given vector will not contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>) -> isize {\n  let max_index = -1;\n  let max_value = -1;\n  for i in arr {\n    if i > max_value {\n      max_value = i;\n      max_index = i - 1;\n    }\n  }\n  return max_index;\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n",
      "timestamp": 1664293282,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max_value`\n  --> /tmp/tmpk6s8eeav.rs:15:7\n   |\n12 |   let max_value = -1;\n   |       ---------\n   |       |\n   |       first assignment to `max_value`\n   |       help: consider making this binding mutable: `mut max_value`\n...\n15 |       max_value = i;\n   |       ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `max_index`\n  --> /tmp/tmpk6s8eeav.rs:16:7\n   |\n11 |   let max_index = -1;\n   |       ---------\n   |       |\n   |       first assignment to `max_index`\n   |       help: consider making this binding mutable: `mut max_index`\n...\n16 |       max_index = i - 1;\n   |       ^^^^^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Create a function which returns the largest index of an element which\n/// is not greater than or equal to the element immediately preceding it. If\n/// no such element exists then return -1. The given vector will not contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>) -> isize {\n  let max_index = 0\n  let max_value = arr[0]\n  for i in arr {\n    if i > max_value {\n      max_index = i\n      max_value = i\n    }\n  }\n  return max_index\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n",
      "timestamp": 1664293282,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `let`\n  --> /tmp/tmpuayf9y2m.rs:11:20\n   |\n11 |   let max_index = 0\n   |                    ^ help: add `;` here\n12 |   let max_value = arr[0]\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `for`\n  --> /tmp/tmpuayf9y2m.rs:12:25\n   |\n12 |   let max_value = arr[0]\n   |                         ^ help: add `;` here\n13 |   for i in arr {\n   |   --- unexpected token\n\nerror: expected `;`, found `max_value`\n  --> /tmp/tmpuayf9y2m.rs:15:20\n   |\n15 |       max_index = i\n   |                    ^ help: add `;` here\n16 |       max_value = i\n   |       --------- unexpected token\n\nerror: aborting due to 3 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Create a function which returns the largest index of an element which\n/// is not greater than or equal to the element immediately preceding it. If\n/// no such element exists then return -1. The given vector will not contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>) -> isize {\n  let i = 0;\n  let j = arr.len - 1;\n  while (i < j) {\n    if (arr[i] < arr[j]) {\n      j -= 1;\n    } else {\n      i += 1;\n    }\n  }\n  if (i == j) {\n    return -1;\n  } else {\n    return i;\n  }\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n",
      "timestamp": 1664293282,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpkzzmcl12.rs:13:9\n   |\n13 |   while (i < j) {\n   |         ^     ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n13 -   while (i < j) {\n13 +   while i < j {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpkzzmcl12.rs:14:8\n   |\n14 |     if (arr[i] < arr[j]) {\n   |        ^               ^\n   |\nhelp: remove these parentheses\n   |\n14 -     if (arr[i] < arr[j]) {\n14 +     if arr[i] < arr[j] {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpkzzmcl12.rs:20:6\n   |\n20 |   if (i == j) {\n   |      ^      ^\n   |\nhelp: remove these parentheses\n   |\n20 -   if (i == j) {\n20 +   if i == j {\n   | \n\nerror[E0616]: field `len` of struct `Vec` is private\n  --> /tmp/tmpkzzmcl12.rs:12:15\n   |\n12 |   let j = arr.len - 1;\n   |               ^^^ private field\n   |\nhelp: a method `len` also exists, call it with parentheses\n   |\n12 |   let j = arr.len() - 1;\n   |                  ++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpkzzmcl12.rs:23:12\n   |\n10 | fn can_arrange(arr: Vec<isize>) -> isize {\n   |                                    ----- expected `isize` because of return type\n...\n23 |     return i;\n   |            ^ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the converted value doesn't fit\n   |\n23 |     return i.try_into().unwrap();\n   |             ++++++++++++++++++++\n\nerror: aborting due to 2 previous errors; 3 warnings emitted\n\nSome errors have detailed explanations: E0308, E0616.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Create a function which returns the largest index of an element which\n/// is not greater than or equal to the element immediately preceding it. If\n/// no such element exists then return -1. The given vector will not contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>) -> isize {\n  let max_index = -1;\n  for i in arr {\n    if i > max_index {\n      max_index = i;\n    }\n  }\n  return max_index;\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n",
      "timestamp": 1664293282,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max_index`\n  --> /tmp/tmpkwi327od.rs:14:7\n   |\n11 |   let max_index = -1;\n   |       ---------\n   |       |\n   |       first assignment to `max_index`\n   |       help: consider making this binding mutable: `mut max_index`\n...\n14 |       max_index = i;\n   |       ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Create a function which returns the largest index of an element which\n/// is not greater than or equal to the element immediately preceding it. If\n/// no such element exists then return -1. The given vector will not contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>) -> isize {\n  let i = 0;\n  for j in arr {\n    if j <= arr[i] {\n      i += 1;\n    }\n  }\n  if i == 0 {\n    return -1;\n  }\n  return i - 1;\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n",
      "timestamp": 1664293282,
      "stdout": "",
      "stderr": "error[E0308]: mismatched types\n  --> /tmp/tmpr_t0nlss.rs:20:10\n   |\n10 | fn can_arrange(arr: Vec<isize>) -> isize {\n   |                                    ----- expected `isize` because of return type\n...\n20 |   return i - 1;\n   |          ^^^^^ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the converted value doesn't fit\n   |\n20 |   return (i - 1).try_into().unwrap();\n   |          +     +++++++++++++++++++++\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Create a function which returns the largest index of an element which\n/// is not greater than or equal to the element immediately preceding it. If\n/// no such element exists then return -1. The given vector will not contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>) -> isize {\n  let i = 0;\n  for i in arr.iter().next() {\n    if arr[i] > arr[i - 1] {\n      return i - 1;\n    }\n  }\n  return -1;\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n",
      "timestamp": 1664293282,
      "stdout": "",
      "stderr": "error[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmpknr__r3m.rs:13:8\n   |\n13 |     if arr[i] > arr[i - 1] {\n   |        ^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpknr__r3m.rs:13:17\n   |\n13 |     if arr[i] > arr[i - 1] {\n   |                 ^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Create a function which returns the largest index of an element which\n/// is not greater than or equal to the element immediately preceding it. If\n/// no such element exists then return -1. The given vector will not contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>) -> isize {\n    let max_index = 0;\n    let max_value = arr[0];\n    for i in arr {\n        if i > max_value {\n            max_value = i;\n            max_index = i;\n        }\n    }\n    if max_value == arr[max_index] {\n        return -1;\n    }\n    return max_index;\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n",
      "timestamp": 1664293282,
      "stdout": "",
      "stderr": "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpzdyegb5h.rs:19:21\n   |\n19 |     if max_value == arr[max_index] {\n   |                     ^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Create a function which returns the largest index of an element which\n/// is not greater than or equal to the element immediately preceding it. If\n/// no such element exists then return -1. The given vector will not contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>) -> isize {\n  let max_index = -1;\n  let max_value = -1;\n  for i in arr {\n    if i > max_value {\n      max_value = i;\n      max_index = i - 1;\n    }\n  }\n  return max_index;\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n",
      "timestamp": 1664293282,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max_value`\n  --> /tmp/tmpk6s8eeav.rs:15:7\n   |\n12 |   let max_value = -1;\n   |       ---------\n   |       |\n   |       first assignment to `max_value`\n   |       help: consider making this binding mutable: `mut max_value`\n...\n15 |       max_value = i;\n   |       ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0384]: cannot assign twice to immutable variable `max_index`\n  --> /tmp/tmpk6s8eeav.rs:16:7\n   |\n11 |   let max_index = -1;\n   |       ---------\n   |       |\n   |       first assignment to `max_index`\n   |       help: consider making this binding mutable: `mut max_index`\n...\n16 |       max_index = i - 1;\n   |       ^^^^^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Create a function which returns the largest index of an element which\n/// is not greater than or equal to the element immediately preceding it. If\n/// no such element exists then return -1. The given vector will not contain\n/// duplicate values.\n/// Examples:\n/// >>> can_arrange(vec![1, 2, 4, 3, 5])\n/// 3\n/// >>> can_arrange(vec![1, 2, 3])\n/// -1\nfn can_arrange(arr: Vec<isize>) -> isize {\n  let max_index = -1;\n  for i in arr {\n    if i > max_index {\n      max_index = i;\n    }\n  }\n  return max_index;\n}\n\nfn main() {\n    let candidate = can_arrange;\n    assert_eq!(candidate(vec![1, 2, 4, 3, 5]), 3);\n    assert_eq!(candidate(vec![1, 2, 4, 5]), -1);\n    assert_eq!(candidate(vec![1, 4, 2, 5, 6, 7, 8, 9, 10]), 2);\n    assert_eq!(candidate(vec![4, 8, 5, 7, 3]), 4);\n    assert_eq!(candidate(Vec::<isize>::new()), -1);\n}\n",
      "timestamp": 1664293282,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `max_index`\n  --> /tmp/tmpkwi327od.rs:14:7\n   |\n11 |   let max_index = -1;\n   |       ---------\n   |       |\n   |       first assignment to `max_index`\n   |       help: consider making this binding mutable: `mut max_index`\n...\n14 |       max_index = i;\n   |       ^^^^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    }
  ]
}