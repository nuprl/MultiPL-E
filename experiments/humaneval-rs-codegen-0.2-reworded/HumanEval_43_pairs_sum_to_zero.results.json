{
  "name": "HumanEval_43_pairs_sum_to_zero",
  "language": "rs",
  "prompt": "/// pairs_sum_to_zero takes a vector of integers as an input.\n/// it returns true if there are two distinct elements in the vector that\n/// sum to zero, and false otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n/// true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n",
  "tests": "}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n",
  "stop_tokens": [
    "\n}"
  ],
  "results": [
    {
      "program": "/// pairs_sum_to_zero takes a vector of integers as an input.\n/// it returns true if there are two distinct elements in the vector that\n/// sum to zero, and false otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n/// true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n  let sum = 0;\n  for i in l {\n    sum += i;\n  }\n  return sum == 0;\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `sum`\n  --> /tmp/tmpmglw88cw.rs:17:5\n   |\n15 |   let sum = 0;\n   |       ---\n   |       |\n   |       first assignment to `sum`\n   |       help: consider making this binding mutable: `mut sum`\n16 |   for i in l {\n17 |     sum += i;\n   |     ^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// pairs_sum_to_zero takes a vector of integers as an input.\n/// it returns true if there are two distinct elements in the vector that\n/// sum to zero, and false otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n/// true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n  let mut pairs = vec![];\n  for i in l {\n    if i == 0 {\n      continue;\n    }\n    if i < 0 {\n      i = -i;\n    }\n    if i > 0 {\n      pairs.push(i);\n    }\n  }\n  if len(pairs) == 0 {\n    return false;\n  }\n  for i in 0..len(pairs) - 1 {\n    if pairs[i] + pairs[i + 1] != 0 {\n      return false;\n    }\n  }\n  return true;\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error[E0425]: cannot find function `len` in this scope\n  --> /tmp/tmpsf_3gl59.rs:27:6\n   |\n27 |   if len(pairs) == 0 {\n   |      ^^^ not found in this scope\n\nerror[E0425]: cannot find function `len` in this scope\n  --> /tmp/tmpsf_3gl59.rs:30:15\n   |\n30 |   for i in 0..len(pairs) - 1 {\n   |               ^^^ not found in this scope\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// pairs_sum_to_zero takes a vector of integers as an input.\n/// it returns true if there are two distinct elements in the vector that\n/// sum to zero, and false otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n/// true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n  let mut pairs = Vec::new();\n  let mut pairs_count = 0;\n  let mut pairs_sum = 0;\n  for i in l {\n    if i == 0 {\n      continue;\n    }\n    pairs_sum += i;\n    if pairs_sum == 0 {\n      pairs_count += 1;\n      pairs.push(i);\n      pairs_sum = 0;\n    }\n  }\n  return pairs_count == 2;\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmpsr5ai71t.rs:37:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// pairs_sum_to_zero takes a vector of integers as an input.\n/// it returns true if there are two distinct elements in the vector that\n/// sum to zero, and false otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n/// true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n  let mut pairs = Vec::new();\n  let mut i = 0;\n  for (i; i < l.len; i++) {\n    let mut j = i + 1;\n    for (j; j < l.len; j++) {\n      if (l[i] + l[j] == 0) {\n        pairs.push(i, j);\n      }\n    }\n  }\n  return !pairs.is_empty();\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `@`, or `|`, found `;`\n  --> /tmp/tmpeqwcfmcd.rs:17:9\n   |\n17 |   for (i; i < l.len; i++) {\n   |         ^\n   |         |\n   |         expected one of `)`, `,`, `@`, or `|`\n   |         help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `<`\n  --> /tmp/tmpeqwcfmcd.rs:17:13\n   |\n17 |   for (i; i < l.len; i++) {\n   |            -^ expected one of `)`, `,`, `@`, or `|`\n   |            |\n   |            help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `.`\n  --> /tmp/tmpeqwcfmcd.rs:17:16\n   |\n17 |   for (i; i < l.len; i++) {\n   |                ^\n   |                |\n   |                expected one of `)`, `,`, `@`, or `|`\n   |                help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `;`\n  --> /tmp/tmpeqwcfmcd.rs:17:20\n   |\n17 |   for (i; i < l.len; i++) {\n   |                    ^\n   |                    |\n   |                    expected one of `)`, `,`, `@`, or `|`\n   |                    help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `+`\n  --> /tmp/tmpeqwcfmcd.rs:17:23\n   |\n17 |   for (i; i < l.len; i++) {\n   |                       ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmpeqwcfmcd.rs:17:23\n   |\n17 |   for (i; i < l.len; i++) {\n   |                       ^ help: try adding `in` here\n\nerror: expected expression, found `)`\n  --> /tmp/tmpeqwcfmcd.rs:17:25\n   |\n17 |   for (i; i < l.len; i++) {\n   |                         ^ expected expression\n\nerror: aborting due to 7 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// pairs_sum_to_zero takes a vector of integers as an input.\n/// it returns true if there are two distinct elements in the vector that\n/// sum to zero, and false otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n/// true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n  if len(l) == 0 {\n    return false\n  }\n  let sum = 0\n  for i in l {\n    sum += i\n  }\n  if sum == 0 {\n    return false\n  }\n  for i in l {\n    if i == sum {\n      return true\n    }\n  }\n  return false\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `for`\n  --> /tmp/tmpmfq06lym.rs:18:14\n   |\n18 |   let sum = 0\n   |              ^ help: add `;` here\n19 |   for i in l {\n   |   --- unexpected token\n\nerror[E0425]: cannot find function `len` in this scope\n  --> /tmp/tmpmfq06lym.rs:15:6\n   |\n15 |   if len(l) == 0 {\n   |      ^^^ not found in this scope\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// pairs_sum_to_zero takes a vector of integers as an input.\n/// it returns true if there are two distinct elements in the vector that\n/// sum to zero, and false otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n/// true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n  let sum = 0;\n  for i in l {\n    sum += i;\n  }\n  if sum == 0 {\n    return false;\n  }\n  for i in l {\n    for j in l {\n      if i + j == 0 {\n        return true;\n      }\n    }\n  }\n  return false;\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `sum`\n  --> /tmp/tmp1mtbxg_u.rs:17:5\n   |\n15 |   let sum = 0;\n   |       ---\n   |       |\n   |       first assignment to `sum`\n   |       help: consider making this binding mutable: `mut sum`\n16 |   for i in l {\n17 |     sum += i;\n   |     ^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0382]: use of moved value: `l`\n   --> /tmp/tmp1mtbxg_u.rs:22:12\n    |\n14  | fn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n    |                      - move occurs because `l` has type `Vec<isize>`, which does not implement the `Copy` trait\n15  |   let sum = 0;\n16  |   for i in l {\n    |            - `l` moved due to this implicit call to `.into_iter()`\n...\n22  |   for i in l {\n    |            ^ value used here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `l`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n16  |   for i in &l {\n    |            +\n\nerror[E0382]: use of moved value: `l`\n  --> /tmp/tmp1mtbxg_u.rs:23:14\n   |\n14 | fn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n   |                      - move occurs because `l` has type `Vec<isize>`, which does not implement the `Copy` trait\n...\n22 |   for i in l {\n   |            - `l` moved due to this implicit call to `.into_iter()`\n23 |     for j in l {\n   |              ^ value used here after move\n   |\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n   |\n22 |   for i in &l {\n   |            +\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0382, E0384.\nFor more information about an error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// pairs_sum_to_zero takes a vector of integers as an input.\n/// it returns true if there are two distinct elements in the vector that\n/// sum to zero, and false otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n/// true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n  let mut pairs = Vec::new();\n  let mut count = 0;\n  for (let i = 0; i < l.len(); i++) {\n    let num = l[i];\n    if (num == 0) {\n      count += 1;\n      continue;\n    }\n    if (count > 0) {\n      pairs.push(count);\n      count = 0;\n    }\n    count += 1;\n  }\n  if (count > 0) {\n    pairs.push(count);\n  }\n  return pairs.len() > 1;\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmp2m1r26y9.rs:17:8\n   |\n17 |   for (let i = 0; i < l.len(); i++) {\n   |        ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmp2m1r26y9.rs:17:12\n   |\n17 |   for (let i = 0; i < l.len(); i++) {\n   |           -^ expected one of `)`, `,`, `@`, or `|`\n   |           |\n   |           help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmp2m1r26y9.rs:17:14\n   |\n17 |   for (let i = 0; i < l.len(); i++) {\n   |              ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmp2m1r26y9.rs:17:13\n   |\n17 |   for (let i = 0; i < l.len(); i++) {\n   |             ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmp2m1r26y9.rs:17:14\n   |\n17 |   for (let i = 0; i < l.len(); i++) {\n   |              ^ expected expression\n\nerror: aborting due to 5 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// pairs_sum_to_zero takes a vector of integers as an input.\n/// it returns true if there are two distinct elements in the vector that\n/// sum to zero, and false otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n/// true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n  let mut pairs = Vec::new();\n  let mut i = 0;\n  for (i = 0; i < l.len; i++) {\n    if (l[i] == 0) {\n      break;\n    }\n  }\n  if (i == l.len) {\n    return false;\n  }\n  for (i = i + 1; i < l.len; i++) {\n    if (l[i] == 0) {\n      break;\n    }\n  }\n  if (i == l.len) {\n    return false;\n  }\n  pairs.extend(l.slice(i, i + 1));\n  pairs.extend(l.slice(0, i));\n  return true;\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmppgkf7rop.rs:17:10\n   |\n17 |   for (i = 0; i < l.len; i++) {\n   |          ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmppgkf7rop.rs:17:9\n   |\n17 |   for (i = 0; i < l.len; i++) {\n   |         ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmppgkf7rop.rs:17:10\n   |\n17 |   for (i = 0; i < l.len; i++) {\n   |          ^ expected expression\n\nerror: aborting due to 3 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// pairs_sum_to_zero takes a vector of integers as an input.\n/// it returns true if there are two distinct elements in the vector that\n/// sum to zero, and false otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n/// true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n  let mut pairs = vec![];\n  for (i, j) in l.iter().enumerate() {\n    if i == j {\n      continue;\n    }\n    if (i + j) % 2 == 0 {\n      pairs.push_back(i);\n      pairs.push_back(j);\n    }\n  }\n  return !pairs.is_empty();\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error[E0308]: mismatched types\n  --> /tmp/tmpdse7qn47.rs:17:13\n   |\n17 |     if i == j {\n   |             ^ expected `usize`, found `&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpdse7qn47.rs:20:13\n   |\n20 |     if (i + j) % 2 == 0 {\n   |             ^ expected `usize`, found `isize`\n\nerror[E0277]: cannot add `&isize` to `usize`\n  --> /tmp/tmpdse7qn47.rs:20:11\n   |\n20 |     if (i + j) % 2 == 0 {\n   |           ^ no implementation for `usize + &isize`\n   |\n   = help: the trait `Add<&isize>` is not implemented for `usize`\n   = help: the following other types implement trait `Add<Rhs>`:\n             <&'a f32 as Add<f32>>\n             <&'a f64 as Add<f64>>\n             <&'a i128 as Add<i128>>\n             <&'a i16 as Add<i16>>\n             <&'a i32 as Add<i32>>\n             <&'a i64 as Add<i64>>\n             <&'a i8 as Add<i8>>\n             <&'a isize as Add<isize>>\n           and 48 others\n\nerror[E0599]: no method named `push_back` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmpdse7qn47.rs:21:13\n   |\n21 |       pairs.push_back(i);\n   |             ^^^^^^^^^ method not found in `Vec<_>`\n\nerror[E0599]: no method named `push_back` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmpdse7qn47.rs:22:13\n   |\n22 |       pairs.push_back(j);\n   |             ^^^^^^^^^ method not found in `Vec<_>`\n\nerror: aborting due to 5 previous errors\n\nSome errors have detailed explanations: E0277, E0308, E0599.\nFor more information about an error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// pairs_sum_to_zero takes a vector of integers as an input.\n/// it returns true if there are two distinct elements in the vector that\n/// sum to zero, and false otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n/// true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n  let sum = 0;\n  for i in l {\n    sum += i;\n  }\n  return sum == 0;\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `sum`\n  --> /tmp/tmpmglw88cw.rs:17:5\n   |\n15 |   let sum = 0;\n   |       ---\n   |       |\n   |       first assignment to `sum`\n   |       help: consider making this binding mutable: `mut sum`\n16 |   for i in l {\n17 |     sum += i;\n   |     ^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// pairs_sum_to_zero takes a vector of integers as an input.\n/// it returns true if there are two distinct elements in the vector that\n/// sum to zero, and false otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n/// true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n  if len(l) == 0 {\n    return false\n  }\n  let (a, b) = (0, 0)\n  for i in 0..len(l) {\n    if a == 0 {\n      a = l[i]\n      continue\n    }\n    if b == 0 {\n      b = l[i]\n      continue\n    }\n    if a + b == 0 {\n      return true\n    }\n  }\n  return false\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `for`\n  --> /tmp/tmpcr0wgdoj.rs:18:22\n   |\n18 |   let (a, b) = (0, 0)\n   |                      ^ help: add `;` here\n19 |   for i in 0..len(l) {\n   |   --- unexpected token\n\nerror: expected `;`, found keyword `continue`\n  --> /tmp/tmpcr0wgdoj.rs:21:15\n   |\n21 |       a = l[i]\n   |               ^ help: add `;` here\n22 |       continue\n   |       -------- unexpected token\n\nerror: expected `;`, found keyword `continue`\n  --> /tmp/tmpcr0wgdoj.rs:25:15\n   |\n25 |       b = l[i]\n   |               ^ help: add `;` here\n26 |       continue\n   |       -------- unexpected token\n\nerror[E0425]: cannot find function `len` in this scope\n  --> /tmp/tmpcr0wgdoj.rs:15:6\n   |\n15 |   if len(l) == 0 {\n   |      ^^^ not found in this scope\n\nerror[E0425]: cannot find function `len` in this scope\n  --> /tmp/tmpcr0wgdoj.rs:19:15\n   |\n19 |   for i in 0..len(l) {\n   |               ^^^ not found in this scope\n\nerror: aborting due to 5 previous errors\n\nFor more information about this error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// pairs_sum_to_zero takes a vector of integers as an input.\n/// it returns true if there are two distinct elements in the vector that\n/// sum to zero, and false otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n/// true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n  let mut pairs = Vec::new();\n  let mut seen = Vec::new();\n  let mut seen_count = 0;\n  let mut seen_sum = 0;\n  for i in l {\n    if seen_count == 0 {\n      seen_sum = i;\n      seen_count = 1;\n    } else if seen_sum == i {\n      seen_count += 1;\n    } else {\n      pairs.push(seen_sum, i);\n      seen_count = 0;\n      seen_sum = i;\n      seen_count = 1;\n    }\n  }\n  if seen_count == 0 {\n    return false;\n  } else {\n    return true;\n  }\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error[E0061]: this function takes 1 argument but 2 arguments were supplied\n    --> /tmp/tmpp2o_wrye.rs:26:13\n     |\n26   |       pairs.push(seen_sum, i);\n     |             ^^^^ --------  - supplied 2 arguments\n     |             |\n     |             expected 1 argument\n     |\nnote: associated function defined here\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0061`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// pairs_sum_to_zero takes a vector of integers as an input.\n/// it returns true if there are two distinct elements in the vector that\n/// sum to zero, and false otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n/// true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n  let mut pairs = vec![];\n  for i in l {\n    if i == 0 {\n      continue;\n    }\n    let mut j = i - 1;\n    while j >= 0 && l[j] == 0 {\n      j -= 1;\n    }\n    if j >= 0 {\n      pairs.push_back(i - j);\n    }\n  }\n  return !pairs.is_empty();\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpv0nu5lmk.rs:21:21\n   |\n21 |     while j >= 0 && l[j] == 0 {\n   |                     ^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\nerror[E0599]: no method named `push_back` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmpv0nu5lmk.rs:25:13\n   |\n25 |       pairs.push_back(i - j);\n   |             ^^^^^^^^^ method not found in `Vec<_>`\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0599.\nFor more information about an error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// pairs_sum_to_zero takes a vector of integers as an input.\n/// it returns true if there are two distinct elements in the vector that\n/// sum to zero, and false otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n/// true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n  let count = 0;\n  for i in 0..l.len - 1 {\n    if l[i] + l[i + 1] == 0 {\n      count += 1;\n    }\n  }\n  return count >= 2;\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error[E0616]: field `len` of struct `Vec` is private\n  --> /tmp/tmpmly2u2i0.rs:16:17\n   |\n16 |   for i in 0..l.len - 1 {\n   |                 ^^^ private field\n   |\nhelp: a method `len` also exists, call it with parentheses\n   |\n16 |   for i in 0..l.len() - 1 {\n   |                    ++\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0616`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// pairs_sum_to_zero takes a vector of integers as an input.\n/// it returns true if there are two distinct elements in the vector that\n/// sum to zero, and false otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n/// true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n  let mut pairs = vec![];\n  for i in l {\n    if i == 0 {\n      continue;\n    }\n    if i < 0 {\n      i = -i;\n    }\n    if i % 2 == 0 {\n      continue;\n    }\n    pairs.push_back(i);\n  }\n  if len(pairs) == 0 {\n    return false;\n  }\n  for i in 0..len(pairs) - 1 {\n    if pairs[i] + pairs[i + 1] == 0 {\n      return true;\n    }\n  }\n  return false;\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error[E0425]: cannot find function `len` in this scope\n  --> /tmp/tmphje1_rl7.rs:28:6\n   |\n28 |   if len(pairs) == 0 {\n   |      ^^^ not found in this scope\n\nerror[E0425]: cannot find function `len` in this scope\n  --> /tmp/tmphje1_rl7.rs:31:15\n   |\n31 |   for i in 0..len(pairs) - 1 {\n   |               ^^^ not found in this scope\n\nerror[E0599]: no method named `push_back` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmphje1_rl7.rs:26:11\n   |\n26 |     pairs.push_back(i);\n   |           ^^^^^^^^^ method not found in `Vec<_>`\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0425, E0599.\nFor more information about an error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// pairs_sum_to_zero takes a vector of integers as an input.\n/// it returns true if there are two distinct elements in the vector that\n/// sum to zero, and false otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n/// true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n  let sum = 0;\n  for i in l {\n    sum += i;\n  }\n  return sum == 0;\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `sum`\n  --> /tmp/tmpmglw88cw.rs:17:5\n   |\n15 |   let sum = 0;\n   |       ---\n   |       |\n   |       first assignment to `sum`\n   |       help: consider making this binding mutable: `mut sum`\n16 |   for i in l {\n17 |     sum += i;\n   |     ^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// pairs_sum_to_zero takes a vector of integers as an input.\n/// it returns true if there are two distinct elements in the vector that\n/// sum to zero, and false otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n/// true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n  let count = 0;\n  for i in 0..l.len - 1 {\n    if l[i] == 0 {\n      count += 1;\n      if count > 1 {\n        return true;\n      }\n    }\n  }\n  return false;\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error[E0616]: field `len` of struct `Vec` is private\n  --> /tmp/tmpvsjm_6m6.rs:16:17\n   |\n16 |   for i in 0..l.len - 1 {\n   |                 ^^^ private field\n   |\nhelp: a method `len` also exists, call it with parentheses\n   |\n16 |   for i in 0..l.len() - 1 {\n   |                    ++\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0616`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// pairs_sum_to_zero takes a vector of integers as an input.\n/// it returns true if there are two distinct elements in the vector that\n/// sum to zero, and false otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n/// true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n  let sum = 0;\n  for i in l {\n    sum += i;\n  }\n  return sum == 0;\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `sum`\n  --> /tmp/tmpmglw88cw.rs:17:5\n   |\n15 |   let sum = 0;\n   |       ---\n   |       |\n   |       first assignment to `sum`\n   |       help: consider making this binding mutable: `mut sum`\n16 |   for i in l {\n17 |     sum += i;\n   |     ^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// pairs_sum_to_zero takes a vector of integers as an input.\n/// it returns true if there are two distinct elements in the vector that\n/// sum to zero, and false otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n/// true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n  let mut pairs = Vec::new();\n  let mut pairs_count = 0;\n  let mut pairs_sum = 0;\n  let mut pairs_sum_count = 0;\n  for i in l {\n    if i == 0 {\n      continue;\n    }\n    if i < 0 {\n      pairs_sum -= i;\n      pairs_sum_count += 1;\n    } else {\n      pairs_sum += i;\n      pairs_sum_count += 1;\n    }\n    if pairs_sum_count == 2 {\n      pairs.push(i);\n      pairs_count += 1;\n      pairs_sum_count = 0;\n    }\n  }\n  return pairs_count == 2 && pairs_sum_count == 0;\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `true`,\n right: `false`', /tmp/tmpjnrm20le.rs:42:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// pairs_sum_to_zero takes a vector of integers as an input.\n/// it returns true if there are two distinct elements in the vector that\n/// sum to zero, and false otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n/// true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n  let sum = 0;\n  for i in l {\n    sum += i;\n  }\n  return sum == 0;\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `sum`\n  --> /tmp/tmpmglw88cw.rs:17:5\n   |\n15 |   let sum = 0;\n   |       ---\n   |       |\n   |       first assignment to `sum`\n   |       help: consider making this binding mutable: `mut sum`\n16 |   for i in l {\n17 |     sum += i;\n   |     ^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// pairs_sum_to_zero takes a vector of integers as an input.\n/// it returns true if there are two distinct elements in the vector that\n/// sum to zero, and false otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n/// true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n  let sum = 0;\n  for i in l {\n    sum += i;\n  }\n  return sum == 0;\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `sum`\n  --> /tmp/tmpmglw88cw.rs:17:5\n   |\n15 |   let sum = 0;\n   |       ---\n   |       |\n   |       first assignment to `sum`\n   |       help: consider making this binding mutable: `mut sum`\n16 |   for i in l {\n17 |     sum += i;\n   |     ^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// pairs_sum_to_zero takes a vector of integers as an input.\n/// it returns true if there are two distinct elements in the vector that\n/// sum to zero, and false otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n/// true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n  let mut pairs = Vec::new();\n  for (i, j) in l.enumerate() {\n    if i == j {\n      continue;\n    }\n    let sum = i + j;\n    if sum == 0 {\n      pairs.push(i, j);\n    }\n  }\n  return !pairs.is_empty();\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error[E0599]: `Vec<isize>` is not an iterator\n   --> /tmp/tmp7a0_t8r3.rs:16:19\n    |\n16  |     for (i, j) in l.enumerate() {\n    |                     ^^^^^^^^^ `Vec<isize>` is not an iterator\n    |\n    = note: the following trait bounds were not satisfied:\n            `Vec<isize>: Iterator`\n            which is required by `&mut Vec<isize>: Iterator`\n            `[isize]: Iterator`\n            which is required by `&mut [isize]: Iterator`\n\nerror[E0061]: this function takes 1 argument but 2 arguments were supplied\n    --> /tmp/tmp7a0_t8r3.rs:22:13\n     |\n22   |       pairs.push(i, j);\n     |             ^^^^ -  - supplied 2 arguments\n     |             |\n     |             expected 1 argument\n     |\nnote: associated function defined here\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations: E0061, E0599.\nFor more information about an error, try `rustc --explain E0061`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// pairs_sum_to_zero takes a vector of integers as an input.\n/// it returns true if there are two distinct elements in the vector that\n/// sum to zero, and false otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n/// true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n  let mut pairs = Vec::new();\n  let mut seen = Vec::new();\n  let mut seen_count = 0;\n  for i in l {\n    if seen_count == 0 {\n      pairs.push(i);\n      seen.push(i);\n      seen_count = 1;\n    } else {\n      if (seen.contains(i - seen_count)) {\n        return true;\n      }\n      seen_count += 1;\n    }\n  }\n  return false;\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `if` condition\n  --> /tmp/tmphcnsen64.rs:24:10\n   |\n24 |       if (seen.contains(i - seen_count)) {\n   |          ^                             ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n24 -       if (seen.contains(i - seen_count)) {\n24 +       if seen.contains(i - seen_count) {\n   | \n\nerror[E0308]: mismatched types\n  --> /tmp/tmphcnsen64.rs:24:25\n   |\n24 |       if (seen.contains(i - seen_count)) {\n   |                         ^^^^^^^^^^^^^^\n   |                         |\n   |                         expected `&isize`, found `isize`\n   |                         help: consider borrowing here: `&(i - seen_count)`\n\nerror: aborting due to previous error; 1 warning emitted\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// pairs_sum_to_zero takes a vector of integers as an input.\n/// it returns true if there are two distinct elements in the vector that\n/// sum to zero, and false otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n/// true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n  let sum = 0;\n  for i in l {\n    sum += i;\n  }\n  return sum == 0;\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `sum`\n  --> /tmp/tmpmglw88cw.rs:17:5\n   |\n15 |   let sum = 0;\n   |       ---\n   |       |\n   |       first assignment to `sum`\n   |       help: consider making this binding mutable: `mut sum`\n16 |   for i in l {\n17 |     sum += i;\n   |     ^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// pairs_sum_to_zero takes a vector of integers as an input.\n/// it returns true if there are two distinct elements in the vector that\n/// sum to zero, and false otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n/// true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n  let sum = 0;\n  for i in l {\n    sum += i;\n  }\n  if sum == 0 {\n    return false;\n  }\n  for i in l {\n    if i == 0 {\n      continue;\n    }\n    if sum % i != 0 {\n      return false;\n    }\n  }\n  return true;\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `sum`\n  --> /tmp/tmp2j1r9dtj.rs:17:5\n   |\n15 |   let sum = 0;\n   |       ---\n   |       |\n   |       first assignment to `sum`\n   |       help: consider making this binding mutable: `mut sum`\n16 |   for i in l {\n17 |     sum += i;\n   |     ^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0382]: use of moved value: `l`\n   --> /tmp/tmp2j1r9dtj.rs:22:12\n    |\n14  | fn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n    |                      - move occurs because `l` has type `Vec<isize>`, which does not implement the `Copy` trait\n15  |   let sum = 0;\n16  |   for i in l {\n    |            - `l` moved due to this implicit call to `.into_iter()`\n...\n22  |   for i in l {\n    |            ^ value used here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `l`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n16  |   for i in &l {\n    |            +\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations: E0382, E0384.\nFor more information about an error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// pairs_sum_to_zero takes a vector of integers as an input.\n/// it returns true if there are two distinct elements in the vector that\n/// sum to zero, and false otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n/// true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n  let mut pairs = false;\n  for i in l {\n    for j in l {\n      if i + j == 0 {\n        pairs = true;\n        break;\n      }\n    }\n    if pairs {\n      break;\n    }\n  }\n  return pairs;\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error[E0382]: use of moved value: `l`\n   --> /tmp/tmphbslmgp2.rs:17:14\n    |\n14  | fn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n    |                      - move occurs because `l` has type `Vec<isize>`, which does not implement the `Copy` trait\n15  |   let mut pairs = false;\n16  |   for i in l {\n    |            - `l` moved due to this implicit call to `.into_iter()`\n17  |     for j in l {\n    |              ^ value used here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `l`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n16  |   for i in &l {\n    |            +\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// pairs_sum_to_zero takes a vector of integers as an input.\n/// it returns true if there are two distinct elements in the vector that\n/// sum to zero, and false otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n/// true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n  let count = 0;\n  for i in l {\n    if i == 0 {\n      count += 1;\n    }\n  }\n  return count >= 2;\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmpyxsodpte.rs:18:7\n   |\n15 |   let count = 0;\n   |       -----\n   |       |\n   |       first assignment to `count`\n   |       help: consider making this binding mutable: `mut count`\n...\n18 |       count += 1;\n   |       ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// pairs_sum_to_zero takes a vector of integers as an input.\n/// it returns true if there are two distinct elements in the vector that\n/// sum to zero, and false otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n/// true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n  let sum = 0;\n  for i in l {\n    sum += i;\n  }\n  if sum == 0 {\n    return false;\n  }\n  for i in l {\n    if i == 0 {\n      continue;\n    }\n    if sum - i == 0 {\n      return true;\n    }\n  }\n  return false;\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `sum`\n  --> /tmp/tmpaswqet35.rs:17:5\n   |\n15 |   let sum = 0;\n   |       ---\n   |       |\n   |       first assignment to `sum`\n   |       help: consider making this binding mutable: `mut sum`\n16 |   for i in l {\n17 |     sum += i;\n   |     ^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0382]: use of moved value: `l`\n   --> /tmp/tmpaswqet35.rs:22:12\n    |\n14  | fn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n    |                      - move occurs because `l` has type `Vec<isize>`, which does not implement the `Copy` trait\n15  |   let sum = 0;\n16  |   for i in l {\n    |            - `l` moved due to this implicit call to `.into_iter()`\n...\n22  |   for i in l {\n    |            ^ value used here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `l`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n16  |   for i in &l {\n    |            +\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations: E0382, E0384.\nFor more information about an error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// pairs_sum_to_zero takes a vector of integers as an input.\n/// it returns true if there are two distinct elements in the vector that\n/// sum to zero, and false otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n/// true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n  let sum = 0;\n  for i in l {\n    sum += i;\n  }\n  return sum == 0;\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `sum`\n  --> /tmp/tmpmglw88cw.rs:17:5\n   |\n15 |   let sum = 0;\n   |       ---\n   |       |\n   |       first assignment to `sum`\n   |       help: consider making this binding mutable: `mut sum`\n16 |   for i in l {\n17 |     sum += i;\n   |     ^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// pairs_sum_to_zero takes a vector of integers as an input.\n/// it returns true if there are two distinct elements in the vector that\n/// sum to zero, and false otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n/// true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n  let sum = 0;\n  for i in l {\n    sum += i;\n  }\n  return sum == 0;\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `sum`\n  --> /tmp/tmpmglw88cw.rs:17:5\n   |\n15 |   let sum = 0;\n   |       ---\n   |       |\n   |       first assignment to `sum`\n   |       help: consider making this binding mutable: `mut sum`\n16 |   for i in l {\n17 |     sum += i;\n   |     ^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// pairs_sum_to_zero takes a vector of integers as an input.\n/// it returns true if there are two distinct elements in the vector that\n/// sum to zero, and false otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n/// true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n  let sum = 0;\n  for i in l {\n    sum += i;\n  }\n  return sum == 0;\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `sum`\n  --> /tmp/tmpmglw88cw.rs:17:5\n   |\n15 |   let sum = 0;\n   |       ---\n   |       |\n   |       first assignment to `sum`\n   |       help: consider making this binding mutable: `mut sum`\n16 |   for i in l {\n17 |     sum += i;\n   |     ^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// pairs_sum_to_zero takes a vector of integers as an input.\n/// it returns true if there are two distinct elements in the vector that\n/// sum to zero, and false otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n/// true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n  let sum = 0;\n  for i in l {\n    sum += i;\n  }\n  return sum == 0;\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `sum`\n  --> /tmp/tmpmglw88cw.rs:17:5\n   |\n15 |   let sum = 0;\n   |       ---\n   |       |\n   |       first assignment to `sum`\n   |       help: consider making this binding mutable: `mut sum`\n16 |   for i in l {\n17 |     sum += i;\n   |     ^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// pairs_sum_to_zero takes a vector of integers as an input.\n/// it returns true if there are two distinct elements in the vector that\n/// sum to zero, and false otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n/// true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n  let mut pairs = Vec::new();\n  let mut pairs_count = 0;\n  for i in l {\n    if i == 0 {\n      continue;\n    }\n    if i < 0 {\n      i = -i;\n    }\n    if i in pairs {\n      continue;\n    }\n    pairs_count += 1;\n    pairs.push(i);\n  }\n  return pairs_count == 2;\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error: expected `{`, found keyword `in`\n  --> /tmp/tmp9je8wagh.rs:24:10\n   |\n24 |     if i in pairs {\n   |     --   ^^ expected `{`\n   |     |\n   |     this `if` expression has a condition, but no block\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// pairs_sum_to_zero takes a vector of integers as an input.\n/// it returns true if there are two distinct elements in the vector that\n/// sum to zero, and false otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n/// true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n  let mut pairs = vec![];\n  for i in l {\n    if i == 0 {\n      continue;\n    }\n    if i < 0 {\n      i = -i;\n    }\n    if i > 0 {\n      pairs.push(i);\n    }\n  }\n  if len(pairs) == 0 {\n    return false;\n  }\n  for i in 0..len(pairs) - 1 {\n    if pairs[i] + pairs[i + 1] != 0 {\n      return false;\n    }\n  }\n  return true;\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error[E0425]: cannot find function `len` in this scope\n  --> /tmp/tmpsf_3gl59.rs:27:6\n   |\n27 |   if len(pairs) == 0 {\n   |      ^^^ not found in this scope\n\nerror[E0425]: cannot find function `len` in this scope\n  --> /tmp/tmpsf_3gl59.rs:30:15\n   |\n30 |   for i in 0..len(pairs) - 1 {\n   |               ^^^ not found in this scope\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// pairs_sum_to_zero takes a vector of integers as an input.\n/// it returns true if there are two distinct elements in the vector that\n/// sum to zero, and false otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n/// true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n  let mut pairs = Vec::new();\n  let mut pairs_count = 0;\n  for i in l {\n    if i == 0 {\n      continue;\n    }\n    if i % 2 == 0 {\n      pairs.push(i);\n      pairs_count += 1;\n    }\n  }\n  if pairs_count == 0 {\n    return false;\n  }\n  if pairs_count == 1 {\n    return true;\n  }\n  let mut i = 0;\n  let mut j = 0;\n  let mut k = 0;\n  let mut l = 0;\n  let mut m = 0;\n  let mut n = 0;\n  let mut o = 0;\n  let mut p = 0;\n  let mut q = 0;\n  let mut r = 0;\n  let mut s = 0;\n  let mut t = 0;\n  let mut u = 0;\n  let mut v = 0;\n  let mut w = 0;\n  let mut x = 0;\n  let mut y = 0;\n  let mut z = 0;\n  let mut a = 0;\n  let mut b = 0;\n  let mut c = 0;\n  let mut d = 0;\n  let mut e = 0;\n  let mut f = 0;\n  let mut g = 0;\n  let mut h = 0;\n  let mut i = 0;\n  let mut j = 0;\n  let mut k = 0;\n  let mut l = 0;\n  let mut m = 0;\n  let mut n = 0;\n  let mut o = 0;\n  let mut p = 0;\n  let mut q = 0;\n  let mut r = 0;\n  let mut s = 0;\n  let mut t = 0;\n  let mut u = 0;\n  let mut v = 0;\n  let mut w = 0;\n  let mut x = 0;\n  let mut y = 0;\n  let mut z = 0;\n  let mut a = 0;\n  let mut b = 0;\n  let mut c = 0;\n  let mut d = 0;\n  let mut e = 0;\n  let mut f = 0;\n  let mut g\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error: expected `;`, found `}`\n  --> /tmp/tmpr521az73.rs:82:12\n   |\n82 |   let mut g\n   |            ^ help: add `;` here\n83 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpr521az73.rs:14:40\n   |\n14 | fn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n   |    -----------------                   ^^^^ expected `bool`, found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// pairs_sum_to_zero takes a vector of integers as an input.\n/// it returns true if there are two distinct elements in the vector that\n/// sum to zero, and false otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n/// true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n  let mut pairs = Vec::new();\n  let mut pairs_count = 0;\n  let mut pairs_sum = 0;\n  for i in l {\n    if i == 0 {\n      continue;\n    }\n    pairs_sum += i;\n    if pairs_sum == 0 {\n      pairs_count += 1;\n      pairs.push(i);\n      pairs_sum = 0;\n    }\n  }\n  return pairs_count == 2;\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmpsr5ai71t.rs:37:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// pairs_sum_to_zero takes a vector of integers as an input.\n/// it returns true if there are two distinct elements in the vector that\n/// sum to zero, and false otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n/// true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n  let mut pairs = Vec::new();\n  let mut pairs_count = 0;\n  for i in l {\n    if i == 0 {\n      continue;\n    }\n    if i % 2 == 0 {\n      pairs.push(i);\n      pairs_count += 1;\n    }\n  }\n  if pairs_count == 0 {\n    return false;\n  }\n  if pairs_count == 2 {\n    return true;\n  }\n  return false;\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmpifxugv6r.rs:43:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// pairs_sum_to_zero takes a vector of integers as an input.\n/// it returns true if there are two distinct elements in the vector that\n/// sum to zero, and false otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n/// true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n  let mut pairs = Vec::new();\n  let mut seen = Vec::new();\n  let mut seen_count = 0;\n  let mut seen_sum = 0;\n  for i in l {\n    if seen_count == 0 {\n      seen_sum = i;\n      seen_count = 1;\n    } else if seen_sum == i {\n      seen_count += 1;\n    } else {\n      pairs.push(seen_sum, i);\n      seen_sum = i;\n      seen_count = 1;\n    }\n  }\n  return seen_count == 2;\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error[E0061]: this function takes 1 argument but 2 arguments were supplied\n    --> /tmp/tmpt_9bvx9k.rs:26:13\n     |\n26   |       pairs.push(seen_sum, i);\n     |             ^^^^ --------  - supplied 2 arguments\n     |             |\n     |             expected 1 argument\n     |\nnote: associated function defined here\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0061`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// pairs_sum_to_zero takes a vector of integers as an input.\n/// it returns true if there are two distinct elements in the vector that\n/// sum to zero, and false otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n/// true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n  let mut pairs = vec![];\n  for i in l {\n    if i == 0 {\n      continue;\n    }\n    if i % 2 == 0 {\n      pairs.push_back(i);\n    }\n  }\n  if len(pairs) == 0 {\n    return false;\n  }\n  if len(pairs) == 1 {\n    return false;\n  }\n  for i in pairs {\n    for j in pairs {\n      if i == j {\n        continue;\n      }\n      if i + j == 0 {\n        return true;\n      }\n    }\n  }\n  return false;\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error[E0425]: cannot find function `len` in this scope\n  --> /tmp/tmpz20waa85.rs:24:6\n   |\n24 |   if len(pairs) == 0 {\n   |      ^^^ not found in this scope\n\nerror[E0425]: cannot find function `len` in this scope\n  --> /tmp/tmpz20waa85.rs:27:6\n   |\n27 |   if len(pairs) == 1 {\n   |      ^^^ not found in this scope\n\nerror[E0599]: no method named `push_back` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmpz20waa85.rs:21:13\n   |\n21 |       pairs.push_back(i);\n   |             ^^^^^^^^^ method not found in `Vec<_>`\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0425, E0599.\nFor more information about an error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// pairs_sum_to_zero takes a vector of integers as an input.\n/// it returns true if there are two distinct elements in the vector that\n/// sum to zero, and false otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n/// true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n  let sum = 0;\n  for i in l {\n    sum += i;\n  }\n  return sum == 0;\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `sum`\n  --> /tmp/tmpmglw88cw.rs:17:5\n   |\n15 |   let sum = 0;\n   |       ---\n   |       |\n   |       first assignment to `sum`\n   |       help: consider making this binding mutable: `mut sum`\n16 |   for i in l {\n17 |     sum += i;\n   |     ^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// pairs_sum_to_zero takes a vector of integers as an input.\n/// it returns true if there are two distinct elements in the vector that\n/// sum to zero, and false otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n/// true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n  let mut pairs = vec![];\n  for i in l {\n    if i == 0 {\n      continue;\n    }\n    if i < 0 {\n      i = -i;\n    }\n    if i in pairs {\n      return false;\n    }\n    pairs.push(i);\n  }\n  return true;\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error: expected `{`, found keyword `in`\n  --> /tmp/tmpow3uk38a.rs:23:10\n   |\n23 |     if i in pairs {\n   |     --   ^^ expected `{`\n   |     |\n   |     this `if` expression has a condition, but no block\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// pairs_sum_to_zero takes a vector of integers as an input.\n/// it returns true if there are two distinct elements in the vector that\n/// sum to zero, and false otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n/// true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n  let mut pairs = vec![];\n  for (let i = 0; i < l.len; i += 2) {\n    let a = l[i];\n    let b = l[i + 1];\n    if (a + b == 0) {\n      pairs.push(a);\n      pairs.push(b);\n    }\n  }\n  return !pairs.is_empty();\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmpxwlybm9q.rs:16:8\n   |\n16 |   for (let i = 0; i < l.len; i += 2) {\n   |        ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmpxwlybm9q.rs:16:12\n   |\n16 |   for (let i = 0; i < l.len; i += 2) {\n   |           -^ expected one of `)`, `,`, `@`, or `|`\n   |           |\n   |           help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmpxwlybm9q.rs:16:14\n   |\n16 |   for (let i = 0; i < l.len; i += 2) {\n   |              ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmpxwlybm9q.rs:16:13\n   |\n16 |   for (let i = 0; i < l.len; i += 2) {\n   |             ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmpxwlybm9q.rs:16:14\n   |\n16 |   for (let i = 0; i < l.len; i += 2) {\n   |              ^ expected expression\n\nerror: aborting due to 5 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// pairs_sum_to_zero takes a vector of integers as an input.\n/// it returns true if there are two distinct elements in the vector that\n/// sum to zero, and false otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n/// true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n  let mut pairs = false;\n  for i in 0..l.len() {\n    for j in 0..i {\n      if l[i] + l[j] == 0 {\n        pairs = true;\n        break;\n      }\n    }\n    if pairs {\n      break;\n    }\n  }\n  return pairs;\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// pairs_sum_to_zero takes a vector of integers as an input.\n/// it returns true if there are two distinct elements in the vector that\n/// sum to zero, and false otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n/// true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n  let mut pairs = Vec::new();\n  let mut count = 0;\n  for i in l {\n    if i == 0 {\n      continue;\n    }\n    if i < 0 {\n      i = -i;\n    }\n    if i in pairs {\n      continue;\n    }\n    pairs.push(i);\n    count += 1;\n  }\n  return count == 2;\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error: expected `{`, found keyword `in`\n  --> /tmp/tmpmyynz0vr.rs:24:10\n   |\n24 |     if i in pairs {\n   |     --   ^^ expected `{`\n   |     |\n   |     this `if` expression has a condition, but no block\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// pairs_sum_to_zero takes a vector of integers as an input.\n/// it returns true if there are two distinct elements in the vector that\n/// sum to zero, and false otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n/// true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n  let sum = 0;\n  for i in l {\n    sum += i;\n  }\n  return sum == 0;\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `sum`\n  --> /tmp/tmpmglw88cw.rs:17:5\n   |\n15 |   let sum = 0;\n   |       ---\n   |       |\n   |       first assignment to `sum`\n   |       help: consider making this binding mutable: `mut sum`\n16 |   for i in l {\n17 |     sum += i;\n   |     ^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// pairs_sum_to_zero takes a vector of integers as an input.\n/// it returns true if there are two distinct elements in the vector that\n/// sum to zero, and false otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n/// true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n  let mut pairs = false;\n  for i in 0..l.len() {\n    if l[i] == 0 {\n      continue;\n    }\n    for j in 0..i {\n      if l[j] == 0 {\n        continue;\n      }\n      if l[i] + l[j] == 0 {\n        pairs = true;\n        break;\n      }\n    }\n    if pairs {\n      break;\n    }\n  }\n  return pairs;\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// pairs_sum_to_zero takes a vector of integers as an input.\n/// it returns true if there are two distinct elements in the vector that\n/// sum to zero, and false otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n/// true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n  let sum = 0;\n  for i in l {\n    sum += i;\n  }\n  if sum == 0 {\n    return false;\n  }\n  let count = 0;\n  for i in l {\n    if i == 0 {\n      count += 1;\n    }\n  }\n  return count >= 2;\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `sum`\n  --> /tmp/tmpruspb5mu.rs:17:5\n   |\n15 |   let sum = 0;\n   |       ---\n   |       |\n   |       first assignment to `sum`\n   |       help: consider making this binding mutable: `mut sum`\n16 |   for i in l {\n17 |     sum += i;\n   |     ^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0382]: use of moved value: `l`\n   --> /tmp/tmpruspb5mu.rs:23:12\n    |\n14  | fn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n    |                      - move occurs because `l` has type `Vec<isize>`, which does not implement the `Copy` trait\n15  |   let sum = 0;\n16  |   for i in l {\n    |            - `l` moved due to this implicit call to `.into_iter()`\n...\n23  |   for i in l {\n    |            ^ value used here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `l`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n16  |   for i in &l {\n    |            +\n\nerror[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmpruspb5mu.rs:25:7\n   |\n22 |   let count = 0;\n   |       -----\n   |       |\n   |       first assignment to `count`\n   |       help: consider making this binding mutable: `mut count`\n...\n25 |       count += 1;\n   |       ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0382, E0384.\nFor more information about an error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// pairs_sum_to_zero takes a vector of integers as an input.\n/// it returns true if there are two distinct elements in the vector that\n/// sum to zero, and false otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n/// true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n  let count = 0;\n  for i in l {\n    if i == 0 {\n      count += 1;\n    }\n  }\n  return count >= 2;\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmpyxsodpte.rs:18:7\n   |\n15 |   let count = 0;\n   |       -----\n   |       |\n   |       first assignment to `count`\n   |       help: consider making this binding mutable: `mut count`\n...\n18 |       count += 1;\n   |       ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// pairs_sum_to_zero takes a vector of integers as an input.\n/// it returns true if there are two distinct elements in the vector that\n/// sum to zero, and false otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n/// true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n  let sum = 0;\n  for i in l {\n    sum += i;\n  }\n  if sum == 0 {\n    return false;\n  }\n  for i in l {\n    if i == 0 {\n      continue;\n    }\n    if sum == i {\n      return true;\n    }\n  }\n  return false;\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `sum`\n  --> /tmp/tmpbqwneu4a.rs:17:5\n   |\n15 |   let sum = 0;\n   |       ---\n   |       |\n   |       first assignment to `sum`\n   |       help: consider making this binding mutable: `mut sum`\n16 |   for i in l {\n17 |     sum += i;\n   |     ^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0382]: use of moved value: `l`\n   --> /tmp/tmpbqwneu4a.rs:22:12\n    |\n14  | fn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n    |                      - move occurs because `l` has type `Vec<isize>`, which does not implement the `Copy` trait\n15  |   let sum = 0;\n16  |   for i in l {\n    |            - `l` moved due to this implicit call to `.into_iter()`\n...\n22  |   for i in l {\n    |            ^ value used here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `l`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n16  |   for i in &l {\n    |            +\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations: E0382, E0384.\nFor more information about an error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// pairs_sum_to_zero takes a vector of integers as an input.\n/// it returns true if there are two distinct elements in the vector that\n/// sum to zero, and false otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n/// true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n  let sum = 0;\n  for i in l {\n    sum += i;\n  }\n  return sum == 0;\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `sum`\n  --> /tmp/tmpmglw88cw.rs:17:5\n   |\n15 |   let sum = 0;\n   |       ---\n   |       |\n   |       first assignment to `sum`\n   |       help: consider making this binding mutable: `mut sum`\n16 |   for i in l {\n17 |     sum += i;\n   |     ^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// pairs_sum_to_zero takes a vector of integers as an input.\n/// it returns true if there are two distinct elements in the vector that\n/// sum to zero, and false otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n/// true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n  let sum = 0;\n  for i in l {\n    sum += i;\n  }\n  return sum == 0;\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `sum`\n  --> /tmp/tmpmglw88cw.rs:17:5\n   |\n15 |   let sum = 0;\n   |       ---\n   |       |\n   |       first assignment to `sum`\n   |       help: consider making this binding mutable: `mut sum`\n16 |   for i in l {\n17 |     sum += i;\n   |     ^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// pairs_sum_to_zero takes a vector of integers as an input.\n/// it returns true if there are two distinct elements in the vector that\n/// sum to zero, and false otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n/// true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n  let sum = 0;\n  for i in l {\n    sum += i;\n  }\n  if sum == 0 {\n    return false;\n  }\n  for i in l {\n    if i == 0 {\n      continue;\n    }\n    if sum == i {\n      return true;\n    }\n  }\n  return false;\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `sum`\n  --> /tmp/tmpbqwneu4a.rs:17:5\n   |\n15 |   let sum = 0;\n   |       ---\n   |       |\n   |       first assignment to `sum`\n   |       help: consider making this binding mutable: `mut sum`\n16 |   for i in l {\n17 |     sum += i;\n   |     ^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0382]: use of moved value: `l`\n   --> /tmp/tmpbqwneu4a.rs:22:12\n    |\n14  | fn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n    |                      - move occurs because `l` has type `Vec<isize>`, which does not implement the `Copy` trait\n15  |   let sum = 0;\n16  |   for i in l {\n    |            - `l` moved due to this implicit call to `.into_iter()`\n...\n22  |   for i in l {\n    |            ^ value used here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `l`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n16  |   for i in &l {\n    |            +\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations: E0382, E0384.\nFor more information about an error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// pairs_sum_to_zero takes a vector of integers as an input.\n/// it returns true if there are two distinct elements in the vector that\n/// sum to zero, and false otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n/// true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n  let sum = 0;\n  for i in l {\n    sum += i;\n  }\n  return sum == 0;\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `sum`\n  --> /tmp/tmpmglw88cw.rs:17:5\n   |\n15 |   let sum = 0;\n   |       ---\n   |       |\n   |       first assignment to `sum`\n   |       help: consider making this binding mutable: `mut sum`\n16 |   for i in l {\n17 |     sum += i;\n   |     ^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// pairs_sum_to_zero takes a vector of integers as an input.\n/// it returns true if there are two distinct elements in the vector that\n/// sum to zero, and false otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n/// true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n  let count = 0;\n  for i in l {\n    if i == 0 {\n      count += 1;\n    }\n  }\n  return count > 1;\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `count`\n  --> /tmp/tmpgmczqfis.rs:18:7\n   |\n15 |   let count = 0;\n   |       -----\n   |       |\n   |       first assignment to `count`\n   |       help: consider making this binding mutable: `mut count`\n...\n18 |       count += 1;\n   |       ^^^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// pairs_sum_to_zero takes a vector of integers as an input.\n/// it returns true if there are two distinct elements in the vector that\n/// sum to zero, and false otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n/// true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n  let count = 0;\n  for i in 0..l.len - 1 {\n    if l[i] + l[i + 1] == 0 {\n      count += 1;\n    }\n  }\n  return count >= 2;\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error[E0616]: field `len` of struct `Vec` is private\n  --> /tmp/tmpmly2u2i0.rs:16:17\n   |\n16 |   for i in 0..l.len - 1 {\n   |                 ^^^ private field\n   |\nhelp: a method `len` also exists, call it with parentheses\n   |\n16 |   for i in 0..l.len() - 1 {\n   |                    ++\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0616`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// pairs_sum_to_zero takes a vector of integers as an input.\n/// it returns true if there are two distinct elements in the vector that\n/// sum to zero, and false otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n/// true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n  let sum = 0;\n  for i in l {\n    sum += i;\n  }\n  return sum == 0;\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `sum`\n  --> /tmp/tmpmglw88cw.rs:17:5\n   |\n15 |   let sum = 0;\n   |       ---\n   |       |\n   |       first assignment to `sum`\n   |       help: consider making this binding mutable: `mut sum`\n16 |   for i in l {\n17 |     sum += i;\n   |     ^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// pairs_sum_to_zero takes a vector of integers as an input.\n/// it returns true if there are two distinct elements in the vector that\n/// sum to zero, and false otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n/// true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n  let mut pairs = Vec::new();\n  let mut pairs_count = 0;\n  let mut i = 0;\n  let mut j = 0;\n  let mut k = 0;\n  for (i = 0; i < l.len(); i++) {\n    for (j = i + 1; j < l.len(); j++) {\n      if (l[i] + l[j] == 0) {\n        pairs.push_back(l[i]);\n        pairs.push_back(l[j]);\n        pairs_count += 1;\n        if (pairs_count == 2) {\n          return true;\n        }\n      }\n    }\n  }\n  return false;\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmpen4b6pc2.rs:20:10\n   |\n20 |   for (i = 0; i < l.len(); i++) {\n   |          ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmpen4b6pc2.rs:20:9\n   |\n20 |   for (i = 0; i < l.len(); i++) {\n   |         ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmpen4b6pc2.rs:20:10\n   |\n20 |   for (i = 0; i < l.len(); i++) {\n   |          ^ expected expression\n\nerror: aborting due to 3 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// pairs_sum_to_zero takes a vector of integers as an input.\n/// it returns true if there are two distinct elements in the vector that\n/// sum to zero, and false otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n/// true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n  let sum = 0;\n  for i in l {\n    sum += i;\n  }\n  return sum == 0;\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `sum`\n  --> /tmp/tmpmglw88cw.rs:17:5\n   |\n15 |   let sum = 0;\n   |       ---\n   |       |\n   |       first assignment to `sum`\n   |       help: consider making this binding mutable: `mut sum`\n16 |   for i in l {\n17 |     sum += i;\n   |     ^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// pairs_sum_to_zero takes a vector of integers as an input.\n/// it returns true if there are two distinct elements in the vector that\n/// sum to zero, and false otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n/// true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n  let sum = 0;\n  for i in l {\n    sum += i;\n  }\n  return sum == 0;\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `sum`\n  --> /tmp/tmpmglw88cw.rs:17:5\n   |\n15 |   let sum = 0;\n   |       ---\n   |       |\n   |       first assignment to `sum`\n   |       help: consider making this binding mutable: `mut sum`\n16 |   for i in l {\n17 |     sum += i;\n   |     ^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// pairs_sum_to_zero takes a vector of integers as an input.\n/// it returns true if there are two distinct elements in the vector that\n/// sum to zero, and false otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n/// true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n  let sum = 0;\n  for i in l {\n    sum += i;\n  }\n  return sum == 0;\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `sum`\n  --> /tmp/tmpmglw88cw.rs:17:5\n   |\n15 |   let sum = 0;\n   |       ---\n   |       |\n   |       first assignment to `sum`\n   |       help: consider making this binding mutable: `mut sum`\n16 |   for i in l {\n17 |     sum += i;\n   |     ^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// pairs_sum_to_zero takes a vector of integers as an input.\n/// it returns true if there are two distinct elements in the vector that\n/// sum to zero, and false otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n/// true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n  let mut pairs = Vec::new();\n  let mut sum = 0;\n  let mut i = 0;\n  for i in l {\n    let mut j = i + 1;\n    while j < l.len() {\n      if l[i] + l[j] == 0 {\n        pairs.push(i, j);\n        sum += l[i] + l[j];\n        j += 1;\n      } else {\n        break;\n      }\n    }\n  }\n  return sum == 0 && pairs.len() > 0;\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error[E0308]: mismatched types\n  --> /tmp/tmpa4ow4z6s.rs:20:15\n   |\n20 |     while j < l.len() {\n   |               ^^^^^^^ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the converted value doesn't fit\n   |\n20 |     while j < l.len().try_into().unwrap() {\n   |                      ++++++++++++++++++++\n\nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpa4ow4z6s.rs:21:10\n   |\n21 |       if l[i] + l[j] == 0 {\n   |          ^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpa4ow4z6s.rs:21:17\n   |\n21 |       if l[i] + l[j] == 0 {\n   |                 ^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\nerror[E0061]: this function takes 1 argument but 2 arguments were supplied\n    --> /tmp/tmpa4ow4z6s.rs:22:15\n     |\n22   |         pairs.push(i, j);\n     |               ^^^^ -  - supplied 2 arguments\n     |               |\n     |               expected 1 argument\n     |\nnote: associated function defined here\n\nerror[E0277]: the type `[isize]` cannot be indexed by `isize`\n  --> /tmp/tmpa4ow4z6s.rs:23:16\n   |\n23 |         sum += l[i] + l[j];\n   |                ^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<isize>` for `Vec<isize>`\n\nerror[E0277]: the type `[isi",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// pairs_sum_to_zero takes a vector of integers as an input.\n/// it returns true if there are two distinct elements in the vector that\n/// sum to zero, and false otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n/// true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n  let sum = 0;\n  for i in l {\n    sum += i;\n  }\n  if sum == 0 {\n    return false;\n  }\n  for i in l {\n    for j in l {\n      if i + j == 0 {\n        return true;\n      }\n    }\n  }\n  return false;\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `sum`\n  --> /tmp/tmp1mtbxg_u.rs:17:5\n   |\n15 |   let sum = 0;\n   |       ---\n   |       |\n   |       first assignment to `sum`\n   |       help: consider making this binding mutable: `mut sum`\n16 |   for i in l {\n17 |     sum += i;\n   |     ^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0382]: use of moved value: `l`\n   --> /tmp/tmp1mtbxg_u.rs:22:12\n    |\n14  | fn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n    |                      - move occurs because `l` has type `Vec<isize>`, which does not implement the `Copy` trait\n15  |   let sum = 0;\n16  |   for i in l {\n    |            - `l` moved due to this implicit call to `.into_iter()`\n...\n22  |   for i in l {\n    |            ^ value used here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `l`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n16  |   for i in &l {\n    |            +\n\nerror[E0382]: use of moved value: `l`\n  --> /tmp/tmp1mtbxg_u.rs:23:14\n   |\n14 | fn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n   |                      - move occurs because `l` has type `Vec<isize>`, which does not implement the `Copy` trait\n...\n22 |   for i in l {\n   |            - `l` moved due to this implicit call to `.into_iter()`\n23 |     for j in l {\n   |              ^ value used here after move\n   |\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n   |\n22 |   for i in &l {\n   |            +\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0382, E0384.\nFor more information about an error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// pairs_sum_to_zero takes a vector of integers as an input.\n/// it returns true if there are two distinct elements in the vector that\n/// sum to zero, and false otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n/// true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n  let mut pairs = vec![];\n  for (i, j) in l.enumerate() {\n    if i == j {\n      continue;\n    }\n    if i > j {\n      std::swap(i, j);\n    }\n    pairs.push_back(i);\n    pairs.push_back(j);\n  }\n  return !pairs.is_empty() && pairs.length() % 2 == 0;\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error[E0425]: cannot find function `swap` in crate `std`\n  --> /tmp/tmpye6dnni4.rs:21:12\n   |\n21 |       std::swap(i, j);\n   |            ^^^^ not found in `std`\n   |\nhelp: consider importing one of these items\n   |\n1  | use std::mem::swap;\n   |\n1  | use std::ptr::swap;\n   |\nhelp: if you import `swap`, refer to it directly\n   |\n21 -       std::swap(i, j);\n21 +       swap(i, j);\n   | \n\nerror[E0599]: `Vec<isize>` is not an iterator\n   --> /tmp/tmpye6dnni4.rs:16:19\n    |\n16  |     for (i, j) in l.enumerate() {\n    |                     ^^^^^^^^^ `Vec<isize>` is not an iterator\n    |\n    = note: the following trait bounds were not satisfied:\n            `Vec<isize>: Iterator`\n            which is required by `&mut Vec<isize>: Iterator`\n            `[isize]: Iterator`\n            which is required by `&mut [isize]: Iterator`\n\nerror[E0599]: no method named `push_back` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmpye6dnni4.rs:23:11\n   |\n23 |     pairs.push_back(i);\n   |           ^^^^^^^^^ method not found in `Vec<_>`\n\nerror[E0599]: no method named `push_back` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmpye6dnni4.rs:24:11\n   |\n24 |     pairs.push_back(j);\n   |           ^^^^^^^^^ method not found in `Vec<_>`\n\nerror[E0599]: no method named `length` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmpye6dnni4.rs:26:37\n   |\n26 |   return !pairs.is_empty() && pairs.length() % 2 == 0;\n   |                                     ^^^^^^ help: there is an associated function with a similar name: `len`\n\nerror: aborting due to 5 previous errors\n\nSome errors have detailed explanations: E0425, E0599.\nFor more information about an error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// pairs_sum_to_zero takes a vector of integers as an input.\n/// it returns true if there are two distinct elements in the vector that\n/// sum to zero, and false otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n/// true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n  let mut pairs = vec![];\n  for (i, j) in l.iter().enumerate() {\n    if i == j {\n      continue;\n    }\n    if l[i] + l[j] == 0 {\n      pairs.push(i, j);\n    }\n  }\n  return !pairs.is_empty();\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error[E0308]: mismatched types\n  --> /tmp/tmph6000n5m.rs:17:13\n   |\n17 |     if i == j {\n   |             ^ expected `usize`, found `&isize`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmph6000n5m.rs:20:15\n   |\n20 |     if l[i] + l[j] == 0 {\n   |               ^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0061]: this function takes 1 argument but 2 arguments were supplied\n    --> /tmp/tmph6000n5m.rs:21:13\n     |\n21   |       pairs.push(i, j);\n     |             ^^^^ -  - supplied 2 arguments\n     |             |\n     |             expected 1 argument\n     |\nnote: associated function defined here\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0061, E0277, E0308.\nFor more information about an error, try `rustc --explain E0061`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// pairs_sum_to_zero takes a vector of integers as an input.\n/// it returns true if there are two distinct elements in the vector that\n/// sum to zero, and false otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n/// true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n  let sum = 0;\n  for i in l {\n    sum += i;\n  }\n  return sum == 0;\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `sum`\n  --> /tmp/tmpmglw88cw.rs:17:5\n   |\n15 |   let sum = 0;\n   |       ---\n   |       |\n   |       first assignment to `sum`\n   |       help: consider making this binding mutable: `mut sum`\n16 |   for i in l {\n17 |     sum += i;\n   |     ^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// pairs_sum_to_zero takes a vector of integers as an input.\n/// it returns true if there are two distinct elements in the vector that\n/// sum to zero, and false otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n/// true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n  let sum = 0;\n  for i in l {\n    sum += i;\n  }\n  return sum == 0;\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `sum`\n  --> /tmp/tmpmglw88cw.rs:17:5\n   |\n15 |   let sum = 0;\n   |       ---\n   |       |\n   |       first assignment to `sum`\n   |       help: consider making this binding mutable: `mut sum`\n16 |   for i in l {\n17 |     sum += i;\n   |     ^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// pairs_sum_to_zero takes a vector of integers as an input.\n/// it returns true if there are two distinct elements in the vector that\n/// sum to zero, and false otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n/// true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n  let sum = 0;\n  for i in l {\n    sum += i;\n  }\n  if sum == 0 {\n    return false;\n  }\n  for i in l {\n    for j in l {\n      if i == j {\n        continue;\n      }\n      if i + j == sum {\n        return true;\n      }\n    }\n  }\n  return false;\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `sum`\n  --> /tmp/tmpmfyt8sep.rs:17:5\n   |\n15 |   let sum = 0;\n   |       ---\n   |       |\n   |       first assignment to `sum`\n   |       help: consider making this binding mutable: `mut sum`\n16 |   for i in l {\n17 |     sum += i;\n   |     ^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0382]: use of moved value: `l`\n   --> /tmp/tmpmfyt8sep.rs:22:12\n    |\n14  | fn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n    |                      - move occurs because `l` has type `Vec<isize>`, which does not implement the `Copy` trait\n15  |   let sum = 0;\n16  |   for i in l {\n    |            - `l` moved due to this implicit call to `.into_iter()`\n...\n22  |   for i in l {\n    |            ^ value used here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `l`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n16  |   for i in &l {\n    |            +\n\nerror[E0382]: use of moved value: `l`\n  --> /tmp/tmpmfyt8sep.rs:23:14\n   |\n14 | fn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n   |                      - move occurs because `l` has type `Vec<isize>`, which does not implement the `Copy` trait\n...\n22 |   for i in l {\n   |            - `l` moved due to this implicit call to `.into_iter()`\n23 |     for j in l {\n   |              ^ value used here after move\n   |\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n   |\n22 |   for i in &l {\n   |            +\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0382, E0384.\nFor more information about an error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// pairs_sum_to_zero takes a vector of integers as an input.\n/// it returns true if there are two distinct elements in the vector that\n/// sum to zero, and false otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n/// true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n  let mut pairs = Vec::new();\n  for (let i = 0; i < l.len(); i++) {\n    for (let j = i + 1; j < l.len(); j++) {\n      if (l[i] + l[j] == 0) {\n        pairs.push_back(i);\n        pairs.push_back(j);\n      }\n    }\n  }\n  return !pairs.is_empty();\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmpo_4a3855.rs:16:8\n   |\n16 |   for (let i = 0; i < l.len(); i++) {\n   |        ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmpo_4a3855.rs:16:12\n   |\n16 |   for (let i = 0; i < l.len(); i++) {\n   |           -^ expected one of `)`, `,`, `@`, or `|`\n   |           |\n   |           help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmpo_4a3855.rs:16:14\n   |\n16 |   for (let i = 0; i < l.len(); i++) {\n   |              ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmpo_4a3855.rs:16:13\n   |\n16 |   for (let i = 0; i < l.len(); i++) {\n   |             ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmpo_4a3855.rs:16:14\n   |\n16 |   for (let i = 0; i < l.len(); i++) {\n   |              ^ expected expression\n\nerror: aborting due to 5 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// pairs_sum_to_zero takes a vector of integers as an input.\n/// it returns true if there are two distinct elements in the vector that\n/// sum to zero, and false otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n/// true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n  let mut pairs = Vec::new();\n  let mut pairs_count = 0;\n  let mut pairs_sum = 0;\n  for i in l {\n    if i == 0 {\n      continue;\n    }\n    if i == -1 {\n      return false;\n    }\n    if i > 0 {\n      pairs_sum += i;\n    } else {\n      pairs_sum -= i;\n    }\n    if pairs_sum == 0 {\n      pairs_count += 1;\n    }\n  }\n  return pairs_count == 2;\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error[E0282]: type annotations needed for `Vec<T>`\n  --> /tmp/tmpcgapnsfs.rs:15:19\n   |\n15 |   let mut pairs = Vec::new();\n   |       ---------   ^^^^^^^^ cannot infer type for type parameter `T`\n   |       |\n   |       consider giving `pairs` the explicit type `Vec<T>`, where the type parameter `T` is specified\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0282`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// pairs_sum_to_zero takes a vector of integers as an input.\n/// it returns true if there are two distinct elements in the vector that\n/// sum to zero, and false otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n/// true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n  let sum = 0;\n  for i in l {\n    sum += i;\n  }\n  return sum == 0;\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `sum`\n  --> /tmp/tmpmglw88cw.rs:17:5\n   |\n15 |   let sum = 0;\n   |       ---\n   |       |\n   |       first assignment to `sum`\n   |       help: consider making this binding mutable: `mut sum`\n16 |   for i in l {\n17 |     sum += i;\n   |     ^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// pairs_sum_to_zero takes a vector of integers as an input.\n/// it returns true if there are two distinct elements in the vector that\n/// sum to zero, and false otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n/// true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n  let mut pairs = Vec::new();\n  let mut pairs_count = 0;\n  let mut pairs_sum = 0;\n  for i in l {\n    if i == 0 {\n      continue;\n    }\n    pairs_sum += i;\n    if pairs_sum == 0 {\n      pairs_count += 1;\n      pairs.push(i);\n      pairs_sum = 0;\n    }\n  }\n  return pairs_count == 2;\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmpsr5ai71t.rs:37:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// pairs_sum_to_zero takes a vector of integers as an input.\n/// it returns true if there are two distinct elements in the vector that\n/// sum to zero, and false otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n/// true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n  let sum = 0;\n  for i in l {\n    sum += i;\n  }\n  if sum == 0 {\n    return false;\n  }\n  for i in l {\n    for j in l {\n      if i + j == 0 {\n        return true;\n      }\n    }\n  }\n  return false;\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `sum`\n  --> /tmp/tmp1mtbxg_u.rs:17:5\n   |\n15 |   let sum = 0;\n   |       ---\n   |       |\n   |       first assignment to `sum`\n   |       help: consider making this binding mutable: `mut sum`\n16 |   for i in l {\n17 |     sum += i;\n   |     ^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0382]: use of moved value: `l`\n   --> /tmp/tmp1mtbxg_u.rs:22:12\n    |\n14  | fn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n    |                      - move occurs because `l` has type `Vec<isize>`, which does not implement the `Copy` trait\n15  |   let sum = 0;\n16  |   for i in l {\n    |            - `l` moved due to this implicit call to `.into_iter()`\n...\n22  |   for i in l {\n    |            ^ value used here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `l`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n16  |   for i in &l {\n    |            +\n\nerror[E0382]: use of moved value: `l`\n  --> /tmp/tmp1mtbxg_u.rs:23:14\n   |\n14 | fn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n   |                      - move occurs because `l` has type `Vec<isize>`, which does not implement the `Copy` trait\n...\n22 |   for i in l {\n   |            - `l` moved due to this implicit call to `.into_iter()`\n23 |     for j in l {\n   |              ^ value used here after move\n   |\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n   |\n22 |   for i in &l {\n   |            +\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0382, E0384.\nFor more information about an error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// pairs_sum_to_zero takes a vector of integers as an input.\n/// it returns true if there are two distinct elements in the vector that\n/// sum to zero, and false otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n/// true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n  let mut pairs = Vec::new();\n  for (i, j) in l.iter().zip(l.iter().rev()) {\n    if i.as_isize() + j.as_isize() == 0 {\n      pairs.push(i, j);\n    }\n  }\n  return !pairs.is_empty();\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error[E0599]: no method named `as_isize` found for reference `&isize` in the current scope\n  --> /tmp/tmpu4t1aru5.rs:17:10\n   |\n17 |     if i.as_isize() + j.as_isize() == 0 {\n   |          ^^^^^^^^ method not found in `&isize`\n\nerror[E0599]: no method named `as_isize` found for reference `&isize` in the current scope\n  --> /tmp/tmpu4t1aru5.rs:17:25\n   |\n17 |     if i.as_isize() + j.as_isize() == 0 {\n   |                         ^^^^^^^^ method not found in `&isize`\n\nerror[E0061]: this function takes 1 argument but 2 arguments were supplied\n    --> /tmp/tmpu4t1aru5.rs:18:13\n     |\n18   |       pairs.push(i, j);\n     |             ^^^^ -  - supplied 2 arguments\n     |             |\n     |             expected 1 argument\n     |\nnote: associated function defined here\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0061, E0599.\nFor more information about an error, try `rustc --explain E0061`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// pairs_sum_to_zero takes a vector of integers as an input.\n/// it returns true if there are two distinct elements in the vector that\n/// sum to zero, and false otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n/// true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n  if l.len == 0 {\n    return false\n  }\n  if l.len == 1 {\n    return false\n  }\n  let sum = 0\n  for i in 0..l.len-1 {\n    sum += l[i]\n  }\n  return sum == 0\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `for`\n  --> /tmp/tmprh0a8w6u.rs:21:14\n   |\n21 |   let sum = 0\n   |              ^ help: add `;` here\n22 |   for i in 0..l.len-1 {\n   |   --- unexpected token\n\nerror[E0616]: field `len` of struct `Vec` is private\n  --> /tmp/tmprh0a8w6u.rs:15:8\n   |\n15 |   if l.len == 0 {\n   |        ^^^ private field\n   |\nhelp: a method `len` also exists, call it with parentheses\n   |\n15 |   if l.len() == 0 {\n   |           ++\n\nerror[E0616]: field `len` of struct `Vec` is private\n  --> /tmp/tmprh0a8w6u.rs:18:8\n   |\n18 |   if l.len == 1 {\n   |        ^^^ private field\n   |\nhelp: a method `len` also exists, call it with parentheses\n   |\n18 |   if l.len() == 1 {\n   |           ++\n\nerror[E0616]: field `len` of struct `Vec` is private\n  --> /tmp/tmprh0a8w6u.rs:22:17\n   |\n22 |   for i in 0..l.len-1 {\n   |                 ^^^ private field\n   |\nhelp: a method `len` also exists, call it with parentheses\n   |\n22 |   for i in 0..l.len()-1 {\n   |                    ++\n\nerror: aborting due to 4 previous errors\n\nFor more information about this error, try `rustc --explain E0616`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// pairs_sum_to_zero takes a vector of integers as an input.\n/// it returns true if there are two distinct elements in the vector that\n/// sum to zero, and false otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n/// true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n  let sum = 0;\n  for i in l {\n    sum += i;\n  }\n  return sum == 0;\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `sum`\n  --> /tmp/tmpmglw88cw.rs:17:5\n   |\n15 |   let sum = 0;\n   |       ---\n   |       |\n   |       first assignment to `sum`\n   |       help: consider making this binding mutable: `mut sum`\n16 |   for i in l {\n17 |     sum += i;\n   |     ^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// pairs_sum_to_zero takes a vector of integers as an input.\n/// it returns true if there are two distinct elements in the vector that\n/// sum to zero, and false otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n/// true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n  let mut pairs = Vec::new();\n  let mut pairs_count = 0;\n  for (let i = 0; i < l.len(); i++) {\n    let num = l[i];\n    if (num > 0) {\n      pairs.push(num - 1);\n      pairs_count += 1;\n    }\n  }\n  if (pairs_count == 0) {\n    return false;\n  }\n  if (pairs_count == 1) {\n    return true;\n  }\n  let mut pairs_count_2 = 0;\n  for (let i = 0; i < pairs.len(); i++) {\n    let num = pairs[i];\n    for (let j = i + 1; j < pairs.len(); j++) {\n      let num2 = pairs[j];\n      if (num + num2 == 0) {\n        pairs_count_2 += 1;\n      }\n    }\n  }\n  return pairs_count_2 == 2;\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmppna2skgx.rs:17:8\n   |\n17 |   for (let i = 0; i < l.len(); i++) {\n   |        ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmppna2skgx.rs:17:12\n   |\n17 |   for (let i = 0; i < l.len(); i++) {\n   |           -^ expected one of `)`, `,`, `@`, or `|`\n   |           |\n   |           help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmppna2skgx.rs:17:14\n   |\n17 |   for (let i = 0; i < l.len(); i++) {\n   |              ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmppna2skgx.rs:17:13\n   |\n17 |   for (let i = 0; i < l.len(); i++) {\n   |             ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmppna2skgx.rs:17:14\n   |\n17 |   for (let i = 0; i < l.len(); i++) {\n   |              ^ expected expression\n\nerror: aborting due to 5 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// pairs_sum_to_zero takes a vector of integers as an input.\n/// it returns true if there are two distinct elements in the vector that\n/// sum to zero, and false otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n/// true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n  let mut pairs = Vec::new();\n  let mut pairs_count = 0;\n  let mut pairs_sum = 0;\n  for (let i = 0; i < l.len(); i++) {\n    if (l[i] == 0) {\n      continue;\n    }\n    if (pairs_count == 0) {\n      pairs_sum = l[i];\n      pairs_count = 1;\n      continue;\n    }\n    if (pairs_sum == l[i]) {\n      pairs_count += 1;\n      continue;\n    }\n    pairs.push(pairs_count);\n    pairs_count = 1;\n    pairs_sum = l[i];\n  }\n  if (pairs_count == 0) {\n    return false;\n  }\n  pairs.push(pairs_count);\n  return true;\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmpq4w_tocc.rs:18:8\n   |\n18 |   for (let i = 0; i < l.len(); i++) {\n   |        ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmpq4w_tocc.rs:18:12\n   |\n18 |   for (let i = 0; i < l.len(); i++) {\n   |           -^ expected one of `)`, `,`, `@`, or `|`\n   |           |\n   |           help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmpq4w_tocc.rs:18:14\n   |\n18 |   for (let i = 0; i < l.len(); i++) {\n   |              ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmpq4w_tocc.rs:18:13\n   |\n18 |   for (let i = 0; i < l.len(); i++) {\n   |             ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmpq4w_tocc.rs:18:14\n   |\n18 |   for (let i = 0; i < l.len(); i++) {\n   |              ^ expected expression\n\nerror: aborting due to 5 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// pairs_sum_to_zero takes a vector of integers as an input.\n/// it returns true if there are two distinct elements in the vector that\n/// sum to zero, and false otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n/// true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n  let mut pairs = false;\n  for (i, j) in l.zip(l.rev()).enumerate() {\n    if i == j {\n      continue;\n    }\n    if (i + j) % 2 == 0 {\n      pairs = true;\n      break;\n    }\n  }\n  return pairs;\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error[E0599]: `Vec<isize>` is not an iterator\n   --> /tmp/tmpy2o6h1rj.rs:16:19\n    |\n16  |     for (i, j) in l.zip(l.rev()).enumerate() {\n    |                     ^^^ `Vec<isize>` is not an iterator\n    |\n    = note: the following trait bounds were not satisfied:\n            `Vec<isize>: Iterator`\n            which is required by `&mut Vec<isize>: Iterator`\n            `[isize]: Iterator`\n            which is required by `&mut [isize]: Iterator`\n\nerror[E0599]: `Vec<isize>` is not an iterator\n   --> /tmp/tmpy2o6h1rj.rs:16:25\n    |\n16  |     for (i, j) in l.zip(l.rev()).enumerate() {\n    |                           ^^^ `Vec<isize>` is not an iterator\n    |\n    = note: the following trait bounds were not satisfied:\n            `Vec<isize>: Iterator`\n            which is required by `&mut Vec<isize>: Iterator`\n            `[isize]: Iterator`\n            which is required by `&mut [isize]: Iterator`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// pairs_sum_to_zero takes a vector of integers as an input.\n/// it returns true if there are two distinct elements in the vector that\n/// sum to zero, and false otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n/// true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n  let mut pairs = Vec::new();\n  let mut count = 0;\n  for i in l {\n    if i == 0 {\n      continue;\n    }\n    if i == -i {\n      pairs.push_back(i);\n      count += 1;\n    }\n  }\n  return count == 2;\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error[E0599]: no method named `push_back` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmpw3v5eq2g.rs:22:13\n   |\n22 |       pairs.push_back(i);\n   |             ^^^^^^^^^ method not found in `Vec<_>`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// pairs_sum_to_zero takes a vector of integers as an input.\n/// it returns true if there are two distinct elements in the vector that\n/// sum to zero, and false otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n/// true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n  let sum = 0;\n  for i in l {\n    sum += i;\n  }\n  return sum == 0;\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `sum`\n  --> /tmp/tmpmglw88cw.rs:17:5\n   |\n15 |   let sum = 0;\n   |       ---\n   |       |\n   |       first assignment to `sum`\n   |       help: consider making this binding mutable: `mut sum`\n16 |   for i in l {\n17 |     sum += i;\n   |     ^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// pairs_sum_to_zero takes a vector of integers as an input.\n/// it returns true if there are two distinct elements in the vector that\n/// sum to zero, and false otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n/// true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n  let mut pairs = Vec::new();\n  let mut pairs_count = 0;\n  let mut pairs_sum = 0;\n  for i in l {\n    if i == 0 {\n      continue;\n    }\n    if i > 0 {\n      pairs_sum += i;\n    } else {\n      pairs_sum -= i;\n    }\n    if pairs_sum == 0 {\n      pairs_count += 1;\n    }\n  }\n  return pairs_count == 2;\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error[E0282]: type annotations needed for `Vec<T>`\n  --> /tmp/tmpii4uzucp.rs:15:19\n   |\n15 |   let mut pairs = Vec::new();\n   |       ---------   ^^^^^^^^ cannot infer type for type parameter `T`\n   |       |\n   |       consider giving `pairs` the explicit type `Vec<T>`, where the type parameter `T` is specified\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0282`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// pairs_sum_to_zero takes a vector of integers as an input.\n/// it returns true if there are two distinct elements in the vector that\n/// sum to zero, and false otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n/// true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n  let mut pairs = vec![];\n  for i in l {\n    if i == 0 {\n      continue;\n    }\n    if i < 0 {\n      i = -i;\n    }\n    if i == 0 {\n      continue;\n    }\n    if i % 2 == 0 {\n      continue;\n    }\n    pairs.push(i);\n  }\n  if len(pairs) == 0 {\n    return false;\n  }\n  for i in pairs {\n    for j in pairs {\n      if i == j {\n        continue;\n      }\n      if i + j == 0 {\n        return true;\n      }\n    }\n  }\n  return false;\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error[E0425]: cannot find function `len` in this scope\n  --> /tmp/tmpfy3pavab.rs:31:6\n   |\n31 |   if len(pairs) == 0 {\n   |      ^^^ not found in this scope\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// pairs_sum_to_zero takes a vector of integers as an input.\n/// it returns true if there are two distinct elements in the vector that\n/// sum to zero, and false otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n/// true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n  let mut pairs = Vec::new();\n  let mut i = 0;\n  let mut j = 0;\n  let mut sum = 0;\n  for (i = 0; i < l.len; i += 1) {\n    sum = l[i];\n    for (j = i + 1; j < l.len; j += 1) {\n      if (sum == l[j]) {\n        pairs.push_back(i);\n        pairs.push_back(j);\n        return true;\n      }\n    }\n  }\n  return false;\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmpdfb9nvtt.rs:19:10\n   |\n19 |   for (i = 0; i < l.len; i += 1) {\n   |          ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmpdfb9nvtt.rs:19:9\n   |\n19 |   for (i = 0; i < l.len; i += 1) {\n   |         ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmpdfb9nvtt.rs:19:10\n   |\n19 |   for (i = 0; i < l.len; i += 1) {\n   |          ^ expected expression\n\nerror: aborting due to 3 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// pairs_sum_to_zero takes a vector of integers as an input.\n/// it returns true if there are two distinct elements in the vector that\n/// sum to zero, and false otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n/// true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n  let mut pairs = Vec::new();\n  let mut pairs_sum = 0;\n  for i in l {\n    if i == 0 {\n      continue;\n    }\n    if i == -i {\n      pairs.push(i);\n      pairs_sum += i;\n    }\n  }\n  return pairs_sum == 0;\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `true`,\n right: `false`', /tmp/tmpoo3g4pgw.rs:31:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// pairs_sum_to_zero takes a vector of integers as an input.\n/// it returns true if there are two distinct elements in the vector that\n/// sum to zero, and false otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n/// true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n  let mut pairs = false;\n  for i in 0..l.len() {\n    for j in i + 1..l.len() {\n      if l[i] + l[j] == 0 {\n        pairs = true;\n        break;\n      }\n    }\n    if pairs {\n      break;\n    }\n  }\n  return pairs;\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// pairs_sum_to_zero takes a vector of integers as an input.\n/// it returns true if there are two distinct elements in the vector that\n/// sum to zero, and false otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n/// true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n  let mut pairs = vec![];\n  for (i, j) in l.enumerate() {\n    if i == j {\n      continue;\n    }\n    if l[i] + l[j] == 0 {\n      pairs.push_back(i);\n      pairs.push_back(j);\n    }\n  }\n  return !pairs.is_empty();\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error[E0599]: `Vec<isize>` is not an iterator\n   --> /tmp/tmp36my3pam.rs:16:19\n    |\n16  |     for (i, j) in l.enumerate() {\n    |                     ^^^^^^^^^ `Vec<isize>` is not an iterator\n    |\n    = note: the following trait bounds were not satisfied:\n            `Vec<isize>: Iterator`\n            which is required by `&mut Vec<isize>: Iterator`\n            `[isize]: Iterator`\n            which is required by `&mut [isize]: Iterator`\n\nerror[E0599]: no method named `push_back` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmp36my3pam.rs:21:13\n   |\n21 |       pairs.push_back(i);\n   |             ^^^^^^^^^ method not found in `Vec<_>`\n\nerror[E0599]: no method named `push_back` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmp36my3pam.rs:22:13\n   |\n22 |       pairs.push_back(j);\n   |             ^^^^^^^^^ method not found in `Vec<_>`\n\nerror: aborting due to 3 previous errors\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// pairs_sum_to_zero takes a vector of integers as an input.\n/// it returns true if there are two distinct elements in the vector that\n/// sum to zero, and false otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n/// true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n  let mut pairs = vec![];\n  for (i, j) in l.iter().zip(l.iter().rev()) {\n    if i == j {\n      continue;\n    }\n    if i + j == 0 {\n      pairs.push(i, j);\n    }\n  }\n  return !pairs.is_empty();\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error[E0061]: this function takes 1 argument but 2 arguments were supplied\n    --> /tmp/tmp_svnfjk0.rs:21:13\n     |\n21   |       pairs.push(i, j);\n     |             ^^^^ -  - supplied 2 arguments\n     |             |\n     |             expected 1 argument\n     |\nnote: associated function defined here\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0061`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// pairs_sum_to_zero takes a vector of integers as an input.\n/// it returns true if there are two distinct elements in the vector that\n/// sum to zero, and false otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n/// true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n  let mut pairs = vec![];\n  for (i, j) in l.iter().enumerate() {\n    if i == j {\n      continue;\n    }\n    if (j - i) % 2 == 0 {\n      pairs.push_back(i);\n      pairs.push_back(j);\n    }\n  }\n  if len(pairs) == 0 {\n    return false;\n  }\n  for (i, j) in pairs.iter().enumerate() {\n    if i == j {\n      continue;\n    }\n    if (j - i) % 2 == 0 {\n      return false;\n    }\n  }\n  return true;\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error[E0425]: cannot find function `len` in this scope\n  --> /tmp/tmp1qxg4gce.rs:25:6\n   |\n25 |   if len(pairs) == 0 {\n   |      ^^^ not found in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp1qxg4gce.rs:17:13\n   |\n17 |     if i == j {\n   |             ^ expected `usize`, found `&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp1qxg4gce.rs:20:13\n   |\n20 |     if (j - i) % 2 == 0 {\n   |             ^ expected `isize`, found `usize`\n\nerror[E0277]: cannot subtract `usize` from `&isize`\n  --> /tmp/tmp1qxg4gce.rs:20:11\n   |\n20 |     if (j - i) % 2 == 0 {\n   |           ^ no implementation for `&isize - usize`\n   |\n   = help: the trait `Sub<usize>` is not implemented for `&isize`\n   = help: the following other types implement trait `Sub<Rhs>`:\n             <&'a f32 as Sub<f32>>\n             <&'a f64 as Sub<f64>>\n             <&'a i128 as Sub<i128>>\n             <&'a i16 as Sub<i16>>\n             <&'a i32 as Sub<i32>>\n             <&'a i64 as Sub<i64>>\n             <&'a i8 as Sub<i8>>\n             <&'a isize as Sub<isize>>\n           and 48 others\n\nerror[E0599]: no method named `push_back` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmp1qxg4gce.rs:21:13\n   |\n21 |       pairs.push_back(i);\n   |             ^^^^^^^^^ method not found in `Vec<_>`\n\nerror[E0599]: no method named `push_back` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmp1qxg4gce.rs:22:13\n   |\n22 |       pairs.push_back(j);\n   |             ^^^^^^^^^ method not found in `Vec<_>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp1qxg4gce.rs:29:13\n   |\n29 |     if i == j {\n   |             ^ expected `usize`, found reference\n   |\n   = note:   expected type `usize`\n           found reference `&_`\nhelp: consider dereferencing the borrow\n   |\n29 |     if i == *j {\n   |             +\n\nerror: aborting due to 7 previous errors\n\nSome errors have detailed explanations: E0277, E0308, E0425, E0599.\nFor more information about an error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// pairs_sum_to_zero takes a vector of integers as an input.\n/// it returns true if there are two distinct elements in the vector that\n/// sum to zero, and false otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n/// true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n  let sum = 0;\n  for i in l {\n    sum += i;\n  }\n  return sum == 0;\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `sum`\n  --> /tmp/tmpmglw88cw.rs:17:5\n   |\n15 |   let sum = 0;\n   |       ---\n   |       |\n   |       first assignment to `sum`\n   |       help: consider making this binding mutable: `mut sum`\n16 |   for i in l {\n17 |     sum += i;\n   |     ^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// pairs_sum_to_zero takes a vector of integers as an input.\n/// it returns true if there are two distinct elements in the vector that\n/// sum to zero, and false otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n/// true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n  let sum = 0;\n  for i in l {\n    sum += i;\n  }\n  return sum == 0;\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `sum`\n  --> /tmp/tmpmglw88cw.rs:17:5\n   |\n15 |   let sum = 0;\n   |       ---\n   |       |\n   |       first assignment to `sum`\n   |       help: consider making this binding mutable: `mut sum`\n16 |   for i in l {\n17 |     sum += i;\n   |     ^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// pairs_sum_to_zero takes a vector of integers as an input.\n/// it returns true if there are two distinct elements in the vector that\n/// sum to zero, and false otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n/// true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n  let mut pairs = Vec::new();\n  let mut i = 0;\n  let mut j = 0;\n  let mut sum = 0;\n  for (i = 0; i < l.len(); i++) {\n    sum = l[i];\n    for (j = i + 1; j < l.len(); j++) {\n      if (sum == l[j]) {\n        pairs.push_back(Pair(i, j));\n      }\n    }\n  }\n  if (pairs.len() == 0) {\n    return false;\n  }\n  for (i = 0; i < pairs.len(); i++) {\n    if (pairs[i].a == pairs[i].b) {\n      return false;\n    }\n  }\n  return true;\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmprmmo398a.rs:19:10\n   |\n19 |   for (i = 0; i < l.len(); i++) {\n   |          ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmprmmo398a.rs:19:9\n   |\n19 |   for (i = 0; i < l.len(); i++) {\n   |         ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmprmmo398a.rs:19:10\n   |\n19 |   for (i = 0; i < l.len(); i++) {\n   |          ^ expected expression\n\nerror: aborting due to 3 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// pairs_sum_to_zero takes a vector of integers as an input.\n/// it returns true if there are two distinct elements in the vector that\n/// sum to zero, and false otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n/// true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n  let mut pairs = vec![];\n  let mut i = 0;\n  for (i; i < l.len; i += 1) {\n    if (l[i] == 0) {\n      continue;\n    }\n    if (pairs.len == 0) {\n      pairs = vec![l[i]];\n      continue;\n    }\n    if (pairs[0] == l[i]) {\n      continue;\n    }\n    return false;\n  }\n  return true;\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `@`, or `|`, found `;`\n  --> /tmp/tmptha07pml.rs:17:9\n   |\n17 |   for (i; i < l.len; i += 1) {\n   |         ^\n   |         |\n   |         expected one of `)`, `,`, `@`, or `|`\n   |         help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `<`\n  --> /tmp/tmptha07pml.rs:17:13\n   |\n17 |   for (i; i < l.len; i += 1) {\n   |            -^ expected one of `)`, `,`, `@`, or `|`\n   |            |\n   |            help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `.`\n  --> /tmp/tmptha07pml.rs:17:16\n   |\n17 |   for (i; i < l.len; i += 1) {\n   |                ^\n   |                |\n   |                expected one of `)`, `,`, `@`, or `|`\n   |                help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `;`\n  --> /tmp/tmptha07pml.rs:17:20\n   |\n17 |   for (i; i < l.len; i += 1) {\n   |                    ^\n   |                    |\n   |                    expected one of `)`, `,`, `@`, or `|`\n   |                    help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `+=`\n  --> /tmp/tmptha07pml.rs:17:24\n   |\n17 |   for (i; i < l.len; i += 1) {\n   |                        ^^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmptha07pml.rs:17:23\n   |\n17 |   for (i; i < l.len; i += 1) {\n   |                       ^ help: try adding `in` here\n\nerror: expected expression, found `+=`\n  --> /tmp/tmptha07pml.rs:17:24\n   |\n17 |   for (i; i < l.len; i += 1) {\n   |                        ^^ expected expression\n\nerror: aborting due to 7 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// pairs_sum_to_zero takes a vector of integers as an input.\n/// it returns true if there are two distinct elements in the vector that\n/// sum to zero, and false otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n/// true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n  let sum = 0;\n  for i in l {\n    sum += i;\n  }\n  return sum == 0;\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `sum`\n  --> /tmp/tmpmglw88cw.rs:17:5\n   |\n15 |   let sum = 0;\n   |       ---\n   |       |\n   |       first assignment to `sum`\n   |       help: consider making this binding mutable: `mut sum`\n16 |   for i in l {\n17 |     sum += i;\n   |     ^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// pairs_sum_to_zero takes a vector of integers as an input.\n/// it returns true if there are two distinct elements in the vector that\n/// sum to zero, and false otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n/// true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n  let mut pairs: Vec<(isize, isize)> = Vec::new();\n  let mut seen: Vec<bool> = Vec::new();\n  let mut seen_index: isize = 0;\n  for i in l {\n    if !seen_index {\n      seen_index = i;\n    } else if seen_index == i {\n      return false;\n    } else {\n      pairs.push((seen_index, i));\n      seen.push(true);\n      seen_index = i;\n    }\n  }\n  return true;\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error[E0308]: mismatched types\n  --> /tmp/tmphghvyacv.rs:19:8\n   |\n19 |     if !seen_index {\n   |        ^^^^^^^^^^^ expected `bool`, found `isize`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// pairs_sum_to_zero takes a vector of integers as an input.\n/// it returns true if there are two distinct elements in the vector that\n/// sum to zero, and false otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n/// true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n  if len(l) == 0 {\n    return false\n  }\n  if len(l) == 1 {\n    return false\n  }\n  let (a, b) = (l[0], l[1]);\n  let sum = a + b;\n  for i in l.slice(2) {\n    let (c, d) = (l[i], l[i + 1]);\n    let sum2 = c + d;\n    if sum == sum2 {\n      return true\n    }\n  }\n  return false\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error[E0425]: cannot find function `len` in this scope\n  --> /tmp/tmp2vl5pegl.rs:15:6\n   |\n15 |   if len(l) == 0 {\n   |      ^^^ not found in this scope\n\nerror[E0425]: cannot find function `len` in this scope\n  --> /tmp/tmp2vl5pegl.rs:18:6\n   |\n18 |   if len(l) == 1 {\n   |      ^^^ not found in this scope\n\nerror[E0599]: no method named `slice` found for struct `Vec<isize>` in the current scope\n  --> /tmp/tmp2vl5pegl.rs:23:14\n   |\n23 |   for i in l.slice(2) {\n   |              ^^^^^\n   |\n   = help: items from traits can only be used if the trait is in scope\nhelp: the following trait is implemented but not in scope; perhaps add a `use` for it:\n   |\n1  | use std::collections::vec_deque::ring_slices::RingSlices;\n   |\nhelp: there is an associated function with a similar name\n   |\n23 |   for i in l.as_slice(2) {\n   |              ~~~~~~~~\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0425, E0599.\nFor more information about an error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// pairs_sum_to_zero takes a vector of integers as an input.\n/// it returns true if there are two distinct elements in the vector that\n/// sum to zero, and false otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n/// true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n  let mut pairs = Vec::new();\n  let mut i = 0;\n  let mut j = 0;\n  let mut sum = 0;\n  let mut count = 0;\n  for (i = 0; i < l.len; i++) {\n    sum = 0;\n    for (j = i; j < l.len; j++) {\n      sum += l[j];\n      if (sum == 0) {\n        pairs.push_back(i);\n        pairs.push_back(j);\n        count += 1;\n        if (count == 2) {\n          return true;\n        }\n      }\n    }\n  }\n  return false;\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmpsqjyb1p1.rs:20:10\n   |\n20 |   for (i = 0; i < l.len; i++) {\n   |          ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmpsqjyb1p1.rs:20:9\n   |\n20 |   for (i = 0; i < l.len; i++) {\n   |         ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmpsqjyb1p1.rs:20:10\n   |\n20 |   for (i = 0; i < l.len; i++) {\n   |          ^ expected expression\n\nerror: aborting due to 3 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// pairs_sum_to_zero takes a vector of integers as an input.\n/// it returns true if there are two distinct elements in the vector that\n/// sum to zero, and false otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n/// true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n  let sum = 0;\n  for i in l {\n    sum += i;\n  }\n  return sum == 0;\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `sum`\n  --> /tmp/tmpmglw88cw.rs:17:5\n   |\n15 |   let sum = 0;\n   |       ---\n   |       |\n   |       first assignment to `sum`\n   |       help: consider making this binding mutable: `mut sum`\n16 |   for i in l {\n17 |     sum += i;\n   |     ^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// pairs_sum_to_zero takes a vector of integers as an input.\n/// it returns true if there are two distinct elements in the vector that\n/// sum to zero, and false otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n/// true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n  let sum = 0;\n  for i in l {\n    sum += i;\n  }\n  return sum == 0;\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `sum`\n  --> /tmp/tmpmglw88cw.rs:17:5\n   |\n15 |   let sum = 0;\n   |       ---\n   |       |\n   |       first assignment to `sum`\n   |       help: consider making this binding mutable: `mut sum`\n16 |   for i in l {\n17 |     sum += i;\n   |     ^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// pairs_sum_to_zero takes a vector of integers as an input.\n/// it returns true if there are two distinct elements in the vector that\n/// sum to zero, and false otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n/// true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n  if len(l) == 0 {\n    return false\n  }\n  if len(l) == 1 {\n    return false\n  }\n  let sum = 0\n  for i in l {\n    sum += i\n  }\n  return sum == 0\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `for`\n  --> /tmp/tmpnajf0xtp.rs:21:14\n   |\n21 |   let sum = 0\n   |              ^ help: add `;` here\n22 |   for i in l {\n   |   --- unexpected token\n\nerror[E0425]: cannot find function `len` in this scope\n  --> /tmp/tmpnajf0xtp.rs:15:6\n   |\n15 |   if len(l) == 0 {\n   |      ^^^ not found in this scope\n\nerror[E0425]: cannot find function `len` in this scope\n  --> /tmp/tmpnajf0xtp.rs:18:6\n   |\n18 |   if len(l) == 1 {\n   |      ^^^ not found in this scope\n\nerror: aborting due to 3 previous errors\n\nFor more information about this error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// pairs_sum_to_zero takes a vector of integers as an input.\n/// it returns true if there are two distinct elements in the vector that\n/// sum to zero, and false otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n/// true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n  let mut pairs = vec![];\n  for (i, j) in l.iter().enumerate() {\n    if (j == 0) {\n      continue;\n    }\n    if (pairs.contains(i) || pairs.contains(j - i)) {\n      return false;\n    }\n    pairs.push(i);\n    pairs.push(j - i);\n  }\n  return true;\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp3eec55_0.rs:17:8\n   |\n17 |     if (j == 0) {\n   |        ^      ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n17 -     if (j == 0) {\n17 +     if j == 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp3eec55_0.rs:20:8\n   |\n20 |     if (pairs.contains(i) || pairs.contains(j - i)) {\n   |        ^                                          ^\n   |\nhelp: remove these parentheses\n   |\n20 -     if (pairs.contains(i) || pairs.contains(j - i)) {\n20 +     if pairs.contains(i) || pairs.contains(j - i) {\n   | \n\nerror[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmp3eec55_0.rs:17:11\n   |\n17 |     if (j == 0) {\n   |           ^^ no implementation for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>` is not implemented for `&isize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n             i16\n             i32\n             i64\n             i8\n             isize\n           and 6 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp3eec55_0.rs:20:24\n   |\n20 |     if (pairs.contains(i) || pairs.contains(j - i)) {\n   |                        ^\n   |                        |\n   |                        expected reference, found `usize`\n   |                        help: consider borrowing here: `&i`\n   |\n   = note: expected reference `&_`\n                   found type `usize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp3eec55_0.rs:20:49\n   |\n20 |     if (pairs.contains(i) || pairs.contains(j - i)) {\n   |                                                 ^ expected `isize`, found `usize`\n\nerror[E0277]: cannot subtract `usize` from `&isize`\n  --> /tmp/tmp3eec55_0.rs:20:47\n   |\n20 |     if (pairs.contains(i) || pairs.contains(j - i)) {\n   |                                               ^ no implementation for `&isize - usize`\n   |\n   = help: the trait `Sub<usize>` is not implemented for ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// pairs_sum_to_zero takes a vector of integers as an input.\n/// it returns true if there are two distinct elements in the vector that\n/// sum to zero, and false otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n/// true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n  let sum = 0;\n  for i in l {\n    sum += i;\n  }\n  return sum == 0;\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `sum`\n  --> /tmp/tmpmglw88cw.rs:17:5\n   |\n15 |   let sum = 0;\n   |       ---\n   |       |\n   |       first assignment to `sum`\n   |       help: consider making this binding mutable: `mut sum`\n16 |   for i in l {\n17 |     sum += i;\n   |     ^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// pairs_sum_to_zero takes a vector of integers as an input.\n/// it returns true if there are two distinct elements in the vector that\n/// sum to zero, and false otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n/// true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n  let sum = 0;\n  for i in l {\n    sum += i;\n  }\n  return sum == 0;\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `sum`\n  --> /tmp/tmpmglw88cw.rs:17:5\n   |\n15 |   let sum = 0;\n   |       ---\n   |       |\n   |       first assignment to `sum`\n   |       help: consider making this binding mutable: `mut sum`\n16 |   for i in l {\n17 |     sum += i;\n   |     ^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// pairs_sum_to_zero takes a vector of integers as an input.\n/// it returns true if there are two distinct elements in the vector that\n/// sum to zero, and false otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n/// true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n  let sum = 0;\n  for i in l {\n    sum += i;\n  }\n  return sum == 0;\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `sum`\n  --> /tmp/tmpmglw88cw.rs:17:5\n   |\n15 |   let sum = 0;\n   |       ---\n   |       |\n   |       first assignment to `sum`\n   |       help: consider making this binding mutable: `mut sum`\n16 |   for i in l {\n17 |     sum += i;\n   |     ^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// pairs_sum_to_zero takes a vector of integers as an input.\n/// it returns true if there are two distinct elements in the vector that\n/// sum to zero, and false otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n/// true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n  let sum = 0;\n  for i in l {\n    sum += i;\n  }\n  return sum == 0;\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `sum`\n  --> /tmp/tmpmglw88cw.rs:17:5\n   |\n15 |   let sum = 0;\n   |       ---\n   |       |\n   |       first assignment to `sum`\n   |       help: consider making this binding mutable: `mut sum`\n16 |   for i in l {\n17 |     sum += i;\n   |     ^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// pairs_sum_to_zero takes a vector of integers as an input.\n/// it returns true if there are two distinct elements in the vector that\n/// sum to zero, and false otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n/// true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n  let sum = 0;\n  for i in l {\n    sum += i;\n  }\n  return sum == 0;\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `sum`\n  --> /tmp/tmpmglw88cw.rs:17:5\n   |\n15 |   let sum = 0;\n   |       ---\n   |       |\n   |       first assignment to `sum`\n   |       help: consider making this binding mutable: `mut sum`\n16 |   for i in l {\n17 |     sum += i;\n   |     ^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// pairs_sum_to_zero takes a vector of integers as an input.\n/// it returns true if there are two distinct elements in the vector that\n/// sum to zero, and false otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n/// true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n  let sum = 0;\n  for i in l {\n    sum += i;\n  }\n  return sum == 0;\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `sum`\n  --> /tmp/tmpmglw88cw.rs:17:5\n   |\n15 |   let sum = 0;\n   |       ---\n   |       |\n   |       first assignment to `sum`\n   |       help: consider making this binding mutable: `mut sum`\n16 |   for i in l {\n17 |     sum += i;\n   |     ^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// pairs_sum_to_zero takes a vector of integers as an input.\n/// it returns true if there are two distinct elements in the vector that\n/// sum to zero, and false otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n/// true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n  let sum = 0;\n  for i in l {\n    sum += i;\n  }\n  return sum == 0;\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `sum`\n  --> /tmp/tmpmglw88cw.rs:17:5\n   |\n15 |   let sum = 0;\n   |       ---\n   |       |\n   |       first assignment to `sum`\n   |       help: consider making this binding mutable: `mut sum`\n16 |   for i in l {\n17 |     sum += i;\n   |     ^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// pairs_sum_to_zero takes a vector of integers as an input.\n/// it returns true if there are two distinct elements in the vector that\n/// sum to zero, and false otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n/// true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n  if l.len() == 0 {\n    return false\n  }\n  let sum = 0\n  for i in l.iter() {\n    sum += i\n  }\n  return sum == 0\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `for`\n  --> /tmp/tmp2rsibhzx.rs:18:14\n   |\n18 |   let sum = 0\n   |              ^ help: add `;` here\n19 |   for i in l.iter() {\n   |   --- unexpected token\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// pairs_sum_to_zero takes a vector of integers as an input.\n/// it returns true if there are two distinct elements in the vector that\n/// sum to zero, and false otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n/// true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n  let sum = 0;\n  for i in l {\n    sum += i;\n  }\n  return sum == 0;\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `sum`\n  --> /tmp/tmpmglw88cw.rs:17:5\n   |\n15 |   let sum = 0;\n   |       ---\n   |       |\n   |       first assignment to `sum`\n   |       help: consider making this binding mutable: `mut sum`\n16 |   for i in l {\n17 |     sum += i;\n   |     ^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// pairs_sum_to_zero takes a vector of integers as an input.\n/// it returns true if there are two distinct elements in the vector that\n/// sum to zero, and false otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n/// true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n  let mut pairs: Vec<(isize, isize)> = Vec::new();\n  for (i, j) in l.iter().enumerate() {\n    if i > j {\n      continue;\n    }\n    let sum = i + j;\n    if sum == 0 {\n      pairs.push((i, j));\n    }\n  }\n  return !pairs.is_empty();\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error[E0308]: mismatched types\n  --> /tmp/tmp7c6emix6.rs:17:12\n   |\n17 |     if i > j {\n   |            ^ expected `usize`, found `&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp7c6emix6.rs:20:19\n   |\n20 |     let sum = i + j;\n   |                   ^ expected `usize`, found `isize`\n\nerror[E0277]: cannot add `&isize` to `usize`\n  --> /tmp/tmp7c6emix6.rs:20:17\n   |\n20 |     let sum = i + j;\n   |                 ^ no implementation for `usize + &isize`\n   |\n   = help: the trait `Add<&isize>` is not implemented for `usize`\n   = help: the following other types implement trait `Add<Rhs>`:\n             <&'a f32 as Add<f32>>\n             <&'a f64 as Add<f64>>\n             <&'a i128 as Add<i128>>\n             <&'a i16 as Add<i16>>\n             <&'a i32 as Add<i32>>\n             <&'a i64 as Add<i64>>\n             <&'a i8 as Add<i8>>\n             <&'a isize as Add<isize>>\n           and 48 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp7c6emix6.rs:22:19\n   |\n22 |       pairs.push((i, j));\n   |                   ^ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the converted value doesn't fit\n   |\n22 |       pairs.push((i.try_into().unwrap(), j));\n   |                    ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp7c6emix6.rs:22:22\n   |\n22 |       pairs.push((i, j));\n   |                      ^ expected `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n22 |       pairs.push((i, *j));\n   |                      +\n\nerror: aborting due to 5 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// pairs_sum_to_zero takes a vector of integers as an input.\n/// it returns true if there are two distinct elements in the vector that\n/// sum to zero, and false otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n/// true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n  let sum = 0;\n  for i in l {\n    sum += i;\n  }\n  return sum == 0;\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `sum`\n  --> /tmp/tmpmglw88cw.rs:17:5\n   |\n15 |   let sum = 0;\n   |       ---\n   |       |\n   |       first assignment to `sum`\n   |       help: consider making this binding mutable: `mut sum`\n16 |   for i in l {\n17 |     sum += i;\n   |     ^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// pairs_sum_to_zero takes a vector of integers as an input.\n/// it returns true if there are two distinct elements in the vector that\n/// sum to zero, and false otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n/// true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n  let mut pairs: Vec<(isize, isize)> = Vec::new();\n  let mut i: isize = 0;\n  let mut j: isize = 0;\n  for i in l {\n    if i == 0 {\n      continue;\n    }\n    for j in l {\n      if j == 0 {\n        continue;\n      }\n      if i + j == 0 {\n        pairs.push((i, j));\n      }\n    }\n  }\n  return !pairs.is_empty();\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "warning: unused variable: `i`\n  --> /tmp/tmpd4a908p2.rs:16:11\n   |\n16 |   let mut i: isize = 0;\n   |           ^ help: if this is intentional, prefix it with an underscore: `_i`\n   |\n   = note: `#[warn(unused_variables)]` on by default\n\nwarning: unused variable: `j`\n  --> /tmp/tmpd4a908p2.rs:17:11\n   |\n17 |   let mut j: isize = 0;\n   |           ^ help: if this is intentional, prefix it with an underscore: `_j`\n\nwarning: variable does not need to be mutable\n  --> /tmp/tmpd4a908p2.rs:16:7\n   |\n16 |   let mut i: isize = 0;\n   |       ----^\n   |       |\n   |       help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]` on by default\n\nwarning: variable does not need to be mutable\n  --> /tmp/tmpd4a908p2.rs:17:7\n   |\n17 |   let mut j: isize = 0;\n   |       ----^\n   |       |\n   |       help: remove this `mut`\n\nerror[E0382]: use of moved value: `l`\n   --> /tmp/tmpd4a908p2.rs:22:14\n    |\n14  | fn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n    |                      - move occurs because `l` has type `Vec<isize>`, which does not implement the `Copy` trait\n...\n18  |   for i in l {\n    |            - `l` moved due to this implicit call to `.into_iter()`\n...\n22  |     for j in l {\n    |              ^ value used here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `l`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n18  |   for i in &l {\n    |            +\n\nerror: aborting due to previous error; 4 warnings emitted\n\nFor more information about this error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// pairs_sum_to_zero takes a vector of integers as an input.\n/// it returns true if there are two distinct elements in the vector that\n/// sum to zero, and false otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n/// true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n  let mut pairs = vec![];\n  for i in l {\n    if i == 0 {\n      continue;\n    }\n    if i % 2 == 0 {\n      pairs.push_back(i);\n    }\n  }\n  if len(pairs) == 0 {\n    return false;\n  }\n  for i in pairs {\n    for j in pairs {\n      if i == j {\n        continue;\n      }\n      if i + j == 0 {\n        return true;\n      }\n    }\n  }\n  return false;\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error[E0425]: cannot find function `len` in this scope\n  --> /tmp/tmp41q6mir0.rs:24:6\n   |\n24 |   if len(pairs) == 0 {\n   |      ^^^ not found in this scope\n\nerror[E0599]: no method named `push_back` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmp41q6mir0.rs:21:13\n   |\n21 |       pairs.push_back(i);\n   |             ^^^^^^^^^ method not found in `Vec<_>`\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations: E0425, E0599.\nFor more information about an error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// pairs_sum_to_zero takes a vector of integers as an input.\n/// it returns true if there are two distinct elements in the vector that\n/// sum to zero, and false otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n/// true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n  let mut pairs = vec![];\n  for (i, j) in l.enumerate() {\n    if i == j {\n      continue;\n    }\n    let sum = i + j;\n    if sum == 0 {\n      pairs.push(i, j);\n    }\n  }\n  return !pairs.is_empty();\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error[E0599]: `Vec<isize>` is not an iterator\n   --> /tmp/tmpfoe91_gy.rs:16:19\n    |\n16  |     for (i, j) in l.enumerate() {\n    |                     ^^^^^^^^^ `Vec<isize>` is not an iterator\n    |\n    = note: the following trait bounds were not satisfied:\n            `Vec<isize>: Iterator`\n            which is required by `&mut Vec<isize>: Iterator`\n            `[isize]: Iterator`\n            which is required by `&mut [isize]: Iterator`\n\nerror[E0061]: this function takes 1 argument but 2 arguments were supplied\n    --> /tmp/tmpfoe91_gy.rs:22:13\n     |\n22   |       pairs.push(i, j);\n     |             ^^^^ -  - supplied 2 arguments\n     |             |\n     |             expected 1 argument\n     |\nnote: associated function defined here\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations: E0061, E0599.\nFor more information about an error, try `rustc --explain E0061`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// pairs_sum_to_zero takes a vector of integers as an input.\n/// it returns true if there are two distinct elements in the vector that\n/// sum to zero, and false otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n/// true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n  let sum = 0;\n  for i in l {\n    sum += i;\n  }\n  return sum == 0;\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `sum`\n  --> /tmp/tmpmglw88cw.rs:17:5\n   |\n15 |   let sum = 0;\n   |       ---\n   |       |\n   |       first assignment to `sum`\n   |       help: consider making this binding mutable: `mut sum`\n16 |   for i in l {\n17 |     sum += i;\n   |     ^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// pairs_sum_to_zero takes a vector of integers as an input.\n/// it returns true if there are two distinct elements in the vector that\n/// sum to zero, and false otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n/// true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n  let mut pairs = vec![];\n  for i in l {\n    if i == 0 {\n      continue;\n    }\n    if i % 2 == 0 {\n      pairs.push_back(i);\n    }\n  }\n  if len(pairs) == 0 {\n    return false;\n  }\n  for i in pairs {\n    for j in pairs {\n      if i == j {\n        continue;\n      }\n      if i + j == 0 {\n        return true;\n      }\n    }\n  }\n  return false;\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error[E0425]: cannot find function `len` in this scope\n  --> /tmp/tmp41q6mir0.rs:24:6\n   |\n24 |   if len(pairs) == 0 {\n   |      ^^^ not found in this scope\n\nerror[E0599]: no method named `push_back` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmp41q6mir0.rs:21:13\n   |\n21 |       pairs.push_back(i);\n   |             ^^^^^^^^^ method not found in `Vec<_>`\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations: E0425, E0599.\nFor more information about an error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// pairs_sum_to_zero takes a vector of integers as an input.\n/// it returns true if there are two distinct elements in the vector that\n/// sum to zero, and false otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n/// true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n  let mut pairs = Vec::new();\n  let mut seen = Vec::new();\n  let mut seen_count = 0;\n  for i in l {\n    if i == 0 {\n      continue;\n    }\n    if seen_count > 0 {\n      pairs.push(i);\n      seen_count = 0;\n    }\n    if seen.contains(i) {\n      seen_count += 1;\n    } else {\n      seen.push(i);\n      seen_count = 1;\n    }\n  }\n  return seen_count > 1;\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error[E0308]: mismatched types\n  --> /tmp/tmpe3rekosc.rs:26:22\n   |\n26 |     if seen.contains(i) {\n   |                      ^\n   |                      |\n   |                      expected reference, found `isize`\n   |                      help: consider borrowing here: `&i`\n   |\n   = note: expected reference `&_`\n                   found type `isize`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// pairs_sum_to_zero takes a vector of integers as an input.\n/// it returns true if there are two distinct elements in the vector that\n/// sum to zero, and false otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n/// true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n  let mut pairs = Vec::new();\n  let mut seen = Vec::new();\n  for (let i = 0; i < l.len(); i++) {\n    let num = l[i];\n    if (num == 0) {\n      continue;\n    }\n    for (let j = 0; j < i; j++) {\n      if (l[j] == num) {\n        continue;\n      }\n      if (seen.contains(num - l[j])) {\n        return false;\n      }\n      seen.push(num - l[j]);\n      pairs.push(num - l[j]);\n    }\n  }\n  return true;\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmpuck54u17.rs:17:8\n   |\n17 |   for (let i = 0; i < l.len(); i++) {\n   |        ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmpuck54u17.rs:17:12\n   |\n17 |   for (let i = 0; i < l.len(); i++) {\n   |           -^ expected one of `)`, `,`, `@`, or `|`\n   |           |\n   |           help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmpuck54u17.rs:17:14\n   |\n17 |   for (let i = 0; i < l.len(); i++) {\n   |              ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmpuck54u17.rs:17:13\n   |\n17 |   for (let i = 0; i < l.len(); i++) {\n   |             ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmpuck54u17.rs:17:14\n   |\n17 |   for (let i = 0; i < l.len(); i++) {\n   |              ^ expected expression\n\nerror: aborting due to 5 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// pairs_sum_to_zero takes a vector of integers as an input.\n/// it returns true if there are two distinct elements in the vector that\n/// sum to zero, and false otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n/// true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n  let sum = 0;\n  for i in l {\n    sum += i;\n  }\n  return sum == 0;\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `sum`\n  --> /tmp/tmpmglw88cw.rs:17:5\n   |\n15 |   let sum = 0;\n   |       ---\n   |       |\n   |       first assignment to `sum`\n   |       help: consider making this binding mutable: `mut sum`\n16 |   for i in l {\n17 |     sum += i;\n   |     ^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// pairs_sum_to_zero takes a vector of integers as an input.\n/// it returns true if there are two distinct elements in the vector that\n/// sum to zero, and false otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n/// true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n  let sum = 0;\n  for i in l {\n    sum += i;\n  }\n  return sum == 0;\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `sum`\n  --> /tmp/tmpmglw88cw.rs:17:5\n   |\n15 |   let sum = 0;\n   |       ---\n   |       |\n   |       first assignment to `sum`\n   |       help: consider making this binding mutable: `mut sum`\n16 |   for i in l {\n17 |     sum += i;\n   |     ^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// pairs_sum_to_zero takes a vector of integers as an input.\n/// it returns true if there are two distinct elements in the vector that\n/// sum to zero, and false otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n/// true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n  let mut pairs = vec![];\n  for (i, j) in l.iter().enumerate() {\n    if i == j {\n      continue;\n    }\n    if l[i] + l[j] == 0 {\n      pairs.push(i, j);\n    }\n  }\n  return !pairs.is_empty();\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error[E0308]: mismatched types\n  --> /tmp/tmph6000n5m.rs:17:13\n   |\n17 |     if i == j {\n   |             ^ expected `usize`, found `&isize`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmph6000n5m.rs:20:15\n   |\n20 |     if l[i] + l[j] == 0 {\n   |               ^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0061]: this function takes 1 argument but 2 arguments were supplied\n    --> /tmp/tmph6000n5m.rs:21:13\n     |\n21   |       pairs.push(i, j);\n     |             ^^^^ -  - supplied 2 arguments\n     |             |\n     |             expected 1 argument\n     |\nnote: associated function defined here\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0061, E0277, E0308.\nFor more information about an error, try `rustc --explain E0061`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// pairs_sum_to_zero takes a vector of integers as an input.\n/// it returns true if there are two distinct elements in the vector that\n/// sum to zero, and false otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n/// true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n  let sum = 0;\n  for i in l {\n    sum += i;\n  }\n  return sum == 0;\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `sum`\n  --> /tmp/tmpmglw88cw.rs:17:5\n   |\n15 |   let sum = 0;\n   |       ---\n   |       |\n   |       first assignment to `sum`\n   |       help: consider making this binding mutable: `mut sum`\n16 |   for i in l {\n17 |     sum += i;\n   |     ^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// pairs_sum_to_zero takes a vector of integers as an input.\n/// it returns true if there are two distinct elements in the vector that\n/// sum to zero, and false otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n/// true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n  let sum = 0;\n  for i in l {\n    sum += i;\n  }\n  return sum == 0;\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `sum`\n  --> /tmp/tmpmglw88cw.rs:17:5\n   |\n15 |   let sum = 0;\n   |       ---\n   |       |\n   |       first assignment to `sum`\n   |       help: consider making this binding mutable: `mut sum`\n16 |   for i in l {\n17 |     sum += i;\n   |     ^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// pairs_sum_to_zero takes a vector of integers as an input.\n/// it returns true if there are two distinct elements in the vector that\n/// sum to zero, and false otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n/// true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n  let mut pairs = false;\n  for i in 0..l.len() {\n    for j in 0..i {\n      if l[i] + l[j] == 0 {\n        pairs = true;\n        break;\n      }\n    }\n  }\n  return pairs;\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n",
      "timestamp": 1664293222,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// pairs_sum_to_zero takes a vector of integers as an input.\n/// it returns true if there are two distinct elements in the vector that\n/// sum to zero, and false otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n/// true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n  let mut pairs = false;\n  for i in 0..l.len() {\n    if l[i] == 0 {\n      continue;\n    }\n    for j in 0..i {\n      if l[j] == 0 {\n        continue;\n      }\n      if l[i] + l[j] == 0 {\n        pairs = true;\n        break;\n      }\n    }\n    if pairs {\n      break;\n    }\n  }\n  return pairs;\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// pairs_sum_to_zero takes a vector of integers as an input.\n/// it returns true if there are two distinct elements in the vector that\n/// sum to zero, and false otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n/// true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n  let mut pairs = Vec::new();\n  let mut count = 0;\n  for (let i = 0; i < l.len(); i += 2) {\n    let a = l[i];\n    let b = l[i + 1];\n    if (a + b == 0) {\n      count += 1;\n      pairs.push(a);\n      pairs.push(b);\n    }\n  }\n  return count >= 2;\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmpchbsyal1.rs:17:8\n   |\n17 |   for (let i = 0; i < l.len(); i += 2) {\n   |        ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmpchbsyal1.rs:17:12\n   |\n17 |   for (let i = 0; i < l.len(); i += 2) {\n   |           -^ expected one of `)`, `,`, `@`, or `|`\n   |           |\n   |           help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmpchbsyal1.rs:17:14\n   |\n17 |   for (let i = 0; i < l.len(); i += 2) {\n   |              ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmpchbsyal1.rs:17:13\n   |\n17 |   for (let i = 0; i < l.len(); i += 2) {\n   |             ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmpchbsyal1.rs:17:14\n   |\n17 |   for (let i = 0; i < l.len(); i += 2) {\n   |              ^ expected expression\n\nerror: aborting due to 5 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// pairs_sum_to_zero takes a vector of integers as an input.\n/// it returns true if there are two distinct elements in the vector that\n/// sum to zero, and false otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n/// true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n  let mut pairs = Vec::new();\n  let mut count = 0;\n  for (let i = 0; i < l.len(); i += 2) {\n    let a = l[i];\n    let b = l[i + 1];\n    if (a + b == 0) {\n      pairs.push(a);\n      pairs.push(b);\n      count += 1;\n    }\n  }\n  return count == 2;\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmpe7w6_opr.rs:17:8\n   |\n17 |   for (let i = 0; i < l.len(); i += 2) {\n   |        ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmpe7w6_opr.rs:17:12\n   |\n17 |   for (let i = 0; i < l.len(); i += 2) {\n   |           -^ expected one of `)`, `,`, `@`, or `|`\n   |           |\n   |           help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmpe7w6_opr.rs:17:14\n   |\n17 |   for (let i = 0; i < l.len(); i += 2) {\n   |              ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmpe7w6_opr.rs:17:13\n   |\n17 |   for (let i = 0; i < l.len(); i += 2) {\n   |             ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmpe7w6_opr.rs:17:14\n   |\n17 |   for (let i = 0; i < l.len(); i += 2) {\n   |              ^ expected expression\n\nerror: aborting due to 5 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// pairs_sum_to_zero takes a vector of integers as an input.\n/// it returns true if there are two distinct elements in the vector that\n/// sum to zero, and false otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n/// true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n  let mut pairs = Vec::new();\n  let mut count = 0;\n  for i in l {\n    if i == 0 {\n      continue;\n    }\n    if i == -1 {\n      count += 1;\n      continue;\n    }\n    if i == 1 {\n      count += 1;\n      continue;\n    }\n    if i == -2 {\n      count += 1;\n      continue;\n    }\n    if i == 2 {\n      count += 1;\n      continue;\n    }\n    if i == -3 {\n      count += 1;\n      continue;\n    }\n    if i == 3 {\n      count += 1;\n      continue;\n    }\n    if i == -4 {\n      count += 1;\n      continue;\n    }\n    if i == 4 {\n      count += 1;\n      continue;\n    }\n    if i == -5 {\n      count += 1;\n      continue;\n    }\n    if i == 5 {\n      count += 1;\n      continue;\n    }\n    if i == -6 {\n      count += 1;\n      continue;\n    }\n    if i == 6 {\n      count += 1;\n      continue;\n    }\n    if i == -7 {\n      count += 1;\n      continue;\n    }\n    if i == 7 {\n      count += 1;\n      continue;\n    }\n    if i == -8 {\n      count += 1;\n      continue;\n    }\n    if i == 8 {\n      count += 1;\n      continue;\n    }\n    if i == -9 {\n      count += 1;\n      continue;\n    }\n    if i == 9 {\n      count += 1;\n      continue;\n    }\n    if i == -10 {\n      count += 1;\n      continue;\n    }\n    if i == 10 {\n      count += 1;\n      continue;\n    }\n    if i == -11 {\n      count += 1;\n      continue;\n    }\n    if i == 11 {\n      count += 1;\n      continue;\n    }\n    if i == -12 {\n      count += 1;\n      continue;\n    }\n    \n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error: this file contains an unclosed delimiter\n   --> /tmp/tmpil4uw0k2.rs:127:3\n    |\n14  | fn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n    |                                             - unclosed delimiter\n...\n17  |   for i in l {\n    |              - this delimiter might not be properly closed...\n...\n114 | }\n    | - ...as it matches this but it has different indentation\n...\n127 | }\n    |   ^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpil4uw0k2.rs:14:40\n   |\n14 | fn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n   |    -----------------                   ^^^^ expected `bool`, found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// pairs_sum_to_zero takes a vector of integers as an input.\n/// it returns true if there are two distinct elements in the vector that\n/// sum to zero, and false otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n/// true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n  let sum = 0;\n  for i in l {\n    sum += i;\n  }\n  return sum == 0;\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `sum`\n  --> /tmp/tmpmglw88cw.rs:17:5\n   |\n15 |   let sum = 0;\n   |       ---\n   |       |\n   |       first assignment to `sum`\n   |       help: consider making this binding mutable: `mut sum`\n16 |   for i in l {\n17 |     sum += i;\n   |     ^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// pairs_sum_to_zero takes a vector of integers as an input.\n/// it returns true if there are two distinct elements in the vector that\n/// sum to zero, and false otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n/// true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n  let mut pairs = vec![];\n  for i in l {\n    if i == 0 {\n      continue;\n    }\n    if i % 2 == 0 {\n      pairs.push(i);\n    }\n  }\n  if len(pairs) == 0 {\n    return false;\n  }\n  for i in pairs {\n    for j in pairs {\n      if i == j {\n        continue;\n      }\n      if i + j == 0 {\n        return true;\n      }\n    }\n  }\n  return false;\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error[E0425]: cannot find function `len` in this scope\n  --> /tmp/tmpf_mv831k.rs:24:6\n   |\n24 |   if len(pairs) == 0 {\n   |      ^^^ not found in this scope\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// pairs_sum_to_zero takes a vector of integers as an input.\n/// it returns true if there are two distinct elements in the vector that\n/// sum to zero, and false otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n/// true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n  let mut pairs = vec![];\n  for (i, j) in l.iter().zip(l.iter().rev()) {\n    if (j == 0) {\n      continue;\n    }\n    if (pairs.contains(i + j)) {\n      return false;\n    }\n    pairs.push(i + j);\n  }\n  return true;\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp4ak3_9qc.rs:17:8\n   |\n17 |     if (j == 0) {\n   |        ^      ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n17 -     if (j == 0) {\n17 +     if j == 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp4ak3_9qc.rs:20:8\n   |\n20 |     if (pairs.contains(i + j)) {\n   |        ^                     ^\n   |\nhelp: remove these parentheses\n   |\n20 -     if (pairs.contains(i + j)) {\n20 +     if pairs.contains(i + j) {\n   | \n\nerror[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmp4ak3_9qc.rs:17:11\n   |\n17 |     if (j == 0) {\n   |           ^^ no implementation for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>` is not implemented for `&isize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n             i16\n             i32\n             i64\n             i8\n             isize\n           and 6 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp4ak3_9qc.rs:20:24\n   |\n20 |     if (pairs.contains(i + j)) {\n   |                        ^^^^^\n   |                        |\n   |                        expected reference, found `isize`\n   |                        help: consider borrowing here: `&(i + j)`\n   |\n   = note: expected reference `&_`\n                   found type `isize`\n\nerror: aborting due to 2 previous errors; 2 warnings emitted\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// pairs_sum_to_zero takes a vector of integers as an input.\n/// it returns true if there are two distinct elements in the vector that\n/// sum to zero, and false otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n/// true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n  let mut pairs = vec![];\n  for i in l {\n    if i == 0 {\n      continue;\n    }\n    if i == -1 {\n      return false;\n    }\n    if i % 2 == 0 {\n      pairs.push(i);\n    }\n  }\n  return true;\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n",
      "timestamp": 1664293222,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `true`,\n right: `false`', /tmp/tmph2tam2ab.rs:32:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// pairs_sum_to_zero takes a vector of integers as an input.\n/// it returns true if there are two distinct elements in the vector that\n/// sum to zero, and false otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n/// true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n  let mut pairs = vec![];\n  for i in l {\n    if i == 0 {\n      continue;\n    }\n    if i % 2 == 0 {\n      pairs.push(i);\n    }\n  }\n  if len(pairs) == 0 {\n    return false;\n  }\n  for i in pairs {\n    for j in pairs {\n      if i == j {\n        continue;\n      }\n      if i + j == 0 {\n        return true;\n      }\n    }\n  }\n  return false;\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error[E0425]: cannot find function `len` in this scope\n  --> /tmp/tmpf_mv831k.rs:24:6\n   |\n24 |   if len(pairs) == 0 {\n   |      ^^^ not found in this scope\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// pairs_sum_to_zero takes a vector of integers as an input.\n/// it returns true if there are two distinct elements in the vector that\n/// sum to zero, and false otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n/// true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n  let mut pairs = false;\n  for i in l {\n    if i == 0 {\n      continue;\n    }\n    for j in l {\n      if i + j == 0 {\n        pairs = true;\n        break;\n      }\n    }\n    if pairs {\n      break;\n    }\n  }\n  return pairs;\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error[E0382]: use of moved value: `l`\n   --> /tmp/tmpv5dd5guo.rs:20:14\n    |\n14  | fn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n    |                      - move occurs because `l` has type `Vec<isize>`, which does not implement the `Copy` trait\n15  |   let mut pairs = false;\n16  |   for i in l {\n    |            - `l` moved due to this implicit call to `.into_iter()`\n...\n20  |     for j in l {\n    |              ^ value used here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `l`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n16  |   for i in &l {\n    |            +\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// pairs_sum_to_zero takes a vector of integers as an input.\n/// it returns true if there are two distinct elements in the vector that\n/// sum to zero, and false otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n/// true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n  let mut pairs = false;\n  for i in l {\n    for j in l {\n      if i + j == 0 {\n        pairs = true;\n        break;\n      }\n    }\n    if pairs {\n      break;\n    }\n  }\n  return pairs;\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error[E0382]: use of moved value: `l`\n   --> /tmp/tmphbslmgp2.rs:17:14\n    |\n14  | fn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n    |                      - move occurs because `l` has type `Vec<isize>`, which does not implement the `Copy` trait\n15  |   let mut pairs = false;\n16  |   for i in l {\n    |            - `l` moved due to this implicit call to `.into_iter()`\n17  |     for j in l {\n    |              ^ value used here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `l`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n16  |   for i in &l {\n    |            +\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// pairs_sum_to_zero takes a vector of integers as an input.\n/// it returns true if there are two distinct elements in the vector that\n/// sum to zero, and false otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n/// true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n  let mut pairs = Vec::new();\n  let mut count = 0;\n  for (let i = 0; i < l.len(); i++) {\n    let num = l[i];\n    if (num == 0) {\n      continue;\n    }\n    if (count > 0) {\n      pairs.push(num);\n    }\n    count++;\n  }\n  return count > 1;\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmpd18ha61y.rs:17:8\n   |\n17 |   for (let i = 0; i < l.len(); i++) {\n   |        ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmpd18ha61y.rs:17:12\n   |\n17 |   for (let i = 0; i < l.len(); i++) {\n   |           -^ expected one of `)`, `,`, `@`, or `|`\n   |           |\n   |           help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmpd18ha61y.rs:17:14\n   |\n17 |   for (let i = 0; i < l.len(); i++) {\n   |              ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmpd18ha61y.rs:17:13\n   |\n17 |   for (let i = 0; i < l.len(); i++) {\n   |             ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmpd18ha61y.rs:17:14\n   |\n17 |   for (let i = 0; i < l.len(); i++) {\n   |              ^ expected expression\n\nerror: aborting due to 5 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// pairs_sum_to_zero takes a vector of integers as an input.\n/// it returns true if there are two distinct elements in the vector that\n/// sum to zero, and false otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n/// true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n  let sum = 0;\n  for i in l {\n    sum += i;\n  }\n  return sum == 0;\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `sum`\n  --> /tmp/tmpmglw88cw.rs:17:5\n   |\n15 |   let sum = 0;\n   |       ---\n   |       |\n   |       first assignment to `sum`\n   |       help: consider making this binding mutable: `mut sum`\n16 |   for i in l {\n17 |     sum += i;\n   |     ^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// pairs_sum_to_zero takes a vector of integers as an input.\n/// it returns true if there are two distinct elements in the vector that\n/// sum to zero, and false otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n/// true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n  let mut pairs = vec![];\n  for (i, j) in l.iter().enumerate() {\n    if i == j {\n      continue;\n    }\n    if (i + j) % 2 == 0 {\n      pairs.push(i, j);\n    }\n  }\n  return !pairs.is_empty();\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error[E0308]: mismatched types\n  --> /tmp/tmpw3x2fgvi.rs:17:13\n   |\n17 |     if i == j {\n   |             ^ expected `usize`, found `&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpw3x2fgvi.rs:20:13\n   |\n20 |     if (i + j) % 2 == 0 {\n   |             ^ expected `usize`, found `isize`\n\nerror[E0277]: cannot add `&isize` to `usize`\n  --> /tmp/tmpw3x2fgvi.rs:20:11\n   |\n20 |     if (i + j) % 2 == 0 {\n   |           ^ no implementation for `usize + &isize`\n   |\n   = help: the trait `Add<&isize>` is not implemented for `usize`\n   = help: the following other types implement trait `Add<Rhs>`:\n             <&'a f32 as Add<f32>>\n             <&'a f64 as Add<f64>>\n             <&'a i128 as Add<i128>>\n             <&'a i16 as Add<i16>>\n             <&'a i32 as Add<i32>>\n             <&'a i64 as Add<i64>>\n             <&'a i8 as Add<i8>>\n             <&'a isize as Add<isize>>\n           and 48 others\n\nerror[E0061]: this function takes 1 argument but 2 arguments were supplied\n    --> /tmp/tmpw3x2fgvi.rs:21:13\n     |\n21   |       pairs.push(i, j);\n     |             ^^^^ -  - supplied 2 arguments\n     |             |\n     |             expected 1 argument\n     |\nnote: associated function defined here\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations: E0061, E0277, E0308.\nFor more information about an error, try `rustc --explain E0061`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// pairs_sum_to_zero takes a vector of integers as an input.\n/// it returns true if there are two distinct elements in the vector that\n/// sum to zero, and false otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n/// true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n  let sum = 0;\n  for i in l {\n    sum += i;\n  }\n  return sum == 0;\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `sum`\n  --> /tmp/tmpmglw88cw.rs:17:5\n   |\n15 |   let sum = 0;\n   |       ---\n   |       |\n   |       first assignment to `sum`\n   |       help: consider making this binding mutable: `mut sum`\n16 |   for i in l {\n17 |     sum += i;\n   |     ^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// pairs_sum_to_zero takes a vector of integers as an input.\n/// it returns true if there are two distinct elements in the vector that\n/// sum to zero, and false otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n/// true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n  let mut pairs = Vec::new();\n  for (i, j) in l.iter().zip(l.iter().rev()) {\n    if (j.is_neg()) {\n      continue;\n    }\n    if (j.is_zero()) {\n      return false;\n    }\n    pairs.push(i, j);\n  }\n  return true;\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpaugr4x7w.rs:17:8\n   |\n17 |     if (j.is_neg()) {\n   |        ^          ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n17 -     if (j.is_neg()) {\n17 +     if j.is_neg() {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpaugr4x7w.rs:20:8\n   |\n20 |     if (j.is_zero()) {\n   |        ^           ^\n   |\nhelp: remove these parentheses\n   |\n20 -     if (j.is_zero()) {\n20 +     if j.is_zero() {\n   | \n\nerror[E0599]: no method named `is_neg` found for reference `&isize` in the current scope\n  --> /tmp/tmpaugr4x7w.rs:17:11\n   |\n17 |     if (j.is_neg()) {\n   |           ^^^^^^ help: there is an associated function with a similar name: `is_negative`\n\nerror[E0599]: no method named `is_zero` found for reference `&isize` in the current scope\n  --> /tmp/tmpaugr4x7w.rs:20:11\n   |\n20 |     if (j.is_zero()) {\n   |           ^^^^^^^ method not found in `&isize`\n\nerror[E0061]: this function takes 1 argument but 2 arguments were supplied\n    --> /tmp/tmpaugr4x7w.rs:23:11\n     |\n23   |     pairs.push(i, j);\n     |           ^^^^ -  - supplied 2 arguments\n     |           |\n     |           expected 1 argument\n     |\nnote: associated function defined here\n\nerror: aborting due to 3 previous errors; 2 warnings emitted\n\nSome errors have detailed explanations: E0061, E0599.\nFor more information about an error, try `rustc --explain E0061`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// pairs_sum_to_zero takes a vector of integers as an input.\n/// it returns true if there are two distinct elements in the vector that\n/// sum to zero, and false otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n/// true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n  let count = 0;\n  for i in 0..l.len - 1 {\n    if l[i] == 0 {\n      count += 1;\n      if count > 1 {\n        return true;\n      }\n    }\n  }\n  return false;\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error[E0616]: field `len` of struct `Vec` is private\n  --> /tmp/tmpvsjm_6m6.rs:16:17\n   |\n16 |   for i in 0..l.len - 1 {\n   |                 ^^^ private field\n   |\nhelp: a method `len` also exists, call it with parentheses\n   |\n16 |   for i in 0..l.len() - 1 {\n   |                    ++\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0616`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// pairs_sum_to_zero takes a vector of integers as an input.\n/// it returns true if there are two distinct elements in the vector that\n/// sum to zero, and false otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n/// true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n  let mut pairs = Vec::new();\n  for (let i = 0; i < l.len(); i += 2) {\n    let a = l[i];\n    let b = l[i + 1];\n    if (a + b == 0) {\n      pairs.push(a);\n      pairs.push(b);\n    }\n  }\n  return !pairs.is_empty();\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmpa0mrriuv.rs:16:8\n   |\n16 |   for (let i = 0; i < l.len(); i += 2) {\n   |        ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmpa0mrriuv.rs:16:12\n   |\n16 |   for (let i = 0; i < l.len(); i += 2) {\n   |           -^ expected one of `)`, `,`, `@`, or `|`\n   |           |\n   |           help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmpa0mrriuv.rs:16:14\n   |\n16 |   for (let i = 0; i < l.len(); i += 2) {\n   |              ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmpa0mrriuv.rs:16:13\n   |\n16 |   for (let i = 0; i < l.len(); i += 2) {\n   |             ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmpa0mrriuv.rs:16:14\n   |\n16 |   for (let i = 0; i < l.len(); i += 2) {\n   |              ^ expected expression\n\nerror: aborting due to 5 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// pairs_sum_to_zero takes a vector of integers as an input.\n/// it returns true if there are two distinct elements in the vector that\n/// sum to zero, and false otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n/// true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n  let mut pairs = Vec::new();\n  let mut pairs_count = 0;\n  for i in l {\n    if i == 0 {\n      continue;\n    }\n    if i < 0 {\n      i = -i;\n    }\n    if i % 2 == 0 {\n      continue;\n    }\n    if i in pairs {\n      continue;\n    }\n    pairs_count += 1;\n    pairs.push(i);\n  }\n  return pairs_count == 2;\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error: expected `{`, found keyword `in`\n  --> /tmp/tmpab4dahbh.rs:27:10\n   |\n27 |     if i in pairs {\n   |     --   ^^ expected `{`\n   |     |\n   |     this `if` expression has a condition, but no block\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// pairs_sum_to_zero takes a vector of integers as an input.\n/// it returns true if there are two distinct elements in the vector that\n/// sum to zero, and false otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n/// true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n  let sum = 0;\n  for i in l {\n    sum += i;\n  }\n  return sum == 0;\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `sum`\n  --> /tmp/tmpmglw88cw.rs:17:5\n   |\n15 |   let sum = 0;\n   |       ---\n   |       |\n   |       first assignment to `sum`\n   |       help: consider making this binding mutable: `mut sum`\n16 |   for i in l {\n17 |     sum += i;\n   |     ^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// pairs_sum_to_zero takes a vector of integers as an input.\n/// it returns true if there are two distinct elements in the vector that\n/// sum to zero, and false otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n/// true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n  let mut pairs = vec![];\n  let mut i = 0;\n  for (i; i < l.len; i += 1) {\n    if (l[i] == 0) {\n      continue;\n    }\n    if (pairs.len == 0) {\n      pairs = vec![l[i]];\n      continue;\n    }\n    if (pairs[0] == l[i]) {\n      continue;\n    }\n    return true;\n  }\n  return false;\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `@`, or `|`, found `;`\n  --> /tmp/tmpsexjtlv8.rs:17:9\n   |\n17 |   for (i; i < l.len; i += 1) {\n   |         ^\n   |         |\n   |         expected one of `)`, `,`, `@`, or `|`\n   |         help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `<`\n  --> /tmp/tmpsexjtlv8.rs:17:13\n   |\n17 |   for (i; i < l.len; i += 1) {\n   |            -^ expected one of `)`, `,`, `@`, or `|`\n   |            |\n   |            help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `.`\n  --> /tmp/tmpsexjtlv8.rs:17:16\n   |\n17 |   for (i; i < l.len; i += 1) {\n   |                ^\n   |                |\n   |                expected one of `)`, `,`, `@`, or `|`\n   |                help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `;`\n  --> /tmp/tmpsexjtlv8.rs:17:20\n   |\n17 |   for (i; i < l.len; i += 1) {\n   |                    ^\n   |                    |\n   |                    expected one of `)`, `,`, `@`, or `|`\n   |                    help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `+=`\n  --> /tmp/tmpsexjtlv8.rs:17:24\n   |\n17 |   for (i; i < l.len; i += 1) {\n   |                        ^^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmpsexjtlv8.rs:17:23\n   |\n17 |   for (i; i < l.len; i += 1) {\n   |                       ^ help: try adding `in` here\n\nerror: expected expression, found `+=`\n  --> /tmp/tmpsexjtlv8.rs:17:24\n   |\n17 |   for (i; i < l.len; i += 1) {\n   |                        ^^ expected expression\n\nerror: aborting due to 7 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// pairs_sum_to_zero takes a vector of integers as an input.\n/// it returns true if there are two distinct elements in the vector that\n/// sum to zero, and false otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n/// true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n  let mut pairs: Vec<(isize, isize)> = Vec::new();\n  let mut i: isize = 0;\n  let mut j: isize = 0;\n  let mut sum: isize = 0;\n  let mut count: isize = 0;\n  let mut found: bool = false;\n  for i in l {\n    if i == 0 {\n      continue;\n    }\n    sum += i;\n    if found {\n      continue;\n    }\n    if sum == 0 {\n      found = true;\n      continue;\n    }\n    pairs.push((i, sum));\n  }\n  for i in l {\n    if i == 0 {\n      continue;\n    }\n    sum -= i;\n    if found {\n      continue;\n    }\n    if sum == 0 {\n      found = true;\n      continue;\n    }\n    pairs.push((i, sum));\n  }\n  for i in l {\n    if i == 0 {\n      continue;\n    }\n    sum -= i;\n    if found {\n      continue;\n    }\n    if sum == 0 {\n      found = true;\n      continue;\n    }\n    pairs.push((i, sum));\n  }\n  for i in l {\n    if i == 0 {\n      continue;\n    }\n    sum += i;\n    if found {\n      continue;\n    }\n    if sum == 0 {\n      found = true;\n      continue;\n    }\n    pairs.push((i, sum));\n  }\n  for i in l {\n    if i == 0 {\n      continue;\n    }\n    sum += i;\n    if found {\n      continue;\n    }\n    if sum == 0 {\n      found = true;\n      continue;\n    }\n    pairs.push((i, sum));\n  }\n  for i in l {\n    if i == 0 {\n      continue;\n    }\n    sum -= i;\n    if found {\n      continue;\n    }\n    if sum == 0 {\n      found = true;\n      continue;\n    }\n    pairs.push((i, sum));\n  }\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error[E0308]: mismatched types\n   --> /tmp/tmpnihcdfr9.rs:91:3\n    |\n14  |   fn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n    |                                          ---- expected `bool` because of return type\n...\n91  | /   for i in l {\n92  | |     if i == 0 {\n93  | |       continue;\n94  | |     }\n...   |\n103 | |     pairs.push((i, sum));\n104 | |   }\n    | |___^ expected `bool`, found `()`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// pairs_sum_to_zero takes a vector of integers as an input.\n/// it returns true if there are two distinct elements in the vector that\n/// sum to zero, and false otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n/// true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n  let mut pairs = Vec::new();\n  let mut count = 0;\n  for (let i = 0; i < l.len(); i++) {\n    if (l[i] == 0) {\n      count += 1;\n      continue;\n    }\n    if (count > 0) {\n      pairs.push(i);\n      count = 0;\n    }\n  }\n  if (count > 0) {\n    pairs.push(l.len());\n  }\n  return !pairs.is_empty();\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmpr11elkf9.rs:17:8\n   |\n17 |   for (let i = 0; i < l.len(); i++) {\n   |        ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmpr11elkf9.rs:17:12\n   |\n17 |   for (let i = 0; i < l.len(); i++) {\n   |           -^ expected one of `)`, `,`, `@`, or `|`\n   |           |\n   |           help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmpr11elkf9.rs:17:14\n   |\n17 |   for (let i = 0; i < l.len(); i++) {\n   |              ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmpr11elkf9.rs:17:13\n   |\n17 |   for (let i = 0; i < l.len(); i++) {\n   |             ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmpr11elkf9.rs:17:14\n   |\n17 |   for (let i = 0; i < l.len(); i++) {\n   |              ^ expected expression\n\nerror: aborting due to 5 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// pairs_sum_to_zero takes a vector of integers as an input.\n/// it returns true if there are two distinct elements in the vector that\n/// sum to zero, and false otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n/// true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n  let mut pairs = false;\n  for i in 0..l.len() {\n    for j in 0..i {\n      if l[i] + l[j] == 0 {\n        pairs = true;\n        break;\n      }\n    }\n    if pairs {\n      break;\n    }\n  }\n  return pairs;\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// pairs_sum_to_zero takes a vector of integers as an input.\n/// it returns true if there are two distinct elements in the vector that\n/// sum to zero, and false otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n/// true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n  let sum = 0;\n  for i in l {\n    sum += i;\n  }\n  return sum == 0;\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `sum`\n  --> /tmp/tmpmglw88cw.rs:17:5\n   |\n15 |   let sum = 0;\n   |       ---\n   |       |\n   |       first assignment to `sum`\n   |       help: consider making this binding mutable: `mut sum`\n16 |   for i in l {\n17 |     sum += i;\n   |     ^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// pairs_sum_to_zero takes a vector of integers as an input.\n/// it returns true if there are two distinct elements in the vector that\n/// sum to zero, and false otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n/// true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n  let mut pairs = Vec::new();\n  for (let i = 0; i < l.len(); i += 2) {\n    let a = l[i];\n    let b = l[i + 1];\n    if (a + b == 0) {\n      pairs.push(a);\n      pairs.push(b);\n    }\n  }\n  return !pairs.is_empty();\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmpa0mrriuv.rs:16:8\n   |\n16 |   for (let i = 0; i < l.len(); i += 2) {\n   |        ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmpa0mrriuv.rs:16:12\n   |\n16 |   for (let i = 0; i < l.len(); i += 2) {\n   |           -^ expected one of `)`, `,`, `@`, or `|`\n   |           |\n   |           help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmpa0mrriuv.rs:16:14\n   |\n16 |   for (let i = 0; i < l.len(); i += 2) {\n   |              ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmpa0mrriuv.rs:16:13\n   |\n16 |   for (let i = 0; i < l.len(); i += 2) {\n   |             ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmpa0mrriuv.rs:16:14\n   |\n16 |   for (let i = 0; i < l.len(); i += 2) {\n   |              ^ expected expression\n\nerror: aborting due to 5 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// pairs_sum_to_zero takes a vector of integers as an input.\n/// it returns true if there are two distinct elements in the vector that\n/// sum to zero, and false otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n/// true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n  let sum = 0;\n  for i in l {\n    sum += i;\n  }\n  return sum == 0;\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `sum`\n  --> /tmp/tmpmglw88cw.rs:17:5\n   |\n15 |   let sum = 0;\n   |       ---\n   |       |\n   |       first assignment to `sum`\n   |       help: consider making this binding mutable: `mut sum`\n16 |   for i in l {\n17 |     sum += i;\n   |     ^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// pairs_sum_to_zero takes a vector of integers as an input.\n/// it returns true if there are two distinct elements in the vector that\n/// sum to zero, and false otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n/// true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n  let sum = 0;\n  for i in l {\n    sum += i;\n  }\n  return sum == 0;\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `sum`\n  --> /tmp/tmpmglw88cw.rs:17:5\n   |\n15 |   let sum = 0;\n   |       ---\n   |       |\n   |       first assignment to `sum`\n   |       help: consider making this binding mutable: `mut sum`\n16 |   for i in l {\n17 |     sum += i;\n   |     ^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// pairs_sum_to_zero takes a vector of integers as an input.\n/// it returns true if there are two distinct elements in the vector that\n/// sum to zero, and false otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n/// true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n  let sum = 0;\n  for i in l {\n    sum += i;\n  }\n  return sum == 0;\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `sum`\n  --> /tmp/tmpmglw88cw.rs:17:5\n   |\n15 |   let sum = 0;\n   |       ---\n   |       |\n   |       first assignment to `sum`\n   |       help: consider making this binding mutable: `mut sum`\n16 |   for i in l {\n17 |     sum += i;\n   |     ^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// pairs_sum_to_zero takes a vector of integers as an input.\n/// it returns true if there are two distinct elements in the vector that\n/// sum to zero, and false otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n/// true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n  let sum = 0;\n  for i in l {\n    sum += i;\n  }\n  if sum == 0 {\n    return false;\n  }\n  for i in l {\n    if i == 0 {\n      continue;\n    }\n    if sum - i == 0 {\n      return true;\n    }\n  }\n  return false;\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `sum`\n  --> /tmp/tmpaswqet35.rs:17:5\n   |\n15 |   let sum = 0;\n   |       ---\n   |       |\n   |       first assignment to `sum`\n   |       help: consider making this binding mutable: `mut sum`\n16 |   for i in l {\n17 |     sum += i;\n   |     ^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0382]: use of moved value: `l`\n   --> /tmp/tmpaswqet35.rs:22:12\n    |\n14  | fn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n    |                      - move occurs because `l` has type `Vec<isize>`, which does not implement the `Copy` trait\n15  |   let sum = 0;\n16  |   for i in l {\n    |            - `l` moved due to this implicit call to `.into_iter()`\n...\n22  |   for i in l {\n    |            ^ value used here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `l`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n16  |   for i in &l {\n    |            +\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations: E0382, E0384.\nFor more information about an error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// pairs_sum_to_zero takes a vector of integers as an input.\n/// it returns true if there are two distinct elements in the vector that\n/// sum to zero, and false otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n/// true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n  let count = 0;\n  for i in 0..l.len - 1 {\n    if l[i] == 0 {\n      count += 1;\n      if count == 2 {\n        return true;\n      }\n    }\n  }\n  return false;\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error[E0616]: field `len` of struct `Vec` is private\n  --> /tmp/tmpoiv2g13i.rs:16:17\n   |\n16 |   for i in 0..l.len - 1 {\n   |                 ^^^ private field\n   |\nhelp: a method `len` also exists, call it with parentheses\n   |\n16 |   for i in 0..l.len() - 1 {\n   |                    ++\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0616`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// pairs_sum_to_zero takes a vector of integers as an input.\n/// it returns true if there are two distinct elements in the vector that\n/// sum to zero, and false otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n/// true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n  let mut pairs = Vec::new();\n  let mut pairs_count = 0;\n  for i in l {\n    if i == 0 {\n      continue;\n    }\n    if i % 2 == 0 {\n      pairs.push(i);\n      pairs_count += 1;\n    }\n  }\n  if pairs_count == 0 {\n    return false;\n  }\n  if pairs_count == 1 {\n    return true;\n  }\n  let mut pairs_sum = 0;\n  for i in pairs {\n    pairs_sum += i;\n  }\n  return pairs_sum == 0;\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n",
      "timestamp": 1664293222,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `true`,\n right: `false`', /tmp/tmppea634x1.rs:42:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// pairs_sum_to_zero takes a vector of integers as an input.\n/// it returns true if there are two distinct elements in the vector that\n/// sum to zero, and false otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n/// true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n  let mut pairs = Vec::new();\n  let mut count = 0;\n  for (let i = 0; i < l.len(); i++) {\n    if (l[i] == 0) {\n      count += 1;\n      continue;\n    }\n    if (count > 0) {\n      pairs.push(i - count);\n      count = 0;\n    }\n  }\n  if (count > 0) {\n    pairs.push(l.len() - count);\n  }\n  return !pairs.is_empty();\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmpj227c08a.rs:17:8\n   |\n17 |   for (let i = 0; i < l.len(); i++) {\n   |        ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmpj227c08a.rs:17:12\n   |\n17 |   for (let i = 0; i < l.len(); i++) {\n   |           -^ expected one of `)`, `,`, `@`, or `|`\n   |           |\n   |           help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmpj227c08a.rs:17:14\n   |\n17 |   for (let i = 0; i < l.len(); i++) {\n   |              ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmpj227c08a.rs:17:13\n   |\n17 |   for (let i = 0; i < l.len(); i++) {\n   |             ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmpj227c08a.rs:17:14\n   |\n17 |   for (let i = 0; i < l.len(); i++) {\n   |              ^ expected expression\n\nerror: aborting due to 5 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// pairs_sum_to_zero takes a vector of integers as an input.\n/// it returns true if there are two distinct elements in the vector that\n/// sum to zero, and false otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n/// true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n  let mut pairs = Vec::new();\n  for (let i = 0; i < l.len(); i += 2) {\n    let a = l[i];\n    let b = l[i + 1];\n    if (a == b) {\n      continue;\n    }\n    if (a + b == 0) {\n      pairs.push(a);\n      pairs.push(b);\n    }\n  }\n  return !pairs.is_empty();\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmpqe844ohn.rs:16:8\n   |\n16 |   for (let i = 0; i < l.len(); i += 2) {\n   |        ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmpqe844ohn.rs:16:12\n   |\n16 |   for (let i = 0; i < l.len(); i += 2) {\n   |           -^ expected one of `)`, `,`, `@`, or `|`\n   |           |\n   |           help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmpqe844ohn.rs:16:14\n   |\n16 |   for (let i = 0; i < l.len(); i += 2) {\n   |              ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmpqe844ohn.rs:16:13\n   |\n16 |   for (let i = 0; i < l.len(); i += 2) {\n   |             ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmpqe844ohn.rs:16:14\n   |\n16 |   for (let i = 0; i < l.len(); i += 2) {\n   |              ^ expected expression\n\nerror: aborting due to 5 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// pairs_sum_to_zero takes a vector of integers as an input.\n/// it returns true if there are two distinct elements in the vector that\n/// sum to zero, and false otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n/// true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n  let mut pairs = vec![];\n  for (i, j) in l.iter().enumerate() {\n    if i == j {\n      continue;\n    }\n    if l[i] + l[j] == 0 {\n      pairs.push(i, j);\n    }\n  }\n  return !pairs.is_empty();\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error[E0308]: mismatched types\n  --> /tmp/tmph6000n5m.rs:17:13\n   |\n17 |     if i == j {\n   |             ^ expected `usize`, found `&isize`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `&isize`\n  --> /tmp/tmph6000n5m.rs:20:15\n   |\n20 |     if l[i] + l[j] == 0 {\n   |               ^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>` is not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of the requirements on the impl of `Index<&isize>` for `Vec<isize>`\n\nerror[E0061]: this function takes 1 argument but 2 arguments were supplied\n    --> /tmp/tmph6000n5m.rs:21:13\n     |\n21   |       pairs.push(i, j);\n     |             ^^^^ -  - supplied 2 arguments\n     |             |\n     |             expected 1 argument\n     |\nnote: associated function defined here\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0061, E0277, E0308.\nFor more information about an error, try `rustc --explain E0061`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// pairs_sum_to_zero takes a vector of integers as an input.\n/// it returns true if there are two distinct elements in the vector that\n/// sum to zero, and false otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n/// true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n  let mut pairs = vec![];\n  for (i, j) in l.iter().enumerate() {\n    if i == j {\n      continue;\n    }\n    if (i + j) % 2 == 0 {\n      pairs.push(i, j);\n    }\n  }\n  return !pairs.is_empty();\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error[E0308]: mismatched types\n  --> /tmp/tmpw3x2fgvi.rs:17:13\n   |\n17 |     if i == j {\n   |             ^ expected `usize`, found `&isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpw3x2fgvi.rs:20:13\n   |\n20 |     if (i + j) % 2 == 0 {\n   |             ^ expected `usize`, found `isize`\n\nerror[E0277]: cannot add `&isize` to `usize`\n  --> /tmp/tmpw3x2fgvi.rs:20:11\n   |\n20 |     if (i + j) % 2 == 0 {\n   |           ^ no implementation for `usize + &isize`\n   |\n   = help: the trait `Add<&isize>` is not implemented for `usize`\n   = help: the following other types implement trait `Add<Rhs>`:\n             <&'a f32 as Add<f32>>\n             <&'a f64 as Add<f64>>\n             <&'a i128 as Add<i128>>\n             <&'a i16 as Add<i16>>\n             <&'a i32 as Add<i32>>\n             <&'a i64 as Add<i64>>\n             <&'a i8 as Add<i8>>\n             <&'a isize as Add<isize>>\n           and 48 others\n\nerror[E0061]: this function takes 1 argument but 2 arguments were supplied\n    --> /tmp/tmpw3x2fgvi.rs:21:13\n     |\n21   |       pairs.push(i, j);\n     |             ^^^^ -  - supplied 2 arguments\n     |             |\n     |             expected 1 argument\n     |\nnote: associated function defined here\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations: E0061, E0277, E0308.\nFor more information about an error, try `rustc --explain E0061`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// pairs_sum_to_zero takes a vector of integers as an input.\n/// it returns true if there are two distinct elements in the vector that\n/// sum to zero, and false otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n/// true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n  let sum = 0;\n  for i in l {\n    sum += i;\n  }\n  if sum == 0 {\n    return false;\n  }\n  for i in l {\n    if i == 0 {\n      continue;\n    }\n    if sum - i == 0 {\n      return true;\n    }\n  }\n  return false;\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `sum`\n  --> /tmp/tmpaswqet35.rs:17:5\n   |\n15 |   let sum = 0;\n   |       ---\n   |       |\n   |       first assignment to `sum`\n   |       help: consider making this binding mutable: `mut sum`\n16 |   for i in l {\n17 |     sum += i;\n   |     ^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0382]: use of moved value: `l`\n   --> /tmp/tmpaswqet35.rs:22:12\n    |\n14  | fn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n    |                      - move occurs because `l` has type `Vec<isize>`, which does not implement the `Copy` trait\n15  |   let sum = 0;\n16  |   for i in l {\n    |            - `l` moved due to this implicit call to `.into_iter()`\n...\n22  |   for i in l {\n    |            ^ value used here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `l`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n16  |   for i in &l {\n    |            +\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations: E0382, E0384.\nFor more information about an error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// pairs_sum_to_zero takes a vector of integers as an input.\n/// it returns true if there are two distinct elements in the vector that\n/// sum to zero, and false otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n/// true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n  let sum = 0;\n  for i in l {\n    sum += i;\n  }\n  if sum == 0 {\n    return false;\n  }\n  for i in l {\n    if i == 0 {\n      continue;\n    }\n    if sum - i == 0 {\n      return true;\n    }\n  }\n  return false;\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `sum`\n  --> /tmp/tmpaswqet35.rs:17:5\n   |\n15 |   let sum = 0;\n   |       ---\n   |       |\n   |       first assignment to `sum`\n   |       help: consider making this binding mutable: `mut sum`\n16 |   for i in l {\n17 |     sum += i;\n   |     ^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0382]: use of moved value: `l`\n   --> /tmp/tmpaswqet35.rs:22:12\n    |\n14  | fn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n    |                      - move occurs because `l` has type `Vec<isize>`, which does not implement the `Copy` trait\n15  |   let sum = 0;\n16  |   for i in l {\n    |            - `l` moved due to this implicit call to `.into_iter()`\n...\n22  |   for i in l {\n    |            ^ value used here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `l`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n16  |   for i in &l {\n    |            +\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations: E0382, E0384.\nFor more information about an error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// pairs_sum_to_zero takes a vector of integers as an input.\n/// it returns true if there are two distinct elements in the vector that\n/// sum to zero, and false otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n/// true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n  let mut pairs = vec![];\n  for (i, j) in l.iter().enumerate() {\n    if (j == 0) {\n      continue;\n    }\n    if (j == i + 1) {\n      continue;\n    }\n    pairs.push(vec![i, j]);\n  }\n  return !pairs.is_empty();\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpl77p7uww.rs:17:8\n   |\n17 |     if (j == 0) {\n   |        ^      ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n17 -     if (j == 0) {\n17 +     if j == 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpl77p7uww.rs:20:8\n   |\n20 |     if (j == i + 1) {\n   |        ^          ^\n   |\nhelp: remove these parentheses\n   |\n20 -     if (j == i + 1) {\n20 +     if j == i + 1 {\n   | \n\nerror[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmpl77p7uww.rs:17:11\n   |\n17 |     if (j == 0) {\n   |           ^^ no implementation for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>` is not implemented for `&isize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n             i16\n             i32\n             i64\n             i8\n             isize\n           and 6 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpl77p7uww.rs:20:14\n   |\n20 |     if (j == i + 1) {\n   |              ^^^^^ expected `isize`, found `usize`\n\nerror[E0277]: can't compare `&isize` with `usize`\n  --> /tmp/tmpl77p7uww.rs:20:11\n   |\n20 |     if (j == i + 1) {\n   |           ^^ no implementation for `&isize == usize`\n   |\n   = help: the trait `PartialEq<usize>` is not implemented for `&isize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n             i16\n             i32\n             i64\n             i8\n             isize\n           and 6 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpl77p7uww.rs:23:24\n   |\n23 |     pairs.push(vec![i, j]);\n   |                        ^ expected `usize`, found `&isize`\n\nerror: aborting due to 4 previous errors; 2 warnings emitted\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// pairs_sum_to_zero takes a vector of integers as an input.\n/// it returns true if there are two distinct elements in the vector that\n/// sum to zero, and false otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n/// true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n  let sum = 0;\n  for i in l {\n    sum += i;\n  }\n  return sum == 0;\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `sum`\n  --> /tmp/tmpmglw88cw.rs:17:5\n   |\n15 |   let sum = 0;\n   |       ---\n   |       |\n   |       first assignment to `sum`\n   |       help: consider making this binding mutable: `mut sum`\n16 |   for i in l {\n17 |     sum += i;\n   |     ^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// pairs_sum_to_zero takes a vector of integers as an input.\n/// it returns true if there are two distinct elements in the vector that\n/// sum to zero, and false otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n/// true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n  let sum = 0;\n  for i in l {\n    sum += i;\n  }\n  if sum == 0 {\n    return false;\n  }\n  for i in l {\n    if i == sum {\n      return true;\n    }\n  }\n  return false;\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `sum`\n  --> /tmp/tmpuydl7qjm.rs:17:5\n   |\n15 |   let sum = 0;\n   |       ---\n   |       |\n   |       first assignment to `sum`\n   |       help: consider making this binding mutable: `mut sum`\n16 |   for i in l {\n17 |     sum += i;\n   |     ^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0382]: use of moved value: `l`\n   --> /tmp/tmpuydl7qjm.rs:22:12\n    |\n14  | fn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n    |                      - move occurs because `l` has type `Vec<isize>`, which does not implement the `Copy` trait\n15  |   let sum = 0;\n16  |   for i in l {\n    |            - `l` moved due to this implicit call to `.into_iter()`\n...\n22  |   for i in l {\n    |            ^ value used here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `l`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n16  |   for i in &l {\n    |            +\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations: E0382, E0384.\nFor more information about an error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// pairs_sum_to_zero takes a vector of integers as an input.\n/// it returns true if there are two distinct elements in the vector that\n/// sum to zero, and false otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n/// true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n  let sum = 0;\n  for i in l {\n    sum += i;\n  }\n  return sum == 0;\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `sum`\n  --> /tmp/tmpmglw88cw.rs:17:5\n   |\n15 |   let sum = 0;\n   |       ---\n   |       |\n   |       first assignment to `sum`\n   |       help: consider making this binding mutable: `mut sum`\n16 |   for i in l {\n17 |     sum += i;\n   |     ^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// pairs_sum_to_zero takes a vector of integers as an input.\n/// it returns true if there are two distinct elements in the vector that\n/// sum to zero, and false otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n/// true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n  let sum = 0;\n  for i in l {\n    sum += i;\n  }\n  return sum == 0;\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `sum`\n  --> /tmp/tmpmglw88cw.rs:17:5\n   |\n15 |   let sum = 0;\n   |       ---\n   |       |\n   |       first assignment to `sum`\n   |       help: consider making this binding mutable: `mut sum`\n16 |   for i in l {\n17 |     sum += i;\n   |     ^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// pairs_sum_to_zero takes a vector of integers as an input.\n/// it returns true if there are two distinct elements in the vector that\n/// sum to zero, and false otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n/// true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n  let mut pairs = Vec::new();\n  for (let i = 0; i < l.len(); i += 2) {\n    let a = l[i];\n    let b = l[i + 1];\n    if (a + b == 0) {\n      pairs.push(a);\n      pairs.push(b);\n    }\n  }\n  return !pairs.is_empty();\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmpa0mrriuv.rs:16:8\n   |\n16 |   for (let i = 0; i < l.len(); i += 2) {\n   |        ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmpa0mrriuv.rs:16:12\n   |\n16 |   for (let i = 0; i < l.len(); i += 2) {\n   |           -^ expected one of `)`, `,`, `@`, or `|`\n   |           |\n   |           help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmpa0mrriuv.rs:16:14\n   |\n16 |   for (let i = 0; i < l.len(); i += 2) {\n   |              ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmpa0mrriuv.rs:16:13\n   |\n16 |   for (let i = 0; i < l.len(); i += 2) {\n   |             ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmpa0mrriuv.rs:16:14\n   |\n16 |   for (let i = 0; i < l.len(); i += 2) {\n   |              ^ expected expression\n\nerror: aborting due to 5 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// pairs_sum_to_zero takes a vector of integers as an input.\n/// it returns true if there are two distinct elements in the vector that\n/// sum to zero, and false otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n/// true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n  let sum = 0;\n  for i in l {\n    sum += i;\n  }\n  return sum == 0;\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `sum`\n  --> /tmp/tmpmglw88cw.rs:17:5\n   |\n15 |   let sum = 0;\n   |       ---\n   |       |\n   |       first assignment to `sum`\n   |       help: consider making this binding mutable: `mut sum`\n16 |   for i in l {\n17 |     sum += i;\n   |     ^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// pairs_sum_to_zero takes a vector of integers as an input.\n/// it returns true if there are two distinct elements in the vector that\n/// sum to zero, and false otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n/// true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n  let mut pairs = Vec::new();\n  for (i, j) in l.iter().enumerate() {\n    if (j == 0) {\n      continue;\n    }\n    if (pairs.contains(i) || pairs.contains(j - i)) {\n      return false;\n    }\n    pairs.push(i);\n    pairs.push(j - i);\n  }\n  return true;\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "warning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpw9oyjhz7.rs:17:8\n   |\n17 |     if (j == 0) {\n   |        ^      ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n17 -     if (j == 0) {\n17 +     if j == 0 {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpw9oyjhz7.rs:20:8\n   |\n20 |     if (pairs.contains(i) || pairs.contains(j - i)) {\n   |        ^                                          ^\n   |\nhelp: remove these parentheses\n   |\n20 -     if (pairs.contains(i) || pairs.contains(j - i)) {\n20 +     if pairs.contains(i) || pairs.contains(j - i) {\n   | \n\nerror[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmpw9oyjhz7.rs:17:11\n   |\n17 |     if (j == 0) {\n   |           ^^ no implementation for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>` is not implemented for `&isize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n             i16\n             i32\n             i64\n             i8\n             isize\n           and 6 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpw9oyjhz7.rs:20:24\n   |\n20 |     if (pairs.contains(i) || pairs.contains(j - i)) {\n   |                        ^\n   |                        |\n   |                        expected reference, found `usize`\n   |                        help: consider borrowing here: `&i`\n   |\n   = note: expected reference `&_`\n                   found type `usize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpw9oyjhz7.rs:20:49\n   |\n20 |     if (pairs.contains(i) || pairs.contains(j - i)) {\n   |                                                 ^ expected `isize`, found `usize`\n\nerror[E0277]: cannot subtract `usize` from `&isize`\n  --> /tmp/tmpw9oyjhz7.rs:20:47\n   |\n20 |     if (pairs.contains(i) || pairs.contains(j - i)) {\n   |                                               ^ no implementation for `&isize - usize`\n   |\n   = help: the trait `Sub<usize>` is not implemented for ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// pairs_sum_to_zero takes a vector of integers as an input.\n/// it returns true if there are two distinct elements in the vector that\n/// sum to zero, and false otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n/// true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n  if len(l) == 0 {\n    return false\n  }\n  let sum = 0\n  for i in l {\n    sum += i\n  }\n  return sum == 0\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error: expected `;`, found keyword `for`\n  --> /tmp/tmp2yy8j8ut.rs:18:14\n   |\n18 |   let sum = 0\n   |              ^ help: add `;` here\n19 |   for i in l {\n   |   --- unexpected token\n\nerror[E0425]: cannot find function `len` in this scope\n  --> /tmp/tmp2yy8j8ut.rs:15:6\n   |\n15 |   if len(l) == 0 {\n   |      ^^^ not found in this scope\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// pairs_sum_to_zero takes a vector of integers as an input.\n/// it returns true if there are two distinct elements in the vector that\n/// sum to zero, and false otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n/// true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n  let mut pairs = false;\n  for i in 0..l.len() {\n    let mut j = i + 1;\n    while j < l.len() && l[i] + l[j] == 0 {\n      j += 1;\n    }\n    if j - i > 1 {\n      pairs = true;\n      break;\n    }\n  }\n  return pairs;\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n",
      "timestamp": 1664293222,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmpg0nx7afp.rs:34:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// pairs_sum_to_zero takes a vector of integers as an input.\n/// it returns true if there are two distinct elements in the vector that\n/// sum to zero, and false otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n/// true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n  let mut pairs = vec![];\n  for i in l {\n    if i == 0 {\n      continue;\n    }\n    if i == -i {\n      pairs.push(i, i);\n    } else {\n      pairs.push(i, -i);\n    }\n  }\n  let mut count = 0;\n  for i in pairs {\n    if i.x == i.y {\n      count += 1;\n    }\n  }\n  return count == 2;\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error[E0061]: this function takes 1 argument but 2 arguments were supplied\n    --> /tmp/tmp2watkg3o.rs:21:13\n     |\n21   |       pairs.push(i, i);\n     |             ^^^^ -  - supplied 2 arguments\n     |             |\n     |             expected 1 argument\n     |\nnote: associated function defined here\n\nerror[E0061]: this function takes 1 argument but 2 arguments were supplied\n    --> /tmp/tmp2watkg3o.rs:23:13\n     |\n23   |       pairs.push(i, -i);\n     |             ^^^^ -  -- supplied 2 arguments\n     |             |\n     |             expected 1 argument\n     |\nnote: associated function defined here\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0061`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// pairs_sum_to_zero takes a vector of integers as an input.\n/// it returns true if there are two distinct elements in the vector that\n/// sum to zero, and false otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n/// true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n  let sum = 0;\n  for i in l {\n    sum += i;\n  }\n  return sum == 0;\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `sum`\n  --> /tmp/tmpmglw88cw.rs:17:5\n   |\n15 |   let sum = 0;\n   |       ---\n   |       |\n   |       first assignment to `sum`\n   |       help: consider making this binding mutable: `mut sum`\n16 |   for i in l {\n17 |     sum += i;\n   |     ^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// pairs_sum_to_zero takes a vector of integers as an input.\n/// it returns true if there are two distinct elements in the vector that\n/// sum to zero, and false otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n/// true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n  let mut pairs = Vec::new();\n  for (let i = 0; i < l.len(); i += 2) {\n    let a = l[i];\n    let b = l[i + 1];\n    if (a + b == 0) {\n      pairs.push(a);\n      pairs.push(b);\n    }\n  }\n  return !pairs.is_empty();\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmpa0mrriuv.rs:16:8\n   |\n16 |   for (let i = 0; i < l.len(); i += 2) {\n   |        ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmpa0mrriuv.rs:16:12\n   |\n16 |   for (let i = 0; i < l.len(); i += 2) {\n   |           -^ expected one of `)`, `,`, `@`, or `|`\n   |           |\n   |           help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmpa0mrriuv.rs:16:14\n   |\n16 |   for (let i = 0; i < l.len(); i += 2) {\n   |              ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmpa0mrriuv.rs:16:13\n   |\n16 |   for (let i = 0; i < l.len(); i += 2) {\n   |             ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmpa0mrriuv.rs:16:14\n   |\n16 |   for (let i = 0; i < l.len(); i += 2) {\n   |              ^ expected expression\n\nerror: aborting due to 5 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// pairs_sum_to_zero takes a vector of integers as an input.\n/// it returns true if there are two distinct elements in the vector that\n/// sum to zero, and false otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n/// true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n  let sum = 0;\n  for i in l {\n    sum += i;\n  }\n  if sum == 0 {\n    return false;\n  }\n  for i in l {\n    if i == 0 {\n      continue;\n    }\n    if sum % i != 0 {\n      return false;\n    }\n  }\n  return true;\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `sum`\n  --> /tmp/tmp2j1r9dtj.rs:17:5\n   |\n15 |   let sum = 0;\n   |       ---\n   |       |\n   |       first assignment to `sum`\n   |       help: consider making this binding mutable: `mut sum`\n16 |   for i in l {\n17 |     sum += i;\n   |     ^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0382]: use of moved value: `l`\n   --> /tmp/tmp2j1r9dtj.rs:22:12\n    |\n14  | fn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n    |                      - move occurs because `l` has type `Vec<isize>`, which does not implement the `Copy` trait\n15  |   let sum = 0;\n16  |   for i in l {\n    |            - `l` moved due to this implicit call to `.into_iter()`\n...\n22  |   for i in l {\n    |            ^ value used here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `l`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n16  |   for i in &l {\n    |            +\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations: E0382, E0384.\nFor more information about an error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// pairs_sum_to_zero takes a vector of integers as an input.\n/// it returns true if there are two distinct elements in the vector that\n/// sum to zero, and false otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n/// true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n  let count = 0;\n  for i in 0..l.len - 1 {\n    if l[i] + l[i + 1] == 0 {\n      count += 1;\n    }\n  }\n  return count >= 2;\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error[E0616]: field `len` of struct `Vec` is private\n  --> /tmp/tmpmly2u2i0.rs:16:17\n   |\n16 |   for i in 0..l.len - 1 {\n   |                 ^^^ private field\n   |\nhelp: a method `len` also exists, call it with parentheses\n   |\n16 |   for i in 0..l.len() - 1 {\n   |                    ++\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0616`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// pairs_sum_to_zero takes a vector of integers as an input.\n/// it returns true if there are two distinct elements in the vector that\n/// sum to zero, and false otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n/// true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n  let mut pairs = Vec::new();\n  let mut seen = Vec::new();\n  for i in l {\n    if !seen.contains(i) {\n      pairs.push(i);\n      seen.push(i);\n    }\n  }\n  return !pairs.is_empty() && pairs.length() == 2;\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error[E0308]: mismatched types\n  --> /tmp/tmpfi4gk98v.rs:18:23\n   |\n18 |     if !seen.contains(i) {\n   |                       ^\n   |                       |\n   |                       expected reference, found `isize`\n   |                       help: consider borrowing here: `&i`\n   |\n   = note: expected reference `&_`\n                   found type `isize`\n\nerror[E0599]: no method named `length` found for struct `Vec<isize>` in the current scope\n  --> /tmp/tmpfi4gk98v.rs:23:37\n   |\n23 |   return !pairs.is_empty() && pairs.length() == 2;\n   |                                     ^^^^^^ help: there is an associated function with a similar name: `len`\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// pairs_sum_to_zero takes a vector of integers as an input.\n/// it returns true if there are two distinct elements in the vector that\n/// sum to zero, and false otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n/// true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n  let sum = 0;\n  for i in l {\n    sum += i;\n  }\n  return sum == 0;\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `sum`\n  --> /tmp/tmpmglw88cw.rs:17:5\n   |\n15 |   let sum = 0;\n   |       ---\n   |       |\n   |       first assignment to `sum`\n   |       help: consider making this binding mutable: `mut sum`\n16 |   for i in l {\n17 |     sum += i;\n   |     ^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// pairs_sum_to_zero takes a vector of integers as an input.\n/// it returns true if there are two distinct elements in the vector that\n/// sum to zero, and false otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n/// true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n  let mut pairs = vec![];\n  for i in l {\n    if i == 0 {\n      continue;\n    }\n    if i < 0 {\n      i = -i;\n    }\n    if i == 0 {\n      continue;\n    }\n    if i % 2 == 0 {\n      continue;\n    }\n    pairs.push_back(i);\n  }\n  if len(pairs) == 0 {\n    return false;\n  }\n  for i in 0..len(pairs) - 1 {\n    if pairs[i] + pairs[i + 1] == 0 {\n      return true;\n    }\n  }\n  return false;\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error[E0425]: cannot find function `len` in this scope\n  --> /tmp/tmpcydik1v2.rs:31:6\n   |\n31 |   if len(pairs) == 0 {\n   |      ^^^ not found in this scope\n\nerror[E0425]: cannot find function `len` in this scope\n  --> /tmp/tmpcydik1v2.rs:34:15\n   |\n34 |   for i in 0..len(pairs) - 1 {\n   |               ^^^ not found in this scope\n\nerror[E0599]: no method named `push_back` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmpcydik1v2.rs:29:11\n   |\n29 |     pairs.push_back(i);\n   |           ^^^^^^^^^ method not found in `Vec<_>`\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0425, E0599.\nFor more information about an error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// pairs_sum_to_zero takes a vector of integers as an input.\n/// it returns true if there are two distinct elements in the vector that\n/// sum to zero, and false otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n/// true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n  let mut pairs = Vec::new();\n  let mut i = 0;\n  let mut j = 0;\n  let mut sum = 0;\n  for (i = 0; i < l.len(); i++) {\n    sum = l[i];\n    for (j = i + 1; j < l.len(); j++) {\n      if (sum == l[j]) {\n        pairs.push_back(i);\n        pairs.push_back(j);\n        return true;\n      }\n    }\n  }\n  return false;\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmpkwkp2fnl.rs:19:10\n   |\n19 |   for (i = 0; i < l.len(); i++) {\n   |          ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmpkwkp2fnl.rs:19:9\n   |\n19 |   for (i = 0; i < l.len(); i++) {\n   |         ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmpkwkp2fnl.rs:19:10\n   |\n19 |   for (i = 0; i < l.len(); i++) {\n   |          ^ expected expression\n\nerror: aborting due to 3 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// pairs_sum_to_zero takes a vector of integers as an input.\n/// it returns true if there are two distinct elements in the vector that\n/// sum to zero, and false otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n/// true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n  let mut pairs = false;\n  for i in 0..l.len() {\n    for j in 0..i {\n      if l[i] + l[j] == 0 {\n        pairs = true;\n        break;\n      }\n    }\n    if pairs {\n      break;\n    }\n  }\n  return pairs;\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// pairs_sum_to_zero takes a vector of integers as an input.\n/// it returns true if there are two distinct elements in the vector that\n/// sum to zero, and false otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n/// true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n  let mut pairs = Vec::new();\n  let mut count = 0;\n  for (let i = 0; i < l.len; i++) {\n    let num = l[i];\n    if (num == 0) {\n      continue;\n    }\n    if (pairs.len > 0 && pairs[0] == num) {\n      continue;\n    }\n    pairs.push(num);\n    count++;\n  }\n  return count > 1;\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmpunrwbk9y.rs:17:8\n   |\n17 |   for (let i = 0; i < l.len; i++) {\n   |        ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmpunrwbk9y.rs:17:12\n   |\n17 |   for (let i = 0; i < l.len; i++) {\n   |           -^ expected one of `)`, `,`, `@`, or `|`\n   |           |\n   |           help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmpunrwbk9y.rs:17:14\n   |\n17 |   for (let i = 0; i < l.len; i++) {\n   |              ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmpunrwbk9y.rs:17:13\n   |\n17 |   for (let i = 0; i < l.len; i++) {\n   |             ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmpunrwbk9y.rs:17:14\n   |\n17 |   for (let i = 0; i < l.len; i++) {\n   |              ^ expected expression\n\nerror: aborting due to 5 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// pairs_sum_to_zero takes a vector of integers as an input.\n/// it returns true if there are two distinct elements in the vector that\n/// sum to zero, and false otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n/// true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n  let sum = 0;\n  for i in l {\n    sum += i;\n  }\n  if sum == 0 {\n    return false;\n  }\n  for i in l {\n    if i == 0 {\n      continue;\n    }\n    if sum - i == 0 {\n      return true;\n    }\n  }\n  return false;\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `sum`\n  --> /tmp/tmpaswqet35.rs:17:5\n   |\n15 |   let sum = 0;\n   |       ---\n   |       |\n   |       first assignment to `sum`\n   |       help: consider making this binding mutable: `mut sum`\n16 |   for i in l {\n17 |     sum += i;\n   |     ^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0382]: use of moved value: `l`\n   --> /tmp/tmpaswqet35.rs:22:12\n    |\n14  | fn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n    |                      - move occurs because `l` has type `Vec<isize>`, which does not implement the `Copy` trait\n15  |   let sum = 0;\n16  |   for i in l {\n    |            - `l` moved due to this implicit call to `.into_iter()`\n...\n22  |   for i in l {\n    |            ^ value used here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `l`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n16  |   for i in &l {\n    |            +\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations: E0382, E0384.\nFor more information about an error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// pairs_sum_to_zero takes a vector of integers as an input.\n/// it returns true if there are two distinct elements in the vector that\n/// sum to zero, and false otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n/// true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n  let mut pairs = false;\n  for i in 0..l.len() {\n    for j in 0..i {\n      if l[i] + l[j] == 0 {\n        pairs = true;\n        break;\n      }\n    }\n    if pairs {\n      break;\n    }\n  }\n  return pairs;\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "/// pairs_sum_to_zero takes a vector of integers as an input.\n/// it returns true if there are two distinct elements in the vector that\n/// sum to zero, and false otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n/// true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n  let sum = 0;\n  for i in l {\n    sum += i;\n  }\n  return sum == 0;\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `sum`\n  --> /tmp/tmpmglw88cw.rs:17:5\n   |\n15 |   let sum = 0;\n   |       ---\n   |       |\n   |       first assignment to `sum`\n   |       help: consider making this binding mutable: `mut sum`\n16 |   for i in l {\n17 |     sum += i;\n   |     ^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// pairs_sum_to_zero takes a vector of integers as an input.\n/// it returns true if there are two distinct elements in the vector that\n/// sum to zero, and false otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n/// true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n  let mut pairs = Vec::new();\n  for (let i = 0; i < l.len(); i++) {\n    for (let j = i + 1; j < l.len(); j++) {\n      let a = l[i];\n      let b = l[j];\n      if (a + b == 0) {\n        pairs.push_back(a);\n        pairs.push_back(b);\n      }\n    }\n  }\n  return !pairs.is_empty();\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmp72i5ekth.rs:16:8\n   |\n16 |   for (let i = 0; i < l.len(); i++) {\n   |        ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmp72i5ekth.rs:16:12\n   |\n16 |   for (let i = 0; i < l.len(); i++) {\n   |           -^ expected one of `)`, `,`, `@`, or `|`\n   |           |\n   |           help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmp72i5ekth.rs:16:14\n   |\n16 |   for (let i = 0; i < l.len(); i++) {\n   |              ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmp72i5ekth.rs:16:13\n   |\n16 |   for (let i = 0; i < l.len(); i++) {\n   |             ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmp72i5ekth.rs:16:14\n   |\n16 |   for (let i = 0; i < l.len(); i++) {\n   |              ^ expected expression\n\nerror: aborting due to 5 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// pairs_sum_to_zero takes a vector of integers as an input.\n/// it returns true if there are two distinct elements in the vector that\n/// sum to zero, and false otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n/// true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n  let sum = 0;\n  for i in l {\n    sum += i;\n  }\n  return sum == 0;\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `sum`\n  --> /tmp/tmpmglw88cw.rs:17:5\n   |\n15 |   let sum = 0;\n   |       ---\n   |       |\n   |       first assignment to `sum`\n   |       help: consider making this binding mutable: `mut sum`\n16 |   for i in l {\n17 |     sum += i;\n   |     ^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// pairs_sum_to_zero takes a vector of integers as an input.\n/// it returns true if there are two distinct elements in the vector that\n/// sum to zero, and false otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n/// true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n  let mut pairs: Vec<(isize, isize)> = Vec::new();\n  let mut count: isize = 0;\n  for (let i = 0; i < l.len(); i++) {\n    let num: isize = l[i];\n    if (num == 0) {\n      continue;\n    }\n    for (let j = i + 1; j < l.len(); j++) {\n      let num2: isize = l[j];\n      if (num + num2 == 0) {\n        pairs.push((i, j));\n        count += 1;\n      }\n    }\n  }\n  return count > 1;\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmphqexy6o6.rs:17:8\n   |\n17 |   for (let i = 0; i < l.len(); i++) {\n   |        ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmphqexy6o6.rs:17:12\n   |\n17 |   for (let i = 0; i < l.len(); i++) {\n   |           -^ expected one of `)`, `,`, `@`, or `|`\n   |           |\n   |           help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmphqexy6o6.rs:17:14\n   |\n17 |   for (let i = 0; i < l.len(); i++) {\n   |              ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmphqexy6o6.rs:17:13\n   |\n17 |   for (let i = 0; i < l.len(); i++) {\n   |             ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmphqexy6o6.rs:17:14\n   |\n17 |   for (let i = 0; i < l.len(); i++) {\n   |              ^ expected expression\n\nerror: aborting due to 5 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// pairs_sum_to_zero takes a vector of integers as an input.\n/// it returns true if there are two distinct elements in the vector that\n/// sum to zero, and false otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n/// true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n  let mut pairs = Vec::new();\n  let mut pairs_count = 0;\n  let mut pairs_sum = 0;\n  let mut pairs_sum_count = 0;\n  for i in l {\n    if i == 0 {\n      continue;\n    }\n    if i < 0 {\n      pairs_sum_count += 1;\n      pairs_sum += i;\n    } else {\n      pairs_count += 1;\n      pairs.push(i);\n    }\n  }\n  if pairs_count == 0 {\n    return false;\n  }\n  if pairs_sum_count == 0 {\n    return true;\n  }\n  if pairs_sum_count == 1 {\n    return false;\n  }\n  if pairs_sum_count == 2 {\n    return true;\n  }\n  return false;\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n",
      "timestamp": 1664293222,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `true`,\n right: `false`', /tmp/tmp0fw1trn9.rs:48:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// pairs_sum_to_zero takes a vector of integers as an input.\n/// it returns true if there are two distinct elements in the vector that\n/// sum to zero, and false otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n/// true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n  let mut pairs = Vec::new();\n  let mut i = 0;\n  for (i = 0; i < l.len(); i++) {\n    if (l[i] == 0) {\n      continue;\n    }\n    if (pairs.len() == 2) {\n      return false;\n    }\n    pairs.push(l[i]);\n  }\n  return true;\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmpc9d94d8h.rs:17:10\n   |\n17 |   for (i = 0; i < l.len(); i++) {\n   |          ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmpc9d94d8h.rs:17:9\n   |\n17 |   for (i = 0; i < l.len(); i++) {\n   |         ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmpc9d94d8h.rs:17:10\n   |\n17 |   for (i = 0; i < l.len(); i++) {\n   |          ^ expected expression\n\nerror: aborting due to 3 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// pairs_sum_to_zero takes a vector of integers as an input.\n/// it returns true if there are two distinct elements in the vector that\n/// sum to zero, and false otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n/// true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n  let mut pairs = Vec::new();\n  let mut pairs_count = 0;\n  let mut pairs_sum = 0;\n  let mut pairs_sum_count = 0;\n  for (let i = 0; i < l.len(); i++) {\n    let num = l[i];\n    if (num == 0) {\n      continue;\n    }\n    if (pairs_sum_count == 0) {\n      pairs_sum = num;\n      pairs_sum_count = 1;\n    } else if (pairs_sum == num) {\n      pairs_sum_count += 1;\n    } else {\n      pairs.push(pairs_sum_count);\n      pairs_sum = num;\n      pairs_sum_count = 1;\n    }\n  }\n  if (pairs_sum_count == 0) {\n    return false;\n  }\n  pairs.push(pairs_sum_count);\n  return true;\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmpmy7q247n.rs:19:8\n   |\n19 |   for (let i = 0; i < l.len(); i++) {\n   |        ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmpmy7q247n.rs:19:12\n   |\n19 |   for (let i = 0; i < l.len(); i++) {\n   |           -^ expected one of `)`, `,`, `@`, or `|`\n   |           |\n   |           help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmpmy7q247n.rs:19:14\n   |\n19 |   for (let i = 0; i < l.len(); i++) {\n   |              ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmpmy7q247n.rs:19:13\n   |\n19 |   for (let i = 0; i < l.len(); i++) {\n   |             ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmpmy7q247n.rs:19:14\n   |\n19 |   for (let i = 0; i < l.len(); i++) {\n   |              ^ expected expression\n\nerror: aborting due to 5 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// pairs_sum_to_zero takes a vector of integers as an input.\n/// it returns true if there are two distinct elements in the vector that\n/// sum to zero, and false otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n/// true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n  let sum = 0;\n  for i in l {\n    sum += i;\n  }\n  if sum == 0 {\n    return false;\n  }\n  for i in l {\n    if i == 0 {\n      continue;\n    }\n    if sum - i == 0 {\n      return true;\n    }\n  }\n  return false;\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `sum`\n  --> /tmp/tmpaswqet35.rs:17:5\n   |\n15 |   let sum = 0;\n   |       ---\n   |       |\n   |       first assignment to `sum`\n   |       help: consider making this binding mutable: `mut sum`\n16 |   for i in l {\n17 |     sum += i;\n   |     ^^^^^^^^ cannot assign twice to immutable variable\n\nerror[E0382]: use of moved value: `l`\n   --> /tmp/tmpaswqet35.rs:22:12\n    |\n14  | fn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n    |                      - move occurs because `l` has type `Vec<isize>`, which does not implement the `Copy` trait\n15  |   let sum = 0;\n16  |   for i in l {\n    |            - `l` moved due to this implicit call to `.into_iter()`\n...\n22  |   for i in l {\n    |            ^ value used here after move\n    |\nnote: this function takes ownership of the receiver `self`, which moves `l`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n16  |   for i in &l {\n    |            +\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations: E0382, E0384.\nFor more information about an error, try `rustc --explain E0382`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// pairs_sum_to_zero takes a vector of integers as an input.\n/// it returns true if there are two distinct elements in the vector that\n/// sum to zero, and false otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n/// true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n  let sum = 0;\n  for i in l {\n    sum += i;\n  }\n  return sum == 0;\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `sum`\n  --> /tmp/tmpmglw88cw.rs:17:5\n   |\n15 |   let sum = 0;\n   |       ---\n   |       |\n   |       first assignment to `sum`\n   |       help: consider making this binding mutable: `mut sum`\n16 |   for i in l {\n17 |     sum += i;\n   |     ^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// pairs_sum_to_zero takes a vector of integers as an input.\n/// it returns true if there are two distinct elements in the vector that\n/// sum to zero, and false otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n/// true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n  let sum = 0;\n  for i in l {\n    sum += i;\n  }\n  return sum == 0;\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error[E0384]: cannot assign twice to immutable variable `sum`\n  --> /tmp/tmpmglw88cw.rs:17:5\n   |\n15 |   let sum = 0;\n   |       ---\n   |       |\n   |       first assignment to `sum`\n   |       help: consider making this binding mutable: `mut sum`\n16 |   for i in l {\n17 |     sum += i;\n   |     ^^^^^^^^ cannot assign twice to immutable variable\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0384`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// pairs_sum_to_zero takes a vector of integers as an input.\n/// it returns true if there are two distinct elements in the vector that\n/// sum to zero, and false otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n/// true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n  let mut pairs = Vec::new();\n  for (i, j) in l.iter().zip(l.iter().rev()) {\n    if i == j {\n      continue;\n    }\n    if i + j == 0 {\n      pairs.push(i, j);\n    }\n  }\n  return !pairs.is_empty();\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error[E0061]: this function takes 1 argument but 2 arguments were supplied\n    --> /tmp/tmpu8dedk2u.rs:21:13\n     |\n21   |       pairs.push(i, j);\n     |             ^^^^ -  - supplied 2 arguments\n     |             |\n     |             expected 1 argument\n     |\nnote: associated function defined here\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0061`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// pairs_sum_to_zero takes a vector of integers as an input.\n/// it returns true if there are two distinct elements in the vector that\n/// sum to zero, and false otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n/// true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n  let mut pairs = Vec::new();\n  let mut count = 0;\n  for (let i = 0; i < l.len(); i++) {\n    if (l[i] == 0) {\n      count++;\n      continue;\n    }\n    if (count > 0) {\n      pairs.push(i - count);\n      count = 0;\n    }\n  }\n  if (count > 0) {\n    pairs.push(l.len() - count);\n  }\n  return !pairs.is_empty();\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmpils5vbsv.rs:17:8\n   |\n17 |   for (let i = 0; i < l.len(); i++) {\n   |        ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmpils5vbsv.rs:17:12\n   |\n17 |   for (let i = 0; i < l.len(); i++) {\n   |           -^ expected one of `)`, `,`, `@`, or `|`\n   |           |\n   |           help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmpils5vbsv.rs:17:14\n   |\n17 |   for (let i = 0; i < l.len(); i++) {\n   |              ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmpils5vbsv.rs:17:13\n   |\n17 |   for (let i = 0; i < l.len(); i++) {\n   |             ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmpils5vbsv.rs:17:14\n   |\n17 |   for (let i = 0; i < l.len(); i++) {\n   |              ^ expected expression\n\nerror: aborting due to 5 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// pairs_sum_to_zero takes a vector of integers as an input.\n/// it returns true if there are two distinct elements in the vector that\n/// sum to zero, and false otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n/// true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n  let mut pairs = Vec::new();\n  let mut i = 0;\n  let mut j = 0;\n  let mut sum = 0;\n  for (i = 0; i < l.len(); i++) {\n    sum = l[i];\n    for (j = i + 1; j < l.len(); j++) {\n      if (sum == l[j]) {\n        pairs.push_back(i);\n        pairs.push_back(j);\n        return true;\n      }\n    }\n  }\n  return false;\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmpkwkp2fnl.rs:19:10\n   |\n19 |   for (i = 0; i < l.len(); i++) {\n   |          ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmpkwkp2fnl.rs:19:9\n   |\n19 |   for (i = 0; i < l.len(); i++) {\n   |         ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmpkwkp2fnl.rs:19:10\n   |\n19 |   for (i = 0; i < l.len(); i++) {\n   |          ^ expected expression\n\nerror: aborting due to 3 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// pairs_sum_to_zero takes a vector of integers as an input.\n/// it returns true if there are two distinct elements in the vector that\n/// sum to zero, and false otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n/// true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n  let mut pairs = Vec::new();\n  let mut pairs_sum = 0;\n  let mut pairs_sum_prev = 0;\n  let mut pairs_sum_prev_prev = 0;\n  for i in l {\n    if i == 0 {\n      continue;\n    }\n    if i == -i {\n      pairs_sum += i;\n      pairs.push(i);\n      continue;\n    }\n    if i == pairs_sum_prev {\n      pairs_sum_prev_prev = pairs_sum_prev;\n      pairs_sum_prev = pairs_sum;\n      pairs_sum = i;\n      continue;\n    }\n    if i == pairs_sum_prev_prev {\n      pairs_sum_prev_prev = pairs_sum_prev;\n      pairs_sum_prev = i;\n      continue;\n    }\n    pairs.push(i);\n  }\n  return pairs_sum_prev_prev != 0 && pairs_sum_prev != 0 && pairs_sum != 0;\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n",
      "timestamp": 1664293222,
      "stdout": "",
      "stderr": "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `false`,\n right: `true`', /tmp/tmpvwntu89g.rs:49:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n",
      "exit_code": 101,
      "status": "Exception"
    },
    {
      "program": "/// pairs_sum_to_zero takes a vector of integers as an input.\n/// it returns true if there are two distinct elements in the vector that\n/// sum to zero, and false otherwise.\n/// >>> pairs_sum_to_zero(vec![1, 3, 5, 0])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 3, -2, 1])\n/// false\n/// >>> pairs_sum_to_zero(vec![1, 2, 3, 7])\n/// false\n/// >>> pairs_sum_to_zero(vec![2, 4, -5, 3, 5, 7])\n/// true\n/// >>> pairs_sum_to_zero(vec![1])\n/// false\nfn pairs_sum_to_zero(l: Vec<isize>) -> bool {\n  let mut pairs = Vec::new();\n  let mut seen = Vec::new();\n  for i in l {\n    if !seen.contains(&i) {\n      pairs.push(i);\n      seen.push(&i);\n    }\n  }\n  return !pairs.is_empty();\n}\n\nfn main() {\n    let candidate = pairs_sum_to_zero;\n    assert_eq!(candidate(vec![1, 3, 5, 0]), false);\n    assert_eq!(candidate(vec![1, 3, -2, 1]), false);\n    assert_eq!(candidate(vec![1, 2, 3, 7]), false);\n    assert_eq!(candidate(vec![2, 4, -5, 3, 5, 7]), true);\n    assert_eq!(candidate(vec![1]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 30]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 3, 2, 31]), true);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 30]), false);\n    assert_eq!(candidate(vec![-3, 9, -1, 4, 2, 31]), false);\n}\n",
      "timestamp": 1664293221,
      "stdout": "",
      "stderr": "error[E0308]: mismatched types\n  --> /tmp/tmpch6m1sup.rs:20:17\n   |\n20 |       seen.push(&i);\n   |                 ^^ expected `isize`, found `&isize`\n   |\nhelp: consider removing the borrow\n   |\n20 -       seen.push(&i);\n20 +       seen.push(i);\n   | \n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    }
  ]
}