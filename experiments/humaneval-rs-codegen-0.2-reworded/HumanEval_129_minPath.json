{
  "name": "HumanEval_129_minPath",
  "language": "rs",
  "prompt": "/// Given a grid with N rows and N columns (N >= 2) and a positive integer k, \n/// each cell of the grid contains a value. Every integer in the range [1, N * N]\n/// inclusive appears exactly once on the cells of the grid.\n/// You have to find the minimum path of length k in the grid. You can start\n/// from any cell, and in each step you can move to any of the neighbor cells,\n/// in other words, you can go to cells which share an edge with you current\n/// cell.\n/// Please note that a path of length k means visiting exactly k cells (not\n/// necessarily distinct).\n/// You CANNOT go off the grid.\n/// A path A (of length k) is considered less than a path B (of length k) if\n/// after making the ordered vectors of the values on the cells that A and B go\n/// through (let's call them lst_A and lst_B), lst_A is lexicographically less\n/// than lst_B, in other words, there exist an integer index i (1 <= i <= k)\n/// such that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n/// lst_A[j] = lst_B[j].\n/// It is guaranteed that the answer is unique.\n/// Return an ordered vector of the values on the cells that the minimum path go through.\n/// Examples:    \n/// >>> minPath(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]], 3)\n/// vec![1, 2, 1]\n/// >>> minPath(vec![vec![5, 9, 3], vec![4, 1, 6], vec![7, 8, 2]], 1)\n/// vec![1]\nfn minPath(grid: Vec<Vec<isize>>, k: isize) -> Vec<isize> {\n",
  "tests": "}\n\nfn main() {\n    let candidate = minPath;\n    assert_eq!(candidate(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]], 3), vec![1, 2, 1]);\n    assert_eq!(candidate(vec![vec![5, 9, 3], vec![4, 1, 6], vec![7, 8, 2]], 1), vec![1]);\n    assert_eq!(candidate(vec![vec![1, 2, 3, 4], vec![5, 6, 7, 8], vec![9, 10, 11, 12], vec![13, 14, 15, 16]], 4), vec![1, 2, 1, 2]);\n    assert_eq!(candidate(vec![vec![6, 4, 13, 10], vec![5, 7, 12, 1], vec![3, 16, 11, 15], vec![8, 14, 9, 2]], 7), vec![1, 10, 1, 10, 1, 10, 1]);\n    assert_eq!(candidate(vec![vec![8, 14, 9, 2], vec![6, 4, 13, 15], vec![5, 7, 1, 12], vec![3, 10, 11, 16]], 5), vec![1, 7, 1, 7, 1]);\n    assert_eq!(candidate(vec![vec![11, 8, 7, 2], vec![5, 16, 14, 4], vec![9, 3, 15, 6], vec![12, 13, 10, 1]], 9), vec![1, 6, 1, 6, 1, 6, 1, 6, 1]);\n    assert_eq!(candidate(vec![vec![12, 13, 10, 1], vec![9, 3, 15, 6], vec![5, 16, 14, 4], vec![11, 8, 7, 2]], 12), vec![1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6]);\n    assert_eq!(candidate(vec![vec![2, 7, 4], vec![3, 1, 5], vec![6, 8, 9]], 8), vec![1, 3, 1, 3, 1, 3, 1, 3]);\n    assert_eq!(candidate(vec![vec![6, 1, 5], vec![3, 8, 9], vec![2, 7, 4]], 8), vec![1, 5, 1, 5, 1, 5, 1, 5]);\n    assert_eq!(candidate(vec![vec![1, 2], vec![3, 4]], 10), vec![1, 2, 1, 2, 1, 2, 1, 2, 1, 2]);\n    assert_eq!(candidate(vec![vec![1, 3], vec![3, 2]], 10), vec![1, 3, 1, 3, 1, 3, 1, 3, 1, 3]);\n}\n",
  "completions": [
    "  let dfs = Dfs{grid, 0, 0};\n  let ans = dfs.dfs(k);\n  return ans;",
    "  let n = grid.len();\n  assert(n >= 2);\n  assert(k >= 1);\n  assert(all(grid, |&| grid.len() == grid[0].len()));\n  assert(all(grid, |&| grid.len() == grid[0][0] + 1));\n  assert(all(grid, |&| grid.len() == grid[0][0] + grid[0][1] + 1));\n  assert(all(grid, |&| grid.len() == grid[0][0] + grid[0][1] + grid[0][2] + 1));\n  assert(all(grid, |&| grid.len() == grid[0][0] + grid[0][1] + grid[0][2] + grid[0][3] + 1));\n  assert(all(grid, |&| grid.len() == grid[0][0] + grid[0][1] + grid[0][2] + grid[0][3] + grid[0][4] + 1));\n  assert(all(grid, |&| grid.len() == grid[0][0] + grid[0][1] + grid[0][2] + grid[0][3] + grid[0][4] + grid[0][5] + 1));\n  assert(all(grid, |&| grid.len() == grid[0][0] + grid[0][1] + grid[0][2] + grid[0][3] + grid[0][4] + grid[0][5] + grid[0][6] + 1));\n  assert(all(grid, |&| grid.len() == grid[0][0] + grid[0][1] + grid[0][2] + grid[0][3] + grid[0][4] + grid[0][5] + grid[0][6] + grid[0][7] + 1));\n  assert(all(grid, |&| grid.len() == grid[0][0] + grid[0][1] + grid[0][2] + grid[0][3] + grid[0][4] + grid[0][5] + grid[0][6] + grid[0][",
    "    let mut result = Vec::new();\n    let mut current = Vec::new();\n    let mut next = Vec::new();\n    let mut index = Vec::new();\n    let mut visited = Vec::new();\n    let mut min = Vec::new();\n    let mut min_index = 0;\n    let mut min_value = 0;\n    let mut min_i = 0;\n    let mut min_j = 0;\n    let mut min_k = 0;\n    let mut min_lst = Vec::new();\n    let mut min_lst_i = 0;\n    let mut min_lst_j = 0;\n    let mut min_lst_k = 0;\n    let mut min_lst_l = 0;\n    let mut min_lst_value = 0;\n    let mut min_lst_i_value = 0;\n    let mut min_lst_j_value = 0;\n    let mut min_lst_k_value = 0;\n    let mut min_lst_l_value = 0;\n    let mut min_lst_i_i = 0;\n    let mut min_lst_i_j = 0;\n    let mut min_lst_i_k = 0;\n    let mut min_lst_i_l = 0;\n    let mut min_lst_j_i = 0;\n    let mut min_lst_j_j = 0;\n    let mut min_lst_j_k = 0;\n    let mut min_lst_j_l = 0;\n    let mut min_lst_k_i = 0;\n    let mut min_lst_k_j = 0;\n    let mut min_lst_k_k = 0;\n    let mut min_lst_k_l = 0;\n    let mut min_lst_l_i = 0;\n    let mut min_lst_l_j = 0;\n    let mut min_lst_l_k = 0;\n    let mut min_lst_l_l = 0;\n    let mut min_lst_i_i_value = 0;\n    let mut min_lst",
    "  let grid_len = grid.len();\n  if grid_len < 2 {\n    return vec![];\n  }\n  let grid_len_sq = grid_len * grid_len;\n  let grid_len_sq_minus_k = grid_len_sq - k;\n  let grid_len_sq_minus_k_minus_1 = grid_len_sq_minus_k - 1;\n  let grid_len_sq_minus_k_minus_2 = grid_len_sq_minus_k - 2;\n  let grid_len_sq_minus_k_minus_3 = grid_len_sq_minus_k - 3;\n  let grid_len_sq_minus_k_minus_4 = grid_len_sq_minus_k - 4;\n  let grid_len_sq_minus_k_minus_5 = grid_len_sq_minus_k - 5;\n  let grid_len_sq_minus_k_minus_6 = grid_len_sq_minus_k - 6;\n  let grid_len_sq_minus_k_minus_7 = grid_len_sq_minus_k - 7;\n  let grid_len_sq_minus_k_minus_8 = grid_len_sq_minus_k - 8;\n  let grid_len_sq_minus_k_minus_9 = grid_len_sq_minus_k - 9;\n  let grid_len_sq_minus_k_minus_10 = grid_len_sq_minus_k - 10;\n  let grid_len_sq_minus_k_minus_11 = grid_len_sq_minus_k - 11;\n  let grid_len_sq_minus_k_minus_12 = grid_len_sq_minus_k - 12;\n  let grid_len_sq_minus_k_minus_13 = grid_len_sq_minus_k - 13;\n  let grid_len_sq_minus_k_minus_14 = grid_len_sq_minus_k - 14;\n  let grid_len_sq_minus_k_minus_15 = grid_len_sq_minus_k - 15;\n  let grid_len_sq_minus",
    "  let grid_len = grid.len();\n  let grid_len_sq = grid_len * grid_len;\n  let grid_len_sq_minus_1 = grid_len_sq - 1;\n  let grid_len_sq_minus_k = grid_len_sq - k;\n  let grid_len_sq_minus_k_minus_1 = grid_len_sq_minus_k - 1;\n  let grid_len_sq_minus_k_minus_k = grid_len_sq_minus_k - k;\n  let grid_len_sq_minus_k_minus_k_minus_1 = grid_len_sq_minus_k_minus_k - 1;\n  let grid_len_sq_minus_k_minus_k_minus_k = grid_len_sq_minus_k_minus_k - k;\n  let grid_len_sq_minus_k_minus_k_minus_k_minus_1 = grid_len_sq_minus_k_minus_k_minus_k - 1;\n  let grid_len_sq_minus_k_minus_k_minus_k_minus_k = grid_len_sq_minus_k_minus_k_minus_k - k;\n  let grid_len_sq_minus_k_minus_k_minus_k_minus_k_minus_1 = grid_len_sq_minus_k_minus_k_minus_k_minus_k - 1;\n  let grid_len_sq_minus_k_minus_k_minus_k_minus_k_minus_k = grid_len_sq_minus_k_minus_k_minus_k_minus_k - k;\n  let grid_len_sq_minus_k_minus_k_minus_k_minus_k_minus_k_minus_1 = grid_len_sq_minus_k_minus_k_minus_k_minus_k_minus_k - 1;\n  let grid_len_sq_minus_k_minus_k_minus_k_minus_k_minus_k_minus_k = grid_len_sq_minus_k_minus_k_minus_k_minus_k",
    "  let mut result = Vec::new();\n  let mut current = Vec::new();\n  let mut visited = Vec::new();\n  let mut queue = Vec::new();\n  let mut min_path = Vec::new();\n  let mut min_index = 0;\n  let mut min_value = 0;\n  let mut min_path_length = 0;\n  let mut min_path_index = 0;\n  let mut min_path_value = 0;\n  let mut min_path_length_index = 0;\n  let mut min_path_length_value = 0;\n  let mut min_path_length_index_value = 0;\n  let mut min_path_length_index_value_value = 0;\n  let mut min_path_length_index_value_value_value = 0;\n  let mut min_path_length_index_value_value_value_value = 0;\n  let mut min_path_length_index_value_value_value_value_value = 0;\n  let mut min_path_length_index_value_value_value_value_value_value = 0;\n  let mut min_path_length_index_value_value_value_value_value_value_value = 0;\n  let mut min_path_length_index_value_value_value_value_value_value_value_value = 0;\n  let mut min_path_length_index_value_value_value_value_value_value_value_value_value = 0;\n  let mut min_path_length_index_value_value_value_value_value_value_value_value_value_value = 0;\n  let mut min_path_length_index_value_value_value_value_value_value_value_value_value_value_value = 0;\n  let mut min_path_length_index_value_value_value_value_value_value_value_value_value_value_value_value = 0;\n  let mut min_path_length_index_value_value_value_value_value_value_value_value_value_value_value_value_value = 0;\n  let mut min_path_length_index_value",
    "  let grid_len = grid.len();\n  if grid_len < 2 {\n    return vec![];\n  }\n  let grid_len_sq = grid_len * grid_len;\n  let grid_len_sq_minus_1 = grid_len_sq - 1;\n  let grid_len_sq_minus_k = grid_len_sq - k;\n  let grid_len_sq_minus_k_minus_1 = grid_len_sq_minus_k - 1;\n  let grid_len_sq_minus_k_minus_2 = grid_len_sq_minus_k - 2;\n  let grid_len_sq_minus_k_minus_3 = grid_len_sq_minus_k - 3;\n  let grid_len_sq_minus_k_minus_4 = grid_len_sq_minus_k - 4;\n  let grid_len_sq_minus_k_minus_5 = grid_len_sq_minus_k - 5;\n  let grid_len_sq_minus_k_minus_6 = grid_len_sq_minus_k - 6;\n  let grid_len_sq_minus_k_minus_7 = grid_len_sq_minus_k - 7;\n  let grid_len_sq_minus_k_minus_8 = grid_len_sq_minus_k - 8;\n  let grid_len_sq_minus_k_minus_9 = grid_len_sq_minus_k - 9;\n  let grid_len_sq_minus_k_minus_10 = grid_len_sq_minus_k - 10;\n  let grid_len_sq_minus_k_minus_11 = grid_len_sq_minus_k - 11;\n  let grid_len_sq_minus_k_minus_12 = grid_len_sq_minus_k - 12;\n  let grid_len_sq_minus_k_minus_13 = grid_len_sq_minus_k - 13;\n  let grid_len_sq_minus_k_minus_14 = grid_len_sq_minus_k - 14;\n  let grid_len_sq_minus_k_minus_15 = grid",
    "    let grid_len = grid.len();\n    let grid_len_sq = grid_len * grid_len;\n    let grid_len_sq_minus_k = grid_len_sq - k;\n    let grid_len_sq_minus_k_minus_1 = grid_len_sq_minus_k - 1;\n    let grid_len_sq_minus_k_minus_2 = grid_len_sq_minus_k - 2;\n    let grid_len_sq_minus_k_minus_3 = grid_len_sq_minus_k - 3;\n    let grid_len_sq_minus_k_minus_4 = grid_len_sq_minus_k - 4;\n    let grid_len_sq_minus_k_minus_5 = grid_len_sq_minus_k - 5;\n    let grid_len_sq_minus_k_minus_6 = grid_len_sq_minus_k - 6;\n    let grid_len_sq_minus_k_minus_7 = grid_len_sq_minus_k - 7;\n    let grid_len_sq_minus_k_minus_8 = grid_len_sq_minus_k - 8;\n    let grid_len_sq_minus_k_minus_9 = grid_len_sq_minus_k - 9;\n    let grid_len_sq_minus_k_minus_10 = grid_len_sq_minus_k - 10;\n    let grid_len_sq_minus_k_minus_11 = grid_len_sq_minus_k - 11;\n    let grid_len_sq_minus_k_minus_12 = grid_len_sq_minus_k - 12;\n    let grid_len_sq_minus_k_minus_13 = grid_len_sq_minus_k - 13;\n    let grid_len_sq_minus_k_minus_14 = grid_len_sq_minus_k - 14;\n    let grid_len_sq_minus_k_minus_15 = grid_len_sq_minus_k - 15;\n    let grid_len_sq_minus_k_minus_16 = grid_len_sq_minus_k - 16;",
    "  let mut lst = Vec::new();\n  for (i in 0..k) {\n    lst.push(0);\n  }\n  for (i in 0..grid.len()) {\n    for (j in 0..grid[i].len()) {\n      if (lst[0] == 0) {\n        lst[0] = grid[i][j];\n      } else if (lst[0] > grid[i][j]) {\n        lst[0] = grid[i][j];\n      }\n    }\n  }\n  return lst;",
    "  let result = Vec::new();\n  let visited = Vec::new();\n  let queue = Vec::new();\n  let min = Vec::new();\n  let min_index = 0;\n  let min_value = 1;\n  let i = 0;\n  let j = 0;\n  let n = grid.len();\n  let m = grid[0].len();\n  for (i = 0; i < n; i++) {\n    for (j = 0; j < m; j++) {\n      if (grid[i][j] == 0) {\n        queue.push(i * m + j);\n        visited.push(0);\n      }\n    }\n  }\n  for (i = 0; i < n; i++) {\n    for (j = 0; j < m; j++) {\n      if (grid[i][j] == 0) {\n        min_value = 1;\n        min_index = 0;\n        queue.push(i * m + j);\n        visited.push(0);\n      }\n    }\n  }\n  while (queue.len() > 0) {\n    let cell = queue.pop();\n    let index = cell / m;\n    let value = cell % m;\n    if (visited[index] == 0) {\n      if (min_value > grid[index][value]) {\n        min_value = grid[index][value];\n        min_index = index;\n      }\n      visited[index] = 1;\n      for (i = 0; i < 4; i++) {\n        let next_cell = index + dx[i];\n        let next_value = value + dy[i];\n        if (next_cell >= 0 && next_cell < n && next_value >= 0 && next_value < m && grid[next_cell][next_value] == 0) {\n          queue.push(next_cell * m + next_value);\n          visited[next_cell] = 1;\n        }\n      }\n    }\n  }\n  result.push(min_index);\n  for (i = 0; i < k; i++) {\n    result.push(min[i]);\n  }",
    "  let n = grid.len();\n  let m = grid[0].len();\n  let dp = Vec::new(n * m);\n  for (let i = 0; i < n * m; i++) {\n    dp[i] = i + 1;\n  }\n  for (let i = 0; i < n; i++) {\n    for (let j = 0; j < m; j++) {\n      let min_i = dp[i * m + j];\n      for (let k = 0; k < n; k++) {\n        for (let l = 0; l < m; l++) {\n          if (grid[k][l] == grid[i][j]) {\n            let min_k = dp[k * m + l];\n            if (min_k < min_i) {\n              min_i = min_k;\n            }\n          }\n        }\n      }\n      dp[i * m + j] = min_i;\n    }\n  }\n  let res = Vec::new(k);\n  for (let i = 0; i < k; i++) {\n    res[i] = dp[i];\n  }\n  return res;",
    "  let m = grid.len();\n  let n = grid[0].len();\n  let dp = Vec::new(n + 1);\n  for (let i = 0; i < m; i++) {\n    for (let j = 0; j < n; j++) {\n      if (i == 0 && j == 0) {\n        dp[j + 1] = grid[i][j];\n      } else if (i == 0) {\n        dp[j + 1] = min(dp[j + 1], dp[j] + grid[i][j]);\n      } else if (j == 0) {\n        dp[j + 1] = min(dp[j + 1], dp[j] + grid[i][j]);\n      } else {\n        dp[j + 1] = min(dp[j + 1], dp[j] + grid[i][j], dp[j] + grid[i][j - 1]);\n      }\n    }\n  }\n  let ans = Vec::new(k);\n  for (let i = 0; i < k; i++) {\n    ans[i] = dp[n];\n  }\n  return ans;",
    "    let mut result = Vec::new();\n    let mut current = Vec::new();\n    let mut next = Vec::new();\n    let mut min = Vec::new();\n    let mut min_index = 0;\n    let mut min_value = 0;\n    let mut min_value_index = 0;\n    let mut min_value_value = 0;\n    let mut min_value_value_index = 0;\n    let mut min_value_value_value = 0;\n    let mut min_value_value_value_index = 0;\n    let mut min_value_value_value_value = 0;\n    let mut min_value_value_value_value_index = 0;\n    let mut min_value_value_value_value_value = 0;\n    let mut min_value_value_value_value_value_index = 0;\n    let mut min_value_value_value_value_value_value = 0;\n    let mut min_value_value_value_value_value_value_index = 0;\n    let mut min_value_value_value_value_value_value_value = 0;\n    let mut min_value_value_value_value_value_value_value_index = 0;\n    let mut min_value_value_value_value_value_value_value_value = 0;\n    let mut min_value_value_value_value_value_value_value_value_index = 0;\n    let mut min_value_value_value_value_value_value_value_value_value = 0;\n    let mut min_value_value_value_value_value_value_value_value_value_index = 0;\n    let mut min_value_value_value_value_value_value_value_value_value_value = 0;\n    let mut min_value_value_value_value_value_value_value_value_value_value_index = 0;\n    let mut min_value_value_value_value_value_value_value_value_value_value_value = 0;\n    let mut min_value_value_value_value_value_value_value_value_value_value_value_index = 0;\n",
    "  let n = grid.len();\n  let m = grid[0].len();\n  let dp = Vec::new(n * m);\n  for (let i = 0; i < n; i++) {\n    for (let j = 0; j < m; j++) {\n      if (i == 0 && j == 0) {\n        dp[0] = grid[i][j];\n      } else if (i == 0) {\n        dp[j] = grid[i][j];\n      } else if (j == 0) {\n        dp[i] = grid[i][j];\n      } else {\n        dp[i * m + j] = grid[i][j];\n        if (i > 0 && j > 0) {\n          dp[i * m + j] = min(dp[i * m + j], dp[i * m + j - 1] + grid[i][j]);\n          dp[i * m + j] = min(dp[i * m + j], dp[(i - 1) * m + j] + grid[i][j]);\n          dp[i * m + j] = min(dp[i * m + j], dp[i * m + j - m] + grid[i][j]);\n        }\n      }\n    }\n  }\n  let ans = Vec::new(k);\n  for (let i = 0; i < k; i++) {\n    ans[i] = dp[i * m + k - 1];\n  }\n  return ans;",
    "  let mut result = Vec::new();\n  let mut visited = Vec::new();\n  let mut queue = Vec::new();\n  let mut min_index = 0;\n  let mut min_value = 1;\n  let mut min_path = Vec::new();\n  let mut min_path_index = 0;\n  let mut min_path_value = 1;\n  let mut min_path_length = 0;\n  let mut min_path_index_length = 0;\n  let mut min_path_value_length = 0;\n  let mut min_path_length_length = 0;\n  let mut min_path_index_length_length = 0;\n  let mut min_path_value_length_length = 0;\n  let mut min_path_length_length_length = 0;\n  let mut min_path_index_length_length_length = 0;\n  let mut min_path_value_length_length_length = 0;\n  let mut min_path_length_length_length_length = 0;\n  let mut min_path_index_length_length_length_length = 0;\n  let mut min_path_value_length_length_length_length = 0;\n  let mut min_path_length_length_length_length_length = 0;\n  let mut min_path_index_length_length_length_length_length = 0;\n  let mut min_path_value_length_length_length_length_length = 0;\n  let mut min_path_length_length_length_length_length_length = 0;\n  let mut min_path_index_length_length_length_length_length_length = 0;\n  let mut min_path_value_length_length_length_length_length_length = 0;\n  let mut min_path_length_length_length_length_length_length_length = 0;\n  let mut min_path_index_length_length_length_length_length_length_length = 0;\n  let mut min_path_value_length_length_length_length_length_length_length = 0;\n  let mut min_path_length_length_length_length_length_length_length",
    "    let mut res = Vec::new();\n    let mut cur = Vec::new();\n    let mut prev = Vec::new();\n    let mut lst = Vec::new();\n    let mut i = 0;\n    for (i = 0; i < k; i++) {\n        prev = cur;\n        cur = Vec::new();\n        for (let j = 0; j < grid.len(); j++) {\n            if (grid[j].len() > i) {\n                cur.push_back(grid[j][i]);\n            }\n        }\n        lst.push_back(cur[0]);\n        for (let j = 1; j < cur.len(); j++) {\n            if (cur[j] < lst[j - 1]) {\n                lst[j] = cur[j];\n            }\n        }\n        if (lst[i] < lst[i - 1]) {\n            lst[i] = lst[i - 1];\n        }\n        if (lst[i] < prev[i]) {\n            res.push_back(lst[i]);\n        }\n    }\n    return res;",
    "  let mut result = Vec::new();\n  let mut min_path = Vec::new();\n  let mut min_path_index = 0;\n  let mut min_path_length = 0;\n  let mut min_path_cell = 0;\n  let mut min_path_cell_index = 0;\n  let mut min_path_cell_length = 0;\n  let mut min_path_cell_value = 0;\n  let mut min_path_cell_value_index = 0;\n  let mut min_path_cell_value_length = 0;\n  let mut min_path_cell_value_value = 0;\n  let mut min_path_cell_value_value_index = 0;\n  let mut min_path_cell_value_value_length = 0;\n  let mut min_path_cell_value_value_value = 0;\n  let mut min_path_cell_value_value_value_index = 0;\n  let mut min_path_cell_value_value_value_length = 0;\n  let mut min_path_cell_value_value_value_value = 0;\n  let mut min_path_cell_value_value_value_value_index = 0;\n  let mut min_path_cell_value_value_value_value_length = 0;\n  let mut min_path_cell_value_value_value_value_value = 0;\n  let mut min_path_cell_value_value_value_value_value_index = 0;\n  let mut min_path_cell_value_value_value_value_value_length = 0;\n  let mut min_path_cell_value_value_value_value_value_value = 0;\n  let mut min_path_cell_value_value_value_value_value_value_index = 0;\n  let mut min_path_cell_value_value_value_value_value_value_length = 0;\n  let mut min_path_cell_value_value_value_value_value_value_value = 0;\n  let mut min_path_cell_value_value_value_value_value_value_value_index = 0;\n  let mut min_path",
    "  let dfs = Dfs{grid, 0, 0};\n  let res = Vec::new();\n  for (let i = 0; i < grid.len(); i++) {\n    for (let j = 0; j < grid[i].len(); j++) {\n      if (grid[i][j] > 0) {\n        dfs.visit(i, j);\n      }\n    }\n  }\n  for (let i = 0; i < k; i++) {\n    res = res.push(dfs.path[i]);\n  }\n  return res;",
    "    let mut res = Vec::new();\n    let mut cur = Vec::new();\n    let mut prev = Vec::new();\n    let mut cur_len = 0;\n    let mut prev_len = 0;\n    let mut min_len = 0;\n    let mut min_index = 0;\n    let mut min_value = 0;\n    let mut min_value_index = 0;\n    for i in 0..grid.len() {\n        if cur_len == k {\n            min_value = cur[min_index];\n            min_value_index = i;\n            break;\n        }\n        if cur_len == 0 {\n            cur[0] = grid[i][0];\n            cur_len = 1;\n            prev_len = 1;\n            prev[0] = 0;\n            min_len = 1;\n            min_index = 0;\n            min_value = 0;\n            min_value_index = i;\n            continue;\n        }\n        for j in 0..grid.len() {\n            if i == j {\n                continue;\n            }\n            if grid[i][j] < grid[i][prev_len] {\n                prev_len = j;\n                prev[j] = i;\n            }\n        }\n        let mut cur_index = 0;\n        for j in 0..grid.len() {\n            if i == j {\n                continue;\n            }\n            if grid[i][j] < grid[prev[j]][cur_index] {\n                cur_index = j;\n                cur[j] = i;\n            }\n        }\n        cur_len += 1;\n        if cur_len < min_len {\n            min_len = cur_len;\n            min_index = cur_index;\n            min_value = grid[i][cur_index];\n            min_value_index = i;\n        }\n    }\n    res.push(min_value);\n    for i in 0..min_len {\n        res.push(grid[min_value_index][i]);\n    }\n    return res;",
    "    let mut result = Vec::new();\n    let mut min_path = Vec::new();\n    let mut min_path_length = 0;\n    let mut min_path_index = 0;\n    let mut min_path_index_length = 0;\n    let mut min_path_index_length_index = 0;\n    let mut min_path_index_length_index_index = 0;\n    let mut min_path_index_length_index_index_index = 0;\n    let mut min_path_index_length_index_index_index_index = 0;\n    let mut min_path_index_length_index_index_index_index_index = 0;\n    let mut min_path_index_length_index_index_index_index_index_index = 0;\n    let mut min_path_index_length_index_index_index_index_index_index_index = 0;\n    let mut min_path_index_length_index_index_index_index_index_index_index_index = 0;\n    let mut min_path_index_length_index_index_index_index_index_index_index_index_index = 0;\n    let mut min_path_index_length_index_index_index_index_index_index_index_index_index_index = 0;\n    let mut min_path_index_length_index_index_index_index_index_index_index_index_index_index_index = 0;\n    let mut min_path_index_length_index_index_index_index_index_index_index_index_index_index_index_index = 0;\n    let mut min_path_index_length_index_index_index_index_index_index_index_index_index_index_index_index_index = 0;\n    let mut min_path_index_length_index_index_index_index_index_index_index_index_index_index_index_index_index_index = 0;\n    let mut min_path_index_length_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index = 0;\n    let",
    "  let grid_len = grid.len();\n  let grid_len_sq = grid_len * grid_len;\n  let grid_len_sq_pow_k = grid_len_sq ** k;\n  let grid_len_sq_pow_k_minus_1 = grid_len_sq_pow_k - 1;\n  let grid_len_sq_pow_k_minus_2 = grid_len_sq_pow_k - 2;\n  let grid_len_sq_pow_k_minus_3 = grid_len_sq_pow_k - 3;\n  let grid_len_sq_pow_k_minus_4 = grid_len_sq_pow_k - 4;\n  let grid_len_sq_pow_k_minus_5 = grid_len_sq_pow_k - 5;\n  let grid_len_sq_pow_k_minus_6 = grid_len_sq_pow_k - 6;\n  let grid_len_sq_pow_k_minus_7 = grid_len_sq_pow_k - 7;\n  let grid_len_sq_pow_k_minus_8 = grid_len_sq_pow_k - 8;\n  let grid_len_sq_pow_k_minus_9 = grid_len_sq_pow_k - 9;\n  let grid_len_sq_pow_k_minus_10 = grid_len_sq_pow_k - 10;\n  let grid_len_sq_pow_k_minus_11 = grid_len_sq_pow_k - 11;\n  let grid_len_sq_pow_k_minus_12 = grid_len_sq_pow_k - 12;\n  let grid_len_sq_pow_k_minus_13 = grid_len_sq_pow_k - 13;\n  let grid_len_sq_pow_k_minus_14 = grid_len_sq_pow_k - 14;\n  let grid_len_sq_pow_k_minus_15 = grid_len_sq_pow_k -",
    "  let mut lst = Vec::new();\n  for _ in range(k) {\n    lst.push_back(0);\n  }\n  for i in range(0, grid.len() - k + 1) {\n    for j in range(0, k) {\n      if grid[i + j].len() > 0 {\n        lst[j] = grid[i + j][lst[j]];\n      }\n    }\n  }\n  for j in range(0, k) {\n    lst[j] = grid[lst[j]].min();\n  }\n  return lst;",
    "  let mut result = Vec::new();\n  let mut visited = Vec::new();\n  let mut queue = Vec::new();\n  queue.push(0);\n  visited.push(0);\n  while !queue.is_empty() {\n    let cur = queue.pop();\n    if cur >= grid.len() {\n      result.push(grid[cur]);\n      continue;\n    }\n    for i in 0..k {\n      let next = cur + i;\n      if next >= grid.len() {\n        continue;\n      }\n      if visited[next] {\n        continue;\n      }\n      if grid[cur][0] < grid[next][0] {\n        result.push(grid[next][0]);\n        queue.push(next);\n        visited.push(next);\n      } else if grid[cur][0] > grid[next][0] {\n        continue;\n      } else {\n        queue.push(next);\n        visited.push(next);\n        result.push(grid[next][0]);\n      }\n    }\n  }\n  return result;",
    "    let mut result = Vec::new();\n    let mut cur = Vec::new();\n    let mut next = Vec::new();\n    let mut cur_index = 0;\n    let mut next_index = 0;\n    let mut min_index = 0;\n    let mut min_value = 0;\n    let mut min_value_index = 0;\n    let mut min_value_value = 0;\n    let mut min_value_value_index = 0;\n    let mut min_value_value_value = 0;\n    let mut min_value_value_value_index = 0;\n    let mut min_value_value_value_value = 0;\n    let mut min_value_value_value_value_index = 0;\n    let mut min_value_value_value_value_value = 0;\n    let mut min_value_value_value_value_value_index = 0;\n    let mut min_value_value_value_value_value_value = 0;\n    let mut min_value_value_value_value_value_value_index = 0;\n    let mut min_value_value_value_value_value_value_value = 0;\n    let mut min_value_value_value_value_value_value_value_index = 0;\n    let mut min_value_value_value_value_value_value_value_value = 0;\n    let mut min_value_value_value_value_value_value_value_value_index = 0;\n    let mut min_value_value_value_value_value_value_value_value_value = 0;\n    let mut min_value_value_value_value_value_value_value_value_value_index = 0;\n    let mut min_value_value_value_value_value_value_value_value_value_value = 0;\n    let mut min_value_value_value_value_value_value_value_value_value_value_index = 0;\n    let mut min_value_value_value_value_value_value_value_value_value_value_value = 0;\n    let mut min_value_value_value_value_value_value_value_value_value",
    "  let grid_len = grid.len();\n  let grid_len_sq = grid_len * grid_len;\n  let grid_len_sq_div_k = grid_len_sq / k;\n  let grid_len_sq_div_k_minus_1 = grid_len_sq_div_k - 1;\n  let grid_len_sq_div_k_minus_2 = grid_len_sq_div_k - 2;\n  let grid_len_sq_div_k_minus_3 = grid_len_sq_div_k - 3;\n  let grid_len_sq_div_k_minus_4 = grid_len_sq_div_k - 4;\n  let grid_len_sq_div_k_minus_5 = grid_len_sq_div_k - 5;\n  let grid_len_sq_div_k_minus_6 = grid_len_sq_div_k - 6;\n  let grid_len_sq_div_k_minus_7 = grid_len_sq_div_k - 7;\n  let grid_len_sq_div_k_minus_8 = grid_len_sq_div_k - 8;\n  let grid_len_sq_div_k_minus_9 = grid_len_sq_div_k - 9;\n  let grid_len_sq_div_k_minus_10 = grid_len_sq_div_k - 10;\n  let grid_len_sq_div_k_minus_11 = grid_len_sq_div_k - 11;\n  let grid_len_sq_div_k_minus_12 = grid_len_sq_div_k - 12;\n  let grid_len_sq_div_k_minus_13 = grid_len_sq_div_k - 13;\n  let grid_len_sq_div_k_minus_14 = grid_len_sq_div_k - 14;\n  let grid_len_sq_div_k_minus_15 = grid_len_sq_div_k - 15;\n  let grid_len_sq_div_k_minus_16 = grid_len_sq_div_k - 16;",
    "  let mut result = Vec::new();\n  let mut lst = Vec::new();\n  for (let i = 0; i < grid.len(); i++) {\n    lst.push(i);\n  }\n  for (let i = 0; i < k; i++) {\n    let min = i + 1;\n    for (let j = 0; j < lst.len(); j++) {\n      if (grid[lst[j]][i] < grid[lst[j]][min]) {\n        min = j;\n      }\n    }\n    result.push(lst[min]);\n    lst.swap(min, i);\n  }\n  return result;",
    "  let mut result = Vec::new();\n  let mut curr = Vec::new();\n  let mut next = Vec::new();\n  let mut curr_idx = 0;\n  let mut next_idx = 0;\n  let mut next_idx_prev = 0;\n  let mut next_idx_prev_prev = 0;\n  let mut next_idx_prev_prev_prev = 0;\n  let mut next_idx_prev_prev_prev_prev = 0;\n  let mut next_idx_prev_prev_prev_prev_prev = 0;\n  let mut next_idx_prev_prev_prev_prev_prev_prev = 0;\n  let mut next_idx_prev_prev_prev_prev_prev_prev_prev = 0;\n  let mut next_idx_prev_prev_prev_prev_prev_prev_prev_prev = 0;\n  let mut next_idx_prev_prev_prev_prev_prev_prev_prev_prev_prev = 0;\n  let mut next_idx_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev = 0;\n  let mut next_idx_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev = 0;\n  let mut next_idx_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev = 0;\n  let mut next_idx_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev = 0;\n  let mut next_idx_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev = 0;\n  let mut next_idx_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev = 0;\n  let mut next_idx_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev = 0;\n  let mut next_idx_prev_",
    "  let result = Vec::new();\n  let visited = Vec::new();\n  let queue = Vec::new();\n  let queue_index = 0;\n  let queue_size = 0;\n  let visited_index = 0;\n  let visited_size = 0;\n  let grid_size = grid.len();\n  let grid_index = 0;\n  let grid_value = grid[0][0];\n  for grid_index in 0..grid_size {\n    if grid_value == 0 {\n      result = result.push(0);\n      continue;\n    }\n    queue_index = 0;\n    queue_size = queue.len();\n    for queue_index in 0..queue_size {\n      let cell = queue[queue_index];\n      if cell[0] == grid_index {\n        result = result.push(cell[1]);\n        queue_index += 1;\n        queue_size -= 1;\n        continue;\n      }\n      if cell[1] == grid_index {\n        result = result.push(cell[0]);\n        queue_index += 1;\n        queue_size -= 1;\n        continue;\n      }\n      if cell[0] < grid_index {\n        if visited_size == 0 {\n          visited = visited.push(cell[0]);\n          visited_size += 1;\n          continue;\n        }\n        if visited[visited_index] < cell[0] {\n          visited = visited.push(cell[0]);\n          visited_size += 1;\n          continue;\n        }\n      }\n      if cell[1] < grid_index {\n        if visited_size == 0 {\n          visited = visited.push(cell[1]);\n          visited_size += 1;\n          continue;\n        }\n        if visited[visited_index] < cell[1] {\n          visited = visited.push(cell[1]);\n          visited_size += 1;\n          continue;\n        }\n      }\n    }\n    queue = queue.push(grid_index);\n    queue_index += 1;\n    queue_size += 1;\n    grid_value -= 1;\n  }\n  if k",
    "    let mut lst: Vec<isize> = vec![];\n    for i in 0..k {\n        lst = lst.push_back(0);\n    }\n    for i in 0..grid.len() {\n        for j in 0..grid[i].len() {\n            if lst[0] < grid[i][j] {\n                lst = lst.push_back(grid[i][j]);\n            }\n        }\n    }\n    return lst;",
    "    let mut result = Vec::new();\n    let mut curr = Vec::new();\n    let mut prev = Vec::new();\n    let mut next = Vec::new();\n    let mut curr_idx = 0;\n    let mut prev_idx = 0;\n    let mut next_idx = 0;\n    let mut curr_val = 0;\n    let mut prev_val = 0;\n    let mut next_val = 0;\n    let mut curr_lst = Vec::new();\n    let mut prev_lst = Vec::new();\n    let mut next_lst = Vec::new();\n    let mut curr_lst_idx = 0;\n    let mut prev_lst_idx = 0;\n    let mut next_lst_idx = 0;\n    let mut curr_lst_val = 0;\n    let mut prev_lst_val = 0;\n    let mut next_lst_val = 0;\n    let mut curr_lst_lst = Vec::new();\n    let mut prev_lst_lst = Vec::new();\n    let mut next_lst_lst = Vec::new();\n    let mut curr_lst_lst_idx = 0;\n    let mut prev_lst_lst_idx = 0;\n    let mut next_lst_lst_idx = 0;\n    let mut curr_lst_lst_val = 0;\n    let mut prev_lst_lst_val = 0;\n    let mut next_lst_lst_val = 0;\n    let mut curr_lst_lst_lst = Vec::new();\n    let mut prev_lst_lst_lst = Vec::new();\n    let mut next_lst_lst_lst = Vec::new();\n    let mut curr_lst_lst_lst_idx = 0;\n    let mut prev_lst_lst_lst_idx = 0;\n    let mut next_lst_lst_lst_idx = 0;\n    let mut curr_lst_lst_lst",
    "    let mut res = Vec::new();\n    let mut cur = Vec::new();\n    let mut prev = Vec::new();\n    let mut min = Vec::new();\n    let mut min_index = 0;\n    let mut min_value = 0;\n    let mut min_value_index = 0;\n    let mut min_value_index_prev = 0;\n    let mut min_value_index_cur = 0;\n    let mut min_value_index_prev_prev = 0;\n    let mut min_value_index_cur_prev = 0;\n    let mut min_value_index_prev_prev_prev = 0;\n    let mut min_value_index_cur_prev_prev = 0;\n    let mut min_value_index_prev_prev_prev_prev = 0;\n    let mut min_value_index_cur_prev_prev_prev_prev = 0;\n    let mut min_value_index_prev_prev_prev_prev_prev = 0;\n    let mut min_value_index_cur_prev_prev_prev_prev_prev = 0;\n    let mut min_value_index_prev_prev_prev_prev_prev_prev = 0;\n    let mut min_value_index_cur_prev_prev_prev_prev_prev_prev = 0;\n    let mut min_value_index_prev_prev_prev_prev_prev_prev_prev = 0;\n    let mut min_value_index_cur_prev_prev_prev_prev_prev_prev_prev = 0;\n    let mut min_value_index_prev_prev_prev_prev_prev_prev_prev_prev = 0;\n    let mut min_value_index_cur_prev_prev_prev_prev_prev_prev_prev_prev = 0;\n    let mut min_value_index_prev_prev_prev_prev_prev_prev_prev_prev_prev = 0;\n    let mut min_value_index_cur_prev_prev_prev_prev_prev_prev_prev_prev_prev = 0;\n    let mut min_value_index_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev = 0;\n",
    "  let result = Vec.new(k);\n  let queue = Vec.new(k);\n  queue.push(0);\n  result.push(grid[0][0]);\n  while (!queue.isEmpty()) {\n    let current = queue.pop();\n    for (let i = 0; i < k; i++) {\n      let next = current + 1;\n      if (next < grid.length && grid[current][0] == grid[next][0]) {\n        result.push(grid[next][0]);\n        queue.push(next);\n      }\n      if (next < grid.length && grid[current][1] == grid[next][1]) {\n        result.push(grid[next][1]);\n        queue.push(next);\n      }\n      if (next < grid.length && grid[current][2] == grid[next][2]) {\n        result.push(grid[next][2]);\n        queue.push(next);\n      }\n    }\n  }\n  return result;",
    "    let m = grid.len();\n    let n = grid[0].len();\n    let dp = Vec::new(n);\n    for (let i = 0; i < n; i++) {\n        dp[i] = Vec::new(n);\n        for (let j = 0; j < n; j++) {\n            dp[i][j] = grid[0][j];\n        }\n    }\n    for (let i = 1; i < m; i++) {\n        for (let j = 0; j < n; j++) {\n            let min = dp[j][0];\n            for (let k = 1; k < n; k++) {\n                if (dp[j][k] < min) {\n                    min = dp[j][k];\n                }\n            }\n            dp[j][0] = min + grid[i][j];\n        }\n    }\n    let res = Vec::new(k);\n    for (let i = 0; i < k; i++) {\n        res[i] = dp[0][i];\n    }\n    return res;",
    "  let m = grid.len();\n  let n = grid[0].len();\n  let dp = Vec::new(n);\n  for (let i = 0; i < n; i++) {\n    dp[i] = Vec::new(n);\n    for (let j = 0; j < n; j++) {\n      dp[i][j] = grid[0][i][j];\n    }\n  }\n  for (let i = 1; i < m; i++) {\n    for (let j = 0; j < n; j++) {\n      let min = dp[j][0];\n      for (let k = 1; k < n; k++) {\n        if (dp[j][k] < min) {\n          min = dp[j][k];\n        }\n      }\n      dp[j][0] = min + grid[i][j][0];\n      for (let k = 1; k < n; k++) {\n        if (dp[j][k] < min) {\n          min = dp[j][k];\n        }\n      }\n      dp[j][0] = min;\n    }\n  }\n  let result = Vec::new(k);\n  for (let i = 0; i < k; i++) {\n    result[i] = dp[0][i];\n  }\n  return result;",
    "    let mut result = Vec::new();\n    let mut curr = Vec::new();\n    let mut next = Vec::new();\n    let mut last = Vec::new();\n    let mut count = 0;\n    for i in 0..grid.len() {\n        for j in 0..grid[i].len() {\n            if grid[i][j] == 0 {\n                continue;\n            }\n            if count == 0 {\n                curr = Vec::new();\n                next = Vec::new();\n                last = Vec::new();\n                count = 1;\n            }\n            curr.push_back(grid[i][j]);\n            if i > 0 {\n                next.push_back(grid[i - 1][j]);\n            }\n            if j > 0 {\n                next.push_back(grid[i][j - 1]);\n            }\n            if i < grid.len() - 1 {\n                next.push_back(grid[i + 1][j]);\n            }\n            if j < grid[i].len() - 1 {\n                next.push_back(grid[i][j + 1]);\n            }\n            if last.len() == 0 {\n                last = next;\n            } else {\n                last = last.min(next);\n            }\n            if last.len() == k {\n                result = result.concat(last);\n            }\n        }\n    }\n    return result;",
    "  let mut res = Vec::new();\n  let mut cur = Vec::new();\n  let mut prev = Vec::new();\n  let mut cur_idx = 0;\n  let mut prev_idx = 0;\n  let mut prev_val = 0;\n  let mut cur_val = 0;\n  let mut cur_idx_prev_idx = 0;\n  let mut cur_idx_prev_val = 0;\n  let mut cur_idx_prev_idx_val = 0;\n  let mut cur_idx_prev_idx_val_idx = 0;\n  let mut cur_idx_prev_idx_val_idx_val = 0;\n  let mut cur_idx_prev_idx_val_idx_val_idx = 0;\n  let mut cur_idx_prev_idx_val_idx_val_idx_val = 0;\n  let mut cur_idx_prev_idx_val_idx_val_idx_val_idx = 0;\n  let mut cur_idx_prev_idx_val_idx_val_idx_val_idx_val = 0;\n  let mut cur_idx_prev_idx_val_idx_val_idx_val_idx_val_idx = 0;\n  let mut cur_idx_prev_idx_val_idx_val_idx_val_idx_val_idx_val = 0;\n  let mut cur_idx_prev_idx_val_idx_val_idx_val_idx_val_idx_val_idx = 0;\n  let mut cur_idx_prev_idx_val_idx_val_idx_val_idx_val_idx_val_idx_val = 0;\n  let mut cur_idx_prev_idx_val_idx_val_idx_val_idx_val_idx_val_idx_val_idx = 0;\n  let mut cur_idx_prev_idx_val_idx_val_idx_val_",
    "  let m = grid.len();\n  let n = grid[0].len();\n  let dp = Vec::new(n + 1);\n  dp[0] = 0;\n  for (let i = 1; i <= n; i++) {\n    dp[i] = dp[i - 1] + grid[0][i - 1];\n  }\n  for (let i = 1; i <= m; i++) {\n    for (let j = 1; j <= n; j++) {\n      let min = dp[j - 1] + grid[i - 1][j - 1];\n      for (let k = 0; k < j; k++) {\n        let val = grid[i - 1][k] + grid[k][j - 1];\n        if (val < min) {\n          min = val;\n        }\n      }\n      dp[j] = min;\n    }\n  }\n  let res = Vec::new(k);\n  for (let i = 0; i < k; i++) {\n    res[i] = dp[n - k + i + 1];\n  }\n  return res;",
    "  let mut result = Vec::new();\n  let mut visited = Vec::new();\n  let mut queue = Vec::new();\n  queue.push(0);\n  visited.push(0);\n  while !queue.is_empty() {\n    let cell = queue.pop();\n    if cell >= grid.len() {\n      result.push(cell);\n      continue;\n    }\n    for i in 0..k {\n      let next_cell = cell + i;\n      if next_cell >= grid.len() {\n        continue;\n      }\n      if visited[next_cell] {\n        continue;\n      }\n      if grid[cell][i] < grid[next_cell][i] {\n        continue;\n      }\n      visited.push(next_cell);\n      queue.push(next_cell);\n    }\n  }\n  return result;",
    "  let result = Vec.new(k);\n  let visited = Vec.new(grid.len);\n  let queue = Vec.new(grid.len);\n  queue.push(0);\n  visited.set(0, true);\n  for (let i = 0; i < k; i++) {\n    let min = i + 1;\n    for (let j = 0; j < queue.len; j++) {\n      let cell = queue[j];\n      let neighbors = grid[cell];\n      for (let n = 0; n < neighbors.len; n++) {\n        let neighbor = neighbors[n];\n        if (!visited[neighbor]) {\n          visited.set(neighbor, true);\n          queue.push(neighbor);\n          if (min > i + 1) {\n            min = i + 1;\n          }\n        }\n      }\n    }\n    result.set(i, min);\n  }\n  return result;",
    "  let mut lst = vec![];\n  for (let i = 0; i < grid.len(); i++) {\n    for (let j = 0; j < grid[i].len(); j++) {\n      lst = append(lst, grid[i][j]);\n    }\n  }\n  let mut min_path = vec![];\n  for (let i = 0; i < k; i++) {\n    min_path = append(min_path, lst[0]);\n    for (let j = 1; j < lst.len(); j++) {\n      if (lst[j] < lst[j - 1]) {\n        min_path = append(min_path, lst[j]);\n        break;\n      }\n    }\n    lst = lst.drop(1);\n  }\n  return min_path;",
    "    let m = grid.len();\n    let n = grid[0].len();\n    let dp = Vec::new(n);\n    for (let i = 0; i < n; i++) {\n        dp[i] = Vec::new(m);\n        for (let j = 0; j < m; j++) {\n            let min = 1_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000",
    "  let grid_len = grid.len();\n  let grid_len_sq = grid_len * grid_len;\n  let grid_len_sq_k = grid_len_sq - k;\n  let grid_len_sq_k_1 = grid_len_sq_k + 1;\n  let grid_len_sq_k_2 = grid_len_sq_k + 2;\n  let grid_len_sq_k_3 = grid_len_sq_k + 3;\n  let grid_len_sq_k_4 = grid_len_sq_k + 4;\n  let grid_len_sq_k_5 = grid_len_sq_k + 5;\n  let grid_len_sq_k_6 = grid_len_sq_k + 6;\n  let grid_len_sq_k_7 = grid_len_sq_k + 7;\n  let grid_len_sq_k_8 = grid_len_sq_k + 8;\n  let grid_len_sq_k_9 = grid_len_sq_k + 9;\n  let grid_len_sq_k_10 = grid_len_sq_k + 10;\n  let grid_len_sq_k_11 = grid_len_sq_k + 11;\n  let grid_len_sq_k_12 = grid_len_sq_k + 12;\n  let grid_len_sq_k_13 = grid_len_sq_k + 13;\n  let grid_len_sq_k_14 = grid_len_sq_k + 14;\n  let grid_len_sq_k_15 = grid_len_sq_k + 15;\n  let grid_len_sq_k_16 = grid_len_sq_k + 16;\n  let grid_len_sq_k_17 = grid_len_sq_k + 17;\n  let grid_len_sq_k_18 = grid_len_sq_k + 18;\n  let grid_len_sq_k_19 = grid_len_sq_k + 19;\n  let grid_len_sq_k_20 = grid_len_sq_k + 20;\n  let grid_len",
    "  let mut result = Vec::new();\n  let mut current = Vec::new();\n  let mut next = Vec::new();\n  let mut min = Vec::new();\n  let mut min_index = 0;\n  let mut min_value = 0;\n  let mut min_value_index = 0;\n  let mut min_value_value = 0;\n  let mut min_value_value_index = 0;\n  let mut min_value_value_value = 0;\n  let mut min_value_value_value_index = 0;\n  let mut min_value_value_value_value = 0;\n  let mut min_value_value_value_value_index = 0;\n  let mut min_value_value_value_value_value = 0;\n  let mut min_value_value_value_value_value_index = 0;\n  let mut min_value_value_value_value_value_value = 0;\n  let mut min_value_value_value_value_value_value_index = 0;\n  let mut min_value_value_value_value_value_value_value = 0;\n  let mut min_value_value_value_value_value_value_value_index = 0;\n  let mut min_value_value_value_value_value_value_value_value = 0;\n  let mut min_value_value_value_value_value_value_value_value_index = 0;\n  let mut min_value_value_value_value_value_value_value_value_value = 0;\n  let mut min_value_value_value_value_value_value_value_value_value_index = 0;\n  let mut min_value_value_value_value_value_value_value_value_value_value = 0;\n  let mut min_value_value_value_value_value_value_value_value_value_value_index = 0;\n  let mut min_value_value_value_value_value_value_value_value_value_value_value = 0;\n  let mut min_value_value_value_value_value_value_value_value_value_value_value_index = 0;\n",
    "  let n = grid.len();\n  let m = grid[0].len();\n  let dp = Vec::new(n * m);\n  for (let i = 0; i < n; i++) {\n    for (let j = 0; j < m; j++) {\n      if (i == 0 && j == 0) {\n        dp[i * m + j] = grid[i][j];\n      } else if (i == 0) {\n        dp[i * m + j] = dp[(i - 1) * m + j] + grid[i][j];\n      } else if (j == 0) {\n        dp[i * m + j] = dp[i * m + (j - 1)] + grid[i][j];\n      } else {\n        dp[i * m + j] = min(dp[(i - 1) * m + j], dp[i * m + (j - 1)], dp[(i - 1) * m + (j - 1)]) + grid[i][j];\n      }\n    }\n  }\n  let res = Vec::new(k);\n  for (let i = 0; i < k; i++) {\n    res[i] = dp[i * m + m - 1];\n  }\n  return res;",
    "  let m = grid.len();\n  let n = grid[0].len();\n  assert(m >= 2 && n >= 2 && k >= 1);\n  let dp = Vec::new(k + 1);\n  dp[0] = 0;\n  for (let i = 0; i < m; i++) {\n    for (let j = 0; j < n; j++) {\n      let v = grid[i][j];\n      if (v == 0) {\n        continue;\n      }\n      let d = dp[k];\n      for (let _ = 0; _ < k; _++) {\n        let u = dp[_];\n        if (u == 0 || v < u) {\n          dp[_] = v;\n          break;\n        }\n      }\n    }\n  }\n  return dp;",
    "  let m = grid.len();\n  let n = grid[0].len();\n  let dp = Vec::new(n + 1);\n  dp[0] = 0;\n  for (let i = 0; i < m; i++) {\n    for (let j = 0; j < n; j++) {\n      if (grid[i][j] == 0) {\n        continue;\n      }\n      let min = dp[j] + 1;\n      for (let k = 0; k < n; k++) {\n        if (grid[i][k] == 0) {\n          continue;\n        }\n        if (k < j) {\n          continue;\n        }\n        if (min > dp[k] + 1) {\n          min = dp[k] + 1;\n        }\n      }\n      dp[j + 1] = min;\n    }\n  }\n  let res = Vec::new(k);\n  for (let i = 0; i < k; i++) {\n    res[i] = dp[n - i];\n  }\n  return res;",
    "  let mut res = Vec::new();\n  let mut curr = Vec::new();\n  let mut prev = Vec::new();\n  let mut visited = Vec::new();\n  let mut min_path = Vec::new();\n  let mut min_path_len = 0;\n  let mut min_path_index = 0;\n  let mut min_path_index_len = 0;\n  let mut min_path_index_index = 0;\n  let mut min_path_index_index_len = 0;\n  for (let i = 0; i < grid.len(); i++) {\n    for (let j = 0; j < grid[i].len(); j++) {\n      if (grid[i][j] == 0) {\n        continue;\n      }\n      if (visited.len() == 0) {\n        curr.push_back(grid[i][j]);\n        visited.push_back(i);\n        visited.push_back(j);\n        prev.push_back(0);\n        min_path.push_back(grid[i][j]);\n        min_path_len = 1;\n        min_path_index = 0;\n        min_path_index_len = 1;\n        min_path_index_index = 0;\n        min_path_index_index_len = 1;\n      } else {\n        for (let k = 0; k < visited.len(); k++) {\n          if (i == visited[k] && j == visited[k + 1]) {\n            continue;\n          }\n          if (grid[i][j] < grid[visited[k]][visited[k + 1]]) {\n            curr.push_back(grid[i][j]);\n            prev.push_back(grid[visited[k]][visited[k + 1]]);\n            min_path.push_back(grid[i][j]);\n            min_path_len = k + 1;\n            min_path_index = k + 1;\n            min_path_index_len = k + 1;\n            min_path_index_index = k + 1;\n            min_path_index_index_len = k +",
    "    let mut lst = Vec::new();\n    let mut lst_prev = Vec::new();\n    lst_prev.push_back(0);\n    let mut lst_curr = Vec::new();\n    lst_curr.push_back(0);\n    let mut lst_next = Vec::new();\n    lst_next.push_back(0);\n    let mut min_path = Vec::new();\n    min_path.push_back(0);\n    let mut min_path_prev = Vec::new();\n    min_path_prev.push_back(0);\n    let mut min_path_curr = Vec::new();\n    min_path_curr.push_back(0);\n    let mut min_path_next = Vec::new();\n    min_path_next.push_back(0);\n    let mut min_path_next_prev = Vec::new();\n    min_path_next_prev.push_back(0);\n    let mut min_path_next_curr = Vec::new();\n    min_path_next_curr.push_back(0);\n    let mut min_path_next_next = Vec::new();\n    min_path_next_next.push_back(0);\n    let mut min_path_next_next_prev = Vec::new();\n    min_path_next_next_prev.push_back(0);\n    let mut min_path_next_next_curr = Vec::new();\n    min_path_next_next_curr.push_back(0);\n    let mut min_path_next_next_next = Vec::new();\n    min_path_next_next_next.push_back(0);\n    let mut min_path_next_next_next_prev = Vec::new();\n    min_path_next_next_next_prev.push_back(0);\n    let mut min_path_next_next_next_curr = Vec::new();\n    min_path_next_next_next_curr.push_back(0);\n    let mut min_path_next_next_next_next = Vec::new();\n    ",
    "  let mut result = Vec::new();\n  let mut min_path = Vec::new();\n  let mut min_path_len = 0;\n  let mut min_path_index = 0;\n  let mut min_path_index_len = 0;\n  let mut min_path_index_index = 0;\n  let mut min_path_index_index_len = 0;\n  let mut min_path_index_index_index = 0;\n  let mut min_path_index_index_index_len = 0;\n  let mut min_path_index_index_index_index = 0;\n  let mut min_path_index_index_index_index_len = 0;\n  let mut min_path_index_index_index_index_index = 0;\n  let mut min_path_index_index_index_index_index_len = 0;\n  let mut min_path_index_index_index_index_index_index = 0;\n  let mut min_path_index_index_index_index_index_index_len = 0;\n  let mut min_path_index_index_index_index_index_index_index = 0;\n  let mut min_path_index_index_index_index_index_index_index_len = 0;\n  let mut min_path_index_index_index_index_index_index_index_index = 0;\n  let mut min_path_index_index_index_index_index_index_index_index_len = 0;\n  let mut min_path_index_index_index_index_index_index_index_index_index = 0;\n  let mut min_path_index_index_index_index_index_index_index_index_index_len = 0;\n  let mut min_path_index_index_index_index_index_index_index_index_index_index = 0;\n  let mut min_path_index_index_index_index_index_index_index_index_index_index_len = 0;\n  let mut min_path_index_index_index_index_index_index_index_index_index_index_index = 0;\n  let mut min_path",
    "  let mut result = Vec::new();\n  let mut min_path = Vec::new();\n  let mut min_path_index = 0;\n  let mut min_path_value = 0;\n  let mut min_path_length = 0;\n  let mut min_path_index_prev = 0;\n  let mut min_path_value_prev = 0;\n  let mut min_path_length_prev = 0;\n  let mut min_path_index_next = 0;\n  let mut min_path_value_next = 0;\n  let mut min_path_length_next = 0;\n  let mut min_path_index_next_prev = 0;\n  let mut min_path_value_next_prev = 0;\n  let mut min_path_length_next_prev = 0;\n  let mut min_path_index_next_next = 0;\n  let mut min_path_value_next_next = 0;\n  let mut min_path_length_next_next = 0;\n  let mut min_path_index_next_next_prev = 0;\n  let mut min_path_value_next_next_prev = 0;\n  let mut min_path_length_next_next_prev = 0;\n  let mut min_path_index_next_next_next = 0;\n  let mut min_path_value_next_next_next = 0;\n  let mut min_path_length_next_next_next = 0;\n  let mut min_path_index_next_next_next_prev = 0;\n  let mut min_path_value_next_next_next_prev = 0;\n  let mut min_path_length_next_next_next_prev = 0;\n  let mut min_path_index_next_next_next_next = 0;\n  let mut min_path_value_next_next_next_next = 0;\n  let mut min_path_length_next_next_next_next = 0;\n  let mut min_path_index_next_next_next_next_prev = 0;\n  let mut min_path_value_next_next_next_next_prev = 0;\n  let",
    "  let lst = vec![];\n  for (let i = 0; i < grid.len(); i++) {\n    lst = lst.concat(grid[i]);\n  }\n  lst.sort();\n  let ans = vec![];\n  for (let i = 0; i < k; i++) {\n    let idx = lst.indexOf(i + 1);\n    if (idx != -1) {\n      ans = ans.concat(lst.take(idx));\n    }\n  }\n  return ans;",
    "    let m = grid.len();\n    let n = grid[0].len();\n    let dp = Vec::new(n);\n    for (let i = 0; i < n; i++) {\n        dp[i] = 1;\n    }\n    for (let i = 0; i < m; i++) {\n        for (let j = 0; j < n; j++) {\n            if (grid[i][j] == 0) {\n                continue;\n            }\n            for (let k = 0; k < n; k++) {\n                if (grid[i][k] == 0 || grid[k][j] == 0) {\n                    continue;\n                }\n                if (dp[k] + 1 < dp[j]) {\n                    dp[j] = dp[k] + 1;\n                }\n            }\n        }\n    }\n    let res = Vec::new(k);\n    for (let i = 0; i < k; i++) {\n        res[i] = dp[i];\n    }\n    return res;",
    "  let dfs = Dfs{grid, k};\n  let res = dfs.run();\n  return res;",
    "  let dfs = Dfs{grid, 0, 0};\n  let ans = Vec::new();\n  for i in 0..k {\n    let cur = dfs.next();\n    if cur.is_none() {\n      break;\n    }\n    ans.push(cur.unwrap());\n  }\n  return ans;",
    "    let mut result = Vec::new();\n    let mut curr = Vec::new();\n    let mut prev = Vec::new();\n    let mut min_path = Vec::new();\n    let mut min_path_len = 0;\n    for i in 0..grid.len() {\n        for j in 0..grid[i].len() {\n            if grid[i][j] > 0 {\n                curr.push_back(grid[i][j]);\n                prev.push_back(grid[i][j]);\n            }\n        }\n        if curr.len() == k {\n            min_path = curr;\n            min_path_len = k;\n            break;\n        }\n        if prev.len() == k {\n            min_path = prev;\n            min_path_len = k;\n            break;\n        }\n        if curr.len() < k {\n            curr = prev;\n        } else {\n            prev = curr;\n        }\n    }\n    for i in 0..min_path.len() {\n        result.push_back(min_path[i]);\n    }\n    return result;",
    "  let m = grid.len();\n  let n = grid[0].len();\n  let dp = Vec::new(n);\n  dp[0] = 0;\n  for (let i = 1; i < n; i++) {\n    dp[i] = dp[i - 1] + grid[0][i - 1];\n  }\n  for (let i = 1; i < m; i++) {\n    for (let j = 1; j < n; j++) {\n      let min = dp[j - 1] + grid[i - 1][j - 1];\n      for (let k = 0; k < j; k++) {\n        let cur = dp[k] + grid[i - 1][k];\n        if (cur < min) {\n          min = cur;\n        }\n      }\n      dp[j] = min;\n    }\n  }\n  let ans = Vec::new(k);\n  for (let i = 0; i < k; i++) {\n    ans[i] = dp[n - 1] - dp[i];\n  }\n  return ans;",
    "    let mut result = Vec::new();\n    let mut curr = Vec::new();\n    let mut prev = Vec::new();\n    let mut curr_idx = 0;\n    let mut prev_idx = 0;\n    let mut prev_val = 0;\n    let mut curr_val = 0;\n    let mut curr_idx_val = 0;\n    let mut prev_idx_val = 0;\n    let mut prev_val_val = 0;\n    let mut curr_val_val = 0;\n    let mut curr_idx_val_val = 0;\n    let mut prev_idx_val_val = 0;\n    let mut prev_val_val_val = 0;\n    let mut curr_val_val_val = 0;\n    let mut curr_idx_val_val_val = 0;\n    let mut prev_idx_val_val_val = 0;\n    let mut prev_val_val_val_val = 0;\n    let mut curr_val_val_val_val = 0;\n    let mut curr_idx_val_val_val_val = 0;\n    let mut prev_idx_val_val_val_val = 0;\n    let mut prev_val_val_val_val_val = 0;\n    let mut curr_val_val_val_val_val = 0;\n    let mut curr_idx_val_val_val_val_val = 0;\n    let mut prev_idx_val_val_val_val_val = 0;\n    let mut prev_val_val_val_val_val_val = 0;\n    let mut curr_val_val_val_val_val_val = 0;\n    let mut curr_idx_val_val_val_val_val_val = 0;\n    let mut prev_idx_val_val_val_val_val_val = 0;\n    let mut prev_val_val_val_val_val_val_val = 0;\n    let mut curr_val_val_val_val_val_val_val = 0;\n    let mut curr",
    "  let m = grid.len();\n  let n = grid[0].len();\n  let dp = Vec::new(n);\n  for (let i = 0; i < n; i++) {\n    dp[i] = Vec::new(n);\n    for (let j = 0; j < n; j++) {\n      if (i == 0 && j == 0) {\n        dp[i][j] = grid[0][0];\n      } else if (i == 0) {\n        dp[i][j] = dp[i][j - 1] + grid[0][j];\n      } else if (j == 0) {\n        dp[i][j] = dp[i - 1][j] + grid[i][0];\n      } else {\n        dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j];\n      }\n    }\n  }\n  let ans = Vec::new(k);\n  for (let i = 0; i < k; i++) {\n    ans[i] = dp[n - 1][n - 1];\n    for (let j = n - 1; j > 0; j--) {\n      if (dp[j][j] < dp[j - 1][j]) {\n        dp[j][j] = dp[j - 1][j];\n      }\n    }\n  }\n  return ans;",
    "  let lst = []\n  for i in 0..k {\n    lst.push(0)\n  }\n  for i in 0..grid.len() {\n    for j in 0..grid[i].len() {\n      lst[0] = grid[i][j]\n      for j in 1..k {\n        lst[j] = min(lst[j], lst[j - 1])\n      }\n    }\n  }\n  return lst",
    "  let mut result = Vec::new();\n  let mut min_index = 0;\n  let mut min_value = 1;\n  let mut min_path = Vec::new();\n  for i in 0..grid.len() {\n    for j in 0..grid[i].len() {\n      let value = grid[i][j];\n      if value < min_value {\n        min_value = value;\n        min_index = j;\n        min_path = Vec::new();\n      }\n      if value == min_value {\n        min_path.push_back(j);\n      }\n    }\n  }\n  for i in 0..k {\n    result.push_back(min_path[i]);\n  }\n  return result;",
    "  let result = Vec::new(k);\n  let visited = Vec::new(grid.len);\n  for (let i = 0; i < grid.len; i++) {\n    if (visited[i] == 0) {\n      result = result.push(i);\n      visited = visited.set(i, 1);\n      for (let j = 0; j < grid.len; j++) {\n        if (grid[i][j] > 0 && visited[j] == 0) {\n          visited = visited.set(j, 1);\n          result = result.push(j);\n        }\n      }\n      if (result.len == k) {\n        return result;\n      }\n      result = result.pop();\n    }\n  }\n  return Vec::new(k);",
    "  let mut result = Vec::new();\n  let mut curr = Vec::new();\n  let mut prev = Vec::new();\n  let mut min = Vec::new();\n  let mut min_index = 0;\n  let mut min_value = 0;\n  let mut min_prev = 0;\n  let mut min_curr = 0;\n  let mut min_prev_index = 0;\n  let mut min_curr_index = 0;\n  let mut min_prev_value = 0;\n  let mut min_curr_value = 0;\n  let mut min_prev_prev = 0;\n  let mut min_curr_prev = 0;\n  let mut min_prev_prev_index = 0;\n  let mut min_curr_prev_index = 0;\n  let mut min_prev_prev_value = 0;\n  let mut min_curr_prev_value = 0;\n  let mut min_prev_prev_prev = 0;\n  let mut min_curr_prev_prev = 0;\n  let mut min_prev_prev_prev_index = 0;\n  let mut min_curr_prev_prev_index = 0;\n  let mut min_prev_prev_prev_value = 0;\n  let mut min_curr_prev_prev_value = 0;\n  let mut min_prev_prev_prev_prev = 0;\n  let mut min_curr_prev_prev_prev = 0;\n  let mut min_prev_prev_prev_prev_index = 0;\n  let mut min_curr_prev_prev_prev_index = 0;\n  let mut min_prev_prev_prev_prev_value = 0;\n  let mut min_curr_prev_prev_prev_value = 0;\n  let mut min_prev_prev_prev_prev_prev = 0;\n  let mut min_curr_prev_prev_prev_prev = 0;\n  let mut min_prev_prev_prev_prev_prev_index = 0;\n  let mut min_curr_prev_prev_prev_prev_index = 0;\n  let mut min_prev_prev_prev_prev_prev_value =",
    "  let mut result = Vec::new();\n  let mut visited = Vec::new();\n  let mut queue = Vec::new();\n  queue.push(0);\n  visited.push(0);\n  while !queue.is_empty() {\n    let cell = queue.pop();\n    if cell >= grid.len() {\n      return result;\n    }\n    for i in 0..k {\n      let next = cell + i;\n      if next >= grid.len() {\n        continue;\n      }\n      if visited[next] {\n        continue;\n      }\n      if grid[cell][i] < grid[next][i] {\n        continue;\n      }\n      if grid[cell][i] > grid[next][i] {\n        continue;\n      }\n      queue.push(next);\n      visited.push(next);\n    }\n  }\n  return result;",
    "  let m = grid.len();\n  let n = grid[0].len();\n  let dp = Vec::new(n + 1);\n  dp[0] = 0;\n  for (let i = 1; i <= n; i++) {\n    dp[i] = dp[i - 1] + grid[0][i - 1];\n  }\n  for (let i = 1; i <= m; i++) {\n    for (let j = 1; j <= n; j++) {\n      let min = dp[j - 1] + grid[i - 1][j - 1];\n      for (let k = 0; k < j; k++) {\n        let val = dp[k] + grid[i - 1][k];\n        if (val < min) {\n          min = val;\n        }\n      }\n      dp[j] = min;\n    }\n  }\n  let res = Vec::new(k);\n  for (let i = 0; i < k; i++) {\n    res[i] = dp[n - k + i + 1];\n  }\n  return res;",
    "  let n = grid.len();\n  let m = grid[0].len();\n  let dp = Vec::new(n, 0);\n  let dp_prev = Vec::new(n, 0);\n  for (let i = 0; i < n; i++) {\n    for (let j = 0; j < m; j++) {\n      if (i == 0 && j == 0) {\n        dp[i] = grid[i][j];\n        dp_prev[i] = grid[i][j];\n      } else if (i == 0) {\n        dp[i] = dp_prev[i] + grid[i][j];\n      } else if (j == 0) {\n        dp[i] = dp_prev[i] + grid[i][j];\n      } else {\n        dp[i] = min(dp_prev[i-1] + grid[i][j], dp_prev[i] + grid[i][j-1], dp_prev[i-1] + grid[i][j-1]);\n      }\n    }\n  }\n  let res = Vec::new(k, 0);\n  for (let i = 0; i < k; i++) {\n    res[i] = dp[n-1] - dp[i];\n  }\n  return res;",
    "  let dfs = DFS{grid, 0, 0};\n  let ans = Vec::new();\n  for isize i = 0; i < k; i++ {\n    let cur = dfs.next();\n    if cur.is_none() {\n      break;\n    }\n    ans.push_back(cur.unwrap());\n  }\n  return ans;",
    "  let grid_len = grid.len();\n  let grid_len_sq = grid_len * grid_len;\n  let grid_len_sq_i = 1_i64 * grid_len_sq;\n  let grid_len_sq_i_k = 1_i64 * grid_len_sq_i + k;\n  let grid_len_sq_i_k_1 = 1_i64 * grid_len_sq_i_k + 1;\n  let grid_len_sq_i_k_2 = 1_i64 * grid_len_sq_i_k + 2;\n  let grid_len_sq_i_k_3 = 1_i64 * grid_len_sq_i_k + 3;\n  let grid_len_sq_i_k_4 = 1_i64 * grid_len_sq_i_k + 4;\n  let grid_len_sq_i_k_5 = 1_i64 * grid_len_sq_i_k + 5;\n  let grid_len_sq_i_k_6 = 1_i64 * grid_len_sq_i_k + 6;\n  let grid_len_sq_i_k_7 = 1_i64 * grid_len_sq_i_k + 7;\n  let grid_len_sq_i_k_8 = 1_i64 * grid_len_sq_i_k + 8;\n  let grid_len_sq_i_k_9 = 1_i64 * grid_len_sq_i_k + 9;\n  let grid_len_sq_i_k_10 = 1_i64 * grid_len_sq_i_k + 10;\n  let grid_len_sq_i_k_11 = 1_i64 * grid_len_sq_i_k + 11;\n  let grid_len_sq_i_k_12 = 1_i64 * grid_len_sq_i_k + 12;\n  let grid_len_sq_i_k_13 = 1_i64 * grid_len_sq_i_k + 13;\n  let grid_len_sq_i_k_14 = 1_i64",
    "  let grid_len = grid.len();\n  let grid_len_sq = grid_len * grid_len;\n  let grid_len_sq_pow_k = grid_len_sq ** k;\n  let grid_len_sq_pow_k_minus_1 = grid_len_sq_pow_k - 1;\n  let grid_len_sq_pow_k_minus_2 = grid_len_sq_pow_k - 2;\n  let grid_len_sq_pow_k_minus_3 = grid_len_sq_pow_k - 3;\n  let grid_len_sq_pow_k_minus_4 = grid_len_sq_pow_k - 4;\n  let grid_len_sq_pow_k_minus_5 = grid_len_sq_pow_k - 5;\n  let grid_len_sq_pow_k_minus_6 = grid_len_sq_pow_k - 6;\n  let grid_len_sq_pow_k_minus_7 = grid_len_sq_pow_k - 7;\n  let grid_len_sq_pow_k_minus_8 = grid_len_sq_pow_k - 8;\n  let grid_len_sq_pow_k_minus_9 = grid_len_sq_pow_k - 9;\n  let grid_len_sq_pow_k_minus_10 = grid_len_sq_pow_k - 10;\n  let grid_len_sq_pow_k_minus_11 = grid_len_sq_pow_k - 11;\n  let grid_len_sq_pow_k_minus_12 = grid_len_sq_pow_k - 12;\n  let grid_len_sq_pow_k_minus_13 = grid_len_sq_pow_k - 13;\n  let grid_len_sq_pow_k_minus_14 = grid_len_sq_pow_k - 14;\n  let grid_len_sq_pow_k_minus_15 = grid_len_sq_pow_k -",
    "  let result = Vec::new(k);\n  let visited = Vec::new(grid.len);\n  for (let i = 0; i < grid.len; i++) {\n    if (visited[i] == 0) {\n      result = minPath(grid, i, k, visited);\n      break;\n    }\n  }\n  return result;",
    "  let n = grid.len();\n  let m = grid[0].len();\n  let dp = Vec::new(n * m);\n  for (let i = 0; i < n; i++) {\n    for (let j = 0; j < m; j++) {\n      if (i == 0 && j == 0) {\n        dp[i * m + j] = grid[i][j];\n      } else if (i == 0) {\n        dp[i * m + j] = grid[i][j] + dp[(i - 1) * m + j];\n      } else if (j == 0) {\n        dp[i * m + j] = grid[i][j] + dp[i * m + (j - 1)];\n      } else {\n        dp[i * m + j] = grid[i][j] + min(dp[(i - 1) * m + j], dp[i * m + (j - 1)]);\n      }\n    }\n  }\n  let res = Vec::new(k);\n  for (let i = 0; i < k; i++) {\n    res[i] = dp[i * m + m - 1];\n  }\n  return res;",
    "  let lst: Vec<isize> = vec![];\n  for i in 0..k {\n    lst = vec![];\n    for j in 0..k {\n      if grid[i][j] {\n        lst = vec![];\n        for _ in 0..k {\n          lst = vec![];\n          for _ in 0..k {\n            if grid[i][j] {\n              lst = vec![];\n              for _ in 0..k {\n                if grid[i][j] {\n                  lst = vec![];\n                  for _ in 0..k {\n                    if grid[i][j] {\n                      lst = vec![];\n                      for _ in 0..k {\n                        if grid[i][j] {\n                          lst = vec![];\n                          for _ in 0..k {\n                            if grid[i][j] {\n                              lst = vec![];\n                              for _ in 0..k {\n                                if grid[i][j] {\n                                  lst = vec![];\n                                  for _ in 0..k {\n                                    if grid[i][j] {\n                                      lst = vec![];\n                                      for _ in 0..k {\n                                        if grid[i][j] {\n                                          lst = vec![];\n                                          for _ in 0..k {\n                                            if grid[i][j] {\n                                              lst = vec![];\n                                              for _ in 0..k {\n                                                if grid[i][j] {\n                                                  lst = vec![];\n                                                  for _ in 0..k {\n                                                    if grid[i][j] {\n                                                      lst = vec![];\n                                                      for _ in 0..k {\n                                                        if grid[i][j] {\n                                                          lst = vec![];\n                                                          for _ in 0..k {\n                                       ",
    "    let mut result = Vec::new();\n    let mut min_path = Vec::new();\n    let mut min_path_index = 0;\n    let mut min_path_length = 0;\n    let mut min_path_length_index = 0;\n    let mut min_path_length_length = 0;\n    let mut min_path_length_length_index = 0;\n    let mut min_path_length_length_length = 0;\n    let mut min_path_length_length_length_index = 0;\n    let mut min_path_length_length_length_length = 0;\n    let mut min_path_length_length_length_length_index = 0;\n    let mut min_path_length_length_length_length_length = 0;\n    let mut min_path_length_length_length_length_length_index = 0;\n    let mut min_path_length_length_length_length_length_length = 0;\n    let mut min_path_length_length_length_length_length_length_index = 0;\n    let mut min_path_length_length_length_length_length_length_length = 0;\n    let mut min_path_length_length_length_length_length_length_length_index = 0;\n    let mut min_path_length_length_length_length_length_length_length_length = 0;\n    let mut min_path_length_length_length_length_length_length_length_length_index = 0;\n    let mut min_path_length_length_length_length_length_length_length_length_length = 0;\n    let mut min_path_length_length_length_length_length_length_length_length_length_index = 0;\n    let mut min_path_length_length_length_length_length_length_length_length_length_length = 0;\n    let mut min_path_length_length_length_length_length_length_length_length_length_length_index = 0;\n    let mut min_path_length_length_length_length_length_length_length_length_length_length_length = 0;\n    let mut min_path",
    "  let mut result = Vec::new();\n  let mut visited = Vec::new();\n  let mut queue = Vec::new();\n  let mut min_path = Vec::new();\n  let mut min_path_len = 0;\n  let mut min_path_index = 0;\n  let mut min_path_index_len = 0;\n  let mut min_path_index_index = 0;\n  let mut min_path_index_index_len = 0;\n  let mut min_path_index_index_index = 0;\n  let mut min_path_index_index_index_len = 0;\n  let mut min_path_index_index_index_index = 0;\n  let mut min_path_index_index_index_index_len = 0;\n  let mut min_path_index_index_index_index_index = 0;\n  let mut min_path_index_index_index_index_index_len = 0;\n  let mut min_path_index_index_index_index_index_index = 0;\n  let mut min_path_index_index_index_index_index_index_len = 0;\n  let mut min_path_index_index_index_index_index_index_index = 0;\n  let mut min_path_index_index_index_index_index_index_index_len = 0;\n  let mut min_path_index_index_index_index_index_index_index_index = 0;\n  let mut min_path_index_index_index_index_index_index_index_index_len = 0;\n  let mut min_path_index_index_index_index_index_index_index_index_index = 0;\n  let mut min_path_index_index_index_index_index_index_index_index_index_len = 0;\n  let mut min_path_index_index_index_index_index_index_index_index_index_index = 0;\n  let mut min_path_index_index_index_index_index_index_index_index_index_index_len = 0;\n  let mut min_path_index_index_index_index_index_index",
    "    let m = grid.len();\n    let n = grid[0].len();\n    let dp = Vec::new(n, 0);\n    for (let i = 0; i < m; i++) {\n        for (let j = 0; j < n; j++) {\n            if (i == 0 && j == 0) {\n                dp[j] = grid[i][j];\n            } else if (i == 0) {\n                dp[j] = min(dp[j], dp[j - 1] + grid[i][j]);\n            } else if (j == 0) {\n                dp[j] = min(dp[j], dp[j] + grid[i][j]);\n            } else {\n                dp[j] = min(dp[j], dp[j - 1] + grid[i][j], dp[j] + grid[i][j - 1]);\n            }\n        }\n    }\n    let res = Vec::new(k, 0);\n    for (let i = 0; i < k; i++) {\n        res[i] = dp[n - 1];\n    }\n    return res;",
    "  let n = grid.len();\n  assert(n >= 2);\n  assert(k >= 1);\n  assert(all(grid, |&| grid.len() == grid[0].len()));\n  \n  let d = [0] * n;\n  let q = [0] * n;\n  let p = [0] * n;\n  \n  for (let i = 0; i < n; i++) {\n    for (let j = 0; j < n; j++) {\n      if (grid[i][j] == 0) {\n        d[i] = j;\n        q[i] = 0;\n        p[i] = i;\n      }\n    }\n  }\n  \n  for (let i = 0; i < k; i++) {\n    let min = i;\n    for (let j = 0; j < n; j++) {\n      if (d[j] == 0) {\n        let min_j = j;\n        for (let k = 0; k < n; k++) {\n          if (d[k] == 0 && q[k] < q[min_j]) {\n            min_j = k;\n          }\n        }\n        if (q[min_j] < i) {\n          min = i;\n        } else if (q[min_j] == i) {\n          min = min_j;\n        }\n        d[min_j] = j;\n        q[min_j] = i + 1;\n        p[min_j] = j;\n      }\n    }\n  }\n  \n  let res = [0] * k;\n  for (let i = 0; i < k; i++) {\n    res[i] = grid[p[i]][d[p[i]]];\n  }\n  return res;",
    "  let mut result = Vec::new();\n  let mut curr = Vec::new();\n  let mut prev = Vec::new();\n  let mut min_index = 0;\n  let mut min_value = 0;\n  let mut min_path = Vec::new();\n  let mut min_path_index = 0;\n  let mut min_path_value = 0;\n  for (let i = 0; i < grid.len(); i++) {\n    for (let j = 0; j < grid[i].len(); j++) {\n      if (grid[i][j] == 0) {\n        continue;\n      }\n      if (curr.len() == 0) {\n        curr.append(grid[i][j]);\n        prev.append(grid[i][j]);\n        continue;\n      }\n      if (grid[i][j] < min_value) {\n        min_value = grid[i][j];\n        min_index = i;\n        min_path_value = curr[0];\n        min_path_index = curr.len() - 1;\n      }\n      if (grid[i][j] == min_value) {\n        if (curr.len() < prev.len()) {\n          curr.append(grid[i][j]);\n          prev.append(grid[i][j]);\n        } else if (curr.len() == prev.len()) {\n          if (curr[curr.len() - 1] < prev[prev.len() - 1]) {\n            curr.append(grid[i][j]);\n            prev.append(grid[i][j]);\n          }\n        } else {\n          curr.append(grid[i][j]);\n          prev.append(grid[i][j]);\n        }\n      }\n    }\n  }\n  for (let i = 0; i < curr.len(); i++) {\n    result.append(curr[i]);\n  }\n  for (let i = 0; i < min_path.len(); i++) {\n    result.append(min_path[i]);\n  }\n  for (let i = min_path_index; i < min_",
    "  let m = grid.len();\n  let n = grid[0].len();\n  let dp = Vec::new(n, 0);\n  for (let i = 0; i < m; i++) {\n    for (let j = 0; j < n; j++) {\n      if (i == 0 && j == 0) {\n        dp[j] = grid[i][j];\n      } else if (i == 0) {\n        dp[j] = min(dp[j], dp[j - 1] + grid[i][j]);\n      } else if (j == 0) {\n        dp[j] = min(dp[j], dp[j] + grid[i][j]);\n      } else {\n        dp[j] = min(dp[j], dp[j - 1] + grid[i][j], dp[j] + grid[i][j - 1]);\n      }\n    }\n  }\n  let res = Vec::new(k, 0);\n  for (let i = 0; i < k; i++) {\n    res[i] = dp[i];\n  }\n  return res;",
    "  let dfs = Dfs{grid, 0, 0};\n  let res = Vec::new();\n  for isize i = 0; i < k; i++ {\n    let cur = dfs.next();\n    if cur.is_none() {\n      return res;\n    }\n    res.push_back(cur.unwrap());\n  }\n  return res;",
    "  let mut res = Vec::new();\n  for (let i = 0; i < grid.len(); i++) {\n    for (let j = 0; j < grid[i].len(); j++) {\n      if (grid[i][j] == 0) {\n        continue;\n      }\n      let lst = Vec::new();\n      for (let _ = 0; _ < k; _++) {\n        lst.push(grid[i][j]);\n        grid[i][j] = 0;\n        if (i > 0) {\n          lst.push(grid[i - 1][j]);\n          grid[i - 1][j] = 0;\n        }\n        if (j > 0) {\n          lst.push(grid[i][j - 1]);\n          grid[i][j - 1] = 0;\n        }\n        if (i < grid.len() - 1) {\n          lst.push(grid[i + 1][j]);\n          grid[i + 1][j] = 0;\n        }\n        if (j < grid[i].len() - 1) {\n          lst.push(grid[i][j + 1]);\n          grid[i][j + 1] = 0;\n        }\n      }\n      let lst_cmp = lst.cmp(res);\n      if (lst_cmp < 0) {\n        res = lst;\n      }\n    }\n  }\n  return res;",
    "  let m = grid.len();\n  let n = grid[0].len();\n  let dp = Vec::new(n);\n  for (let i = 0; i < n; i++) {\n    dp[i] = Vec::new(m);\n    for (let j = 0; j < m; j++) {\n      if (j == 0) {\n        dp[i][j] = grid[i][j];\n      } else {\n        dp[i][j] = dp[i][j - 1] + grid[i][j];\n      }\n    }\n  }\n  for (let i = 0; i < n; i++) {\n    for (let j = 0; j < m; j++) {\n      for (let k = 0; k < m; k++) {\n        if (j == k) continue;\n        if (dp[i][k] < dp[i][j]) {\n          dp[i][j] = dp[i][k];\n        }\n      }\n    }\n  }\n  let ans = Vec::new(k);\n  for (let i = 0; i < k; i++) {\n    ans[i] = dp[0][i];\n  }\n  return ans;",
    "  let mut result = Vec::new();\n  let mut visited = Vec::new();\n  let mut queue = Vec::new();\n  let mut min_path = Vec::new();\n  let mut min_index = 0;\n  let mut min_value = 0;\n  let mut min_path_length = 0;\n  let mut min_path_index = 0;\n  let mut min_path_value = 0;\n  let mut min_path_length_index = 0;\n  let mut min_path_length_value = 0;\n  let mut min_path_length_index_value = 0;\n  let mut min_path_length_value_value = 0;\n  let mut min_path_length_index_value_value = 0;\n  let mut min_path_length_value_value_value = 0;\n  let mut min_path_length_index_value_value_value = 0;\n  let mut min_path_length_value_value_value_value = 0;\n  let mut min_path_length_index_value_value_value_value = 0;\n  let mut min_path_length_value_value_value_value_value = 0;\n  let mut min_path_length_index_value_value_value_value_value = 0;\n  let mut min_path_length_value_value_value_value_value_value = 0;\n  let mut min_path_length_index_value_value_value_value_value_value = 0;\n  let mut min_path_length_value_value_value_value_value_value_value = 0;\n  let mut min_path_length_index_value_value_value_value_value_value_value = 0;\n  let mut min_path_length_value_value_value_value_value_value_value_value = 0;\n  let mut min_path_length_index_value_value_value_value_value_value_value_value = 0;\n  let mut min_path_length_value_value_value_value_value_value_value_value_value = 0;\n  let mut min_path_length_index_value_value_value_value",
    "    let grid_size = grid.len();\n    let grid_size_sq = grid_size * grid_size;\n    let grid_size_sq_minus_1 = grid_size_sq - 1;\n    let grid_size_sq_minus_k = grid_size_sq - k;\n    let grid_size_sq_minus_2 = grid_size_sq - 2;\n    let grid_size_sq_minus_k_minus_1 = grid_size_sq - k - 1;\n    let grid_size_sq_minus_k_minus_2 = grid_size_sq - k - 2;\n    let grid_size_sq_minus_k_minus_k = grid_size_sq - k - k;\n    let grid_size_sq_minus_k_minus_k_minus_1 = grid_size_sq - k - k - 1;\n    let grid_size_sq_minus_k_minus_k_minus_2 = grid_size_sq - k - k - 2;\n    let grid_size_sq_minus_k_minus_k_minus_k = grid_size_sq - k - k - k;\n    let grid_size_sq_minus_k_minus_k_minus_k_minus_1 = grid_size_sq - k - k - k - 1;\n    let grid_size_sq_minus_k_minus_k_minus_k_minus_2 = grid_size_sq - k - k - k - 2;\n    let grid_size_sq_minus_k_minus_k_minus_k_minus_k = grid_size_sq - k - k - k - k;\n    let grid_size_sq_minus_k_minus_k_minus_k_minus_k_minus_1 = grid_size_sq - k - k - k - k - 1;\n    let grid_size_sq_minus_k_minus_k_minus_k_minus_k_minus_2 = grid_size_sq - k - k - k - k - 2;\n    let grid_size_sq_minus_k_minus_k_minus_k_minus_k_minus_k = grid_size_sq -",
    "    let mut result = Vec::new();\n    let mut curr = Vec::new();\n    let mut prev = Vec::new();\n    let mut curr_index = 0;\n    let mut prev_index = 0;\n    let mut min_index = 0;\n    let mut min_value = 0;\n    let mut min_value_index = 0;\n    let mut min_value_index_prev = 0;\n    let mut min_value_index_curr = 0;\n    let mut min_value_index_prev_prev = 0;\n    let mut min_value_index_curr_prev = 0;\n    let mut min_value_index_prev_prev_prev = 0;\n    let mut min_value_index_curr_prev_prev = 0;\n    let mut min_value_index_prev_prev_prev_prev = 0;\n    let mut min_value_index_curr_prev_prev_prev_prev = 0;\n    let mut min_value_index_prev_prev_prev_prev_prev = 0;\n    let mut min_value_index_curr_prev_prev_prev_prev_prev = 0;\n    let mut min_value_index_prev_prev_prev_prev_prev_prev = 0;\n    let mut min_value_index_curr_prev_prev_prev_prev_prev_prev = 0;\n    let mut min_value_index_prev_prev_prev_prev_prev_prev_prev = 0;\n    let mut min_value_index_curr_prev_prev_prev_prev_prev_prev_prev = 0;\n    let mut min_value_index_prev_prev_prev_prev_prev_prev_prev_prev = 0;\n    let mut min_value_index_curr_prev_prev_prev_prev_prev_prev_prev_prev = 0;\n    let mut min_value_index_prev_prev_prev_prev_prev_prev_prev_prev_prev = 0;\n    let mut min_value_index_curr_prev_prev_prev_prev_prev_prev_prev_prev_prev = 0;\n    let mut min_value_index_prev_",
    "  let lst = vec![];\n  for (let i = 0; i < grid.len(); i++) {\n    let lst_i = vec![];\n    for (let j = 0; j < grid[i].len(); j++) {\n      let lst_i_j = vec![];\n      for (let jj = 0; jj < grid[i].len(); jj++) {\n        if (jj == j) {\n          lst_i_j.push(grid[i][j]);\n        } else {\n          lst_i_j.push(grid[i][jj]);\n        }\n      }\n      lst_i.push(lst_i_j);\n    }\n    lst.push(lst_i);\n  }\n  for (let i = 0; i < lst.len(); i++) {\n    for (let j = 0; j < lst[i].len(); j++) {\n      if (lst[i][j] == k) {\n        return lst[i];\n      }\n    }\n  }\n  return vec![];",
    "  let lst = vec![];\n  for i in 0..k {\n    for j in 0..k {\n      if grid[i][j] > 0 {\n        lst = lst.push(grid[i][j]);\n      }\n    }\n  }\n  lst.sort();\n  return lst;",
    "  let mut result = Vec::new();\n  let mut current = Vec::new();\n  let mut next = Vec::new();\n  let mut index = Vec::new();\n  let mut count = 0;\n  for (let i = 0; i < grid.len(); i++) {\n    for (let j = 0; j < grid[i].len(); j++) {\n      if (grid[i][j] == count) {\n        current.push_back(i);\n        next.push_back(j);\n        index.push_back(count);\n        count++;\n      }\n    }\n  }\n  for (let i = 0; i < count; i++) {\n    let mut current_i = current[i];\n    let mut next_i = next[i];\n    let mut index_i = index[i];\n    let mut current_j = current[index_i];\n    let mut next_j = next[index_i];\n    let mut index_j = index[index_i];\n    let mut current_k = current[index_j];\n    let mut next_k = next[index_j];\n    let mut index_k = index[index_j];\n    let mut current_l = current[index_k];\n    let mut next_l = next[index_k];\n    let mut index_l = index[index_k];\n    let mut current_m = current[index_l];\n    let mut next_m = next[index_l];\n    let mut index_m = index[index_l];\n    let mut current_n = current[index_m];\n    let mut next_n = next[index_m];\n    let mut index_n = index[index_m];\n    let mut current_o = current[index_n];\n    let mut next_o = next[index_n];\n    let mut index_o = index[index_n];\n    let mut current_p = current[index_o];\n    let mut next_p = next[index_o];\n    let mut index_p = index[index_o];\n    let mut current_q = current[index_p];\n    let mut next_q = next[",
    "  let dfs = Dfs{grid, 0, 0};\n  let res = Vec::new();\n  for isize i = 0; i < k; i++ {\n    let cur = dfs.next();\n    if cur.is_none() {\n      return res;\n    }\n    res = res.push(cur.unwrap());\n  }\n  return res;",
    "  let dfs = Dfs{};\n  let dfs_grid = grid.map(|v| vec![v.map(|x| dfs.visit(x))]);\n  let dfs_grid_len = dfs_grid.length();\n  let dfs_grid_idx = 0;\n  let dfs_grid_val = dfs_grid[0];\n  for (; dfs_grid_idx < dfs_grid_len; dfs_grid_idx += 1) {\n    let dfs_grid_val_idx = dfs_grid_idx;\n    for (; dfs_grid_val_idx < dfs_grid_len; dfs_grid_val_idx += 1) {\n      let dfs_grid_val_next = dfs_grid[dfs_grid_val_idx + 1];\n      if (dfs_grid_val < dfs_grid_val_next) {\n        dfs_grid_val = dfs_grid_val_next;\n      }\n    }\n  }\n  let res = dfs_grid[dfs_grid_idx];\n  for (; dfs_grid_idx < dfs_grid_len; dfs_grid_idx += 1) {\n    let dfs_grid_val_idx = dfs_grid_idx;\n    for (; dfs_grid_val_idx < dfs_grid_len; dfs_grid_val_idx += 1) {\n      let dfs_grid_val_next = dfs_grid[dfs_grid_val_idx + 1];\n      if (dfs_grid_val < dfs_grid_val_next) {\n        dfs_grid_val = dfs_grid_val_next;\n      }\n    }\n    res = vec![res, dfs_grid[dfs_grid_val_idx]];\n  }\n  return res;",
    "    let lst = vec![];\n    for _ in range(k) {\n        lst = lst.push_back(0);\n    }\n    for i in 0..grid.len() {\n        for j in 0..grid[i].len() {\n            if lst[0] == 0 {\n                lst = lst.push_back(grid[i][j]);\n            } else {\n                lst = lst.push_back(min(lst[0], grid[i][j]));\n            }\n        }\n    }\n    return lst;",
    "  let n = grid.len();\n  let m = grid[0].len();\n  let d = Vec::new(n * m);\n  let q = Vec::new(n * m);\n  let p = Vec::new(n * m);\n  let i = 0;\n  for (i = 0; i < n; i++) {\n    for (j = 0; j < m; j++) {\n      d[i * m + j] = grid[i][j];\n    }\n  }\n  for (i = 0; i < n; i++) {\n    for (j = 0; j < m; j++) {\n      q[i * m + j] = i * m + j + 1;\n    }\n  }\n  for (i = 0; i < n; i++) {\n    for (j = 0; j < m; j++) {\n      p[i * m + j] = i * m + j;\n    }\n  }\n  for (i = 0; i < n; i++) {\n    for (j = 0; j < m; j++) {\n      let d_i = d[i * m + j];\n      let q_i = q[i * m + j];\n      let p_i = p[i * m + j];\n      for (k = 0; k < n; k++) {\n        for (l = 0; l < m; l++) {\n          let d_k = d[k * m + l];\n          let q_k = q[k * m + l];\n          let p_k = p[k * m + l];\n          if (d_i == d_k && q_i < q_k) {\n            q[i * m + j] = q_k;\n            p[i * m + j] = p_k;\n          }\n          if (d_i == d_k && q_i == q_k && p_i < p_k) {\n            q[i * m + j] = q_k;\n            p[i * m + j] = p_k;\n          }\n        }\n      }\n    }\n  }\n  let result = Vec::new",
    "  let mut result = Vec::new();\n  let mut min_path = Vec::new();\n  let mut min_path_index = 0;\n  let mut min_path_value = 0;\n  let mut min_path_index_value = 0;\n  let mut min_path_value_value = 0;\n  let mut min_path_index_value_value = 0;\n  let mut min_path_index_value_value_value = 0;\n  let mut min_path_index_value_value_value_value = 0;\n  let mut min_path_index_value_value_value_value_value = 0;\n  let mut min_path_index_value_value_value_value_value_value = 0;\n  let mut min_path_index_value_value_value_value_value_value_value = 0;\n  let mut min_path_index_value_value_value_value_value_value_value_value = 0;\n  let mut min_path_index_value_value_value_value_value_value_value_value_value = 0;\n  let mut min_path_index_value_value_value_value_value_value_value_value_value_value = 0;\n  let mut min_path_index_value_value_value_value_value_value_value_value_value_value_value = 0;\n  let mut min_path_index_value_value_value_value_value_value_value_value_value_value_value_value = 0;\n  let mut min_path_index_value_value_value_value_value_value_value_value_value_value_value_value_value = 0;\n  let mut min_path_index_value_value_value_value_value_value_value_value_value_value_value_value_value_value = 0;\n  let mut min_path_index_value_value_value_value_value_value_value_value_value_value_value_value_value_value_value = 0;\n  let mut min_path_index_value_value_value_value_value_value_value_value_value_value_value_value",
    "    let mut result = Vec::new();\n    let mut min_path = Vec::new();\n    let mut min_path_len = 0;\n    let mut min_path_index = 0;\n    let mut min_path_index_len = 0;\n    let mut min_path_index_index = 0;\n    let mut min_path_index_index_len = 0;\n    let mut min_path_index_index_index = 0;\n    let mut min_path_index_index_index_len = 0;\n    let mut min_path_index_index_index_index = 0;\n    let mut min_path_index_index_index_index_len = 0;\n    let mut min_path_index_index_index_index_index = 0;\n    let mut min_path_index_index_index_index_index_len = 0;\n    let mut min_path_index_index_index_index_index_index = 0;\n    let mut min_path_index_index_index_index_index_index_len = 0;\n    let mut min_path_index_index_index_index_index_index_index = 0;\n    let mut min_path_index_index_index_index_index_index_index_len = 0;\n    let mut min_path_index_index_index_index_index_index_index_index = 0;\n    let mut min_path_index_index_index_index_index_index_index_index_len = 0;\n    let mut min_path_index_index_index_index_index_index_index_index_index = 0;\n    let mut min_path_index_index_index_index_index_index_index_index_index_len = 0;\n    let mut min_path_index_index_index_index_index_index_index_index_index_index = 0;\n    let mut min_path_index_index_index_index_index_index_index_index_index_index_len = 0;\n    let mut min_path_index_index_index_index_index_index_index_index_index_index_index = 0;\n    let mut min_path",
    "    let mut res = Vec::new();\n    let mut cur = Vec::new();\n    let mut prev = Vec::new();\n    let mut min = Vec::new();\n    let mut min_idx = 0;\n    for i in 0..grid.len() {\n        if i == 0 {\n            prev = grid[i];\n            cur = Vec::new();\n            min = Vec::new();\n            min_idx = 0;\n            continue;\n        }\n        min = Vec::new();\n        min_idx = 0;\n        for j in 0..i {\n            if grid[i][j] < grid[i - 1][j] {\n                min[min_idx] = grid[i][j];\n                min_idx += 1;\n            }\n        }\n        if min[min_idx - 1] < prev[min_idx - 1] {\n            prev = min;\n            cur = Vec::new();\n            min = Vec::new();\n            min_idx = 0;\n        } else {\n            cur = Vec::new();\n            for j in 0..min_idx - 1 {\n                cur[j] = prev[j];\n            }\n        }\n        res = Vec::new();\n        for j in 0..min_idx - 1 {\n            res[j] = cur[j];\n        }\n        res = res.append(min[min_idx - 1]);\n    }\n    return res.take(k);",
    "    let m = grid.len();\n    let n = grid[0].len();\n    let dp = Vec::new(n);\n    for (let i = 0; i < n; i++) {\n        dp[i] = Vec::new(n);\n        for (let j = 0; j < n; j++) {\n            if (i == 0 && j == 0) {\n                dp[i][j] = grid[0][0];\n            } else if (i == 0) {\n                dp[i][j] = dp[i][j - 1] + grid[0][j];\n            } else if (j == 0) {\n                dp[i][j] = dp[i - 1][j] + grid[i][0];\n            } else {\n                dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j];\n            }\n        }\n    }\n    let res = Vec::new(k);\n    for (let i = 0; i < k; i++) {\n        res[i] = dp[n - 1][n - 1];\n        for (let j = n - 1; j > 0; j--) {\n            if (dp[j][j] < res[i]) {\n                res[i] = dp[j][j];\n            }\n        }\n    }\n    return res;",
    "    let dp = Vec::new(grid.len() * grid[0].len());\n    for (i: isize) {\n        for (j: isize) {\n            if (i == 0 || j == 0) {\n                dp[i * grid[0].len() + j] = 1;\n            } else if (grid[i][j] == grid[i - 1][j] + 1) {\n                dp[i * grid[0].len() + j] = dp[(i - 1) * grid[0].len() + j] + 1;\n            } else {\n                dp[i * grid[0].len() + j] = dp[(i - 1) * grid[0].len() + j];\n            }\n        }\n    }\n    let res = Vec::new(k);\n    for (i: isize) {\n        if (dp[i * grid[0].len() + grid[0].len() - 1] == k) {\n            res[i] = grid[0].len() - 1;\n        } else {\n            res[i] = dp[i * grid[0].len() + grid[0].len() - 1];\n        }\n    }\n    return res;",
    "  let dfs = Dfs{grid, k};\n  let res = dfs.run();\n  return res;",
    "    let mut res = Vec::new();\n    let mut cur = Vec::new();\n    let mut prev = Vec::new();\n    let mut cur_idx = 0;\n    let mut prev_idx = 0;\n    let mut min_idx = 0;\n    let mut min_val = 0;\n    let mut min_val_idx = 0;\n    let mut min_val_idx_prev = 0;\n    let mut min_val_idx_cur = 0;\n    let mut min_val_idx_prev_prev = 0;\n    let mut min_val_idx_cur_prev = 0;\n    let mut min_val_idx_prev_prev_prev = 0;\n    let mut min_val_idx_cur_prev_prev_prev = 0;\n    let mut min_val_idx_prev_prev_prev_prev = 0;\n    let mut min_val_idx_cur_prev_prev_prev_prev = 0;\n    let mut min_val_idx_prev_prev_prev_prev_prev = 0;\n    let mut min_val_idx_cur_prev_prev_prev_prev_prev = 0;\n    let mut min_val_idx_prev_prev_prev_prev_prev_prev = 0;\n    let mut min_val_idx_cur_prev_prev_prev_prev_prev_prev = 0;\n    let mut min_val_idx_prev_prev_prev_prev_prev_prev_prev = 0;\n    let mut min_val_idx_cur_prev_prev_prev_prev_prev_prev_prev = 0;\n    let mut min_val_idx_prev_prev_prev_prev_prev_prev_prev_prev = 0;\n    let mut min_val_idx_cur_prev_prev_prev_prev_prev_prev_prev_prev = 0;\n    let mut min_val_idx_prev_prev_prev_prev_prev_prev_prev_prev_prev = 0;\n    let mut min_val_idx_cur_prev_prev_prev_prev_prev_prev_prev_prev_prev = 0",
    "  let mut result = Vec::new();\n  let mut lst = Vec::new();\n  let mut index = Vec::new();\n  let mut visited = Vec::new();\n  let mut queue = Vec::new();\n  let mut queue_index = Vec::new();\n  let mut queue_size = 0;\n  let mut visited_size = 0;\n  let mut result_size = 0;\n  let mut i = 0;\n  let mut j = 0;\n  let mut k = 0;\n  let mut m = 0;\n  let mut n = 0;\n  let mut p = 0;\n  let mut q = 0;\n  let mut r = 0;\n  let mut s = 0;\n  let mut t = 0;\n  let mut u = 0;\n  let mut v = 0;\n  let mut w = 0;\n  let mut x = 0;\n  let mut y = 0;\n  let mut z = 0;\n  let mut w_index = 0;\n  let mut w_size = 0;\n  let mut w_index_size = 0;\n  let mut w_size_size = 0;\n  let mut w_index_size_size = 0;\n  let mut w_size_size_size = 0;\n  let mut w_index_size_size_size = 0;\n  let mut w_size_size_size_size = 0;\n  let mut w_index_size_size_size_size = 0;\n  let mut w_size_size_size_size_size = 0;\n  let mut w_index_size_size_size_size_size = 0;\n  let mut w_size_size_size_size_size_size = 0;\n  let mut w_index_size_size_size_size_size_size = 0;\n  let mut w_size_size_size_size_size_size_size = 0;\n  let mut w_index_size_size_size_size_size_size_size = 0;\n  let mut w_size_size_size_size_size_size_size_size = 0;\n  let mut w_index_size_size_size_size_size_size_",
    "  let mut result = Vec::new();\n  let mut visited = Vec::new();\n  let mut queue = Vec::new();\n  queue.push(0);\n  visited.push(0);\n  let mut min = Vec::new();\n  min.push(0);\n  while (queue.len() > 0) {\n    let mut cur = queue.pop();\n    let mut cur_idx = visited.pop();\n    let mut cur_val = grid[cur_idx];\n    for (let i = 0; i < cur_val.len(); i++) {\n      let mut n = cur + i;\n      if (n >= grid.len()) {\n        continue;\n      }\n      if (visited.contains(n)) {\n        continue;\n      }\n      if (min.len() == k) {\n        if (cur_val[i] < min[0]) {\n          min.clear();\n          min.push(cur_val[i]);\n        }\n      } else {\n        if (cur_val[i] < min[0]) {\n          min.clear();\n          min.push(cur_val[i]);\n        }\n      }\n      queue.push(n);\n      visited.push(n);\n    }\n  }\n  result.push(min[0]);\n  return result;",
    "  let m = grid.len();\n  let n = grid[0].len();\n  let dp = Vec::new(n);\n  for (let i = 0; i < n; i++) {\n    dp[i] = Vec::new(n);\n    for (let j = 0; j < n; j++) {\n      dp[i][j] = grid[0][j];\n    }\n  }\n  for (let i = 1; i < m; i++) {\n    for (let j = 0; j < n; j++) {\n      let min = dp[j][0];\n      for (let k = 1; k < n; k++) {\n        if (dp[j][k] < min) {\n          min = dp[j][k];\n        }\n      }\n      dp[j][0] = min + grid[i][j];\n    }\n  }\n  let res = Vec::new(k);\n  for (let i = 0; i < k; i++) {\n    res[i] = dp[0][i];\n  }\n  return res;",
    "    let mut result = Vec::new();\n    let mut visited = Vec::new();\n    let mut queue = Vec::new();\n    queue.push(0);\n    visited.push(0);\n    while !queue.is_empty() {\n        let mut cur = queue.pop();\n        let mut lst = Vec::new();\n        for i in 0..k {\n            lst.push(grid[cur][i]);\n        }\n        if lst == visited {\n            result.push(grid[cur][k]);\n            continue;\n        }\n        for i in 0..k {\n            if grid[cur][i] == grid[cur][k] {\n                continue;\n            }\n            if visited.contains(grid[cur][i]) {\n                continue;\n            }\n            queue.push(i);\n            visited.push(grid[cur][i]);\n        }\n    }\n    return result;",
    "  let result = Vec::new(k);\n  let visited = Vec::new(k);\n  let queue = Vec::new(k);\n  let queue_index = 0;\n  let queue_head = 0;\n  let queue_tail = 0;\n  let queue_size = 0;\n  let queue_size_max = 0;\n  let queue_size_min = 0;\n  let queue_size_min_index = 0;\n  let queue_size_min_value = 0;\n  let queue_size_min_value_index = 0;\n  let queue_size_min_value_value = 0;\n  let queue_size_min_value_value_index = 0;\n  let queue_size_min_value_value_value = 0;\n  let queue_size_min_value_value_value_index = 0;\n  let queue_size_min_value_value_value_value = 0;\n  let queue_size_min_value_value_value_value_index = 0;\n  let queue_size_min_value_value_value_value_value = 0;\n  let queue_size_min_value_value_value_value_value_index = 0;\n  let queue_size_min_value_value_value_value_value_value = 0;\n  let queue_size_min_value_value_value_value_value_value_index = 0;\n  let queue_size_min_value_value_value_value_value_value_value = 0;\n  let queue_size_min_value_value_value_value_value_value_value_index = 0;\n  let queue_size_min_value_value_value_value_value_value_value_value = 0;\n  let queue_size_min_value_value_value_value_value_value_value_value_index = 0;\n  let queue_size_min_value_value_value_value_value_value_value_value_value = 0;\n  let queue_size_min_value_value_value_value_value_value_value_value_value_index = 0;\n  let queue_size_min_value_value_",
    "    let n = grid.len();\n    let m = grid[0].len();\n    let dp = Vec::new(n * m);\n    for (let i = 0; i < n; i++) {\n        for (let j = 0; j < m; j++) {\n            if (i == 0 && j == 0) {\n                dp[i * m + j] = grid[i][j];\n            } else if (i == 0) {\n                dp[i * m + j] = dp[(i - 1) * m + j] + grid[i][j];\n            } else if (j == 0) {\n                dp[i * m + j] = dp[i * m + (j - 1)] + grid[i][j];\n            } else {\n                dp[i * m + j] = min(dp[(i - 1) * m + j], dp[i * m + (j - 1)], dp[(i - 1) * m + (j - 1)]) + grid[i][j];\n            }\n        }\n    }\n    let res = Vec::new(k);\n    for (let i = 0; i < k; i++) {\n        res[i] = dp[i * m + m - 1];\n    }\n    return res;",
    "    let lst = vec![];\n    for i in 0..k {\n        lst = lst.push(0);\n    }\n    for i in 0..grid.len() {\n        for j in 0..grid[i].len() {\n            if (lst[0] > grid[i][j]) {\n                lst = lst.set(0, grid[i][j]);\n            }\n            for k in 1..k {\n                if (lst[k] > grid[i][j]) {\n                    lst = lst.set(k, grid[i][j]);\n                }\n            }\n        }\n    }\n    return lst;",
    "  let m = grid.len();\n  let n = grid[0].len();\n  let dp = Vec::new(n + 1);\n  for (let i = 0; i < m; i++) {\n    for (let j = 0; j < n; j++) {\n      if (grid[i][j] == 0) {\n        continue;\n      }\n      let lst = Vec::new(k + 1);\n      lst[0] = grid[i][j];\n      for (let k = 1; k <= k; k++) {\n        if (i - 1 >= 0 && grid[i - 1][j] == lst[k - 1]) {\n          lst[k] = grid[i - 1][j];\n        } else if (j - 1 >= 0 && grid[i][j - 1] == lst[k - 1]) {\n          lst[k] = grid[i][j - 1];\n        } else if (i + 1 < m && grid[i + 1][j] == lst[k - 1]) {\n          lst[k] = grid[i + 1][j];\n        } else if (j + 1 < n && grid[i][j + 1] == lst[k - 1]) {\n          lst[k] = grid[i][j + 1];\n        } else {\n          lst[k] = 0;\n        }\n      }\n      dp[j + 1] = lst[k];\n    }\n  }\n  return dp;",
    "  let grid_len = grid.len();\n  let grid_len_sq = grid_len * grid_len;\n  let lst = [0] * grid_len_sq;\n  for (let i = 0; i < grid_len_sq; i++) {\n    lst[i] = grid[i % grid_len][i / grid_len];\n  }\n  let lst_len = lst.len();\n  for (let i = 0; i < lst_len; i++) {\n    let lst_i = lst[i];\n    for (let j = i + 1; j < lst_len; j++) {\n      let lst_j = lst[j];\n      if (lst_i < lst_j) {\n        lst[j] = lst_i;\n        lst[i] = lst_j;\n      }\n    }\n  }\n  let lst_len_sq = lst_len * lst_len;\n  let res = [0] * lst_len_sq;\n  for (let i = 0; i < lst_len_sq; i++) {\n    res[i] = lst[i % lst_len][i / lst_len];\n  }\n  for (let i = 0; i < lst_len_sq; i++) {\n    for (let j = 0; j < lst_len_sq; j++) {\n      if (i == j) {\n        continue;\n      }\n      let lst_i = lst[i % lst_len];\n      let lst_j = lst[j % lst_len];\n      if (lst_i < lst_j) {\n        res[i] = res[i];\n      } else if (lst_i > lst_j) {\n        res[i] = res[i];\n      } else {\n        res[i] = res[i];\n      }\n    }\n  }\n  for (let i = 0; i < lst_len_sq; i++) {\n    for (let j = 0; j < lst_len_sq",
    "    let mut result = Vec::new();\n    let mut min_path = Vec::new();\n    let mut min_path_length = 0;\n    let mut min_path_index = 0;\n    for i in 0..grid.len() {\n        for j in 0..grid[i].len() {\n            let mut cur_path = Vec::new();\n            let mut cur_path_length = 0;\n            let mut cur_path_index = 0;\n            for _ in 0..k {\n                let mut cur_cell = Vec::new();\n                for _ in 0..grid.len() {\n                    for _ in 0..grid[i].len() {\n                        if grid[i][j] == grid[i][j + 1] {\n                            cur_cell.push_back(grid[i][j]);\n                        }\n                    }\n                }\n                if cur_cell.len() > 0 {\n                    cur_path.push_back(cur_cell);\n                    cur_path_length += cur_cell.len();\n                    cur_path_index += 1;\n                }\n            }\n            if cur_path_length < min_path_length {\n                min_path_length = cur_path_length;\n                min_path_index = cur_path_index;\n                min_path = cur_path;\n            }\n        }\n    }\n    result.push_back(min_path[min_path_index]);\n    for _ in 0..min_path_index {\n        result.push_back(min_path[min_path_index - 1]);\n    }\n    return result;",
    "  let mut result = Vec::new();\n  let mut lst = Vec::new();\n  for (let i = 0; i < grid.len(); i++) {\n    for (let j = 0; j < grid[i].len(); j++) {\n      lst.push(grid[i][j]);\n    }\n  }\n  for (let i = 0; i < k; i++) {\n    let min = lst[0];\n    for (let j = 1; j < lst.len(); j++) {\n      if (lst[j] < min) {\n        min = lst[j];\n      }\n    }\n    result.push(min);\n    for (let j = 0; j < lst.len(); j++) {\n      if (lst[j] == min) {\n        lst[j] = lst[lst.len() - 1];\n        lst.pop();\n      }\n    }\n  }\n  return result;",
    "  let grid_len = grid.len();\n  let grid_len_sq = grid_len * grid_len;\n  let grid_len_sq_minus_k = grid_len_sq - k;\n  let grid_len_sq_minus_k_minus_1 = grid_len_sq_minus_k - 1;\n  let grid_len_sq_minus_k_minus_2 = grid_len_sq_minus_k - 2;\n  let grid_len_sq_minus_k_minus_3 = grid_len_sq_minus_k - 3;\n  let grid_len_sq_minus_k_minus_4 = grid_len_sq_minus_k - 4;\n  let grid_len_sq_minus_k_minus_5 = grid_len_sq_minus_k - 5;\n  let grid_len_sq_minus_k_minus_6 = grid_len_sq_minus_k - 6;\n  let grid_len_sq_minus_k_minus_7 = grid_len_sq_minus_k - 7;\n  let grid_len_sq_minus_k_minus_8 = grid_len_sq_minus_k - 8;\n  let grid_len_sq_minus_k_minus_9 = grid_len_sq_minus_k - 9;\n  let grid_len_sq_minus_k_minus_10 = grid_len_sq_minus_k - 10;\n  let grid_len_sq_minus_k_minus_11 = grid_len_sq_minus_k - 11;\n  let grid_len_sq_minus_k_minus_12 = grid_len_sq_minus_k - 12;\n  let grid_len_sq_minus_k_minus_13 = grid_len_sq_minus_k - 13;\n  let grid_len_sq_minus_k_minus_14 = grid_len_sq_minus_k - 14;\n  let grid_len_sq_minus_k_minus_15 = grid_len_sq_minus_k - 15;\n  let grid_len_sq_minus_k_minus_16 = grid_len_sq_minus_k - 16;",
    "  let mut result = Vec::new();\n  let mut current = Vec::new();\n  let mut next = Vec::new();\n  let mut index = Vec::new();\n  let mut visited = Vec::new();\n  let mut min = Vec::new();\n  let mut min_index = Vec::new();\n  let mut min_value = Vec::new();\n  let mut min_index_value = Vec::new();\n  let mut min_index_value_index = Vec::new();\n  let mut min_index_value_index_value = Vec::new();\n  let mut min_index_value_index_value_index = Vec::new();\n  let mut min_index_value_index_value_index_value = Vec::new();\n  let mut min_index_value_index_value_index_value_index = Vec::new();\n  let mut min_index_value_index_value_index_value_index_value = Vec::new();\n  let mut min_index_value_index_value_index_value_index_value_index = Vec::new();\n  let mut min_index_value_index_value_index_value_index_value_index_value = Vec::new();\n  let mut min_index_value_index_value_index_value_index_value_index_value_index = Vec::new();\n  let mut min_index_value_index_value_index_value_index_value_index_value_index_value = Vec::new();\n  let mut min_index_value_index_value_index_value_index_value_index_value_index_value_index = Vec::new();\n  let mut min_index_value_index_value_index_value_index_value_index_value_index_value_index_value = Vec::new();\n  let mut min_index_value_index_value_index_value_index_value_index_value_index_value_index_value_index = Vec::new();\n  let mut min_index_value_index_value_index_value_index_value_index_value_index_value_index_value_index_value = Vec::new();\n  let mut min_index_value",
    "  let grid_len = grid.len();\n  let grid_len_sq = grid_len * grid_len;\n  let grid_len_sq_p1 = grid_len_sq + 1;\n  let grid_len_sq_p1_p1 = grid_len_sq_p1 + 1;\n  let grid_len_sq_p1_p1_p1 = grid_len_sq_p1_p1 + 1;\n  let grid_len_sq_p1_p1_p1_p1 = grid_len_sq_p1_p1_p1 + 1;\n  let grid_len_sq_p1_p1_p1_p1_p1 = grid_len_sq_p1_p1_p1_p1 + 1;\n  let grid_len_sq_p1_p1_p1_p1_p1_p1 = grid_len_sq_p1_p1_p1_p1_p1 + 1;\n  let grid_len_sq_p1_p1_p1_p1_p1_p1_p1 = grid_len_sq_p1_p1_p1_p1_p1_p1 + 1;\n  let grid_len_sq_p1_p1_p1_p1_p1_p1_p1_p1 = grid_len_sq_p1_p1_p1_p1_p1_p1_p1 + 1;\n  let grid_len_sq_p1_p1_p1_p1_p1_p1_p1_p1_p1 = grid_len_sq_p1_p1_p1_p1_p1_p1_p1_p1 + 1;\n  let grid_len_sq_p1_p1_p1_p1_p1_p1_p1_p1_p1_p1 = grid_len_sq_p1_p1_p1_p1_p1_p1_p1_p1_p1 + 1;\n  let grid_len_sq_p1_p1_",
    "  let mut result = Vec::new();\n  let mut curr = Vec::new();\n  let mut next = Vec::new();\n  let mut curr_index = 0;\n  let mut next_index = 0;\n  let mut min_index = 0;\n  let mut min_value = 0;\n  let mut min_value_index = 0;\n  let mut min_value_value = 0;\n  let mut min_value_value_index = 0;\n  let mut min_value_value_value = 0;\n  let mut min_value_value_value_index = 0;\n  let mut min_value_value_value_value = 0;\n  let mut min_value_value_value_value_index = 0;\n  let mut min_value_value_value_value_value = 0;\n  let mut min_value_value_value_value_value_index = 0;\n  let mut min_value_value_value_value_value_value = 0;\n  let mut min_value_value_value_value_value_value_index = 0;\n  let mut min_value_value_value_value_value_value_value = 0;\n  let mut min_value_value_value_value_value_value_value_index = 0;\n  let mut min_value_value_value_value_value_value_value_value = 0;\n  let mut min_value_value_value_value_value_value_value_value_index = 0;\n  let mut min_value_value_value_value_value_value_value_value_value = 0;\n  let mut min_value_value_value_value_value_value_value_value_value_index = 0;\n  let mut min_value_value_value_value_value_value_value_value_value_value = 0;\n  let mut min_value_value_value_value_value_value_value_value_value_value_index = 0;\n  let mut min_value_value_value_value_value_value_value_value_value_value_value = 0;\n  let mut min_value_value_value_value_value_value_value_value",
    "    let n = grid.len();\n    let m = grid[0].len();\n    let dp = Vec::new(n * m);\n    for (let i = 0; i < n; i++) {\n        for (let j = 0; j < m; j++) {\n            if (i == 0 && j == 0) {\n                dp[i * m + j] = grid[i][j];\n            } else if (i == 0) {\n                dp[i * m + j] = dp[(i - 1) * m + j] + grid[i][j];\n            } else if (j == 0) {\n                dp[i * m + j] = dp[i * m + (j - 1)] + grid[i][j];\n            } else {\n                dp[i * m + j] = min(dp[(i - 1) * m + j], dp[i * m + (j - 1)], dp[(i - 1) * m + (j - 1)]) + grid[i][j];\n            }\n        }\n    }\n    let res = Vec::new(k);\n    for (let i = 0; i < k; i++) {\n        res[i] = dp[i * m + m - 1];\n    }\n    return res;",
    "    let mut result = Vec::new();\n    let mut curr = Vec::new();\n    let mut prev = Vec::new();\n    let mut min = Vec::new();\n    let mut min_index = 0;\n    let mut min_value = 0;\n    let mut min_prev = 0;\n    let mut min_prev_index = 0;\n    for (let i = 0; i < grid.len(); i++) {\n        for (let j = 0; j < grid[i].len(); j++) {\n            if (grid[i][j] == 0) {\n                continue;\n            }\n            if (i == 0 && j == 0) {\n                min_value = grid[i][j];\n                min_index = 0;\n                min_prev = 0;\n                min_prev_index = 0;\n                continue;\n            }\n            if (grid[i][j] < min_value) {\n                min_value = grid[i][j];\n                min_index = i;\n                min_prev = i - 1;\n                min_prev_index = j;\n                continue;\n            }\n            if (grid[i][j] == min_value) {\n                if (j == min_prev_index) {\n                    min_prev = i - 1;\n                    min_prev_index = j;\n                }\n                if (i == min_index) {\n                    min_index = i;\n                    min_prev = i - 1;\n                    min_prev_index = j;\n                }\n            }\n        }\n    }\n    for (let i = 0; i < k; i++) {\n        if (min_prev == 0) {\n            result.push_back(min_value);\n        } else {\n            result.push_back(grid[min_prev][min_prev_index]);\n        }\n        min_prev = min_prev - 1;\n        min_prev_index = min_prev_index + 1;\n    }\n    return result;",
    "    let mut lst = vec![];\n    for i in 1..k {\n        lst = vec![];\n        for j in 0..grid.len() - 1 {\n            if grid[j].len() > i {\n                lst.push_back(grid[j][i]);\n            }\n        }\n        lst.sort();\n    }\n    return lst;",
    "  let grid_len = grid.len();\n  let grid_len_sq = grid_len * grid_len;\n  let grid_len_sq_pow_k = grid_len_sq ** k;\n  let grid_len_sq_pow_k_minus_1 = grid_len_sq_pow_k - 1;\n  let grid_len_sq_pow_k_minus_2 = grid_len_sq_pow_k - 2;\n  let grid_len_sq_pow_k_minus_3 = grid_len_sq_pow_k - 3;\n  let grid_len_sq_pow_k_minus_4 = grid_len_sq_pow_k - 4;\n  let grid_len_sq_pow_k_minus_5 = grid_len_sq_pow_k - 5;\n  let grid_len_sq_pow_k_minus_6 = grid_len_sq_pow_k - 6;\n  let grid_len_sq_pow_k_minus_7 = grid_len_sq_pow_k - 7;\n  let grid_len_sq_pow_k_minus_8 = grid_len_sq_pow_k - 8;\n  let grid_len_sq_pow_k_minus_9 = grid_len_sq_pow_k - 9;\n  let grid_len_sq_pow_k_minus_10 = grid_len_sq_pow_k - 10;\n  let grid_len_sq_pow_k_minus_11 = grid_len_sq_pow_k - 11;\n  let grid_len_sq_pow_k_minus_12 = grid_len_sq_pow_k - 12;\n  let grid_len_sq_pow_k_minus_13 = grid_len_sq_pow_k - 13;\n  let grid_len_sq_pow_k_minus_14 = grid_len_sq_pow_k - 14;\n  let grid_len_sq_pow_k_minus_15 = grid_len_sq_pow_k -",
    "    let mut result = Vec::new();\n    let mut min_path = Vec::new();\n    let mut min_value = 1_isize;\n    let mut min_index = 0_isize;\n    let mut min_index_prev = 0_isize;\n    let mut min_index_prev_prev = 0_isize;\n    let mut min_index_prev_prev_prev = 0_isize;\n    let mut min_index_prev_prev_prev_prev = 0_isize;\n    let mut min_index_prev_prev_prev_prev_prev = 0_isize;\n    let mut min_index_prev_prev_prev_prev_prev_prev = 0_isize;\n    let mut min_index_prev_prev_prev_prev_prev_prev_prev = 0_isize;\n    let mut min_index_prev_prev_prev_prev_prev_prev_prev_prev = 0_isize;\n    let mut min_index_prev_prev_prev_prev_prev_prev_prev_prev_prev = 0_isize;\n    let mut min_index_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev = 0_isize;\n    let mut min_index_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev = 0_isize;\n    let mut min_index_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev = 0_isize;\n    let mut min_index_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev = 0_isize;\n    let mut min_index_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev = 0_isize;\n    let mut min_index_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev = 0_isize;\n    let mut min_index_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_",
    "  let result = Vec.new(k);\n  let visited = Vec.new(grid.len);\n  let queue = Vec.new(grid.len);\n  queue.push(0);\n  visited.set(0, true);\n  result.set(0, grid[0][0]);\n  while (queue.len > 0) {\n    let cell = queue.pop();\n    for (let i = 0; i < 4; i++) {\n      let next = cell + i;\n      if (next < grid.len && !visited.get(next)) {\n        queue.push(next);\n        visited.set(next, true);\n        result.set(k - 1, grid[next][0]);\n      }\n    }\n  }\n  return result;",
    "  let grid_len = grid.len();\n  let grid_len_sq = grid_len * grid_len;\n  let grid_len_sq_pow_k = grid_len_sq ** k;\n  let grid_len_sq_pow_k_minus_1 = grid_len_sq_pow_k - 1;\n  let grid_len_sq_pow_k_minus_2 = grid_len_sq_pow_k - 2;\n  let grid_len_sq_pow_k_minus_3 = grid_len_sq_pow_k - 3;\n  let grid_len_sq_pow_k_minus_4 = grid_len_sq_pow_k - 4;\n  let grid_len_sq_pow_k_minus_5 = grid_len_sq_pow_k - 5;\n  let grid_len_sq_pow_k_minus_6 = grid_len_sq_pow_k - 6;\n  let grid_len_sq_pow_k_minus_7 = grid_len_sq_pow_k - 7;\n  let grid_len_sq_pow_k_minus_8 = grid_len_sq_pow_k - 8;\n  let grid_len_sq_pow_k_minus_9 = grid_len_sq_pow_k - 9;\n  let grid_len_sq_pow_k_minus_10 = grid_len_sq_pow_k - 10;\n  let grid_len_sq_pow_k_minus_11 = grid_len_sq_pow_k - 11;\n  let grid_len_sq_pow_k_minus_12 = grid_len_sq_pow_k - 12;\n  let grid_len_sq_pow_k_minus_13 = grid_len_sq_pow_k - 13;\n  let grid_len_sq_pow_k_minus_14 = grid_len_sq_pow_k - 14;\n  let grid_len_sq_pow_k_minus_15 = grid_len_sq_pow_k -",
    "    let mut result = Vec::new();\n    let mut visited = Vec::new();\n    let mut queue = Vec::new();\n    queue.push(0);\n    visited.push(0);\n    while !queue.is_empty() {\n        let cell = queue.pop();\n        if cell >= grid.len() {\n            result.push(cell);\n            continue;\n        }\n        for i in 0..k {\n            let next_cell = cell + i;\n            if next_cell >= grid.len() {\n                continue;\n            }\n            if visited[next_cell] {\n                continue;\n            }\n            if grid[cell][i] < grid[next_cell][i] {\n                continue;\n            }\n            queue.push(next_cell);\n            visited.push(next_cell);\n        }\n    }\n    return result;",
    "  let mut result = Vec::new();\n  let mut lst = Vec::new();\n  for (let i = 0; i < grid.len(); i++) {\n    for (let j = 0; j < grid[i].len(); j++) {\n      if (grid[i][j] == 1) {\n        lst = Vec::new(k + 1);\n        lst[0] = i;\n        lst[1] = j;\n        break;\n      }\n    }\n  }\n  for (let i = 0; i < lst.len(); i++) {\n    for (let j = 0; j < lst.len(); j++) {\n      if (i == 0 && j == 0) continue;\n      if (grid[lst[i - 1]][lst[j - 1]] == 1) {\n        result = Vec::new(k + 1);\n        result[0] = lst[i - 1];\n        result[1] = lst[j - 1];\n        break;\n      }\n    }\n  }\n  return result;",
    "  let grid_len = grid.len();\n  let grid_len_sq = grid_len * grid_len;\n  let grid_len_sq_i = 1_i64 * grid_len_sq;\n  let grid_len_sq_i_k = grid_len_sq_i + k;\n  let grid_len_sq_i_k_1 = grid_len_sq_i_k + 1_i64;\n  let grid_len_sq_i_k_2 = grid_len_sq_i_k + 2_i64;\n  let grid_len_sq_i_k_3 = grid_len_sq_i_k + 3_i64;\n  let grid_len_sq_i_k_4 = grid_len_sq_i_k + 4_i64;\n  let grid_len_sq_i_k_5 = grid_len_sq_i_k + 5_i64;\n  let grid_len_sq_i_k_6 = grid_len_sq_i_k + 6_i64;\n  let grid_len_sq_i_k_7 = grid_len_sq_i_k + 7_i64;\n  let grid_len_sq_i_k_8 = grid_len_sq_i_k + 8_i64;\n  let grid_len_sq_i_k_9 = grid_len_sq_i_k + 9_i64;\n  let grid_len_sq_i_k_10 = grid_len_sq_i_k + 10_i64;\n  let grid_len_sq_i_k_11 = grid_len_sq_i_k + 11_i64;\n  let grid_len_sq_i_k_12 = grid_len_sq_i_k + 12_i64;\n  let grid_len_sq_i_k_13 = grid_len_sq_i_k + 13_i64;\n  let grid_len_sq_i_k_14 = grid_len_sq_i_k + 14_i64;\n  let grid_len_sq_i_k_15 = grid_len_sq",
    "  let mut res = Vec::new();\n  let mut lst = Vec::new();\n  let mut lst_prev = Vec::new();\n  let mut lst_next = Vec::new();\n  let mut lst_prev_next = Vec::new();\n  let mut lst_prev_next_prev = Vec::new();\n  let mut lst_prev_next_prev_next = Vec::new();\n  let mut lst_prev_next_prev_next_prev = Vec::new();\n  let mut lst_prev_next_prev_next_prev_next = Vec::new();\n  let mut lst_prev_next_prev_next_prev_next_prev = Vec::new();\n  let mut lst_prev_next_prev_next_prev_next_prev_next = Vec::new();\n  let mut lst_prev_next_prev_next_prev_next_prev_next_prev = Vec::new();\n  let mut lst_prev_next_prev_next_prev_next_prev_next_prev_next = Vec::new();\n  let mut lst_prev_next_prev_next_prev_next_prev_next_prev_next_prev = Vec::new();\n  let mut lst_prev_next_prev_next_prev_next_prev_next_prev_next_prev_next = Vec::new();\n  let mut lst_prev_next_prev_next_prev_next_prev_next_prev_next_prev_next_prev = Vec::new();\n  let mut lst_prev_next_prev_next_prev_next_prev_next_prev_next_prev_next_prev_next = Vec::new();\n  let mut lst_prev_next_prev_next_prev_next_prev_next_prev_next_prev_next_prev_next_prev = Vec::new();\n  let mut lst_prev_next_prev_next_prev_next_prev_next_prev_next_prev_next_prev_next_prev_next = Vec::new();\n  let mut lst_prev_next_prev_next_prev_next_prev_next_prev_next_prev_next_",
    "    let mut result = Vec::new();\n    let mut curr = 0;\n    for i in 0..k {\n        let mut lst = Vec::new();\n        for j in 0..grid.len() {\n            if i == 0 {\n                lst.push(grid[j][curr]);\n            } else {\n                lst.push(grid[j][curr]);\n                if j > 0 && lst[i - 1] > lst[i] {\n                    lst.push(grid[j - 1][curr]);\n                }\n                if j < grid.len() - 1 && lst[i - 1] > lst[i] {\n                    lst.push(grid[j + 1][curr]);\n                }\n            }\n        }\n        result.push(lst[k]);\n        curr = lst[k];\n    }\n    return result;",
    "  let n = grid.len();\n  let m = grid[0].len();\n  let dp = Vec::new(n * m);\n  for (let i = 0; i < n; i++) {\n    for (let j = 0; j < m; j++) {\n      if (i == 0 && j == 0) {\n        dp[0] = grid[i][j];\n      } else if (i == 0) {\n        dp[j] = grid[i][j];\n      } else if (j == 0) {\n        dp[i] = grid[i][j];\n      } else {\n        dp[i * m + j] = grid[i][j];\n      }\n    }\n  }\n  let ans = Vec::new(k);\n  for (let i = 0; i < k; i++) {\n    let min = dp[0];\n    for (let j = 1; j < n * m; j++) {\n      if (dp[j] < min) {\n        min = dp[j];\n        ans[i] = j;\n      }\n    }\n    for (let j = 0; j < i; j++) {\n      let idx = ans[j];\n      let idx_next = ans[i];\n      let idx_prev = ans[i - 1];\n      if (idx_next < idx_prev) {\n        ans[i] = idx_prev;\n      }\n    }\n  }\n  return ans;",
    "    let n = grid.len();\n    let m = grid[0].len();\n    let dp = Vec::new(n, 0);\n    let dp_prev = Vec::new(n, 0);\n    for i in 0..n {\n        for j in 0..m {\n            if (i == 0 && j == 0) {\n                dp[i] = 1;\n            } else if (i == 0) {\n                dp[i] = dp_prev[i] + 1;\n            } else if (j == 0) {\n                dp[i] = dp_prev[i] + 1;\n            } else {\n                dp[i] = min(dp_prev[i], dp_prev[i - 1]) + 1;\n            }\n            dp_prev[i] = dp[i];\n        }\n    }\n    let res = Vec::new(k, 0);\n    for i in 0..k {\n        res[i] = dp[n - 1];\n    }\n    return res;",
    "    let n = grid.len();\n    let m = grid[0].len();\n    let dp = Vec::new(n, 0);\n    for i in 0..n {\n        for j in 0..m {\n            if i == 0 || j == 0 {\n                dp[i] = 1;\n            } else if grid[i][j] == grid[i - 1][j] + 1 {\n                dp[i] = dp[i - 1] + 1;\n            } else {\n                dp[i] = dp[i - 1];\n            }\n        }\n    }\n    let ans = Vec::new(k, 0);\n    for i in 0..k {\n        ans[i] = dp[n - 1];\n        for j in 0..n - 1 {\n            if dp[j] == dp[j + 1] {\n                ans[i] = min(ans[i], dp[j]);\n            }\n        }\n    }\n    return ans;",
    "    let mut result = Vec::new();\n    let mut min_index = 0;\n    let mut min_value = 1;\n    for i in 0..k {\n        let mut min_value_i = 1;\n        for j in 0..i {\n            if grid[j][i] < grid[j][min_index] {\n                min_value_i = grid[j][i];\n            }\n        }\n        if min_value_i < min_value {\n            min_value = min_value_i;\n            min_index = i;\n        }\n    }\n    result.push_back(min_index);\n    for i in 0..k {\n        if grid[min_index][i] < grid[min_index][min_index] {\n            min_index = i;\n        }\n    }\n    result.push_back(min_index);\n    return result;",
    "  let mut min_path = Vec::new();\n  let mut min_path_length = 0;\n  let mut min_path_index = 0;\n  let mut min_path_index_prev = 0;\n  let mut min_path_index_next = 0;\n  let mut min_path_index_prev_prev = 0;\n  let mut min_path_index_next_next = 0;\n  let mut min_path_index_prev_prev_prev = 0;\n  let mut min_path_index_next_next_next = 0;\n  let mut min_path_index_prev_prev_prev_prev = 0;\n  let mut min_path_index_next_next_next_next = 0;\n  let mut min_path_index_prev_prev_prev_prev_prev = 0;\n  let mut min_path_index_next_next_next_next_next = 0;\n  let mut min_path_index_prev_prev_prev_prev_prev_prev = 0;\n  let mut min_path_index_next_next_next_next_next_next = 0;\n  let mut min_path_index_prev_prev_prev_prev_prev_prev_prev = 0;\n  let mut min_path_index_next_next_next_next_next_next_next = 0;\n  let mut min_path_index_prev_prev_prev_prev_prev_prev_prev_prev = 0;\n  let mut min_path_index_next_next_next_next_next_next_next_next = 0;\n  let mut min_path_index_prev_prev_prev_prev_prev_prev_prev_prev_prev = 0;\n  let mut min_path_index_next_next_next_next_next_next_next_next_next = 0;\n  let mut min_path_index_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev = 0;\n  let mut min_path_index_next_next_next_next_next_next_next_next_next_next = 0;\n  let mut min_path_index_prev_prev_prev_prev",
    "  let mut result = Vec::new();\n  let mut visited = Vec::new();\n  let mut queue = Vec::new();\n  queue.push(0);\n  visited.push(0);\n  let mut min = 1_isize;\n  for (let i = 0; i < grid.len(); i++) {\n    for (let j = 0; j < grid[i].len(); j++) {\n      if (grid[i][j] == 0) {\n        queue.push(i * grid[i].len() + j);\n      }\n    }\n  }\n  while (queue.len() > 0) {\n    let cur = queue.pop();\n    let i = cur / grid[0].len();\n    let j = cur % grid[0].len();\n    if (grid[i][j] < min) {\n      min = grid[i][j];\n      result = Vec::new();\n    }\n    if (i > 0 && grid[i - 1][j] == 0 && !visited.contains(i - 1)) {\n      queue.push(i - 1 * grid[0].len() + j);\n      visited.push(i - 1);\n    }\n    if (i < grid.len() - 1 && grid[i + 1][j] == 0 && !visited.contains(i + 1)) {\n      queue.push(i + 1 * grid[0].len() + j);\n      visited.push(i + 1);\n    }\n    if (j > 0 && grid[i][j - 1] == 0 && !visited.contains(i * grid[0].len() + j - 1)) {\n      queue.push(i * grid[0].len() + j - 1);\n      visited.push(i * grid[0].len() + j - 1);\n    }\n    if (j < grid[0].len() - 1 && grid[i][j + 1] == 0 && !visited.contains(i * grid[0].len() + j + 1)) {\n      queue.push(i * grid[0].len() + j + 1);\n      visited.push(i * grid[0].len",
    "  let grid_len = grid.len();\n  let grid_len_sq = grid_len * grid_len;\n  let grid_len_sq_pow_k = grid_len_sq ** k;\n  let grid_len_sq_pow_k_minus_1 = grid_len_sq_pow_k - 1;\n  let grid_len_sq_pow_k_minus_2 = grid_len_sq_pow_k - 2;\n  let grid_len_sq_pow_k_minus_3 = grid_len_sq_pow_k - 3;\n  let grid_len_sq_pow_k_minus_4 = grid_len_sq_pow_k - 4;\n  let grid_len_sq_pow_k_minus_5 = grid_len_sq_pow_k - 5;\n  let grid_len_sq_pow_k_minus_6 = grid_len_sq_pow_k - 6;\n  let grid_len_sq_pow_k_minus_7 = grid_len_sq_pow_k - 7;\n  let grid_len_sq_pow_k_minus_8 = grid_len_sq_pow_k - 8;\n  let grid_len_sq_pow_k_minus_9 = grid_len_sq_pow_k - 9;\n  let grid_len_sq_pow_k_minus_10 = grid_len_sq_pow_k - 10;\n  let grid_len_sq_pow_k_minus_11 = grid_len_sq_pow_k - 11;\n  let grid_len_sq_pow_k_minus_12 = grid_len_sq_pow_k - 12;\n  let grid_len_sq_pow_k_minus_13 = grid_len_sq_pow_k - 13;\n  let grid_len_sq_pow_k_minus_14 = grid_len_sq_pow_k - 14;\n  let grid_len_sq_pow_k_minus_15 = grid_len_sq_pow_k -",
    "  let dfs = Dfs{grid, k};\n  let res = dfs.run();\n  return res;",
    "  let mut result = Vec::new();\n  let mut min_path = Vec::new();\n  let mut min_value = 1_isize;\n  let mut min_index = 0_isize;\n  let mut min_index_prev = 0_isize;\n  let mut min_index_prev_prev = 0_isize;\n  let mut min_index_prev_prev_prev = 0_isize;\n  let mut min_index_prev_prev_prev_prev = 0_isize;\n  let mut min_index_prev_prev_prev_prev_prev = 0_isize;\n  let mut min_index_prev_prev_prev_prev_prev_prev = 0_isize;\n  let mut min_index_prev_prev_prev_prev_prev_prev_prev = 0_isize;\n  let mut min_index_prev_prev_prev_prev_prev_prev_prev_prev = 0_isize;\n  let mut min_index_prev_prev_prev_prev_prev_prev_prev_prev_prev = 0_isize;\n  let mut min_index_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev = 0_isize;\n  let mut min_index_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev = 0_isize;\n  let mut min_index_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev = 0_isize;\n  let mut min_index_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev = 0_isize;\n  let mut min_index_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev = 0_isize;\n  let mut min_index_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev = 0_isize;\n  let mut min_index_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_",
    "  let m = grid.len();\n  let n = grid[0].len();\n  let dp = Vec::new(n, 0);\n  let dp_prev = Vec::new(n, 0);\n  let dp_prev_prev = Vec::new(n, 0);\n  for (let i = 0; i < m; i++) {\n    for (let j = 0; j < n; j++) {\n      if (i == 0 && j == 0) {\n        dp[j] = grid[i][j];\n      } else if (i == 0) {\n        dp[j] = dp[j - 1] + grid[i][j];\n      } else if (j == 0) {\n        dp[j] = dp[j] + grid[i][j];\n      } else {\n        dp[j] = min(dp[j - 1], dp[j]) + grid[i][j];\n      }\n    }\n  }\n  for (let i = 0; i < n; i++) {\n    dp_prev[i] = dp[i];\n  }\n  for (let i = 0; i < n; i++) {\n    for (let j = 0; j < n; j++) {\n      if (i == 0 && j == 0) {\n        dp_prev_prev[j] = dp[j];\n      } else if (i == 0) {\n        dp_prev_prev[j] = dp_prev[j - 1];\n      } else if (j == 0) {\n        dp_prev_prev[j] = dp_prev[j];\n      } else {\n        dp_prev_prev[j] = min(dp_prev_prev[j - 1], dp_prev[j]) + grid[i][j];\n      }\n    }\n  }\n  let min_path = Vec::new(k, 0);\n  for (let i = 0; i < k; i++) {\n    min_path[i] = dp_prev_prev[n - 1];\n  }\n  return min_path;",
    "  let m = grid.len();\n  let n = grid[0].len();\n  let dp = Vec::new(n);\n  for (let i = 0; i < n; i++) {\n    dp[i] = Vec::new(n);\n    for (let j = 0; j < n; j++) {\n      if (i == 0 && j == 0) {\n        dp[i][j] = grid[0][0];\n      } else if (i == 0) {\n        dp[i][j] = dp[i][j - 1] + grid[0][j];\n      } else if (j == 0) {\n        dp[i][j] = dp[i - 1][j] + grid[i][0];\n      } else {\n        dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j];\n      }\n    }\n  }\n  let ans = Vec::new(k);\n  for (let i = 0; i < k; i++) {\n    ans[i] = dp[n - 1][n - 1];\n    for (let j = n - 1; j > 0; j--) {\n      if (dp[j - 1][j] < dp[j][n - 1]) {\n        dp[j - 1][j] = dp[j][n - 1];\n      }\n    }\n  }\n  return ans;",
    "  let n = grid.len();\n  let m = grid[0].len();\n  let d = Vec::new(n * m);\n  let q = Vec::new(n * m);\n  let p = Vec::new(n * m);\n  let i = 0;\n  let j = 0;\n  let x = 0;\n  let y = 0;\n  let z = 0;\n  let l = 0;\n  let r = 0;\n  let u = 0;\n  let v = 0;\n  let w = 0;\n  let f = 0;\n  let g = 0;\n  let h = 0;\n  let s = 0;\n  let t = 0;\n  let a = 0;\n  let b = 0;\n  let c = 0;\n  let d_ = 0;\n  let e = 0;\n  let f_ = 0;\n  let g_ = 0;\n  let h_ = 0;\n  let i_ = 0;\n  let j_ = 0;\n  let k_ = 0;\n  let l_ = 0;\n  let m_ = 0;\n  let n_ = 0;\n  let o_ = 0;\n  let p_ = 0;\n  let q_ = 0;\n  let r_ = 0;\n  let s_ = 0;\n  let t_ = 0;\n  let u_ = 0;\n  let v_ = 0;\n  let w_ = 0;\n  let x_ = 0;\n  let y_ = 0;\n  let z_ = 0;\n  let _ = 0;\n  let _1 = 0;\n  let _2 = 0;\n  let _3 = 0;\n  let _4 = 0;\n  let _5 = 0;\n  let _6 = 0;\n  let _7 = 0;\n  let _8 = 0;\n  let _9 = 0;\n  let _10 = 0;\n  let _11 = 0;\n  let _12 = 0;\n  let _13 = 0;\n  let _14 = 0;\n  let _15 = 0;\n  let _16 = 0;\n  let _17 = 0;\n  ",
    "    let mut result = Vec::new();\n    let mut current = Vec::new();\n    let mut next = Vec::new();\n    let mut current_index = 0;\n    let mut next_index = 0;\n    let mut current_value = 0;\n    let mut next_value = 0;\n    let mut current_path = Vec::new();\n    let mut next_path = Vec::new();\n    let mut current_path_index = 0;\n    let mut next_path_index = 0;\n    let mut current_path_value = 0;\n    let mut next_path_value = 0;\n    let mut current_path_path = Vec::new();\n    let mut next_path_path = Vec::new();\n    let mut current_path_path_index = 0;\n    let mut next_path_path_index = 0;\n    let mut current_path_path_value = 0;\n    let mut next_path_path_value = 0;\n    let mut current_path_path_path = Vec::new();\n    let mut next_path_path_path = Vec::new();\n    let mut current_path_path_path_index = 0;\n    let mut next_path_path_path_index = 0;\n    let mut current_path_path_path_value = 0;\n    let mut next_path_path_path_value = 0;\n    let mut current_path_path_path_path = Vec::new();\n    let mut next_path_path_path_path = Vec::new();\n    let mut current_path_path_path_path_index = 0;\n    let mut next_path_path_path_path_index = 0;\n    let mut current_path_path_path_path_value = 0;\n    let mut next_path_path_path_path_value = 0;\n    let mut current_path_path_path_path_path = Vec::new();\n    let mut next_path_path_path_path_path = Vec::new();\n    let mut current_path_path_path_path_path_index = 0;\n    let mut next_path_path_path_path_path_index = 0;\n    let",
    "    let mut result = Vec::new();\n    let mut min_path = Vec::new();\n    let mut min_path_len = 0;\n    let mut min_path_index = 0;\n    let mut min_path_index_len = 0;\n    let mut min_path_index_index = 0;\n    let mut min_path_index_index_len = 0;\n    let mut min_path_index_index_index = 0;\n    let mut min_path_index_index_index_len = 0;\n    let mut min_path_index_index_index_index = 0;\n    let mut min_path_index_index_index_index_len = 0;\n    let mut min_path_index_index_index_index_index = 0;\n    let mut min_path_index_index_index_index_index_len = 0;\n    let mut min_path_index_index_index_index_index_index = 0;\n    let mut min_path_index_index_index_index_index_index_len = 0;\n    let mut min_path_index_index_index_index_index_index_index = 0;\n    let mut min_path_index_index_index_index_index_index_index_len = 0;\n    let mut min_path_index_index_index_index_index_index_index_index = 0;\n    let mut min_path_index_index_index_index_index_index_index_index_len = 0;\n    let mut min_path_index_index_index_index_index_index_index_index_index = 0;\n    let mut min_path_index_index_index_index_index_index_index_index_index_len = 0;\n    let mut min_path_index_index_index_index_index_index_index_index_index_index = 0;\n    let mut min_path_index_index_index_index_index_index_index_index_index_index_len = 0;\n    let mut min_path_index_index_index_index_index_index_index_index_index_index_index = 0;\n    let mut min_path",
    "    let mut result = vec![];\n    let mut cur = vec![];\n    for _ in range(k) {\n        result = cur;\n        for _ in range(grid.len()) {\n            cur = cur.append(grid[cur.len() - 1]);\n            grid = grid.remove(grid.len() - 1);\n        }\n    }\n    return result;",
    "  let lst: Vec<isize> = vec![];\n  for i in 0..k {\n    for j in 0..k {\n      if grid[i][j] > 0 {\n        lst = lst.push(grid[i][j]);\n      }\n    }\n  }\n  for i in 0..k {\n    for j in 0..k {\n      if grid[i][j] > 0 {\n        if lst.len() > 0 && lst[lst.len() - 1] < grid[i][j] {\n          lst = lst.push(grid[i][j]);\n        }\n      }\n    }\n  }\n  return lst;",
    "    let mut result = Vec::new();\n    let mut visited = Vec::new();\n    let mut queue = Vec::new();\n    queue.push(0);\n    visited.push(0);\n    while !queue.is_empty() {\n        let mut cur = queue.pop();\n        let mut lst = Vec::new();\n        for i in 0..k {\n            lst.push(grid[cur][i]);\n        }\n        if lst.is_empty() {\n            result.push(0);\n        } else {\n            if lst.is_last() {\n                result.push(lst.last());\n            } else {\n                for i in 0..k {\n                    if lst.last() < grid[cur][i] {\n                        result.push(grid[cur][i]);\n                        break;\n                    }\n                }\n            }\n        }\n        for i in 0..k {\n            if grid[cur][i] != result.last() {\n                queue.push(i);\n                visited.push(i);\n            }\n        }\n    }\n    return result;",
    "  let lst = vec![];\n  for (let i = 0; i < grid.len(); i++) {\n    let lst_i = vec![];\n    for (let j = 0; j < grid[i].len(); j++) {\n      lst_i = vec![lst_i.len() + 1, grid[i][j]];\n    }\n    lst = vec![min(lst, lst_i), i];\n  }\n  lst = vec![lst.len() - k + 1];\n  return lst;",
    "  let m = grid.len();\n  let n = grid[0].len();\n  let dp = Vec::new(n);\n  dp[0] = 1;\n  for (let i = 1; i < n; i++) {\n    dp[i] = dp[i - 1] + grid[0][i - 1];\n  }\n  for (let i = 1; i < m; i++) {\n    for (let j = 1; j < n; j++) {\n      let min = dp[j - 1] + grid[i - 1][j - 1];\n      for (let k = 0; k < j; k++) {\n        let val = grid[i - 1][k] + grid[k][j - 1];\n        if (val < min) {\n          min = val;\n        }\n      }\n      dp[j] = min;\n    }\n  }\n  let res = Vec::new(k);\n  for (let i = 0; i < k; i++) {\n    res[i] = dp[n - 1] - dp[i];\n  }\n  return res;",
    "  let m = grid.len();\n  let n = grid[0].len();\n  let dp = Vec::new(n);\n  dp[0] = 1;\n  for (let i = 1; i < m; i++) {\n    for (let j = 0; j < n; j++) {\n      let p = dp[j];\n      if (grid[i][j] == 1) {\n        let q = dp[j + 1];\n        if (q < p) {\n          dp[j + 1] = p;\n        }\n        let r = dp[j - 1];\n        if (r < p) {\n          dp[j - 1] = p;\n        }\n        let s = dp[j + n];\n        if (s < p) {\n          dp[j + n] = p;\n        }\n        let t = dp[j - n];\n        if (t < p) {\n          dp[j - n] = p;\n        }\n      }\n    }\n  }\n  let ans = Vec::new(k);\n  for (let i = 0; i < k; i++) {\n    ans[i] = dp[i];\n  }\n  return ans;",
    "  let lst: Vec<isize> = vec![];\n  for i in 1..k {\n    for j in 0..i - 1 {\n      if grid[i][j] < grid[i][j + 1] {\n        lst = lst.push_back(grid[i][j]);\n      }\n    }\n  }\n  return lst;",
    "    let m = grid.len();\n    let n = grid[0].len();\n    let dp = Vec::new(n);\n    for (let i = 0; i < n; i++) {\n        dp[i] = Vec::new(m);\n        for (let j = 0; j < m; j++) {\n            let min = 1_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000",
    "    let mut result = Vec::new();\n    let mut visited = Vec::new();\n    let mut queue = Vec::new();\n    let mut min_path = Vec::new();\n    let mut min_value = 1_i64;\n    let mut min_index = 0_i64;\n    let mut min_index_value = 0_i64;\n    let mut min_index_value_index = 0_i64;\n    let mut min_index_value_index_value = 0_i64;\n    let mut min_index_value_index_value_index = 0_i64;\n    let mut min_index_value_index_value_index_value = 0_i64;\n    let mut min_index_value_index_value_index_value_index = 0_i64;\n    let mut min_index_value_index_value_index_value_index_value = 0_i64;\n    let mut min_index_value_index_value_index_value_index_value_index = 0_i64;\n    let mut min_index_value_index_value_index_value_index_value_index_value = 0_i64;\n    let mut min_index_value_index_value_index_value_index_value_index_value_index = 0_i64;\n    let mut min_index_value_index_value_index_value_index_value_index_value_index_value = 0_i64;\n    let mut min_index_value_index_value_index_value_index_value_index_value_index_value_index = 0_i64;\n    let mut min_index_value_index_value_index_value_index_value_index_value_index_value_index_value = 0_i64;\n    let mut min_index_value_index_value_index_value_index_value_index_value_index_value_index_value_index = 0_i64;\n    let mut min_index_value_index_value_index_value_index_value_index_value_index_value_index_value_index_value = 0_i64;\n    let mut min_index_value_",
    "  let mut result = Vec::new();\n  let mut curr = Vec::new();\n  let mut next = Vec::new();\n  let mut curr_idx = 0;\n  let mut next_idx = 0;\n  let mut min_idx = 0;\n  let mut min_val = 0;\n  let mut min_val_idx = 0;\n  let mut min_val_idx_idx = 0;\n  let mut min_val_idx_idx_idx = 0;\n  let mut min_val_idx_idx_idx_idx = 0;\n  let mut min_val_idx_idx_idx_idx_idx = 0;\n  let mut min_val_idx_idx_idx_idx_idx_idx = 0;\n  let mut min_val_idx_idx_idx_idx_idx_idx_idx = 0;\n  let mut min_val_idx_idx_idx_idx_idx_idx_idx_idx = 0;\n  let mut min_val_idx_idx_idx_idx_idx_idx_idx_idx_idx = 0;\n  let mut min_val_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx = 0;\n  let mut min_val_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx = 0;\n  let mut min_val_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx = 0;\n  let mut min_val_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx_idx = 0;\n  let mut min_val_idx_idx_idx_idx_idx_idx_idx_idx_idx_",
    "  let n = grid.len();\n  let m = grid[0].len();\n  let dp = Vec::new(n * m);\n  for (let i = 0; i < n; i++) {\n    for (let j = 0; j < m; j++) {\n      if (i == 0 && j == 0) {\n        dp[i * m + j] = grid[i][j];\n      } else if (i == 0) {\n        dp[i * m + j] = dp[(i - 1) * m + j] + grid[i][j];\n      } else if (j == 0) {\n        dp[i * m + j] = dp[i * m + (j - 1)] + grid[i][j];\n      } else {\n        dp[i * m + j] = min(dp[(i - 1) * m + j], dp[i * m + (j - 1)], dp[(i - 1) * m + (j - 1)]) + grid[i][j];\n      }\n    }\n  }\n  let ans = Vec::new(k);\n  for (let i = 0; i < k; i++) {\n    ans[i] = dp[i * m + m - 1];\n  }\n  return ans;",
    "    let mut result = Vec::new();\n    let mut lst = Vec::new();\n    let mut i = 0;\n    let mut j = 0;\n    let mut k = 0;\n    for (i = 0; i < grid.len(); i++) {\n        for (j = 0; j < grid[i].len(); j++) {\n            if (grid[i][j] == 1) {\n                lst = Vec::new();\n                lst.push(i);\n                lst.push(j);\n                k = 1;\n                result.push(1);\n                while (k < k) {\n                    if (lst.len() > 0) {\n                        let mut lst_i = lst.pop();\n                        let mut lst_j = lst.pop();\n                        if (lst_i > 0 && lst_i < grid.len() && lst_j > 0 && lst_j < grid[lst_i].len()) {\n                            if (grid[lst_i][lst_j] == 1) {\n                                lst.push(lst_i);\n                                lst.push(lst_j);\n                                result.push(1);\n                                k++;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    return result;",
    "  let m = grid.len();\n  let n = grid[0].len();\n  let dp = Vec::new(n + 1);\n  for (let i = 1; i <= n; i++) {\n    dp[i] = Vec::new(n + 1);\n    for (let j = 1; j <= n; j++) {\n      let min = 1_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000_000",
    "    let mut res = Vec::new();\n    let mut cur = Vec::new();\n    let mut next = Vec::new();\n    let mut last = Vec::new();\n    let mut i = 0;\n    let mut j = 0;\n    let mut k = 0;\n    let mut min = 0;\n    let mut min_i = 0;\n    let mut min_j = 0;\n    let mut min_k = 0;\n    let mut min_lst = Vec::new();\n    for (i = 0; i < grid.len(); i++) {\n        for (j = 0; j < grid[i].len(); j++) {\n            if (grid[i][j] == 1) {\n                cur.push_back(i);\n                next.push_back(j);\n                k = 1;\n                last.push_back(i);\n                last.push_back(j);\n                min = grid[i][j];\n                min_i = i;\n                min_j = j;\n                min_k = k;\n                min_lst = last;\n            }\n        }\n    }\n    for (i = 0; i < grid.len(); i++) {\n        for (j = 0; j < grid[i].len(); j++) {\n            if (grid[i][j] == 1) {\n                if (k == 1) {\n                    if (i == last[0] && j == last[1]) {\n                        res.push_back(min);\n                        k = min_k;\n                        last = min_lst;\n                    } else {\n                        k = min_k;\n                        last = min_lst;\n                    }\n                } else {\n                    if (i == last[0] && j == last[1]) {\n                        res.push_back(min);\n                        k = min_k;\n                        last = min_lst;\n                    } else {\n                        k = min_k;\n                        last = min_lst;\n                    }\n                }\n            }\n        }\n    }\n    return res;",
    "  let n = grid.len();\n  let m = grid[0].len();\n  let dp = Vec::new(n * m);\n  for (let i = 0; i < n; i++) {\n    for (let j = 0; j < m; j++) {\n      if (i == 0 && j == 0) {\n        dp[0] = grid[0][0];\n      } else if (i == 0) {\n        dp[j] = grid[i][j];\n      } else if (j == 0) {\n        dp[i] = grid[i][j];\n      } else {\n        dp[i * m + j] = grid[i][j] + min(dp[i * m + j - 1], dp[(i - 1) * m + j], dp[i * m + j - m], dp[(i - 1) * m + j - m]);\n      }\n    }\n  }\n  let res = Vec::new(k);\n  for (let i = 0; i < k; i++) {\n    res[i] = dp[i * m + m - 1];\n  }\n  return res;",
    "  let mut result = Vec::new();\n  let mut curr = Vec::new();\n  let mut prev = Vec::new();\n  let mut min_path = Vec::new();\n  let mut min_path_index = 0;\n  let mut min_path_length = 0;\n  let mut min_path_length_index = 0;\n  let mut min_path_length_length = 0;\n  let mut min_path_length_length_index = 0;\n  let mut min_path_length_length_length = 0;\n  let mut min_path_length_length_length_index = 0;\n  let mut min_path_length_length_length_length = 0;\n  let mut min_path_length_length_length_length_index = 0;\n  let mut min_path_length_length_length_length_length = 0;\n  let mut min_path_length_length_length_length_length_index = 0;\n  let mut min_path_length_length_length_length_length_length = 0;\n  let mut min_path_length_length_length_length_length_length_index = 0;\n  let mut min_path_length_length_length_length_length_length_length = 0;\n  let mut min_path_length_length_length_length_length_length_length_index = 0;\n  let mut min_path_length_length_length_length_length_length_length_length = 0;\n  let mut min_path_length_length_length_length_length_length_length_length_index = 0;\n  let mut min_path_length_length_length_length_length_length_length_length_length = 0;\n  let mut min_path_length_length_length_length_length_length_length_length_length_index = 0;\n  let mut min_path_length_length_length_length_length_length_length_length_length_length = 0;\n  let mut min_path_length_length_length_length_length_length_length_length_length_length_index = 0;\n  let mut min_path_length_length_length_length_length_",
    "  let lst = vec![];\n  for (let i = 0; i < grid.len(); i++) {\n    let lst_i = vec![];\n    for (let j = 0; j < grid[i].len(); j++) {\n      lst_i = append(lst_i, grid[i][j]);\n    }\n    lst = append(lst, lst_i);\n  }\n  let ans = vec![];\n  for (let i = 0; i < k; i++) {\n    let min = lst[0];\n    for (let j = 1; j < lst.len(); j++) {\n      if (lst[j] < min) {\n        min = lst[j];\n      }\n    }\n    ans = append(ans, min);\n    for (let j = 0; j < lst.len(); j++) {\n      if (lst[j] == min) {\n        lst[j] = lst[lst.len() - 1];\n        lst.pop();\n      }\n    }\n  }\n  return ans;",
    "  let n = grid.len();\n  let m = grid[0].len();\n  let dp = Vec::new(n * m);\n  for (let i = 0; i < n; i++) {\n    for (let j = 0; j < m; j++) {\n      if (i == 0 && j == 0) {\n        dp[i * m + j] = grid[i][j];\n      } else if (i == 0) {\n        dp[i * m + j] = dp[(i - 1) * m + j] + grid[i][j];\n      } else if (j == 0) {\n        dp[i * m + j] = dp[i * m + (j - 1)] + grid[i][j];\n      } else {\n        dp[i * m + j] = min(dp[(i - 1) * m + j], dp[i * m + (j - 1)], dp[(i - 1) * m + (j - 1)]) + grid[i][j];\n      }\n    }\n  }\n  let lst = Vec::new(k);\n  for (let i = 0; i < k; i++) {\n    lst[i] = dp[i * m + m - 1];\n  }\n  return lst;",
    "    let m = grid.len();\n    let n = grid[0].len();\n    let dp = Vec::new(n);\n    for (i := 0; i < n; i++) {\n        dp[i] = 1;\n    }\n    for (i := 0; i < m; i++) {\n        for (j := 0; j < n; j++) {\n            if (grid[i][j] == 0) {\n                continue;\n            }\n            for (k := 0; k < n; k++) {\n                if (grid[i][k] == 0 || grid[k][j] == 0) {\n                    continue;\n                }\n                if (dp[k] + 1 < dp[j]) {\n                    dp[j] = dp[k] + 1;\n                }\n            }\n        }\n    }\n    let ans = Vec::new(k);\n    for (i := 0; i < k; i++) {\n        ans[i] = dp[i];\n    }\n    return ans;",
    "    let mut res = Vec::new();\n    let mut cur = Vec::new();\n    let mut lst = Vec::new();\n    let mut lst_cur = Vec::new();\n    let mut lst_lst = Vec::new();\n    for (let i = 0; i < grid.len(); i++) {\n        for (let j = 0; j < grid[i].len(); j++) {\n            if (grid[i][j] == 0) {\n                continue;\n            }\n            lst.push(grid[i][j]);\n            lst_cur.push(i);\n            lst_lst.push(j);\n        }\n    }\n    for (let i = 0; i < k; i++) {\n        let min = lst.pop();\n        let min_i = lst_cur.pop();\n        let min_j = lst_lst.pop();\n        cur.push(min);\n        res.push(min);\n        for (let j = 0; j < lst_lst.len(); j++) {\n            if (lst[j] < min) {\n                min = lst[j];\n                min_i = lst_cur[j];\n                min_j = lst_lst[j];\n            }\n        }\n        lst.push(min);\n        lst_cur.push(min_i);\n        lst_lst.push(min_j);\n    }\n    return res;",
    "    let mut result = Vec::new();\n    let mut curr = Vec::new();\n    let mut prev = Vec::new();\n    let mut curr_idx = 0;\n    let mut prev_idx = 0;\n    let mut curr_len = 0;\n    let mut prev_len = 0;\n    let mut curr_idx_prev = 0;\n    let mut prev_idx_curr = 0;\n    let mut curr_idx_prev_len = 0;\n    let mut prev_idx_curr_len = 0;\n    let mut curr_idx_prev_idx = 0;\n    let mut prev_idx_curr_idx = 0;\n    let mut curr_idx_prev_idx_len = 0;\n    let mut prev_idx_curr_idx_len = 0;\n    let mut curr_idx_prev_idx_idx = 0;\n    let mut prev_idx_curr_idx_idx = 0;\n    let mut curr_idx_prev_idx_idx_len = 0;\n    let mut prev_idx_curr_idx_idx_len = 0;\n    let mut curr_idx_prev_idx_idx_idx = 0;\n    let mut prev_idx_curr_idx_idx_idx = 0;\n    let mut curr_idx_prev_idx_idx_idx_len = 0;\n    let mut prev_idx_curr_idx_idx_idx_len = 0;\n    let mut curr_idx_prev_idx_idx_idx_idx = 0;\n    let mut prev_idx_curr_idx_idx_idx_idx = 0;\n    let mut curr_idx_prev_idx_idx_idx_idx_len = 0;\n    let mut prev_idx_curr_idx_idx_idx_idx_len = 0;\n    let mut curr_idx_prev_idx_idx_",
    "    let mut result = Vec::new();\n    let mut curr = Vec::new();\n    let mut prev = Vec::new();\n    let mut next = Vec::new();\n    let mut min_path = Vec::new();\n    let mut min_path_len = 0;\n    let mut min_path_index = 0;\n    let mut min_path_index_len = 0;\n    let mut min_path_index_index = 0;\n    let mut min_path_index_index_len = 0;\n    let mut min_path_index_index_index = 0;\n    let mut min_path_index_index_index_len = 0;\n    let mut min_path_index_index_index_index = 0;\n    let mut min_path_index_index_index_index_len = 0;\n    let mut min_path_index_index_index_index_index = 0;\n    let mut min_path_index_index_index_index_index_len = 0;\n    let mut min_path_index_index_index_index_index_index = 0;\n    let mut min_path_index_index_index_index_index_index_len = 0;\n    let mut min_path_index_index_index_index_index_index_index = 0;\n    let mut min_path_index_index_index_index_index_index_index_len = 0;\n    let mut min_path_index_index_index_index_index_index_index_index = 0;\n    let mut min_path_index_index_index_index_index_index_index_index_len = 0;\n    let mut min_path_index_index_index_index_index_index_index_index_index = 0;\n    let mut min_path_index_index_index_index_index_index_index_index_index_len = 0;\n    let mut min_path_index_index_index_index_index_index_index_index_index_index = 0;\n    let mut min_path_index_index_index_index_index_index_index_index_index_index_len = 0;\n    let mut min_path_",
    "  let m = grid.len();\n  let n = grid[0].len();\n  let dp = Vec::new(n);\n  for (let i = 0; i < n; i++) {\n    dp[i] = Vec::new(n);\n    for (let j = 0; j < n; j++) {\n      if (i == 0 && j == 0) {\n        dp[i][j] = grid[0][0];\n      } else if (i == 0) {\n        dp[i][j] = dp[i][j - 1] + grid[0][j];\n      } else if (j == 0) {\n        dp[i][j] = dp[i - 1][j] + grid[i][0];\n      } else {\n        dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j];\n      }\n    }\n  }\n  let res = Vec::new(k);\n  for (let i = 0; i < k; i++) {\n    res[i] = dp[n - 1][n - 1];\n    for (let j = n - 1; j > 0; j--) {\n      if (dp[j - 1][n - 1] < res[i]) {\n        res[i] = dp[j - 1][n - 1];\n      }\n    }\n  }\n  return res;",
    "    let n = grid.len();\n    let m = grid[0].len();\n    let dp = Vec::new(n * m);\n    for (let i = 0; i < n; i++) {\n        for (let j = 0; j < m; j++) {\n            if (i == 0 && j == 0) {\n                dp[i * m + j] = grid[i][j];\n            } else if (i == 0) {\n                dp[i * m + j] = dp[(i - 1) * m + j] + grid[i][j];\n            } else if (j == 0) {\n                dp[i * m + j] = dp[i * m + (j - 1)] + grid[i][j];\n            } else {\n                dp[i * m + j] = min(dp[(i - 1) * m + j], dp[i * m + (j - 1)], dp[(i - 1) * m + (j - 1)]) + grid[i][j];\n            }\n        }\n    }\n    let res = Vec::new(k);\n    for (let i = 0; i < k; i++) {\n        res[i] = dp[i * m + m - 1];\n    }\n    return res;",
    "    let m = grid.len();\n    let n = grid[0].len();\n    let dp = Vec::new(n);\n    for (let i = 0; i < n; i++) {\n        dp[i] = Vec::new(n);\n        for (let j = 0; j < n; j++) {\n            if (i == 0 && j == 0) {\n                dp[i][j] = grid[0][0];\n            } else if (i == 0) {\n                dp[i][j] = dp[i][j - 1] + grid[0][j];\n            } else if (j == 0) {\n                dp[i][j] = dp[i - 1][j] + grid[i][0];\n            } else {\n                dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j];\n            }\n        }\n    }\n    let ans = Vec::new(k);\n    for (let i = 0; i < k; i++) {\n        ans[i] = dp[n - 1][n - 1];\n        for (let j = n - 1; j > 0; j--) {\n            if (dp[j - 1][n - 1] < dp[j][n - 1]) {\n                dp[j][n - 1] = dp[j - 1][n - 1];\n            }\n        }\n    }\n    return ans;",
    "    let dp = Vec::new(grid.len(), -1);\n    let dp_prev = Vec::new(grid.len(), -1);\n    for i in 0..grid.len() {\n        for j in 0..grid.len() {\n            if (i == 0 && j == 0) {\n                dp[i] = grid[i][j];\n                dp_prev[i] = grid[i][j];\n            } else if (i == 0) {\n                dp[i] = dp_prev[i] + grid[i][j];\n                dp_prev[i] = dp[i];\n            } else if (j == 0) {\n                dp[i] = dp_prev[i] + grid[i][j];\n                dp_prev[i] = dp[i];\n            } else {\n                dp[i] = min(dp_prev[i-1], dp_prev[i], dp_prev[i+1]) + grid[i][j];\n                dp_prev[i] = dp[i];\n            }\n        }\n    }\n    let res = Vec::new(k, -1);\n    for i in 0..k {\n        res[i] = dp[i];\n    }\n    return res;",
    "  let grid_len = grid.len();\n  let grid_len_sq = grid_len * grid_len;\n  let grid_len_sq_pow_k = grid_len_sq ** k;\n  let grid_len_sq_pow_k_minus_1 = grid_len_sq_pow_k - 1;\n  let grid_len_sq_pow_k_minus_2 = grid_len_sq_pow_k - 2;\n  let grid_len_sq_pow_k_minus_3 = grid_len_sq_pow_k - 3;\n  let grid_len_sq_pow_k_minus_4 = grid_len_sq_pow_k - 4;\n  let grid_len_sq_pow_k_minus_5 = grid_len_sq_pow_k - 5;\n  let grid_len_sq_pow_k_minus_6 = grid_len_sq_pow_k - 6;\n  let grid_len_sq_pow_k_minus_7 = grid_len_sq_pow_k - 7;\n  let grid_len_sq_pow_k_minus_8 = grid_len_sq_pow_k - 8;\n  let grid_len_sq_pow_k_minus_9 = grid_len_sq_pow_k - 9;\n  let grid_len_sq_pow_k_minus_10 = grid_len_sq_pow_k - 10;\n  let grid_len_sq_pow_k_minus_11 = grid_len_sq_pow_k - 11;\n  let grid_len_sq_pow_k_minus_12 = grid_len_sq_pow_k - 12;\n  let grid_len_sq_pow_k_minus_13 = grid_len_sq_pow_k - 13;\n  let grid_len_sq_pow_k_minus_14 = grid_len_sq_pow_k - 14;\n  let grid_len_sq_pow_k_minus_15 = grid_len_sq_pow_k -",
    "  let grid_len = grid.len();\n  if grid_len < 2 {\n    return Vec::new(0);\n  }\n  let grid_len_sq = grid_len * grid_len;\n  let grid_len_sq_minus_k = grid_len_sq - k;\n  let grid_len_sq_minus_k_minus_1 = grid_len_sq_minus_k - 1;\n  let grid_len_sq_minus_k_minus_2 = grid_len_sq_minus_k - 2;\n  let grid_len_sq_minus_k_minus_3 = grid_len_sq_minus_k - 3;\n  let grid_len_sq_minus_k_minus_4 = grid_len_sq_minus_k - 4;\n  let grid_len_sq_minus_k_minus_5 = grid_len_sq_minus_k - 5;\n  let grid_len_sq_minus_k_minus_6 = grid_len_sq_minus_k - 6;\n  let grid_len_sq_minus_k_minus_7 = grid_len_sq_minus_k - 7;\n  let grid_len_sq_minus_k_minus_8 = grid_len_sq_minus_k - 8;\n  let grid_len_sq_minus_k_minus_9 = grid_len_sq_minus_k - 9;\n  let grid_len_sq_minus_k_minus_10 = grid_len_sq_minus_k - 10;\n  let grid_len_sq_minus_k_minus_11 = grid_len_sq_minus_k - 11;\n  let grid_len_sq_minus_k_minus_12 = grid_len_sq_minus_k - 12;\n  let grid_len_sq_minus_k_minus_13 = grid_len_sq_minus_k - 13;\n  let grid_len_sq_minus_k_minus_14 = grid_len_sq_minus_k - 14;\n  let grid_len_sq_minus_k_minus_15 = grid_len_sq_minus_k - 15;\n  let grid_len_sq",
    "    let mut res = Vec::new();\n    let mut lst = Vec::new();\n    let mut i = 0;\n    for (let j = 0; j < grid.len(); j++) {\n        if (grid[j].len() == k) {\n            lst = grid[j];\n            i = j;\n            break;\n        }\n    }\n    if (i == 0) {\n        return res;\n    }\n    for (let j = 0; j < i; j++) {\n        if (grid[j][k] < lst[k]) {\n            lst = grid[j];\n        }\n    }\n    for (let j = i + 1; j < grid.len(); j++) {\n        if (grid[j][k] < lst[k]) {\n            lst = grid[j];\n        }\n    }\n    for (let j = 0; j < k; j++) {\n        if (lst[j] < lst[k]) {\n            lst = grid[i][j];\n        }\n    }\n    for (let j = 0; j < k; j++) {\n        res.push(lst[j]);\n    }\n    return res;",
    "    let mut lst = vec![];\n    for i in 0..k {\n        lst.push_back(0);\n    }\n    for i in 0..grid.len() {\n        for j in 0..grid[i].len() {\n            if lst[0] == 0 {\n                lst[0] = grid[i][j];\n            } else {\n                lst[0] = min(lst[0], grid[i][j]);\n            }\n        }\n    }\n    return lst;",
    "  let mut result = Vec::new();\n  let mut curr = 0;\n  let mut prev = 0;\n  for i in 0..k {\n    let mut curr_idx = 0;\n    for j in 0..grid.len() {\n      if grid[j][curr] == 1 {\n        curr_idx = j;\n        break;\n      }\n    }\n    if curr_idx == 0 {\n      result = Vec::new();\n      break;\n    }\n    prev = curr;\n    curr = curr_idx;\n  }\n  for i in 0..grid.len() {\n    if grid[prev][i] == 1 {\n      result = Vec::new();\n      break;\n    }\n  }\n  return result;",
    "  let mut result = Vec::new();\n  let mut visited = Vec::new();\n  let mut queue = Vec::new();\n  let mut min = Vec::new();\n  let mut min_index = 0;\n  let mut min_value = 0;\n  let mut min_value_index = 0;\n  let mut min_value_value = 0;\n  let mut min_value_value_index = 0;\n  let mut min_value_value_value = 0;\n  let mut min_value_value_value_index = 0;\n  let mut min_value_value_value_value = 0;\n  let mut min_value_value_value_value_index = 0;\n  let mut min_value_value_value_value_value = 0;\n  let mut min_value_value_value_value_value_index = 0;\n  let mut min_value_value_value_value_value_value = 0;\n  let mut min_value_value_value_value_value_value_index = 0;\n  let mut min_value_value_value_value_value_value_value = 0;\n  let mut min_value_value_value_value_value_value_value_index = 0;\n  let mut min_value_value_value_value_value_value_value_value = 0;\n  let mut min_value_value_value_value_value_value_value_value_index = 0;\n  let mut min_value_value_value_value_value_value_value_value_value = 0;\n  let mut min_value_value_value_value_value_value_value_value_value_index = 0;\n  let mut min_value_value_value_value_value_value_value_value_value_value = 0;\n  let mut min_value_value_value_value_value_value_value_value_value_value_index = 0;\n  let mut min_value_value_value_value_value_value_value_value_value_value_value = 0;\n  let mut min_value_value_value_value_value_value_value_value_value_value_value_index = 0;\n",
    "    let m = grid.len();\n    let n = grid[0].len();\n    let dp = Vec::new(n);\n    for (let i = 0; i < n; i++) {\n        dp[i] = Vec::new(n);\n        for (let j = 0; j < n; j++) {\n            if (i == 0 && j == 0) {\n                dp[i][j] = grid[0][0];\n            } else if (i == 0) {\n                dp[i][j] = dp[i][j - 1] + grid[0][j];\n            } else if (j == 0) {\n                dp[i][j] = dp[i - 1][j] + grid[i][0];\n            } else {\n                dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j];\n            }\n        }\n    }\n    let res = Vec::new(k);\n    for (let i = 0; i < k; i++) {\n        res[i] = dp[n - 1][n - 1];\n        for (let j = n - 1; j >= 0; j--) {\n            if (dp[j][n - 1] < res[i]) {\n                res[i] = dp[j][n - 1];\n            }\n        }\n    }\n    return res;",
    "  let dfs = Dfs{grid, 0, 0};\n  let result = Vec::new();\n  for isize i = 0; i < grid.len(); i++ {\n    let cur = dfs.next();\n    if cur.len() < k {\n      result = result.push(cur.at(0));\n    } else {\n      result = result.push(cur.at(k));\n    }\n  }\n  return result;",
    "  let dfs = Dfs{grid, 0, 0, 0};\n  let res = Vec::new();\n  for isize i = 1; i <= k; i ++ {\n    for isize j = 0; j < grid.len(); j ++ {\n      if grid[j][0] == i {\n        dfs.visit(j, 0);\n        res.push_back(i);\n        break;\n      }\n    }\n  }\n  return res;",
    "  let m = grid.len();\n  let n = grid[0].len();\n  let dp = Vec::new(n);\n  dp[0] = 1;\n  for (let i = 1; i < n; i++) {\n    dp[i] = dp[i - 1] + grid[0][i - 1];\n  }\n  for (let i = 1; i < m; i++) {\n    for (let j = 1; j < n; j++) {\n      let min = dp[j - 1] + grid[i - 1][j - 1];\n      for (let k = 0; k < j; k++) {\n        if (grid[i - 1][k] < grid[i - 1][j - 1]) {\n          min = min + grid[i - 1][k];\n        }\n      }\n      dp[j] = min;\n    }\n  }\n  let res = Vec::new(k);\n  for (let i = 0; i < k; i++) {\n    res[i] = dp[n - 1] - dp[i];\n  }\n  return res;",
    "    let mut result = Vec::new();\n    let mut curr = Vec::new();\n    let mut next = Vec::new();\n    let mut visited = Vec::new();\n    let mut min = Vec::new();\n    let mut min_index = 0;\n    let mut min_value = 0;\n    let mut min_index_value = 0;\n    let mut min_index_value_index = 0;\n    let mut min_index_value_value = 0;\n    let mut min_index_value_value_index = 0;\n    let mut min_index_value_value_value = 0;\n    let mut min_index_value_value_value_index = 0;\n    let mut min_index_value_value_value_value = 0;\n    let mut min_index_value_value_value_value_index = 0;\n    let mut min_index_value_value_value_value_value = 0;\n    let mut min_index_value_value_value_value_value_index = 0;\n    let mut min_index_value_value_value_value_value_value = 0;\n    let mut min_index_value_value_value_value_value_value_index = 0;\n    let mut min_index_value_value_value_value_value_value_value = 0;\n    let mut min_index_value_value_value_value_value_value_value_index = 0;\n    let mut min_index_value_value_value_value_value_value_value_value = 0;\n    let mut min_index_value_value_value_value_value_value_value_value_index = 0;\n    let mut min_index_value_value_value_value_value_value_value_value_value = 0;\n    let mut min_index_value_value_value_value_value_value_value_value_value_index = 0;\n    let mut min_index_value_value_value_value_value_value_value_value_value_value = 0;\n    let mut min_index_value_value_value_value_value_value_value_value_value_value_index = 0;\n    ",
    "  let mut result = Vec::new();\n  let mut min_path = Vec::new();\n  let mut min_path_len = 0;\n  let mut min_path_index = 0;\n  let mut min_path_index_len = 0;\n  let mut min_path_index_index = 0;\n  let mut min_path_index_index_len = 0;\n  let mut min_path_index_index_index = 0;\n  let mut min_path_index_index_index_len = 0;\n  let mut min_path_index_index_index_index = 0;\n  let mut min_path_index_index_index_index_len = 0;\n  let mut min_path_index_index_index_index_index = 0;\n  let mut min_path_index_index_index_index_index_len = 0;\n  let mut min_path_index_index_index_index_index_index = 0;\n  let mut min_path_index_index_index_index_index_index_len = 0;\n  let mut min_path_index_index_index_index_index_index_index = 0;\n  let mut min_path_index_index_index_index_index_index_index_len = 0;\n  let mut min_path_index_index_index_index_index_index_index_index = 0;\n  let mut min_path_index_index_index_index_index_index_index_index_len = 0;\n  let mut min_path_index_index_index_index_index_index_index_index_index = 0;\n  let mut min_path_index_index_index_index_index_index_index_index_index_len = 0;\n  let mut min_path_index_index_index_index_index_index_index_index_index_index = 0;\n  let mut min_path_index_index_index_index_index_index_index_index_index_index_len = 0;\n  let mut min_path_index_index_index_index_index_index_index_index_index_index_index = 0;\n  let mut min_path",
    "  let lst = vec![];\n  for (let i = 0; i < grid.len(); i++) {\n    let cur = grid[i];\n    for (let j = 0; j < cur.len(); j++) {\n      if (cur[j] == 1) {\n        lst = append(lst, j + 1);\n      }\n    }\n  }\n  let res = vec![];\n  for (let i = 0; i < k; i++) {\n    let cur = lst[i];\n    for (let j = 0; j < lst.len(); j++) {\n      if (lst[j] < cur) {\n        res = append(res, lst[j]);\n        lst = lst.slice(0, j).concat(lst.slice(j + 1));\n        break;\n      }\n    }\n  }\n  return res;",
    "  let n = grid.len();\n  let m = grid[0].len();\n  let dp = Vec::new(n * m);\n  for (let i = 0; i < n; i++) {\n    for (let j = 0; j < m; j++) {\n      if (i == 0 && j == 0) {\n        dp[i * m + j] = grid[i][j];\n      } else if (i == 0) {\n        dp[i * m + j] = grid[i][j] + dp[(i - 1) * m + j];\n      } else if (j == 0) {\n        dp[i * m + j] = grid[i][j] + dp[i * m + (j - 1)];\n      } else {\n        dp[i * m + j] = grid[i][j] + min(dp[(i - 1) * m + j], dp[i * m + (j - 1)]);\n      }\n    }\n  }\n  let ans = Vec::new(k);\n  for (let i = 0; i < k; i++) {\n    ans[i] = dp[i * m + m - 1];\n  }\n  return ans;",
    "  let grid_len = grid.len();\n  let grid_len_sq = grid_len * grid_len;\n  let grid_len_sq_p1 = grid_len_sq + 1;\n  let grid_len_sq_p2 = grid_len_sq + 2;\n  let grid_len_sq_p3 = grid_len_sq + 3;\n  let grid_len_sq_p4 = grid_len_sq + 4;\n  let grid_len_sq_p5 = grid_len_sq + 5;\n  let grid_len_sq_p6 = grid_len_sq + 6;\n  let grid_len_sq_p7 = grid_len_sq + 7;\n  let grid_len_sq_p8 = grid_len_sq + 8;\n  let grid_len_sq_p9 = grid_len_sq + 9;\n  let grid_len_sq_p10 = grid_len_sq + 10;\n  let grid_len_sq_p11 = grid_len_sq + 11;\n  let grid_len_sq_p12 = grid_len_sq + 12;\n  let grid_len_sq_p13 = grid_len_sq + 13;\n  let grid_len_sq_p14 = grid_len_sq + 14;\n  let grid_len_sq_p15 = grid_len_sq + 15;\n  let grid_len_sq_p16 = grid_len_sq + 16;\n  let grid_len_sq_p17 = grid_len_sq + 17;\n  let grid_len_sq_p18 = grid_len_sq + 18;\n  let grid_len_sq_p19 = grid_len_sq + 19;\n  let grid_len_sq_p20 = grid_len_sq + 20;\n  let grid_len_sq_p21 = grid_len_sq + 21;\n  let grid_len_sq_p22 = grid_len_sq + 22;\n  let grid_len_sq_p23 = grid_len_sq + 23;\n  let grid_len_sq_p24 = grid_len_sq + 24;\n  let grid_",
    "  let dfs = Dfs{grid, 0, 0};\n  let res = Vec::new();\n  for isize i = 0; i < grid.len(); i++ {\n    let cur = dfs.next();\n    if cur.len() < k {\n      res = res.push(cur.head());\n      dfs = Dfs{grid, i + 1, cur.len() + 1};\n    }\n  }\n  return res;",
    "  let m = grid.len();\n  let n = grid[0].len();\n  let result = Vec::new(k);\n  let visited = Vec::new(m * n);\n  let queue = Vec::new(m * n);\n  queue.fill(0);\n  for (let i = 0; i < m; i++) {\n    for (let j = 0; j < n; j++) {\n      if (grid[i][j] == 0) {\n        queue[i * n + j] = 1;\n      }\n    }\n  }\n  for (let i = 0; i < m; i++) {\n    for (let j = 0; j < n; j++) {\n      if (grid[i][j] == 0 && queue[i * n + j] == 1) {\n        visited[i * n + j] = 1;\n        result[0] = i;\n        result[1] = j;\n        for (let k = 2; k <= k; k++) {\n          let next_i = i;\n          let next_j = j;\n          let next_k = k;\n          while (next_k > 0) {\n            next_i = result[next_k - 1];\n            next_j = result[next_k];\n            next_k -= 1;\n          }\n          if (visited[next_i * n + next_j] == 0) {\n            visited[next_i * n + next_j] = 1;\n            result[next_k] = next_i;\n            result[next_k + 1] = next_j;\n          }\n        }\n        break;\n      }\n    }\n  }\n  return result;",
    "    let mut lst: Vec<isize> = vec![];\n    let mut min_path: Vec<isize> = vec![];\n    let mut min_path_len: isize = 0;\n    \n    for i in 0..k {\n        for j in 0..k {\n            if grid[i][j] {\n                lst = lst.push(i);\n                lst = lst.push(j);\n                if i > 0 && j > 0 && grid[i - 1][j - 1] {\n                    lst = lst.push(i - 1);\n                    lst = lst.push(j - 1);\n                }\n            }\n        }\n        if lst.len() == k {\n            if min_path_len > lst.len() {\n                min_path = lst;\n                min_path_len = lst.len();\n            }\n        }\n        lst = vec![];\n    }\n    return min_path;",
    "  let mut result = Vec::new();\n  let mut curr = Vec::new();\n  let mut prev = Vec::new();\n  let mut curr_idx = 0;\n  let mut prev_idx = 0;\n  let mut curr_len = 0;\n  let mut prev_len = 0;\n  let mut curr_min = 0;\n  let mut prev_min = 0;\n  let mut curr_min_idx = 0;\n  let mut prev_min_idx = 0;\n  let mut curr_min_len = 0;\n  let mut prev_min_len = 0;\n  let mut curr_min_min = 0;\n  let mut prev_min_min = 0;\n  let mut curr_min_min_idx = 0;\n  let mut prev_min_min_idx = 0;\n  let mut curr_min_min_len = 0;\n  let mut prev_min_min_len = 0;\n  let mut curr_min_min_min = 0;\n  let mut prev_min_min_min = 0;\n  let mut curr_min_min_min_idx = 0;\n  let mut prev_min_min_min_idx = 0;\n  let mut curr_min_min_min_len = 0;\n  let mut prev_min_min_min_len = 0;\n  let mut curr_min_min_min_min = 0;\n  let mut prev_min_min_min_min = 0;\n  let mut curr_min_min_min_min_idx = 0;\n  let mut prev_min_min_min_min_idx = 0;\n  let mut curr_min_min_min_min_len = 0;\n  let mut prev_min_min_min_min_len = 0;\n  let mut curr_min_min_min_min_min = 0;\n  let mut prev_min_min_min_min_min = 0;\n  let mut curr_min_min_min_min_min_idx = 0;\n  let mut prev_min_min_min_min_min",
    "  let mut lst = Vec::new();\n  for (let i = 0; i < grid.len(); i++) {\n    lst.push(i);\n  }\n  let mut res = Vec::new();\n  for (let i = 0; i < k; i++) {\n    let mut cur = Vec::new();\n    for (let j = 0; j < lst.len(); j++) {\n      let idx = lst[j];\n      let val = grid[idx][i];\n      if (val > 0) {\n        cur.push(val);\n      }\n    }\n    lst = cur;\n    res.push(lst[0]);\n  }\n  return res;",
    "    let mut result = vec![];\n    let mut curr = vec![];\n    let mut prev = vec![];\n    let mut path = vec![];\n    let mut path_len = 0;\n    let mut curr_len = 0;\n    let mut prev_len = 0;\n    let mut curr_index = 0;\n    let mut prev_index = 0;\n    let mut path_index = 0;\n    let mut curr_index_prev = 0;\n    let mut prev_index_curr = 0;\n    let mut curr_index_prev_prev = 0;\n    let mut prev_index_curr_prev = 0;\n    let mut curr_index_prev_prev_prev = 0;\n    let mut prev_index_curr_prev_prev = 0;\n    let mut curr_index_prev_prev_prev_prev = 0;\n    let mut prev_index_curr_prev_prev_prev = 0;\n    let mut curr_index_prev_prev_prev_prev_prev = 0;\n    let mut prev_index_curr_prev_prev_prev_prev = 0;\n    let mut curr_index_prev_prev_prev_prev_prev_prev = 0;\n    let mut prev_index_curr_prev_prev_prev_prev_prev_prev = 0;\n    let mut curr_index_prev_prev_prev_prev_prev_prev_prev_prev = 0;\n    let mut prev_index_curr_prev_prev_prev_prev_prev_prev_prev_prev = 0;\n    let mut curr_index_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev = 0;\n    let mut prev_index_curr_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev = 0;\n    let mut curr_index_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev = 0;\n    let mut prev_index_curr_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev =",
    "    let mut result = vec![];\n    let mut curr = vec![];\n    let mut next = vec![];\n    for i in 0..k {\n        for j in 0..grid.len() {\n            if i == 0 {\n                next = vec![grid[j][0]];\n            } else {\n                next = vec![];\n                for jj in 0..grid.len() {\n                    if jj == j {\n                        continue;\n                    }\n                    if grid[jj][i] < grid[j][i] {\n                        next = vec![grid[jj][i]];\n                    }\n                }\n            }\n            if next.len() == 0 {\n                break;\n            }\n            if result.len() == 0 || next.len() < result.len() {\n                result = next;\n            }\n        }\n    }\n    return result;",
    "  let dp = Vec::new(grid.len(), -1);\n  let res = Vec::new(k + 1);\n  for (let i = 0; i < grid.len(); i++) {\n    for (let j = 0; j < grid[i].len(); j++) {\n      if (grid[i][j] == 0) {\n        continue;\n      }\n      let cur = dp[i] + 1;\n      let next = dp[j] + 1;\n      if (cur < next) {\n        dp[j] = cur;\n        res[1] = i;\n        res[2] = j;\n      }\n    }\n  }\n  for (let i = 0; i < k; i++) {\n    let cur = dp[res[i + 1]];\n    let next = dp[res[i + 2]];\n    if (cur < next) {\n      res[i + 1] = cur;\n    } else {\n      res[i + 1] = next;\n    }\n  }\n  return res;",
    "  let n = grid.len();\n  assert(n >= 2);\n  let m = grid[0].len();\n  assert(m >= 2);\n  let result = Vec::new(k);\n  let i = 0;\n  let j = 0;\n  let min_value = 1;\n  let min_index = 0;\n  for (i = 0; i < n; i++) {\n    for (j = 0; j < m; j++) {\n      let value = grid[i][j];\n      if (value > 0) {\n        if (value < min_value) {\n          min_value = value;\n          min_index = i * m + j;\n        }\n      }\n    }\n  }\n  for (i = 0; i < k; i++) {\n    result[i] = min_index / m;\n    min_index %= m;\n    if (min_index == 0) {\n      min_index = m - 1;\n    }\n  }\n  return result;",
    "  let dfs = Dfs{grid, 0, 0};\n  let res = Vec::new();\n  for i in 0..k {\n    let cur = dfs.next();\n    if cur.is_none() {\n      break;\n    }\n    res = res.push(cur.unwrap());\n  }\n  return res;",
    "  let mut result = Vec::new();\n  let mut visited = Vec::new();\n  let mut queue = Vec::new();\n  queue.push(0);\n  visited.push(0);\n  while !queue.is_empty() {\n    let cell = queue.pop();\n    if cell == k {\n      result.push(cell);\n      break;\n    }\n    for i in 0..k {\n      let next = cell + i;\n      if next < grid.len() && !visited.contains(next) {\n        queue.push(next);\n        visited.push(next);\n      }\n    }\n  }\n  return result;",
    "    let m = grid.len();\n    let n = grid[0].len();\n    let dp = Vec::new(n);\n    for (let i = 0; i < n; i++) {\n        dp[i] = Vec::new(m);\n        for (let j = 0; j < m; j++) {\n            if (i == 0 && j == 0) {\n                dp[i][j] = grid[0][0];\n            } else if (i == 0) {\n                dp[i][j] = dp[i][j - 1] + grid[0][j];\n            } else if (j == 0) {\n                dp[i][j] = dp[i - 1][j] + grid[i][0];\n            } else {\n                dp[i][j] = min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + grid[i][j];\n            }\n        }\n    }\n    let ans = Vec::new(k);\n    for (let i = 0; i < k; i++) {\n        ans[i] = dp[n - 1][m - 1];\n        for (let j = m - 1; j >= 0; j--) {\n            if (dp[n - 1][j] < ans[i]) {\n                ans[i] = dp[n - 1][j];\n            }\n        }\n        for (let j = n - 1; j >= 0; j--) {\n            if (dp[j][m - 1] < ans[i]) {\n                ans[i] = dp[j][m - 1];\n            }\n        }\n        for (let j = n - 1; j >= 0; j--) {\n            if (dp[j][m - 1] < ans[i]) {\n                ans[i] = dp[j][m - 1];\n            }\n        }\n        for (let j = n - 1; j >= 0; j--) {\n            if (dp[j][m - 1] < ans[i]) {\n                ans[i] = dp[j][m - 1];\n",
    "  let n = grid.len();\n  let m = grid[0].len();\n  let dp = Vec::new(n, 0);\n  for (let i = 0; i < n; i++) {\n    for (let j = 0; j < m; j++) {\n      if (i == 0 && j == 0) {\n        dp[i] = grid[i][j];\n      } else if (i == 0) {\n        dp[i] = min(dp[i], dp[i - 1] + grid[i][j]);\n      } else if (j == 0) {\n        dp[i] = min(dp[i], dp[i - 1] + grid[i][j]);\n      } else {\n        dp[i] = min(dp[i], dp[i - 1] + grid[i][j]);\n      }\n    }\n  }\n  let ans = Vec::new(k, 0);\n  for (let i = 0; i < k; i++) {\n    ans[i] = dp[n - 1 - i];\n  }\n  return ans;",
    "    let m = grid.length;\n    let n = grid[0].length;\n    let dp = Vec::new(n);\n    for (let i = 0; i < n; i++) {\n        dp[i] = Vec::new(n);\n        for (let j = 0; j < n; j++) {\n            if (i == 0 && j == 0) {\n                dp[i][j] = grid[0][0];\n            } else if (i == 0) {\n                dp[i][j] = dp[i][j - 1] + grid[0][j];\n            } else if (j == 0) {\n                dp[i][j] = dp[i - 1][j] + grid[i][0];\n            } else {\n                dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j];\n            }\n        }\n    }\n    let ans = Vec::new(k);\n    for (let i = 0; i < k; i++) {\n        ans[i] = dp[n - 1][n - 1];\n        for (let j = n - 1; j >= 0; j--) {\n            if (dp[j][j] < ans[i]) {\n                ans[i] = dp[j][j];\n            }\n        }\n    }\n    return ans;",
    "  let dfs = Dfs{grid, 0, 0, 0};\n  let res = Vec::new();\n  for (let i = 0; i < grid.len(); i++) {\n    let cur = grid[i];\n    let next = dfs.dfs(i);\n    if (next.len() == k) {\n      res = Vec::concat(res, Vec::from_iter(next));\n    }\n  }\n  return res;",
    "    let mut result = Vec::new();\n    let mut min_path = Vec::new();\n    let mut min_path_len = 0;\n    let mut min_path_index = 0;\n    let mut min_path_index_len = 0;\n    let mut min_path_index_index = 0;\n    let mut min_path_index_index_len = 0;\n    let mut min_path_index_index_index = 0;\n    let mut min_path_index_index_index_len = 0;\n    let mut min_path_index_index_index_index = 0;\n    let mut min_path_index_index_index_index_len = 0;\n    let mut min_path_index_index_index_index_index = 0;\n    let mut min_path_index_index_index_index_index_len = 0;\n    let mut min_path_index_index_index_index_index_index = 0;\n    let mut min_path_index_index_index_index_index_index_len = 0;\n    let mut min_path_index_index_index_index_index_index_index = 0;\n    let mut min_path_index_index_index_index_index_index_index_len = 0;\n    let mut min_path_index_index_index_index_index_index_index_index = 0;\n    let mut min_path_index_index_index_index_index_index_index_index_len = 0;\n    let mut min_path_index_index_index_index_index_index_index_index_index = 0;\n    let mut min_path_index_index_index_index_index_index_index_index_index_len = 0;\n    let mut min_path_index_index_index_index_index_index_index_index_index_index = 0;\n    let mut min_path_index_index_index_index_index_index_index_index_index_index_len = 0;\n    let mut min_path_index_index_index_index_index_index_index_index_index_index_index = 0;\n    let mut min_path",
    "  let mut result = Vec::new();\n  let mut curr = Vec::new();\n  let mut prev = Vec::new();\n  let mut next = Vec::new();\n  let mut curr_idx = 0;\n  let mut prev_idx = 0;\n  let mut next_idx = 0;\n  let mut curr_len = 0;\n  let mut prev_len = 0;\n  let mut next_len = 0;\n  let mut curr_idx_len = 0;\n  let mut prev_idx_len = 0;\n  let mut next_idx_len = 0;\n  let mut curr_idx_len_prev = 0;\n  let mut curr_idx_len_next = 0;\n  let mut curr_idx_len_prev_next = 0;\n  let mut curr_idx_len_prev_next_prev = 0;\n  let mut curr_idx_len_prev_next_next = 0;\n  let mut curr_idx_len_prev_next_prev_next = 0;\n  let mut curr_idx_len_prev_next_prev_next_prev = 0;\n  let mut curr_idx_len_prev_next_prev_next_prev_next = 0;\n  let mut curr_idx_len_prev_next_prev_next_prev_next_prev = 0;\n  let mut curr_idx_len_prev_next_prev_next_prev_next_prev_next = 0;\n  let mut curr_idx_len_prev_next_prev_next_prev_next_prev_next_prev = 0;\n  let mut curr_idx_len_prev_next_prev_next_prev_next_prev_next_prev_next = 0;\n  let mut curr_idx_len_prev_next_prev_next_prev_next_prev_next_prev_next_prev = 0;\n  let mut curr_idx_len_prev_next_prev_next_prev_next_prev_next_prev_next_prev_next = 0;\n  let mut curr_",
    "    let mut result = Vec::new();\n    let mut min_path = Vec::new();\n    let mut min_path_len = 0;\n    let mut min_path_index = 0;\n    let mut min_path_index_len = 0;\n    let mut min_path_index_index = 0;\n    let mut min_path_index_index_len = 0;\n    let mut min_path_index_index_index = 0;\n    let mut min_path_index_index_index_len = 0;\n    let mut min_path_index_index_index_index = 0;\n    let mut min_path_index_index_index_index_len = 0;\n    let mut min_path_index_index_index_index_index = 0;\n    let mut min_path_index_index_index_index_index_len = 0;\n    let mut min_path_index_index_index_index_index_index = 0;\n    let mut min_path_index_index_index_index_index_index_len = 0;\n    let mut min_path_index_index_index_index_index_index_index = 0;\n    let mut min_path_index_index_index_index_index_index_index_len = 0;\n    let mut min_path_index_index_index_index_index_index_index_index = 0;\n    let mut min_path_index_index_index_index_index_index_index_index_len = 0;\n    let mut min_path_index_index_index_index_index_index_index_index_index = 0;\n    let mut min_path_index_index_index_index_index_index_index_index_index_len = 0;\n    let mut min_path_index_index_index_index_index_index_index_index_index_index = 0;\n    let mut min_path_index_index_index_index_index_index_index_index_index_index_len = 0;\n    let mut min_path_index_index_index_index_index_index_index_index_index_index_index = 0;\n    let mut min_path",
    "  let mut result = Vec::new();\n  let mut curr = Vec::new();\n  let mut next = Vec::new();\n  let mut curr_idx = 0;\n  let mut next_idx = 0;\n  let mut next_idx_prev = 0;\n  let mut next_idx_next = 0;\n  let mut next_idx_prev_prev = 0;\n  let mut next_idx_next_next = 0;\n  let mut next_idx_prev_next = 0;\n  let mut next_idx_prev_prev_prev = 0;\n  let mut next_idx_next_next_next = 0;\n  let mut next_idx_prev_next_next = 0;\n  let mut next_idx_prev_prev_prev_prev = 0;\n  let mut next_idx_next_next_next_next = 0;\n  let mut next_idx_prev_next_next_next = 0;\n  let mut next_idx_prev_prev_next_next = 0;\n  let mut next_idx_prev_prev_prev_prev = 0;\n  let mut next_idx_next_next_next_next = 0;\n  let mut next_idx_prev_next_next_next = 0;\n  let mut next_idx_prev_prev_next_next = 0;\n  let mut next_idx_prev_prev_prev_prev = 0;\n  let mut next_idx_next_next_next_next = 0;\n  let mut next_idx_prev_next_next_next = 0;\n  let mut next_idx_prev_prev_next_next = 0;\n  let mut next_idx_prev_prev_prev_prev = 0;\n  let mut next_idx_next_next_next_next = 0;\n  let mut next_idx_prev_next_next_next = 0;\n  let mut next_idx_prev_prev_next_next = 0;\n  let mut next_idx_prev_prev_prev_prev = 0;\n  let mut next_idx_next_next_next",
    "  let dfs = Dfs{grid, k};\n  let res = dfs.run();\n  return res;",
    "  let m = grid.len();\n  let n = grid[0].len();\n  let dp = Vec::new(n + 1);\n  for (let i = 0; i <= n; i++) {\n    dp[i] = Vec::new(n + 1);\n    for (let j = 0; j <= n; j++) {\n      if (i == 0 && j == 0) {\n        dp[i][j] = grid[0][0];\n      } else if (i == 0) {\n        dp[i][j] = dp[i][j - 1] + grid[0][j];\n      } else if (j == 0) {\n        dp[i][j] = dp[i - 1][j] + grid[i][0];\n      } else {\n        dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j];\n      }\n    }\n  }\n  let ans = Vec::new(k);\n  for (let i = 0; i < k; i++) {\n    ans[i] = dp[n][n];\n    for (let j = n - 1; j >= 0; j--) {\n      if (dp[j][n] < dp[j + 1][n]) {\n        ans[i] = dp[j][n];\n        break;\n      }\n    }\n  }\n  return ans;"
  ],
  "stop_tokens": [
    "\n}"
  ]
}