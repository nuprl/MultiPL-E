{
  "name": "HumanEval_117_select_words",
  "language": "rs",
  "prompt": "/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns a vector of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty vector.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n/// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n",
  "tests": "}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n",
  "stop_tokens": [
    "\n}"
  ],
  "results": [
    {
      "program": "/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns a vector of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty vector.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n/// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n  let mut words = Vec::new();\n  let mut word = String::new();\n  let mut i = 0;\n  let mut j = 0;\n  let mut count = 0;\n  while i < s.len() {\n    if s[i] == ' ' {\n      if count == n {\n        words.push(word);\n        word = String::new();\n        count = 0;\n      }\n      i += 1;\n      continue;\n    }\n    if s[i] == '\\n' {\n      i += 1;\n      continue;\n    }\n    if s[i] == '\\r' {\n      i += 1;\n      continue;\n    }\n    if s[i] == '\\t' {\n      i += 1;\n      continue;\n    }\n    if s[i] == '\\v' {\n      i += 1;\n      continue;\n    }\n    if s[i] == '\\f' {\n      i += 1;\n      continue;\n    }\n    if s[i] == '\\b' {\n      i += 1;\n      continue;\n    }\n    if s[i] == '\\u00A0' {\n      i += 1;\n      continue;\n    }\n    if s[i] == '\\u2007' {\n      i += 1;\n      continue;\n    }\n    if s[i] == '\\u202F' {\n      i += 1;\n      continue;\n    }\n    if s[i] == '\\u3000' {\n      i += 1;\n      continue;\n    }\n    if s[i] == '\\uFF01' {\n      i += 1;\n      continue;\n    }\n    if s[i] == '\\uFF02' {\n      i += 1;\n      continue;\n    }\n    if s[i] == '\\uFF03' {\n      i += 1;\n      continue;\n    }\n    if s[i] == '\\uFF04' {\n      i += 1;\n      continue;\n    }\n    if s[i] == '\\uFF05' {\n      i += 1;\n      continue\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "error: unknown character escape: `v`\n  --> /tmp/tmpu7uvvzhb.rs:45:18\n   |\n45 |     if s[i] == '\\v' {\n   |                  ^ unknown character escape\n   |\n   = help: for more information, visit <https://static.rust-lang.org/doc/master/reference.html#literals>\nhelp: if you meant to write a literal backslash (perhaps escaping in a regular expression), consider a raw string literal\n   |\n45 |     if s[i] == r\"\\v\" {\n   |                ~~~~~\n\nerror: unknown character escape: `f`\n  --> /tmp/tmpu7uvvzhb.rs:49:18\n   |\n49 |     if s[i] == '\\f' {\n   |                  ^ unknown character escape\n   |\n   = help: for more information, visit <https://static.rust-lang.org/doc/master/reference.html#literals>\nhelp: if you meant to write a literal backslash (perhaps escaping in a regular expression), consider a raw string literal\n   |\n49 |     if s[i] == r\"\\f\" {\n   |                ~~~~~\n\nerror: unknown character escape: `b`\n  --> /tmp/tmpu7uvvzhb.rs:53:18\n   |\n53 |     if s[i] == '\\b' {\n   |                  ^ unknown character escape\n   |\n   = help: for more information, visit <https://static.rust-lang.org/doc/master/reference.html#literals>\nhelp: if you meant to write a literal backslash (perhaps escaping in a regular expression), consider a raw string literal\n   |\n53 |     if s[i] == r\"\\b\" {\n   |                ~~~~~\n\nerror: incorrect unicode escape sequence\n  --> /tmp/tmpu7uvvzhb.rs:57:17\n   |\n57 |     if s[i] == '\\u00A0' {\n   |                 ^^^---\n   |                 |\n   |                 help: format of unicode escape sequences uses braces: `\\u{00A0}`\n\nerror: incorrect unicode escape sequence\n  --> /tmp/tmpu7uvvzhb.rs:61:17\n   |\n61 |     if s[i] == '\\u2007' {\n   |                 ^^^---\n   |                 |\n   |                 help: format of unicode escape sequences uses braces: `\\u{2007}`\n\nerror: incorrect unicode escape sequence\n  --> /tmp/tmpu7uvvzhb.rs:65:17\n   |\n65 |     if s[i] == '\\u202F' {\n   |                 ^^^---\n   |                 |\n   |                 help: format of unicode escape sequences uses b",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns a vector of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty vector.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n/// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n  let mut result = Vec::new();\n  let mut word = String::new();\n  let mut count = 0;\n  for (let i = 0; i < s.len(); i++) {\n    if (s[i] == ' ') {\n      if (count == n) {\n        result.push(word);\n        word = String::new();\n        count = 0;\n      }\n    } else {\n      if (count == 0) {\n        word = String::new();\n      }\n      word += s[i];\n      count += 1;\n    }\n  }\n  if (count == n) {\n    result.push(word);\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmp6xgpn4c5.rs:21:8\n   |\n21 |   for (let i = 0; i < s.len(); i++) {\n   |        ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmp6xgpn4c5.rs:21:12\n   |\n21 |   for (let i = 0; i < s.len(); i++) {\n   |           -^ expected one of `)`, `,`, `@`, or `|`\n   |           |\n   |           help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmp6xgpn4c5.rs:21:14\n   |\n21 |   for (let i = 0; i < s.len(); i++) {\n   |              ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmp6xgpn4c5.rs:21:13\n   |\n21 |   for (let i = 0; i < s.len(); i++) {\n   |             ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmp6xgpn4c5.rs:21:14\n   |\n21 |   for (let i = 0; i < s.len(); i++) {\n   |              ^ expected expression\n\nerror: aborting due to 5 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns a vector of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty vector.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n/// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n  let mut words = Vec::new();\n  let mut word = String::new();\n  let mut word_count = 0;\n  let mut word_index = 0;\n  let mut word_index_end = 0;\n  let mut word_index_start = 0;\n  let mut word_index_start_end = 0;\n  let mut word_index_start_start = 0;\n  let mut word_index_start_start_end = 0;\n  let mut word_index_start_start_start = 0;\n  let mut word_index_start_start_start_end = 0;\n  let mut word_index_start_start_start_start = 0;\n  let mut word_index_start_start_start_start_end = 0;\n  let mut word_index_start_start_start_start_start = 0;\n  let mut word_index_start_start_start_start_start_end = 0;\n  let mut word_index_start_start_start_start_start_start = 0;\n  let mut word_index_start_start_start_start_start_start_end = 0;\n  let mut word_index_start_start_start_start_start_start_start = 0;\n  let mut word_index_start_start_start_start_start_start_start_end = 0;\n  let mut word_index_start_start_start_start_start_start_start_start = 0;\n  let mut word_index_start_start_start_start_start_start_start_start_end = 0;\n  let mut word_index_start_start_start_start_start_start_start_start_start = 0;\n  let mut word_index_start_start_start_start_start_start_start_start_start_end = 0;\n  let mut word_index_start_start_start_start_start_start_start_start_start_start = 0;\n  let mut word_index_start_start_start_start_start_start_start_start_start_start_end = 0;\n  let mut word_index_start_start_start_start_start_start_start\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "error: expected `;`, found `}`\n  --> /tmp/tmpkpbme8fs.rs:43:63\n   |\n43 |   let mut word_index_start_start_start_start_start_start_start\n   |                                                               ^ help: add `;` here\n44 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpkpbme8fs.rs:17:41\n   |\n17 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |    ------------                         ^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<String>`\n           found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns a vector of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty vector.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n/// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n  let mut words = Vec::new();\n  let mut word = String::new();\n  let mut word_count = 0;\n  let mut word_index = 0;\n  let mut word_index_end = 0;\n  let mut word_index_start = 0;\n  let mut word_index_start_end = 0;\n  let mut word_index_start_end_end = 0;\n  let mut word_index_start_end_end_end = 0;\n  let mut word_index_start_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end_end_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end_end_end_end\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "error: expected `;`, found `}`\n  --> /tmp/tmpkoz4q7r5.rs:39:67\n   |\n39 |   let mut word_index_start_end_end_end_end_end_end_end_end_end_end\n   |                                                                   ^ help: add `;` here\n40 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpkoz4q7r5.rs:17:41\n   |\n17 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |    ------------                         ^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<String>`\n           found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns a vector of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty vector.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n/// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut words = Vec::new();\n    let mut word = String::new();\n    let mut last_consonant = String::new();\n    let mut consonant_count = 0;\n    for i in s.chars() {\n        if i.is_upper() {\n            if consonant_count == n {\n                words.push(word);\n                word = String::new();\n                last_consonant = String::new();\n                consonant_count = 0;\n            }\n            word += i.to_lower();\n            last_consonant = i;\n            consonant_count += 1;\n        } else if i.is_lower() {\n            if consonant_count == n {\n                words.push(word);\n                word = String::new();\n                last_consonant = String::new();\n                consonant_count = 0;\n            }\n            word += i;\n            last_consonant = i;\n            consonant_count += 1;\n        } else if i.is_space() {\n            if consonant_count == n {\n                words.push(word);\n                word = String::new();\n                last_consonant = String::new();\n                consonant_count = 0;\n            }\n            word += i;\n            last_consonant = i;\n            consonant_count += 1;\n        }\n    }\n    if consonant_count == n {\n        words.push(word);\n    }\n    return words;\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "error[E0599]: no method named `is_upper` found for type `char` in the current scope\n  --> /tmp/tmpl9f2quhx.rs:23:14\n   |\n23 |         if i.is_upper() {\n   |              ^^^^^^^^ help: there is an associated function with a similar name: `is_uppercase`\n\nerror[E0599]: no method named `to_lower` found for type `char` in the current scope\n  --> /tmp/tmpl9f2quhx.rs:30:23\n   |\n30 |             word += i.to_lower();\n   |                       ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpl9f2quhx.rs:31:30\n   |\n20 |     let mut last_consonant = String::new();\n   |                              ------------- expected due to this value\n...\n31 |             last_consonant = i;\n   |                              ^- help: try using a conversion method: `.to_string()`\n   |                              |\n   |                              expected struct `String`, found `char`\n\nerror[E0599]: no method named `is_lower` found for type `char` in the current scope\n  --> /tmp/tmpl9f2quhx.rs:33:21\n   |\n33 |         } else if i.is_lower() {\n   |                     ^^^^^^^^ help: there is an associated function with a similar name: `is_lowercase`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpl9f2quhx.rs:40:21\n   |\n40 |             word += i;\n   |                     ^ expected `&str`, found `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpl9f2quhx.rs:41:30\n   |\n20 |     let mut last_consonant = String::new();\n   |                              ------------- expected due to this value\n...\n41 |             last_consonant = i;\n   |                              ^- help: try using a conversion method: `.to_string()`\n   |                              |\n   |                              expected struct `String`, found `char`\n\nerror[E0599]: no method named `is_space` found for type `char` in the current scope\n  --> /tmp/tmpl9f2quhx.rs:43:21\n   |\n43 |         } else if i.is_space() {\n   |                     ^^^^^^^^ help: there is an associated function with a",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns a vector of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty vector.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n/// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n  let mut words = Vec::new();\n  let mut word = String::new();\n  let mut count = 0;\n  for (let i = 0; i < s.len(); i++) {\n    if (s[i] == ' ') {\n      if (count == n) {\n        words.push(word);\n        word = String::new();\n        count = 0;\n      }\n    } else {\n      if (count == n) {\n        words.push(word);\n        word = String::new();\n        count = 0;\n      }\n      word.push_back(s[i]);\n      count += 1;\n    }\n  }\n  if (count == n) {\n    words.push(word);\n  }\n  return words;\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmptm8qmam1.rs:21:8\n   |\n21 |   for (let i = 0; i < s.len(); i++) {\n   |        ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmptm8qmam1.rs:21:12\n   |\n21 |   for (let i = 0; i < s.len(); i++) {\n   |           -^ expected one of `)`, `,`, `@`, or `|`\n   |           |\n   |           help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmptm8qmam1.rs:21:14\n   |\n21 |   for (let i = 0; i < s.len(); i++) {\n   |              ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmptm8qmam1.rs:21:13\n   |\n21 |   for (let i = 0; i < s.len(); i++) {\n   |             ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmptm8qmam1.rs:21:14\n   |\n21 |   for (let i = 0; i < s.len(); i++) {\n   |              ^ expected expression\n\nerror: aborting due to 5 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns a vector of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty vector.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n/// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n  let mut words = Vec::new();\n  let mut word = String::new();\n  let mut word_count = 0;\n  for i in s.chars() {\n    if word_count == n {\n      words.push(word);\n      word = String::new();\n      word_count = 0;\n    }\n    if i.is_space() {\n      if !word.is_empty() {\n        words.push(word);\n        word = String::new();\n        word_count = 0;\n      }\n    } else {\n      word.push_back(i);\n      word_count += 1;\n    }\n  }\n  if !word.is_empty() {\n    words.push(word);\n  }\n  return words;\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "error[E0599]: no method named `is_space` found for type `char` in the current scope\n  --> /tmp/tmplv_s_8_w.rs:27:10\n   |\n27 |     if i.is_space() {\n   |          ^^^^^^^^ help: there is an associated function with a similar name: `is_whitespace`\n\nerror[E0599]: no method named `push_back` found for struct `String` in the current scope\n  --> /tmp/tmplv_s_8_w.rs:34:12\n   |\n34 |       word.push_back(i);\n   |            ^^^^^^^^^ method not found in `String`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns a vector of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty vector.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n/// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut words = Vec::new();\n    let mut word = String::new();\n    let mut count = 0;\n    for c in s.chars() {\n        if c.is_upper() {\n            if count == n {\n                words.push(word);\n                word = String::new();\n                count = 0;\n            }\n            word += c;\n            count += 1;\n        } else if c.is_lower() {\n            if count == n {\n                words.push(word);\n                word = String::new();\n                count = 0;\n            }\n            word += c;\n            count += 1;\n        } else if c.is_space() {\n            if count == n {\n                words.push(word);\n                word = String::new();\n                count = 0;\n            }\n            word += c;\n            count += 1;\n        }\n    }\n    if count == n {\n        words.push(word);\n    }\n    return words;\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "error[E0599]: no method named `is_upper` found for type `char` in the current scope\n  --> /tmp/tmphb29jjpy.rs:22:14\n   |\n22 |         if c.is_upper() {\n   |              ^^^^^^^^ help: there is an associated function with a similar name: `is_uppercase`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmphb29jjpy.rs:28:21\n   |\n28 |             word += c;\n   |                     ^ expected `&str`, found `char`\n\nerror[E0599]: no method named `is_lower` found for type `char` in the current scope\n  --> /tmp/tmphb29jjpy.rs:30:21\n   |\n30 |         } else if c.is_lower() {\n   |                     ^^^^^^^^ help: there is an associated function with a similar name: `is_lowercase`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmphb29jjpy.rs:36:21\n   |\n36 |             word += c;\n   |                     ^ expected `&str`, found `char`\n\nerror[E0599]: no method named `is_space` found for type `char` in the current scope\n  --> /tmp/tmphb29jjpy.rs:38:21\n   |\n38 |         } else if c.is_space() {\n   |                     ^^^^^^^^ help: there is an associated function with a similar name: `is_whitespace`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmphb29jjpy.rs:44:21\n   |\n44 |             word += c;\n   |                     ^ expected `&str`, found `char`\n\nerror: aborting due to 6 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns a vector of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty vector.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n/// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut words: Vec<String> = Vec::new();\n    let mut word: String = String::from(\"\");\n    let mut count: isize = 0;\n    for i in s.iter() {\n        if count == n {\n            words.push(word);\n            word = String::from(\"\");\n            count = 0;\n        }\n        if s[i] == ' ' {\n            if count > 0 {\n                words.push(word);\n                word = String::from(\"\");\n                count = 0;\n            }\n        } else {\n            count += 1;\n            word += s[i];\n        }\n    }\n    if count > 0 {\n        words.push(word);\n    }\n    return words;\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "error[E0599]: no method named `iter` found for struct `String` in the current scope\n  --> /tmp/tmpye09ve0q.rs:21:16\n   |\n21 |     for i in s.iter() {\n   |                ^^^^ method not found in `String`\n   |\nhelp: because of the in-memory representation of `&str`, to obtain an `Iterator` over each of its codepoint use method `chars`\n   |\n21 |     for i in s.chars() {\n   |                ~~~~~\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns a vector of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty vector.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n/// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n  let mut words = Vec::new();\n  let mut word = String::new();\n  let mut word_count = 0;\n  let mut word_index = 0;\n  let mut word_index_end = 0;\n  let mut word_index_start = 0;\n  let mut word_index_start_end = 0;\n  let mut word_index_start_end_end = 0;\n  let mut word_index_start_end_end_end = 0;\n  let mut word_index_start_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end_end_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end_end_end_end\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "error: expected `;`, found `}`\n  --> /tmp/tmpkoz4q7r5.rs:39:67\n   |\n39 |   let mut word_index_start_end_end_end_end_end_end_end_end_end_end\n   |                                                                   ^ help: add `;` here\n40 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpkoz4q7r5.rs:17:41\n   |\n17 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |    ------------                         ^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<String>`\n           found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns a vector of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty vector.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n/// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n  let mut words = Vec::new();\n  let mut word = String::new();\n  let mut count = 0;\n  let mut i = 0;\n  let mut j = 0;\n  let mut k = 0;\n  let mut l = 0;\n  let mut m = 0;\n  let mut n = 0;\n  let mut o = 0;\n  let mut p = 0;\n  let mut q = 0;\n  let mut r = 0;\n  let mut s = 0;\n  let mut t = 0;\n  let mut u = 0;\n  let mut v = 0;\n  let mut w = 0;\n  let mut x = 0;\n  let mut y = 0;\n  let mut z = 0;\n  let mut a = 0;\n  let mut b = 0;\n  let mut c = 0;\n  let mut d = 0;\n  let mut e = 0;\n  let mut f = 0;\n  let mut g = 0;\n  let mut h = 0;\n  let mut i = 0;\n  let mut j = 0;\n  let mut k = 0;\n  let mut l = 0;\n  let mut m = 0;\n  let mut n = 0;\n  let mut o = 0;\n  let mut p = 0;\n  let mut q = 0;\n  let mut r = 0;\n  let mut s = 0;\n  let mut t = 0;\n  let mut u = 0;\n  let mut v = 0;\n  let mut w = 0;\n  let mut x = 0;\n  let mut y = 0;\n  let mut z = 0;\n  let mut a = 0;\n  let mut b = 0;\n  let mut c = 0;\n  let mut d = 0;\n  let mut e = 0;\n  let mut f = 0;\n  let mut g = 0;\n  let mut h = 0;\n  let mut i = 0;\n  let mut j = 0;\n  let mut k = 0;\n  let mut l = 0;\n  let mut m = 0;\n  let mut n = 0;\n  let mut o = 0;\n  let mut p = 0;\n  let mut q\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "error: expected `;`, found `}`\n  --> /tmp/tmp0aji3r25.rs:81:12\n   |\n81 |   let mut q\n   |            ^ help: add `;` here\n82 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp0aji3r25.rs:17:41\n   |\n17 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |    ------------                         ^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<String>`\n           found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns a vector of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty vector.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n/// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n  let mut words = Vec::new();\n  let mut word = String::new();\n  let mut word_count = 0;\n  let mut word_index = 0;\n  let mut word_index_end = 0;\n  let mut word_index_start = 0;\n  let mut word_index_start_end = 0;\n  let mut word_index_start_end_end = 0;\n  let mut word_index_start_end_end_end = 0;\n  let mut word_index_start_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end_end_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end_end_end_end\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "error: expected `;`, found `}`\n  --> /tmp/tmpkoz4q7r5.rs:39:67\n   |\n39 |   let mut word_index_start_end_end_end_end_end_end_end_end_end_end\n   |                                                                   ^ help: add `;` here\n40 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpkoz4q7r5.rs:17:41\n   |\n17 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |    ------------                         ^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<String>`\n           found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns a vector of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty vector.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n/// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n  let mut result: Vec<String> = Vec::new();\n  let mut word: String = String::new();\n  let mut count: isize = 0;\n  for (let i = 0; i < s.len(); i++) {\n    if (s[i] == ' ') {\n      if (count == n) {\n        result.push(word);\n        word = String::new();\n        count = 0;\n      }\n    } else {\n      word += s[i];\n      count += 1;\n    }\n  }\n  if (count == n) {\n    result.push(word);\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmppsdgrcoz.rs:21:8\n   |\n21 |   for (let i = 0; i < s.len(); i++) {\n   |        ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmppsdgrcoz.rs:21:12\n   |\n21 |   for (let i = 0; i < s.len(); i++) {\n   |           -^ expected one of `)`, `,`, `@`, or `|`\n   |           |\n   |           help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmppsdgrcoz.rs:21:14\n   |\n21 |   for (let i = 0; i < s.len(); i++) {\n   |              ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmppsdgrcoz.rs:21:13\n   |\n21 |   for (let i = 0; i < s.len(); i++) {\n   |             ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmppsdgrcoz.rs:21:14\n   |\n21 |   for (let i = 0; i < s.len(); i++) {\n   |              ^ expected expression\n\nerror: aborting due to 5 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns a vector of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty vector.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n/// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut words = Vec::new();\n    let mut word = String::new();\n    let mut word_count = 0;\n    for i in s.chars() {\n        if word_count == n {\n            words.push(word);\n            word = String::new();\n            word_count = 0;\n        }\n        if s[i] == ' ' {\n            if word_count > 0 {\n                words.push(word);\n                word = String::new();\n                word_count = 0;\n            }\n        } else {\n            word = word.concat(String::from(s[i]));\n            word_count += 1;\n        }\n    }\n    if word_count > 0 {\n        words.push(word);\n    }\n    return words;\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "error[E0277]: the type `String` cannot be indexed by `char`\n  --> /tmp/tmpurirjwxw.rs:27:12\n   |\n27 |         if s[i] == ' ' {\n   |            ^^^^ `String` cannot be indexed by `char`\n   |\n   = help: the trait `Index<char>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0599]: no method named `concat` found for struct `String` in the current scope\n  --> /tmp/tmpurirjwxw.rs:34:25\n   |\n34 |             word = word.concat(String::from(s[i]));\n   |                         ^^^^^^ method not found in `String`\n\nerror[E0277]: the type `String` cannot be indexed by `char`\n  --> /tmp/tmpurirjwxw.rs:34:45\n   |\n34 |             word = word.concat(String::from(s[i]));\n   |                                             ^^^^ `String` cannot be indexed by `char`\n   |\n   = help: the trait `Index<char>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0599.\nFor more information about an error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns a vector of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty vector.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n/// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n  let mut words = Vec::new();\n  let mut word = String::new();\n  let mut consonants = 0;\n  let mut consonant_index = 0;\n  let mut consonant_count = 0;\n  let mut consonant_index_count = 0;\n  let mut consonant_index_count_end = 0;\n  let mut consonant_index_count_end_end = 0;\n  let mut consonant_index_count_end_end_end = 0;\n  let mut consonant_index_count_end_end_end_end = 0;\n  let mut consonant_index_count_end_end_end_end_end = 0;\n  let mut consonant_index_count_end_end_end_end_end_end = 0;\n  let mut consonant_index_count_end_end_end_end_end_end_end = 0;\n  let mut consonant_index_count_end_end_end_end_end_end_end_end = 0;\n  let mut consonant_index_count_end_end_end_end_end_end_end_end_end = 0;\n  let mut consonant_index_count_end_end_end_end_end_end_end_end_end_end = 0;\n  let mut consonant_index_count_end_end_end_end_end_end_end_end_end_end_end = 0;\n  let mut consonant_index_count_end_end_end_end_end_end_end_end_end_end_end_end = 0;\n  let mut consonant_index_count_end_end_end_end_end_end_end_end_end_end_end_end_end = 0;\n  let mut consonant_index_count_end_end_end_end_end_end_end_end_end_end_end_end_end_end = 0;\n  let mut consonant_index_count_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end = 0;\n  let mut consonant_index_count_end_end\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "error: expected `;`, found `}`\n  --> /tmp/tmp1eh66h27.rs:39:40\n   |\n39 |   let mut consonant_index_count_end_end\n   |                                        ^ help: add `;` here\n40 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp1eh66h27.rs:17:41\n   |\n17 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |    ------------                         ^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<String>`\n           found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns a vector of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty vector.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n/// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut words = Vec::new();\n    let mut word = String::new();\n    let mut count = 0;\n    for i in s.chars() {\n        if count == n {\n            words.push(word);\n            word = String::new();\n            count = 0;\n        }\n        if s[i] == ' ' {\n            if count > 0 {\n                words.push(word);\n                word = String::new();\n                count = 0;\n            }\n        } else {\n            count += 1;\n            word.push_back(s[i]);\n        }\n    }\n    if count > 0 {\n        words.push(word);\n    }\n    return words;\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "error[E0277]: the type `String` cannot be indexed by `char`\n  --> /tmp/tmp5pp9kyg4.rs:27:12\n   |\n27 |         if s[i] == ' ' {\n   |            ^^^^ `String` cannot be indexed by `char`\n   |\n   = help: the trait `Index<char>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0599]: no method named `push_back` found for struct `String` in the current scope\n  --> /tmp/tmp5pp9kyg4.rs:35:18\n   |\n35 |             word.push_back(s[i]);\n   |                  ^^^^^^^^^ method not found in `String`\n\nerror[E0277]: the type `String` cannot be indexed by `char`\n  --> /tmp/tmp5pp9kyg4.rs:35:28\n   |\n35 |             word.push_back(s[i]);\n   |                            ^^^^ `String` cannot be indexed by `char`\n   |\n   = help: the trait `Index<char>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0599.\nFor more information about an error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns a vector of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty vector.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n/// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut words = Vec::new();\n    let mut word = String::new();\n    let mut word_count = 0;\n    let mut word_index = 0;\n    let mut word_index_end = 0;\n    let mut word_index_start = 0;\n    let mut word_index_start_end = 0;\n    let mut word_index_start_end_end = 0;\n    let mut word_index_start_end_end_end = 0;\n    let mut word_index_start_end_end_end_end = 0;\n    let mut word_index_start_end_end_end_end_end = 0;\n    let mut word_index_start_end_end_end_end_end_end = 0;\n    let mut word_index_start_end_end_end_end_end_end_end = 0;\n    let mut word_index_start_end_end_end_end_end_end_end_end = 0;\n    let mut word_index_start_end_end_end_end_end_end_end_end_end = 0;\n    let mut word_index_start_end_end_end_end_end_end_end_end_end_end = 0;\n    let mut word_index_start_end_end_end_end_end_end_end_end_end_end_end = 0;\n    let mut word_index_start_end_end_end_end_end_end_end_end_end_end_end_end = 0;\n    let mut word_index_start_end_end_end_end_end_end_end_end_end_end_end_end_end = 0;\n    let mut word_index_start_end_end_end_end_end_end_end_end_end_end_end_end_end_end = 0;\n    let mut word_index_start_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end = 0;\n    let mut word_index_start_end_end_end_end_end_end_end_end_end_end\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "error: expected `;`, found `}`\n  --> /tmp/tmpwkh6xpwz.rs:39:69\n   |\n39 |     let mut word_index_start_end_end_end_end_end_end_end_end_end_end\n   |                                                                     ^ help: add `;` here\n40 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpwkh6xpwz.rs:17:41\n   |\n17 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |    ------------                         ^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<String>`\n           found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns a vector of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty vector.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n/// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n  let mut words = Vec::new();\n  let mut word = String::new();\n  let mut count = 0;\n  let mut pos = 0;\n  let mut i = 0;\n  let mut j = 0;\n  let mut k = 0;\n  let mut l = 0;\n  let mut m = 0;\n  let mut n = 0;\n  let mut o = 0;\n  let mut p = 0;\n  let mut q = 0;\n  let mut r = 0;\n  let mut s = 0;\n  let mut t = 0;\n  let mut u = 0;\n  let mut v = 0;\n  let mut w = 0;\n  let mut x = 0;\n  let mut y = 0;\n  let mut z = 0;\n  let mut a = 0;\n  let mut b = 0;\n  let mut c = 0;\n  let mut d = 0;\n  let mut e = 0;\n  let mut f = 0;\n  let mut g = 0;\n  let mut h = 0;\n  let mut i = 0;\n  let mut j = 0;\n  let mut k = 0;\n  let mut l = 0;\n  let mut m = 0;\n  let mut n = 0;\n  let mut o = 0;\n  let mut p = 0;\n  let mut q = 0;\n  let mut r = 0;\n  let mut s = 0;\n  let mut t = 0;\n  let mut u = 0;\n  let mut v = 0;\n  let mut w = 0;\n  let mut x = 0;\n  let mut y = 0;\n  let mut z = 0;\n  let mut a = 0;\n  let mut b = 0;\n  let mut c = 0;\n  let mut d = 0;\n  let mut e = 0;\n  let mut f = 0;\n  let mut g = 0;\n  let mut h = 0;\n  let mut i = 0;\n  let mut j = 0;\n  let mut k = 0;\n  let mut l = 0;\n  let mut m = 0;\n  let mut n = 0;\n  let mut o = 0;\n  let mut p\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "error: expected `;`, found `}`\n  --> /tmp/tmpwn1chy1v.rs:81:12\n   |\n81 |   let mut p\n   |            ^ help: add `;` here\n82 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpwn1chy1v.rs:17:41\n   |\n17 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |    ------------                         ^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<String>`\n           found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns a vector of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty vector.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n/// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n  let mut result = Vec::new();\n  let mut pos = 0;\n  let mut count = 0;\n  let mut word = String::new();\n  let mut word_count = 0;\n  let mut word_pos = 0;\n  let mut word_count_pos = 0;\n  let mut word_pos_pos = 0;\n  let mut word_count_pos_pos = 0;\n  let mut word_pos_pos_pos = 0;\n  let mut word_count_pos_pos_pos = 0;\n  let mut word_pos_pos_pos_pos = 0;\n  let mut word_count_pos_pos_pos_pos = 0;\n  let mut word_pos_pos_pos_pos_pos = 0;\n  let mut word_count_pos_pos_pos_pos_pos = 0;\n  let mut word_pos_pos_pos_pos_pos_pos = 0;\n  let mut word_count_pos_pos_pos_pos_pos_pos = 0;\n  let mut word_pos_pos_pos_pos_pos_pos_pos = 0;\n  let mut word_count_pos_pos_pos_pos_pos_pos_pos = 0;\n  let mut word_pos_pos_pos_pos_pos_pos_pos_pos = 0;\n  let mut word_count_pos_pos_pos_pos_pos_pos_pos_pos = 0;\n  let mut word_pos_pos_pos_pos_pos_pos_pos_pos_pos = 0;\n  let mut word_count_pos_pos_pos_pos_pos_pos_pos_pos_pos = 0;\n  let mut word_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos = 0;\n  let mut word_count_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos = 0;\n  let mut word_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos = 0;\n  let mut word_count_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos_pos = 0;\n\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "error[E0308]: mismatched types\n  --> /tmp/tmp_3lfrsnb.rs:17:41\n   |\n17 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |    ------------                         ^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<String>`\n           found unit type `()`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns a vector of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty vector.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n/// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n  let mut result = Vec::new();\n  let mut word = String::new();\n  let mut consonants = 0;\n  let mut consonant_index = 0;\n  let mut consonant_count = 0;\n  let mut consonant_count_index = 0;\n  let mut consonant_count_count = 0;\n  let mut consonant_count_count_index = 0;\n  let mut consonant_count_count_count = 0;\n  let mut consonant_count_count_count_index = 0;\n  let mut consonant_count_count_count_count = 0;\n  let mut consonant_count_count_count_count_index = 0;\n  let mut consonant_count_count_count_count_count = 0;\n  let mut consonant_count_count_count_count_count_index = 0;\n  let mut consonant_count_count_count_count_count_count = 0;\n  let mut consonant_count_count_count_count_count_count_index = 0;\n  let mut consonant_count_count_count_count_count_count_count = 0;\n  let mut consonant_count_count_count_count_count_count_count_index = 0;\n  let mut consonant_count_count_count_count_count_count_count_count = 0;\n  let mut consonant_count_count_count_count_count_count_count_count_index = 0;\n  let mut consonant_count_count_count_count_count_count_count_count_count = 0;\n  let mut consonant_count_count_count_count_count_count_count_count_count_index = 0;\n  let mut consonant_count_count_count_count_count_count_count_count_count_count = 0;\n  let mut consonant_count_count_count_count_count_count_count_count_count_count_index = 0;\n  let mut consonant_count_count_count_count_count_count_count_count_count_count_count = 0;\n  let mut consonant_count_count_count_count_count_count_count_count\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "error: expected `;`, found `}`\n  --> /tmp/tmp5iczd7pu.rs:43:68\n   |\n43 |   let mut consonant_count_count_count_count_count_count_count_count\n   |                                                                    ^ help: add `;` here\n44 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp5iczd7pu.rs:17:41\n   |\n17 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |    ------------                         ^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<String>`\n           found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns a vector of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty vector.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n/// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n  let mut words = Vec::new();\n  let mut word = String::new();\n  let mut count = 0;\n  for (let i = 0; i < s.len(); i++) {\n    if (s[i] == ' ') {\n      if (count == n) {\n        words.push(word);\n        word = String::new();\n        count = 0;\n      }\n    } else {\n      if (count == n) {\n        words.push(word);\n        word = String::new();\n        count = 0;\n      }\n      word += s[i];\n      count += 1;\n    }\n  }\n  if (count == n) {\n    words.push(word);\n  }\n  return words;\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmp_82swdw6.rs:21:8\n   |\n21 |   for (let i = 0; i < s.len(); i++) {\n   |        ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmp_82swdw6.rs:21:12\n   |\n21 |   for (let i = 0; i < s.len(); i++) {\n   |           -^ expected one of `)`, `,`, `@`, or `|`\n   |           |\n   |           help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmp_82swdw6.rs:21:14\n   |\n21 |   for (let i = 0; i < s.len(); i++) {\n   |              ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmp_82swdw6.rs:21:13\n   |\n21 |   for (let i = 0; i < s.len(); i++) {\n   |             ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmp_82swdw6.rs:21:14\n   |\n21 |   for (let i = 0; i < s.len(); i++) {\n   |              ^ expected expression\n\nerror: aborting due to 5 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns a vector of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty vector.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n/// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut result = Vec::new();\n    let mut word = String::new();\n    let mut consonants = 0;\n    let mut consonant_index = 0;\n    let mut consonant_count = 0;\n    let mut consonant_count_index = 0;\n    let mut consonant_count_count = 0;\n    let mut consonant_count_count_index = 0;\n    let mut consonant_count_count_count = 0;\n    let mut consonant_count_count_count_index = 0;\n    let mut consonant_count_count_count_count = 0;\n    let mut consonant_count_count_count_count_index = 0;\n    let mut consonant_count_count_count_count_count = 0;\n    let mut consonant_count_count_count_count_count_index = 0;\n    let mut consonant_count_count_count_count_count_count = 0;\n    let mut consonant_count_count_count_count_count_count_index = 0;\n    let mut consonant_count_count_count_count_count_count_count = 0;\n    let mut consonant_count_count_count_count_count_count_count_index = 0;\n    let mut consonant_count_count_count_count_count_count_count_count = 0;\n    let mut consonant_count_count_count_count_count_count_count_count_index = 0;\n    let mut consonant_count_count_count_count_count_count_count_count_count = 0;\n    let mut consonant_count_count_count_count_count_count_count_count_count_index = 0;\n    let mut consonant_count_count_count_count_count_count_count_count_count_count = 0;\n    let mut consonant_count_count_count_count_count_count_count_count_count_count_index = 0;\n    let mut consonant_count_count_count_count_count_count_count_count_count_count_count = 0;\n    let mut consonant_count_count_count_count_count_count_count_count\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "error: expected `;`, found `}`\n  --> /tmp/tmpmhk99u1j.rs:43:70\n   |\n43 |     let mut consonant_count_count_count_count_count_count_count_count\n   |                                                                      ^ help: add `;` here\n44 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpmhk99u1j.rs:17:41\n   |\n17 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |    ------------                         ^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<String>`\n           found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns a vector of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty vector.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n/// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n  let mut words = Vec::new();\n  let mut word = String::new();\n  let mut word_count = 0;\n  let mut word_index = 0;\n  let mut word_index_end = 0;\n  let mut word_index_start = 0;\n  let mut word_index_start_end = 0;\n  let mut word_index_start_end_end = 0;\n  let mut word_index_start_end_end_end = 0;\n  let mut word_index_start_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end_end_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end_end_end_end\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "error: expected `;`, found `}`\n  --> /tmp/tmpkoz4q7r5.rs:39:67\n   |\n39 |   let mut word_index_start_end_end_end_end_end_end_end_end_end_end\n   |                                                                   ^ help: add `;` here\n40 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpkoz4q7r5.rs:17:41\n   |\n17 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |    ------------                         ^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<String>`\n           found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns a vector of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty vector.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n/// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n  let mut words = Vec::new();\n  let mut word = String::new();\n  let mut word_count = 0;\n  let mut word_index = 0;\n  let mut word_index_end = 0;\n  let mut word_index_start = 0;\n  let mut word_index_start_end = 0;\n  let mut word_index_start_end_end = 0;\n  let mut word_index_start_end_end_end = 0;\n  let mut word_index_start_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end_end_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end_end_end_end\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "error: expected `;`, found `}`\n  --> /tmp/tmpkoz4q7r5.rs:39:67\n   |\n39 |   let mut word_index_start_end_end_end_end_end_end_end_end_end_end\n   |                                                                   ^ help: add `;` here\n40 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpkoz4q7r5.rs:17:41\n   |\n17 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |    ------------                         ^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<String>`\n           found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns a vector of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty vector.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n/// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut result = Vec::new();\n    let mut current = 0;\n    let mut count = 0;\n    let mut word = String::new();\n    let mut word_count = 0;\n    let mut word_index = 0;\n    let mut word_index_end = 0;\n    let mut word_index_start = 0;\n    let mut word_index_start_end = 0;\n    let mut word_index_start_end_end = 0;\n    let mut word_index_start_end_end_end = 0;\n    let mut word_index_start_end_end_end_end = 0;\n    let mut word_index_start_end_end_end_end_end = 0;\n    let mut word_index_start_end_end_end_end_end_end = 0;\n    let mut word_index_start_end_end_end_end_end_end_end = 0;\n    let mut word_index_start_end_end_end_end_end_end_end_end = 0;\n    let mut word_index_start_end_end_end_end_end_end_end_end_end = 0;\n    let mut word_index_start_end_end_end_end_end_end_end_end_end_end = 0;\n    let mut word_index_start_end_end_end_end_end_end_end_end_end_end_end = 0;\n    let mut word_index_start_end_end_end_end_end_end_end_end_end_end_end_end = 0;\n    let mut word_index_start_end_end_end_end_end_end_end_end_end_end_end_end_end = 0;\n    let mut word_index_start_end_end_end_end_end_end_end_end_end_end_end_end_end_end = 0;\n    let mut word_index_start_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end = 0;\n    let mut word_index_start_end_end\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "error: expected `;`, found `}`\n  --> /tmp/tmpua2kiqop.rs:41:37\n   |\n41 |     let mut word_index_start_end_end\n   |                                     ^ help: add `;` here\n42 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpua2kiqop.rs:17:41\n   |\n17 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |    ------------                         ^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<String>`\n           found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns a vector of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty vector.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n/// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n  let mut words = Vec::new();\n  let mut word = String::new();\n  let mut count = 0;\n  let mut i = 0;\n  let mut j = 0;\n  let mut k = 0;\n  let mut l = 0;\n  let mut m = 0;\n  let mut n = 0;\n  let mut o = 0;\n  let mut p = 0;\n  let mut q = 0;\n  let mut r = 0;\n  let mut s = 0;\n  let mut t = 0;\n  let mut u = 0;\n  let mut v = 0;\n  let mut w = 0;\n  let mut x = 0;\n  let mut y = 0;\n  let mut z = 0;\n  let mut a = 0;\n  let mut b = 0;\n  let mut c = 0;\n  let mut d = 0;\n  let mut e = 0;\n  let mut f = 0;\n  let mut g = 0;\n  let mut h = 0;\n  let mut i = 0;\n  let mut j = 0;\n  let mut k = 0;\n  let mut l = 0;\n  let mut m = 0;\n  let mut n = 0;\n  let mut o = 0;\n  let mut p = 0;\n  let mut q = 0;\n  let mut r = 0;\n  let mut s = 0;\n  let mut t = 0;\n  let mut u = 0;\n  let mut v = 0;\n  let mut w = 0;\n  let mut x = 0;\n  let mut y = 0;\n  let mut z = 0;\n  let mut a = 0;\n  let mut b = 0;\n  let mut c = 0;\n  let mut d = 0;\n  let mut e = 0;\n  let mut f = 0;\n  let mut g = 0;\n  let mut h = 0;\n  let mut i = 0;\n  let mut j = 0;\n  let mut k = 0;\n  let mut l = 0;\n  let mut m = 0;\n  let mut n = 0;\n  let mut o = 0;\n  let mut p = 0;\n  let mut q\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "error: expected `;`, found `}`\n  --> /tmp/tmp0aji3r25.rs:81:12\n   |\n81 |   let mut q\n   |            ^ help: add `;` here\n82 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp0aji3r25.rs:17:41\n   |\n17 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |    ------------                         ^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<String>`\n           found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns a vector of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty vector.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n/// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut words: Vec<String> = Vec::new();\n    let mut word: String = String::new();\n    let mut count: isize = 0;\n    for i in s.chars() {\n        if count == n {\n            words.push(word);\n            word = String::new();\n            count = 0;\n        }\n        if s[i] == ' ' {\n            continue;\n        }\n        if s[i] == ' ' {\n            continue;\n        }\n        if s[i] == ' ' {\n            continue;\n        }\n        if s[i] == ' ' {\n            continue;\n        }\n        if s[i] == ' ' {\n            continue;\n        }\n        if s[i] == ' ' {\n            continue;\n        }\n        if s[i] == ' ' {\n            continue;\n        }\n        if s[i] == ' ' {\n            continue;\n        }\n        if s[i] == ' ' {\n            continue;\n        }\n        if s[i] == ' ' {\n            continue;\n        }\n        if s[i] == ' ' {\n            continue;\n        }\n        if s[i] == ' ' {\n            continue;\n        }\n        if s[i] == ' ' {\n            continue;\n        }\n        if s[i] == ' ' {\n            continue;\n        }\n        if s[i] == ' ' {\n            continue;\n        }\n        if s[i] == ' ' {\n            continue;\n        }\n        if s[i] == ' ' {\n            continue;\n        }\n        if s[i] == ' ' {\n            continue;\n        }\n        if s[i] == ' ' {\n            continue;\n        }\n        if s[i] == ' ' {\n            continue;\n        }\n        if s[i] == ' ' {\n            continue;\n        }\n        if s[i] == ' ' {\n            continue;\n        }\n        if s[i] == ' ' {\n            continue;\n        }\n        if s[i] == ' ' {\n            continue;\n        }\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "error: this file contains an unclosed delimiter\n   --> /tmp/tmph7tmhgd4.rs:110:3\n    |\n17  | fn select_words(s: String, n: isize) -> Vec<String> {\n    |                                                     - unclosed delimiter\n...\n21  |     for i in s.chars() {\n    |                        - this delimiter might not be properly closed...\n...\n99  | }\n    | - ...as it matches this but it has different indentation\n...\n110 | }\n    |   ^\n\nerror[E0277]: the type `String` cannot be indexed by `char`\n  --> /tmp/tmph7tmhgd4.rs:27:12\n   |\n27 |         if s[i] == ' ' {\n   |            ^^^^ `String` cannot be indexed by `char`\n   |\n   = help: the trait `Index<char>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `char`\n  --> /tmp/tmph7tmhgd4.rs:30:12\n   |\n30 |         if s[i] == ' ' {\n   |            ^^^^ `String` cannot be indexed by `char`\n   |\n   = help: the trait `Index<char>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `char`\n  --> /tmp/tmph7tmhgd4.rs:33:12\n   |\n33 |         if s[i] == ' ' {\n   |            ^^^^ `String` cannot be indexed by `char`\n   |\n   = help: the trait `Index<char>` is not implemented for `String`\n   = help: the following other types",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns a vector of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty vector.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n/// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n  let mut words = Vec::new();\n  let mut word = String::new();\n  let mut count = 0;\n  for (let i = 0; i < s.len(); i++) {\n    if (s[i] == ' ') {\n      if (count == n) {\n        words.push(word);\n        word = String::new();\n        count = 0;\n      }\n    } else {\n      word = word.cat(s[i]);\n      count += 1;\n    }\n  }\n  if (count == n) {\n    words.push(word);\n  }\n  return words;\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmp7y9tr_5a.rs:21:8\n   |\n21 |   for (let i = 0; i < s.len(); i++) {\n   |        ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmp7y9tr_5a.rs:21:12\n   |\n21 |   for (let i = 0; i < s.len(); i++) {\n   |           -^ expected one of `)`, `,`, `@`, or `|`\n   |           |\n   |           help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmp7y9tr_5a.rs:21:14\n   |\n21 |   for (let i = 0; i < s.len(); i++) {\n   |              ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmp7y9tr_5a.rs:21:13\n   |\n21 |   for (let i = 0; i < s.len(); i++) {\n   |             ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmp7y9tr_5a.rs:21:14\n   |\n21 |   for (let i = 0; i < s.len(); i++) {\n   |              ^ expected expression\n\nerror: aborting due to 5 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns a vector of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty vector.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n/// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut words: Vec<String> = Vec::new();\n    let mut word: String = String::from(\"\");\n    for i in s.chars() {\n        if i.is_upper() {\n            if word.len() == n {\n                words.push(word);\n                word = String::from(\"\");\n            }\n        } else {\n            word += String::from(i);\n        }\n    }\n    if word.len() == n {\n        words.push(word);\n    }\n    return words;\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "error[E0599]: no method named `is_upper` found for type `char` in the current scope\n  --> /tmp/tmpxn48zxe4.rs:21:14\n   |\n21 |         if i.is_upper() {\n   |              ^^^^^^^^ help: there is an associated function with a similar name: `is_uppercase`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpxn48zxe4.rs:22:30\n   |\n22 |             if word.len() == n {\n   |                              ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic if the converted value doesn't fit\n   |\n22 |             if word.len() == n.try_into().unwrap() {\n   |                               ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpxn48zxe4.rs:27:21\n   |\n27 |             word += String::from(i);\n   |                     ^^^^^^^^^^^^^^^\n   |                     |\n   |                     expected `&str`, found struct `String`\n   |                     help: consider borrowing here: `&String::from(i)`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpxn48zxe4.rs:30:22\n   |\n30 |     if word.len() == n {\n   |                      ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic if the converted value doesn't fit\n   |\n30 |     if word.len() == n.try_into().unwrap() {\n   |                       ++++++++++++++++++++\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns a vector of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty vector.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n/// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n  let mut words = Vec::new();\n  let mut word = String::new();\n  let mut i = 0;\n  let mut j = 0;\n  let mut count = 0;\n  while i < s.len() {\n    if s[i] == ' ' {\n      if count == n {\n        words.push(word);\n        word = String::new();\n        count = 0;\n      }\n      i += 1;\n      continue;\n    }\n    if s[i] == '\\n' {\n      i += 1;\n      continue;\n    }\n    if s[i] == '\\r' {\n      i += 1;\n      continue;\n    }\n    if s[i] == '\\t' {\n      i += 1;\n      continue;\n    }\n    if s[i] == '\\v' {\n      i += 1;\n      continue;\n    }\n    if s[i] == '\\f' {\n      i += 1;\n      continue;\n    }\n    if s[i] == '\\b' {\n      i += 1;\n      continue;\n    }\n    if s[i] == '\\a' {\n      i += 1;\n      continue;\n    }\n    if s[i] == '\\0' {\n      i += 1;\n      continue;\n    }\n    if s[i] == '\\x0b' {\n      i += 1;\n      continue;\n    }\n    if s[i] == '\\x0c' {\n      i += 1;\n      continue;\n    }\n    if s[i] == '\\x0e' {\n      i += 1;\n      continue;\n    }\n    if s[i] == '\\x0f' {\n      i += 1;\n      continue;\n    }\n    if s[i] == '\\x1b' {\n      i += 1;\n      continue;\n    }\n    if s[i] == '\\x1c' {\n      i += 1;\n      continue;\n    }\n    if s[i] == '\\x1d' {\n      i += 1;\n      continue;\n    \n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "error: unknown character escape: `v`\n  --> /tmp/tmp3q0dqsih.rs:45:18\n   |\n45 |     if s[i] == '\\v' {\n   |                  ^ unknown character escape\n   |\n   = help: for more information, visit <https://static.rust-lang.org/doc/master/reference.html#literals>\nhelp: if you meant to write a literal backslash (perhaps escaping in a regular expression), consider a raw string literal\n   |\n45 |     if s[i] == r\"\\v\" {\n   |                ~~~~~\n\nerror: unknown character escape: `f`\n  --> /tmp/tmp3q0dqsih.rs:49:18\n   |\n49 |     if s[i] == '\\f' {\n   |                  ^ unknown character escape\n   |\n   = help: for more information, visit <https://static.rust-lang.org/doc/master/reference.html#literals>\nhelp: if you meant to write a literal backslash (perhaps escaping in a regular expression), consider a raw string literal\n   |\n49 |     if s[i] == r\"\\f\" {\n   |                ~~~~~\n\nerror: unknown character escape: `b`\n  --> /tmp/tmp3q0dqsih.rs:53:18\n   |\n53 |     if s[i] == '\\b' {\n   |                  ^ unknown character escape\n   |\n   = help: for more information, visit <https://static.rust-lang.org/doc/master/reference.html#literals>\nhelp: if you meant to write a literal backslash (perhaps escaping in a regular expression), consider a raw string literal\n   |\n53 |     if s[i] == r\"\\b\" {\n   |                ~~~~~\n\nerror: unknown character escape: `a`\n  --> /tmp/tmp3q0dqsih.rs:57:18\n   |\n57 |     if s[i] == '\\a' {\n   |                  ^ unknown character escape\n   |\n   = help: for more information, visit <https://static.rust-lang.org/doc/master/reference.html#literals>\nhelp: if you meant to write a literal backslash (perhaps escaping in a regular expression), consider a raw string literal\n   |\n57 |     if s[i] == r\"\\a\" {\n   |                ~~~~~\n\nerror: this file contains an unclosed delimiter\n   --> /tmp/tmp3q0dqsih.rs:104:3\n    |\n17  | fn select_words(s: String, n: isize) -> Vec<String> {\n    |                                                     - unclosed delimiter\n...\n23  |   while i < s.len() {\n    |                 ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns a vector of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty vector.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n/// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut words: Vec<String> = Vec::new();\n    let mut word: String = String::new();\n    let mut count: isize = 0;\n    for i in s.chars() {\n        if count == n {\n            words.push(word);\n            word = String::new();\n            count = 0;\n        }\n        if s[i] == ' ' {\n            if !word.is_empty() {\n                count += 1;\n            }\n        } else {\n            word += s[i];\n            count += 1;\n        }\n    }\n    if !word.is_empty() {\n        words.push(word);\n    }\n    return words;\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "error[E0277]: the type `String` cannot be indexed by `char`\n  --> /tmp/tmptl4n4j1e.rs:27:12\n   |\n27 |         if s[i] == ' ' {\n   |            ^^^^ `String` cannot be indexed by `char`\n   |\n   = help: the trait `Index<char>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `char`\n  --> /tmp/tmptl4n4j1e.rs:32:21\n   |\n32 |             word += s[i];\n   |                     ^^^^ `String` cannot be indexed by `char`\n   |\n   = help: the trait `Index<char>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns a vector of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty vector.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n/// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut words = Vec::new();\n    let mut word = String::new();\n    let mut word_count = 0;\n    for i in s.chars() {\n        if word_count == n {\n            words.push(word);\n            word = String::new();\n            word_count = 0;\n        }\n        if s[i] == ' ' {\n            if word_count > 0 {\n                words.push(word);\n                word = String::new();\n                word_count = 0;\n            }\n        } else {\n            word = word.concat(String::from(s[i]));\n            word_count += 1;\n        }\n    }\n    if word_count > 0 {\n        words.push(word);\n    }\n    return words;\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "error[E0277]: the type `String` cannot be indexed by `char`\n  --> /tmp/tmpurirjwxw.rs:27:12\n   |\n27 |         if s[i] == ' ' {\n   |            ^^^^ `String` cannot be indexed by `char`\n   |\n   = help: the trait `Index<char>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0599]: no method named `concat` found for struct `String` in the current scope\n  --> /tmp/tmpurirjwxw.rs:34:25\n   |\n34 |             word = word.concat(String::from(s[i]));\n   |                         ^^^^^^ method not found in `String`\n\nerror[E0277]: the type `String` cannot be indexed by `char`\n  --> /tmp/tmpurirjwxw.rs:34:45\n   |\n34 |             word = word.concat(String::from(s[i]));\n   |                                             ^^^^ `String` cannot be indexed by `char`\n   |\n   = help: the trait `Index<char>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0599.\nFor more information about an error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns a vector of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty vector.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n/// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut words = Vec::new();\n    let mut word = String::new();\n    let mut count = 0;\n    for c in s.chars() {\n        if c == ' ' {\n            if count == n {\n                words.push(word);\n                word = String::new();\n                count = 0;\n            }\n        } else {\n            if count < n {\n                count += 1;\n                word.push_back(c);\n            } else {\n                count -= 1;\n                word.push_back(c);\n            }\n        }\n    }\n    if count == n {\n        words.push(word);\n    }\n    return words;\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "error[E0599]: no method named `push_back` found for struct `String` in the current scope\n  --> /tmp/tmpbz5w5iho.rs:31:22\n   |\n31 |                 word.push_back(c);\n   |                      ^^^^^^^^^ method not found in `String`\n\nerror[E0599]: no method named `push_back` found for struct `String` in the current scope\n  --> /tmp/tmpbz5w5iho.rs:34:22\n   |\n34 |                 word.push_back(c);\n   |                      ^^^^^^^^^ method not found in `String`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns a vector of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty vector.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n/// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut words = Vec::new();\n    let mut word = String::new();\n    let mut count = 0;\n    let mut pos = 0;\n    let mut last_pos = 0;\n    let mut last_word = String::new();\n    while pos < s.len() {\n        if s[pos] == ' ' {\n            if count == n {\n                words.push(last_word);\n                count = 0;\n                last_word = String::new();\n            }\n            last_pos = pos;\n        } else {\n            if count == n {\n                words.push(last_word);\n                count = 0;\n                last_word = String::new();\n            }\n            if count == 0 {\n                last_word = last_word.concat(String::from(s[pos]));\n                count += 1;\n            } else {\n                last_word = last_word.concat(String::from(s[pos]));\n            }\n        }\n        pos += 1;\n    }\n    if count == n {\n        words.push(last_word);\n    }\n    return words;\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpqvp_d7hw.rs:25:12\n   |\n25 |         if s[pos] == ' ' {\n   |            ^^^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0599]: no method named `concat` found for struct `String` in the current scope\n  --> /tmp/tmpqvp_d7hw.rs:39:39\n   |\n39 |                 last_word = last_word.concat(String::from(s[pos]));\n   |                                       ^^^^^^ method not found in `String`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpqvp_d7hw.rs:39:59\n   |\n39 |                 last_word = last_word.concat(String::from(s[pos]));\n   |                                                           ^^^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0599]: no method named `concat` found for struct `String` in the current scope\n  --> /tmp/tmpqvp_d7hw.rs:42:39\n   |\n42 |                 last_word = last_word.concat(String::from(s[pos]));\n   |                                       ^^^^^^ method not found in `String`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpq",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns a vector of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty vector.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n/// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut words: Vec<String> = Vec::new();\n    let mut word: String = String::new();\n    let mut count: isize = 0;\n    for c in s.chars() {\n        if count == n {\n            words.push(word);\n            word = String::new();\n            count = 0;\n        }\n        if c.is_upper() {\n            word += c.to_lower();\n        } else {\n            count += 1;\n        }\n    }\n    words.push(word);\n    return words;\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "error[E0599]: no method named `is_upper` found for type `char` in the current scope\n  --> /tmp/tmpleazupzk.rs:27:14\n   |\n27 |         if c.is_upper() {\n   |              ^^^^^^^^ help: there is an associated function with a similar name: `is_uppercase`\n\nerror[E0599]: no method named `to_lower` found for type `char` in the current scope\n  --> /tmp/tmpleazupzk.rs:28:23\n   |\n28 |             word += c.to_lower();\n   |                       ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns a vector of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty vector.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n/// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n  let mut words = Vec::new();\n  let mut word = String::new();\n  let mut consonants = 0;\n  let mut consonant_count = 0;\n  let mut consonant_index = 0;\n  let mut consonant_index_start = 0;\n  let mut consonant_index_end = 0;\n  let mut consonant_index_end_start = 0;\n  let mut consonant_index_end_end = 0;\n  let mut consonant_index_end_end_start = 0;\n  let mut consonant_index_end_end_end = 0;\n  let mut consonant_index_end_end_end_start = 0;\n  let mut consonant_index_end_end_end_end = 0;\n  let mut consonant_index_end_end_end_end_start = 0;\n  let mut consonant_index_end_end_end_end_end = 0;\n  let mut consonant_index_end_end_end_end_end_start = 0;\n  let mut consonant_index_end_end_end_end_end_end = 0;\n  let mut consonant_index_end_end_end_end_end_end_start = 0;\n  let mut consonant_index_end_end_end_end_end_end_end = 0;\n  let mut consonant_index_end_end_end_end_end_end_end_start = 0;\n  let mut consonant_index_end_end_end_end_end_end_end_end = 0;\n  let mut consonant_index_end_end_end_end_end_end_end_end_start = 0;\n  let mut consonant_index_end_end_end_end_end_end_end_end_end = 0;\n  let mut consonant_index_end_end_end_end_end_end_end_end_end_start = 0;\n  let mut consonant_index_end_end_end_end_end_end_end_end_end_end = 0;\n  let mut consonant_index_end_end_end_end_end_end_end\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "error: expected `;`, found `}`\n  --> /tmp/tmp9eujiah6.rs:43:54\n   |\n43 |   let mut consonant_index_end_end_end_end_end_end_end\n   |                                                      ^ help: add `;` here\n44 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9eujiah6.rs:17:41\n   |\n17 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |    ------------                         ^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<String>`\n           found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns a vector of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty vector.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n/// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n  let mut words = Vec::new();\n  let mut word = String::new();\n  let mut word_count = 0;\n  let mut word_index = 0;\n  let mut word_index_end = 0;\n  let mut word_index_start = 0;\n  let mut word_index_start_end = 0;\n  let mut word_index_start_start = 0;\n  let mut word_index_start_start_end = 0;\n  let mut word_index_start_start_start = 0;\n  let mut word_index_start_start_start_end = 0;\n  let mut word_index_start_start_start_start = 0;\n  let mut word_index_start_start_start_start_end = 0;\n  let mut word_index_start_start_start_start_start = 0;\n  let mut word_index_start_start_start_start_start_end = 0;\n  let mut word_index_start_start_start_start_start_start = 0;\n  let mut word_index_start_start_start_start_start_start_end = 0;\n  let mut word_index_start_start_start_start_start_start_start = 0;\n  let mut word_index_start_start_start_start_start_start_start_end = 0;\n  let mut word_index_start_start_start_start_start_start_start_start = 0;\n  let mut word_index_start_start_start_start_start_start_start_start_end = 0;\n  let mut word_index_start_start_start_start_start_start_start_start_start = 0;\n  let mut word_index_start_start_start_start_start_start_start_start_start_end = 0;\n  let mut word_index_start_start_start_start_start_start_start_start_start_start = 0;\n  let mut word_index_start_start_start_start_start_start_start_start_start_start_end = 0;\n  let mut word_index_start_start_start_start_start_start_start\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "error: expected `;`, found `}`\n  --> /tmp/tmpkpbme8fs.rs:43:63\n   |\n43 |   let mut word_index_start_start_start_start_start_start_start\n   |                                                               ^ help: add `;` here\n44 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpkpbme8fs.rs:17:41\n   |\n17 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |    ------------                         ^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<String>`\n           found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns a vector of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty vector.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n/// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n  let mut words = Vec::new();\n  let mut word = String::new();\n  let mut count = 0;\n  for (let c of s) {\n    if (count == n) {\n      words.push(word);\n      word = String::new();\n      count = 0;\n    }\n    if (c.is_upper()) {\n      word += c.to_lower();\n    } else {\n      word += c;\n    }\n    count += 1;\n  }\n  words.push(word);\n  return words;\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmpf9sh1oni.rs:21:8\n   |\n21 |   for (let c of s) {\n   |        ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `c`\n  --> /tmp/tmpf9sh1oni.rs:21:12\n   |\n21 |   for (let c of s) {\n   |           -^ expected one of `)`, `,`, `@`, or `|`\n   |           |\n   |           help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `of`\n  --> /tmp/tmpf9sh1oni.rs:21:14\n   |\n21 |   for (let c of s) {\n   |             -^^ expected one of `)`, `,`, `@`, or `|`\n   |             |\n   |             help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `s`\n  --> /tmp/tmpf9sh1oni.rs:21:17\n   |\n21 |   for (let c of s) {\n   |                -^ expected one of `)`, `,`, `@`, or `|`\n   |                |\n   |                help: missing `,`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmpf9sh1oni.rs:21:19\n   |\n21 |   for (let c of s) {\n   |                   ^ help: try adding `in` here\n\nerror: expected `{`, found `words`\n  --> /tmp/tmpf9sh1oni.rs:34:3\n   |\n34 |   words.push(word);\n   |   ^^^^^ expected `{`\n   |\nhelp: try placing this code inside a block\n   |\n34 |   { words.push(word); }\n   |   +                   +\n\nerror: aborting due to 6 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns a vector of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty vector.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n/// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut words = Vec::new();\n    let mut word = String::new();\n    let mut i = 0;\n    for i in s.chars() {\n        if i.is_upper() {\n            if word.len() == n {\n                words.push(word);\n                word = String::new();\n            }\n        } else if i.is_lower() {\n            if word.len() == n {\n                words.push(word);\n                word = String::new();\n            }\n        } else if i.is_space() {\n            if word.len() == n {\n                words.push(word);\n                word = String::new();\n            }\n        } else {\n            word += i;\n        }\n    }\n    if word.len() == n {\n        words.push(word);\n    }\n    return words;\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "error[E0599]: no method named `is_upper` found for type `char` in the current scope\n  --> /tmp/tmp3y6ql1x7.rs:22:14\n   |\n22 |         if i.is_upper() {\n   |              ^^^^^^^^ help: there is an associated function with a similar name: `is_uppercase`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp3y6ql1x7.rs:23:30\n   |\n23 |             if word.len() == n {\n   |                              ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic if the converted value doesn't fit\n   |\n23 |             if word.len() == n.try_into().unwrap() {\n   |                               ++++++++++++++++++++\n\nerror[E0599]: no method named `is_lower` found for type `char` in the current scope\n  --> /tmp/tmp3y6ql1x7.rs:27:21\n   |\n27 |         } else if i.is_lower() {\n   |                     ^^^^^^^^ help: there is an associated function with a similar name: `is_lowercase`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp3y6ql1x7.rs:28:30\n   |\n28 |             if word.len() == n {\n   |                              ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic if the converted value doesn't fit\n   |\n28 |             if word.len() == n.try_into().unwrap() {\n   |                               ++++++++++++++++++++\n\nerror[E0599]: no method named `is_space` found for type `char` in the current scope\n  --> /tmp/tmp3y6ql1x7.rs:32:21\n   |\n32 |         } else if i.is_space() {\n   |                     ^^^^^^^^ help: there is an associated function with a similar name: `is_whitespace`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp3y6ql1x7.rs:33:30\n   |\n33 |             if word.len() == n {\n   |                              ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic if the converted value doesn't fit\n   |\n33 |             if word.len() == n.try_into().unwrap() {\n   |                               ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp3y6ql1x7.rs:38:21\n   |\n38 |             wo",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns a vector of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty vector.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n/// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n  let mut words = Vec::new();\n  let mut word = String::new();\n  let mut count = 0;\n  let mut i = 0;\n  let mut j = 0;\n  let mut k = 0;\n  while i < s.len() {\n    if s[i] == ' ' {\n      if count == n {\n        words.push(word);\n        word = String::new();\n        count = 0;\n      }\n      i += 1;\n      continue;\n    }\n    if s[i] == '\\n' {\n      i += 1;\n      continue;\n    }\n    if s[i] == '\\r' {\n      i += 1;\n      continue;\n    }\n    if s[i] == '\\t' {\n      i += 1;\n      continue;\n    }\n    if s[i] == '\\v' {\n      i += 1;\n      continue;\n    }\n    if s[i] == '\\f' {\n      i += 1;\n      continue;\n    }\n    if s[i] == '\\b' {\n      i += 1;\n      continue;\n    }\n    if s[i] == '\\a' {\n      i += 1;\n      continue;\n    }\n    if s[i] == '\\0' {\n      i += 1;\n      continue;\n    }\n    if s[i] == '\\x0b' {\n      i += 1;\n      continue;\n    }\n    if s[i] == '\\x0c' {\n      i += 1;\n      continue;\n    }\n    if s[i] == '\\x0e' {\n      i += 1;\n      continue;\n    }\n    if s[i] == '\\x0f' {\n      i += 1;\n      continue;\n    }\n    if s[i] == '\\x1b' {\n      i += 1;\n      continue;\n    }\n    if s[i] == '\\x1c' {\n      i += 1;\n      continue;\n    }\n    if s[i] == '\\x1d' {\n      i +=\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "error: unknown character escape: `v`\n  --> /tmp/tmpcua_fy2q.rs:46:18\n   |\n46 |     if s[i] == '\\v' {\n   |                  ^ unknown character escape\n   |\n   = help: for more information, visit <https://static.rust-lang.org/doc/master/reference.html#literals>\nhelp: if you meant to write a literal backslash (perhaps escaping in a regular expression), consider a raw string literal\n   |\n46 |     if s[i] == r\"\\v\" {\n   |                ~~~~~\n\nerror: unknown character escape: `f`\n  --> /tmp/tmpcua_fy2q.rs:50:18\n   |\n50 |     if s[i] == '\\f' {\n   |                  ^ unknown character escape\n   |\n   = help: for more information, visit <https://static.rust-lang.org/doc/master/reference.html#literals>\nhelp: if you meant to write a literal backslash (perhaps escaping in a regular expression), consider a raw string literal\n   |\n50 |     if s[i] == r\"\\f\" {\n   |                ~~~~~\n\nerror: unknown character escape: `b`\n  --> /tmp/tmpcua_fy2q.rs:54:18\n   |\n54 |     if s[i] == '\\b' {\n   |                  ^ unknown character escape\n   |\n   = help: for more information, visit <https://static.rust-lang.org/doc/master/reference.html#literals>\nhelp: if you meant to write a literal backslash (perhaps escaping in a regular expression), consider a raw string literal\n   |\n54 |     if s[i] == r\"\\b\" {\n   |                ~~~~~\n\nerror: unknown character escape: `a`\n  --> /tmp/tmpcua_fy2q.rs:58:18\n   |\n58 |     if s[i] == '\\a' {\n   |                  ^ unknown character escape\n   |\n   = help: for more information, visit <https://static.rust-lang.org/doc/master/reference.html#literals>\nhelp: if you meant to write a literal backslash (perhaps escaping in a regular expression), consider a raw string literal\n   |\n58 |     if s[i] == r\"\\a\" {\n   |                ~~~~~\n\nerror: this file contains an unclosed delimiter\n   --> /tmp/tmpcua_fy2q.rs:103:3\n    |\n17  | fn select_words(s: String, n: isize) -> Vec<String> {\n    |                                                     - unclosed delimiter\n...\n24  |   while i < s.len() {\n    |                 ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns a vector of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty vector.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n/// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n  let mut words = Vec::new();\n  let mut word = String::new();\n  let mut word_count = 0;\n  let mut word_index = 0;\n  let mut word_index_end = 0;\n  let mut word_index_start = 0;\n  let mut word_index_start_end = 0;\n  let mut word_index_start_end_end = 0;\n  let mut word_index_start_end_end_end = 0;\n  let mut word_index_start_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end_end_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end_end_end_end\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "error: expected `;`, found `}`\n  --> /tmp/tmpkoz4q7r5.rs:39:67\n   |\n39 |   let mut word_index_start_end_end_end_end_end_end_end_end_end_end\n   |                                                                   ^ help: add `;` here\n40 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpkoz4q7r5.rs:17:41\n   |\n17 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |    ------------                         ^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<String>`\n           found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns a vector of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty vector.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n/// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n  let mut words = Vec::new();\n  let mut word = String::new();\n  let mut word_count = 0;\n  let mut word_index = 0;\n  let mut word_index_end = 0;\n  let mut word_index_start = 0;\n  let mut word_index_start_end = 0;\n  let mut word_index_start_end_end = 0;\n  let mut word_index_start_end_end_end = 0;\n  let mut word_index_start_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end_end_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end_end_end_end\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "error: expected `;`, found `}`\n  --> /tmp/tmpkoz4q7r5.rs:39:67\n   |\n39 |   let mut word_index_start_end_end_end_end_end_end_end_end_end_end\n   |                                                                   ^ help: add `;` here\n40 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpkoz4q7r5.rs:17:41\n   |\n17 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |    ------------                         ^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<String>`\n           found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns a vector of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty vector.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n/// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n  let mut words = Vec::new();\n  let mut word = String::new();\n  let mut i = 0;\n  for i in s.iter() {\n    if i.is_space() {\n      if word.len() == n {\n        words.push(word);\n        word = String::new();\n      }\n    } else {\n      word.push_back(i.chr());\n    }\n  }\n  if word.len() == n {\n    words.push(word);\n  }\n  return words;\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "error[E0599]: no method named `iter` found for struct `String` in the current scope\n  --> /tmp/tmpgwlw8b81.rs:21:14\n   |\n21 |   for i in s.iter() {\n   |              ^^^^ method not found in `String`\n   |\nhelp: because of the in-memory representation of `&str`, to obtain an `Iterator` over each of its codepoint use method `chars`\n   |\n21 |   for i in s.chars() {\n   |              ~~~~~\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpgwlw8b81.rs:23:24\n   |\n23 |       if word.len() == n {\n   |                        ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic if the converted value doesn't fit\n   |\n23 |       if word.len() == n.try_into().unwrap() {\n   |                         ++++++++++++++++++++\n\nerror[E0599]: no method named `push_back` found for struct `String` in the current scope\n  --> /tmp/tmpgwlw8b81.rs:28:12\n   |\n28 |       word.push_back(i.chr());\n   |            ^^^^^^^^^ method not found in `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpgwlw8b81.rs:31:20\n   |\n31 |   if word.len() == n {\n   |                    ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic if the converted value doesn't fit\n   |\n31 |   if word.len() == n.try_into().unwrap() {\n   |                     ++++++++++++++++++++\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns a vector of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty vector.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n/// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n  let mut words = Vec::new();\n  let mut word = String::new();\n  let mut count = 0;\n  for (let i = 0; i < s.len(); i++) {\n    if (s[i] == ' ') {\n      if (count == n) {\n        words.push(word);\n        word = String::new();\n        count = 0;\n      }\n    } else {\n      word = word.cat(s[i]);\n      count += 1;\n    }\n  }\n  if (count == n) {\n    words.push(word);\n  }\n  return words;\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmp7y9tr_5a.rs:21:8\n   |\n21 |   for (let i = 0; i < s.len(); i++) {\n   |        ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmp7y9tr_5a.rs:21:12\n   |\n21 |   for (let i = 0; i < s.len(); i++) {\n   |           -^ expected one of `)`, `,`, `@`, or `|`\n   |           |\n   |           help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmp7y9tr_5a.rs:21:14\n   |\n21 |   for (let i = 0; i < s.len(); i++) {\n   |              ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmp7y9tr_5a.rs:21:13\n   |\n21 |   for (let i = 0; i < s.len(); i++) {\n   |             ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmp7y9tr_5a.rs:21:14\n   |\n21 |   for (let i = 0; i < s.len(); i++) {\n   |              ^ expected expression\n\nerror: aborting due to 5 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns a vector of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty vector.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n/// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n  let mut words = Vec::new();\n  let mut word = String::new();\n  let mut word_count = 0;\n  let mut word_index = 0;\n  let mut word_index_end = 0;\n  let mut word_index_start = 0;\n  let mut word_index_start_end = 0;\n  let mut word_index_start_end_end = 0;\n  let mut word_index_start_end_end_end = 0;\n  let mut word_index_start_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end_end_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end_end_end_end\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "error: expected `;`, found `}`\n  --> /tmp/tmpkoz4q7r5.rs:39:67\n   |\n39 |   let mut word_index_start_end_end_end_end_end_end_end_end_end_end\n   |                                                                   ^ help: add `;` here\n40 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpkoz4q7r5.rs:17:41\n   |\n17 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |    ------------                         ^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<String>`\n           found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns a vector of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty vector.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n/// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n  let mut words = Vec::new();\n  let mut word = String::new();\n  let mut count = 0;\n  for (let c of s) {\n    if (c == ' ') {\n      if (count == n) {\n        words.push(word);\n        word = String::new();\n        count = 0;\n      }\n    } else {\n      count += 1;\n      word.push_back(c);\n    }\n  }\n  if (count == n) {\n    words.push(word);\n  }\n  return words;\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmp9_ah3nts.rs:21:8\n   |\n21 |   for (let c of s) {\n   |        ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `c`\n  --> /tmp/tmp9_ah3nts.rs:21:12\n   |\n21 |   for (let c of s) {\n   |           -^ expected one of `)`, `,`, `@`, or `|`\n   |           |\n   |           help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `of`\n  --> /tmp/tmp9_ah3nts.rs:21:14\n   |\n21 |   for (let c of s) {\n   |             -^^ expected one of `)`, `,`, `@`, or `|`\n   |             |\n   |             help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `s`\n  --> /tmp/tmp9_ah3nts.rs:21:17\n   |\n21 |   for (let c of s) {\n   |                -^ expected one of `)`, `,`, `@`, or `|`\n   |                |\n   |                help: missing `,`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmp9_ah3nts.rs:21:19\n   |\n21 |   for (let c of s) {\n   |                   ^ help: try adding `in` here\n\nerror: expected `{`, found keyword `if`\n  --> /tmp/tmp9_ah3nts.rs:33:3\n   |\n33 |   if (count == n) {\n   |   ^^ expected `{`\n   |\nhelp: try placing this code inside a block\n   |\n33 ~   { if (count == n) {\n34 |     words.push(word);\n35 ~   } }\n   |\n\nerror: aborting due to 6 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns a vector of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty vector.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n/// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n  let mut words: Vec<String> = Vec::new();\n  let mut word: String = String::new();\n  let mut word_count: isize = 0;\n  let mut word_index: isize = 0;\n  let mut word_index_end: isize = 0;\n  let mut word_index_start: isize = 0;\n  let mut word_index_start_end: isize = 0;\n  let mut word_index_start_end_end: isize = 0;\n  let mut word_index_start_end_end_end: isize = 0;\n  let mut word_index_start_end_end_end_end: isize = 0;\n  let mut word_index_start_end_end_end_end_end: isize = 0;\n  let mut word_index_start_end_end_end_end_end_end: isize = 0;\n  let mut word_index_start_end_end_end_end_end_end_end: isize = 0;\n  let mut word_index_start_end_end_end_end_end_end_end_end: isize = 0;\n  let mut word_index_start_end_end_end_end_end_end_end_end_end: isize = 0;\n  let mut word_index_start_end_end_end_end_end_end_end_end_end_end: isize = 0;\n  let mut word_index_start_end_end_end_end_end_end_end_end_end_end_end: isize = 0;\n  let mut word_index_start_end_end_end_end_end_end_end_end_end_end_end_end: isize = 0;\n  let mut word_index_start_end_end_end_end_end_end_end_end_end_end_end_end_end: isize = 0;\n  let mut word_index_start_end_end_end_end_end_end_end_end_end_end_end_end_end_end: isize = 0;\n  let mut word_index_start_\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "error: expected `;`, found `}`\n  --> /tmp/tmpy4qn90wq.rs:38:28\n   |\n38 |   let mut word_index_start_\n   |                            ^ help: add `;` here\n39 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpy4qn90wq.rs:17:41\n   |\n17 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |    ------------                         ^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<String>`\n           found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns a vector of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty vector.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n/// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut words: Vec<String> = Vec::new();\n    let mut word: String = String::new();\n    let mut count: isize = 0;\n    for i in s.chars() {\n        if count == n {\n            words.push(word);\n            word = String::new();\n            count = 0;\n        }\n        if s[i] == ' ' {\n            continue;\n        }\n        if s[i] == ' ' {\n            continue;\n        }\n        if s[i] == ' ' {\n            continue;\n        }\n        if s[i] == ' ' {\n            continue;\n        }\n        if s[i] == ' ' {\n            continue;\n        }\n        if s[i] == ' ' {\n            continue;\n        }\n        if s[i] == ' ' {\n            continue;\n        }\n        if s[i] == ' ' {\n            continue;\n        }\n        if s[i] == ' ' {\n            continue;\n        }\n        if s[i] == ' ' {\n            continue;\n        }\n        if s[i] == ' ' {\n            continue;\n        }\n        if s[i] == ' ' {\n            continue;\n        }\n        if s[i] == ' ' {\n            continue;\n        }\n        if s[i] == ' ' {\n            continue;\n        }\n        if s[i] == ' ' {\n            continue;\n        }\n        if s[i] == ' ' {\n            continue;\n        }\n        if s[i] == ' ' {\n            continue;\n        }\n        if s[i] == ' ' {\n            continue;\n        }\n        if s[i] == ' ' {\n            continue;\n        }\n        if s[i] == ' ' {\n            continue;\n        }\n        if s[i] == ' ' {\n            continue;\n        }\n        if s[i] == ' ' {\n            continue;\n        }\n        if s[i] == ' ' {\n            continue;\n        }\n        if s[i] == ' ' {\n            continue;\n        }\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "error: this file contains an unclosed delimiter\n   --> /tmp/tmph7tmhgd4.rs:110:3\n    |\n17  | fn select_words(s: String, n: isize) -> Vec<String> {\n    |                                                     - unclosed delimiter\n...\n21  |     for i in s.chars() {\n    |                        - this delimiter might not be properly closed...\n...\n99  | }\n    | - ...as it matches this but it has different indentation\n...\n110 | }\n    |   ^\n\nerror[E0277]: the type `String` cannot be indexed by `char`\n  --> /tmp/tmph7tmhgd4.rs:27:12\n   |\n27 |         if s[i] == ' ' {\n   |            ^^^^ `String` cannot be indexed by `char`\n   |\n   = help: the trait `Index<char>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `char`\n  --> /tmp/tmph7tmhgd4.rs:30:12\n   |\n30 |         if s[i] == ' ' {\n   |            ^^^^ `String` cannot be indexed by `char`\n   |\n   = help: the trait `Index<char>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `char`\n  --> /tmp/tmph7tmhgd4.rs:33:12\n   |\n33 |         if s[i] == ' ' {\n   |            ^^^^ `String` cannot be indexed by `char`\n   |\n   = help: the trait `Index<char>` is not implemented for `String`\n   = help: the following other types",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns a vector of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty vector.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n/// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n  let mut words = Vec::new();\n  let mut word = String::new();\n  let mut i = 0;\n  let mut j = 0;\n  let mut k = 0;\n  let mut count = 0;\n  let mut count_end = 0;\n  let mut count_start = 0;\n  let mut count_end_start = 0;\n  let mut count_end_start_end = 0;\n  let mut count_end_start_end_start = 0;\n  let mut count_end_start_end_start_end = 0;\n  let mut count_end_start_end_start_end_start = 0;\n  let mut count_end_start_end_start_end_start_end = 0;\n  let mut count_end_start_end_start_end_start_end_start = 0;\n  let mut count_end_start_end_start_end_start_end_start_end = 0;\n  let mut count_end_start_end_start_end_start_end_start_end_start = 0;\n  let mut count_end_start_end_start_end_start_end_start_end_start_end = 0;\n  let mut count_end_start_end_start_end_start_end_start_end_start_end_start = 0;\n  let mut count_end_start_end_start_end_start_end_start_end_start_end_start_end = 0;\n  let mut count_end_start_end_start_end_start_end_start_end_start_end_start_end_start = 0;\n  let mut count_end_start_end_start_end_start_end_start_end_start_end_start_end_start_end = 0;\n  let mut count_end_start_end_start_end_start_end_start_end_start_end_start_end_start_end_start = 0;\n  let mut count_end_start_end_start_end_start_end_start_end_start_end_start_end_start_end_start_end = 0;\n  let mut count_end_start\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "error: expected `;`, found `}`\n  --> /tmp/tmp9lrjhwcy.rs:42:26\n   |\n42 |   let mut count_end_start\n   |                          ^ help: add `;` here\n43 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9lrjhwcy.rs:17:41\n   |\n17 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |    ------------                         ^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<String>`\n           found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns a vector of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty vector.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n/// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut words = Vec::new();\n    let mut word = String::new();\n    let mut last_consonant = String::new();\n    let mut consonant_count = 0;\n    let mut consonant_index = 0;\n    let mut consonant_index_end = 0;\n    let mut consonant_index_start = 0;\n    let mut consonant_index_start_end = 0;\n    let mut consonant_index_start_start = 0;\n    let mut consonant_index_start_start_end = 0;\n    let mut consonant_index_start_start_start = 0;\n    let mut consonant_index_start_start_start_end = 0;\n    let mut consonant_index_start_start_start_start = 0;\n    let mut consonant_index_start_start_start_start_end = 0;\n    let mut consonant_index_start_start_start_start_start = 0;\n    let mut consonant_index_start_start_start_start_start_end = 0;\n    let mut consonant_index_start_start_start_start_start_start = 0;\n    let mut consonant_index_start_start_start_start_start_start_end = 0;\n    let mut consonant_index_start_start_start_start_start_start_start = 0;\n    let mut consonant_index_start_start_start_start_start_start_start_end = 0;\n    let mut consonant_index_start_start_start_start_start_start_start_start = 0;\n    let mut consonant_index_start_start_start_start_start_start_start_start_end = 0;\n    let mut consonant_index_start_start_start_start_start_start_start_start_start = 0;\n    let mut consonant_index_start_start_start_start_start_start_start_start_start_end = 0;\n    let mut consonant_index_start_start_start_start_start_start_start_start_start_start = 0;\n    let mut consonant_index_start_start_start_start_\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "error: expected `;`, found `}`\n  --> /tmp/tmpkgog9h03.rs:43:53\n   |\n43 |     let mut consonant_index_start_start_start_start_\n   |                                                     ^ help: add `;` here\n44 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpkgog9h03.rs:17:41\n   |\n17 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |    ------------                         ^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<String>`\n           found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns a vector of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty vector.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n/// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n  let mut words = Vec::new();\n  let mut word = String::new();\n  let mut word_count = 0;\n  let mut word_index = 0;\n  let mut word_index_end = 0;\n  let mut word_index_start = 0;\n  let mut word_index_start_end = 0;\n  let mut word_index_start_end_end = 0;\n  let mut word_index_start_end_end_end = 0;\n  let mut word_index_start_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end_end_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end_end_end_end\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "error: expected `;`, found `}`\n  --> /tmp/tmpkoz4q7r5.rs:39:67\n   |\n39 |   let mut word_index_start_end_end_end_end_end_end_end_end_end_end\n   |                                                                   ^ help: add `;` here\n40 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpkoz4q7r5.rs:17:41\n   |\n17 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |    ------------                         ^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<String>`\n           found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns a vector of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty vector.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n/// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n  let mut words = Vec::new();\n  let mut word = String::new();\n  let mut count = 0;\n  let mut i = 0;\n  for i < s.len() {\n    if s[i] == ' ' {\n      if count == n {\n        words.push(word);\n        word = String::new();\n        count = 0;\n      }\n      i++;\n    } else {\n      word.push_back(s[i]);\n      count++;\n      i++;\n    }\n  }\n  if count == n {\n    words.push(word);\n  }\n  return words;\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "error: missing `in` in `for` loop\n  --> /tmp/tmpbbum0t3e.rs:22:8\n   |\n22 |   for i < s.len() {\n   |        ^ help: try adding `in` here\n\nerror: expected one of `!`, `(`, `+`, `::`, `<`, `>`, or `as`, found `.`\n  --> /tmp/tmpbbum0t3e.rs:22:12\n   |\n22 |   for i < s.len() {\n   |            ^ expected one of 7 possible tokens\n\nerror: aborting due to 2 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns a vector of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty vector.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n/// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut words: Vec<String> = Vec::new();\n    let mut word: String = String::new();\n    let mut count: usize = 0;\n    for i in s.chars() {\n        if count == n {\n            words.push(word);\n            word = String::new();\n            count = 0;\n        }\n        if s[i] == ' ' {\n            continue;\n        }\n        if s[i] == '\\n' {\n            continue;\n        }\n        if s[i] == '\\r' {\n            continue;\n        }\n        if s[i] == '\\t' {\n            continue;\n        }\n        if s[i] == '\\v' {\n            continue;\n        }\n        if s[i] == '\\f' {\n            continue;\n        }\n        if s[i] == '\\b' {\n            continue;\n        }\n        if s[i] == '\\a' {\n            continue;\n        }\n        if s[i] == '\\0' {\n            continue;\n        }\n        if s[i] == '\\x0b' {\n            continue;\n        }\n        if s[i] == '\\x0c' {\n            continue;\n        }\n        if s[i] == '\\x0e' {\n            continue;\n        }\n        if s[i] == '\\x0f' {\n            continue;\n        }\n        if s[i] == '\\x1b' {\n            continue;\n        }\n        if s[i] == '\\x1c' {\n            continue;\n        }\n        if s[i] == '\\x1d' {\n            continue;\n        }\n        if s[i] == '\\x1e' {\n            continue;\n        }\n        if s[i] == '\\x1f' {\n            continue;\n        }\n        if s[i] == '\\x7f' {\n            continue;\n        }\n        if s[i] == '\\x80' {\n            continue;\n        }\n        if s[i] == '\\x81'\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "error: unknown character escape: `v`\n  --> /tmp/tmpupnu7t27.rs:39:22\n   |\n39 |         if s[i] == '\\v' {\n   |                      ^ unknown character escape\n   |\n   = help: for more information, visit <https://static.rust-lang.org/doc/master/reference.html#literals>\nhelp: if you meant to write a literal backslash (perhaps escaping in a regular expression), consider a raw string literal\n   |\n39 |         if s[i] == r\"\\v\" {\n   |                    ~~~~~\n\nerror: unknown character escape: `f`\n  --> /tmp/tmpupnu7t27.rs:42:22\n   |\n42 |         if s[i] == '\\f' {\n   |                      ^ unknown character escape\n   |\n   = help: for more information, visit <https://static.rust-lang.org/doc/master/reference.html#literals>\nhelp: if you meant to write a literal backslash (perhaps escaping in a regular expression), consider a raw string literal\n   |\n42 |         if s[i] == r\"\\f\" {\n   |                    ~~~~~\n\nerror: unknown character escape: `b`\n  --> /tmp/tmpupnu7t27.rs:45:22\n   |\n45 |         if s[i] == '\\b' {\n   |                      ^ unknown character escape\n   |\n   = help: for more information, visit <https://static.rust-lang.org/doc/master/reference.html#literals>\nhelp: if you meant to write a literal backslash (perhaps escaping in a regular expression), consider a raw string literal\n   |\n45 |         if s[i] == r\"\\b\" {\n   |                    ~~~~~\n\nerror: unknown character escape: `a`\n  --> /tmp/tmpupnu7t27.rs:48:22\n   |\n48 |         if s[i] == '\\a' {\n   |                      ^ unknown character escape\n   |\n   = help: for more information, visit <https://static.rust-lang.org/doc/master/reference.html#literals>\nhelp: if you meant to write a literal backslash (perhaps escaping in a regular expression), consider a raw string literal\n   |\n48 |         if s[i] == r\"\\a\" {\n   |                    ~~~~~\n\nerror: out of range hex escape\n  --> /tmp/tmpupnu7t27.rs:84:21\n   |\n84 |         if s[i] == '\\x80' {\n   |                     ^^^^ must be a character in the range [\\x00-\\x7f]\n\nerror: out of range hex escape\n  --> /t",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns a vector of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty vector.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n/// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n  let mut words = Vec::new();\n  let mut word = String::new();\n  let mut i = 0;\n  let mut j = 0;\n  let mut count = 0;\n  let mut count_end = 0;\n  while i < s.len() {\n    if s[i] == ' ' {\n      if count == n {\n        words.push(word);\n        word = String::new();\n        count = 0;\n        count_end = 0;\n      } else {\n        count_end = i;\n      }\n    } else {\n      if count == n {\n        words.push(word);\n        word = String::new();\n        count = 0;\n        count_end = 0;\n      }\n      if count == 0 {\n        word = word.concat(s[i]);\n        count++;\n      } else {\n        if count == n {\n          words.push(word);\n          word = String::new();\n          count = 0;\n          count_end = 0;\n        } else {\n          word = word.concat(s[i]);\n          count++;\n        }\n      }\n    }\n    i++;\n  }\n  if count == n {\n    words.push(word);\n  }\n  return words;\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "error: Rust has no postfix increment operator\n  --> /tmp/tmpw5gii06d.rs:43:14\n   |\n43 |         count++;\n   |              ^^ not a valid postfix operator\n   |\nhelp: use `+= 1` instead\n   |\n43 |         { let tmp = count; count += 1; tmp };\n   |         +++++++++++      ~~~~~~~~~~~~~~~~~~~\n43 -         count++;\n43 +         count += 1;\n   | \n\nerror: Rust has no postfix increment operator\n  --> /tmp/tmpw5gii06d.rs:52:16\n   |\n52 |           count++;\n   |                ^^ not a valid postfix operator\n   |\nhelp: use `+= 1` instead\n   |\n52 |           { let tmp = count; count += 1; tmp };\n   |           +++++++++++      ~~~~~~~~~~~~~~~~~~~\n52 -           count++;\n52 +           count += 1;\n   | \n\nerror: Rust has no postfix increment operator\n  --> /tmp/tmpw5gii06d.rs:56:6\n   |\n56 |     i++;\n   |      ^^ not a valid postfix operator\n   |\nhelp: use `+= 1` instead\n   |\n56 |     { let tmp = i; i += 1; tmp };\n   |     +++++++++++  ~~~~~~~~~~~~~~~\n56 -     i++;\n56 +     i += 1;\n   | \n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpw5gii06d.rs:25:8\n   |\n25 |     if s[i] == ' ' {\n   |        ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0599]: no method named `concat` found for struct `String` in the current scope\n  --> /tmp/tmpw5gii06d.rs:42:21\n   |\n42 |         word = word.concat(s[i]);\n   |                     ^^^^^^ method not found in `String`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpw5gii06d.rs:42:28\n   |\n42 |         word = word.concat(s[i]);\n   |                            ^^^^ `String",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns a vector of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty vector.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n/// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut words = Vec::new();\n    let mut word = String::new();\n    let mut word_count = 0;\n    let mut word_index = 0;\n    let mut word_index_end = 0;\n    let mut word_index_start = 0;\n    let mut word_index_start_end = 0;\n    let mut word_index_start_end_end = 0;\n    let mut word_index_start_end_end_end = 0;\n    let mut word_index_start_end_end_end_end = 0;\n    let mut word_index_start_end_end_end_end_end = 0;\n    let mut word_index_start_end_end_end_end_end_end = 0;\n    let mut word_index_start_end_end_end_end_end_end_end = 0;\n    let mut word_index_start_end_end_end_end_end_end_end_end = 0;\n    let mut word_index_start_end_end_end_end_end_end_end_end_end = 0;\n    let mut word_index_start_end_end_end_end_end_end_end_end_end_end = 0;\n    let mut word_index_start_end_end_end_end_end_end_end_end_end_end_end = 0;\n    let mut word_index_start_end_end_end_end_end_end_end_end_end_end_end_end = 0;\n    let mut word_index_start_end_end_end_end_end_end_end_end_end_end_end_end_end = 0;\n    let mut word_index_start_end_end_end_end_end_end_end_end_end_end_end_end_end_end = 0;\n    let mut word_index_start_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end = 0;\n    let mut word_index_start_end_end_end_end_end_end_end_end_end_end\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "error: expected `;`, found `}`\n  --> /tmp/tmpwkh6xpwz.rs:39:69\n   |\n39 |     let mut word_index_start_end_end_end_end_end_end_end_end_end_end\n   |                                                                     ^ help: add `;` here\n40 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpwkh6xpwz.rs:17:41\n   |\n17 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |    ------------                         ^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<String>`\n           found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns a vector of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty vector.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n/// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n  let mut words = Vec::new();\n  let mut word = String::new();\n  let mut word_count = 0;\n  let mut word_index = 0;\n  let mut word_index_end = 0;\n  let mut word_index_start = 0;\n  let mut word_index_start_end = 0;\n  let mut word_index_start_end_end = 0;\n  let mut word_index_start_end_end_end = 0;\n  let mut word_index_start_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end_end_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end_end_end_end\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "error: expected `;`, found `}`\n  --> /tmp/tmpkoz4q7r5.rs:39:67\n   |\n39 |   let mut word_index_start_end_end_end_end_end_end_end_end_end_end\n   |                                                                   ^ help: add `;` here\n40 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpkoz4q7r5.rs:17:41\n   |\n17 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |    ------------                         ^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<String>`\n           found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns a vector of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty vector.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n/// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n  let mut words = Vec::new();\n  let mut word = String::new();\n  let mut count = 0;\n  for i in s.chars() {\n    if count == n {\n      words.push(word);\n      word = String::new();\n      count = 0;\n    }\n    if s[i] == ' ' {\n      if count > 0 {\n        words.push(word);\n        word = String::new();\n        count = 0;\n      }\n    } else {\n      count += 1;\n      word.push_back(s[i]);\n    }\n  }\n  if count > 0 {\n    words.push(word);\n  }\n  return words;\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "error[E0277]: the type `String` cannot be indexed by `char`\n  --> /tmp/tmpmji10jmg.rs:27:8\n   |\n27 |     if s[i] == ' ' {\n   |        ^^^^ `String` cannot be indexed by `char`\n   |\n   = help: the trait `Index<char>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0599]: no method named `push_back` found for struct `String` in the current scope\n  --> /tmp/tmpmji10jmg.rs:35:12\n   |\n35 |       word.push_back(s[i]);\n   |            ^^^^^^^^^ method not found in `String`\n\nerror[E0277]: the type `String` cannot be indexed by `char`\n  --> /tmp/tmpmji10jmg.rs:35:22\n   |\n35 |       word.push_back(s[i]);\n   |                      ^^^^ `String` cannot be indexed by `char`\n   |\n   = help: the trait `Index<char>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0599.\nFor more information about an error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns a vector of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty vector.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n/// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n  let mut words = Vec::new();\n  let mut word = String::new();\n  let mut count = 0;\n  for (let i = 0; i < s.len(); i++) {\n    if (s[i] == ' ') {\n      if (count == n) {\n        words.push(word);\n        word = String::new();\n        count = 0;\n      }\n    } else {\n      if (count < n) {\n        word = word.cat(s[i]);\n        count += 1;\n      }\n    }\n  }\n  if (count == n) {\n    words.push(word);\n  }\n  return words;\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmpdaiurs5f.rs:21:8\n   |\n21 |   for (let i = 0; i < s.len(); i++) {\n   |        ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmpdaiurs5f.rs:21:12\n   |\n21 |   for (let i = 0; i < s.len(); i++) {\n   |           -^ expected one of `)`, `,`, `@`, or `|`\n   |           |\n   |           help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmpdaiurs5f.rs:21:14\n   |\n21 |   for (let i = 0; i < s.len(); i++) {\n   |              ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmpdaiurs5f.rs:21:13\n   |\n21 |   for (let i = 0; i < s.len(); i++) {\n   |             ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmpdaiurs5f.rs:21:14\n   |\n21 |   for (let i = 0; i < s.len(); i++) {\n   |              ^ expected expression\n\nerror: aborting due to 5 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns a vector of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty vector.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n/// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n  let mut result = Vec::new();\n  let mut word = String::new();\n  let mut count = 0;\n  for (let i = 0; i < s.len(); i++) {\n    if (s[i] == ' ') {\n      if (count == n) {\n        result.push(word);\n        word = String::new();\n        count = 0;\n      }\n    } else {\n      word += s[i];\n      count += 1;\n    }\n  }\n  if (count == n) {\n    result.push(word);\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmpc8pj2kwx.rs:21:8\n   |\n21 |   for (let i = 0; i < s.len(); i++) {\n   |        ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmpc8pj2kwx.rs:21:12\n   |\n21 |   for (let i = 0; i < s.len(); i++) {\n   |           -^ expected one of `)`, `,`, `@`, or `|`\n   |           |\n   |           help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmpc8pj2kwx.rs:21:14\n   |\n21 |   for (let i = 0; i < s.len(); i++) {\n   |              ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmpc8pj2kwx.rs:21:13\n   |\n21 |   for (let i = 0; i < s.len(); i++) {\n   |             ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmpc8pj2kwx.rs:21:14\n   |\n21 |   for (let i = 0; i < s.len(); i++) {\n   |              ^ expected expression\n\nerror: aborting due to 5 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns a vector of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty vector.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n/// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n  let mut words = Vec::new();\n  let mut word = String::new();\n  let mut last_consonant = String::new();\n  let mut consonant_count = 0;\n  let mut consonant_index = 0;\n  let mut consonant_index_prev = 0;\n  let mut consonant_index_next = 0;\n  let mut consonant_index_next_prev = 0;\n  let mut consonant_index_prev_next = 0;\n  let mut consonant_index_next_next_prev = 0;\n  let mut consonant_index_next_next_next_prev = 0;\n  let mut consonant_index_next_next_next_next_prev = 0;\n  let mut consonant_index_next_next_next_next_next_prev = 0;\n  let mut consonant_index_next_next_next_next_next_next_prev = 0;\n  let mut consonant_index_next_next_next_next_next_next_next_prev = 0;\n  let mut consonant_index_next_next_next_next_next_next_next_next_prev = 0;\n  let mut consonant_index_next_next_next_next_next_next_next_next_next_prev = 0;\n  let mut consonant_index_next_next_next_next_next_next_next_next_next_next_prev = 0;\n  let mut consonant_index_next_next_next_next_next_next_next_next_next_next_next_prev = 0;\n  let mut consonant_index_next_next_next_next_next_next_next_next_next_next_next_next_prev = 0;\n  let mut consonant_index_next_next_next_next_next_next_next_next_next_next_next_next_next_prev = 0;\n  let mut consonant_index_next_next_next_next_next_next_next_next_next_next_next_next_next_next_prev = 0;\n  let mut consonant_index_next_next_next_next_next_next_next_next\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "error: expected `;`, found `}`\n  --> /tmp/tmpd42i684z.rs:40:66\n   |\n40 |   let mut consonant_index_next_next_next_next_next_next_next_next\n   |                                                                  ^ help: add `;` here\n41 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpd42i684z.rs:17:41\n   |\n17 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |    ------------                         ^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<String>`\n           found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns a vector of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty vector.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n/// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n  let mut words = Vec::new();\n  let mut word = String::new();\n  let mut consonants = 0;\n  let mut consonant_index = 0;\n  let mut consonant_count = 0;\n  let mut consonant_count_index = 0;\n  let mut consonant_count_count = 0;\n  let mut consonant_count_count_index = 0;\n  let mut consonant_count_count_count = 0;\n  let mut consonant_count_count_count_index = 0;\n  let mut consonant_count_count_count_count = 0;\n  let mut consonant_count_count_count_count_index = 0;\n  let mut consonant_count_count_count_count_count = 0;\n  let mut consonant_count_count_count_count_count_index = 0;\n  let mut consonant_count_count_count_count_count_count = 0;\n  let mut consonant_count_count_count_count_count_count_index = 0;\n  let mut consonant_count_count_count_count_count_count_count = 0;\n  let mut consonant_count_count_count_count_count_count_count_index = 0;\n  let mut consonant_count_count_count_count_count_count_count_count = 0;\n  let mut consonant_count_count_count_count_count_count_count_count_index = 0;\n  let mut consonant_count_count_count_count_count_count_count_count_count = 0;\n  let mut consonant_count_count_count_count_count_count_count_count_count_index = 0;\n  let mut consonant_count_count_count_count_count_count_count_count_count_count = 0;\n  let mut consonant_count_count_count_count_count_count_count_count_count_count_index = 0;\n  let mut consonant_count_count_count_count_count_count_count_count_count_count_count = 0;\n  let mut consonant_count_count_count_count_count_count_count_count\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "error: expected `;`, found `}`\n  --> /tmp/tmp_jj1vug4.rs:43:68\n   |\n43 |   let mut consonant_count_count_count_count_count_count_count_count\n   |                                                                    ^ help: add `;` here\n44 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp_jj1vug4.rs:17:41\n   |\n17 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |    ------------                         ^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<String>`\n           found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns a vector of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty vector.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n/// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut result = Vec::new();\n    let mut word = String::new();\n    let mut count = 0;\n    for i in s.chars() {\n        if count == n {\n            result.push(word);\n            word = String::new();\n            count = 0;\n        }\n        if !is_consonant(i) {\n            word += String::from(i);\n            count += 1;\n        }\n    }\n    if count == n {\n        result.push(word);\n    }\n    return result;\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "error[E0425]: cannot find function `is_consonant` in this scope\n  --> /tmp/tmp2ahhuwue.rs:27:13\n   |\n27 |         if !is_consonant(i) {\n   |             ^^^^^^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2ahhuwue.rs:28:21\n   |\n28 |             word += String::from(i);\n   |                     ^^^^^^^^^^^^^^^\n   |                     |\n   |                     expected `&str`, found struct `String`\n   |                     help: consider borrowing here: `&String::from(i)`\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0425.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns a vector of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty vector.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n/// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n  let mut words = Vec::new();\n  let mut word = String::new();\n  let mut word_count = 0;\n  for (let i = 0; i < s.len(); i++) {\n    if (s[i] == ' ') {\n      if (word_count == n) {\n        words.push(word);\n        word = String::new();\n        word_count = 0;\n      }\n    } else {\n      if (word_count < n) {\n        word += s[i];\n        word_count += 1;\n      }\n    }\n  }\n  if (word_count == n) {\n    words.push(word);\n  }\n  return words;\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmp470dasi7.rs:21:8\n   |\n21 |   for (let i = 0; i < s.len(); i++) {\n   |        ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmp470dasi7.rs:21:12\n   |\n21 |   for (let i = 0; i < s.len(); i++) {\n   |           -^ expected one of `)`, `,`, `@`, or `|`\n   |           |\n   |           help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmp470dasi7.rs:21:14\n   |\n21 |   for (let i = 0; i < s.len(); i++) {\n   |              ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmp470dasi7.rs:21:13\n   |\n21 |   for (let i = 0; i < s.len(); i++) {\n   |             ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmp470dasi7.rs:21:14\n   |\n21 |   for (let i = 0; i < s.len(); i++) {\n   |              ^ expected expression\n\nerror: aborting due to 5 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns a vector of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty vector.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n/// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n  let mut words = Vec::new();\n  let mut word = String::new();\n  let mut count = 0;\n  let mut i = 0;\n  while i < s.len() {\n    if s[i] == ' ' {\n      if count == n {\n        words.push(word);\n        word = String::new();\n        count = 0;\n      }\n      i += 1;\n    } else if s[i] == '\\n' {\n      i += 1;\n    } else {\n      word.push_back(s[i]);\n      count += 1;\n      i += 1;\n    }\n  }\n  if count == n {\n    words.push(word);\n  }\n  return words;\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp31q03486.rs:23:8\n   |\n23 |     if s[i] == ' ' {\n   |        ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp31q03486.rs:30:15\n   |\n30 |     } else if s[i] == '\\n' {\n   |               ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0599]: no method named `push_back` found for struct `String` in the current scope\n  --> /tmp/tmp31q03486.rs:33:12\n   |\n33 |       word.push_back(s[i]);\n   |            ^^^^^^^^^ method not found in `String`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp31q03486.rs:33:22\n   |\n33 |       word.push_back(s[i]);\n   |                      ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as In",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns a vector of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty vector.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n/// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut words: Vec<String> = Vec::new();\n    let mut word: String = String::new();\n    let mut count: isize = 0;\n    let mut start: isize = 0;\n    let mut end: isize = 0;\n    let mut i: isize = 0;\n    let mut j: isize = 0;\n    let mut k: isize = 0;\n    let mut l: isize = 0;\n    let mut m: isize = 0;\n    let mut n: isize = 0;\n    let mut o: isize = 0;\n    let mut p: isize = 0;\n    let mut q: isize = 0;\n    let mut r: isize = 0;\n    let mut s: isize = 0;\n    let mut t: isize = 0;\n    let mut u: isize = 0;\n    let mut v: isize = 0;\n    let mut w: isize = 0;\n    let mut x: isize = 0;\n    let mut y: isize = 0;\n    let mut z: isize = 0;\n    let mut c: isize = 0;\n    let mut d: isize = 0;\n    let mut e: isize = 0;\n    let mut f: isize = 0;\n    let mut g: isize = 0;\n    let mut h: isize = 0;\n    let mut i: isize = 0;\n    let mut j: isize = 0;\n    let mut k: isize = 0;\n    let mut l: isize = 0;\n    let mut m: isize = 0;\n    let mut n: isize = 0;\n    let mut o: isize = 0;\n    let mut p: isize = 0;\n    let mut q: isize = 0;\n    let mut r: isize = 0;\n    let mut s: isize = 0;\n    let mut t: isize = 0;\n    let mut u: isize = 0;\n    let mut v: isize = 0;\n    let mut w: isize = 0;\n    let mut x: isize = 0;\n    let mut y: isize = 0;\n    \n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "error[E0308]: mismatched types\n  --> /tmp/tmpxtn7awpa.rs:17:41\n   |\n17 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |    ------------                         ^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<String>`\n           found unit type `()`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns a vector of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty vector.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n/// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n  let mut words = Vec::new();\n  let mut word = String::new();\n  let mut count = 0;\n  let mut i = 0;\n  while i < s.len() {\n    if s[i] == ' ' {\n      if count == n {\n        words.push(word);\n        word = String::new();\n        count = 0;\n      }\n      i++;\n    } else {\n      word.push_back(s[i]);\n      count++;\n      i++;\n    }\n  }\n  if count == n {\n    words.push(word);\n  }\n  return words;\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "error: Rust has no postfix increment operator\n  --> /tmp/tmpsl0og402.rs:29:8\n   |\n29 |       i++;\n   |        ^^ not a valid postfix operator\n   |\nhelp: use `+= 1` instead\n   |\n29 |       { let tmp = i; i += 1; tmp };\n   |       +++++++++++  ~~~~~~~~~~~~~~~\n29 -       i++;\n29 +       i += 1;\n   | \n\nerror: Rust has no postfix increment operator\n  --> /tmp/tmpsl0og402.rs:32:12\n   |\n32 |       count++;\n   |            ^^ not a valid postfix operator\n   |\nhelp: use `+= 1` instead\n   |\n32 |       { let tmp = count; count += 1; tmp };\n   |       +++++++++++      ~~~~~~~~~~~~~~~~~~~\n32 -       count++;\n32 +       count += 1;\n   | \n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpsl0og402.rs:23:8\n   |\n23 |     if s[i] == ' ' {\n   |        ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0599]: no method named `push_back` found for struct `String` in the current scope\n  --> /tmp/tmpsl0og402.rs:31:12\n   |\n31 |       word.push_back(s[i]);\n   |            ^^^^^^^^^ method not found in `String`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpsl0og402.rs:31:22\n   |\n31 |       word.push_back(s[i]);\n   |                      ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <S",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns a vector of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty vector.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n/// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n  let mut words = Vec::new();\n  let mut word = String::new();\n  let mut word_count = 0;\n  let mut word_index = 0;\n  let mut word_index_end = 0;\n  let mut word_index_start = 0;\n  let mut word_index_start_end = 0;\n  let mut word_index_start_start = 0;\n  let mut word_index_start_start_end = 0;\n  let mut word_index_start_start_start = 0;\n  let mut word_index_start_start_start_end = 0;\n  let mut word_index_start_start_start_start = 0;\n  let mut word_index_start_start_start_start_end = 0;\n  let mut word_index_start_start_start_start_start = 0;\n  let mut word_index_start_start_start_start_start_end = 0;\n  let mut word_index_start_start_start_start_start_start = 0;\n  let mut word_index_start_start_start_start_start_start_end = 0;\n  let mut word_index_start_start_start_start_start_start_start = 0;\n  let mut word_index_start_start_start_start_start_start_start_end = 0;\n  let mut word_index_start_start_start_start_start_start_start_start = 0;\n  let mut word_index_start_start_start_start_start_start_start_start_end = 0;\n  let mut word_index_start_start_start_start_start_start_start_start_start = 0;\n  let mut word_index_start_start_start_start_start_start_start_start_start_end = 0;\n  let mut word_index_start_start_start_start_start_start_start_start_start_start = 0;\n  let mut word_index_start_start_start_start_start_start_start_start_start_start_end = 0;\n  let mut word_index_start_start_start_start_start_start_start\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "error: expected `;`, found `}`\n  --> /tmp/tmpkpbme8fs.rs:43:63\n   |\n43 |   let mut word_index_start_start_start_start_start_start_start\n   |                                                               ^ help: add `;` here\n44 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpkpbme8fs.rs:17:41\n   |\n17 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |    ------------                         ^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<String>`\n           found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns a vector of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty vector.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n/// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut words: Vec<String> = Vec::new();\n    let mut word: String = String::from(\"\");\n    let mut count: isize = 0;\n    for i in s.chars() {\n        if count == n {\n            words.push(word);\n            word = String::from(\"\");\n            count = 0;\n        }\n        if s[i] == ' ' {\n            continue;\n        }\n        if s[i] == ' ' {\n            continue;\n        }\n        if s[i] == ' ' {\n            continue;\n        }\n        if s[i] == ' ' {\n            continue;\n        }\n        if s[i] == ' ' {\n            continue;\n        }\n        if s[i] == ' ' {\n            continue;\n        }\n        if s[i] == ' ' {\n            continue;\n        }\n        if s[i] == ' ' {\n            continue;\n        }\n        if s[i] == ' ' {\n            continue;\n        }\n        if s[i] == ' ' {\n            continue;\n        }\n        if s[i] == ' ' {\n            continue;\n        }\n        if s[i] == ' ' {\n            continue;\n        }\n        if s[i] == ' ' {\n            continue;\n        }\n        if s[i] == ' ' {\n            continue;\n        }\n        if s[i] == ' ' {\n            continue;\n        }\n        if s[i] == ' ' {\n            continue;\n        }\n        if s[i] == ' ' {\n            continue;\n        }\n        if s[i] == ' ' {\n            continue;\n        }\n        if s[i] == ' ' {\n            continue;\n        }\n        if s[i] == ' ' {\n            continue;\n        }\n        if s[i] == ' ' {\n            continue;\n        }\n        if s[i] == ' ' {\n            continue;\n        }\n        if s[i] == ' ' {\n            continue;\n        }\n        if s[i] == ' ' {\n            continue;\n\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "error: this file contains an unclosed delimiter\n   --> /tmp/tmpsiuc54ve.rs:110:3\n    |\n17  | fn select_words(s: String, n: isize) -> Vec<String> {\n    |                                                     - unclosed delimiter\n...\n21  |     for i in s.chars() {\n    |                        - unclosed delimiter\n...\n96  |         if s[i] == ' ' {\n    |                        - this delimiter might not be properly closed...\n...\n99  | }\n    | - ...as it matches this but it has different indentation\n...\n110 | }\n    |   ^\n\nerror[E0277]: the type `String` cannot be indexed by `char`\n  --> /tmp/tmpsiuc54ve.rs:27:12\n   |\n27 |         if s[i] == ' ' {\n   |            ^^^^ `String` cannot be indexed by `char`\n   |\n   = help: the trait `Index<char>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `char`\n  --> /tmp/tmpsiuc54ve.rs:30:12\n   |\n30 |         if s[i] == ' ' {\n   |            ^^^^ `String` cannot be indexed by `char`\n   |\n   = help: the trait `Index<char>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `char`\n  --> /tmp/tmpsiuc54ve.rs:33:12\n   |\n33 |         if s[i] == ' ' {\n   |            ^^^^ `String` cannot be indexed by `char`\n   |\n   = help: the tra",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns a vector of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty vector.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n/// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut words = Vec::new();\n    let mut word = String::new();\n    let mut count = 0;\n    for i in s.chars() {\n        if count == n {\n            words.push(word);\n            word = String::new();\n            count = 0;\n        }\n        if s[i] == ' ' {\n            continue;\n        }\n        if s[i] == ' ' {\n            continue;\n        }\n        if s[i] == ' ' {\n            continue;\n        }\n        if s[i] == ' ' {\n            continue;\n        }\n        if s[i] == ' ' {\n            continue;\n        }\n        if s[i] == ' ' {\n            continue;\n        }\n        if s[i] == ' ' {\n            continue;\n        }\n        if s[i] == ' ' {\n            continue;\n        }\n        if s[i] == ' ' {\n            continue;\n        }\n        if s[i] == ' ' {\n            continue;\n        }\n        if s[i] == ' ' {\n            continue;\n        }\n        if s[i] == ' ' {\n            continue;\n        }\n        if s[i] == ' ' {\n            continue;\n        }\n        if s[i] == ' ' {\n            continue;\n        }\n        if s[i] == ' ' {\n            continue;\n        }\n        if s[i] == ' ' {\n            continue;\n        }\n        if s[i] == ' ' {\n            continue;\n        }\n        if s[i] == ' ' {\n            continue;\n        }\n        if s[i] == ' ' {\n            continue;\n        }\n        if s[i] == ' ' {\n            continue;\n        }\n        if s[i] == ' ' {\n            continue;\n        }\n        if s[i] == ' ' {\n            continue;\n        }\n        if s[i] == ' ' {\n            continue;\n        }\n        if s[i] == ' ' {\n            continue;\n        }\n        if s[i] == ' '\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "error: this file contains an unclosed delimiter\n   --> /tmp/tmpgc0yhkq6.rs:111:3\n    |\n17  | fn select_words(s: String, n: isize) -> Vec<String> {\n    |                                                     - unclosed delimiter\n...\n21  |     for i in s.chars() {\n    |                        - this delimiter might not be properly closed...\n...\n100 | }\n    | - ...as it matches this but it has different indentation\n...\n111 | }\n    |   ^\n\nerror: expected `{`, found `}`\n   --> /tmp/tmpgc0yhkq6.rs:100:1\n    |\n99  |         if s[i] == ' '\n    |         -- this `if` expression has a condition, but no block\n100 | }\n    | ^ expected `{`\n\nerror[E0277]: the type `String` cannot be indexed by `char`\n  --> /tmp/tmpgc0yhkq6.rs:27:12\n   |\n27 |         if s[i] == ' ' {\n   |            ^^^^ `String` cannot be indexed by `char`\n   |\n   = help: the trait `Index<char>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `char`\n  --> /tmp/tmpgc0yhkq6.rs:30:12\n   |\n30 |         if s[i] == ' ' {\n   |            ^^^^ `String` cannot be indexed by `char`\n   |\n   = help: the trait `Index<char>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `char`\n  --> /tmp/tmpgc0yhkq6.rs:33:12\n   |",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns a vector of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty vector.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n/// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n  let mut words = Vec::new();\n  let mut word = String::new();\n  let mut count = 0;\n  for (let i = 0; i < s.len(); i++) {\n    if (s[i] == ' ') {\n      if (count == n) {\n        words.push(word);\n        word = String::new();\n        count = 0;\n      }\n    } else {\n      if (count < n) {\n        count += 1;\n        word.push_back(s[i]);\n      } else {\n        if (count == n) {\n          words.push(word);\n          word = String::new();\n          count = 0;\n        }\n      }\n    }\n  }\n  if (count == n) {\n    words.push(word);\n  }\n  words\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmpi7voeaql.rs:21:8\n   |\n21 |   for (let i = 0; i < s.len(); i++) {\n   |        ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmpi7voeaql.rs:21:12\n   |\n21 |   for (let i = 0; i < s.len(); i++) {\n   |           -^ expected one of `)`, `,`, `@`, or `|`\n   |           |\n   |           help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmpi7voeaql.rs:21:14\n   |\n21 |   for (let i = 0; i < s.len(); i++) {\n   |              ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmpi7voeaql.rs:21:13\n   |\n21 |   for (let i = 0; i < s.len(); i++) {\n   |             ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmpi7voeaql.rs:21:14\n   |\n21 |   for (let i = 0; i < s.len(); i++) {\n   |              ^ expected expression\n\nerror: aborting due to 5 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns a vector of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty vector.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n/// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n  let mut words = Vec::new();\n  let mut word = String::new();\n  let mut word_count = 0;\n  for (let i = 0; i < s.len(); i++) {\n    if (s[i] == ' ') {\n      if (word_count == n) {\n        words.push(word);\n        word = String::new();\n        word_count = 0;\n      }\n    } else {\n      word += s[i];\n      word_count += 1;\n    }\n  }\n  if (word_count == n) {\n    words.push(word);\n  }\n  return words;\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmp698lvfwn.rs:21:8\n   |\n21 |   for (let i = 0; i < s.len(); i++) {\n   |        ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmp698lvfwn.rs:21:12\n   |\n21 |   for (let i = 0; i < s.len(); i++) {\n   |           -^ expected one of `)`, `,`, `@`, or `|`\n   |           |\n   |           help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmp698lvfwn.rs:21:14\n   |\n21 |   for (let i = 0; i < s.len(); i++) {\n   |              ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmp698lvfwn.rs:21:13\n   |\n21 |   for (let i = 0; i < s.len(); i++) {\n   |             ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmp698lvfwn.rs:21:14\n   |\n21 |   for (let i = 0; i < s.len(); i++) {\n   |              ^ expected expression\n\nerror: aborting due to 5 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns a vector of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty vector.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n/// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut result = Vec::new();\n    let mut word = String::new();\n    let mut count = 0;\n    for c in s.chars() {\n        if count == n {\n            result.push(word);\n            word = String::new();\n            count = 0;\n        }\n        if c.is_upper() {\n            word += c.to_lower();\n        } else {\n            count += 1;\n        }\n    }\n    if count == n {\n        result.push(word);\n    }\n    return result;\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "error[E0599]: no method named `is_upper` found for type `char` in the current scope\n  --> /tmp/tmpvv1x5mb1.rs:27:14\n   |\n27 |         if c.is_upper() {\n   |              ^^^^^^^^ help: there is an associated function with a similar name: `is_uppercase`\n\nerror[E0599]: no method named `to_lower` found for type `char` in the current scope\n  --> /tmp/tmpvv1x5mb1.rs:28:23\n   |\n28 |             word += c.to_lower();\n   |                       ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns a vector of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty vector.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n/// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut words: Vec<String> = Vec::new();\n    let mut word: String = String::new();\n    let mut count: isize = 0;\n    for i in s.chars() {\n        if count == n {\n            words.push(word);\n            word = String::new();\n            count = 0;\n        }\n        if s[i] == ' ' {\n            if count > 0 {\n                words.push(word);\n                word = String::new();\n                count = 0;\n            }\n        } else {\n            count += 1;\n            word.push_back(s[i]);\n        }\n    }\n    if count > 0 {\n        words.push(word);\n    }\n    return words;\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "error[E0277]: the type `String` cannot be indexed by `char`\n  --> /tmp/tmpsa4e53tp.rs:27:12\n   |\n27 |         if s[i] == ' ' {\n   |            ^^^^ `String` cannot be indexed by `char`\n   |\n   = help: the trait `Index<char>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0599]: no method named `push_back` found for struct `String` in the current scope\n  --> /tmp/tmpsa4e53tp.rs:35:18\n   |\n35 |             word.push_back(s[i]);\n   |                  ^^^^^^^^^ method not found in `String`\n\nerror[E0277]: the type `String` cannot be indexed by `char`\n  --> /tmp/tmpsa4e53tp.rs:35:28\n   |\n35 |             word.push_back(s[i]);\n   |                            ^^^^ `String` cannot be indexed by `char`\n   |\n   = help: the trait `Index<char>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0599.\nFor more information about an error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns a vector of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty vector.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n/// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n  let mut words = Vec::new();\n  let mut word = String::new();\n  let mut count = 0;\n  for i in s.chars() {\n    if count == n {\n      words.push(word);\n      word = String::new();\n      count = 0;\n    }\n    if s[i] == ' ' {\n      if !word.is_empty() {\n        count += 1;\n      }\n    } else {\n      word += s[i];\n      count += 1;\n    }\n  }\n  if !word.is_empty() {\n    words.push(word);\n  }\n  return words;\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "error[E0277]: the type `String` cannot be indexed by `char`\n  --> /tmp/tmp6d3ltx7k.rs:27:8\n   |\n27 |     if s[i] == ' ' {\n   |        ^^^^ `String` cannot be indexed by `char`\n   |\n   = help: the trait `Index<char>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `char`\n  --> /tmp/tmp6d3ltx7k.rs:32:15\n   |\n32 |       word += s[i];\n   |               ^^^^ `String` cannot be indexed by `char`\n   |\n   = help: the trait `Index<char>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns a vector of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty vector.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n/// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n  let mut words: Vec<String> = Vec::new();\n  let mut word: String = String::from(\"\");\n  let mut count: isize = 0;\n  for i in s.chars() {\n    if count == n {\n      words.push(word);\n      word = String::from(\"\");\n      count = 0;\n    }\n    if s[i] == ' ' {\n      continue;\n    }\n    if s[i] == ' ' {\n      continue;\n    }\n    if s[i] == ' ' {\n      continue;\n    }\n    if s[i] == ' ' {\n      continue;\n    }\n    if s[i] == ' ' {\n      continue;\n    }\n    if s[i] == ' ' {\n      continue;\n    }\n    if s[i] == ' ' {\n      continue;\n    }\n    if s[i] == ' ' {\n      continue;\n    }\n    if s[i] == ' ' {\n      continue;\n    }\n    if s[i] == ' ' {\n      continue;\n    }\n    if s[i] == ' ' {\n      continue;\n    }\n    if s[i] == ' ' {\n      continue;\n    }\n    if s[i] == ' ' {\n      continue;\n    }\n    if s[i] == ' ' {\n      continue;\n    }\n    if s[i] == ' ' {\n      continue;\n    }\n    if s[i] == ' ' {\n      continue;\n    }\n    if s[i] == ' ' {\n      continue;\n    }\n    if s[i] == ' ' {\n      continue;\n    }\n    if s[i] == ' ' {\n      continue;\n    }\n    if s[i] == ' ' {\n      continue;\n    }\n    if s[i] == ' ' {\n      continue;\n    }\n    if s[i] == ' ' {\n      continue;\n    }\n    if s[i] == ' ' {\n      continue;\n    }\n    if s[i] == ' ' {\n      continue;\n\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "error: this file contains an unclosed delimiter\n   --> /tmp/tmpshu75nca.rs:110:3\n    |\n17  | fn select_words(s: String, n: isize) -> Vec<String> {\n    |                                                     - unclosed delimiter\n...\n21  |   for i in s.chars() {\n    |                      - unclosed delimiter\n...\n96  |     if s[i] == ' ' {\n    |                    - this delimiter might not be properly closed...\n...\n99  | }\n    | - ...as it matches this but it has different indentation\n...\n110 | }\n    |   ^\n\nerror[E0277]: the type `String` cannot be indexed by `char`\n  --> /tmp/tmpshu75nca.rs:27:8\n   |\n27 |     if s[i] == ' ' {\n   |        ^^^^ `String` cannot be indexed by `char`\n   |\n   = help: the trait `Index<char>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `char`\n  --> /tmp/tmpshu75nca.rs:30:8\n   |\n30 |     if s[i] == ' ' {\n   |        ^^^^ `String` cannot be indexed by `char`\n   |\n   = help: the trait `Index<char>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `char`\n  --> /tmp/tmpshu75nca.rs:33:8\n   |\n33 |     if s[i] == ' ' {\n   |        ^^^^ `String` cannot be indexed by `char`\n   |\n   = help: the trait `Index<char>` is not implemented for",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns a vector of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty vector.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n/// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n  let mut words: Vec<String> = Vec::new();\n  let mut word: String = String::new();\n  let mut count: isize = 0;\n  for i in s.chars() {\n    if count == n {\n      words.push(word);\n      word = String::new();\n      count = 0;\n    }\n    if s[i] == ' ' {\n      continue;\n    }\n    if s[i] == '\\n' {\n      continue;\n    }\n    if s[i] == '\\r' {\n      continue;\n    }\n    if s[i] == '\\t' {\n      continue;\n    }\n    if s[i] == '\\v' {\n      continue;\n    }\n    if s[i] == '\\f' {\n      continue;\n    }\n    if s[i] == '\\b' {\n      continue;\n    }\n    if s[i] == '\\u00A0' {\n      continue;\n    }\n    if s[i] == '\\u2007' {\n      continue;\n    }\n    if s[i] == '\\u202F' {\n      continue;\n    }\n    if s[i] == '\\u3000' {\n      continue;\n    }\n    if s[i] == '\\uFF0D' {\n      continue;\n    }\n    if s[i] == '\\uFF0E' {\n      continue;\n    }\n    if s[i] == '\\uFF0F' {\n      continue;\n    }\n    if s[i] == '\\uFF1A' {\n      continue;\n    }\n    if s[i] == '\\uFF1B' {\n      continue;\n    }\n    if s[i] == '\\uFF1C' {\n      continue;\n    }\n    if s[i] == '\\uFF1D' {\n      continue;\n    }\n    if s[i] == '\\uFF1E' {\n      continue;\n    }\n    if s[i] == '\\uFF1F' {\n      continue;\n    }\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "error: unknown character escape: `v`\n  --> /tmp/tmpwle_kkqi.rs:39:18\n   |\n39 |     if s[i] == '\\v' {\n   |                  ^ unknown character escape\n   |\n   = help: for more information, visit <https://static.rust-lang.org/doc/master/reference.html#literals>\nhelp: if you meant to write a literal backslash (perhaps escaping in a regular expression), consider a raw string literal\n   |\n39 |     if s[i] == r\"\\v\" {\n   |                ~~~~~\n\nerror: unknown character escape: `f`\n  --> /tmp/tmpwle_kkqi.rs:42:18\n   |\n42 |     if s[i] == '\\f' {\n   |                  ^ unknown character escape\n   |\n   = help: for more information, visit <https://static.rust-lang.org/doc/master/reference.html#literals>\nhelp: if you meant to write a literal backslash (perhaps escaping in a regular expression), consider a raw string literal\n   |\n42 |     if s[i] == r\"\\f\" {\n   |                ~~~~~\n\nerror: unknown character escape: `b`\n  --> /tmp/tmpwle_kkqi.rs:45:18\n   |\n45 |     if s[i] == '\\b' {\n   |                  ^ unknown character escape\n   |\n   = help: for more information, visit <https://static.rust-lang.org/doc/master/reference.html#literals>\nhelp: if you meant to write a literal backslash (perhaps escaping in a regular expression), consider a raw string literal\n   |\n45 |     if s[i] == r\"\\b\" {\n   |                ~~~~~\n\nerror: incorrect unicode escape sequence\n  --> /tmp/tmpwle_kkqi.rs:48:17\n   |\n48 |     if s[i] == '\\u00A0' {\n   |                 ^^^---\n   |                 |\n   |                 help: format of unicode escape sequences uses braces: `\\u{00A0}`\n\nerror: incorrect unicode escape sequence\n  --> /tmp/tmpwle_kkqi.rs:51:17\n   |\n51 |     if s[i] == '\\u2007' {\n   |                 ^^^---\n   |                 |\n   |                 help: format of unicode escape sequences uses braces: `\\u{2007}`\n\nerror: incorrect unicode escape sequence\n  --> /tmp/tmpwle_kkqi.rs:54:17\n   |\n54 |     if s[i] == '\\u202F' {\n   |                 ^^^---\n   |                 |\n   |                 help: format of unicode escape sequences uses b",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns a vector of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty vector.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n/// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n  let mut words = Vec::new();\n  let mut word = String::new();\n  let mut consonants = 0;\n  for (let c of s) {\n    if (c == ' ') {\n      if (consonants == n) {\n        words.push(word);\n        word = String::new();\n        consonants = 0;\n      }\n    } else {\n      consonants += 1;\n      word += c;\n    }\n  }\n  if (consonants == n) {\n    words.push(word);\n  }\n  return words;\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmpyx6rjcj3.rs:21:8\n   |\n21 |   for (let c of s) {\n   |        ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `c`\n  --> /tmp/tmpyx6rjcj3.rs:21:12\n   |\n21 |   for (let c of s) {\n   |           -^ expected one of `)`, `,`, `@`, or `|`\n   |           |\n   |           help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `of`\n  --> /tmp/tmpyx6rjcj3.rs:21:14\n   |\n21 |   for (let c of s) {\n   |             -^^ expected one of `)`, `,`, `@`, or `|`\n   |             |\n   |             help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `s`\n  --> /tmp/tmpyx6rjcj3.rs:21:17\n   |\n21 |   for (let c of s) {\n   |                -^ expected one of `)`, `,`, `@`, or `|`\n   |                |\n   |                help: missing `,`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmpyx6rjcj3.rs:21:19\n   |\n21 |   for (let c of s) {\n   |                   ^ help: try adding `in` here\n\nerror: expected `{`, found keyword `if`\n  --> /tmp/tmpyx6rjcj3.rs:33:3\n   |\n33 |   if (consonants == n) {\n   |   ^^ expected `{`\n   |\nhelp: try placing this code inside a block\n   |\n33 ~   { if (consonants == n) {\n34 |     words.push(word);\n35 ~   } }\n   |\n\nerror: aborting due to 6 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns a vector of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty vector.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n/// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut words = Vec::new();\n    let mut word = String::new();\n    let mut i = 0;\n    for i in s.chars() {\n        if i.is_space() {\n            if word.len() > 0 {\n                words.push(word);\n                word = String::new();\n            }\n        } else {\n            word += i;\n        }\n    }\n    if word.len() > 0 {\n        words.push(word);\n    }\n    words.sort();\n    words.drop_while(|w| w.len() < n);\n    return words;\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "error[E0599]: no method named `is_space` found for type `char` in the current scope\n  --> /tmp/tmpl0x_bp0b.rs:22:14\n   |\n22 |         if i.is_space() {\n   |              ^^^^^^^^ help: there is an associated function with a similar name: `is_whitespace`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpl0x_bp0b.rs:28:21\n   |\n28 |             word += i;\n   |                     ^ expected `&str`, found `char`\n\nerror[E0599]: no method named `drop_while` found for struct `Vec<String>` in the current scope\n  --> /tmp/tmpl0x_bp0b.rs:35:11\n   |\n35 |     words.drop_while(|w| w.len() < n);\n   |           ^^^^^^^^^^ method not found in `Vec<String>`\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns a vector of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty vector.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n/// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut words = Vec::new();\n    let mut word = String::new();\n    let mut i = 0;\n    let mut j = 0;\n    let mut k = 0;\n    let mut l = 0;\n    let mut m = 0;\n    let mut n = 0;\n    let mut count = 0;\n    let mut count_2 = 0;\n    let mut count_3 = 0;\n    let mut count_4 = 0;\n    let mut count_5 = 0;\n    let mut count_6 = 0;\n    let mut count_7 = 0;\n    let mut count_8 = 0;\n    let mut count_9 = 0;\n    let mut count_10 = 0;\n    let mut count_11 = 0;\n    let mut count_12 = 0;\n    let mut count_13 = 0;\n    let mut count_14 = 0;\n    let mut count_15 = 0;\n    let mut count_16 = 0;\n    let mut count_17 = 0;\n    let mut count_18 = 0;\n    let mut count_19 = 0;\n    let mut count_20 = 0;\n    let mut count_21 = 0;\n    let mut count_22 = 0;\n    let mut count_23 = 0;\n    let mut count_24 = 0;\n    let mut count_25 = 0;\n    let mut count_26 = 0;\n    let mut count_27 = 0;\n    let mut count_28 = 0;\n    let mut count_29 = 0;\n    let mut count_30 = 0;\n    let mut count_31 = 0;\n    let mut count_32 = 0;\n    let mut count_33 = 0;\n    let mut count_34 = 0;\n    let mut count_35 = 0;\n    let mut count_36 = 0;\n    let mut count_37 = 0;\n    let mut count_38 = 0;\n    let mut count_39 = 0;\n    let mut count_40 = 0;\n    let mut count_41 = 0;\n    let mut count_42 = 0;\n    let mut count_43 = 0;\n    let mut count_44 = 0;\n    let mut count_45\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "error: expected `;`, found `}`\n  --> /tmp/tmphdk0ktf4.rs:70:21\n   |\n70 |     let mut count_45\n   |                     ^ help: add `;` here\n71 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmphdk0ktf4.rs:17:41\n   |\n17 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |    ------------                         ^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<String>`\n           found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns a vector of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty vector.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n/// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n  let mut words: Vec<String> = Vec::new();\n  let mut word: String = String::from(\"\");\n  let mut count: isize = 0;\n  for i in s.chars() {\n    if count == n {\n      words.push(word);\n      word = String::from(\"\");\n      count = 0;\n    }\n    if s[i] == ' ' {\n      continue;\n    }\n    if s[i] == '\\n' {\n      continue;\n    }\n    if s[i] == '\\t' {\n      continue;\n    }\n    if s[i] == '\\r' {\n      continue;\n    }\n    if s[i] == '\\v' {\n      continue;\n    }\n    if s[i] == '\\f' {\n      continue;\n    }\n    if s[i] == '\\b' {\n      continue;\n    }\n    if s[i] == '\\u00A0' {\n      continue;\n    }\n    if s[i] == '\\u2007' {\n      continue;\n    }\n    if s[i] == '\\u202F' {\n      continue;\n    }\n    if s[i] == '\\u3000' {\n      continue;\n    }\n    if s[i] == '\\uFF0D' {\n      continue;\n    }\n    if s[i] == '\\uFF0E' {\n      continue;\n    }\n    if s[i] == '\\uFF0F' {\n      continue;\n    }\n    if s[i] == '\\uFF1A' {\n      continue;\n    }\n    if s[i] == '\\uFF1B' {\n      continue;\n    }\n    if s[i] == '\\uFF1C' {\n      continue;\n    }\n    if s[i] == '\\uFF1D' {\n      continue;\n    }\n    if s[i] == '\\uFF1E' {\n      continue;\n    }\n    if s[i] == '\\uFF1F' {\n      continue;\n\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "error: unknown character escape: `v`\n  --> /tmp/tmpfgr_yit_.rs:39:18\n   |\n39 |     if s[i] == '\\v' {\n   |                  ^ unknown character escape\n   |\n   = help: for more information, visit <https://static.rust-lang.org/doc/master/reference.html#literals>\nhelp: if you meant to write a literal backslash (perhaps escaping in a regular expression), consider a raw string literal\n   |\n39 |     if s[i] == r\"\\v\" {\n   |                ~~~~~\n\nerror: unknown character escape: `f`\n  --> /tmp/tmpfgr_yit_.rs:42:18\n   |\n42 |     if s[i] == '\\f' {\n   |                  ^ unknown character escape\n   |\n   = help: for more information, visit <https://static.rust-lang.org/doc/master/reference.html#literals>\nhelp: if you meant to write a literal backslash (perhaps escaping in a regular expression), consider a raw string literal\n   |\n42 |     if s[i] == r\"\\f\" {\n   |                ~~~~~\n\nerror: unknown character escape: `b`\n  --> /tmp/tmpfgr_yit_.rs:45:18\n   |\n45 |     if s[i] == '\\b' {\n   |                  ^ unknown character escape\n   |\n   = help: for more information, visit <https://static.rust-lang.org/doc/master/reference.html#literals>\nhelp: if you meant to write a literal backslash (perhaps escaping in a regular expression), consider a raw string literal\n   |\n45 |     if s[i] == r\"\\b\" {\n   |                ~~~~~\n\nerror: incorrect unicode escape sequence\n  --> /tmp/tmpfgr_yit_.rs:48:17\n   |\n48 |     if s[i] == '\\u00A0' {\n   |                 ^^^---\n   |                 |\n   |                 help: format of unicode escape sequences uses braces: `\\u{00A0}`\n\nerror: incorrect unicode escape sequence\n  --> /tmp/tmpfgr_yit_.rs:51:17\n   |\n51 |     if s[i] == '\\u2007' {\n   |                 ^^^---\n   |                 |\n   |                 help: format of unicode escape sequences uses braces: `\\u{2007}`\n\nerror: incorrect unicode escape sequence\n  --> /tmp/tmpfgr_yit_.rs:54:17\n   |\n54 |     if s[i] == '\\u202F' {\n   |                 ^^^---\n   |                 |\n   |                 help: format of unicode escape sequences uses b",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns a vector of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty vector.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n/// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut words: Vec<String> = Vec::new();\n    let mut word: String = String::new();\n    let mut count: isize = 0;\n    for i in s.chars() {\n        if count == n {\n            words.push(word);\n            word = String::new();\n            count = 0;\n        }\n        if s[i] == ' ' {\n            continue;\n        }\n        if s[i] == '\\n' {\n            continue;\n        }\n        if s[i] == '\\r' {\n            continue;\n        }\n        if s[i] == '\\t' {\n            continue;\n        }\n        if s[i] == '\\v' {\n            continue;\n        }\n        if s[i] == '\\f' {\n            continue;\n        }\n        if s[i] == '\\b' {\n            continue;\n        }\n        if s[i] == '\\a' {\n            continue;\n        }\n        if s[i] == '\\0' {\n            continue;\n        }\n        if s[i] == '\\x0B' {\n            continue;\n        }\n        if s[i] == '\\x0C' {\n            continue;\n        }\n        if s[i] == '\\x0E' {\n            continue;\n        }\n        if s[i] == '\\x0F' {\n            continue;\n        }\n        if s[i] == '\\x1B' {\n            continue;\n        }\n        if s[i] == '\\x1C' {\n            continue;\n        }\n        if s[i] == '\\x1D' {\n            continue;\n        }\n        if s[i] == '\\x1E' {\n            continue;\n        }\n        if s[i] == '\\x1F' {\n            continue;\n        }\n        if s[i] == '\\x7F' {\n            continue;\n        }\n        if s[i] == '\\x80' {\n            continue;\n        }\n        if s[i] == '\\x81'\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "error: unknown character escape: `v`\n  --> /tmp/tmp9fi8o14c.rs:39:22\n   |\n39 |         if s[i] == '\\v' {\n   |                      ^ unknown character escape\n   |\n   = help: for more information, visit <https://static.rust-lang.org/doc/master/reference.html#literals>\nhelp: if you meant to write a literal backslash (perhaps escaping in a regular expression), consider a raw string literal\n   |\n39 |         if s[i] == r\"\\v\" {\n   |                    ~~~~~\n\nerror: unknown character escape: `f`\n  --> /tmp/tmp9fi8o14c.rs:42:22\n   |\n42 |         if s[i] == '\\f' {\n   |                      ^ unknown character escape\n   |\n   = help: for more information, visit <https://static.rust-lang.org/doc/master/reference.html#literals>\nhelp: if you meant to write a literal backslash (perhaps escaping in a regular expression), consider a raw string literal\n   |\n42 |         if s[i] == r\"\\f\" {\n   |                    ~~~~~\n\nerror: unknown character escape: `b`\n  --> /tmp/tmp9fi8o14c.rs:45:22\n   |\n45 |         if s[i] == '\\b' {\n   |                      ^ unknown character escape\n   |\n   = help: for more information, visit <https://static.rust-lang.org/doc/master/reference.html#literals>\nhelp: if you meant to write a literal backslash (perhaps escaping in a regular expression), consider a raw string literal\n   |\n45 |         if s[i] == r\"\\b\" {\n   |                    ~~~~~\n\nerror: unknown character escape: `a`\n  --> /tmp/tmp9fi8o14c.rs:48:22\n   |\n48 |         if s[i] == '\\a' {\n   |                      ^ unknown character escape\n   |\n   = help: for more information, visit <https://static.rust-lang.org/doc/master/reference.html#literals>\nhelp: if you meant to write a literal backslash (perhaps escaping in a regular expression), consider a raw string literal\n   |\n48 |         if s[i] == r\"\\a\" {\n   |                    ~~~~~\n\nerror: out of range hex escape\n  --> /tmp/tmp9fi8o14c.rs:84:21\n   |\n84 |         if s[i] == '\\x80' {\n   |                     ^^^^ must be a character in the range [\\x00-\\x7f]\n\nerror: out of range hex escape\n  --> /t",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns a vector of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty vector.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n/// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n  let mut words = Vec::new();\n  let mut word = String::new();\n  let mut word_count = 0;\n  let mut word_index = 0;\n  let mut word_index_end = 0;\n  let mut word_index_start = 0;\n  let mut word_index_start_end = 0;\n  let mut word_index_start_end_end = 0;\n  let mut word_index_start_end_end_end = 0;\n  let mut word_index_start_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end_end_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end_end_end_end\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "error: expected `;`, found `}`\n  --> /tmp/tmpkoz4q7r5.rs:39:67\n   |\n39 |   let mut word_index_start_end_end_end_end_end_end_end_end_end_end\n   |                                                                   ^ help: add `;` here\n40 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpkoz4q7r5.rs:17:41\n   |\n17 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |    ------------                         ^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<String>`\n           found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns a vector of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty vector.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n/// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n  let mut words: Vec<String> = Vec::new();\n  let mut word: String = String::new();\n  let mut count: usize = 0;\n  for (let i = 0; i < s.len(); i++) {\n    if (s[i] == ' ') {\n      if (count == n) {\n        words.push(word);\n        word = String::new();\n        count = 0;\n      }\n    } else {\n      if (count < n) {\n        count += 1;\n        word += s[i];\n      } else {\n        count = 0;\n        word += s[i];\n      }\n    }\n  }\n  if (count == n) {\n    words.push(word);\n  }\n  return words;\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmp7v3afwct.rs:21:8\n   |\n21 |   for (let i = 0; i < s.len(); i++) {\n   |        ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmp7v3afwct.rs:21:12\n   |\n21 |   for (let i = 0; i < s.len(); i++) {\n   |           -^ expected one of `)`, `,`, `@`, or `|`\n   |           |\n   |           help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmp7v3afwct.rs:21:14\n   |\n21 |   for (let i = 0; i < s.len(); i++) {\n   |              ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmp7v3afwct.rs:21:13\n   |\n21 |   for (let i = 0; i < s.len(); i++) {\n   |             ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmp7v3afwct.rs:21:14\n   |\n21 |   for (let i = 0; i < s.len(); i++) {\n   |              ^ expected expression\n\nerror: aborting due to 5 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns a vector of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty vector.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n/// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n  let mut result = Vec::new();\n  let mut word = String::new();\n  let mut count = 0;\n  for (let i = 0; i < s.len(); i++) {\n    if (s[i] == ' ') {\n      if (count == n) {\n        result.push(word);\n        word = String::new();\n        count = 0;\n      }\n    } else {\n      if (count < n) {\n        word += s[i];\n        count += 1;\n      }\n    }\n  }\n  if (count == n) {\n    result.push(word);\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmpj5vmbwlb.rs:21:8\n   |\n21 |   for (let i = 0; i < s.len(); i++) {\n   |        ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmpj5vmbwlb.rs:21:12\n   |\n21 |   for (let i = 0; i < s.len(); i++) {\n   |           -^ expected one of `)`, `,`, `@`, or `|`\n   |           |\n   |           help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmpj5vmbwlb.rs:21:14\n   |\n21 |   for (let i = 0; i < s.len(); i++) {\n   |              ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmpj5vmbwlb.rs:21:13\n   |\n21 |   for (let i = 0; i < s.len(); i++) {\n   |             ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmpj5vmbwlb.rs:21:14\n   |\n21 |   for (let i = 0; i < s.len(); i++) {\n   |              ^ expected expression\n\nerror: aborting due to 5 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns a vector of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty vector.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n/// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n  let mut result = Vec::new();\n  let mut word = String::new();\n  let mut word_count = 0;\n  let mut word_index = 0;\n  let mut word_index_end = 0;\n  let mut word_index_start = 0;\n  let mut word_index_start_end = 0;\n  let mut word_index_start_end_end = 0;\n  let mut word_index_start_end_end_end = 0;\n  let mut word_index_start_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end_end_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end_end_end_end\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "error: expected `;`, found `}`\n  --> /tmp/tmpzevw3u6c.rs:39:67\n   |\n39 |   let mut word_index_start_end_end_end_end_end_end_end_end_end_end\n   |                                                                   ^ help: add `;` here\n40 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpzevw3u6c.rs:17:41\n   |\n17 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |    ------------                         ^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<String>`\n           found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns a vector of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty vector.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n/// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n  let mut result = Vec::new();\n  let mut word = String::new();\n  let mut count = 0;\n  for (let c of s) {\n    if (c == ' ') {\n      if (count == n) {\n        result.push(word);\n        word = String::new();\n        count = 0;\n      }\n    } else {\n      if (count < n) {\n        word = word.concat(c);\n        count += 1;\n      } else {\n        result.push(word);\n        word = String::new();\n        count = 0;\n        word = word.concat(c);\n        count += 1;\n      }\n    }\n  }\n  if (count == n) {\n    result.push(word);\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmpcrpzepw6.rs:21:8\n   |\n21 |   for (let c of s) {\n   |        ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `c`\n  --> /tmp/tmpcrpzepw6.rs:21:12\n   |\n21 |   for (let c of s) {\n   |           -^ expected one of `)`, `,`, `@`, or `|`\n   |           |\n   |           help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `of`\n  --> /tmp/tmpcrpzepw6.rs:21:14\n   |\n21 |   for (let c of s) {\n   |             -^^ expected one of `)`, `,`, `@`, or `|`\n   |             |\n   |             help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `s`\n  --> /tmp/tmpcrpzepw6.rs:21:17\n   |\n21 |   for (let c of s) {\n   |                -^ expected one of `)`, `,`, `@`, or `|`\n   |                |\n   |                help: missing `,`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmpcrpzepw6.rs:21:19\n   |\n21 |   for (let c of s) {\n   |                   ^ help: try adding `in` here\n\nerror: expected `{`, found keyword `if`\n  --> /tmp/tmpcrpzepw6.rs:41:3\n   |\n41 |   if (count == n) {\n   |   ^^ expected `{`\n   |\nhelp: try placing this code inside a block\n   |\n41 ~   { if (count == n) {\n42 |     result.push(word);\n43 ~   } }\n   |\n\nerror: aborting due to 6 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns a vector of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty vector.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n/// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n  let mut words = Vec::new();\n  let mut word = String::new();\n  let mut word_count = 0;\n  let mut word_index = 0;\n  let mut word_index_end = 0;\n  let mut word_index_start = 0;\n  let mut word_index_start_end = 0;\n  let mut word_index_start_end_end = 0;\n  let mut word_index_start_end_end_end = 0;\n  let mut word_index_start_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end_end_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end_end_end_end\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "error: expected `;`, found `}`\n  --> /tmp/tmpkoz4q7r5.rs:39:67\n   |\n39 |   let mut word_index_start_end_end_end_end_end_end_end_end_end_end\n   |                                                                   ^ help: add `;` here\n40 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpkoz4q7r5.rs:17:41\n   |\n17 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |    ------------                         ^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<String>`\n           found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns a vector of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty vector.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n/// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n  let mut words = Vec::new();\n  let mut word = String::new();\n  let mut count = 0;\n  for (let i = 0; i < s.len(); i++) {\n    if (s[i] == ' ') {\n      if (count == n) {\n        words.push(word);\n        word = String::new();\n        count = 0;\n      }\n    } else {\n      if (count == n) {\n        words.push(word);\n        word = String::new();\n        count = 0;\n      } else {\n        word += s[i];\n        count += 1;\n      }\n    }\n  }\n  if (count == n) {\n    words.push(word);\n  }\n  words\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmpbgln08tp.rs:21:8\n   |\n21 |   for (let i = 0; i < s.len(); i++) {\n   |        ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmpbgln08tp.rs:21:12\n   |\n21 |   for (let i = 0; i < s.len(); i++) {\n   |           -^ expected one of `)`, `,`, `@`, or `|`\n   |           |\n   |           help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmpbgln08tp.rs:21:14\n   |\n21 |   for (let i = 0; i < s.len(); i++) {\n   |              ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmpbgln08tp.rs:21:13\n   |\n21 |   for (let i = 0; i < s.len(); i++) {\n   |             ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmpbgln08tp.rs:21:14\n   |\n21 |   for (let i = 0; i < s.len(); i++) {\n   |              ^ expected expression\n\nerror: aborting due to 5 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns a vector of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty vector.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n/// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut words: Vec<String> = Vec::new();\n    let mut word: String = String::new();\n    let mut i: isize = 0;\n    for i in s.chars() {\n        if i == ' ' {\n            if word.len() == n {\n                words.push(word);\n                word = String::new();\n            }\n        } else {\n            word += String::from(i);\n        }\n    }\n    if word.len() == n {\n        words.push(word);\n    }\n    return words;\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "error[E0308]: mismatched types\n  --> /tmp/tmprls9iljx.rs:23:30\n   |\n23 |             if word.len() == n {\n   |                              ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic if the converted value doesn't fit\n   |\n23 |             if word.len() == n.try_into().unwrap() {\n   |                               ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmprls9iljx.rs:28:21\n   |\n28 |             word += String::from(i);\n   |                     ^^^^^^^^^^^^^^^\n   |                     |\n   |                     expected `&str`, found struct `String`\n   |                     help: consider borrowing here: `&String::from(i)`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmprls9iljx.rs:31:22\n   |\n31 |     if word.len() == n {\n   |                      ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic if the converted value doesn't fit\n   |\n31 |     if word.len() == n.try_into().unwrap() {\n   |                       ++++++++++++++++++++\n\nerror: aborting due to 3 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns a vector of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty vector.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n/// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n  let mut words = Vec::new();\n  let mut word = String::new();\n  let mut count = 0;\n  let mut i = 0;\n  while i < s.len() {\n    if s[i] == ' ' {\n      if count == n {\n        words.push(word);\n        word = String::new();\n        count = 0;\n      }\n      i += 1;\n    } else {\n      if count < n {\n        count += 1;\n        word += s[i];\n      } else {\n        i += 1;\n      }\n    }\n  }\n  if count == n {\n    words.push(word);\n  }\n  return words;\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmps72p22z3.rs:23:8\n   |\n23 |     if s[i] == ' ' {\n   |        ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmps72p22z3.rs:33:17\n   |\n33 |         word += s[i];\n   |                 ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns a vector of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty vector.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n/// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n  let mut words = Vec::new();\n  let mut word = String::new();\n  let mut i = 0;\n  let mut j = 0;\n  let mut count = 0;\n  while i < s.len() {\n    if s[i] == ' ' {\n      if count == n {\n        words.push(word);\n        word = String::new();\n        count = 0;\n      }\n      i += 1;\n      continue;\n    }\n    if s[i] == '\\n' {\n      i += 1;\n      continue;\n    }\n    if s[i] == '\\r' {\n      i += 1;\n      continue;\n    }\n    if s[i] == '\\t' {\n      i += 1;\n      continue;\n    }\n    if s[i] == '\\v' {\n      i += 1;\n      continue;\n    }\n    if s[i] == '\\f' {\n      i += 1;\n      continue;\n    }\n    if s[i] == '\\b' {\n      i += 1;\n      continue;\n    }\n    if s[i] == '\\u00A0' {\n      i += 1;\n      continue;\n    }\n    if s[i] == '\\u2007' {\n      i += 1;\n      continue;\n    }\n    if s[i] == '\\u202F' {\n      i += 1;\n      continue;\n    }\n    if s[i] == '\\u3000' {\n      i += 1;\n      continue;\n    }\n    if s[i] == '\\uFF0D' {\n      i += 1;\n      continue;\n    }\n    if s[i] == '\\uFF0E' {\n      i += 1;\n      continue;\n    }\n    if s[i] == '\\uFF0F' {\n      i += 1;\n      continue;\n    }\n    if s[i] == '\\uFF1A' {\n      i += 1;\n      continue;\n    }\n    if s[i] == '\\uFF1B' {\n      i +=\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "error: unknown character escape: `v`\n  --> /tmp/tmpw5fxu1l1.rs:45:18\n   |\n45 |     if s[i] == '\\v' {\n   |                  ^ unknown character escape\n   |\n   = help: for more information, visit <https://static.rust-lang.org/doc/master/reference.html#literals>\nhelp: if you meant to write a literal backslash (perhaps escaping in a regular expression), consider a raw string literal\n   |\n45 |     if s[i] == r\"\\v\" {\n   |                ~~~~~\n\nerror: unknown character escape: `f`\n  --> /tmp/tmpw5fxu1l1.rs:49:18\n   |\n49 |     if s[i] == '\\f' {\n   |                  ^ unknown character escape\n   |\n   = help: for more information, visit <https://static.rust-lang.org/doc/master/reference.html#literals>\nhelp: if you meant to write a literal backslash (perhaps escaping in a regular expression), consider a raw string literal\n   |\n49 |     if s[i] == r\"\\f\" {\n   |                ~~~~~\n\nerror: unknown character escape: `b`\n  --> /tmp/tmpw5fxu1l1.rs:53:18\n   |\n53 |     if s[i] == '\\b' {\n   |                  ^ unknown character escape\n   |\n   = help: for more information, visit <https://static.rust-lang.org/doc/master/reference.html#literals>\nhelp: if you meant to write a literal backslash (perhaps escaping in a regular expression), consider a raw string literal\n   |\n53 |     if s[i] == r\"\\b\" {\n   |                ~~~~~\n\nerror: incorrect unicode escape sequence\n  --> /tmp/tmpw5fxu1l1.rs:57:17\n   |\n57 |     if s[i] == '\\u00A0' {\n   |                 ^^^---\n   |                 |\n   |                 help: format of unicode escape sequences uses braces: `\\u{00A0}`\n\nerror: incorrect unicode escape sequence\n  --> /tmp/tmpw5fxu1l1.rs:61:17\n   |\n61 |     if s[i] == '\\u2007' {\n   |                 ^^^---\n   |                 |\n   |                 help: format of unicode escape sequences uses braces: `\\u{2007}`\n\nerror: incorrect unicode escape sequence\n  --> /tmp/tmpw5fxu1l1.rs:65:17\n   |\n65 |     if s[i] == '\\u202F' {\n   |                 ^^^---\n   |                 |\n   |                 help: format of unicode escape sequences uses b",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns a vector of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty vector.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n/// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n  let mut words = Vec::new();\n  let mut word = String::new();\n  let mut count = 0;\n  let mut i = 0;\n  let mut j = 0;\n  let mut k = 0;\n  let mut l = 0;\n  let mut m = 0;\n  let mut n = 0;\n  let mut o = 0;\n  let mut p = 0;\n  let mut q = 0;\n  let mut r = 0;\n  let mut s = 0;\n  let mut t = 0;\n  let mut u = 0;\n  let mut v = 0;\n  let mut w = 0;\n  let mut x = 0;\n  let mut y = 0;\n  let mut z = 0;\n  let mut a = 0;\n  let mut b = 0;\n  let mut c = 0;\n  let mut d = 0;\n  let mut e = 0;\n  let mut f = 0;\n  let mut g = 0;\n  let mut h = 0;\n  let mut i = 0;\n  let mut j = 0;\n  let mut k = 0;\n  let mut l = 0;\n  let mut m = 0;\n  let mut n = 0;\n  let mut o = 0;\n  let mut p = 0;\n  let mut q = 0;\n  let mut r = 0;\n  let mut s = 0;\n  let mut t = 0;\n  let mut u = 0;\n  let mut v = 0;\n  let mut w = 0;\n  let mut x = 0;\n  let mut y = 0;\n  let mut z = 0;\n  let mut a = 0;\n  let mut b = 0;\n  let mut c = 0;\n  let mut d = 0;\n  let mut e = 0;\n  let mut f = 0;\n  let mut g = 0;\n  let mut h = 0;\n  let mut i = 0;\n  let mut j = 0;\n  let mut k = 0;\n  let mut l = 0;\n  let mut m = 0;\n  let mut n = 0;\n  let mut o = 0;\n  let mut p = 0;\n  let mut q\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "error: expected `;`, found `}`\n  --> /tmp/tmp0aji3r25.rs:81:12\n   |\n81 |   let mut q\n   |            ^ help: add `;` here\n82 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp0aji3r25.rs:17:41\n   |\n17 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |    ------------                         ^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<String>`\n           found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns a vector of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty vector.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n/// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut words: Vec<String> = Vec::new();\n    let mut word: String = String::from(\"\");\n    let mut count: isize = 0;\n    for i in s.chars() {\n        if count == n {\n            words.push(word);\n            word = String::from(\"\");\n            count = 0;\n        }\n        if s[i] == ' ' {\n            if count > 0 {\n                words.push(word);\n                word = String::from(\"\");\n                count = 0;\n            }\n        } else {\n            count += 1;\n            word += s[i];\n        }\n    }\n    if count > 0 {\n        words.push(word);\n    }\n    return words;\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "error[E0277]: the type `String` cannot be indexed by `char`\n  --> /tmp/tmpra2pw3rd.rs:27:12\n   |\n27 |         if s[i] == ' ' {\n   |            ^^^^ `String` cannot be indexed by `char`\n   |\n   = help: the trait `Index<char>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `char`\n  --> /tmp/tmpra2pw3rd.rs:35:21\n   |\n35 |             word += s[i];\n   |                     ^^^^ `String` cannot be indexed by `char`\n   |\n   = help: the trait `Index<char>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns a vector of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty vector.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n/// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n  let mut result = Vec::new();\n  let mut word = String::new();\n  let mut count = 0;\n  let mut i = 0;\n  while i < s.len() {\n    if s[i] == ' ' {\n      if word.len() > 0 {\n        result.push(word);\n        word = String::new();\n        count = 0;\n      }\n      i++;\n      continue;\n    }\n    if s[i] == '\\n' {\n      i++;\n      continue;\n    }\n    if s[i] == '\\r' {\n      i++;\n      continue;\n    }\n    if s[i] == '\\t' {\n      i++;\n      continue;\n    }\n    if s[i] == '\\v' {\n      i++;\n      continue;\n    }\n    if s[i] == '\\f' {\n      i++;\n      continue;\n    }\n    if s[i] == '\\b' {\n      i++;\n      continue;\n    }\n    if s[i] == '\\a' {\n      i++;\n      continue;\n    }\n    if s[i] == '\\0' {\n      i++;\n      continue;\n    }\n    if s[i] == '\\x0b' {\n      i++;\n      continue;\n    }\n    if s[i] == '\\x0c' {\n      i++;\n      continue;\n    }\n    if s[i] == '\\x0e' {\n      i++;\n      continue;\n    }\n    if s[i] == '\\x0f' {\n      i++;\n      continue;\n    }\n    if s[i] == '\\x1b' {\n      i++;\n      continue;\n    }\n    if s[i] == '\\x1c' {\n      i++;\n      continue;\n    }\n    if s[i] == '\\x1d' {\n      i++;\n      continue;\n    }\n    if s[i] == '\\x1e' {\n      i++;\n      continue;\n    }\n    if s[i] == '\\\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "error: unknown character escape: `v`\n  --> /tmp/tmp4m0fv2h2.rs:44:18\n   |\n44 |     if s[i] == '\\v' {\n   |                  ^ unknown character escape\n   |\n   = help: for more information, visit <https://static.rust-lang.org/doc/master/reference.html#literals>\nhelp: if you meant to write a literal backslash (perhaps escaping in a regular expression), consider a raw string literal\n   |\n44 |     if s[i] == r\"\\v\" {\n   |                ~~~~~\n\nerror: unknown character escape: `f`\n  --> /tmp/tmp4m0fv2h2.rs:48:18\n   |\n48 |     if s[i] == '\\f' {\n   |                  ^ unknown character escape\n   |\n   = help: for more information, visit <https://static.rust-lang.org/doc/master/reference.html#literals>\nhelp: if you meant to write a literal backslash (perhaps escaping in a regular expression), consider a raw string literal\n   |\n48 |     if s[i] == r\"\\f\" {\n   |                ~~~~~\n\nerror: unknown character escape: `b`\n  --> /tmp/tmp4m0fv2h2.rs:52:18\n   |\n52 |     if s[i] == '\\b' {\n   |                  ^ unknown character escape\n   |\n   = help: for more information, visit <https://static.rust-lang.org/doc/master/reference.html#literals>\nhelp: if you meant to write a literal backslash (perhaps escaping in a regular expression), consider a raw string literal\n   |\n52 |     if s[i] == r\"\\b\" {\n   |                ~~~~~\n\nerror: unknown character escape: `a`\n  --> /tmp/tmp4m0fv2h2.rs:56:18\n   |\n56 |     if s[i] == '\\a' {\n   |                  ^ unknown character escape\n   |\n   = help: for more information, visit <https://static.rust-lang.org/doc/master/reference.html#literals>\nhelp: if you meant to write a literal backslash (perhaps escaping in a regular expression), consider a raw string literal\n   |\n56 |     if s[i] == r\"\\a\" {\n   |                ~~~~~\n\nerror[E0762]: unterminated character literal\n  --> /tmp/tmp4m0fv2h2.rs:96:16\n   |\n96 |       if s[i] == '\\\n   |  ________________^\n97 | | }\n   | |_^\n\nerror: aborting due to 5 previous errors\n\nFor more information about this error, try `rustc --explain E0762`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns a vector of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty vector.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n/// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut words = Vec::new();\n    let mut word = String::new();\n    let mut count = 0;\n    for i in s.iter() {\n        if count == n {\n            words.push(word);\n            word = String::new();\n            count = 0;\n        }\n        if s[i] == ' ' {\n            if word.len() > 0 {\n                count += 1;\n            }\n        } else {\n            word += s[i];\n        }\n    }\n    if word.len() > 0 {\n        words.push(word);\n    }\n    return words;\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "error[E0599]: no method named `iter` found for struct `String` in the current scope\n  --> /tmp/tmpikxsfsfm.rs:21:16\n   |\n21 |     for i in s.iter() {\n   |                ^^^^ method not found in `String`\n   |\nhelp: because of the in-memory representation of `&str`, to obtain an `Iterator` over each of its codepoint use method `chars`\n   |\n21 |     for i in s.chars() {\n   |                ~~~~~\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns a vector of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty vector.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n/// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n  let mut words = Vec::new();\n  let mut word = String::new();\n  let mut count = 0;\n  for i in s.iter() {\n    if count == n {\n      words.push(word);\n      word = String::new();\n      count = 0;\n    }\n    if s[i] == ' ' {\n      if count > 0 {\n        words.push(word);\n        word = String::new();\n        count = 0;\n      }\n    } else {\n      count += 1;\n      word.push_back(s[i]);\n    }\n  }\n  if count > 0 {\n    words.push(word);\n  }\n  return words;\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "error[E0599]: no method named `iter` found for struct `String` in the current scope\n  --> /tmp/tmpb7fdti2w.rs:21:14\n   |\n21 |   for i in s.iter() {\n   |              ^^^^ method not found in `String`\n   |\nhelp: because of the in-memory representation of `&str`, to obtain an `Iterator` over each of its codepoint use method `chars`\n   |\n21 |   for i in s.chars() {\n   |              ~~~~~\n\nerror[E0599]: no method named `push_back` found for struct `String` in the current scope\n  --> /tmp/tmpb7fdti2w.rs:35:12\n   |\n35 |       word.push_back(s[i]);\n   |            ^^^^^^^^^ method not found in `String`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns a vector of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty vector.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n/// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n  let mut words = Vec::new();\n  let mut word = String::new();\n  let mut word_count = 0;\n  let mut word_index = 0;\n  let mut word_index_end = 0;\n  let mut word_index_start = 0;\n  let mut word_index_start_end = 0;\n  let mut word_index_start_end_end = 0;\n  let mut word_index_start_end_end_end = 0;\n  let mut word_index_start_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end_end_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end_end_end_end\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "error: expected `;`, found `}`\n  --> /tmp/tmpkoz4q7r5.rs:39:67\n   |\n39 |   let mut word_index_start_end_end_end_end_end_end_end_end_end_end\n   |                                                                   ^ help: add `;` here\n40 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpkoz4q7r5.rs:17:41\n   |\n17 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |    ------------                         ^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<String>`\n           found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns a vector of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty vector.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n/// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n  let mut result = Vec::new();\n  let mut word = String::new();\n  let mut count = 0;\n  for i in s.chars() {\n    if count == n {\n      result.push(word);\n      word = String::new();\n      count = 0;\n    }\n    if s[i] == ' ' {\n      if word.len() > 0 {\n        result.push(word);\n        word = String::new();\n        count = 0;\n      }\n    } else {\n      word += s[i];\n      count += 1;\n    }\n  }\n  if word.len() > 0 {\n    result.push(word);\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "error[E0277]: the type `String` cannot be indexed by `char`\n  --> /tmp/tmpwmybvgrg.rs:27:8\n   |\n27 |     if s[i] == ' ' {\n   |        ^^^^ `String` cannot be indexed by `char`\n   |\n   = help: the trait `Index<char>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `char`\n  --> /tmp/tmpwmybvgrg.rs:34:15\n   |\n34 |       word += s[i];\n   |               ^^^^ `String` cannot be indexed by `char`\n   |\n   = help: the trait `Index<char>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns a vector of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty vector.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n/// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut result = Vec::new();\n    let mut word = String::new();\n    let mut word_count = 0;\n    let mut word_index = 0;\n    let mut word_index_end = 0;\n    let mut word_index_start = 0;\n    let mut word_index_start_end = 0;\n    let mut word_index_start_end_end = 0;\n    let mut word_index_start_end_end_end = 0;\n    let mut word_index_start_end_end_end_end = 0;\n    let mut word_index_start_end_end_end_end_end = 0;\n    let mut word_index_start_end_end_end_end_end_end = 0;\n    let mut word_index_start_end_end_end_end_end_end_end = 0;\n    let mut word_index_start_end_end_end_end_end_end_end_end = 0;\n    let mut word_index_start_end_end_end_end_end_end_end_end_end = 0;\n    let mut word_index_start_end_end_end_end_end_end_end_end_end_end = 0;\n    let mut word_index_start_end_end_end_end_end_end_end_end_end_end_end = 0;\n    let mut word_index_start_end_end_end_end_end_end_end_end_end_end_end_end = 0;\n    let mut word_index_start_end_end_end_end_end_end_end_end_end_end_end_end_end = 0;\n    let mut word_index_start_end_end_end_end_end_end_end_end_end_end_end_end_end_end = 0;\n    let mut word_index_start_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end = 0;\n    let mut word_index_start_end_end_end_end_end_end_end_end_end_end\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "error: expected `;`, found `}`\n  --> /tmp/tmpg8cknv_2.rs:39:69\n   |\n39 |     let mut word_index_start_end_end_end_end_end_end_end_end_end_end\n   |                                                                     ^ help: add `;` here\n40 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpg8cknv_2.rs:17:41\n   |\n17 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |    ------------                         ^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<String>`\n           found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns a vector of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty vector.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n/// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n  let mut words = Vec::new();\n  let mut word = String::new();\n  let mut word_count = 0;\n  let mut word_index = 0;\n  let mut word_index_end = 0;\n  let mut word_index_start = 0;\n  let mut word_index_start_end = 0;\n  let mut word_index_start_end_end = 0;\n  let mut word_index_start_end_end_end = 0;\n  let mut word_index_start_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end_end_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end_end_end_end\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "error: expected `;`, found `}`\n  --> /tmp/tmpkoz4q7r5.rs:39:67\n   |\n39 |   let mut word_index_start_end_end_end_end_end_end_end_end_end_end\n   |                                                                   ^ help: add `;` here\n40 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpkoz4q7r5.rs:17:41\n   |\n17 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |    ------------                         ^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<String>`\n           found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns a vector of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty vector.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n/// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut result = Vec::new();\n    let mut word = String::new();\n    let mut count = 0;\n    for i in s.chars() {\n        if count == n {\n            result.push(word);\n            word = String::new();\n            count = 0;\n        }\n        if s[i] == ' ' {\n            if word.len() > 0 {\n                result.push(word);\n                word = String::new();\n                count = 0;\n            }\n        } else {\n            word += s[i];\n            count += 1;\n        }\n    }\n    if word.len() > 0 {\n        result.push(word);\n    }\n    return result;\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "error[E0277]: the type `String` cannot be indexed by `char`\n  --> /tmp/tmpua2s5ou9.rs:27:12\n   |\n27 |         if s[i] == ' ' {\n   |            ^^^^ `String` cannot be indexed by `char`\n   |\n   = help: the trait `Index<char>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `char`\n  --> /tmp/tmpua2s5ou9.rs:34:21\n   |\n34 |             word += s[i];\n   |                     ^^^^ `String` cannot be indexed by `char`\n   |\n   = help: the trait `Index<char>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns a vector of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty vector.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n/// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut words: Vec<String> = Vec::new();\n    let mut word: String = String::new();\n    let mut word_count: isize = 0;\n    let mut word_index: isize = 0;\n    let mut word_index_end: isize = 0;\n    let mut word_index_start: isize = 0;\n    let mut word_index_start_end: isize = 0;\n    let mut word_index_start_end_end: isize = 0;\n    let mut word_index_start_end_end_end: isize = 0;\n    let mut word_index_start_end_end_end_end: isize = 0;\n    let mut word_index_start_end_end_end_end_end: isize = 0;\n    let mut word_index_start_end_end_end_end_end_end: isize = 0;\n    let mut word_index_start_end_end_end_end_end_end_end: isize = 0;\n    let mut word_index_start_end_end_end_end_end_end_end_end: isize = 0;\n    let mut word_index_start_end_end_end_end_end_end_end_end_end: isize = 0;\n    let mut word_index_start_end_end_end_end_end_end_end_end_end_end: isize = 0;\n    let mut word_index_start_end_end_end_end_end_end_end_end_end_end_end: isize = 0;\n    let mut word_index_start_end_end_end_end_end_end_end_end_end_end_end_end: isize = 0;\n    let mut word_index_start_end_end_end_end_end_end_end_end_end_end_end_end_end: isize = 0;\n    let mut word_index_start_end_end_end_end_end_end_end_end_end_end_end_end_end_end: isize = 0;\n    let mut word_index_start_\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "error: expected `;`, found `}`\n  --> /tmp/tmpa08_y5tt.rs:38:30\n   |\n38 |     let mut word_index_start_\n   |                              ^ help: add `;` here\n39 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpa08_y5tt.rs:17:41\n   |\n17 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |    ------------                         ^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<String>`\n           found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns a vector of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty vector.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n/// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut result = Vec::new();\n    let mut word = String::new();\n    let mut count = 0;\n    for i in s.chars() {\n        if count == n {\n            result.push(word);\n            word = String::new();\n            count = 0;\n        }\n        if s[i] == ' ' {\n            if word.len() > 0 {\n                result.push(word);\n                word = String::new();\n                count = 0;\n            }\n        } else {\n            word += s[i];\n            count += 1;\n        }\n    }\n    if word.len() > 0 {\n        result.push(word);\n    }\n    return result;\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "error[E0277]: the type `String` cannot be indexed by `char`\n  --> /tmp/tmpua2s5ou9.rs:27:12\n   |\n27 |         if s[i] == ' ' {\n   |            ^^^^ `String` cannot be indexed by `char`\n   |\n   = help: the trait `Index<char>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `char`\n  --> /tmp/tmpua2s5ou9.rs:34:21\n   |\n34 |             word += s[i];\n   |                     ^^^^ `String` cannot be indexed by `char`\n   |\n   = help: the trait `Index<char>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns a vector of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty vector.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n/// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut result = Vec::new();\n    let mut word = String::new();\n    let mut count = 0;\n    let mut i = 0;\n    for i in s.iter() {\n        if i == ' ' {\n            if count == n {\n                result.push(word);\n            }\n            word = String::new();\n            count = 0;\n        } else {\n            word += i;\n            count += 1;\n        }\n    }\n    if count == n {\n        result.push(word);\n    }\n    return result;\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "error[E0599]: no method named `iter` found for struct `String` in the current scope\n  --> /tmp/tmp__e6h22i.rs:22:16\n   |\n22 |     for i in s.iter() {\n   |                ^^^^ method not found in `String`\n   |\nhelp: because of the in-memory representation of `&str`, to obtain an `Iterator` over each of its codepoint use method `chars`\n   |\n22 |     for i in s.chars() {\n   |                ~~~~~\n\nerror[E0277]: can't compare `&str` with `char`\n  --> /tmp/tmp__e6h22i.rs:23:14\n   |\n23 |         if i == ' ' {\n   |              ^^ no implementation for `&str == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for `&str`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n             <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<str>>\n             <String as PartialEq>\n             <str as PartialEq<Cow<'a, str>>>\n           and 4 others\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0599.\nFor more information about an error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns a vector of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty vector.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n/// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n  let mut result = Vec::new();\n  let mut word = String::new();\n  let mut count = 0;\n  for (let c of s) {\n    if (c == ' ') {\n      if (count == n) {\n        result.push(word);\n        word = String::new();\n        count = 0;\n      }\n    } else {\n      word = word.cat(c);\n      count += 1;\n    }\n  }\n  if (count == n) {\n    result.push(word);\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmpu9_l_fje.rs:21:8\n   |\n21 |   for (let c of s) {\n   |        ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `c`\n  --> /tmp/tmpu9_l_fje.rs:21:12\n   |\n21 |   for (let c of s) {\n   |           -^ expected one of `)`, `,`, `@`, or `|`\n   |           |\n   |           help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `of`\n  --> /tmp/tmpu9_l_fje.rs:21:14\n   |\n21 |   for (let c of s) {\n   |             -^^ expected one of `)`, `,`, `@`, or `|`\n   |             |\n   |             help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `s`\n  --> /tmp/tmpu9_l_fje.rs:21:17\n   |\n21 |   for (let c of s) {\n   |                -^ expected one of `)`, `,`, `@`, or `|`\n   |                |\n   |                help: missing `,`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmpu9_l_fje.rs:21:19\n   |\n21 |   for (let c of s) {\n   |                   ^ help: try adding `in` here\n\nerror: expected `{`, found keyword `if`\n  --> /tmp/tmpu9_l_fje.rs:33:3\n   |\n33 |   if (count == n) {\n   |   ^^ expected `{`\n   |\nhelp: try placing this code inside a block\n   |\n33 ~   { if (count == n) {\n34 |     result.push(word);\n35 ~   } }\n   |\n\nerror: aborting due to 6 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns a vector of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty vector.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n/// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut words = Vec::new();\n    let mut word = String::new();\n    let mut word_count = 0;\n    let mut word_index = 0;\n    let mut word_index_end = 0;\n    let mut word_index_start = 0;\n    let mut word_index_start_end = 0;\n    let mut word_index_start_end_end = 0;\n    let mut word_index_start_end_end_end = 0;\n    let mut word_index_start_end_end_end_end = 0;\n    let mut word_index_start_end_end_end_end_end = 0;\n    let mut word_index_start_end_end_end_end_end_end = 0;\n    let mut word_index_start_end_end_end_end_end_end_end = 0;\n    let mut word_index_start_end_end_end_end_end_end_end_end = 0;\n    let mut word_index_start_end_end_end_end_end_end_end_end_end = 0;\n    let mut word_index_start_end_end_end_end_end_end_end_end_end_end = 0;\n    let mut word_index_start_end_end_end_end_end_end_end_end_end_end_end = 0;\n    let mut word_index_start_end_end_end_end_end_end_end_end_end_end_end_end = 0;\n    let mut word_index_start_end_end_end_end_end_end_end_end_end_end_end_end_end = 0;\n    let mut word_index_start_end_end_end_end_end_end_end_end_end_end_end_end_end_end = 0;\n    let mut word_index_start_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end = 0;\n    let mut word_index_start_end_end_end_end_end_end_end_end_end_end\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "error: expected `;`, found `}`\n  --> /tmp/tmpwkh6xpwz.rs:39:69\n   |\n39 |     let mut word_index_start_end_end_end_end_end_end_end_end_end_end\n   |                                                                     ^ help: add `;` here\n40 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpwkh6xpwz.rs:17:41\n   |\n17 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |    ------------                         ^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<String>`\n           found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns a vector of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty vector.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n/// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n  let mut result: Vec<String> = Vec::new();\n  let mut word: String = String::from(\"\");\n  let mut count: isize = 0;\n  for (let i = 0; i < s.len(); i++) {\n    if (s[i] == ' ') {\n      if (count == n) {\n        result.push(word);\n        word = String::from(\"\");\n        count = 0;\n      }\n    } else {\n      if (count == 0) {\n        word = word.concat(s[i]);\n      } else {\n        count += 1;\n      }\n    }\n  }\n  if (count == n) {\n    result.push(word);\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmp9lpw5v15.rs:21:8\n   |\n21 |   for (let i = 0; i < s.len(); i++) {\n   |        ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmp9lpw5v15.rs:21:12\n   |\n21 |   for (let i = 0; i < s.len(); i++) {\n   |           -^ expected one of `)`, `,`, `@`, or `|`\n   |           |\n   |           help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmp9lpw5v15.rs:21:14\n   |\n21 |   for (let i = 0; i < s.len(); i++) {\n   |              ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmp9lpw5v15.rs:21:13\n   |\n21 |   for (let i = 0; i < s.len(); i++) {\n   |             ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmp9lpw5v15.rs:21:14\n   |\n21 |   for (let i = 0; i < s.len(); i++) {\n   |              ^ expected expression\n\nerror: aborting due to 5 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns a vector of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty vector.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n/// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n  let mut words = Vec::new();\n  let mut word = String::new();\n  let mut count = 0;\n  for (let c of s) {\n    if (c == ' ') {\n      if (count == n) {\n        words.push(word);\n        word = String::new();\n        count = 0;\n      }\n    } else {\n      if (count < n) {\n        count += 1;\n        word += c;\n      } else {\n        count = 0;\n        word += c;\n      }\n    }\n  }\n  if (count == n) {\n    words.push(word);\n  }\n  words\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmpcrnj3jw_.rs:21:8\n   |\n21 |   for (let c of s) {\n   |        ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `c`\n  --> /tmp/tmpcrnj3jw_.rs:21:12\n   |\n21 |   for (let c of s) {\n   |           -^ expected one of `)`, `,`, `@`, or `|`\n   |           |\n   |           help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `of`\n  --> /tmp/tmpcrnj3jw_.rs:21:14\n   |\n21 |   for (let c of s) {\n   |             -^^ expected one of `)`, `,`, `@`, or `|`\n   |             |\n   |             help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `s`\n  --> /tmp/tmpcrnj3jw_.rs:21:17\n   |\n21 |   for (let c of s) {\n   |                -^ expected one of `)`, `,`, `@`, or `|`\n   |                |\n   |                help: missing `,`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmpcrnj3jw_.rs:21:19\n   |\n21 |   for (let c of s) {\n   |                   ^ help: try adding `in` here\n\nerror: expected `{`, found keyword `if`\n  --> /tmp/tmpcrnj3jw_.rs:38:3\n   |\n38 |   if (count == n) {\n   |   ^^ expected `{`\n   |\nhelp: try placing this code inside a block\n   |\n38 ~   { if (count == n) {\n39 |     words.push(word);\n40 ~   } }\n   |\n\nerror: aborting due to 6 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns a vector of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty vector.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n/// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut words = Vec::new();\n    let mut word = String::new();\n    let mut i = 0;\n    let mut j = 0;\n    let mut count = 0;\n    while i < s.len() {\n        if s[i] == ' ' {\n            if count == n {\n                words.push(word);\n                word = String::new();\n                count = 0;\n            }\n            i += 1;\n        } else if s[i] == '\\n' {\n            i += 1;\n        } else {\n            word += s[i];\n            count += 1;\n            i += 1;\n        }\n    }\n    if count == n {\n        words.push(word);\n    }\n    return words;\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp1qaoogvy.rs:24:12\n   |\n24 |         if s[i] == ' ' {\n   |            ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp1qaoogvy.rs:31:19\n   |\n31 |         } else if s[i] == '\\n' {\n   |                   ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp1qaoogvy.rs:34:21\n   |\n34 |             word += s[i];\n   |                     ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror: aborting due to 3 previous err",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns a vector of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty vector.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n/// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n  let mut words = Vec::new();\n  let mut word = String::new();\n  let mut count = 0;\n  let mut i = 0;\n  let mut j = 0;\n  let mut k = 0;\n  while i < s.len() {\n    if s[i] == ' ' {\n      if count == n {\n        words.push(word);\n        word = String::new();\n        count = 0;\n      }\n      i += 1;\n      continue;\n    }\n    if s[i] == '\\n' {\n      i += 1;\n      continue;\n    }\n    if s[i] == '\\r' {\n      i += 1;\n      continue;\n    }\n    if s[i] == '\\t' {\n      i += 1;\n      continue;\n    }\n    if s[i] == '\\v' {\n      i += 1;\n      continue;\n    }\n    if s[i] == '\\f' {\n      i += 1;\n      continue;\n    }\n    if s[i] == '\\b' {\n      i += 1;\n      continue;\n    }\n    if s[i] == '\\u00A0' {\n      i += 1;\n      continue;\n    }\n    if s[i] == '\\u0085' {\n      i += 1;\n      continue;\n    }\n    if s[i] == '\\u2028' {\n      i += 1;\n      continue;\n    }\n    if s[i] == '\\u2029' {\n      i += 1;\n      continue;\n    }\n    if s[i] == '\\u0009' {\n      i += 1;\n      continue;\n    }\n    if s[i] == '\\u000A' {\n      i += 1;\n      continue;\n    }\n    if s[i] == '\\u000B' {\n      i += 1;\n      continue;\n    }\n    if s[i] == '\\u000C' {\n      i += 1;\n      continue;\n    }\n    if s[i] == '\\u000D'\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "error: unknown character escape: `v`\n  --> /tmp/tmpy26f7y0_.rs:46:18\n   |\n46 |     if s[i] == '\\v' {\n   |                  ^ unknown character escape\n   |\n   = help: for more information, visit <https://static.rust-lang.org/doc/master/reference.html#literals>\nhelp: if you meant to write a literal backslash (perhaps escaping in a regular expression), consider a raw string literal\n   |\n46 |     if s[i] == r\"\\v\" {\n   |                ~~~~~\n\nerror: unknown character escape: `f`\n  --> /tmp/tmpy26f7y0_.rs:50:18\n   |\n50 |     if s[i] == '\\f' {\n   |                  ^ unknown character escape\n   |\n   = help: for more information, visit <https://static.rust-lang.org/doc/master/reference.html#literals>\nhelp: if you meant to write a literal backslash (perhaps escaping in a regular expression), consider a raw string literal\n   |\n50 |     if s[i] == r\"\\f\" {\n   |                ~~~~~\n\nerror: unknown character escape: `b`\n  --> /tmp/tmpy26f7y0_.rs:54:18\n   |\n54 |     if s[i] == '\\b' {\n   |                  ^ unknown character escape\n   |\n   = help: for more information, visit <https://static.rust-lang.org/doc/master/reference.html#literals>\nhelp: if you meant to write a literal backslash (perhaps escaping in a regular expression), consider a raw string literal\n   |\n54 |     if s[i] == r\"\\b\" {\n   |                ~~~~~\n\nerror: incorrect unicode escape sequence\n  --> /tmp/tmpy26f7y0_.rs:58:17\n   |\n58 |     if s[i] == '\\u00A0' {\n   |                 ^^^---\n   |                 |\n   |                 help: format of unicode escape sequences uses braces: `\\u{00A0}`\n\nerror: incorrect unicode escape sequence\n  --> /tmp/tmpy26f7y0_.rs:62:17\n   |\n62 |     if s[i] == '\\u0085' {\n   |                 ^^^---\n   |                 |\n   |                 help: format of unicode escape sequences uses braces: `\\u{0085}`\n\nerror: incorrect unicode escape sequence\n  --> /tmp/tmpy26f7y0_.rs:66:17\n   |\n66 |     if s[i] == '\\u2028' {\n   |                 ^^^---\n   |                 |\n   |                 help: format of unicode escape sequences uses b",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns a vector of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty vector.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n/// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut words = Vec::new();\n    let mut word = String::new();\n    let mut consonants = 0;\n    let mut consonant_index = 0;\n    let mut consonant_count = 0;\n    let mut consonant_index_end = 0;\n    let mut consonant_count_end = 0;\n    let mut consonant_index_start = 0;\n    let mut consonant_count_start = 0;\n    let mut consonant_index_end_start = 0;\n    let mut consonant_count_end_start = 0;\n    let mut consonant_index_end_end = 0;\n    let mut consonant_count_end_end = 0;\n    let mut consonant_index_start_end = 0;\n    let mut consonant_count_start_end = 0;\n    let mut consonant_index_end_start_end = 0;\n    let mut consonant_count_end_start_end = 0;\n    let mut consonant_index_start_start = 0;\n    let mut consonant_count_start_start = 0;\n    let mut consonant_index_end_start_start = 0;\n    let mut consonant_count_end_start_start = 0;\n    let mut consonant_index_end_end_start = 0;\n    let mut consonant_count_end_end_start = 0;\n    let mut consonant_index_start_end_start = 0;\n    let mut consonant_count_start_end_start = 0;\n    let mut consonant_index_end_start_end = 0;\n    let mut consonant_count_end_start_end = 0;\n    let mut consonant_index_start_start_end = 0;\n    let mut consonant_count_start_start_end = 0;\n    let mut consonant_index_end_start_start = 0;\n    let mut consonant_count_end_start_start = 0;\n    let mut consonant_index_start_end_start = 0;\n    let mut consonant_count_start_end_start = 0;\n    let mut consonant_index_end_end_start = 0;\n\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "error[E0308]: mismatched types\n  --> /tmp/tmp74i3oytk.rs:17:41\n   |\n17 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |    ------------                         ^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<String>`\n           found unit type `()`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns a vector of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty vector.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n/// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut words = Vec::new();\n    let mut word = String::new();\n    let mut count = 0;\n    for i in s.chars() {\n        if count == n {\n            words.push(word);\n            word = String::new();\n            count = 0;\n        }\n        if s[i] == ' ' {\n            count += 1;\n        } else {\n            count += 1;\n            word.push_back(s[i]);\n        }\n    }\n    words.push(word);\n    return words;\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "error[E0277]: the type `String` cannot be indexed by `char`\n  --> /tmp/tmplqedi5ze.rs:27:12\n   |\n27 |         if s[i] == ' ' {\n   |            ^^^^ `String` cannot be indexed by `char`\n   |\n   = help: the trait `Index<char>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0599]: no method named `push_back` found for struct `String` in the current scope\n  --> /tmp/tmplqedi5ze.rs:31:18\n   |\n31 |             word.push_back(s[i]);\n   |                  ^^^^^^^^^ method not found in `String`\n\nerror[E0277]: the type `String` cannot be indexed by `char`\n  --> /tmp/tmplqedi5ze.rs:31:28\n   |\n31 |             word.push_back(s[i]);\n   |                            ^^^^ `String` cannot be indexed by `char`\n   |\n   = help: the trait `Index<char>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0599.\nFor more information about an error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns a vector of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty vector.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n/// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n  let mut result = Vec::new();\n  let mut word = String::new();\n  let mut count = 0;\n  let mut i = 0;\n  for i < s.len() {\n    if s[i] == ' ' {\n      if word.len() > 0 {\n        result.push(word);\n        word = String::new();\n        count = 0;\n      }\n      i++;\n      continue;\n    }\n    if s[i] == '\\n' {\n      i++;\n      continue;\n    }\n    if s[i] == '\\r' {\n      i++;\n      continue;\n    }\n    if s[i] == '\\t' {\n      i++;\n      continue;\n    }\n    if s[i] == '\\v' {\n      i++;\n      continue;\n    }\n    if s[i] == '\\f' {\n      i++;\n      continue;\n    }\n    if s[i] == '\\b' {\n      i++;\n      continue;\n    }\n    if s[i] == '\\a' {\n      i++;\n      continue;\n    }\n    if s[i] == '\\0' {\n      i++;\n      continue;\n    }\n    if s[i] == '\\x0' {\n      i++;\n      continue;\n    }\n    if s[i] == '\\x1' {\n      i++;\n      continue;\n    }\n    if s[i] == '\\x2' {\n      i++;\n      continue;\n    }\n    if s[i] == '\\x3' {\n      i++;\n      continue;\n    }\n    if s[i] == '\\x4' {\n      i++;\n      continue;\n    }\n    if s[i] == '\\x5' {\n      i++;\n      continue;\n    }\n    if s[i] == '\\x6' {\n      i++;\n      continue;\n    }\n    if s[i] == '\\x7' {\n      i++;\n      continue;\n    }\n    if s[i] == '\\x8' {\n      i++;\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "error: unknown character escape: `v`\n  --> /tmp/tmp7_0wd11_.rs:44:18\n   |\n44 |     if s[i] == '\\v' {\n   |                  ^ unknown character escape\n   |\n   = help: for more information, visit <https://static.rust-lang.org/doc/master/reference.html#literals>\nhelp: if you meant to write a literal backslash (perhaps escaping in a regular expression), consider a raw string literal\n   |\n44 |     if s[i] == r\"\\v\" {\n   |                ~~~~~\n\nerror: unknown character escape: `f`\n  --> /tmp/tmp7_0wd11_.rs:48:18\n   |\n48 |     if s[i] == '\\f' {\n   |                  ^ unknown character escape\n   |\n   = help: for more information, visit <https://static.rust-lang.org/doc/master/reference.html#literals>\nhelp: if you meant to write a literal backslash (perhaps escaping in a regular expression), consider a raw string literal\n   |\n48 |     if s[i] == r\"\\f\" {\n   |                ~~~~~\n\nerror: unknown character escape: `b`\n  --> /tmp/tmp7_0wd11_.rs:52:18\n   |\n52 |     if s[i] == '\\b' {\n   |                  ^ unknown character escape\n   |\n   = help: for more information, visit <https://static.rust-lang.org/doc/master/reference.html#literals>\nhelp: if you meant to write a literal backslash (perhaps escaping in a regular expression), consider a raw string literal\n   |\n52 |     if s[i] == r\"\\b\" {\n   |                ~~~~~\n\nerror: unknown character escape: `a`\n  --> /tmp/tmp7_0wd11_.rs:56:18\n   |\n56 |     if s[i] == '\\a' {\n   |                  ^ unknown character escape\n   |\n   = help: for more information, visit <https://static.rust-lang.org/doc/master/reference.html#literals>\nhelp: if you meant to write a literal backslash (perhaps escaping in a regular expression), consider a raw string literal\n   |\n56 |     if s[i] == r\"\\a\" {\n   |                ~~~~~\n\nerror: numeric character escape is too short\n  --> /tmp/tmp7_0wd11_.rs:64:17\n   |\n64 |     if s[i] == '\\x0' {\n   |                 ^^^\n\nerror: numeric character escape is too short\n  --> /tmp/tmp7_0wd11_.rs:68:17\n   |\n68 |     if s[i] == '\\x1' {\n   |                 ^^^\n\nerror: n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns a vector of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty vector.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n/// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n  let mut words: Vec<String> = Vec::new();\n  let mut word: String = String::from(\"\");\n  let mut count: isize = 0;\n  for i in s.chars() {\n    if count == n {\n      words.push(word);\n      word = String::from(\"\");\n      count = 0;\n    }\n    if i.is_upper() {\n      word = word.concat(i);\n      count += 1;\n    }\n  }\n  if count == n {\n    words.push(word);\n  }\n  return words;\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "error[E0599]: no method named `is_upper` found for type `char` in the current scope\n  --> /tmp/tmpxcupg3fl.rs:27:10\n   |\n27 |     if i.is_upper() {\n   |          ^^^^^^^^ help: there is an associated function with a similar name: `is_uppercase`\n\nerror[E0599]: no method named `concat` found for struct `String` in the current scope\n  --> /tmp/tmpxcupg3fl.rs:28:19\n   |\n28 |       word = word.concat(i);\n   |                   ^^^^^^ method not found in `String`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns a vector of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty vector.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n/// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut result: Vec<String> = Vec::new();\n    let mut word: String = String::new();\n    let mut count: usize = 0;\n    for i in s.chars() {\n        if count == n {\n            result.push(word);\n            word = String::new();\n            count = 0;\n        }\n        if s[i] == ' ' {\n            if word.len() > 0 {\n                count += 1;\n            }\n        } else {\n            word += s[i];\n            count += 1;\n        }\n    }\n    if word.len() > 0 {\n        result.push(word);\n    }\n    return result;\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "error[E0308]: mismatched types\n  --> /tmp/tmp5c74wo6k.rs:22:21\n   |\n22 |         if count == n {\n   |                     ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic if the converted value doesn't fit\n   |\n22 |         if count == n.try_into().unwrap() {\n   |                      ++++++++++++++++++++\n\nerror[E0277]: the type `String` cannot be indexed by `char`\n  --> /tmp/tmp5c74wo6k.rs:27:12\n   |\n27 |         if s[i] == ' ' {\n   |            ^^^^ `String` cannot be indexed by `char`\n   |\n   = help: the trait `Index<char>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `char`\n  --> /tmp/tmp5c74wo6k.rs:32:21\n   |\n32 |             word += s[i];\n   |                     ^^^^ `String` cannot be indexed by `char`\n   |\n   = help: the trait `Index<char>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns a vector of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty vector.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n/// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut words: Vec<String> = Vec::new();\n    let mut word: String = String::from(\"\");\n    let mut word_count: isize = 0;\n    for i in s.chars() {\n        if word_count == n {\n            words.push(word);\n            word = String::from(\"\");\n            word_count = 0;\n        }\n        if i.is_space() {\n            if !word.is_empty() {\n                words.push(word);\n                word = String::from(\"\");\n                word_count = 0;\n            }\n        } else {\n            word = word.concat(String::from(i));\n            word_count += 1;\n        }\n    }\n    if !word.is_empty() {\n        words.push(word);\n    }\n    return words;\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "error[E0599]: no method named `is_space` found for type `char` in the current scope\n  --> /tmp/tmpeir1gopr.rs:27:14\n   |\n27 |         if i.is_space() {\n   |              ^^^^^^^^ help: there is an associated function with a similar name: `is_whitespace`\n\nerror[E0599]: no method named `concat` found for struct `String` in the current scope\n  --> /tmp/tmpeir1gopr.rs:34:25\n   |\n34 |             word = word.concat(String::from(i));\n   |                         ^^^^^^ method not found in `String`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns a vector of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty vector.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n/// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n  let mut words = Vec::new();\n  let mut word = String::new();\n  let mut consonants = 0;\n  for i in s.chars() {\n    if consonants == n {\n      words.push(word);\n      word = String::new();\n      consonants = 0;\n    }\n    if !is_consonant(i) {\n      consonants += 1;\n    }\n    if consonants == n {\n      words.push(word);\n      word = String::new();\n      consonants = 0;\n    }\n    if consonants > n {\n      break;\n    }\n  }\n  words.push(word);\n  return words;\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "error[E0425]: cannot find function `is_consonant` in this scope\n  --> /tmp/tmpurn7iujr.rs:27:9\n   |\n27 |     if !is_consonant(i) {\n   |         ^^^^^^^^^^^^ help: a local variable with a similar name exists: `consonants`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns a vector of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty vector.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n/// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut words = Vec::new();\n    let mut word = String::new();\n    let mut word_count = 0;\n    let mut word_index = 0;\n    let mut word_index_end = 0;\n    let mut word_index_start = 0;\n    let mut word_index_start_end = 0;\n    let mut word_index_start_end_end = 0;\n    let mut word_index_start_end_end_end = 0;\n    let mut word_index_start_end_end_end_end = 0;\n    let mut word_index_start_end_end_end_end_end = 0;\n    let mut word_index_start_end_end_end_end_end_end = 0;\n    let mut word_index_start_end_end_end_end_end_end_end = 0;\n    let mut word_index_start_end_end_end_end_end_end_end_end = 0;\n    let mut word_index_start_end_end_end_end_end_end_end_end_end = 0;\n    let mut word_index_start_end_end_end_end_end_end_end_end_end_end = 0;\n    let mut word_index_start_end_end_end_end_end_end_end_end_end_end_end = 0;\n    let mut word_index_start_end_end_end_end_end_end_end_end_end_end_end_end = 0;\n    let mut word_index_start_end_end_end_end_end_end_end_end_end_end_end_end_end = 0;\n    let mut word_index_start_end_end_end_end_end_end_end_end_end_end_end_end_end_end = 0;\n    let mut word_index_start_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end = 0;\n    let mut word_index_start_end_end_end_end_end_end_end_end_end_end\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "error: expected `;`, found `}`\n  --> /tmp/tmpwkh6xpwz.rs:39:69\n   |\n39 |     let mut word_index_start_end_end_end_end_end_end_end_end_end_end\n   |                                                                     ^ help: add `;` here\n40 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpwkh6xpwz.rs:17:41\n   |\n17 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |    ------------                         ^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<String>`\n           found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns a vector of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty vector.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n/// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n  let mut words = Vec::new();\n  let mut word = String::new();\n  let mut word_count = 0;\n  for i in s.chars() {\n    if word_count == n {\n      words.push(word);\n      word = String::new();\n      word_count = 0;\n    }\n    if s[i] == ' ' {\n      if word_count > 0 {\n        words.push(word);\n        word = String::new();\n        word_count = 0;\n      }\n    } else {\n      word = word.concat(String::from(s[i]));\n      word_count += 1;\n    }\n  }\n  if word_count > 0 {\n    words.push(word);\n  }\n  return words;\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "error[E0277]: the type `String` cannot be indexed by `char`\n  --> /tmp/tmp3psyoa44.rs:27:8\n   |\n27 |     if s[i] == ' ' {\n   |        ^^^^ `String` cannot be indexed by `char`\n   |\n   = help: the trait `Index<char>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0599]: no method named `concat` found for struct `String` in the current scope\n  --> /tmp/tmp3psyoa44.rs:34:19\n   |\n34 |       word = word.concat(String::from(s[i]));\n   |                   ^^^^^^ method not found in `String`\n\nerror[E0277]: the type `String` cannot be indexed by `char`\n  --> /tmp/tmp3psyoa44.rs:34:39\n   |\n34 |       word = word.concat(String::from(s[i]));\n   |                                       ^^^^ `String` cannot be indexed by `char`\n   |\n   = help: the trait `Index<char>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0599.\nFor more information about an error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns a vector of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty vector.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n/// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n  let mut words = Vec::new();\n  let mut word = String::new();\n  let mut word_count = 0;\n  let mut word_index = 0;\n  let mut word_index_end = 0;\n  let mut word_index_start = 0;\n  let mut word_index_start_end = 0;\n  let mut word_index_start_end_end = 0;\n  let mut word_index_start_end_end_end = 0;\n  let mut word_index_start_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end_end_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end_end_end_end\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "error: expected `;`, found `}`\n  --> /tmp/tmpkoz4q7r5.rs:39:67\n   |\n39 |   let mut word_index_start_end_end_end_end_end_end_end_end_end_end\n   |                                                                   ^ help: add `;` here\n40 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpkoz4q7r5.rs:17:41\n   |\n17 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |    ------------                         ^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<String>`\n           found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns a vector of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty vector.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n/// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut words = Vec::new();\n    let mut word = String::new();\n    let mut word_count = 0;\n    let mut word_index = 0;\n    let mut word_index_end = 0;\n    let mut word_index_start = 0;\n    let mut word_index_start_end = 0;\n    let mut word_index_start_end_end = 0;\n    let mut word_index_start_end_end_end = 0;\n    let mut word_index_start_end_end_end_end = 0;\n    let mut word_index_start_end_end_end_end_end = 0;\n    let mut word_index_start_end_end_end_end_end_end = 0;\n    let mut word_index_start_end_end_end_end_end_end_end = 0;\n    let mut word_index_start_end_end_end_end_end_end_end_end = 0;\n    let mut word_index_start_end_end_end_end_end_end_end_end_end = 0;\n    let mut word_index_start_end_end_end_end_end_end_end_end_end_end = 0;\n    let mut word_index_start_end_end_end_end_end_end_end_end_end_end_end = 0;\n    let mut word_index_start_end_end_end_end_end_end_end_end_end_end_end_end = 0;\n    let mut word_index_start_end_end_end_end_end_end_end_end_end_end_end_end_end = 0;\n    let mut word_index_start_end_end_end_end_end_end_end_end_end_end_end_end_end_end = 0;\n    let mut word_index_start_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end = 0;\n    let mut word_index_start_end_end_end_end_end_end_end_end_end_end\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "error: expected `;`, found `}`\n  --> /tmp/tmpwkh6xpwz.rs:39:69\n   |\n39 |     let mut word_index_start_end_end_end_end_end_end_end_end_end_end\n   |                                                                     ^ help: add `;` here\n40 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpwkh6xpwz.rs:17:41\n   |\n17 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |    ------------                         ^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<String>`\n           found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns a vector of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty vector.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n/// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n  let mut result = Vec::new();\n  let mut word = String::new();\n  let mut count = 0;\n  for (let i = 0; i < s.len(); i++) {\n    if (s[i] == ' ') {\n      if (count == n) {\n        result.push(word);\n        word = String::new();\n        count = 0;\n      }\n    } else {\n      word += s[i];\n      count += 1;\n    }\n  }\n  if (count == n) {\n    result.push(word);\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmpc8pj2kwx.rs:21:8\n   |\n21 |   for (let i = 0; i < s.len(); i++) {\n   |        ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmpc8pj2kwx.rs:21:12\n   |\n21 |   for (let i = 0; i < s.len(); i++) {\n   |           -^ expected one of `)`, `,`, `@`, or `|`\n   |           |\n   |           help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmpc8pj2kwx.rs:21:14\n   |\n21 |   for (let i = 0; i < s.len(); i++) {\n   |              ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmpc8pj2kwx.rs:21:13\n   |\n21 |   for (let i = 0; i < s.len(); i++) {\n   |             ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmpc8pj2kwx.rs:21:14\n   |\n21 |   for (let i = 0; i < s.len(); i++) {\n   |              ^ expected expression\n\nerror: aborting due to 5 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns a vector of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty vector.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n/// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n  let mut words = Vec::new();\n  let mut word = String::new();\n  let mut consonants = 0;\n  let mut consonant_index = 0;\n  let mut consonant_count = 0;\n  let mut consonant_count_index = 0;\n  let mut consonant_count_count = 0;\n  let mut consonant_count_count_index = 0;\n  let mut consonant_count_count_count = 0;\n  let mut consonant_count_count_count_index = 0;\n  let mut consonant_count_count_count_count = 0;\n  let mut consonant_count_count_count_count_index = 0;\n  let mut consonant_count_count_count_count_count = 0;\n  let mut consonant_count_count_count_count_count_index = 0;\n  let mut consonant_count_count_count_count_count_count = 0;\n  let mut consonant_count_count_count_count_count_count_index = 0;\n  let mut consonant_count_count_count_count_count_count_count = 0;\n  let mut consonant_count_count_count_count_count_count_count_index = 0;\n  let mut consonant_count_count_count_count_count_count_count_count = 0;\n  let mut consonant_count_count_count_count_count_count_count_count_index = 0;\n  let mut consonant_count_count_count_count_count_count_count_count_count = 0;\n  let mut consonant_count_count_count_count_count_count_count_count_count_index = 0;\n  let mut consonant_count_count_count_count_count_count_count_count_count_count = 0;\n  let mut consonant_count_count_count_count_count_count_count_count_count_count_index = 0;\n  let mut consonant_count_count_count_count_count_count_count_count_count_count_count = 0;\n  let mut consonant_count_count_count_count_count_count_count_count\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "error: expected `;`, found `}`\n  --> /tmp/tmp_jj1vug4.rs:43:68\n   |\n43 |   let mut consonant_count_count_count_count_count_count_count_count\n   |                                                                    ^ help: add `;` here\n44 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp_jj1vug4.rs:17:41\n   |\n17 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |    ------------                         ^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<String>`\n           found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns a vector of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty vector.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n/// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut result = Vec::new();\n    let mut word = String::new();\n    let mut word_count = 0;\n    let mut word_index = 0;\n    let mut word_index_end = 0;\n    let mut word_index_start = 0;\n    let mut word_index_start_end = 0;\n    let mut word_index_start_end_end = 0;\n    let mut word_index_start_end_end_end = 0;\n    let mut word_index_start_end_end_end_end = 0;\n    let mut word_index_start_end_end_end_end_end = 0;\n    let mut word_index_start_end_end_end_end_end_end = 0;\n    let mut word_index_start_end_end_end_end_end_end_end = 0;\n    let mut word_index_start_end_end_end_end_end_end_end_end = 0;\n    let mut word_index_start_end_end_end_end_end_end_end_end_end = 0;\n    let mut word_index_start_end_end_end_end_end_end_end_end_end_end = 0;\n    let mut word_index_start_end_end_end_end_end_end_end_end_end_end_end = 0;\n    let mut word_index_start_end_end_end_end_end_end_end_end_end_end_end_end = 0;\n    let mut word_index_start_end_end_end_end_end_end_end_end_end_end_end_end_end = 0;\n    let mut word_index_start_end_end_end_end_end_end_end_end_end_end_end_end_end_end = 0;\n    let mut word_index_start_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end = 0;\n    let mut word_index_start_end_end_end_end_end_end_end_end_end_end\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "error: expected `;`, found `}`\n  --> /tmp/tmpg8cknv_2.rs:39:69\n   |\n39 |     let mut word_index_start_end_end_end_end_end_end_end_end_end_end\n   |                                                                     ^ help: add `;` here\n40 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpg8cknv_2.rs:17:41\n   |\n17 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |    ------------                         ^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<String>`\n           found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns a vector of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty vector.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n/// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n  let mut words = Vec::new();\n  let mut word = String::new();\n  let mut consonants = 0;\n  for (let i = 0; i < s.len(); i++) {\n    if (s[i] == ' ') {\n      if (consonants == n) {\n        words.push(word);\n        word = String::new();\n        consonants = 0;\n      }\n    } else {\n      if (s[i] == 'a' || s[i] == 'e' || s[i] == 'i' || s[i] == 'o' || s[i] == 'u') {\n        consonants += 1;\n      }\n      word.push_back(s[i]);\n    }\n  }\n  if (consonants == n) {\n    words.push(word);\n  }\n  return words;\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmp43dlub8y.rs:21:8\n   |\n21 |   for (let i = 0; i < s.len(); i++) {\n   |        ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmp43dlub8y.rs:21:12\n   |\n21 |   for (let i = 0; i < s.len(); i++) {\n   |           -^ expected one of `)`, `,`, `@`, or `|`\n   |           |\n   |           help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmp43dlub8y.rs:21:14\n   |\n21 |   for (let i = 0; i < s.len(); i++) {\n   |              ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmp43dlub8y.rs:21:13\n   |\n21 |   for (let i = 0; i < s.len(); i++) {\n   |             ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmp43dlub8y.rs:21:14\n   |\n21 |   for (let i = 0; i < s.len(); i++) {\n   |              ^ expected expression\n\nerror: aborting due to 5 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns a vector of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty vector.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n/// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n  let mut words = Vec::new();\n  let mut word = String::new();\n  let mut count = 0;\n  for (let c of s) {\n    if (c == ' ') {\n      if (count == n) {\n        words.push(word);\n        word = String::new();\n        count = 0;\n      }\n    } else {\n      if (count < n) {\n        count += 1;\n        word += c;\n      } else {\n        words.push(word);\n        word = String::new();\n        count = 0;\n        word += c;\n      }\n    }\n  }\n  words.push(word);\n  return words;\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmpq_vvwxzh.rs:21:8\n   |\n21 |   for (let c of s) {\n   |        ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `c`\n  --> /tmp/tmpq_vvwxzh.rs:21:12\n   |\n21 |   for (let c of s) {\n   |           -^ expected one of `)`, `,`, `@`, or `|`\n   |           |\n   |           help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `of`\n  --> /tmp/tmpq_vvwxzh.rs:21:14\n   |\n21 |   for (let c of s) {\n   |             -^^ expected one of `)`, `,`, `@`, or `|`\n   |             |\n   |             help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `s`\n  --> /tmp/tmpq_vvwxzh.rs:21:17\n   |\n21 |   for (let c of s) {\n   |                -^ expected one of `)`, `,`, `@`, or `|`\n   |                |\n   |                help: missing `,`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmpq_vvwxzh.rs:21:19\n   |\n21 |   for (let c of s) {\n   |                   ^ help: try adding `in` here\n\nerror: expected `{`, found `words`\n  --> /tmp/tmpq_vvwxzh.rs:40:3\n   |\n40 |   words.push(word);\n   |   ^^^^^ expected `{`\n   |\nhelp: try placing this code inside a block\n   |\n40 |   { words.push(word); }\n   |   +                   +\n\nerror: aborting due to 6 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns a vector of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty vector.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n/// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n  let mut words = Vec::new();\n  let mut word = String::new();\n  let mut count = 0;\n  let mut i = 0;\n  while i < s.len() {\n    if s[i] == ' ' {\n      if count == n {\n        words.push(word);\n        word = String::new();\n        count = 0;\n      }\n      i++;\n    } else {\n      word = word.cat(s[i]);\n      count += 1;\n      i += 1;\n    }\n  }\n  if count == n {\n    words.push(word);\n  }\n  return words;\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "error: Rust has no postfix increment operator\n  --> /tmp/tmpnv3uabzh.rs:29:8\n   |\n29 |       i++;\n   |        ^^ not a valid postfix operator\n   |\nhelp: use `+= 1` instead\n   |\n29 |       { let tmp = i; i += 1; tmp };\n   |       +++++++++++  ~~~~~~~~~~~~~~~\n29 -       i++;\n29 +       i += 1;\n   | \n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpnv3uabzh.rs:23:8\n   |\n23 |     if s[i] == ' ' {\n   |        ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0599]: no method named `cat` found for struct `String` in the current scope\n  --> /tmp/tmpnv3uabzh.rs:31:19\n   |\n31 |       word = word.cat(s[i]);\n   |                   ^^^ method not found in `String`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpnv3uabzh.rs:31:23\n   |\n31 |       word = word.cat(s[i]);\n   |                       ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations: E0277, E0599.\nFor more information about an error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns a vector of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty vector.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n/// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut words = Vec::new();\n    let mut word = String::new();\n    let mut word_count = 0;\n    let mut word_index = 0;\n    let mut word_index_end = 0;\n    let mut word_index_start = 0;\n    let mut word_index_start_end = 0;\n    let mut word_index_start_end_end = 0;\n    let mut word_index_start_end_end_end = 0;\n    let mut word_index_start_end_end_end_end = 0;\n    let mut word_index_start_end_end_end_end_end = 0;\n    let mut word_index_start_end_end_end_end_end_end = 0;\n    let mut word_index_start_end_end_end_end_end_end_end = 0;\n    let mut word_index_start_end_end_end_end_end_end_end_end = 0;\n    let mut word_index_start_end_end_end_end_end_end_end_end_end = 0;\n    let mut word_index_start_end_end_end_end_end_end_end_end_end_end = 0;\n    let mut word_index_start_end_end_end_end_end_end_end_end_end_end_end = 0;\n    let mut word_index_start_end_end_end_end_end_end_end_end_end_end_end_end = 0;\n    let mut word_index_start_end_end_end_end_end_end_end_end_end_end_end_end_end = 0;\n    let mut word_index_start_end_end_end_end_end_end_end_end_end_end_end_end_end_end = 0;\n    let mut word_index_start_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end = 0;\n    let mut word_index_start_end_end_end_end_end_end_end_end_end_end\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "error: expected `;`, found `}`\n  --> /tmp/tmpwkh6xpwz.rs:39:69\n   |\n39 |     let mut word_index_start_end_end_end_end_end_end_end_end_end_end\n   |                                                                     ^ help: add `;` here\n40 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpwkh6xpwz.rs:17:41\n   |\n17 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |    ------------                         ^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<String>`\n           found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns a vector of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty vector.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n/// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n  let mut words: Vec<String> = Vec::new();\n  let mut word: String = String::new();\n  let mut word_count: usize = 0;\n  for i in s.chars() {\n    if word_count == n {\n      words.push(word);\n      word = String::new();\n      word_count = 0;\n    }\n    if i == ' ' {\n      continue;\n    }\n    if !word.is_empty() {\n      word_count += 1;\n    }\n    word.push_back(i);\n  }\n  if !word.is_empty() {\n    words.push(word);\n  }\n  return words;\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "error[E0308]: mismatched types\n  --> /tmp/tmp4sadvbcl.rs:22:22\n   |\n22 |     if word_count == n {\n   |                      ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic if the converted value doesn't fit\n   |\n22 |     if word_count == n.try_into().unwrap() {\n   |                       ++++++++++++++++++++\n\nerror[E0599]: no method named `push_back` found for struct `String` in the current scope\n  --> /tmp/tmp4sadvbcl.rs:33:10\n   |\n33 |     word.push_back(i);\n   |          ^^^^^^^^^ method not found in `String`\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns a vector of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty vector.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n/// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n  let mut words = Vec::new();\n  let mut word = String::new();\n  let mut i = 0;\n  let mut j = 0;\n  let mut count = 0;\n  while i < s.len() {\n    if s[i] == ' ' {\n      if count == n {\n        words.push(word);\n        word = String::new();\n        count = 0;\n      }\n      i += 1;\n      continue;\n    }\n    if s[i] == '\\n' {\n      i += 1;\n      continue;\n    }\n    if s[i] == '\\r' {\n      i += 1;\n      continue;\n    }\n    if s[i] == '\\t' {\n      i += 1;\n      continue;\n    }\n    if s[i] == '\\v' {\n      i += 1;\n      continue;\n    }\n    if s[i] == '\\f' {\n      i += 1;\n      continue;\n    }\n    if s[i] == '\\b' {\n      i += 1;\n      continue;\n    }\n    if s[i] == '\\u00A0' {\n      i += 1;\n      continue;\n    }\n    if s[i] == '\\u2007' {\n      i += 1;\n      continue;\n    }\n    if s[i] == '\\u202F' {\n      i += 1;\n      continue;\n    }\n    if s[i] == '\\u3000' {\n      i += 1;\n      continue;\n    }\n    if s[i] == '\\uFF01' {\n      i += 1;\n      continue;\n    }\n    if s[i] == '\\uFF02' {\n      i += 1;\n      continue;\n    }\n    if s[i] == '\\uFF03' {\n      i += 1;\n      continue;\n    }\n    if s[i] == '\\uFF04' {\n      i += 1;\n      continue;\n    }\n    if s[i] == '\\uFF05' {\n      i += 1;\n      continue\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "error: unknown character escape: `v`\n  --> /tmp/tmpu7uvvzhb.rs:45:18\n   |\n45 |     if s[i] == '\\v' {\n   |                  ^ unknown character escape\n   |\n   = help: for more information, visit <https://static.rust-lang.org/doc/master/reference.html#literals>\nhelp: if you meant to write a literal backslash (perhaps escaping in a regular expression), consider a raw string literal\n   |\n45 |     if s[i] == r\"\\v\" {\n   |                ~~~~~\n\nerror: unknown character escape: `f`\n  --> /tmp/tmpu7uvvzhb.rs:49:18\n   |\n49 |     if s[i] == '\\f' {\n   |                  ^ unknown character escape\n   |\n   = help: for more information, visit <https://static.rust-lang.org/doc/master/reference.html#literals>\nhelp: if you meant to write a literal backslash (perhaps escaping in a regular expression), consider a raw string literal\n   |\n49 |     if s[i] == r\"\\f\" {\n   |                ~~~~~\n\nerror: unknown character escape: `b`\n  --> /tmp/tmpu7uvvzhb.rs:53:18\n   |\n53 |     if s[i] == '\\b' {\n   |                  ^ unknown character escape\n   |\n   = help: for more information, visit <https://static.rust-lang.org/doc/master/reference.html#literals>\nhelp: if you meant to write a literal backslash (perhaps escaping in a regular expression), consider a raw string literal\n   |\n53 |     if s[i] == r\"\\b\" {\n   |                ~~~~~\n\nerror: incorrect unicode escape sequence\n  --> /tmp/tmpu7uvvzhb.rs:57:17\n   |\n57 |     if s[i] == '\\u00A0' {\n   |                 ^^^---\n   |                 |\n   |                 help: format of unicode escape sequences uses braces: `\\u{00A0}`\n\nerror: incorrect unicode escape sequence\n  --> /tmp/tmpu7uvvzhb.rs:61:17\n   |\n61 |     if s[i] == '\\u2007' {\n   |                 ^^^---\n   |                 |\n   |                 help: format of unicode escape sequences uses braces: `\\u{2007}`\n\nerror: incorrect unicode escape sequence\n  --> /tmp/tmpu7uvvzhb.rs:65:17\n   |\n65 |     if s[i] == '\\u202F' {\n   |                 ^^^---\n   |                 |\n   |                 help: format of unicode escape sequences uses b",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns a vector of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty vector.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n/// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut words = Vec::new();\n    let mut word = String::new();\n    let mut count = 0;\n    let mut i = 0;\n    let mut j = 0;\n    let mut k = 0;\n    while i < s.len() {\n        if s[i] == ' ' {\n            if count == n {\n                words.push(word);\n                word = String::new();\n                count = 0;\n            }\n            i += 1;\n            continue;\n        }\n        if s[i] == '\\n' {\n            i += 1;\n            continue;\n        }\n        if s[i] == '\\r' {\n            i += 1;\n            continue;\n        }\n        if s[i] == '\\t' {\n            i += 1;\n            continue;\n        }\n        if s[i] == '\\b' {\n            i += 1;\n            continue;\n        }\n        if s[i] == '\\f' {\n            i += 1;\n            continue;\n        }\n        if s[i] == '\\v' {\n            i += 1;\n            continue;\n        }\n        if s[i] == '\\u00A0' {\n            i += 1;\n            continue;\n        }\n        if s[i] == '\\u2007' {\n            i += 1;\n            continue;\n        }\n        if s[i] == '\\u202F' {\n            i += 1;\n            continue;\n        }\n        if s[i] == '\\u3000' {\n            i += 1;\n            continue;\n        }\n        if s[i] == '\\uFF0D' {\n            i += 1;\n            continue;\n        }\n        if s[i] == '\\u3001' {\n            i += 1;\n            continue;\n        }\n        if s[i] == '\\u3002' {\n            i += 1;\n            continue;\n        }\n        if s[i] == '\\u3003' {\n            i += 1;\n            continue;\n        }\n        if s[i] == '\\u3004' {\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "error: unknown character escape: `b`\n  --> /tmp/tmpfcsv11iv.rs:46:22\n   |\n46 |         if s[i] == '\\b' {\n   |                      ^ unknown character escape\n   |\n   = help: for more information, visit <https://static.rust-lang.org/doc/master/reference.html#literals>\nhelp: if you meant to write a literal backslash (perhaps escaping in a regular expression), consider a raw string literal\n   |\n46 |         if s[i] == r\"\\b\" {\n   |                    ~~~~~\n\nerror: unknown character escape: `f`\n  --> /tmp/tmpfcsv11iv.rs:50:22\n   |\n50 |         if s[i] == '\\f' {\n   |                      ^ unknown character escape\n   |\n   = help: for more information, visit <https://static.rust-lang.org/doc/master/reference.html#literals>\nhelp: if you meant to write a literal backslash (perhaps escaping in a regular expression), consider a raw string literal\n   |\n50 |         if s[i] == r\"\\f\" {\n   |                    ~~~~~\n\nerror: unknown character escape: `v`\n  --> /tmp/tmpfcsv11iv.rs:54:22\n   |\n54 |         if s[i] == '\\v' {\n   |                      ^ unknown character escape\n   |\n   = help: for more information, visit <https://static.rust-lang.org/doc/master/reference.html#literals>\nhelp: if you meant to write a literal backslash (perhaps escaping in a regular expression), consider a raw string literal\n   |\n54 |         if s[i] == r\"\\v\" {\n   |                    ~~~~~\n\nerror: incorrect unicode escape sequence\n  --> /tmp/tmpfcsv11iv.rs:58:21\n   |\n58 |         if s[i] == '\\u00A0' {\n   |                     ^^^---\n   |                     |\n   |                     help: format of unicode escape sequences uses braces: `\\u{00A0}`\n\nerror: incorrect unicode escape sequence\n  --> /tmp/tmpfcsv11iv.rs:62:21\n   |\n62 |         if s[i] == '\\u2007' {\n   |                     ^^^---\n   |                     |\n   |                     help: format of unicode escape sequences uses braces: `\\u{2007}`\n\nerror: incorrect unicode escape sequence\n  --> /tmp/tmpfcsv11iv.rs:66:21\n   |\n66 |         if s[i] == '\\u202F' {\n   |                     ^^^---\n   ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns a vector of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty vector.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n/// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n  let mut words = Vec::new();\n  let mut word = String::new();\n  let mut count = 0;\n  let mut i = 0;\n  while i < s.len() {\n    if s[i] == ' ' {\n      if count == n {\n        words.push(word);\n        word = String::new();\n        count = 0;\n      }\n      i++;\n    } else {\n      word.push_back(s[i]);\n      count++;\n      i++;\n    }\n  }\n  if count == n {\n    words.push(word);\n  }\n  return words;\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "error: Rust has no postfix increment operator\n  --> /tmp/tmpsl0og402.rs:29:8\n   |\n29 |       i++;\n   |        ^^ not a valid postfix operator\n   |\nhelp: use `+= 1` instead\n   |\n29 |       { let tmp = i; i += 1; tmp };\n   |       +++++++++++  ~~~~~~~~~~~~~~~\n29 -       i++;\n29 +       i += 1;\n   | \n\nerror: Rust has no postfix increment operator\n  --> /tmp/tmpsl0og402.rs:32:12\n   |\n32 |       count++;\n   |            ^^ not a valid postfix operator\n   |\nhelp: use `+= 1` instead\n   |\n32 |       { let tmp = count; count += 1; tmp };\n   |       +++++++++++      ~~~~~~~~~~~~~~~~~~~\n32 -       count++;\n32 +       count += 1;\n   | \n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpsl0og402.rs:23:8\n   |\n23 |     if s[i] == ' ' {\n   |        ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0599]: no method named `push_back` found for struct `String` in the current scope\n  --> /tmp/tmpsl0og402.rs:31:12\n   |\n31 |       word.push_back(s[i]);\n   |            ^^^^^^^^^ method not found in `String`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpsl0og402.rs:31:22\n   |\n31 |       word.push_back(s[i]);\n   |                      ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <S",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns a vector of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty vector.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n/// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut words: Vec<String> = Vec::new();\n    let mut word: String = String::new();\n    let mut count: isize = 0;\n    for i in s.chars() {\n        if count == n {\n            words.push(word);\n            word = String::new();\n            count = 0;\n        }\n        if s[i] == ' ' {\n            continue;\n        }\n        if s[i] == '\\n' {\n            continue;\n        }\n        if s[i] == '\\r' {\n            continue;\n        }\n        if s[i] == '\\t' {\n            continue;\n        }\n        if s[i] == '\\v' {\n            continue;\n        }\n        if s[i] == '\\f' {\n            continue;\n        }\n        if s[i] == '\\b' {\n            continue;\n        }\n        if s[i] == '\\u00A0' {\n            continue;\n        }\n        if s[i] == '\\u2007' {\n            continue;\n        }\n        if s[i] == '\\u202F' {\n            continue;\n        }\n        if s[i] == '\\u3000' {\n            continue;\n        }\n        if s[i] == '\\uFF0D' {\n            continue;\n        }\n        if s[i] == '\\uFF0E' {\n            continue;\n        }\n        if s[i] == '\\uFF0F' {\n            continue;\n        }\n        if s[i] == '\\uFF1A' {\n            continue;\n        }\n        if s[i] == '\\uFF1B' {\n            continue;\n        }\n        if s[i] == '\\uFF1C' {\n            continue;\n        }\n        if s[i] == '\\uFF1D' {\n            continue;\n        }\n        if s[i] == '\\uFF1E' {\n            continue;\n        }\n        if s[i] == '\\uFF1F' {\n            continue;\n        }\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "error: unknown character escape: `v`\n  --> /tmp/tmp1192s4lw.rs:39:22\n   |\n39 |         if s[i] == '\\v' {\n   |                      ^ unknown character escape\n   |\n   = help: for more information, visit <https://static.rust-lang.org/doc/master/reference.html#literals>\nhelp: if you meant to write a literal backslash (perhaps escaping in a regular expression), consider a raw string literal\n   |\n39 |         if s[i] == r\"\\v\" {\n   |                    ~~~~~\n\nerror: unknown character escape: `f`\n  --> /tmp/tmp1192s4lw.rs:42:22\n   |\n42 |         if s[i] == '\\f' {\n   |                      ^ unknown character escape\n   |\n   = help: for more information, visit <https://static.rust-lang.org/doc/master/reference.html#literals>\nhelp: if you meant to write a literal backslash (perhaps escaping in a regular expression), consider a raw string literal\n   |\n42 |         if s[i] == r\"\\f\" {\n   |                    ~~~~~\n\nerror: unknown character escape: `b`\n  --> /tmp/tmp1192s4lw.rs:45:22\n   |\n45 |         if s[i] == '\\b' {\n   |                      ^ unknown character escape\n   |\n   = help: for more information, visit <https://static.rust-lang.org/doc/master/reference.html#literals>\nhelp: if you meant to write a literal backslash (perhaps escaping in a regular expression), consider a raw string literal\n   |\n45 |         if s[i] == r\"\\b\" {\n   |                    ~~~~~\n\nerror: incorrect unicode escape sequence\n  --> /tmp/tmp1192s4lw.rs:48:21\n   |\n48 |         if s[i] == '\\u00A0' {\n   |                     ^^^---\n   |                     |\n   |                     help: format of unicode escape sequences uses braces: `\\u{00A0}`\n\nerror: incorrect unicode escape sequence\n  --> /tmp/tmp1192s4lw.rs:51:21\n   |\n51 |         if s[i] == '\\u2007' {\n   |                     ^^^---\n   |                     |\n   |                     help: format of unicode escape sequences uses braces: `\\u{2007}`\n\nerror: incorrect unicode escape sequence\n  --> /tmp/tmp1192s4lw.rs:54:21\n   |\n54 |         if s[i] == '\\u202F' {\n   |                     ^^^---\n   ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns a vector of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty vector.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n/// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n  let mut words = Vec::new();\n  let mut word = String::new();\n  let mut count = 0;\n  let mut i = 0;\n  while i < s.len() {\n    if s[i] == ' ' {\n      if count == n {\n        words.push(word);\n        word = String::new();\n        count = 0;\n      }\n      i += 1;\n    } else {\n      word += s[i];\n      count += 1;\n      i += 1;\n    }\n  }\n  if count == n {\n    words.push(word);\n  }\n  return words;\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp29mlqcyq.rs:23:8\n   |\n23 |     if s[i] == ' ' {\n   |        ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp29mlqcyq.rs:31:15\n   |\n31 |       word += s[i];\n   |               ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns a vector of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty vector.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n/// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n  let mut words = Vec::new();\n  let mut word = String::new();\n  let mut word_count = 0;\n  let mut word_index = 0;\n  let mut word_index_end = 0;\n  let mut word_index_start = 0;\n  let mut word_index_start_end = 0;\n  let mut word_index_start_end_end = 0;\n  let mut word_index_start_end_end_end = 0;\n  let mut word_index_start_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end_end_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end_end_end_end\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "error: expected `;`, found `}`\n  --> /tmp/tmpkoz4q7r5.rs:39:67\n   |\n39 |   let mut word_index_start_end_end_end_end_end_end_end_end_end_end\n   |                                                                   ^ help: add `;` here\n40 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpkoz4q7r5.rs:17:41\n   |\n17 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |    ------------                         ^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<String>`\n           found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns a vector of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty vector.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n/// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n  let mut words = Vec::new();\n  let mut word = String::new();\n  let mut count = 0;\n  for (let c of s) {\n    if (c == ' ') {\n      if (count == n) {\n        words.push(word);\n        word = String::new();\n        count = 0;\n      }\n    } else {\n      if (count == n) {\n        words.push(word);\n        word = String::new();\n        count = 0;\n      } else {\n        word = word.concat(c);\n        count += 1;\n      }\n    }\n  }\n  if (count == n) {\n    words.push(word);\n  }\n  words\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmp0r2dlmb8.rs:21:8\n   |\n21 |   for (let c of s) {\n   |        ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `c`\n  --> /tmp/tmp0r2dlmb8.rs:21:12\n   |\n21 |   for (let c of s) {\n   |           -^ expected one of `)`, `,`, `@`, or `|`\n   |           |\n   |           help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `of`\n  --> /tmp/tmp0r2dlmb8.rs:21:14\n   |\n21 |   for (let c of s) {\n   |             -^^ expected one of `)`, `,`, `@`, or `|`\n   |             |\n   |             help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `s`\n  --> /tmp/tmp0r2dlmb8.rs:21:17\n   |\n21 |   for (let c of s) {\n   |                -^ expected one of `)`, `,`, `@`, or `|`\n   |                |\n   |                help: missing `,`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmp0r2dlmb8.rs:21:19\n   |\n21 |   for (let c of s) {\n   |                   ^ help: try adding `in` here\n\nerror: expected `{`, found keyword `if`\n  --> /tmp/tmp0r2dlmb8.rs:39:3\n   |\n39 |   if (count == n) {\n   |   ^^ expected `{`\n   |\nhelp: try placing this code inside a block\n   |\n39 ~   { if (count == n) {\n40 |     words.push(word);\n41 ~   } }\n   |\n\nerror: aborting due to 6 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns a vector of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty vector.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n/// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n  let mut result = Vec::new();\n  let mut word = String::new();\n  let mut count = 0;\n  for i in s.chars() {\n    if count == n {\n      result.push(word);\n      word = String::new();\n      count = 0;\n    }\n    if i.is_space() {\n      continue;\n    }\n    if i.is_upper() {\n      word += i.to_lower();\n    } else {\n      word += i;\n    }\n    count += 1;\n  }\n  if word.len() > 0 {\n    result.push(word);\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "error[E0599]: no method named `is_space` found for type `char` in the current scope\n  --> /tmp/tmpbk5zv40l.rs:27:10\n   |\n27 |     if i.is_space() {\n   |          ^^^^^^^^ help: there is an associated function with a similar name: `is_whitespace`\n\nerror[E0599]: no method named `is_upper` found for type `char` in the current scope\n  --> /tmp/tmpbk5zv40l.rs:30:10\n   |\n30 |     if i.is_upper() {\n   |          ^^^^^^^^ help: there is an associated function with a similar name: `is_uppercase`\n\nerror[E0599]: no method named `to_lower` found for type `char` in the current scope\n  --> /tmp/tmpbk5zv40l.rs:31:17\n   |\n31 |       word += i.to_lower();\n   |                 ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpbk5zv40l.rs:33:15\n   |\n33 |       word += i;\n   |               ^ expected `&str`, found `char`\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns a vector of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty vector.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n/// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n  let mut words = Vec::new();\n  let mut word = String::new();\n  let mut word_count = 0;\n  let mut word_index = 0;\n  let mut word_index_end = 0;\n  let mut word_index_start = 0;\n  let mut word_index_start_end = 0;\n  let mut word_index_start_end_end = 0;\n  let mut word_index_start_end_end_end = 0;\n  let mut word_index_start_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end_end_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end_end_end_end\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "error: expected `;`, found `}`\n  --> /tmp/tmpkoz4q7r5.rs:39:67\n   |\n39 |   let mut word_index_start_end_end_end_end_end_end_end_end_end_end\n   |                                                                   ^ help: add `;` here\n40 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpkoz4q7r5.rs:17:41\n   |\n17 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |    ------------                         ^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<String>`\n           found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns a vector of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty vector.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n/// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut words = Vec::new();\n    let mut word = String::new();\n    let mut word_count = 0;\n    let mut word_index = 0;\n    let mut word_index_end = 0;\n    let mut word_index_start = 0;\n    let mut word_index_start_end = 0;\n    let mut word_index_start_end_end = 0;\n    let mut word_index_start_end_end_end = 0;\n    let mut word_index_start_end_end_end_end = 0;\n    let mut word_index_start_end_end_end_end_end = 0;\n    let mut word_index_start_end_end_end_end_end_end = 0;\n    let mut word_index_start_end_end_end_end_end_end_end = 0;\n    let mut word_index_start_end_end_end_end_end_end_end_end = 0;\n    let mut word_index_start_end_end_end_end_end_end_end_end_end = 0;\n    let mut word_index_start_end_end_end_end_end_end_end_end_end_end = 0;\n    let mut word_index_start_end_end_end_end_end_end_end_end_end_end_end = 0;\n    let mut word_index_start_end_end_end_end_end_end_end_end_end_end_end_end = 0;\n    let mut word_index_start_end_end_end_end_end_end_end_end_end_end_end_end_end = 0;\n    let mut word_index_start_end_end_end_end_end_end_end_end_end_end_end_end_end_end = 0;\n    let mut word_index_start_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end = 0;\n    let mut word_index_start_end_end_end_end_end_end_end_end_end_end\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "error: expected `;`, found `}`\n  --> /tmp/tmpwkh6xpwz.rs:39:69\n   |\n39 |     let mut word_index_start_end_end_end_end_end_end_end_end_end_end\n   |                                                                     ^ help: add `;` here\n40 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpwkh6xpwz.rs:17:41\n   |\n17 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |    ------------                         ^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<String>`\n           found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns a vector of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty vector.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n/// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n  let mut result = Vec::new();\n  let mut word = String::new();\n  let mut count = 0;\n  for i in s.chars() {\n    if count == n {\n      result.push(word);\n      word = String::new();\n      count = 0;\n    }\n    if s[i] == ' ' {\n      if word.len() > 0 {\n        result.push(word);\n        word = String::new();\n        count = 0;\n      }\n    } else {\n      word += s[i];\n      count += 1;\n    }\n  }\n  if word.len() > 0 {\n    result.push(word);\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "error[E0277]: the type `String` cannot be indexed by `char`\n  --> /tmp/tmpwmybvgrg.rs:27:8\n   |\n27 |     if s[i] == ' ' {\n   |        ^^^^ `String` cannot be indexed by `char`\n   |\n   = help: the trait `Index<char>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `char`\n  --> /tmp/tmpwmybvgrg.rs:34:15\n   |\n34 |       word += s[i];\n   |               ^^^^ `String` cannot be indexed by `char`\n   |\n   = help: the trait `Index<char>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns a vector of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty vector.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n/// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n  let mut result = Vec::new();\n  let mut word = String::new();\n  let mut count = 0;\n  for (let i = 0; i < s.len(); i++) {\n    if (s[i] == ' ') {\n      if (count == n) {\n        result.push(word);\n        word = String::new();\n        count = 0;\n      }\n    } else {\n      word = word.cat(s[i]);\n      count += 1;\n    }\n  }\n  if (count == n) {\n    result.push(word);\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmpe8puq9vw.rs:21:8\n   |\n21 |   for (let i = 0; i < s.len(); i++) {\n   |        ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmpe8puq9vw.rs:21:12\n   |\n21 |   for (let i = 0; i < s.len(); i++) {\n   |           -^ expected one of `)`, `,`, `@`, or `|`\n   |           |\n   |           help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmpe8puq9vw.rs:21:14\n   |\n21 |   for (let i = 0; i < s.len(); i++) {\n   |              ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmpe8puq9vw.rs:21:13\n   |\n21 |   for (let i = 0; i < s.len(); i++) {\n   |             ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmpe8puq9vw.rs:21:14\n   |\n21 |   for (let i = 0; i < s.len(); i++) {\n   |              ^ expected expression\n\nerror: aborting due to 5 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns a vector of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty vector.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n/// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n  let mut words = Vec::new();\n  let mut word = String::new();\n  let mut i = 0;\n  let mut j = 0;\n  let mut k = 0;\n  let mut l = 0;\n  let mut m = 0;\n  let mut n = 0;\n  let mut o = 0;\n  let mut p = 0;\n  let mut q = 0;\n  let mut r = 0;\n  let mut s = 0;\n  let mut t = 0;\n  let mut u = 0;\n  let mut v = 0;\n  let mut w = 0;\n  let mut x = 0;\n  let mut y = 0;\n  let mut z = 0;\n  let mut a = 0;\n  let mut b = 0;\n  let mut c = 0;\n  let mut d = 0;\n  let mut e = 0;\n  let mut f = 0;\n  let mut g = 0;\n  let mut h = 0;\n  let mut i = 0;\n  let mut j = 0;\n  let mut k = 0;\n  let mut l = 0;\n  let mut m = 0;\n  let mut n = 0;\n  let mut o = 0;\n  let mut p = 0;\n  let mut q = 0;\n  let mut r = 0;\n  let mut s = 0;\n  let mut t = 0;\n  let mut u = 0;\n  let mut v = 0;\n  let mut w = 0;\n  let mut x = 0;\n  let mut y = 0;\n  let mut z = 0;\n  let mut a = 0;\n  let mut b = 0;\n  let mut c = 0;\n  let mut d = 0;\n  let mut e = 0;\n  let mut f = 0;\n  let mut g = 0;\n  let mut h = 0;\n  let mut i = 0;\n  let mut j = 0;\n  let mut k = 0;\n  let mut l = 0;\n  let mut m = 0;\n  let mut n = 0;\n  let mut o = 0;\n  let mut p = 0;\n  let mut q = 0;\n  let mut r\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "error: expected `;`, found `}`\n  --> /tmp/tmphhs68iah.rs:81:12\n   |\n81 |   let mut r\n   |            ^ help: add `;` here\n82 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmphhs68iah.rs:17:41\n   |\n17 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |    ------------                         ^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<String>`\n           found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns a vector of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty vector.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n/// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n  let mut result = Vec::new();\n  let mut word = String::new();\n  let mut consonants = 0;\n  let mut i = 0;\n  for i < s.len() {\n    if s[i] == ' ' {\n      if consonants == n {\n        result.push(word);\n      }\n      word = String::new();\n      consonants = 0;\n    } else {\n      consonants += 1;\n      word += s[i];\n    }\n    i += 1;\n  }\n  if consonants == n {\n    result.push(word);\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "error: missing `in` in `for` loop\n  --> /tmp/tmpt4lhnzqf.rs:22:8\n   |\n22 |   for i < s.len() {\n   |        ^ help: try adding `in` here\n\nerror: expected one of `!`, `(`, `+`, `::`, `<`, `>`, or `as`, found `.`\n  --> /tmp/tmpt4lhnzqf.rs:22:12\n   |\n22 |   for i < s.len() {\n   |            ^ expected one of 7 possible tokens\n\nerror: aborting due to 2 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns a vector of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty vector.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n/// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n  let mut words = Vec::new();\n  let mut word = String::new();\n  let mut i = 0;\n  let mut j = 0;\n  let mut k = 0;\n  let mut count = 0;\n  while i < s.len() {\n    if s[i] == ' ' {\n      if count == n {\n        words.push(word);\n        word = String::new();\n        count = 0;\n      }\n      i += 1;\n      continue;\n    }\n    if s[i] == '\\n' {\n      i += 1;\n      continue;\n    }\n    if s[i] == '\\r' {\n      i += 1;\n      continue;\n    }\n    if s[i] == '\\t' {\n      i += 1;\n      continue;\n    }\n    if s[i] == '\\v' {\n      i += 1;\n      continue;\n    }\n    if s[i] == '\\f' {\n      i += 1;\n      continue;\n    }\n    if s[i] == '\\b' {\n      i += 1;\n      continue;\n    }\n    if s[i] == '\\u00A0' {\n      i += 1;\n      continue;\n    }\n    if s[i] == '\\u0085' {\n      i += 1;\n      continue;\n    }\n    if s[i] == '\\u2028' {\n      i += 1;\n      continue;\n    }\n    if s[i] == '\\u2029' {\n      i += 1;\n      continue;\n    }\n    if s[i] == '\\u0009' {\n      i += 1;\n      continue;\n    }\n    if s[i] == '\\u000A' {\n      i += 1;\n      continue;\n    }\n    if s[i] == '\\u000B' {\n      i += 1;\n      continue;\n    }\n    if s[i] == '\\u000C' {\n      i += 1;\n      continue;\n    }\n    if s[i] == '\\u000D'\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "error: unknown character escape: `v`\n  --> /tmp/tmpoce3vi3x.rs:46:18\n   |\n46 |     if s[i] == '\\v' {\n   |                  ^ unknown character escape\n   |\n   = help: for more information, visit <https://static.rust-lang.org/doc/master/reference.html#literals>\nhelp: if you meant to write a literal backslash (perhaps escaping in a regular expression), consider a raw string literal\n   |\n46 |     if s[i] == r\"\\v\" {\n   |                ~~~~~\n\nerror: unknown character escape: `f`\n  --> /tmp/tmpoce3vi3x.rs:50:18\n   |\n50 |     if s[i] == '\\f' {\n   |                  ^ unknown character escape\n   |\n   = help: for more information, visit <https://static.rust-lang.org/doc/master/reference.html#literals>\nhelp: if you meant to write a literal backslash (perhaps escaping in a regular expression), consider a raw string literal\n   |\n50 |     if s[i] == r\"\\f\" {\n   |                ~~~~~\n\nerror: unknown character escape: `b`\n  --> /tmp/tmpoce3vi3x.rs:54:18\n   |\n54 |     if s[i] == '\\b' {\n   |                  ^ unknown character escape\n   |\n   = help: for more information, visit <https://static.rust-lang.org/doc/master/reference.html#literals>\nhelp: if you meant to write a literal backslash (perhaps escaping in a regular expression), consider a raw string literal\n   |\n54 |     if s[i] == r\"\\b\" {\n   |                ~~~~~\n\nerror: incorrect unicode escape sequence\n  --> /tmp/tmpoce3vi3x.rs:58:17\n   |\n58 |     if s[i] == '\\u00A0' {\n   |                 ^^^---\n   |                 |\n   |                 help: format of unicode escape sequences uses braces: `\\u{00A0}`\n\nerror: incorrect unicode escape sequence\n  --> /tmp/tmpoce3vi3x.rs:62:17\n   |\n62 |     if s[i] == '\\u0085' {\n   |                 ^^^---\n   |                 |\n   |                 help: format of unicode escape sequences uses braces: `\\u{0085}`\n\nerror: incorrect unicode escape sequence\n  --> /tmp/tmpoce3vi3x.rs:66:17\n   |\n66 |     if s[i] == '\\u2028' {\n   |                 ^^^---\n   |                 |\n   |                 help: format of unicode escape sequences uses b",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns a vector of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty vector.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n/// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut result = Vec::new();\n    let mut word = String::new();\n    let mut consonants = 0;\n    let mut i = 0;\n    let mut j = 0;\n    while i < s.len() {\n        if s[i] == ' ' {\n            if consonants == n {\n                result.push(word);\n            }\n            word = String::new();\n            consonants = 0;\n            i += 1;\n        } else if s[i] == '\\n' {\n            i += 1;\n        } else {\n            if consonants == 0 {\n                j = i;\n            }\n            consonants += 1;\n            i += 1;\n        }\n    }\n    if consonants == n {\n        result.push(word);\n    }\n    return result;\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpqb8gs196.rs:24:12\n   |\n24 |         if s[i] == ' ' {\n   |            ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpqb8gs196.rs:31:19\n   |\n31 |         } else if s[i] == '\\n' {\n   |                   ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns a vector of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty vector.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n/// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n  let mut words = Vec::new();\n  let mut word = String::new();\n  let mut count = 0;\n  let mut i = 0;\n  let mut j = 0;\n  let mut k = 0;\n  let mut l = 0;\n  let mut m = 0;\n  let mut n = 0;\n  let mut o = 0;\n  let mut p = 0;\n  let mut q = 0;\n  let mut r = 0;\n  let mut s = 0;\n  let mut t = 0;\n  let mut u = 0;\n  let mut v = 0;\n  let mut w = 0;\n  let mut x = 0;\n  let mut y = 0;\n  let mut z = 0;\n  let mut a = 0;\n  let mut b = 0;\n  let mut c = 0;\n  let mut d = 0;\n  let mut e = 0;\n  let mut f = 0;\n  let mut g = 0;\n  let mut h = 0;\n  let mut i = 0;\n  let mut j = 0;\n  let mut k = 0;\n  let mut l = 0;\n  let mut m = 0;\n  let mut n = 0;\n  let mut o = 0;\n  let mut p = 0;\n  let mut q = 0;\n  let mut r = 0;\n  let mut s = 0;\n  let mut t = 0;\n  let mut u = 0;\n  let mut v = 0;\n  let mut w = 0;\n  let mut x = 0;\n  let mut y = 0;\n  let mut z = 0;\n  let mut a = 0;\n  let mut b = 0;\n  let mut c = 0;\n  let mut d = 0;\n  let mut e = 0;\n  let mut f = 0;\n  let mut g = 0;\n  let mut h = 0;\n  let mut i = 0;\n  let mut j = 0;\n  let mut k = 0;\n  let mut l = 0;\n  let mut m = 0;\n  let mut n = 0;\n  let mut o = 0;\n  let mut p = 0;\n  let mut q\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "error: expected `;`, found `}`\n  --> /tmp/tmp0aji3r25.rs:81:12\n   |\n81 |   let mut q\n   |            ^ help: add `;` here\n82 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp0aji3r25.rs:17:41\n   |\n17 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |    ------------                         ^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<String>`\n           found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns a vector of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty vector.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n/// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut words = Vec::new();\n    let mut word = String::new();\n    let mut word_count = 0;\n    let mut word_index = 0;\n    let mut word_index_end = 0;\n    let mut word_index_start = 0;\n    let mut word_index_start_end = 0;\n    let mut word_index_start_end_end = 0;\n    let mut word_index_start_end_end_end = 0;\n    let mut word_index_start_end_end_end_end = 0;\n    let mut word_index_start_end_end_end_end_end = 0;\n    let mut word_index_start_end_end_end_end_end_end = 0;\n    let mut word_index_start_end_end_end_end_end_end_end = 0;\n    let mut word_index_start_end_end_end_end_end_end_end_end = 0;\n    let mut word_index_start_end_end_end_end_end_end_end_end_end = 0;\n    let mut word_index_start_end_end_end_end_end_end_end_end_end_end = 0;\n    let mut word_index_start_end_end_end_end_end_end_end_end_end_end_end = 0;\n    let mut word_index_start_end_end_end_end_end_end_end_end_end_end_end_end = 0;\n    let mut word_index_start_end_end_end_end_end_end_end_end_end_end_end_end_end = 0;\n    let mut word_index_start_end_end_end_end_end_end_end_end_end_end_end_end_end_end = 0;\n    let mut word_index_start_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end = 0;\n    let mut word_index_start_end_end_end_end_end_end_end_end_end_end\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "error: expected `;`, found `}`\n  --> /tmp/tmpwkh6xpwz.rs:39:69\n   |\n39 |     let mut word_index_start_end_end_end_end_end_end_end_end_end_end\n   |                                                                     ^ help: add `;` here\n40 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpwkh6xpwz.rs:17:41\n   |\n17 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |    ------------                         ^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<String>`\n           found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns a vector of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty vector.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n/// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n  let mut words = Vec::new();\n  let mut word = String::new();\n  let mut i = 0;\n  let mut j = 0;\n  let mut count = 0;\n  let mut count_end = 0;\n  let mut count_start = 0;\n  let mut count_end_start = 0;\n  let mut count_end_end = 0;\n  let mut count_start_start = 0;\n  let mut count_start_end = 0;\n  let mut count_end_start_start = 0;\n  let mut count_end_start_end = 0;\n  let mut count_start_start_start = 0;\n  let mut count_start_start_end = 0;\n  let mut count_end_end_start = 0;\n  let mut count_end_end_end = 0;\n  let mut count_start_end_start = 0;\n  let mut count_start_end_end = 0;\n  let mut count_end_start_start_start = 0;\n  let mut count_end_start_start_end = 0;\n  let mut count_start_end_start_start = 0;\n  let mut count_start_end_start_end = 0;\n  let mut count_end_end_end_start = 0;\n  let mut count_end_end_end_end = 0;\n  let mut count_start_end_end_start = 0;\n  let mut count_start_end_end_end = 0;\n  let mut count_end_start_start_start_start = 0;\n  let mut count_end_start_start_start_end = 0;\n  let mut count_start_end_start_start_end = 0;\n  let mut count_end_start_start_start_end = 0;\n  let mut count_end_start_start_start_end = 0;\n  let mut count_end_start_start_start_end = 0;\n  let mut count_end_start_start_start_end = 0;\n  let mut count_end_start_start_start_end = 0;\n  let mut count_end_start_start_start_end = 0\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "error: expected `;`, found `}`\n  --> /tmp/tmpvdgneq5z.rs:53:46\n   |\n53 |   let mut count_end_start_start_start_end = 0\n   |                                              ^ help: add `;` here\n54 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpvdgneq5z.rs:17:41\n   |\n17 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |    ------------                         ^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<String>`\n           found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns a vector of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty vector.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n/// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut words = Vec::new();\n    let mut word = String::new();\n    let mut count = 0;\n    let mut i = 0;\n    while i < s.len() {\n        if s[i] == ' ' {\n            if count == n {\n                words.push(word);\n                word = String::new();\n                count = 0;\n            }\n            i += 1;\n        } else {\n            if count < n {\n                count += 1;\n                word.push_back(s[i]);\n            } else {\n                if word.len() > 0 {\n                    words.push(word);\n                    word = String::new();\n                    count = 0;\n                }\n                word.push_back(s[i]);\n            }\n            i += 1;\n        }\n    }\n    if count == n {\n        words.push(word);\n    }\n    return words;\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp34bw_ajn.rs:23:12\n   |\n23 |         if s[i] == ' ' {\n   |            ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0599]: no method named `push_back` found for struct `String` in the current scope\n  --> /tmp/tmp34bw_ajn.rs:33:22\n   |\n33 |                 word.push_back(s[i]);\n   |                      ^^^^^^^^^ method not found in `String`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp34bw_ajn.rs:33:32\n   |\n33 |                 word.push_back(s[i]);\n   |                                ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0599]: no method named `push_back` found for struct `String` in the current scope\n  --> /tmp/tmp34bw_ajn.rs:40:22\n   |\n40 |                 word.push_back(s[i]);\n   |                      ^^^^^^^^^ method not found in `String`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp34bw_ajn.rs:40:32\n   |\n40 |                 word.push_back(s[i]);\n   |                                ^^^^ `String` cannot be indexed by `usize`\n ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns a vector of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty vector.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n/// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n  let mut words = Vec::new();\n  let mut word = String::new();\n  let mut word_count = 0;\n  for (let i = 0; i < s.len(); i++) {\n    if s[i] == ' ' {\n      if word_count == n {\n        words.push(word);\n        word = String::new();\n        word_count = 0;\n      }\n    } else {\n      word = word.cat(s[i]);\n      word_count += 1;\n    }\n  }\n  if word_count == n {\n    words.push(word);\n  }\n  words\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmpqmtozo6r.rs:21:8\n   |\n21 |   for (let i = 0; i < s.len(); i++) {\n   |        ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmpqmtozo6r.rs:21:12\n   |\n21 |   for (let i = 0; i < s.len(); i++) {\n   |           -^ expected one of `)`, `,`, `@`, or `|`\n   |           |\n   |           help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmpqmtozo6r.rs:21:14\n   |\n21 |   for (let i = 0; i < s.len(); i++) {\n   |              ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmpqmtozo6r.rs:21:13\n   |\n21 |   for (let i = 0; i < s.len(); i++) {\n   |             ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmpqmtozo6r.rs:21:14\n   |\n21 |   for (let i = 0; i < s.len(); i++) {\n   |              ^ expected expression\n\nerror: aborting due to 5 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns a vector of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty vector.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n/// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n  let mut words = Vec::new();\n  let mut word = String::new();\n  let mut count = 0;\n  let mut i = 0;\n  while i < s.len() {\n    if s[i] == ' ' {\n      if count == n {\n        words.push(word);\n        word = String::new();\n        count = 0;\n      }\n      i += 1;\n      continue;\n    }\n    if s[i] == '\\n' {\n      i += 1;\n      continue;\n    }\n    if s[i] == '\\r' {\n      i += 1;\n      continue;\n    }\n    if s[i] == '\\t' {\n      i += 1;\n      continue;\n    }\n    if s[i] == '\\v' {\n      i += 1;\n      continue;\n    }\n    if s[i] == '\\f' {\n      i += 1;\n      continue;\n    }\n    if s[i] == '\\b' {\n      i += 1;\n      continue;\n    }\n    if s[i] == '\\a' {\n      i += 1;\n      continue;\n    }\n    if s[i] == '\\0' {\n      i += 1;\n      continue;\n    }\n    if s[i] == '\\x0b' {\n      i += 1;\n      continue;\n    }\n    if s[i] == '\\x0c' {\n      i += 1;\n      continue;\n    }\n    if s[i] == '\\x0e' {\n      i += 1;\n      continue;\n    }\n    if s[i] == '\\x0f' {\n      i += 1;\n      continue;\n    }\n    if s[i] == '\\x10' {\n      i += 1;\n      continue;\n    }\n    if s[i] == '\\x11' {\n      i += 1;\n      continue;\n    }\n    if s[i] == '\\x12' {\n      i += 1;\n      continue;\n    }\n    if s[i] == '\\\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "error: unknown character escape: `v`\n  --> /tmp/tmpry9_40rt.rs:44:18\n   |\n44 |     if s[i] == '\\v' {\n   |                  ^ unknown character escape\n   |\n   = help: for more information, visit <https://static.rust-lang.org/doc/master/reference.html#literals>\nhelp: if you meant to write a literal backslash (perhaps escaping in a regular expression), consider a raw string literal\n   |\n44 |     if s[i] == r\"\\v\" {\n   |                ~~~~~\n\nerror: unknown character escape: `f`\n  --> /tmp/tmpry9_40rt.rs:48:18\n   |\n48 |     if s[i] == '\\f' {\n   |                  ^ unknown character escape\n   |\n   = help: for more information, visit <https://static.rust-lang.org/doc/master/reference.html#literals>\nhelp: if you meant to write a literal backslash (perhaps escaping in a regular expression), consider a raw string literal\n   |\n48 |     if s[i] == r\"\\f\" {\n   |                ~~~~~\n\nerror: unknown character escape: `b`\n  --> /tmp/tmpry9_40rt.rs:52:18\n   |\n52 |     if s[i] == '\\b' {\n   |                  ^ unknown character escape\n   |\n   = help: for more information, visit <https://static.rust-lang.org/doc/master/reference.html#literals>\nhelp: if you meant to write a literal backslash (perhaps escaping in a regular expression), consider a raw string literal\n   |\n52 |     if s[i] == r\"\\b\" {\n   |                ~~~~~\n\nerror: unknown character escape: `a`\n  --> /tmp/tmpry9_40rt.rs:56:18\n   |\n56 |     if s[i] == '\\a' {\n   |                  ^ unknown character escape\n   |\n   = help: for more information, visit <https://static.rust-lang.org/doc/master/reference.html#literals>\nhelp: if you meant to write a literal backslash (perhaps escaping in a regular expression), consider a raw string literal\n   |\n56 |     if s[i] == r\"\\a\" {\n   |                ~~~~~\n\nerror[E0762]: unterminated character literal\n  --> /tmp/tmpry9_40rt.rs:92:16\n   |\n92 |       if s[i] == '\\\n   |  ________________^\n93 | | }\n   | |_^\n\nerror: aborting due to 5 previous errors\n\nFor more information about this error, try `rustc --explain E0762`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns a vector of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty vector.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n/// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n  let mut result = Vec::new();\n  let mut word = String::new();\n  let mut consonants = 0;\n  let mut consonant_index = 0;\n  let mut consonant_count = 0;\n  let mut consonant_count_index = 0;\n  let mut consonant_count_count = 0;\n  let mut consonant_count_count_index = 0;\n  let mut consonant_count_count_count = 0;\n  let mut consonant_count_count_count_index = 0;\n  let mut consonant_count_count_count_count = 0;\n  let mut consonant_count_count_count_count_index = 0;\n  let mut consonant_count_count_count_count_count = 0;\n  let mut consonant_count_count_count_count_count_index = 0;\n  let mut consonant_count_count_count_count_count_count = 0;\n  let mut consonant_count_count_count_count_count_count_index = 0;\n  let mut consonant_count_count_count_count_count_count_count = 0;\n  let mut consonant_count_count_count_count_count_count_count_index = 0;\n  let mut consonant_count_count_count_count_count_count_count_count = 0;\n  let mut consonant_count_count_count_count_count_count_count_count_index = 0;\n  let mut consonant_count_count_count_count_count_count_count_count_count = 0;\n  let mut consonant_count_count_count_count_count_count_count_count_count_index = 0;\n  let mut consonant_count_count_count_count_count_count_count_count_count_count = 0;\n  let mut consonant_count_count_count_count_count_count_count_count_count_count_index = 0;\n  let mut consonant_count_count_count_count_count_count_count_count_count_count_count = 0;\n  let mut consonant_count_count_count_count_count_count_count_count\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "error: expected `;`, found `}`\n  --> /tmp/tmp5iczd7pu.rs:43:68\n   |\n43 |   let mut consonant_count_count_count_count_count_count_count_count\n   |                                                                    ^ help: add `;` here\n44 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp5iczd7pu.rs:17:41\n   |\n17 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |    ------------                         ^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<String>`\n           found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns a vector of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty vector.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n/// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut result: Vec<String> = Vec::new();\n    let mut word: String = String::from(\"\");\n    let mut count: isize = 0;\n    for i in s.chars() {\n        if count == n {\n            result.push(word);\n            word = String::from(\"\");\n            count = 0;\n        }\n        if i.is_upper() {\n            if word.is_empty() {\n                word += i.to_lower();\n            } else {\n                word += i;\n            }\n        } else {\n            if word.is_empty() {\n                word += i;\n            } else {\n                count += 1;\n            }\n        }\n    }\n    if !word.is_empty() {\n        result.push(word);\n    }\n    return result;\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "error[E0599]: no method named `is_upper` found for type `char` in the current scope\n  --> /tmp/tmpj4numl0t.rs:27:14\n   |\n27 |         if i.is_upper() {\n   |              ^^^^^^^^ help: there is an associated function with a similar name: `is_uppercase`\n\nerror[E0599]: no method named `to_lower` found for type `char` in the current scope\n  --> /tmp/tmpj4numl0t.rs:29:27\n   |\n29 |                 word += i.to_lower();\n   |                           ^^^^^^^^ help: there is an associated function with a similar name: `to_lowercase`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpj4numl0t.rs:31:25\n   |\n31 |                 word += i;\n   |                         ^ expected `&str`, found `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpj4numl0t.rs:35:25\n   |\n35 |                 word += i;\n   |                         ^ expected `&str`, found `char`\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns a vector of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty vector.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n/// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n  let mut result = Vec::new();\n  let mut word = String::new();\n  let mut count = 0;\n  for (let i = 0; i < s.len(); i++) {\n    if (s[i] == ' ') {\n      if (count == n) {\n        result.push(word);\n        word = String::new();\n        count = 0;\n      }\n    } else {\n      if (count == n) {\n        result.push(word);\n        word = String::new();\n        count = 0;\n      }\n      word += s[i];\n      count += 1;\n    }\n  }\n  if (count == n) {\n    result.push(word);\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmppbsq3mq9.rs:21:8\n   |\n21 |   for (let i = 0; i < s.len(); i++) {\n   |        ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmppbsq3mq9.rs:21:12\n   |\n21 |   for (let i = 0; i < s.len(); i++) {\n   |           -^ expected one of `)`, `,`, `@`, or `|`\n   |           |\n   |           help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmppbsq3mq9.rs:21:14\n   |\n21 |   for (let i = 0; i < s.len(); i++) {\n   |              ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmppbsq3mq9.rs:21:13\n   |\n21 |   for (let i = 0; i < s.len(); i++) {\n   |             ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmppbsq3mq9.rs:21:14\n   |\n21 |   for (let i = 0; i < s.len(); i++) {\n   |              ^ expected expression\n\nerror: aborting due to 5 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns a vector of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty vector.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n/// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut words = Vec::new();\n    let mut word = String::new();\n    let mut count = 0;\n    let mut i = 0;\n    let mut j = 0;\n    let mut k = 0;\n    let mut l = 0;\n    let mut m = 0;\n    let mut n = 0;\n    let mut o = 0;\n    let mut p = 0;\n    let mut q = 0;\n    let mut r = 0;\n    let mut s = 0;\n    let mut t = 0;\n    let mut u = 0;\n    let mut v = 0;\n    let mut w = 0;\n    let mut x = 0;\n    let mut y = 0;\n    let mut z = 0;\n    let mut a = 0;\n    let mut b = 0;\n    let mut c = 0;\n    let mut d = 0;\n    let mut e = 0;\n    let mut f = 0;\n    let mut g = 0;\n    let mut h = 0;\n    let mut i = 0;\n    let mut j = 0;\n    let mut k = 0;\n    let mut l = 0;\n    let mut m = 0;\n    let mut n = 0;\n    let mut o = 0;\n    let mut p = 0;\n    let mut q = 0;\n    let mut r = 0;\n    let mut s = 0;\n    let mut t = 0;\n    let mut u = 0;\n    let mut v = 0;\n    let mut w = 0;\n    let mut x = 0;\n    let mut y = 0;\n    let mut z = 0;\n    let mut a = 0;\n    let mut b = 0;\n    let mut c = 0;\n    let mut d = 0;\n    let mut e = 0;\n    let mut f = 0;\n    let mut g = 0;\n    let mut h = 0;\n    let mut i = 0;\n    let mut j = 0;\n    let mut k = 0;\n    let mut l = 0;\n    let mut m = 0;\n    let mut n = 0;\n    let mut o = 0;\n    let mut p = 0;\n    let mut q\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "error: expected `;`, found `}`\n  --> /tmp/tmptcliclee.rs:81:14\n   |\n81 |     let mut q\n   |              ^ help: add `;` here\n82 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmptcliclee.rs:17:41\n   |\n17 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |    ------------                         ^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<String>`\n           found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns a vector of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty vector.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n/// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n  let mut words = Vec::new();\n  let mut word = String::new();\n  let mut word_count = 0;\n  let mut word_index = 0;\n  let mut word_index_end = 0;\n  let mut word_index_start = 0;\n  let mut word_index_start_end = 0;\n  let mut word_index_start_end_end = 0;\n  let mut word_index_start_end_end_end = 0;\n  let mut word_index_start_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end_end_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end_end_end_end\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "error: expected `;`, found `}`\n  --> /tmp/tmpkoz4q7r5.rs:39:67\n   |\n39 |   let mut word_index_start_end_end_end_end_end_end_end_end_end_end\n   |                                                                   ^ help: add `;` here\n40 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpkoz4q7r5.rs:17:41\n   |\n17 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |    ------------                         ^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<String>`\n           found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns a vector of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty vector.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n/// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n  let mut words = Vec::new();\n  let mut word = String::new();\n  let mut consonants = 0;\n  let mut consonant_index = 0;\n  let mut consonant_index_end = 0;\n  let mut consonant_index_start = 0;\n  let mut consonant_index_start_end = 0;\n  let mut consonant_index_start_end_end = 0;\n  let mut consonant_index_start_end_end_end = 0;\n  let mut consonant_index_start_end_end_end_end = 0;\n  let mut consonant_index_start_end_end_end_end_end = 0;\n  let mut consonant_index_start_end_end_end_end_end_end = 0;\n  let mut consonant_index_start_end_end_end_end_end_end_end = 0;\n  let mut consonant_index_start_end_end_end_end_end_end_end_end = 0;\n  let mut consonant_index_start_end_end_end_end_end_end_end_end_end = 0;\n  let mut consonant_index_start_end_end_end_end_end_end_end_end_end_end = 0;\n  let mut consonant_index_start_end_end_end_end_end_end_end_end_end_end_end = 0;\n  let mut consonant_index_start_end_end_end_end_end_end_end_end_end_end_end_end = 0;\n  let mut consonant_index_start_end_end_end_end_end_end_end_end_end_end_end_end_end = 0;\n  let mut consonant_index_start_end_end_end_end_end_end_end_end_end_end_end_end_end_end = 0;\n  let mut consonant_index_start_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end = 0;\n  let mut consonant_index_start_end\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "error: expected `;`, found `}`\n  --> /tmp/tmpyrdzzx8f.rs:39:36\n   |\n39 |   let mut consonant_index_start_end\n   |                                    ^ help: add `;` here\n40 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpyrdzzx8f.rs:17:41\n   |\n17 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |    ------------                         ^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<String>`\n           found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns a vector of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty vector.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n/// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n  let mut words = Vec::new();\n  let mut word = String::new();\n  let mut last_consonant = String::new();\n  let mut consonant_count = 0;\n  let mut consonant_index = 0;\n  let mut consonant_index_prev = 0;\n  let mut consonant_index_next = 0;\n  let mut consonant_index_next_prev = 0;\n  let mut consonant_index_next_next = 0;\n  let mut consonant_index_next_next_prev = 0;\n  let mut consonant_index_next_next_next = 0;\n  let mut consonant_index_next_next_next_prev = 0;\n  let mut consonant_index_next_next_next_next = 0;\n  let mut consonant_index_next_next_next_next_prev = 0;\n  let mut consonant_index_next_next_next_next_next = 0;\n  let mut consonant_index_next_next_next_next_next_prev = 0;\n  let mut consonant_index_next_next_next_next_next_next = 0;\n  let mut consonant_index_next_next_next_next_next_next_prev = 0;\n  let mut consonant_index_next_next_next_next_next_next_next = 0;\n  let mut consonant_index_next_next_next_next_next_next_next_prev = 0;\n  let mut consonant_index_next_next_next_next_next_next_next_next = 0;\n  let mut consonant_index_next_next_next_next_next_next_next_next_prev = 0;\n  let mut consonant_index_next_next_next_next_next_next_next_next_next = 0;\n  let mut consonant_index_next_next_next_next_next_next_next_next_next_prev = 0;\n  let mut consonant_index_next_next_next_next_next_next_next_next_next_next = 0;\n  let mut consonant_index_next_next_next_next_\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "error: expected `;`, found `}`\n  --> /tmp/tmp2sruz8la.rs:43:47\n   |\n43 |   let mut consonant_index_next_next_next_next_\n   |                                               ^ help: add `;` here\n44 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2sruz8la.rs:17:41\n   |\n17 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |    ------------                         ^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<String>`\n           found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns a vector of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty vector.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n/// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n  let mut words: Vec<String> = Vec::new();\n  let mut word: String = String::new();\n  let mut count: isize = 0;\n  for i in s.chars() {\n    if count == n {\n      words.push(word);\n      word = String::new();\n      count = 0;\n    }\n    if s[i] == ' ' {\n      if count > 0 {\n        words.push(word);\n        word = String::new();\n        count = 0;\n      }\n    } else {\n      count += 1;\n      word.push_back(s[i]);\n    }\n  }\n  if count > 0 {\n    words.push(word);\n  }\n  return words;\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "error[E0277]: the type `String` cannot be indexed by `char`\n  --> /tmp/tmpa7x0nhs4.rs:27:8\n   |\n27 |     if s[i] == ' ' {\n   |        ^^^^ `String` cannot be indexed by `char`\n   |\n   = help: the trait `Index<char>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0599]: no method named `push_back` found for struct `String` in the current scope\n  --> /tmp/tmpa7x0nhs4.rs:35:12\n   |\n35 |       word.push_back(s[i]);\n   |            ^^^^^^^^^ method not found in `String`\n\nerror[E0277]: the type `String` cannot be indexed by `char`\n  --> /tmp/tmpa7x0nhs4.rs:35:22\n   |\n35 |       word.push_back(s[i]);\n   |                      ^^^^ `String` cannot be indexed by `char`\n   |\n   = help: the trait `Index<char>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0599.\nFor more information about an error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns a vector of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty vector.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n/// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n  let mut words = Vec::new();\n  let mut word = String::new();\n  let mut count = 0;\n  for (let i = 0; i < s.len(); i++) {\n    if (s[i] == ' ') {\n      if (count == n) {\n        words.push(word);\n        word = String::new();\n        count = 0;\n      }\n    } else {\n      word.push_back(s[i]);\n      count += 1;\n    }\n  }\n  if (count == n) {\n    words.push(word);\n  }\n  return words;\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmpi56v6n8f.rs:21:8\n   |\n21 |   for (let i = 0; i < s.len(); i++) {\n   |        ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmpi56v6n8f.rs:21:12\n   |\n21 |   for (let i = 0; i < s.len(); i++) {\n   |           -^ expected one of `)`, `,`, `@`, or `|`\n   |           |\n   |           help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmpi56v6n8f.rs:21:14\n   |\n21 |   for (let i = 0; i < s.len(); i++) {\n   |              ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmpi56v6n8f.rs:21:13\n   |\n21 |   for (let i = 0; i < s.len(); i++) {\n   |             ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmpi56v6n8f.rs:21:14\n   |\n21 |   for (let i = 0; i < s.len(); i++) {\n   |              ^ expected expression\n\nerror: aborting due to 5 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns a vector of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty vector.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n/// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut words = Vec::new();\n    let mut word = String::new();\n    let mut count = 0;\n    let mut i = 0;\n    while i < s.len() {\n        if s[i] == ' ' {\n            if count == n {\n                words.push(word);\n                word = String::new();\n                count = 0;\n            }\n            i += 1;\n        } else {\n            word += s[i];\n            count += 1;\n            i += 1;\n        }\n    }\n    if count == n {\n        words.push(word);\n    }\n    return words;\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpr74vsw5b.rs:23:12\n   |\n23 |         if s[i] == ' ' {\n   |            ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpr74vsw5b.rs:31:21\n   |\n31 |             word += s[i];\n   |                     ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns a vector of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty vector.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n/// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n  let mut words = Vec::new();\n  let mut word = String::new();\n  let mut count = 0;\n  for i in s.chars() {\n    if count == n {\n      words.push(word);\n      word = String::new();\n      count = 0;\n    }\n    if s[i] == ' ' {\n      if count > 0 {\n        words.push(word);\n        word = String::new();\n        count = 0;\n      }\n    } else {\n      count += 1;\n      word.push_back(s[i]);\n    }\n  }\n  if count > 0 {\n    words.push(word);\n  }\n  return words;\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "error[E0277]: the type `String` cannot be indexed by `char`\n  --> /tmp/tmpmji10jmg.rs:27:8\n   |\n27 |     if s[i] == ' ' {\n   |        ^^^^ `String` cannot be indexed by `char`\n   |\n   = help: the trait `Index<char>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0599]: no method named `push_back` found for struct `String` in the current scope\n  --> /tmp/tmpmji10jmg.rs:35:12\n   |\n35 |       word.push_back(s[i]);\n   |            ^^^^^^^^^ method not found in `String`\n\nerror[E0277]: the type `String` cannot be indexed by `char`\n  --> /tmp/tmpmji10jmg.rs:35:22\n   |\n35 |       word.push_back(s[i]);\n   |                      ^^^^ `String` cannot be indexed by `char`\n   |\n   = help: the trait `Index<char>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0599.\nFor more information about an error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns a vector of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty vector.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n/// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n  let mut words = Vec::new();\n  let mut word = String::new();\n  let mut last_consonant = String::new();\n  let mut consonant_count = 0;\n  let mut consonant_index = 0;\n  let mut consonant_index_prev = 0;\n  let mut consonant_index_next = 0;\n  let mut consonant_index_next_prev = 0;\n  let mut consonant_index_prev_next = 0;\n  let mut consonant_index_next_next_prev = 0;\n  let mut consonant_index_prev_next_next = 0;\n  let mut consonant_index_next_next_next_prev = 0;\n  let mut consonant_index_prev_next_next_next = 0;\n  let mut consonant_index_next_next_next_next_prev = 0;\n  let mut consonant_index_prev_next_next_next_next = 0;\n  let mut consonant_index_next_next_next_next_next_prev = 0;\n  let mut consonant_index_prev_next_next_next_next_next = 0;\n  let mut consonant_index_next_next_next_next_next_next_prev = 0;\n  let mut consonant_index_prev_next_next_next_next_next_next = 0;\n  let mut consonant_index_next_next_next_next_next_next_next_prev = 0;\n  let mut consonant_index_prev_next_next_next_next_next_next_next = 0;\n  let mut consonant_index_next_next_next_next_next_next_next_next_prev = 0;\n  let mut consonant_index_prev_next_next_next_next_next_next_next_next = 0;\n  let mut consonant_index_next_next_next_next_next_next_next_next_next_prev = 0;\n  let mut consonant_index_prev_next_next_next_next_next_next_next_next_next = 0;\n  let mut consonant_index_next_next_next_next_\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "error: expected `;`, found `}`\n  --> /tmp/tmp5svrh3oe.rs:43:47\n   |\n43 |   let mut consonant_index_next_next_next_next_\n   |                                               ^ help: add `;` here\n44 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp5svrh3oe.rs:17:41\n   |\n17 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |    ------------                         ^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<String>`\n           found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns a vector of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty vector.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n/// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut result = Vec::new();\n    let mut word = String::new();\n    let mut count = 0;\n    for c in s.chars() {\n        if c.is_upper() {\n            if count == n {\n                result.push(word);\n                word = String::new();\n                count = 0;\n            }\n            word += c;\n            count += 1;\n        } else {\n            if count > 0 {\n                result.push(word);\n                word = String::new();\n                count = 0;\n            }\n            word += c;\n        }\n    }\n    if count > 0 {\n        result.push(word);\n    }\n    return result;\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "error[E0599]: no method named `is_upper` found for type `char` in the current scope\n  --> /tmp/tmpa1cahev8.rs:22:14\n   |\n22 |         if c.is_upper() {\n   |              ^^^^^^^^ help: there is an associated function with a similar name: `is_uppercase`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpa1cahev8.rs:28:21\n   |\n28 |             word += c;\n   |                     ^ expected `&str`, found `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpa1cahev8.rs:36:21\n   |\n36 |             word += c;\n   |                     ^ expected `&str`, found `char`\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns a vector of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty vector.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n/// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut words = Vec::new();\n    let mut word = String::new();\n    let mut consonants = 0;\n    let mut consonant_index = 0;\n    let mut consonant_count = 0;\n    let mut consonant_count_index = 0;\n    let mut consonant_count_count = 0;\n    let mut consonant_count_count_index = 0;\n    let mut consonant_count_count_count = 0;\n    let mut consonant_count_count_count_index = 0;\n    let mut consonant_count_count_count_count = 0;\n    let mut consonant_count_count_count_count_index = 0;\n    let mut consonant_count_count_count_count_count = 0;\n    let mut consonant_count_count_count_count_count_index = 0;\n    let mut consonant_count_count_count_count_count_count = 0;\n    let mut consonant_count_count_count_count_count_count_index = 0;\n    let mut consonant_count_count_count_count_count_count_count = 0;\n    let mut consonant_count_count_count_count_count_count_count_index = 0;\n    let mut consonant_count_count_count_count_count_count_count_count = 0;\n    let mut consonant_count_count_count_count_count_count_count_count_index = 0;\n    let mut consonant_count_count_count_count_count_count_count_count_count = 0;\n    let mut consonant_count_count_count_count_count_count_count_count_count_index = 0;\n    let mut consonant_count_count_count_count_count_count_count_count_count_count = 0;\n    let mut consonant_count_count_count_count_count_count_count_count_count_count_index = 0;\n    let mut consonant_count_count_count_count_count_count_count_count_count_count_count = 0;\n    let mut consonant_count_count_count_count_count_count_count_count\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "error: expected `;`, found `}`\n  --> /tmp/tmpsoldy6c9.rs:43:70\n   |\n43 |     let mut consonant_count_count_count_count_count_count_count_count\n   |                                                                      ^ help: add `;` here\n44 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpsoldy6c9.rs:17:41\n   |\n17 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |    ------------                         ^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<String>`\n           found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns a vector of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty vector.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n/// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut result = Vec::new();\n    let mut word = String::new();\n    let mut count = 0;\n    for i in s.chars() {\n        if count == n {\n            result.push(word);\n            word = String::new();\n            count = 0;\n        }\n        if s[i] == ' ' {\n            if word.len() > 0 {\n                result.push(word);\n                word = String::new();\n                count = 0;\n            }\n        } else {\n            word += s[i];\n            count += 1;\n        }\n    }\n    if word.len() > 0 {\n        result.push(word);\n    }\n    return result;\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "error[E0277]: the type `String` cannot be indexed by `char`\n  --> /tmp/tmpua2s5ou9.rs:27:12\n   |\n27 |         if s[i] == ' ' {\n   |            ^^^^ `String` cannot be indexed by `char`\n   |\n   = help: the trait `Index<char>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `char`\n  --> /tmp/tmpua2s5ou9.rs:34:21\n   |\n34 |             word += s[i];\n   |                     ^^^^ `String` cannot be indexed by `char`\n   |\n   = help: the trait `Index<char>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns a vector of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty vector.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n/// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n  let mut result = Vec::new();\n  let mut word = String::new();\n  let mut count = 0;\n  let mut i = 0;\n  let mut j = 0;\n  while i < s.len() {\n    if s[i] == ' ' {\n      if count == n {\n        result.push(word);\n        count = 0;\n        word = String::new();\n      }\n      i += 1;\n    } else {\n      if count < n {\n        count += 1;\n        word += s[i];\n      } else {\n        i += 1;\n      }\n    }\n  }\n  if count == n {\n    result.push(word);\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpb6rx1v7z.rs:24:8\n   |\n24 |     if s[i] == ' ' {\n   |        ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpb6rx1v7z.rs:34:17\n   |\n34 |         word += s[i];\n   |                 ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns a vector of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty vector.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n/// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n  let mut words = Vec::new();\n  let mut word = String::new();\n  let mut word_count = 0;\n  let mut word_index = 0;\n  let mut word_index_end = 0;\n  let mut word_index_start = 0;\n  let mut word_index_start_end = 0;\n  let mut word_index_start_end_end = 0;\n  let mut word_index_start_end_end_end = 0;\n  let mut word_index_start_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end_end_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end_end_end_end\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "error: expected `;`, found `}`\n  --> /tmp/tmpkoz4q7r5.rs:39:67\n   |\n39 |   let mut word_index_start_end_end_end_end_end_end_end_end_end_end\n   |                                                                   ^ help: add `;` here\n40 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpkoz4q7r5.rs:17:41\n   |\n17 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |    ------------                         ^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<String>`\n           found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns a vector of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty vector.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n/// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n  let mut words = Vec::new();\n  let mut word = String::new();\n  let mut word_count = 0;\n  let mut word_index = 0;\n  let mut word_index_end = 0;\n  let mut word_index_start = 0;\n  let mut word_index_start_end = 0;\n  let mut word_index_start_end_end = 0;\n  let mut word_index_start_end_end_end = 0;\n  let mut word_index_start_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end_end_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end_end_end_end\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "error: expected `;`, found `}`\n  --> /tmp/tmpkoz4q7r5.rs:39:67\n   |\n39 |   let mut word_index_start_end_end_end_end_end_end_end_end_end_end\n   |                                                                   ^ help: add `;` here\n40 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpkoz4q7r5.rs:17:41\n   |\n17 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |    ------------                         ^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<String>`\n           found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns a vector of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty vector.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n/// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n  let mut words = Vec::new();\n  let mut word = String::new();\n  let mut word_count = 0;\n  for (let i = 0; i < s.len(); i++) {\n    if (s[i] == ' ') {\n      if (word_count == n) {\n        words.push(word);\n        word = String::new();\n        word_count = 0;\n      }\n    } else {\n      word = word.cat(s[i]);\n      word_count += 1;\n    }\n  }\n  if (word_count == n) {\n    words.push(word);\n  }\n  return words;\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmpqxkbd2rz.rs:21:8\n   |\n21 |   for (let i = 0; i < s.len(); i++) {\n   |        ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmpqxkbd2rz.rs:21:12\n   |\n21 |   for (let i = 0; i < s.len(); i++) {\n   |           -^ expected one of `)`, `,`, `@`, or `|`\n   |           |\n   |           help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmpqxkbd2rz.rs:21:14\n   |\n21 |   for (let i = 0; i < s.len(); i++) {\n   |              ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmpqxkbd2rz.rs:21:13\n   |\n21 |   for (let i = 0; i < s.len(); i++) {\n   |             ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmpqxkbd2rz.rs:21:14\n   |\n21 |   for (let i = 0; i < s.len(); i++) {\n   |              ^ expected expression\n\nerror: aborting due to 5 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns a vector of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty vector.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n/// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n  let mut words = Vec::new();\n  let mut word = String::new();\n  let mut consonants = 0;\n  for i in s.chars() {\n    if consonants == n {\n      words.push(word);\n      word = String::new();\n      consonants = 0;\n    }\n    if s[i] == ' ' {\n      continue;\n    }\n    if s[i] == ' ' {\n      continue;\n    }\n    if s[i] == ' ' {\n      continue;\n    }\n    if s[i] == ' ' {\n      continue;\n    }\n    if s[i] == ' ' {\n      continue;\n    }\n    if s[i] == ' ' {\n      continue;\n    }\n    if s[i] == ' ' {\n      continue;\n    }\n    if s[i] == ' ' {\n      continue;\n    }\n    if s[i] == ' ' {\n      continue;\n    }\n    if s[i] == ' ' {\n      continue;\n    }\n    if s[i] == ' ' {\n      continue;\n    }\n    if s[i] == ' ' {\n      continue;\n    }\n    if s[i] == ' ' {\n      continue;\n    }\n    if s[i] == ' ' {\n      continue;\n    }\n    if s[i] == ' ' {\n      continue;\n    }\n    if s[i] == ' ' {\n      continue;\n    }\n    if s[i] == ' ' {\n      continue;\n    }\n    if s[i] == ' ' {\n      continue;\n    }\n    if s[i] == ' ' {\n      continue;\n    }\n    if s[i] == ' ' {\n      continue;\n    }\n    if s[i] == ' ' {\n      continue;\n    }\n    if s[i] == ' ' {\n      continue;\n    }\n    if s[i] == ' ' {\n      continue;\n    }\n    if s[i] == ' ' {\n      continue;\n    }\n    if s[i\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "error: this file contains an unclosed delimiter\n   --> /tmp/tmp_o0g_v7n.rs:111:3\n    |\n17  | fn select_words(s: String, n: isize) -> Vec<String> {\n    |                                                     - unclosed delimiter\n...\n21  |   for i in s.chars() {\n    |                      - this delimiter might not be properly closed...\n...\n100 | }\n    | - ...as it matches this but it has different indentation\n...\n111 | }\n    |   ^\n\nerror: expected `{`, found `}`\n   --> /tmp/tmp_o0g_v7n.rs:100:1\n    |\n99  |     if s[i\n    |     -- this `if` expression has a condition, but no block\n100 | }\n    | ^ expected `{`\n\nerror: mismatched closing delimiter: `}`\n   --> /tmp/tmp_o0g_v7n.rs:99:9\n    |\n17  | fn select_words(s: String, n: isize) -> Vec<String> {\n    |                                                     - closing delimiter possibly meant for this\n...\n99  |     if s[i\n    |         ^ unclosed delimiter\n100 | }\n    | ^ mismatched closing delimiter\n\nerror[E0277]: the type `String` cannot be indexed by `char`\n  --> /tmp/tmp_o0g_v7n.rs:27:8\n   |\n27 |     if s[i] == ' ' {\n   |        ^^^^ `String` cannot be indexed by `char`\n   |\n   = help: the trait `Index<char>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `char`\n  --> /tmp/tmp_o0g_v7n.rs:30:8\n   |\n30 |     if s[i] == ' ' {\n   |        ^^^^ `String` cannot be indexed by `char`\n   |\n   = help: the trait `Index<char>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<Range",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns a vector of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty vector.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n/// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n  let mut words: Vec<String> = Vec::new();\n  let mut word: String = String::new();\n  let mut count: isize = 0;\n  for i in s.chars() {\n    if count == n {\n      words.push(word);\n      word = String::new();\n      count = 0;\n    }\n    if s[i] == ' ' {\n      continue;\n    }\n    if s[i] == '\\n' {\n      continue;\n    }\n    if s[i] == '\\t' {\n      continue;\n    }\n    if s[i] == '\\r' {\n      continue;\n    }\n    if s[i] == '\\v' {\n      continue;\n    }\n    if s[i] == '\\f' {\n      continue;\n    }\n    if s[i] == '\\b' {\n      continue;\n    }\n    if s[i] == '\\u00A0' {\n      continue;\n    }\n    if s[i] == '\\u2007' {\n      continue;\n    }\n    if s[i] == '\\u202F' {\n      continue;\n    }\n    if s[i] == '\\u3000' {\n      continue;\n    }\n    if s[i] == '\\uFF0D' {\n      continue;\n    }\n    if s[i] == '\\uFF0E' {\n      continue;\n    }\n    if s[i] == '\\uFF0F' {\n      continue;\n    }\n    if s[i] == '\\uFF1A' {\n      continue;\n    }\n    if s[i] == '\\uFF1B' {\n      continue;\n    }\n    if s[i] == '\\uFF1C' {\n      continue;\n    }\n    if s[i] == '\\uFF1D' {\n      continue;\n    }\n    if s[i] == '\\uFF1E' {\n      continue;\n    }\n    if s[i] == '\\uFF1F' {\n      continue;\n    }\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "error: unknown character escape: `v`\n  --> /tmp/tmpisocxx1o.rs:39:18\n   |\n39 |     if s[i] == '\\v' {\n   |                  ^ unknown character escape\n   |\n   = help: for more information, visit <https://static.rust-lang.org/doc/master/reference.html#literals>\nhelp: if you meant to write a literal backslash (perhaps escaping in a regular expression), consider a raw string literal\n   |\n39 |     if s[i] == r\"\\v\" {\n   |                ~~~~~\n\nerror: unknown character escape: `f`\n  --> /tmp/tmpisocxx1o.rs:42:18\n   |\n42 |     if s[i] == '\\f' {\n   |                  ^ unknown character escape\n   |\n   = help: for more information, visit <https://static.rust-lang.org/doc/master/reference.html#literals>\nhelp: if you meant to write a literal backslash (perhaps escaping in a regular expression), consider a raw string literal\n   |\n42 |     if s[i] == r\"\\f\" {\n   |                ~~~~~\n\nerror: unknown character escape: `b`\n  --> /tmp/tmpisocxx1o.rs:45:18\n   |\n45 |     if s[i] == '\\b' {\n   |                  ^ unknown character escape\n   |\n   = help: for more information, visit <https://static.rust-lang.org/doc/master/reference.html#literals>\nhelp: if you meant to write a literal backslash (perhaps escaping in a regular expression), consider a raw string literal\n   |\n45 |     if s[i] == r\"\\b\" {\n   |                ~~~~~\n\nerror: incorrect unicode escape sequence\n  --> /tmp/tmpisocxx1o.rs:48:17\n   |\n48 |     if s[i] == '\\u00A0' {\n   |                 ^^^---\n   |                 |\n   |                 help: format of unicode escape sequences uses braces: `\\u{00A0}`\n\nerror: incorrect unicode escape sequence\n  --> /tmp/tmpisocxx1o.rs:51:17\n   |\n51 |     if s[i] == '\\u2007' {\n   |                 ^^^---\n   |                 |\n   |                 help: format of unicode escape sequences uses braces: `\\u{2007}`\n\nerror: incorrect unicode escape sequence\n  --> /tmp/tmpisocxx1o.rs:54:17\n   |\n54 |     if s[i] == '\\u202F' {\n   |                 ^^^---\n   |                 |\n   |                 help: format of unicode escape sequences uses b",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns a vector of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty vector.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n/// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n  let mut words = Vec::new();\n  let mut word = String::new();\n  let mut count = 0;\n  for i in s.chars() {\n    if count == n {\n      words.push(word);\n      word = String::new();\n      count = 0;\n    }\n    if s[i] == ' ' {\n      if count > 0 {\n        words.push(word);\n        word = String::new();\n        count = 0;\n      }\n    } else {\n      count += 1;\n      word.push_back(s[i]);\n    }\n  }\n  if count > 0 {\n    words.push(word);\n  }\n  return words;\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "error[E0277]: the type `String` cannot be indexed by `char`\n  --> /tmp/tmpmji10jmg.rs:27:8\n   |\n27 |     if s[i] == ' ' {\n   |        ^^^^ `String` cannot be indexed by `char`\n   |\n   = help: the trait `Index<char>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0599]: no method named `push_back` found for struct `String` in the current scope\n  --> /tmp/tmpmji10jmg.rs:35:12\n   |\n35 |       word.push_back(s[i]);\n   |            ^^^^^^^^^ method not found in `String`\n\nerror[E0277]: the type `String` cannot be indexed by `char`\n  --> /tmp/tmpmji10jmg.rs:35:22\n   |\n35 |       word.push_back(s[i]);\n   |                      ^^^^ `String` cannot be indexed by `char`\n   |\n   = help: the trait `Index<char>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0599.\nFor more information about an error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns a vector of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty vector.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n/// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n  let mut words = Vec::new();\n  let mut word = String::new();\n  let mut count = 0;\n  for i in s.chars() {\n    if count == n {\n      words.push(word);\n      word = String::new();\n      count = 0;\n    }\n    if !is_consonant(i) {\n      continue;\n    }\n    count += 1;\n    word.push_back(i);\n  }\n  if count == n {\n    words.push(word);\n  }\n  return words;\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "error[E0425]: cannot find function `is_consonant` in this scope\n  --> /tmp/tmpduv3kbf2.rs:27:9\n   |\n27 |     if !is_consonant(i) {\n   |         ^^^^^^^^^^^^ not found in this scope\n\nerror[E0599]: no method named `push_back` found for struct `String` in the current scope\n  --> /tmp/tmpduv3kbf2.rs:31:10\n   |\n31 |     word.push_back(i);\n   |          ^^^^^^^^^ method not found in `String`\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations: E0425, E0599.\nFor more information about an error, try `rustc --explain E0425`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns a vector of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty vector.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n/// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n  let mut words = Vec::new();\n  let mut word = String::new();\n  let mut consonants = 0;\n  let mut consonant_count = 0;\n  let mut consonant_index = 0;\n  let mut consonant_index_start = 0;\n  let mut consonant_index_end = 0;\n  let mut consonant_index_end_start = 0;\n  let mut consonant_index_end_end = 0;\n  let mut consonant_index_end_end_start = 0;\n  let mut consonant_index_end_end_end = 0;\n  let mut consonant_index_end_end_end_start = 0;\n  let mut consonant_index_end_end_end_end = 0;\n  let mut consonant_index_end_end_end_end_start = 0;\n  let mut consonant_index_end_end_end_end_end = 0;\n  let mut consonant_index_end_end_end_end_end_start = 0;\n  let mut consonant_index_end_end_end_end_end_end = 0;\n  let mut consonant_index_end_end_end_end_end_end_start = 0;\n  let mut consonant_index_end_end_end_end_end_end_end = 0;\n  let mut consonant_index_end_end_end_end_end_end_end_start = 0;\n  let mut consonant_index_end_end_end_end_end_end_end_end = 0;\n  let mut consonant_index_end_end_end_end_end_end_end_end_start = 0;\n  let mut consonant_index_end_end_end_end_end_end_end_end_end = 0;\n  let mut consonant_index_end_end_end_end_end_end_end_end_end_start = 0;\n  let mut consonant_index_end_end_end_end_end_end_end_end_end_end = 0;\n  let mut consonant_index_end_end_end_end_end_end_end\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "error: expected `;`, found `}`\n  --> /tmp/tmp9eujiah6.rs:43:54\n   |\n43 |   let mut consonant_index_end_end_end_end_end_end_end\n   |                                                      ^ help: add `;` here\n44 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9eujiah6.rs:17:41\n   |\n17 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |    ------------                         ^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<String>`\n           found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns a vector of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty vector.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n/// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n  let mut result = Vec::new();\n  let mut word = String::new();\n  let mut word_count = 0;\n  let mut word_index = 0;\n  let mut word_index_end = 0;\n  let mut word_index_start = 0;\n  let mut word_index_start_end = 0;\n  let mut word_index_start_end_end = 0;\n  let mut word_index_start_end_end_end = 0;\n  let mut word_index_start_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end_end_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end_end_end_end\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "error: expected `;`, found `}`\n  --> /tmp/tmpzevw3u6c.rs:39:67\n   |\n39 |   let mut word_index_start_end_end_end_end_end_end_end_end_end_end\n   |                                                                   ^ help: add `;` here\n40 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpzevw3u6c.rs:17:41\n   |\n17 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |    ------------                         ^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<String>`\n           found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns a vector of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty vector.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n/// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut words = Vec::new();\n    let mut word = String::new();\n    let mut last_consonant = String::new();\n    let mut consonant_count = 0;\n    let mut consonant_index = 0;\n    let mut consonant_index_end = 0;\n    let mut consonant_index_start = 0;\n    let mut consonant_index_start_end = 0;\n    let mut consonant_index_start_end_end = 0;\n    let mut consonant_index_start_end_end_end = 0;\n    let mut consonant_index_start_end_end_end_end = 0;\n    let mut consonant_index_start_end_end_end_end_end = 0;\n    let mut consonant_index_start_end_end_end_end_end_end = 0;\n    let mut consonant_index_start_end_end_end_end_end_end_end = 0;\n    let mut consonant_index_start_end_end_end_end_end_end_end_end = 0;\n    let mut consonant_index_start_end_end_end_end_end_end_end_end_end = 0;\n    let mut consonant_index_start_end_end_end_end_end_end_end_end_end_end = 0;\n    let mut consonant_index_start_end_end_end_end_end_end_end_end_end_end_end = 0;\n    let mut consonant_index_start_end_end_end_end_end_end_end_end_end_end_end_end = 0;\n    let mut consonant_index_start_end_end_end_end_end_end_end_end_end_end_end_end_end = 0;\n    let mut consonant_index_start_end_end_end_end_end_end_end_end_end_end_end_end_end_end = 0;\n    let mut consonant_index_start_end_end_end_end_end_end_end_end_end_end_end_end_end_end_\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "error: expected `;`, found `}`\n  --> /tmp/tmpmpcdry_4.rs:39:91\n   |\n39 |     let mut consonant_index_start_end_end_end_end_end_end_end_end_end_end_end_end_end_end_\n   |                                                                                           ^ help: add `;` here\n40 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpmpcdry_4.rs:17:41\n   |\n17 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |    ------------                         ^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<String>`\n           found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns a vector of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty vector.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n/// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n  let mut words = Vec::new();\n  let mut word = String::new();\n  let mut count = 0;\n  let mut i = 0;\n  while i < s.len() {\n    if s[i] == ' ' {\n      if count == n {\n        words.push(word);\n        word = String::new();\n        count = 0;\n      }\n      i++;\n    } else {\n      if count < n {\n        count++;\n        word += s[i];\n        i++;\n      } else {\n        i++;\n      }\n    }\n  }\n  if count == n {\n    words.push(word);\n  }\n  return words;\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "error: Rust has no postfix increment operator\n  --> /tmp/tmp3o7w_l7r.rs:29:8\n   |\n29 |       i++;\n   |        ^^ not a valid postfix operator\n   |\nhelp: use `+= 1` instead\n   |\n29 |       { let tmp = i; i += 1; tmp };\n   |       +++++++++++  ~~~~~~~~~~~~~~~\n29 -       i++;\n29 +       i += 1;\n   | \n\nerror: Rust has no postfix increment operator\n  --> /tmp/tmp3o7w_l7r.rs:32:14\n   |\n32 |         count++;\n   |              ^^ not a valid postfix operator\n   |\nhelp: use `+= 1` instead\n   |\n32 |         { let tmp = count; count += 1; tmp };\n   |         +++++++++++      ~~~~~~~~~~~~~~~~~~~\n32 -         count++;\n32 +         count += 1;\n   | \n\nerror: Rust has no postfix increment operator\n  --> /tmp/tmp3o7w_l7r.rs:36:10\n   |\n36 |         i++;\n   |          ^^ not a valid postfix operator\n   |\nhelp: use `+= 1` instead\n   |\n36 |         { let tmp = i; i += 1; tmp };\n   |         +++++++++++  ~~~~~~~~~~~~~~~\n36 -         i++;\n36 +         i += 1;\n   | \n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp3o7w_l7r.rs:23:8\n   |\n23 |     if s[i] == ' ' {\n   |        ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror: aborting due to 4 previous errors\n\nFor more information about this error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns a vector of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty vector.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n/// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n  let mut words = Vec::new();\n  let mut word = String::new();\n  let mut count = 0;\n  let mut i = 0;\n  for i < s.len() {\n    if s[i] == ' ' {\n      if count == n {\n        words.push(word);\n        word = String::new();\n        count = 0;\n      }\n      i += 1;\n      continue;\n    }\n    if s[i] == '\\n' {\n      i += 1;\n      continue;\n    }\n    if s[i] == '\\r' {\n      i += 1;\n      continue;\n    }\n    if s[i] == '\\t' {\n      i += 1;\n      continue;\n    }\n    if s[i] == '\\v' {\n      i += 1;\n      continue;\n    }\n    if s[i] == '\\f' {\n      i += 1;\n      continue;\n    }\n    if s[i] == '\\b' {\n      i += 1;\n      continue;\n    }\n    if s[i] == '\\a' {\n      i += 1;\n      continue;\n    }\n    if s[i] == '\\0' {\n      i += 1;\n      continue;\n    }\n    if s[i] == '\\x0' {\n      i += 1;\n      continue;\n    }\n    if s[i] == '\\x1' {\n      i += 1;\n      continue;\n    }\n    if s[i] == '\\x2' {\n      i += 1;\n      continue;\n    }\n    if s[i] == '\\x3' {\n      i += 1;\n      continue;\n    }\n    if s[i] == '\\x4' {\n      i += 1;\n      continue;\n    }\n    if s[i] == '\\x5' {\n      i += 1;\n      continue;\n    }\n    if s[i] == '\\x6' {\n      i += 1;\n      continue;\n    }\n    if s[i] == '\\x7' {\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "error: unknown character escape: `v`\n  --> /tmp/tmpigrsuyg_.rs:44:18\n   |\n44 |     if s[i] == '\\v' {\n   |                  ^ unknown character escape\n   |\n   = help: for more information, visit <https://static.rust-lang.org/doc/master/reference.html#literals>\nhelp: if you meant to write a literal backslash (perhaps escaping in a regular expression), consider a raw string literal\n   |\n44 |     if s[i] == r\"\\v\" {\n   |                ~~~~~\n\nerror: unknown character escape: `f`\n  --> /tmp/tmpigrsuyg_.rs:48:18\n   |\n48 |     if s[i] == '\\f' {\n   |                  ^ unknown character escape\n   |\n   = help: for more information, visit <https://static.rust-lang.org/doc/master/reference.html#literals>\nhelp: if you meant to write a literal backslash (perhaps escaping in a regular expression), consider a raw string literal\n   |\n48 |     if s[i] == r\"\\f\" {\n   |                ~~~~~\n\nerror: unknown character escape: `b`\n  --> /tmp/tmpigrsuyg_.rs:52:18\n   |\n52 |     if s[i] == '\\b' {\n   |                  ^ unknown character escape\n   |\n   = help: for more information, visit <https://static.rust-lang.org/doc/master/reference.html#literals>\nhelp: if you meant to write a literal backslash (perhaps escaping in a regular expression), consider a raw string literal\n   |\n52 |     if s[i] == r\"\\b\" {\n   |                ~~~~~\n\nerror: unknown character escape: `a`\n  --> /tmp/tmpigrsuyg_.rs:56:18\n   |\n56 |     if s[i] == '\\a' {\n   |                  ^ unknown character escape\n   |\n   = help: for more information, visit <https://static.rust-lang.org/doc/master/reference.html#literals>\nhelp: if you meant to write a literal backslash (perhaps escaping in a regular expression), consider a raw string literal\n   |\n56 |     if s[i] == r\"\\a\" {\n   |                ~~~~~\n\nerror: numeric character escape is too short\n  --> /tmp/tmpigrsuyg_.rs:64:17\n   |\n64 |     if s[i] == '\\x0' {\n   |                 ^^^\n\nerror: numeric character escape is too short\n  --> /tmp/tmpigrsuyg_.rs:68:17\n   |\n68 |     if s[i] == '\\x1' {\n   |                 ^^^\n\nerror: n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns a vector of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty vector.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n/// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n  let mut words: Vec<String> = Vec::new();\n  let mut word: String = String::from(\"\");\n  let mut consonants: Vec<isize> = Vec::new();\n  let mut consonant: isize = 0;\n  let mut consonant_count: isize = 0;\n  let mut consonant_index: isize = 0;\n  let mut consonant_index_count: isize = 0;\n  let mut consonant_index_index: isize = 0;\n  let mut consonant_index_index_count: isize = 0;\n  let mut consonant_index_index_index: isize = 0;\n  let mut consonant_index_index_index_count: isize = 0;\n  let mut consonant_index_index_index_index: isize = 0;\n  let mut consonant_index_index_index_index_count: isize = 0;\n  let mut consonant_index_index_index_index_index: isize = 0;\n  let mut consonant_index_index_index_index_index_count: isize = 0;\n  let mut consonant_index_index_index_index_index_index: isize = 0;\n  let mut consonant_index_index_index_index_index_index_count: isize = 0;\n  let mut consonant_index_index_index_index_index_index_index: isize = 0;\n  let mut consonant_index_index_index_index_index_index_index_count: isize = 0;\n  let mut consonant_index_index_index_index_index_index_index_index: isize = 0;\n  let mut consonant_index_index_index_index_index_index_index_index_count: isize = 0;\n  let mut consonant_index_index_index_index_index_index_index_index_index: isize = 0;\n  let mut consonant_index_index_index_index_index_index_index_index_index_count: isize = 0;\n  let mut consonant_index_index_index_index_index_index_index_index_index_index: is\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "error: expected `;`, found `}`\n  --> /tmp/tmpa99didvc.rs:41:84\n   |\n41 |   let mut consonant_index_index_index_index_index_index_index_index_index_index: is\n   |                                                                                    ^ help: add `;` here\n42 | }\n   | - unexpected token\n\nerror[E0412]: cannot find type `is` in this scope\n  --> /tmp/tmpa99didvc.rs:41:82\n   |\n41 |   let mut consonant_index_index_index_index_index_index_index_index_index_index: is\n   |                                                                                  ^^ help: a builtin type with a similar name exists: `i8`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpa99didvc.rs:17:41\n   |\n17 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |    ------------                         ^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<String>`\n           found unit type `()`\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0308, E0412.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns a vector of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty vector.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n/// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut words: Vec<String> = Vec::new();\n    let mut word: String = String::from(\"\");\n    let mut count: isize = 0;\n    for i in s.chars() {\n        if count == n {\n            words.push(word);\n            word = String::from(\"\");\n            count = 0;\n        }\n        if s[i] == ' ' {\n            if count > 0 {\n                words.push(word);\n                word = String::from(\"\");\n                count = 0;\n            }\n        } else {\n            word = word.concat(String::from(s[i]));\n            count += 1;\n        }\n    }\n    if count > 0 {\n        words.push(word);\n    }\n    return words;\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "error[E0277]: the type `String` cannot be indexed by `char`\n  --> /tmp/tmpxcokrids.rs:27:12\n   |\n27 |         if s[i] == ' ' {\n   |            ^^^^ `String` cannot be indexed by `char`\n   |\n   = help: the trait `Index<char>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0599]: no method named `concat` found for struct `String` in the current scope\n  --> /tmp/tmpxcokrids.rs:34:25\n   |\n34 |             word = word.concat(String::from(s[i]));\n   |                         ^^^^^^ method not found in `String`\n\nerror[E0277]: the type `String` cannot be indexed by `char`\n  --> /tmp/tmpxcokrids.rs:34:45\n   |\n34 |             word = word.concat(String::from(s[i]));\n   |                                             ^^^^ `String` cannot be indexed by `char`\n   |\n   = help: the trait `Index<char>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0599.\nFor more information about an error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns a vector of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty vector.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n/// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n  let mut words = Vec::new();\n  let mut word = String::new();\n  let mut count = 0;\n  let mut i = 0;\n  let mut j = 0;\n  let mut k = 0;\n  let mut l = 0;\n  let mut m = 0;\n  let mut n = 0;\n  let mut o = 0;\n  let mut p = 0;\n  let mut q = 0;\n  let mut r = 0;\n  let mut s = 0;\n  let mut t = 0;\n  let mut u = 0;\n  let mut v = 0;\n  let mut w = 0;\n  let mut x = 0;\n  let mut y = 0;\n  let mut z = 0;\n  let mut a = 0;\n  let mut b = 0;\n  let mut c = 0;\n  let mut d = 0;\n  let mut e = 0;\n  let mut f = 0;\n  let mut g = 0;\n  let mut h = 0;\n  let mut i = 0;\n  let mut j = 0;\n  let mut k = 0;\n  let mut l = 0;\n  let mut m = 0;\n  let mut n = 0;\n  let mut o = 0;\n  let mut p = 0;\n  let mut q = 0;\n  let mut r = 0;\n  let mut s = 0;\n  let mut t = 0;\n  let mut u = 0;\n  let mut v = 0;\n  let mut w = 0;\n  let mut x = 0;\n  let mut y = 0;\n  let mut z = 0;\n  let mut a = 0;\n  let mut b = 0;\n  let mut c = 0;\n  let mut d = 0;\n  let mut e = 0;\n  let mut f = 0;\n  let mut g = 0;\n  let mut h = 0;\n  let mut i = 0;\n  let mut j = 0;\n  let mut k = 0;\n  let mut l = 0;\n  let mut m = 0;\n  let mut n = 0;\n  let mut o = 0;\n  let mut p = 0;\n  let mut q\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "error: expected `;`, found `}`\n  --> /tmp/tmp0aji3r25.rs:81:12\n   |\n81 |   let mut q\n   |            ^ help: add `;` here\n82 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp0aji3r25.rs:17:41\n   |\n17 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |    ------------                         ^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<String>`\n           found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns a vector of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty vector.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n/// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut words = Vec::new();\n    let mut word = String::new();\n    let mut last_consonant = String::new();\n    let mut consonant_count = 0;\n    let mut consonant_index = 0;\n    let mut consonant_index_prev = 0;\n    let mut consonant_index_next = 0;\n    let mut consonant_index_next_prev = 0;\n    let mut consonant_index_next_next = 0;\n    let mut consonant_index_next_next_prev = 0;\n    let mut consonant_index_next_next_next = 0;\n    let mut consonant_index_next_next_next_prev = 0;\n    let mut consonant_index_next_next_next_next = 0;\n    let mut consonant_index_next_next_next_next_prev = 0;\n    let mut consonant_index_next_next_next_next_next = 0;\n    let mut consonant_index_next_next_next_next_next_prev = 0;\n    let mut consonant_index_next_next_next_next_next_next = 0;\n    let mut consonant_index_next_next_next_next_next_next_prev = 0;\n    let mut consonant_index_next_next_next_next_next_next_next = 0;\n    let mut consonant_index_next_next_next_next_next_next_next_prev = 0;\n    let mut consonant_index_next_next_next_next_next_next_next_next = 0;\n    let mut consonant_index_next_next_next_next_next_next_next_next_prev = 0;\n    let mut consonant_index_next_next_next_next_next_next_next_next_next = 0;\n    let mut consonant_index_next_next_next_next_next_next_next_next_next_prev = 0;\n    let mut consonant_index_next_next_next_next_next_next_next_next_next_next = 0;\n    let mut consonant_index_next_next_next_next_\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "error: expected `;`, found `}`\n  --> /tmp/tmp2t10g2jq.rs:43:49\n   |\n43 |     let mut consonant_index_next_next_next_next_\n   |                                                 ^ help: add `;` here\n44 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2t10g2jq.rs:17:41\n   |\n17 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |    ------------                         ^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<String>`\n           found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns a vector of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty vector.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n/// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n  let mut result = Vec::new();\n  let mut word = String::new();\n  let mut count = 0;\n  for i in s.chars() {\n    if count == n {\n      result.push(word);\n      word = String::new();\n      count = 0;\n    }\n    if !is_consonant(i) {\n      word += String::from(i);\n      count += 1;\n    }\n  }\n  if count == n {\n    result.push(word);\n  }\n  return result;\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "error[E0425]: cannot find function `is_consonant` in this scope\n  --> /tmp/tmpnyvx3i7i.rs:27:9\n   |\n27 |     if !is_consonant(i) {\n   |         ^^^^^^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpnyvx3i7i.rs:28:15\n   |\n28 |       word += String::from(i);\n   |               ^^^^^^^^^^^^^^^\n   |               |\n   |               expected `&str`, found struct `String`\n   |               help: consider borrowing here: `&String::from(i)`\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0425.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns a vector of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty vector.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n/// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n  let mut words = Vec::new();\n  let mut word = String::new();\n  let mut word_count = 0;\n  let mut word_index = 0;\n  let mut word_index_end = 0;\n  let mut word_index_start = 0;\n  let mut word_index_start_end = 0;\n  let mut word_index_start_end_end = 0;\n  let mut word_index_start_end_end_end = 0;\n  let mut word_index_start_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end_end_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end_end_end_end\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "error: expected `;`, found `}`\n  --> /tmp/tmpkoz4q7r5.rs:39:67\n   |\n39 |   let mut word_index_start_end_end_end_end_end_end_end_end_end_end\n   |                                                                   ^ help: add `;` here\n40 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpkoz4q7r5.rs:17:41\n   |\n17 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |    ------------                         ^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<String>`\n           found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns a vector of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty vector.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n/// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n  let mut words = Vec::new();\n  let mut word = String::new();\n  let mut count = 0;\n  for (let i = 0; i < s.len(); i++) {\n    if (s[i] == ' ') {\n      if (count == n) {\n        words.push(word);\n        word = String::new();\n        count = 0;\n      }\n    } else {\n      if (count < n) {\n        word += s[i];\n        count += 1;\n      }\n    }\n  }\n  if (count == n) {\n    words.push(word);\n  }\n  words\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmpv3hl2tn2.rs:21:8\n   |\n21 |   for (let i = 0; i < s.len(); i++) {\n   |        ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmpv3hl2tn2.rs:21:12\n   |\n21 |   for (let i = 0; i < s.len(); i++) {\n   |           -^ expected one of `)`, `,`, `@`, or `|`\n   |           |\n   |           help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmpv3hl2tn2.rs:21:14\n   |\n21 |   for (let i = 0; i < s.len(); i++) {\n   |              ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmpv3hl2tn2.rs:21:13\n   |\n21 |   for (let i = 0; i < s.len(); i++) {\n   |             ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmpv3hl2tn2.rs:21:14\n   |\n21 |   for (let i = 0; i < s.len(); i++) {\n   |              ^ expected expression\n\nerror: aborting due to 5 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns a vector of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty vector.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n/// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut result = Vec::new();\n    let mut word = String::new();\n    let mut word_count = 0;\n    for i in s.chars() {\n        if word_count == n {\n            result.push(word);\n            word_count = 0;\n            word = String::new();\n        }\n        if i == ' ' {\n            continue;\n        }\n        if i == ' ' || i == '\\n' || i == '\\r' || i == '\\t' {\n            if word_count > 0 {\n                result.push(word);\n                word_count = 0;\n                word = String::new();\n            }\n            continue;\n        }\n        word = word.cat(String::from(i));\n        word_count += 1;\n    }\n    if word_count > 0 {\n        result.push(word);\n    }\n    return result;\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "error[E0599]: no method named `cat` found for struct `String` in the current scope\n  --> /tmp/tmp9jk6fwg5.rs:38:21\n   |\n38 |         word = word.cat(String::from(i));\n   |                     ^^^ method not found in `String`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0599`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns a vector of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty vector.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n/// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut result = Vec::new();\n    let mut word = String::new();\n    let mut count = 0;\n    for i in s.chars() {\n        if count == n {\n            result.push(word);\n            word = String::new();\n            count = 0;\n        }\n        if !is_consonant(i) {\n            word += String::from(i);\n            count += 1;\n        }\n    }\n    if count == n {\n        result.push(word);\n    }\n    return result;\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "error[E0425]: cannot find function `is_consonant` in this scope\n  --> /tmp/tmp2ahhuwue.rs:27:13\n   |\n27 |         if !is_consonant(i) {\n   |             ^^^^^^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2ahhuwue.rs:28:21\n   |\n28 |             word += String::from(i);\n   |                     ^^^^^^^^^^^^^^^\n   |                     |\n   |                     expected `&str`, found struct `String`\n   |                     help: consider borrowing here: `&String::from(i)`\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0425.\nFor more information about an error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns a vector of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty vector.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n/// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n  let mut words: Vec<String> = Vec::new();\n  let mut word: String = String::from(\"\");\n  let mut count: isize = 0;\n  for (let c: s) {\n    if (c == ' ') {\n      if (count == n) {\n        words.push(word);\n        word = String::from(\"\");\n        count = 0;\n      }\n    } else {\n      if (count < n) {\n        count += 1;\n        word += c;\n      } else {\n        if (count == n) {\n          words.push(word);\n          word = String::from(\"\");\n          count = 0;\n        }\n      }\n    }\n  }\n  if (count == n) {\n    words.push(word);\n  }\n  return words;\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmpr9y9wetb.rs:21:8\n   |\n21 |   for (let c: s) {\n   |        ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `c`\n  --> /tmp/tmpr9y9wetb.rs:21:12\n   |\n21 |   for (let c: s) {\n   |           -^ expected one of `)`, `,`, `@`, or `|`\n   |           |\n   |           help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `:`\n  --> /tmp/tmpr9y9wetb.rs:21:13\n   |\n21 |   for (let c: s) {\n   |             ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmpr9y9wetb.rs:21:13\n   |\n21 |   for (let c: s) {\n   |             ^ help: try adding `in` here\n\nerror: expected expression, found `:`\n  --> /tmp/tmpr9y9wetb.rs:21:13\n   |\n21 |   for (let c: s) {\n   |             ^ expected expression\n\nerror: aborting due to 5 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns a vector of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty vector.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n/// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n  let mut words = Vec::new();\n  let mut word = String::new();\n  let mut count = 0;\n  for i in s.chars() {\n    if count == n {\n      words.push(word);\n      word = String::new();\n      count = 0;\n    }\n    if s[i] == ' ' {\n      count += 1;\n    } else {\n      count += 1;\n      word.push_back(s[i]);\n    }\n  }\n  words.push(word);\n  return words;\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "error[E0277]: the type `String` cannot be indexed by `char`\n  --> /tmp/tmp8203_7t9.rs:27:8\n   |\n27 |     if s[i] == ' ' {\n   |        ^^^^ `String` cannot be indexed by `char`\n   |\n   = help: the trait `Index<char>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0599]: no method named `push_back` found for struct `String` in the current scope\n  --> /tmp/tmp8203_7t9.rs:31:12\n   |\n31 |       word.push_back(s[i]);\n   |            ^^^^^^^^^ method not found in `String`\n\nerror[E0277]: the type `String` cannot be indexed by `char`\n  --> /tmp/tmp8203_7t9.rs:31:22\n   |\n31 |       word.push_back(s[i]);\n   |                      ^^^^ `String` cannot be indexed by `char`\n   |\n   = help: the trait `Index<char>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0599.\nFor more information about an error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns a vector of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty vector.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n/// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n  let mut words = Vec::new();\n  let mut word = String::new();\n  let mut i = 0;\n  for (; i < s.len(); i++) {\n    if s[i] == ' ' {\n      if word.len() == n {\n        words.push(word);\n        word = String::new();\n      }\n    } else {\n      word.push_back(s[i]);\n    }\n  }\n  if word.len() == n {\n    words.push(word);\n  }\n  return words;\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "error: expected pattern, found `;`\n  --> /tmp/tmprb5g3o41.rs:21:8\n   |\n21 |   for (; i < s.len(); i++) {\n   |        ^ expected pattern\n\nerror: aborting due to previous error\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns a vector of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty vector.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n/// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut words = Vec::new();\n    let mut word = String::new();\n    let mut count = 0;\n    for i in s.chars() {\n        if count == n {\n            words.push(word);\n            word = String::new();\n            count = 0;\n        }\n        if s[i] == ' ' {\n            if !word.is_empty() {\n                words.push(word);\n                word = String::new();\n                count = 0;\n            }\n        } else {\n            word += s[i];\n            count += 1;\n        }\n    }\n    if !word.is_empty() {\n        words.push(word);\n    }\n    return words;\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "error[E0277]: the type `String` cannot be indexed by `char`\n  --> /tmp/tmp3o3n4tpw.rs:27:12\n   |\n27 |         if s[i] == ' ' {\n   |            ^^^^ `String` cannot be indexed by `char`\n   |\n   = help: the trait `Index<char>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `char`\n  --> /tmp/tmp3o3n4tpw.rs:34:21\n   |\n34 |             word += s[i];\n   |                     ^^^^ `String` cannot be indexed by `char`\n   |\n   = help: the trait `Index<char>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns a vector of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty vector.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n/// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n  let mut words = Vec::new();\n  let mut word = String::new();\n  let mut consonants = 0;\n  let mut consonant_index = 0;\n  let mut consonant_count = 0;\n  let mut consonant_index_end = 0;\n  let mut consonant_count_end = 0;\n  let mut consonant_index_start = 0;\n  let mut consonant_count_start = 0;\n  let mut consonant_index_end_start = 0;\n  let mut consonant_count_end_start = 0;\n  let mut consonant_index_end_end = 0;\n  let mut consonant_count_end_end = 0;\n  let mut consonant_index_start_end = 0;\n  let mut consonant_count_start_end = 0;\n  let mut consonant_index_start_start = 0;\n  let mut consonant_count_start_start = 0;\n  let mut consonant_index_end_start_start = 0;\n  let mut consonant_count_end_start_start = 0;\n  let mut consonant_index_end_end_start = 0;\n  let mut consonant_count_end_end_start = 0;\n  let mut consonant_index_start_end_start = 0;\n  let mut consonant_count_start_end_start = 0;\n  let mut consonant_index_end_end_end = 0;\n  let mut consonant_count_end_end_end = 0;\n  let mut consonant_index_start_end_end = 0;\n  let mut consonant_count_start_end_end = 0;\n  let mut consonant_index_start_start_end = 0;\n  let mut consonant_count_start_start_end = 0;\n  let mut consonant_index_end_start_start = 0;\n  let mut consonant_count_end_start_start = 0;\n  let mut consonant_index_end_end_start = 0;\n  let mut consonant_count_end_end_start = 0;\n  let mut consonant_index_start_end_start = 0;\n\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "error[E0308]: mismatched types\n  --> /tmp/tmpxoqtvmnt.rs:17:41\n   |\n17 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |    ------------                         ^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<String>`\n           found unit type `()`\n\nerror: aborting due to previous error\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns a vector of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty vector.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n/// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n  let mut words = Vec::new();\n  let mut word = String::new();\n  let mut word_count = 0;\n  let mut word_index = 0;\n  let mut word_index_prev = 0;\n  let mut word_index_next = 0;\n  let mut word_index_next_prev = 0;\n  let mut word_index_next_next = 0;\n  let mut word_index_next_next_prev = 0;\n  let mut word_index_next_next_next = 0;\n  let mut word_index_next_next_next_prev = 0;\n  let mut word_index_next_next_next_next = 0;\n  let mut word_index_next_next_next_next_prev = 0;\n  let mut word_index_next_next_next_next_next = 0;\n  let mut word_index_next_next_next_next_next_prev = 0;\n  let mut word_index_next_next_next_next_next_next = 0;\n  let mut word_index_next_next_next_next_next_next_prev = 0;\n  let mut word_index_next_next_next_next_next_next_next = 0;\n  let mut word_index_next_next_next_next_next_next_next_prev = 0;\n  let mut word_index_next_next_next_next_next_next_next_next = 0;\n  let mut word_index_next_next_next_next_next_next_next_next_prev = 0;\n  let mut word_index_next_next_next_next_next_next_next_next_next = 0;\n  let mut word_index_next_next_next_next_next_next_next_next_next_prev = 0;\n  let mut word_index_next_next_next_next_next_next_next_next_next_next = 0;\n  let mut word_index_next_next_next_next_next_next_next_next_next_next_prev = 0;\n  let mut word_index_next_next_next_next_next_next_next\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "error: expected `;`, found `}`\n  --> /tmp/tmp7ap3zsq5.rs:43:56\n   |\n43 |   let mut word_index_next_next_next_next_next_next_next\n   |                                                        ^ help: add `;` here\n44 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp7ap3zsq5.rs:17:41\n   |\n17 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |    ------------                         ^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<String>`\n           found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns a vector of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty vector.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n/// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n  let mut words = Vec::new();\n  let mut word = String::new();\n  let mut word_count = 0;\n  let mut word_index = 0;\n  let mut word_index_end = 0;\n  let mut word_index_start = 0;\n  let mut word_index_start_end = 0;\n  let mut word_index_start_end_end = 0;\n  let mut word_index_start_end_end_end = 0;\n  let mut word_index_start_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end_end_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end_end_end_end\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "error: expected `;`, found `}`\n  --> /tmp/tmpkoz4q7r5.rs:39:67\n   |\n39 |   let mut word_index_start_end_end_end_end_end_end_end_end_end_end\n   |                                                                   ^ help: add `;` here\n40 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpkoz4q7r5.rs:17:41\n   |\n17 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |    ------------                         ^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<String>`\n           found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns a vector of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty vector.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n/// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n  let mut words = Vec::new();\n  let mut word = String::new();\n  let mut word_count = 0;\n  let mut word_index = 0;\n  let mut word_index_end = 0;\n  let mut word_index_start = 0;\n  let mut word_index_start_end = 0;\n  let mut word_index_start_end_end = 0;\n  let mut word_index_start_end_end_end = 0;\n  let mut word_index_start_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end_end_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end_end_end_end\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "error: expected `;`, found `}`\n  --> /tmp/tmpkoz4q7r5.rs:39:67\n   |\n39 |   let mut word_index_start_end_end_end_end_end_end_end_end_end_end\n   |                                                                   ^ help: add `;` here\n40 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpkoz4q7r5.rs:17:41\n   |\n17 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |    ------------                         ^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<String>`\n           found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns a vector of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty vector.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n/// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n  let mut words = Vec::new();\n  let mut word = String::new();\n  let mut word_count = 0;\n  let mut word_index = 0;\n  let mut word_index_end = 0;\n  let mut word_index_start = 0;\n  let mut word_index_start_end = 0;\n  let mut word_index_start_end_end = 0;\n  let mut word_index_start_end_end_end = 0;\n  let mut word_index_start_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end_end_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end_end_end_end_end_end_end_end_end = 0;\n  let mut word_index_start_end_end_end_end_end_end_end_end_end_end\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "error: expected `;`, found `}`\n  --> /tmp/tmpkoz4q7r5.rs:39:67\n   |\n39 |   let mut word_index_start_end_end_end_end_end_end_end_end_end_end\n   |                                                                   ^ help: add `;` here\n40 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpkoz4q7r5.rs:17:41\n   |\n17 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |    ------------                         ^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<String>`\n           found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns a vector of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty vector.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n/// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n    let mut words = Vec::new();\n    let mut word = String::new();\n    let mut word_count = 0;\n    let mut word_index = 0;\n    let mut word_index_end = 0;\n    let mut word_index_start = 0;\n    let mut word_index_start_end = 0;\n    let mut word_index_start_start = 0;\n    let mut word_index_start_start_end = 0;\n    let mut word_index_start_start_start = 0;\n    let mut word_index_start_start_start_end = 0;\n    let mut word_index_start_start_start_start = 0;\n    let mut word_index_start_start_start_start_end = 0;\n    let mut word_index_start_start_start_start_start = 0;\n    let mut word_index_start_start_start_start_start_end = 0;\n    let mut word_index_start_start_start_start_start_start = 0;\n    let mut word_index_start_start_start_start_start_start_end = 0;\n    let mut word_index_start_start_start_start_start_start_start = 0;\n    let mut word_index_start_start_start_start_start_start_start_end = 0;\n    let mut word_index_start_start_start_start_start_start_start_start = 0;\n    let mut word_index_start_start_start_start_start_start_start_start_end = 0;\n    let mut word_index_start_start_start_start_start_start_start_start_start = 0;\n    let mut word_index_start_start_start_start_start_start_start_start_start_end = 0;\n    let mut word_index_start_start_start_start_start_start_start_start_start_start = 0;\n    let mut word_index_start_start_start_start_start_start_start_start_start_start_end = 0;\n    let mut word_index_start_start_start_start_start_start_start\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "error: expected `;`, found `}`\n  --> /tmp/tmpkb4lsiec.rs:43:65\n   |\n43 |     let mut word_index_start_start_start_start_start_start_start\n   |                                                                 ^ help: add `;` here\n44 | }\n   | - unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpkb4lsiec.rs:17:41\n   |\n17 | fn select_words(s: String, n: isize) -> Vec<String> {\n   |    ------------                         ^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n   |\n   = note: expected struct `Vec<String>`\n           found unit type `()`\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns a vector of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty vector.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n/// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n  let mut words = Vec::new();\n  let mut word = String::new();\n  let mut count = 0;\n  let mut i = 0;\n  while i < s.len() {\n    if s[i] == ' ' {\n      if count == n {\n        words.push(word);\n        word = String::new();\n        count = 0;\n      }\n      i += 1;\n    } else {\n      word.push_back(s[i]);\n      count += 1;\n      i += 1;\n    }\n  }\n  if count == n {\n    words.push(word);\n  }\n  return words;\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpx864v8c5.rs:23:8\n   |\n23 |     if s[i] == ' ' {\n   |        ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0599]: no method named `push_back` found for struct `String` in the current scope\n  --> /tmp/tmpx864v8c5.rs:31:12\n   |\n31 |       word.push_back(s[i]);\n   |            ^^^^^^^^^ method not found in `String`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpx864v8c5.rs:31:22\n   |\n31 |       word.push_back(s[i]);\n   |                      ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n             <String as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0599.\nFor more information about an error, try `rustc --explain E0277`.\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "/// Given a string s and a natural number n, you have been tasked to implement \n/// a function that returns a vector of all words from string s that contain exactly \n/// n consonants, in order these words appear in the string s.\n/// If the string s is empty then the function should return an empty vector.\n/// Note: you may assume the input string contains only letters and spaces.\n/// Examples:\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 4)\n/// vec![String::from(\"little\")]\n/// >>> select_words(String::from(\"Mary had a little lamb\"), 3)\n/// vec![String::from(\"Mary\"), String::from(\"lamb\")]\n/// >>> select_words(String::from(\"simple white space\"), 2)\n/// Vec::<String>::new()\n/// >>> select_words(String::from(\"Hello world\"), 4)\n/// vec![String::from(\"world\")]\n/// >>> select_words(String::from(\"Uncle sam\"), 3)\n/// vec![String::from(\"Uncle\")]\nfn select_words(s: String, n: isize) -> Vec<String> {\n  let mut words = Vec::new();\n  let mut word = String::new();\n  let mut count = 0;\n  for (let i = 0; i < s.len(); i++) {\n    if (s[i] == ' ') {\n      if (count == n) {\n        words.push(word);\n        word = String::new();\n        count = 0;\n      }\n    } else {\n      if (count == n) {\n        words.push(word);\n        word = String::new();\n        count = 0;\n      } else {\n        word += s[i];\n        count += 1;\n      }\n    }\n  }\n  if (count == n) {\n    words.push(word);\n  }\n  return words;\n}\n\nfn main() {\n    let candidate = select_words;\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 4), vec![String::from(\"little\")]);\n    assert_eq!(candidate(String::from(\"Mary had a little lamb\"), 3), vec![String::from(\"Mary\"), String::from(\"lamb\")]);\n    assert_eq!(candidate(String::from(\"simple white space\"), 2), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"Hello world\"), 4), vec![String::from(\"world\")]);\n    assert_eq!(candidate(String::from(\"Uncle sam\"), 3), vec![String::from(\"Uncle\")]);\n    assert_eq!(candidate(String::from(\"\"), 4), Vec::<String>::new());\n    assert_eq!(candidate(String::from(\"a b c d e f\"), 1), vec![String::from(\"b\"), String::from(\"c\"), String::from(\"d\"), String::from(\"f\")]);\n}\n",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "error: expected identifier, found keyword `let`\n  --> /tmp/tmp0evq20kn.rs:21:8\n   |\n21 |   for (let i = 0; i < s.len(); i++) {\n   |        ^^^ expected identifier, found keyword\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `i`\n  --> /tmp/tmp0evq20kn.rs:21:12\n   |\n21 |   for (let i = 0; i < s.len(); i++) {\n   |           -^ expected one of `)`, `,`, `@`, or `|`\n   |           |\n   |           help: missing `,`\n\nerror: expected one of `)`, `,`, `@`, or `|`, found `=`\n  --> /tmp/tmp0evq20kn.rs:21:14\n   |\n21 |   for (let i = 0; i < s.len(); i++) {\n   |              ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmp0evq20kn.rs:21:13\n   |\n21 |   for (let i = 0; i < s.len(); i++) {\n   |             ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n  --> /tmp/tmp0evq20kn.rs:21:14\n   |\n21 |   for (let i = 0; i < s.len(); i++) {\n   |              ^ expected expression\n\nerror: aborting due to 5 previous errors\n\n",
      "exit_code": 1,
      "status": "SyntaxError"
    }
  ]
}