{
  "name": "mbpp_721_maxAverageOfPath",
  "language": "js",
  "prompt": "//Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n",
  "doctests": "keep",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_721_maxAverageOfPath.py",
  "prompt_terminology": "verbatim",
  "tests": "const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
  "stop_tokens": [
    "\nfunction ",
    "\n/*",
    "\n//",
    "\nconsole.log"
  ],
  "results": [
    {
      "program": "//Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let n = cost.length;\n    let dp = new Array(n).fill(0).map(()=>new Array(n).fill(0));\n    dp[0][0] = cost[0][0];\n    for(let i = 1; i < n; i++){\n        dp[0][i] = dp[0][i-1] + cost[0][i];\n    }\n    for(let i = 1; i < n; i++){\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let i = 1; i < n; i++){\n        for(let j = 1; j < n; j++){\n            dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[n-1][n-1]/(2*n-1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1665509918,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    var n = cost.length;\n    var dp = new Array(n);\n    for(var i=0;i<n;i++){\n        dp[i] = new Array(n);\n    }\n    dp[0][0] = cost[0][0];\n    for(var i=1;i<n;i++){\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n        dp[0][i] = dp[0][i-1] + cost[0][i];\n    }\n    for(var i=1;i<n;i++){\n        for(var j=1;j<n;j++){\n            dp[i][j] = Math.max(dp[i-1][j],dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[n-1][n-1]/(2*n-1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1665509918,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let n = cost.length;\n    let dp = new Array(n);\n    for(let i=0; i<n; i++){\n        dp[i] = new Array(n);\n    }\n    dp[0][0] = cost[0][0];\n    for(let i=1; i<n; i++){\n        dp[0][i] = dp[0][i-1] + cost[0][i];\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let i=1; i<n; i++){\n        for(let j=1; j<n; j++){\n            dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[n-1][n-1]/(2*n-1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1665509918,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n  let rows = cost.length;\n  let cols = cost[0].length;\n  let dp = new Array(rows);\n  for(let i = 0; i < rows; i++){\n    dp[i] = new Array(cols);\n    for(let j = 0; j < cols; j++){\n      dp[i][j] = new Array(2);\n      dp[i][j][0] = 0;\n      dp[i][j][1] = 0;\n    }\n  }\n  dp[0][0][0] = cost[0][0];\n  dp[0][0][1] = 1;\n  for(let i = 1; i < rows; i++){\n    dp[i][0][0] = dp[i-1][0][0] + cost[i][0];\n    dp[i][0][1] = dp[i-1][0][1] + 1;\n  }\n  for(let j = 1; j < cols; j++){\n    dp[0][j][0] = dp[0][j-1][0] + cost[0][j];\n    dp[0][j][1] = dp[0][j-1][1] + 1;\n  }\n  for(let i = 1; i < rows; i++){\n    for(let j = 1; j < cols; j++){\n      let left = dp[i][j-1][0] + cost[i][j];\n      let leftCount = dp[i][j-1][1] + 1;\n      let up = dp[i-1][j][0] + cost[i][j];\n      let upCount = dp[i-1][j][1] + 1;\n      if(left/leftCount > up/upCount){\n        dp[i][j][0] = left;\n        dp[i][j][1] = leftCount;\n      } else {\n        dp[i][j][0] = up;\n        dp[i][j][1] = upCount;\n      }\n   \nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1665509918,
      "stdout": "",
      "stderr": "/tmp/tmpo_k_oxp9.js:49\ntest();\n       \n\nSyntaxError: Unexpected end of input\n    at Object.compileFunction (node:vm:360:18)\n    at wrapSafe (node:internal/modules/cjs/loader:1049:15)\n    at Module._compile (node:internal/modules/cjs/loader:1084:27)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47\n\nNode.js v18.7.0\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "//Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let n = cost.length;\n    let dp = new Array(n);\n    for(let i = 0; i < n; i++){\n        dp[i] = new Array(n);\n        for(let j = 0; j < n; j++){\n            dp[i][j] = new Array(2);\n        }\n    }\n    dp[0][0][0] = cost[0][0];\n    dp[0][0][1] = 1;\n    for(let i = 1; i < n; i++){\n        dp[i][0][0] = dp[i-1][0][0] + cost[i][0];\n        dp[i][0][1] = dp[i-1][0][1] + 1;\n        dp[0][i][0] = dp[0][i-1][0] + cost[0][i];\n        dp[0][i][1] = dp[0][i-1][1] + 1;\n    }\n    for(let i = 1; i < n; i++){\n        for(let j = 1; j < n; j++){\n            let a = dp[i-1][j][0] + cost[i][j];\n            let b = dp[i-1][j][1] + 1;\n            let c = dp[i][j-1][0] + cost[i][j];\n            let d = dp[i][j-1][1] + 1;\n            if(a/b > c/d){\n                dp[i][j][0] = a;\n                dp[i][j][1] = b;\n            }else{\n                dp[i][j][0] = c;\n                dp[i][j][1] = d;\n            }\n        }\n    }\n    return dp[n-1][n-1][0]/dp[n-1][n-1][1];\n}\n\nlet cost = [\n    [1,2,3],\n    [4,5,6],\n    [7,8,9]\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1665509918,
      "stdout": "",
      "stderr": "/tmp/tmptj4i1nd6.js:42\nconst assert = require('node:assert');\n^^^^^\n\nSyntaxError: Unexpected token 'const'\n    at Object.compileFunction (node:vm:360:18)\n    at wrapSafe (node:internal/modules/cjs/loader:1049:15)\n    at Module._compile (node:internal/modules/cjs/loader:1084:27)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47\n\nNode.js v18.7.0\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "//Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let n = cost.length;\n    let dp = new Array(n);\n    for(let i = 0; i < n; i++){\n        dp[i] = new Array(n);\n    }\n    dp[0][0] = cost[0][0];\n    for(let i = 1; i < n; i++){\n        dp[0][i] = dp[0][i-1] + cost[0][i];\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let i = 1; i < n; i++){\n        for(let j = 1; j < n; j++){\n            dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[n-1][n-1]/(2*n-1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1665509918,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let n = cost.length;\n    let dp = new Array(n).fill(0).map(() => new Array(n).fill(0));\n    dp[0][0] = cost[0][0];\n    for(let i = 1; i < n; i++){\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n        dp[0][i] = dp[0][i-1] + cost[0][i];\n    }\n    for(let i = 1; i < n; i++){\n        for(let j = 1; j < n; j++){\n            dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[n-1][n-1] / (2*n - 1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1665509918,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let n = cost.length;\n    let dp = new Array(n);\n    for(let i = 0; i < n; i++){\n        dp[i] = new Array(n);\n    }\n    dp[0][0] = cost[0][0];\n    for(let i = 1; i < n; i++){\n        dp[0][i] = dp[0][i-1] + cost[0][i];\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let i = 1; i < n; i++){\n        for(let j = 1; j < n; j++){\n            dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[n-1][n-1]/(2*n-1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1665509918,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n  let dp = [];\n  for(let i = 0; i < cost.length; i++){\n    dp.push([]);\n  }\n  dp[0][0] = cost[0][0];\n  for(let i = 1; i < cost.length; i++){\n    dp[0][i] = dp[0][i-1] + cost[0][i];\n  }\n  for(let i = 1; i < cost.length; i++){\n    dp[i][0] = dp[i-1][0] + cost[i][0];\n  }\n  for(let i = 1; i < cost.length; i++){\n    for(let j = 1; j < cost.length; j++){\n      dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n    }\n  }\n  return dp[cost.length-1][cost.length-1] / (2*cost.length - 1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1665509918,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    var n = cost.length;\n    var dp = [];\n    for(var i=0;i<n;i++){\n        dp[i] = [];\n        for(var j=0;j<n;j++){\n            if(i==0 && j==0){\n                dp[i][j] = cost[i][j];\n            }else if(i==0){\n                dp[i][j] = dp[i][j-1] + cost[i][j];\n            }else if(j==0){\n                dp[i][j] = dp[i-1][j] + cost[i][j];\n            }else{\n                dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n            }\n        }\n    }\n    return dp[n-1][n-1]/(2*n-1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1665509918,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let n = cost.length;\n    let dp = new Array(n).fill(0).map(() => new Array(n).fill(0));\n    dp[0][0] = cost[0][0];\n    for(let i = 1; i < n; i++){\n        dp[0][i] = dp[0][i-1] + cost[0][i];\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let i = 1; i < n; i++){\n        for(let j = 1; j < n; j++){\n            dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[n-1][n-1] / (2*n-1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1665509918,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n  let n = cost.length;\n  let dp = new Array(n).fill(0).map(()=>new Array(n).fill(0));\n  dp[0][0] = cost[0][0];\n  for(let i=1;i<n;i++){\n    dp[0][i] = dp[0][i-1] + cost[0][i];\n  }\n  for(let i=1;i<n;i++){\n    dp[i][0] = dp[i-1][0] + cost[i][0];\n  }\n  for(let i=1;i<n;i++){\n    for(let j=1;j<n;j++){\n      dp[i][j] = Math.max(dp[i-1][j],dp[i][j-1]) + cost[i][j];\n    }\n  }\n  return dp[n-1][n-1]/(2*n-1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1665509918,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let n = cost.length;\n    let dp = new Array(n);\n    for(let i = 0; i < n; i++){\n        dp[i] = new Array(n);\n    }\n    dp[0][0] = cost[0][0];\n    for(let i = 1; i < n; i++){\n        dp[0][i] = dp[0][i-1] + cost[0][i];\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let i = 1; i < n; i++){\n        for(let j = 1; j < n; j++){\n            dp[i][j] = cost[i][j] + Math.max(dp[i-1][j], dp[i][j-1]);\n        }\n    }\n    return dp[n-1][n-1] / (2*n-1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1665509918,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n  let n = cost.length;\n  let dp = new Array(n);\n  for(let i = 0; i < n; i++){\n    dp[i] = new Array(n);\n  }\n  dp[0][0] = cost[0][0];\n  for(let i = 1; i < n; i++){\n    dp[0][i] = dp[0][i-1] + cost[0][i];\n    dp[i][0] = dp[i-1][0] + cost[i][0];\n  }\n  for(let i = 1; i < n; i++){\n    for(let j = 1; j < n; j++){\n      dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n    }\n  }\n  return dp[n-1][n-1] / (2*n-1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1665509918,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let n = cost.length;\n    let dp = new Array(n).fill(0).map(()=>new Array(n).fill(0));\n    dp[0][0] = cost[0][0];\n    for(let i=1;i<n;i++){\n        dp[0][i] = dp[0][i-1] + cost[0][i];\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let i=1;i<n;i++){\n        for(let j=1;j<n;j++){\n            dp[i][j] = Math.max(dp[i-1][j],dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[n-1][n-1]/(2*n-1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1665509918,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n  let n = cost.length;\n  let dp = new Array(n).fill(0).map(() => new Array(n).fill(0));\n  dp[0][0] = cost[0][0];\n  for(let i = 1; i < n; i++){\n    dp[0][i] = dp[0][i-1] + cost[0][i];\n    dp[i][0] = dp[i-1][0] + cost[i][0];\n  }\n  for(let i = 1; i < n; i++){\n    for(let j = 1; j < n; j++){\n      dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n    }\n  }\n  return dp[n-1][n-1] / (2*n-1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1665509918,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n  let row = cost.length;\n  let col = cost[0].length;\n  let dp = [];\n  for(let i = 0; i < row; i++){\n    dp.push([]);\n  }\n  dp[0][0] = cost[0][0];\n  for(let i = 1; i < row; i++){\n    dp[i][0] = dp[i-1][0] + cost[i][0];\n  }\n  for(let j = 1; j < col; j++){\n    dp[0][j] = dp[0][j-1] + cost[0][j];\n  }\n  for(let i = 1; i < row; i++){\n    for(let j = 1; j < col; j++){\n      dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n    }\n  }\n  return dp[row-1][col-1]/(row+col-1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1665509918,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let row = cost.length;\n    let col = cost[0].length;\n    let dp = new Array(row);\n    for(let i = 0; i < row; i++){\n        dp[i] = new Array(col);\n    }\n    dp[0][0] = cost[0][0];\n    for(let i = 1; i < row; i++){\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let i = 1; i < col; i++){\n        dp[0][i] = dp[0][i-1] + cost[0][i];\n    }\n    for(let i = 1; i < row; i++){\n        for(let j = 1; j < col; j++){\n            dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[row-1][col-1] / (row + col - 1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1665509918,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let n = cost.length;\n    let dp = new Array(n);\n    for(let i = 0; i < n; i++){\n        dp[i] = new Array(n);\n    }\n    dp[0][0] = cost[0][0];\n    for(let i = 1; i < n; i++){\n        dp[0][i] = dp[0][i-1] + cost[0][i];\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let i = 1; i < n; i++){\n        for(let j = 1; j < n; j++){\n            dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[n-1][n-1] / (2*n - 1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1665509918,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n  let n = cost.length;\n  let m = cost[0].length;\n  let dp = new Array(n).fill(0).map(() => new Array(m).fill(0));\n  dp[0][0] = cost[0][0];\n  for(let i = 1; i < n; i++){\n    dp[i][0] = dp[i-1][0] + cost[i][0];\n  }\n  for(let j = 1; j < m; j++){\n    dp[0][j] = dp[0][j-1] + cost[0][j];\n  }\n  for(let i = 1; i < n; i++){\n    for(let j = 1; j < m; j++){\n      dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n    }\n  }\n  return dp[n-1][m-1] / (n+m-1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1665509918,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let rows = cost.length;\n    let cols = cost[0].length;\n    let dp = new Array(rows).fill(0).map(()=>new Array(cols).fill(0));\n    dp[0][0] = cost[0][0];\n    for(let i=1;i<rows;i++){\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let j=1;j<cols;j++){\n        dp[0][j] = dp[0][j-1] + cost[0][j];\n    }\n    for(let i=1;i<rows;i++){\n        for(let j=1;j<cols;j++){\n            dp[i][j] = Math.max(dp[i-1][j],dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[rows-1][cols-1]/(rows+cols-1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124040,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n  let rows = cost.length;\n  let cols = cost[0].length;\n  let dp = new Array(rows).fill(0).map(() => new Array(cols).fill(0));\n  dp[0][0] = cost[0][0];\n  for(let i = 1; i < rows; i++){\n    dp[i][0] = dp[i - 1][0] + cost[i][0];\n  }\n  for(let j = 1; j < cols; j++){\n    dp[0][j] = dp[0][j - 1] + cost[0][j];\n  }\n  for(let i = 1; i < rows; i++){\n    for(let j = 1; j < cols; j++){\n      dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]) + cost[i][j];\n    }\n  }\n  return dp[rows - 1][cols - 1] / (rows + cols - 1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124040,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let n = cost.length;\n    let dp = new Array(n);\n    for(let i = 0; i < n; i++){\n        dp[i] = new Array(n);\n    }\n    dp[0][0] = cost[0][0];\n    for(let i = 1; i < n; i++){\n        dp[0][i] = dp[0][i-1] + cost[0][i];\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let i = 1; i < n; i++){\n        for(let j = 1; j < n; j++){\n            dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[n-1][n-1]/(2*n-1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1665509918,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let n = cost.length;\n    let dp = new Array(n);\n    for(let i = 0; i < n; i++){\n        dp[i] = new Array(n);\n    }\n    dp[0][0] = cost[0][0];\n    for(let i = 1; i < n; i++){\n        dp[0][i] = dp[0][i-1] + cost[0][i];\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let i = 1; i < n; i++){\n        for(let j = 1; j < n; j++){\n            dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[n-1][n-1] / (2*n - 1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1665509918,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let n = cost.length;\n    let dp = new Array(n);\n    for(let i=0;i<n;i++){\n        dp[i] = new Array(n);\n    }\n    dp[0][0] = cost[0][0];\n    for(let i=1;i<n;i++){\n        dp[0][i] = dp[0][i-1] + cost[0][i];\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let i=1;i<n;i++){\n        for(let j=1;j<n;j++){\n            dp[i][j] = Math.max(dp[i-1][j],dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[n-1][n-1]/(2*n-1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124040,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let row = cost.length;\n    let col = cost[0].length;\n    let dp = new Array(row).fill(0).map(() => new Array(col).fill(0));\n    dp[0][0] = cost[0][0];\n    for(let i = 1; i < row; i++){\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let j = 1; j < col; j++){\n        dp[0][j] = dp[0][j-1] + cost[0][j];\n    }\n    for(let i = 1; i < row; i++){\n        for(let j = 1; j < col; j++){\n            dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[row-1][col-1] / (row + col - 1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124040,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let rows = cost.length;\n    let cols = cost[0].length;\n    let dp = new Array(rows).fill(0).map(() => new Array(cols).fill(0));\n    dp[0][0] = cost[0][0];\n    for(let i = 1; i < rows; i++){\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let j = 1; j < cols; j++){\n        dp[0][j] = dp[0][j-1] + cost[0][j];\n    }\n    for(let i = 1; i < rows; i++){\n        for(let j = 1; j < cols; j++){\n            dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[rows-1][cols-1] / (rows + cols - 1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124040,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let n = cost.length;\n    let dp = new Array(n).fill(0).map(() => new Array(n).fill(0));\n    dp[0][0] = cost[0][0];\n    for(let i = 1; i < n; i++){\n        dp[0][i] = dp[0][i-1] + cost[0][i];\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let i = 1; i < n; i++){\n        for(let j = 1; j < n; j++){\n            dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[n-1][n-1] / (2*n - 1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124040,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let n = cost.length;\n    let dp = new Array(n);\n    for(let i = 0; i < n; i++){\n        dp[i] = new Array(n);\n    }\n    dp[0][0] = cost[0][0];\n    for(let i = 1; i < n; i++){\n        dp[0][i] = dp[0][i-1] + cost[0][i];\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let i = 1; i < n; i++){\n        for(let j = 1; j < n; j++){\n            dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[n-1][n-1] / (2*n - 1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1665509918,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n  let rows = cost.length, cols = cost[0].length;\n  let dp = new Array(rows).fill(0).map(() => new Array(cols).fill(0));\n  dp[0][0] = cost[0][0];\n  for(let i = 1; i < rows; i++){\n    dp[i][0] = dp[i - 1][0] + cost[i][0];\n  }\n  for(let j = 1; j < cols; j++){\n    dp[0][j] = dp[0][j - 1] + cost[0][j];\n  }\n  for(let i = 1; i < rows; i++){\n    for(let j = 1; j < cols; j++){\n      dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]) + cost[i][j];\n    }\n  }\n  return dp[rows - 1][cols - 1] / (rows + cols - 1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124040,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n  let n = cost.length;\n  let dp = new Array(n).fill(0).map(()=>new Array(n).fill(0));\n  dp[0][0] = cost[0][0];\n  for(let i = 1; i < n; i++){\n    dp[i][0] = dp[i-1][0] + cost[i][0];\n    dp[0][i] = dp[0][i-1] + cost[0][i];\n  }\n  for(let i = 1; i < n; i++){\n    for(let j = 1; j < n; j++){\n      dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n    }\n  }\n  return dp[n-1][n-1] / (2*n-1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124040,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let n = cost.length;\n    let dp = new Array(n);\n    for(let i=0;i<n;i++){\n        dp[i] = new Array(n);\n    }\n    dp[0][0] = cost[0][0];\n    for(let i=1;i<n;i++){\n        dp[0][i] = dp[0][i-1] + cost[0][i];\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let i=1;i<n;i++){\n        for(let j=1;j<n;j++){\n            dp[i][j] = Math.max(dp[i-1][j],dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[n-1][n-1]/(2*n-1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124040,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let row = cost.length;\n    let col = cost[0].length;\n    let dp = new Array(row);\n    for(let i = 0; i < row; i++){\n        dp[i] = new Array(col);\n    }\n    dp[0][0] = cost[0][0];\n    for(let i = 1; i < row; i++){\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let i = 1; i < col; i++){\n        dp[0][i] = dp[0][i-1] + cost[0][i];\n    }\n    for(let i = 1; i < row; i++){\n        for(let j = 1; j < col; j++){\n            dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[row-1][col-1] / (row+col-1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124040,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let n = cost.length;\n    let dp = new Array(n).fill(0).map(() => new Array(n).fill(0));\n    dp[0][0] = cost[0][0];\n    for(let i = 1; i < n; i++){\n        dp[0][i] = dp[0][i-1] + cost[0][i];\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let i = 1; i < n; i++){\n        for(let j = 1; j < n; j++){\n            dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[n-1][n-1] / (2*n - 1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124040,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let m = cost.length;\n    let n = cost[0].length;\n    let dp = new Array(m);\n    for(let i = 0; i < m; i++){\n        dp[i] = new Array(n);\n    }\n    dp[0][0] = cost[0][0];\n    for(let i = 1; i < m; i++){\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let j = 1; j < n; j++){\n        dp[0][j] = dp[0][j-1] + cost[0][j];\n    }\n    for(let i = 1; i < m; i++){\n        for(let j = 1; j < n; j++){\n            dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[m-1][n-1] / (m+n-1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124040,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let n = cost.length;\n    let dp = new Array(n);\n    for(let i = 0; i < n; i++){\n        dp[i] = new Array(n);\n    }\n    dp[0][0] = cost[0][0];\n    for(let i = 1; i < n; i++){\n        dp[0][i] = dp[0][i-1] + cost[0][i];\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let i = 1; i < n; i++){\n        for(let j = 1; j < n; j++){\n            dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[n-1][n-1] / (2*n - 1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1665509918,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n  let n = cost.length;\n  let dp = new Array(n).fill(0).map(()=>new Array(n).fill(0));\n  dp[0][0] = cost[0][0];\n  for(let i=1;i<n;i++){\n    dp[0][i] = dp[0][i-1]+cost[0][i];\n    dp[i][0] = dp[i-1][0]+cost[i][0];\n  }\n  for(let i=1;i<n;i++){\n    for(let j=1;j<n;j++){\n      dp[i][j] = Math.max(dp[i-1][j],dp[i][j-1])+cost[i][j];\n    }\n  }\n  return dp[n-1][n-1]/(2*n-1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124040,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n\tvar n = cost.length;\n\tvar dp = new Array(n);\n\tfor(var i = 0; i < n; i++){\n\t\tdp[i] = new Array(n);\n\t}\n\tdp[0][0] = cost[0][0];\n\tfor(var i = 1; i < n; i++){\n\t\tdp[0][i] = dp[0][i-1] + cost[0][i];\n\t\tdp[i][0] = dp[i-1][0] + cost[i][0];\n\t}\n\tfor(var i = 1; i < n; i++){\n\t\tfor(var j = 1; j < n; j++){\n\t\t\tdp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n\t\t}\n\t}\n\treturn dp[n-1][n-1]/(2*n-1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124040,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let n = cost.length;\n    let dp = new Array(n);\n    for(let i = 0; i < n; i++){\n        dp[i] = new Array(n);\n    }\n    dp[0][0] = cost[0][0];\n    for(let i = 1; i < n; i++){\n        dp[0][i] = dp[0][i-1] + cost[0][i];\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let i = 1; i < n; i++){\n        for(let j = 1; j < n; j++){\n            dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[n-1][n-1] / (2*n - 1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1665509918,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let n = cost.length;\n    let dp = new Array(n).fill(0).map(()=>new Array(n).fill(0));\n    dp[0][0] = cost[0][0];\n    for(let i = 1; i < n; i++){\n        dp[0][i] = dp[0][i-1] + cost[0][i];\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let i = 1; i < n; i++){\n        for(let j = 1; j < n; j++){\n            dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[n-1][n-1]/(2*n-1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124040,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n  let n = cost.length;\n  let dp = new Array(n).fill(0).map(()=>new Array(n).fill(0));\n  dp[0][0] = cost[0][0];\n  for(let i = 1; i < n; i++){\n    dp[0][i] = dp[0][i-1] + cost[0][i];\n    dp[i][0] = dp[i-1][0] + cost[i][0];\n  }\n  for(let i = 1; i < n; i++){\n    for(let j = 1; j < n; j++){\n      dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n    }\n  }\n  return dp[n-1][n-1]/(2*n-1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124040,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let n = cost.length;\n    let dp = new Array(n).fill(0).map(()=>new Array(n).fill(0));\n    dp[0][0] = cost[0][0];\n    for(let i = 1; i < n; i++){\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n        dp[0][i] = dp[0][i-1] + cost[0][i];\n    }\n    for(let i = 1; i < n; i++){\n        for(let j = 1; j < n; j++){\n            dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[n-1][n-1]/(2*n-1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124040,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let n = cost.length;\n    let dp = new Array(n);\n    for(let i = 0; i < n; i++){\n        dp[i] = new Array(n).fill(0);\n    }\n    dp[0][0] = cost[0][0];\n    for(let i = 1; i < n; i++){\n        dp[0][i] = dp[0][i-1] + cost[0][i];\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let i = 1; i < n; i++){\n        for(let j = 1; j < n; j++){\n            dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[n-1][n-1]/(2*n-1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124040,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let row = cost.length;\n    let col = cost[0].length;\n    let dp = new Array(row).fill(0).map(() => new Array(col).fill(0));\n    dp[0][0] = cost[0][0];\n    for(let i = 1; i < row; i++){\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let j = 1; j < col; j++){\n        dp[0][j] = dp[0][j-1] + cost[0][j];\n    }\n    for(let i = 1; i < row; i++){\n        for(let j = 1; j < col; j++){\n            dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[row-1][col-1] / (row + col - 1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124040,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let n = cost.length;\n    let dp = new Array(n).fill(0).map(() => new Array(n).fill(0));\n    dp[0][0] = cost[0][0];\n    for(let i = 1; i < n; i++){\n        dp[0][i] = dp[0][i-1] + cost[0][i];\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let i = 1; i < n; i++){\n        for(let j = 1; j < n; j++){\n            dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[n-1][n-1] / (2*n - 1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124040,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let n = cost.length;\n    let dp = new Array(n);\n    for(let i=0;i<n;i++){\n        dp[i] = new Array(n);\n    }\n    dp[0][0] = cost[0][0];\n    for(let i=1;i<n;i++){\n        dp[0][i] = dp[0][i-1] + cost[0][i];\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let i=1;i<n;i++){\n        for(let j=1;j<n;j++){\n            dp[i][j] = Math.max(dp[i-1][j],dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[n-1][n-1]/(2*n-1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124040,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let n = cost.length;\n    let dp = new Array(n);\n    for(let i = 0; i < n; i++){\n        dp[i] = new Array(n);\n    }\n    dp[0][0] = cost[0][0];\n    for(let i = 1; i < n; i++){\n        dp[0][i] = dp[0][i-1] + cost[0][i];\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let i = 1; i < n; i++){\n        for(let j = 1; j < n; j++){\n            dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[n-1][n-1] / (2*n-1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124040,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let row = cost.length;\n    let col = cost[0].length;\n    let dp = new Array(row);\n    for(let i = 0; i < row; i++){\n        dp[i] = new Array(col);\n    }\n    dp[0][0] = cost[0][0];\n    for(let i = 1; i < row; i++){\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let i = 1; i < col; i++){\n        dp[0][i] = dp[0][i-1] + cost[0][i];\n    }\n    for(let i = 1; i < row; i++){\n        for(let j = 1; j < col; j++){\n            dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[row-1][col-1] / (row + col - 1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1665509918,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let dp = new Array(cost.length);\n    for(let i = 0; i < cost.length; i++){\n        dp[i] = new Array(cost.length);\n    }\n    dp[0][0] = cost[0][0];\n    for(let i = 1; i < cost.length; i++){\n        dp[0][i] = dp[0][i-1] + cost[0][i];\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let i = 1; i < cost.length; i++){\n        for(let j = 1; j < cost.length; j++){\n            dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[cost.length-1][cost.length-1] / (2*cost.length - 1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124040,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n  let n = cost.length;\n  let dp = Array(n).fill(0).map(() => Array(n).fill(0));\n  dp[0][0] = cost[0][0];\n  for(let i = 1; i < n; i++){\n    dp[0][i] = dp[0][i-1] + cost[0][i];\n    dp[i][0] = dp[i-1][0] + cost[i][0];\n  }\n  for(let i = 1; i < n; i++){\n    for(let j = 1; j < n; j++){\n      dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n    }\n  }\n  return dp[n-1][n-1] / (2*n - 1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124040,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let row = cost.length;\n    let col = cost[0].length;\n    let dp = new Array(row);\n    for(let i = 0; i < row; i++){\n        dp[i] = new Array(col);\n    }\n    dp[0][0] = cost[0][0];\n    for(let i = 1; i < row; i++){\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let i = 1; i < col; i++){\n        dp[0][i] = dp[0][i-1] + cost[0][i];\n    }\n    for(let i = 1; i < row; i++){\n        for(let j = 1; j < col; j++){\n            dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[row-1][col-1]/(row+col-1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124040,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n  let n = cost.length;\n  let dp = new Array(n).fill(0).map(() => new Array(n).fill(0));\n  dp[0][0] = cost[0][0];\n  for(let i = 1; i < n; i++){\n    dp[0][i] = dp[0][i-1] + cost[0][i];\n  }\n  for(let i = 1; i < n; i++){\n    dp[i][0] = dp[i-1][0] + cost[i][0];\n  }\n  for(let i = 1; i < n; i++){\n    for(let j = 1; j < n; j++){\n      dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n    }\n  }\n  return dp[n-1][n-1] / (2*n - 1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124040,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let n = cost.length;\n    let dp = new Array(n);\n    for(let i = 0; i < n; i++){\n        dp[i] = new Array(n);\n    }\n    dp[0][0] = cost[0][0];\n    for(let i = 1; i < n; i++){\n        dp[0][i] = dp[0][i-1] + cost[0][i];\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let i = 1; i < n; i++){\n        for(let j = 1; j < n; j++){\n            dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[n-1][n-1] / (2*n-1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124040,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n  let rows = cost.length;\n  let cols = cost[0].length;\n  let dp = new Array(rows);\n  for(let i=0; i<rows; i++){\n    dp[i] = new Array(cols);\n  }\n  dp[0][0] = cost[0][0];\n  for(let i=1; i<rows; i++){\n    dp[i][0] = dp[i-1][0] + cost[i][0];\n  }\n  for(let j=1; j<cols; j++){\n    dp[0][j] = dp[0][j-1] + cost[0][j];\n  }\n  for(let i=1; i<rows; i++){\n    for(let j=1; j<cols; j++){\n      dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n    }\n  }\n  return dp[rows-1][cols-1] / (rows+cols-1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124040,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let n = cost.length;\n    let dp = new Array(n);\n    for(let i=0;i<n;i++){\n        dp[i] = new Array(n);\n    }\n    dp[0][0] = cost[0][0];\n    for(let i=1;i<n;i++){\n        dp[0][i] = dp[0][i-1] + cost[0][i];\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let i=1;i<n;i++){\n        for(let j=1;j<n;j++){\n            dp[i][j] = Math.max(dp[i-1][j],dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[n-1][n-1]/(2*n-1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124040,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let n = cost.length;\n    let dp = new Array(n).fill(0).map(() => new Array(n).fill(0));\n    dp[0][0] = cost[0][0];\n    for(let i = 1; i < n; i++){\n        dp[0][i] = dp[0][i-1] + cost[0][i];\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let i = 1; i < n; i++){\n        for(let j = 1; j < n; j++){\n            dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[n-1][n-1] / (2*n - 1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124040,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let n = cost.length;\n    let dp = new Array(n);\n    for(let i = 0; i < n; i++){\n        dp[i] = new Array(n);\n    }\n    dp[0][0] = cost[0][0];\n    for(let i = 1; i < n; i++){\n        dp[0][i] = dp[0][i-1] + cost[0][i];\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let i = 1; i < n; i++){\n        for(let j = 1; j < n; j++){\n            dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[n-1][n-1] / (2*n - 1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1665509918,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let n = cost.length;\n    let dp = new Array(n);\n    for(let i = 0; i < n; i++){\n        dp[i] = new Array(n);\n    }\n    dp[0][0] = cost[0][0];\n    for(let i = 1; i < n; i++){\n        dp[0][i] = dp[0][i-1] + cost[0][i];\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let i = 1; i < n; i++){\n        for(let j = 1; j < n; j++){\n            dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[n-1][n-1]/(2*n-1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1665509918,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let dp = [];\n    for(let i = 0; i < cost.length; i++){\n        dp.push([]);\n    }\n    dp[0][0] = cost[0][0];\n    for(let i = 1; i < cost.length; i++){\n        dp[0][i] = dp[0][i-1] + cost[0][i];\n    }\n    for(let i = 1; i < cost.length; i++){\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let i = 1; i < cost.length; i++){\n        for(let j = 1; j < cost.length; j++){\n            dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[cost.length-1][cost.length-1]/(2*cost.length-1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124040,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let n = cost.length;\n    let dp = [];\n    for(let i = 0; i < n; i++){\n        dp.push([]);\n        for(let j = 0; j < n; j++){\n            dp[i].push(0);\n        }\n    }\n    dp[0][0] = cost[0][0];\n    for(let i = 1; i < n; i++){\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n        dp[0][i] = dp[0][i-1] + cost[0][i];\n    }\n    for(let i = 1; i < n; i++){\n        for(let j = 1; j < n; j++){\n            dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[n-1][n-1] / (2*n - 1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124040,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let n = cost.length;\n    let m = cost[0].length;\n    let dp = new Array(n).fill(0).map(() => new Array(m).fill(0));\n    dp[0][0] = cost[0][0];\n    for(let i = 1; i < n; i++){\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let j = 1; j < m; j++){\n        dp[0][j] = dp[0][j-1] + cost[0][j];\n    }\n    for(let i = 1; i < n; i++){\n        for(let j = 1; j < m; j++){\n            dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[n-1][m-1] / (n+m-1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124040,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let row = cost.length;\n    let col = cost[0].length;\n    let dp = new Array(row);\n    for(let i = 0; i < row; i++){\n        dp[i] = new Array(col);\n    }\n    dp[0][0] = cost[0][0];\n    for(let i = 1; i < row; i++){\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let j = 1; j < col; j++){\n        dp[0][j] = dp[0][j-1] + cost[0][j];\n    }\n    for(let i = 1; i < row; i++){\n        for(let j = 1; j < col; j++){\n            dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[row-1][col-1]/(row+col-1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124040,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n  let n = cost.length;\n  let dp = new Array(n);\n  for(let i = 0; i < n; i++){\n    dp[i] = new Array(n);\n  }\n  dp[0][0] = cost[0][0];\n  for(let i = 1; i < n; i++){\n    dp[0][i] = dp[0][i-1] + cost[0][i];\n    dp[i][0] = dp[i-1][0] + cost[i][0];\n  }\n  for(let i = 1; i < n; i++){\n    for(let j = 1; j < n; j++){\n      dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n    }\n  }\n  return dp[n-1][n-1] / (2*n - 1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124040,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let n = cost.length;\n    let dp = new Array(n);\n    for(let i = 0; i < n; i++){\n        dp[i] = new Array(n);\n    }\n    dp[0][0] = cost[0][0];\n    for(let i = 1; i < n; i++){\n        dp[0][i] = dp[0][i-1] + cost[0][i];\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let i = 1; i < n; i++){\n        for(let j = 1; j < n; j++){\n            dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[n-1][n-1]/(2*n-1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1665509918,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let n = cost.length;\n    let dp = new Array(n);\n    for(let i = 0; i < n; i++){\n        dp[i] = new Array(n);\n    }\n    dp[0][0] = cost[0][0];\n    for(let i = 1; i < n; i++){\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n        dp[0][i] = dp[0][i-1] + cost[0][i];\n    }\n    for(let i = 1; i < n; i++){\n        for(let j = 1; j < n; j++){\n            dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[n-1][n-1] / (2*n - 1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124040,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let n = cost.length;\n    let dp = new Array(n).fill(0).map(() => new Array(n).fill(0));\n    dp[0][0] = cost[0][0];\n    for(let i = 1; i < n; i++){\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n        dp[0][i] = dp[0][i-1] + cost[0][i];\n    }\n    for(let i = 1; i < n; i++){\n        for(let j = 1; j < n; j++){\n            dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[n-1][n-1] / (2*n - 1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1665509918,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n  let n = cost.length;\n  let dp = new Array(n).fill(0).map(() => new Array(n).fill(0));\n  dp[0][0] = cost[0][0];\n  for(let i = 1; i < n; i++){\n    dp[i][0] = dp[i-1][0] + cost[i][0];\n    dp[0][i] = dp[0][i-1] + cost[0][i];\n  }\n  for(let i = 1; i < n; i++){\n    for(let j = 1; j < n; j++){\n      dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n    }\n  }\n  return dp[n-1][n-1]/(2*n-1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124040,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n  let n = cost.length;\n  let dp = new Array(n);\n  for(let i = 0; i < n; i++){\n    dp[i] = new Array(n);\n  }\n  dp[0][0] = cost[0][0];\n  for(let i = 1; i < n; i++){\n    dp[0][i] = dp[0][i-1] + cost[0][i];\n    dp[i][0] = dp[i-1][0] + cost[i][0];\n  }\n  for(let i = 1; i < n; i++){\n    for(let j = 1; j < n; j++){\n      dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n    }\n  }\n  return dp[n-1][n-1] / (2*n - 1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124040,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n  var max = 0;\n  var sum = 0;\n  var count = 0;\n  for(var i = 0; i < cost.length; i++){\n    for(var j = 0; j < cost[i].length; j++){\n      sum += cost[i][j];\n      count++;\n      if(i === cost.length - 1 && j === cost[i].length - 1){\n        if(max < sum/count){\n          max = sum/count;\n        }\n      }\n    }\n  }\n  return max;\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124040,
      "stdout": "",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n4.444444444444445\n\nshould loosely deep-equal\n\n5.2\n    at test (/tmp/tmpt_rly6pd.js:25:10)\n    at Object.<anonymous> (/tmp/tmpt_rly6pd.js:31:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: 4.444444444444445,\n  expected: 5.2,\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "exit_code": 1,
      "status": "AssertionError"
    },
    {
      "program": "//Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let n = cost.length;\n    let dp = new Array(n);\n    for(let i = 0; i < n; i++){\n        dp[i] = new Array(n);\n    }\n    dp[0][0] = cost[0][0];\n    for(let i = 1; i < n; i++){\n        dp[0][i] = dp[0][i-1] + cost[0][i];\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let i = 1; i < n; i++){\n        for(let j = 1; j < n; j++){\n            dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[n-1][n-1]/(2*n-1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1665509918,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    var row = cost.length;\n    var col = cost[0].length;\n    var dp = new Array(row);\n    for(var i = 0; i < row; i++){\n        dp[i] = new Array(col);\n    }\n    dp[0][0] = cost[0][0];\n    for(var i = 1; i < row; i++){\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(var i = 1; i < col; i++){\n        dp[0][i] = dp[0][i-1] + cost[0][i];\n    }\n    for(var i = 1; i < row; i++){\n        for(var j = 1; j < col; j++){\n            dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n        }\n    }\n    var max = dp[row-1][col-1];\n    var count = row + col - 1;\n    return max / count;\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124040,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let n = cost.length;\n    let dp = new Array(n);\n    for(let i = 0; i < n; i++){\n        dp[i] = new Array(n);\n    }\n    dp[0][0] = cost[0][0];\n    for(let i = 1; i < n; i++){\n        dp[0][i] = dp[0][i-1] + cost[0][i];\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let i = 1; i < n; i++){\n        for(let j = 1; j < n; j++){\n            dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[n-1][n-1] / (2*n-1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124040,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n  let n = cost.length;\n  let dp = new Array(n);\n  for(let i = 0; i < n; i++){\n    dp[i] = new Array(n);\n  }\n  dp[0][0] = cost[0][0];\n  for(let i = 1; i < n; i++){\n    dp[0][i] = dp[0][i-1] + cost[0][i];\n    dp[i][0] = dp[i-1][0] + cost[i][0];\n  }\n  for(let i = 1; i < n; i++){\n    for(let j = 1; j < n; j++){\n      dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n    }\n  }\n  return dp[n-1][n-1] / (2*n-1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1665509918,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let rows = cost.length;\n    let cols = cost[0].length;\n    let dp = new Array(rows).fill(0).map(()=>new Array(cols).fill(0));\n    dp[0][0] = cost[0][0];\n    for(let i=1;i<rows;i++){\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let j=1;j<cols;j++){\n        dp[0][j] = dp[0][j-1] + cost[0][j];\n    }\n    for(let i=1;i<rows;i++){\n        for(let j=1;j<cols;j++){\n            dp[i][j] = Math.max(dp[i-1][j],dp[i][j-1]) + cost[i][j];\n        }\n    }\n    let path = [];\n    let i = rows-1;\n    let j = cols-1;\n    while(i>0 || j>0){\n        path.push(cost[i][j]);\n        if(i==0){\n            j--;\n        }\n        else if(j==0){\n            i--;\n        }\n        else if(dp[i-1][j] > dp[i][j-1]){\n            i--;\n        }\n        else{\n            j--;\n        }\n    }\n    path.push(cost[0][0]);\n    return path.reverse();\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124040,
      "stdout": "",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n[\n  1,\n  6,\n  7,\n  3,\n  9\n]\n\nshould loosely deep-equal\n\n5.2\n    at test (/tmp/tmpjvigyrbj.js:45:10)\n    at Object.<anonymous> (/tmp/tmpjvigyrbj.js:51:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: [ 1, 6, 7, 3, 9 ],\n  expected: 5.2,\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "exit_code": 1,
      "status": "AssertionError"
    },
    {
      "program": "//Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n  let n = cost.length;\n  let dp = new Array(n);\n  for(let i = 0; i < n; i++){\n    dp[i] = new Array(n);\n    for(let j = 0; j < n; j++){\n      dp[i][j] = new Array(2);\n    }\n  }\n  dp[0][0][0] = cost[0][0];\n  dp[0][0][1] = 1;\n  for(let i = 1; i < n; i++){\n    dp[0][i][0] = dp[0][i-1][0] + cost[0][i];\n    dp[0][i][1] = dp[0][i-1][1] + 1;\n    dp[i][0][0] = dp[i-1][0][0] + cost[i][0];\n    dp[i][0][1] = dp[i-1][0][1] + 1;\n  }\n  for(let i = 1; i < n; i++){\n    for(let j = 1; j < n; j++){\n      dp[i][j][0] = Math.max(dp[i-1][j][0], dp[i][j-1][0]) + cost[i][j];\n      dp[i][j][1] = Math.max(dp[i-1][j][1], dp[i][j-1][1]) + 1;\n    }\n  }\n  return dp[n-1][n-1][0] / dp[n-1][n-1][1];\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124040,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let n = cost.length;\n    let dp = Array(n).fill(0).map(() => Array(n).fill(0));\n    dp[0][0] = cost[0][0];\n    for(let i = 1; i < n; i++){\n        dp[0][i] = dp[0][i-1] + cost[0][i];\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let i = 1; i < n; i++){\n        for(let j = 1; j < n; j++){\n            dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[n-1][n-1] / (2*n - 1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124040,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let rows = cost.length;\n    let cols = cost[0].length;\n    let dp = Array(rows).fill().map(() => Array(cols).fill(0));\n    dp[0][0] = cost[0][0];\n    for(let i=1; i<rows; i++){\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let j=1; j<cols; j++){\n        dp[0][j] = dp[0][j-1] + cost[0][j];\n    }\n    for(let i=1; i<rows; i++){\n        for(let j=1; j<cols; j++){\n            dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[rows-1][cols-1]/(rows+cols-1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124040,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let n = cost.length;\n    let dp = new Array(n);\n    for(let i = 0; i < n; i++){\n        dp[i] = new Array(n);\n    }\n    dp[0][0] = cost[0][0];\n    for(let i = 1; i < n; i++){\n        dp[0][i] = dp[0][i-1] + cost[0][i];\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let i = 1; i < n; i++){\n        for(let j = 1; j < n; j++){\n            dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[n-1][n-1] / (2*n - 1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1665509918,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let n = cost.length;\n    let dp = new Array(n).fill(0).map(() => new Array(n).fill(0));\n    dp[0][0] = cost[0][0];\n    for(let i = 1; i < n; i++){\n        dp[0][i] = dp[0][i-1] + cost[0][i];\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let i = 1; i < n; i++){\n        for(let j = 1; j < n; j++){\n            dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[n-1][n-1] / (2*n - 1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124040,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let n = cost.length;\n    let dp = new Array(n);\n    for(let i = 0; i < n; i++){\n        dp[i] = new Array(n);\n    }\n    dp[0][0] = cost[0][0];\n    for(let i = 1; i < n; i++){\n        dp[0][i] = dp[0][i-1] + cost[0][i];\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let i = 1; i < n; i++){\n        for(let j = 1; j < n; j++){\n            dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[n-1][n-1] / (2*n - 1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1665509918,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n  let row = cost.length;\n  let col = cost[0].length;\n  let dp = new Array(row).fill(0).map(() => new Array(col).fill(0));\n  dp[0][0] = cost[0][0];\n  for(let i = 1; i < row; i++){\n    dp[i][0] = dp[i-1][0] + cost[i][0];\n  }\n  for(let j = 1; j < col; j++){\n    dp[0][j] = dp[0][j-1] + cost[0][j];\n  }\n  for(let i = 1; i < row; i++){\n    for(let j = 1; j < col; j++){\n      dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n    }\n  }\n  return dp[row-1][col-1] / (row + col - 1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124040,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    var n = cost.length;\n    var dp = new Array(n);\n    for(var i = 0; i < n; i++){\n        dp[i] = new Array(n);\n        for(var j = 0; j < n; j++){\n            dp[i][j] = new Array(2);\n            dp[i][j][0] = 0;\n            dp[i][j][1] = 0;\n        }\n    }\n    dp[0][0][0] = cost[0][0];\n    dp[0][0][1] = 1;\n    for(var i = 1; i < n; i++){\n        dp[0][i][0] = dp[0][i-1][0] + cost[0][i];\n        dp[0][i][1] = dp[0][i-1][1] + 1;\n        dp[i][0][0] = dp[i-1][0][0] + cost[i][0];\n        dp[i][0][1] = dp[i-1][0][1] + 1;\n    }\n    for(var i = 1; i < n; i++){\n        for(var j = 1; j < n; j++){\n            dp[i][j][0] = Math.max(dp[i-1][j][0], dp[i][j-1][0]) + cost[i][j];\n            dp[i][j][1] = Math.max(dp[i-1][j][1], dp[i][j-1][1]) + 1;\n        }\n    }\n    return dp[n-1][n-1][0]/dp[n-1][n-1][1];\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124040,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let n = cost.length;\n    let dp = new Array(n).fill(0).map(() => new Array(n).fill(0));\n    dp[0][0] = cost[0][0];\n    for(let i = 1; i < n; i++){\n        dp[0][i] = dp[0][i-1] + cost[0][i];\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let i = 1; i < n; i++){\n        for(let j = 1; j < n; j++){\n            dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[n-1][n-1] / (2*n - 1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124040,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let n = cost.length;\n    let dp = new Array(n).fill(0).map(() => new Array(n).fill(0));\n    dp[0][0] = cost[0][0];\n    for(let i = 1; i < n; i++){\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n        dp[0][i] = dp[0][i-1] + cost[0][i];\n    }\n    for(let i = 1; i < n; i++){\n        for(let j = 1; j < n; j++){\n            dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[n-1][n-1] / (2*n - 1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1665509918,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let n = cost.length;\n    let dp = new Array(n).fill(0).map(()=>new Array(n).fill(0));\n    dp[0][0] = cost[0][0];\n    for(let i=1;i<n;i++){\n        dp[0][i] = dp[0][i-1] + cost[0][i];\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let i=1;i<n;i++){\n        for(let j=1;j<n;j++){\n            dp[i][j] = Math.max(dp[i-1][j],dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[n-1][n-1]/(2*n-1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1665509918,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let n = cost.length;\n    let dp = new Array(n).fill(0).map(() => new Array(n).fill(0));\n    dp[0][0] = cost[0][0];\n    for(let i = 1; i < n; i++){\n        dp[0][i] = dp[0][i-1] + cost[0][i];\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let i = 1; i < n; i++){\n        for(let j = 1; j < n; j++){\n            dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[n-1][n-1] / (2*n - 1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124040,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n  let n = cost.length;\n  let dp = new Array(n).fill(0).map(() => new Array(n).fill(0));\n  dp[0][0] = cost[0][0];\n  for(let i = 1; i < n; i++){\n    dp[0][i] = dp[0][i-1] + cost[0][i];\n    dp[i][0] = dp[i-1][0] + cost[i][0];\n  }\n  for(let i = 1; i < n; i++){\n    for(let j = 1; j < n; j++){\n      dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n    }\n  }\n  return dp[n-1][n-1]/(2*n-1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124040,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n  let dp = new Array(cost.length).fill(0).map(() => new Array(cost.length).fill(0));\n  dp[0][0] = cost[0][0];\n  for(let i = 1; i < cost.length; i++){\n    dp[0][i] = dp[0][i-1] + cost[0][i];\n    dp[i][0] = dp[i-1][0] + cost[i][0];\n  }\n  for(let i = 1; i < cost.length; i++){\n    for(let j = 1; j < cost.length; j++){\n      dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n    }\n  }\n  return dp[cost.length-1][cost.length-1] / (2*cost.length - 1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124040,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n  var n = cost.length;\n  var dp = new Array(n);\n  for(var i=0;i<n;i++){\n    dp[i] = new Array(n);\n    for(var j=0;j<n;j++){\n      dp[i][j] = new Array(2);\n    }\n  }\n  dp[0][0][0] = cost[0][0];\n  dp[0][0][1] = 1;\n  for(var i=1;i<n;i++){\n    dp[0][i][0] = dp[0][i-1][0] + cost[0][i];\n    dp[0][i][1] = dp[0][i-1][1] + 1;\n    dp[i][0][0] = dp[i-1][0][0] + cost[i][0];\n    dp[i][0][1] = dp[i-1][0][1] + 1;\n  }\n  for(var i=1;i<n;i++){\n    for(var j=1;j<n;j++){\n      var a = dp[i-1][j][0] + cost[i][j];\n      var b = dp[i-1][j][1] + 1;\n      var c = dp[i][j-1][0] + cost[i][j];\n      var d = dp[i][j-1][1] + 1;\n      if(a/b > c/d){\n        dp[i][j][0] = a;\n        dp[i][j][1] = b;\n      }else{\n        dp[i][j][0] = c;\n        dp[i][j][1] = d;\n      }\n    }\n  }\n  return dp[n-1][n-1][0]/dp[n-1][n-1][1];\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124040,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n  let dp = [];\n  let n = cost.length;\n  let m = cost[0].length;\n  for(let i = 0; i < n; i++){\n    dp.push([]);\n    for(let j = 0; j < m; j++){\n      dp[i].push(0);\n    }\n  }\n  dp[0][0] = cost[0][0];\n  for(let i = 1; i < n; i++){\n    dp[i][0] = dp[i-1][0] + cost[i][0];\n  }\n  for(let j = 1; j < m; j++){\n    dp[0][j] = dp[0][j-1] + cost[0][j];\n  }\n  for(let i = 1; i < n; i++){\n    for(let j = 1; j < m; j++){\n      dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n    }\n  }\n  return dp[n-1][m-1]/(n+m-2);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124040,
      "stdout": "",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n6.5\n\nshould loosely deep-equal\n\n5.2\n    at test (/tmp/tmp7ujcnwlm.js:32:10)\n    at Object.<anonymous> (/tmp/tmp7ujcnwlm.js:38:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: 6.5,\n  expected: 5.2,\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "exit_code": 1,
      "status": "AssertionError"
    },
    {
      "program": "//Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let n = cost.length;\n    let dp = new Array(n);\n    for(let i=0;i<n;i++){\n        dp[i] = new Array(n);\n    }\n    dp[0][0] = cost[0][0];\n    for(let i=1;i<n;i++){\n        dp[0][i] = dp[0][i-1] + cost[0][i];\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let i=1;i<n;i++){\n        for(let j=1;j<n;j++){\n            dp[i][j] = Math.max(dp[i-1][j],dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[n-1][n-1]/(2*n-1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124040,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n  let max = 0;\n  let sum = 0;\n  let count = 0;\n  let maxPath = [];\n  let path = [];\n  let row = 0;\n  let col = 0;\n  let maxRow = cost.length - 1;\n  let maxCol = cost[0].length - 1;\n  let temp = [];\n  let tempSum = 0;\n  let tempCount = 0;\n  let tempPath = [];\n  let tempRow = 0;\n  let tempCol = 0;\n  let tempMaxRow = maxRow;\n  let tempMaxCol = maxCol;\n  let tempMax = 0;\n  let tempMaxPath = [];\n  let tempMaxSum = 0;\n  let tempMaxCount = 0;\n  let tempMaxPath = [];\n  let tempMaxRow = 0;\n  let tempMaxCol = 0;\n  let tempMax = 0;\n  let tempMaxPath = [];\n  let tempMaxSum = 0;\n  let tempMaxCount = 0;\n  let tempMaxPath = [];\n  let tempMaxRow = 0;\n  let tempMaxCol = 0;\n  let tempMax = 0;\n  let tempMaxPath = [];\n  let tempMaxSum = 0;\n  let tempMaxCount = 0;\n  let tempMaxPath = [];\n  let tempMaxRow = 0;\n  let tempMaxCol = 0;\n  let tempMax = 0;\n  let tempMaxPath = [];\n  let tempMaxSum = 0;\n  let tempMaxCount = 0;\n  let tempMaxPath = [];\n  let tempMaxRow = 0;\n  let tempMaxCol = 0;\n  let tempMax = 0;\n  let tempMaxPath = [];\n  let tempMaxSum = 0;\n  let tempMaxCount = 0;\n  let tempMaxPath = [];\n  let tempMaxRow = 0;\n  let tempMaxCol = 0;\n  let tempMax = 0;\n  let tempMaxPath = [];\n  let tempMaxSum = 0;\n  let tempMaxCount = 0;\n  let tempMaxPath = [];\n  let tempMaxRow = 0;\n  let tempMaxCol = 0;\n  let tempMax = 0;\n  let tempMax\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124040,
      "stdout": "",
      "stderr": "/tmp/tmp9bggzb5g.js:24\n  let tempMaxPath = [];\n      ^\n\nSyntaxError: Identifier 'tempMaxPath' has already been declared\n    at Object.compileFunction (node:vm:360:18)\n    at wrapSafe (node:internal/modules/cjs/loader:1049:15)\n    at Module._compile (node:internal/modules/cjs/loader:1084:27)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47\n\nNode.js v18.7.0\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "//Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let n = cost.length;\n    let dp = new Array(n);\n    for(let i=0;i<n;i++){\n        dp[i] = new Array(n);\n    }\n    dp[0][0] = cost[0][0];\n    for(let i=1;i<n;i++){\n        dp[0][i] = dp[0][i-1] + cost[0][i];\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let i=1;i<n;i++){\n        for(let j=1;j<n;j++){\n            dp[i][j] = Math.max(dp[i-1][j],dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[n-1][n-1]/(2*n-1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124040,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n  let n = cost.length;\n  let dp = [];\n  for(let i = 0; i < n; i++){\n    dp.push([]);\n    for(let j = 0; j < n; j++){\n      dp[i].push(0);\n    }\n  }\n  dp[0][0] = cost[0][0];\n  for(let i = 1; i < n; i++){\n    dp[0][i] = dp[0][i-1] + cost[0][i];\n    dp[i][0] = dp[i-1][0] + cost[i][0];\n  }\n  for(let i = 1; i < n; i++){\n    for(let j = 1; j < n; j++){\n      dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n    }\n  }\n  return dp[n-1][n-1] / (2*n-1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124040,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n  let n = cost.length;\n  let dp = new Array(n).fill(0).map(() => new Array(n).fill(0));\n  dp[0][0] = cost[0][0];\n  for(let i = 1; i < n; i++){\n    dp[0][i] = dp[0][i-1] + cost[0][i];\n    dp[i][0] = dp[i-1][0] + cost[i][0];\n  }\n  for(let i = 1; i < n; i++){\n    for(let j = 1; j < n; j++){\n      dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n    }\n  }\n  return dp[n-1][n-1] / (2*n-1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1665509918,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let n = cost.length;\n    let dp = new Array(n).fill(0).map(() => new Array(n).fill(0));\n    dp[0][0] = cost[0][0];\n    for(let i = 1; i < n; i++){\n        dp[0][i] = dp[0][i-1] + cost[0][i];\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let i = 1; i < n; i++){\n        for(let j = 1; j < n; j++){\n            dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[n-1][n-1] / (2*n - 1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124040,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let n = cost.length;\n    let dp = new Array(n).fill(0).map(() => new Array(n).fill(0));\n    dp[0][0] = cost[0][0];\n    for(let i = 1; i < n; i++){\n        dp[0][i] = dp[0][i - 1] + cost[0][i];\n        dp[i][0] = dp[i - 1][0] + cost[i][0];\n    }\n    for(let i = 1; i < n; i++){\n        for(let j = 1; j < n; j++){\n            dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]) + cost[i][j];\n        }\n    }\n    return dp[n - 1][n - 1] / (2 * n - 1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124040,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let n = cost.length;\n    let dp = new Array(n).fill(0).map(()=>new Array(n).fill(0));\n    dp[0][0] = cost[0][0];\n    for(let i=1;i<n;i++){\n        dp[0][i] = dp[0][i-1] + cost[0][i];\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let i=1;i<n;i++){\n        for(let j=1;j<n;j++){\n            dp[i][j] = Math.max(dp[i-1][j],dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[n-1][n-1]/(2*n-1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1665509918,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let n = cost.length;\n    let dp = [];\n    for(let i = 0; i < n; i++){\n        dp[i] = [];\n        for(let j = 0; j < n; j++){\n            dp[i][j] = cost[i][j];\n        }\n    }\n    for(let i = 1; i < n; i++){\n        dp[0][i] += dp[0][i-1];\n        dp[i][0] += dp[i-1][0];\n    }\n    for(let i = 1; i < n; i++){\n        for(let j = 1; j < n; j++){\n            dp[i][j] += Math.max(dp[i-1][j], dp[i][j-1]);\n        }\n    }\n    return dp[n-1][n-1]/(2*n-1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124040,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let n = cost.length;\n    let m = cost[0].length;\n    let dp = new Array(n);\n    for(let i = 0; i < n; i++){\n        dp[i] = new Array(m);\n    }\n    dp[0][0] = cost[0][0];\n    for(let i = 1; i < n; i++){\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let i = 1; i < m; i++){\n        dp[0][i] = dp[0][i-1] + cost[0][i];\n    }\n    for(let i = 1; i < n; i++){\n        for(let j = 1; j < m; j++){\n            dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[n-1][m-1] / (n+m-1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124040,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let n = cost.length;\n    let dp = new Array(n);\n    for(let i = 0; i < n; i++){\n        dp[i] = new Array(n);\n    }\n    dp[0][0] = cost[0][0];\n    for(let i = 1; i < n; i++){\n        dp[0][i] = dp[0][i-1] + cost[0][i];\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let i = 1; i < n; i++){\n        for(let j = 1; j < n; j++){\n            dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[n-1][n-1]/(2*n-1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1665509918,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let n = cost.length;\n    let dp = [];\n    for(let i = 0; i < n; i++){\n        dp.push([]);\n    }\n    dp[0][0] = cost[0][0];\n    for(let i = 1; i < n; i++){\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n        dp[0][i] = dp[0][i-1] + cost[0][i];\n    }\n    for(let i = 1; i < n; i++){\n        for(let j = 1; j < n; j++){\n            dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[n-1][n-1] / (2*n-1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124040,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let n = cost.length;\n    let dp = new Array(n);\n    for(let i = 0; i < n; i++){\n        dp[i] = new Array(n);\n    }\n    dp[0][0] = cost[0][0];\n    for(let i = 1; i < n; i++){\n        dp[0][i] = dp[0][i-1] + cost[0][i];\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let i = 1; i < n; i++){\n        for(let j = 1; j < n; j++){\n            dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[n-1][n-1]/(2*n-1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1665509918,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n  let n = cost.length;\n  let dp = new Array(n);\n  for(let i = 0; i < n; i++){\n    dp[i] = new Array(n);\n    for(let j = 0; j < n; j++){\n      dp[i][j] = new Array(2);\n    }\n  }\n  dp[0][0][0] = cost[0][0];\n  dp[0][0][1] = 1;\n  for(let i = 1; i < n; i++){\n    dp[i][0][0] = dp[i-1][0][0] + cost[i][0];\n    dp[i][0][1] = dp[i-1][0][1] + 1;\n    dp[0][i][0] = dp[0][i-1][0] + cost[0][i];\n    dp[0][i][1] = dp[0][i-1][1] + 1;\n  }\n  for(let i = 1; i < n; i++){\n    for(let j = 1; j < n; j++){\n      let a = dp[i-1][j][0] + cost[i][j];\n      let b = dp[i-1][j][1] + 1;\n      let c = dp[i][j-1][0] + cost[i][j];\n      let d = dp[i][j-1][1] + 1;\n      if(a/b > c/d){\n        dp[i][j][0] = a;\n        dp[i][j][1] = b;\n      }else{\n        dp[i][j][0] = c;\n        dp[i][j][1] = d;\n      }\n    }\n  }\n  return dp[n-1][n-1][0]/dp[n-1][n-1][1];\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124040,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let n = cost.length;\n    let dp = new Array(n).fill(0).map(() => new Array(n).fill(0));\n    dp[0][0] = cost[0][0];\n    for(let i = 1; i < n; i++){\n        dp[0][i] = dp[0][i-1] + cost[0][i];\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let i = 1; i < n; i++){\n        for(let j = 1; j < n; j++){\n            dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[n-1][n-1] / (2*n-1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1665509918,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let n = cost.length;\n    let dp = new Array(n);\n    for(let i = 0; i < n; i++){\n        dp[i] = new Array(n);\n        for(let j = 0; j < n; j++){\n            dp[i][j] = [cost[i][j], 1];\n        }\n    }\n\n    for(let i = 1; i < n; i++){\n        dp[0][i][0] += dp[0][i-1][0];\n        dp[0][i][1] += dp[0][i-1][1];\n        dp[i][0][0] += dp[i-1][0][0];\n        dp[i][0][1] += dp[i-1][0][1];\n    }\n\n    for(let i = 1; i < n; i++){\n        for(let j = 1; j < n; j++){\n            let left = dp[i][j-1];\n            let up = dp[i-1][j];\n            if(left[0]/left[1] > up[0]/up[1]){\n                dp[i][j][0] += left[0];\n                dp[i][j][1] += left[1];\n            }else{\n                dp[i][j][0] += up[0];\n                dp[i][j][1] += up[1];\n            }\n        }\n    }\n\n    return dp[n-1][n-1][0]/dp[n-1][n-1][1];\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124040,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let n = cost.length;\n    let dp = [];\n    for(let i = 0; i < n; i++){\n        dp.push([]);\n        for(let j = 0; j < n; j++){\n            dp[i].push(0);\n        }\n    }\n    dp[0][0] = cost[0][0];\n    for(let i = 1; i < n; i++){\n        dp[0][i] = dp[0][i-1] + cost[0][i];\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let i = 1; i < n; i++){\n        for(let j = 1; j < n; j++){\n            dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[n-1][n-1] / (2*n - 1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124040,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n  let n = cost.length;\n  let dp = new Array(n).fill(0).map(()=>new Array(n).fill(0));\n  dp[0][0] = cost[0][0];\n  for(let i=1;i<n;i++){\n    dp[0][i] = dp[0][i-1] + cost[0][i];\n    dp[i][0] = dp[i-1][0] + cost[i][0];\n  }\n  for(let i=1;i<n;i++){\n    for(let j=1;j<n;j++){\n      dp[i][j] = Math.max(dp[i-1][j],dp[i][j-1]) + cost[i][j];\n    }\n  }\n  return dp[n-1][n-1]/(2*n-1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124040,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let n = cost.length;\n    let dp = new Array(n).fill(0).map(()=>new Array(n).fill(0));\n    dp[0][0] = cost[0][0];\n    for(let i=1;i<n;i++){\n        dp[0][i] = dp[0][i-1] + cost[0][i];\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let i=1;i<n;i++){\n        for(let j=1;j<n;j++){\n            dp[i][j] = Math.max(dp[i-1][j],dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[n-1][n-1]/(2*n-1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1665509918,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let n = cost.length;\n    let dp = new Array(n);\n    for(let i = 0; i < n; i++){\n        dp[i] = new Array(n);\n    }\n    dp[0][0] = cost[0][0];\n    for(let i = 1; i < n; i++){\n        dp[0][i] = dp[0][i-1] + cost[0][i];\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let i = 1; i < n; i++){\n        for(let j = 1; j < n; j++){\n            dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n        }\n    }\n    let path = [];\n    let i = n-1;\n    let j = n-1;\n    while(i > 0 || j > 0){\n        path.push([i,j]);\n        if(i == 0){\n            j--;\n        }else if(j == 0){\n            i--;\n        }else{\n            if(dp[i-1][j] > dp[i][j-1]){\n                i--;\n            }else{\n                j--;\n            }\n        }\n    }\n    path.push([0,0]);\n    path.reverse();\n    return [dp[n-1][n-1]/(2*n-1), path];\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124040,
      "stdout": "",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n[\n  5.2,\n  [\n    [\n      0,\n      0\n    ],\n    [\n      1,\n      0\n    ],\n    [\n      2,\n      0\n    ],\n    [\n      2,\n      1\n    ],\n    [\n      2,\n      2\n    ]\n  ]\n]\n\nshould loosely deep-equal\n\n5.2\n    at test (/tmp/tmp0yyttftb.js:45:10)\n    at Object.<anonymous> (/tmp/tmp0yyttftb.js:51:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: [ 5.2, [ [ 0, 0 ], [ 1, 0 ], [ 2, 0 ], [ 2, 1 ], [ 2, 2 ] ] ],\n  expected: 5.2,\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "exit_code": 1,
      "status": "AssertionError"
    },
    {
      "program": "//Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n  let n = cost.length;\n  let dp = new Array(n).fill(0).map(() => new Array(n).fill(0));\n  dp[0][0] = cost[0][0];\n  for(let i = 1; i < n; i++){\n    dp[0][i] = dp[0][i-1] + cost[0][i];\n    dp[i][0] = dp[i-1][0] + cost[i][0];\n  }\n  for(let i = 1; i < n; i++){\n    for(let j = 1; j < n; j++){\n      dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n    }\n  }\n  return dp[n-1][n-1] / (2*n - 1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124040,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let n = cost.length;\n    let dp = new Array(n).fill(0).map(() => new Array(n).fill(0));\n    dp[0][0] = cost[0][0];\n    for(let i = 1; i < n; i++){\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n        dp[0][i] = dp[0][i-1] + cost[0][i];\n    }\n    for(let i = 1; i < n; i++){\n        for(let j = 1; j < n; j++){\n            dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[n-1][n-1] / (2*n - 1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1665509918,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let n = cost.length;\n    let dp = new Array(n);\n    for(let i = 0; i < n; i++){\n        dp[i] = new Array(n);\n        dp[i][0] = cost[i][0];\n        if(i > 0){\n            dp[i][0] += dp[i-1][0];\n        }\n    }\n    for(let j = 1; j < n; j++){\n        dp[0][j] = cost[0][j];\n        dp[0][j] += dp[0][j-1];\n    }\n    for(let i = 1; i < n; i++){\n        for(let j = 1; j < n; j++){\n            dp[i][j] = cost[i][j] + Math.max(dp[i-1][j], dp[i][j-1]);\n        }\n    }\n    let max = dp[n-1][n-1] / (2*n - 1);\n    return max;\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124040,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let n = cost.length;\n    let dp = new Array(n).fill(0).map(() => new Array(n).fill(0));\n    dp[0][0] = cost[0][0];\n    for(let i = 1; i < n; i++){\n        dp[0][i] = dp[0][i-1] + cost[0][i];\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let i = 1; i < n; i++){\n        for(let j = 1; j < n; j++){\n            dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[n-1][n-1] / (2*n-1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1665509918,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let n = cost.length;\n    let dp = new Array(n);\n    for(let i = 0; i < n; i++){\n        dp[i] = new Array(n);\n    }\n    dp[0][0] = cost[0][0];\n    for(let i = 1; i < n; i++){\n        dp[0][i] = dp[0][i-1] + cost[0][i];\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let i = 1; i < n; i++){\n        for(let j = 1; j < n; j++){\n            dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[n-1][n-1]/(2*n-1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1665509918,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let n = cost.length;\n    let dp = [];\n    for(let i = 0; i < n; i++){\n        dp.push([]);\n        for(let j = 0; j < n; j++){\n            dp[i].push(0);\n        }\n    }\n    dp[0][0] = cost[0][0];\n    for(let i = 1; i < n; i++){\n        dp[0][i] = dp[0][i-1] + cost[0][i];\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let i = 1; i < n; i++){\n        for(let j = 1; j < n; j++){\n            dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[n-1][n-1] / (2*n - 1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124040,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n  let n = cost.length;\n  let dp = new Array(n).fill(0).map(() => new Array(n).fill(0));\n  dp[0][0] = cost[0][0];\n  for (let i = 1; i < n; i++) {\n    dp[0][i] = dp[0][i - 1] + cost[0][i];\n    dp[i][0] = dp[i - 1][0] + cost[i][0];\n  }\n  for (let i = 1; i < n; i++) {\n    for (let j = 1; j < n; j++) {\n      dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]) + cost[i][j];\n    }\n  }\n  return dp[n - 1][n - 1] / (2 * n - 1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124040,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let maxAvg = 0;\n    let sum = 0;\n    let count = 0;\n    let row = 0;\n    let col = 0;\n    let rowMax = cost.length - 1;\n    let colMax = cost[0].length - 1;\n    while(row < rowMax && col < colMax){\n        sum += cost[row][col];\n        count++;\n        if(cost[row][col + 1] > cost[row + 1][col]){\n            col++;\n        } else {\n            row++;\n        }\n    }\n    while(row < rowMax){\n        sum += cost[row][col];\n        count++;\n        row++;\n    }\n    while(col < colMax){\n        sum += cost[row][col];\n        count++;\n        col++;\n    }\n    maxAvg = sum / count;\n    return maxAvg;\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124040,
      "stdout": "",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n4.25\n\nshould loosely deep-equal\n\n5.2\n    at test (/tmp/tmp293t4qf8.js:38:10)\n    at Object.<anonymous> (/tmp/tmp293t4qf8.js:44:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: 4.25,\n  expected: 5.2,\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "exit_code": 1,
      "status": "AssertionError"
    },
    {
      "program": "//Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n  let n = cost.length;\n  let m = cost[0].length;\n  let dp = new Array(n).fill(0).map(() => new Array(m).fill(0));\n  dp[0][0] = cost[0][0];\n  for(let i = 1; i < n; i++){\n    dp[i][0] = dp[i-1][0] + cost[i][0];\n  }\n  for(let j = 1; j < m; j++){\n    dp[0][j] = dp[0][j-1] + cost[0][j];\n  }\n  for(let i = 1; i < n; i++){\n    for(let j = 1; j < m; j++){\n      dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n    }\n  }\n  return dp[n-1][m-1] / (n + m - 1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124040,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let row = cost.length;\n    let col = cost[0].length;\n    let dp = new Array(row);\n    for(let i = 0; i < row; i++){\n        dp[i] = new Array(col);\n    }\n    dp[0][0] = cost[0][0];\n    for(let i = 1; i < row; i++){\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let i = 1; i < col; i++){\n        dp[0][i] = dp[0][i-1] + cost[0][i];\n    }\n    for(let i = 1; i < row; i++){\n        for(let j = 1; j < col; j++){\n            dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[row-1][col-1] / (row + col - 1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1665509918,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n  let n = cost.length;\n  let dp = new Array(n).fill(0).map(()=>new Array(n).fill(0));\n  dp[0][0] = cost[0][0];\n  for(let i = 1; i < n; i++){\n    dp[i][0] = dp[i-1][0] + cost[i][0];\n    dp[0][i] = dp[0][i-1] + cost[0][i];\n  }\n  for(let i = 1; i < n; i++){\n    for(let j = 1; j < n; j++){\n      dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n    }\n  }\n  return dp[n-1][n-1]/(2*n-1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124040,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n  let n = cost.length;\n  let dp = new Array(n);\n  for(let i = 0; i < n; i++){\n    dp[i] = new Array(n);\n  }\n  dp[0][0] = cost[0][0];\n  for(let i = 1; i < n; i++){\n    dp[0][i] = dp[0][i-1] + cost[0][i];\n    dp[i][0] = dp[i-1][0] + cost[i][0];\n  }\n  for(let i = 1; i < n; i++){\n    for(let j = 1; j < n; j++){\n      dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n    }\n  }\n  return dp[n-1][n-1] / (2*n - 1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124040,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let row = cost.length;\n    let col = cost[0].length;\n    let dp = new Array(row);\n    for(let i = 0; i < row; i++){\n        dp[i] = new Array(col);\n    }\n    dp[0][0] = cost[0][0];\n    for(let i = 1; i < row; i++){\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let j = 1; j < col; j++){\n        dp[0][j] = dp[0][j-1] + cost[0][j];\n    }\n    for(let i = 1; i < row; i++){\n        for(let j = 1; j < col; j++){\n            dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[row-1][col-1]/(row+col-1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124040,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let n = cost.length;\n    let dp = new Array(n);\n    for(let i = 0; i < n; i++){\n        dp[i] = new Array(n);\n    }\n    dp[0][0] = cost[0][0];\n    for(let i = 1; i < n; i++){\n        dp[0][i] = dp[0][i-1] + cost[0][i];\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let i = 1; i < n; i++){\n        for(let j = 1; j < n; j++){\n            dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[n-1][n-1]/(2*n-1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1665509918,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let n = cost.length;\n    let dp = new Array(n);\n    for(let i = 0; i < n; i++){\n        dp[i] = new Array(n);\n    }\n    dp[0][0] = cost[0][0];\n    for(let i = 1; i < n; i++){\n        dp[0][i] = dp[0][i-1] + cost[0][i];\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let i = 1; i < n; i++){\n        for(let j = 1; j < n; j++){\n            dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[n-1][n-1] / (2*n-1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124040,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let n = cost.length;\n    let dp = new Array(n);\n    for(let i = 0; i < n; i++){\n        dp[i] = new Array(n);\n    }\n    dp[0][0] = cost[0][0];\n    for(let i = 1; i < n; i++){\n        dp[0][i] = dp[0][i-1] + cost[0][i];\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let i = 1; i < n; i++){\n        for(let j = 1; j < n; j++){\n            dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[n-1][n-1] / (2*n - 1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1665509918,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let n = cost.length;\n    let dp = new Array(n);\n    for(let i = 0; i < n; i++){\n        dp[i] = new Array(n);\n        for(let j = 0; j < n; j++){\n            dp[i][j] = new Array(2);\n            dp[i][j][0] = 0;\n            dp[i][j][1] = 0;\n        }\n    }\n    dp[0][0][0] = cost[0][0];\n    dp[0][0][1] = 1;\n    for(let i = 1; i < n; i++){\n        dp[0][i][0] = dp[0][i - 1][0] + cost[0][i];\n        dp[0][i][1] = dp[0][i - 1][1] + 1;\n        dp[i][0][0] = dp[i - 1][0][0] + cost[i][0];\n        dp[i][0][1] = dp[i - 1][0][1] + 1;\n    }\n    for(let i = 1; i < n; i++){\n        for(let j = 1; j < n; j++){\n            if(dp[i - 1][j][0] / dp[i - 1][j][1] > dp[i][j - 1][0] / dp[i][j - 1][1]){\n                dp[i][j][0] = dp[i - 1][j][0] + cost[i][j];\n                dp[i][j][1] = dp[i - 1][j][1] + 1;\n            }\n            else{\n                dp[i][j][0] = dp[i][j - 1][0] + cost[i][j];\n                dp[i][j][1] = dp[i][j - 1][1] + 1;\n            }\n        }\n    }\n    return dp[n - 1][n - 1][0] / dp[n - 1][\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124040,
      "stdout": "",
      "stderr": "/tmp/tmpz2oilcgc.js:34\nconst assert = require('node:assert');\n^^^^^\n\nSyntaxError: Unexpected token 'const'\n    at Object.compileFunction (node:vm:360:18)\n    at wrapSafe (node:internal/modules/cjs/loader:1049:15)\n    at Module._compile (node:internal/modules/cjs/loader:1084:27)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47\n\nNode.js v18.7.0\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "//Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n  let n = cost.length;\n  let dp = new Array(n);\n  for(let i = 0; i < n; i++){\n    dp[i] = new Array(n);\n    for(let j = 0; j < n; j++){\n      dp[i][j] = new Array(2);\n      dp[i][j][0] = 0;\n      dp[i][j][1] = 0;\n    }\n  }\n  dp[0][0][0] = cost[0][0];\n  dp[0][0][1] = 1;\n  for(let i = 1; i < n; i++){\n    dp[0][i][0] = dp[0][i-1][0] + cost[0][i];\n    dp[0][i][1] = dp[0][i-1][1] + 1;\n    dp[i][0][0] = dp[i-1][0][0] + cost[i][0];\n    dp[i][0][1] = dp[i-1][0][1] + 1;\n  }\n  for(let i = 1; i < n; i++){\n    for(let j = 1; j < n; j++){\n      if(dp[i-1][j][0]/dp[i-1][j][1] > dp[i][j-1][0]/dp[i][j-1][1]){\n        dp[i][j][0] = dp[i-1][j][0] + cost[i][j];\n        dp[i][j][1] = dp[i-1][j][1] + 1;\n      }else{\n        dp[i][j][0] = dp[i][j-1][0] + cost[i][j];\n        dp[i][j][1] = dp[i][j-1][1] + 1;\n      }\n    }\n  }\n  return dp[n-1][n-1][0]/dp[n-1][n-1][1\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124040,
      "stdout": "",
      "stderr": "/tmp/tmpoks7iasd.js:33\nconst assert = require('node:assert');\n^^^^^\n\nSyntaxError: Unexpected token 'const'\n    at Object.compileFunction (node:vm:360:18)\n    at wrapSafe (node:internal/modules/cjs/loader:1049:15)\n    at Module._compile (node:internal/modules/cjs/loader:1084:27)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47\n\nNode.js v18.7.0\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "//Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    //initialize the first row and column\n    for(let i = 1; i < cost.length; i++){\n        cost[i][0] += cost[i-1][0];\n    }\n    for(let j = 1; j < cost[0].length; j++){\n        cost[0][j] += cost[0][j-1];\n    }\n    //fill in the rest of the matrix\n    for(let i = 1; i < cost.length; i++){\n        for(let j = 1; j < cost[0].length; j++){\n            cost[i][j] += Math.max(cost[i-1][j], cost[i][j-1]);\n        }\n    }\n    //return the last value in the matrix\n    return cost[cost.length-1][cost[0].length-1] / (cost.length + cost[0].length - 1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124040,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n  let n = cost.length;\n  let dp = new Array(n);\n  for(let i = 0; i < n; i++){\n    dp[i] = new Array(n);\n  }\n  dp[0][0] = cost[0][0];\n  for(let i = 1; i < n; i++){\n    dp[0][i] = dp[0][i-1] + cost[0][i];\n    dp[i][0] = dp[i-1][0] + cost[i][0];\n  }\n  for(let i = 1; i < n; i++){\n    for(let j = 1; j < n; j++){\n      dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n    }\n  }\n  return dp[n-1][n-1]/(2*n-1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124040,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n  let dp = [];\n  for(let i = 0; i < cost.length; i++){\n    dp.push([]);\n    for(let j = 0; j < cost[i].length; j++){\n      dp[i].push(0);\n    }\n  }\n  dp[0][0] = cost[0][0];\n  for(let i = 1; i < cost.length; i++){\n    dp[i][0] = dp[i-1][0] + cost[i][0];\n  }\n  for(let j = 1; j < cost[0].length; j++){\n    dp[0][j] = dp[0][j-1] + cost[0][j];\n  }\n  for(let i = 1; i < cost.length; i++){\n    for(let j = 1; j < cost[i].length; j++){\n      dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n    }\n  }\n  return dp[cost.length-1][cost[0].length-1] / (cost.length + cost[0].length - 1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124040,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let n = cost.length;\n    let dp = new Array(n);\n    for(let i = 0; i < n; i++){\n        dp[i] = new Array(n);\n        dp[i][0] = cost[i][0];\n    }\n    for(let j = 0; j < n; j++){\n        dp[0][j] = cost[0][j];\n    }\n    for(let i = 1; i < n; i++){\n        for(let j = 1; j < n; j++){\n            dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[n-1][n-1]/(2*n-1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124040,
      "stdout": "",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n4.8\n\nshould loosely deep-equal\n\n5.2\n    at test (/tmp/tmp1kaz0k2_.js:25:10)\n    at Object.<anonymous> (/tmp/tmp1kaz0k2_.js:31:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: 4.8,\n  expected: 5.2,\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "exit_code": 1,
      "status": "AssertionError"
    },
    {
      "program": "//Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let n = cost.length;\n    let dp = new Array(n);\n    for(let i=0;i<n;i++){\n        dp[i] = new Array(n);\n        for(let j=0;j<n;j++){\n            dp[i][j] = 0;\n        }\n    }\n    dp[0][0] = cost[0][0];\n    for(let i=1;i<n;i++){\n        dp[0][i] = dp[0][i-1] + cost[0][i];\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let i=1;i<n;i++){\n        for(let j=1;j<n;j++){\n            dp[i][j] = Math.max(dp[i-1][j],dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[n-1][n-1]/(2*n-1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124040,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let n = cost.length;\n    let dp = new Array(n).fill(0).map(()=>new Array(n).fill(0));\n    dp[0][0] = cost[0][0];\n    for(let i = 1; i < n; i++){\n        dp[0][i] = dp[0][i-1] + cost[0][i];\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let i = 1; i < n; i++){\n        for(let j = 1; j < n; j++){\n            dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[n-1][n-1]/(2*n-1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124040,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let n = cost.length;\n    let dp = new Array(n).fill(0).map(()=>new Array(n).fill(0));\n    dp[0][0] = cost[0][0];\n    for(let i=1;i<n;i++){\n        dp[0][i] = dp[0][i-1] + cost[0][i];\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let i=1;i<n;i++){\n        for(let j=1;j<n;j++){\n            dp[i][j] = Math.max(dp[i-1][j],dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[n-1][n-1]/(2*n-1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1665509918,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let rows = cost.length;\n    let cols = cost[0].length;\n    let dp = new Array(rows);\n    for(let i=0; i<rows; i++){\n        dp[i] = new Array(cols);\n    }\n    dp[0][0] = cost[0][0];\n    for(let i=1; i<rows; i++){\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let i=1; i<cols; i++){\n        dp[0][i] = dp[0][i-1] + cost[0][i];\n    }\n    for(let i=1; i<rows; i++){\n        for(let j=1; j<cols; j++){\n            dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[rows-1][cols-1]/(rows+cols-1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124040,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let n = cost.length;\n    let dp = new Array(n);\n    for(let i = 0; i < n; i++){\n        dp[i] = new Array(n);\n    }\n    dp[0][0] = cost[0][0];\n    for(let i = 1; i < n; i++){\n        dp[0][i] = dp[0][i-1] + cost[0][i];\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let i = 1; i < n; i++){\n        for(let j = 1; j < n; j++){\n            dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[n-1][n-1] / (2*n - 1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1665509918,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let row = cost.length;\n    let col = cost[0].length;\n    let dp = new Array(row);\n    for(let i=0;i<row;i++){\n        dp[i] = new Array(col);\n    }\n    dp[0][0] = cost[0][0];\n    for(let i=1;i<row;i++){\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let j=1;j<col;j++){\n        dp[0][j] = dp[0][j-1] + cost[0][j];\n    }\n    for(let i=1;i<row;i++){\n        for(let j=1;j<col;j++){\n            dp[i][j] = Math.max(dp[i-1][j],dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[row-1][col-1]/(row+col-1);\n}\n\nlet cost = [[1,2,3],[4,5,6],[7,8,9]];\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124040,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n  let n = cost.length;\n  let dp = new Array(n);\n  for(let i=0;i<n;i++){\n    dp[i] = new Array(n);\n  }\n  dp[0][0] = cost[0][0];\n  for(let i=1;i<n;i++){\n    dp[0][i] = dp[0][i-1] + cost[0][i];\n    dp[i][0] = dp[i-1][0] + cost[i][0];\n  }\n  for(let i=1;i<n;i++){\n    for(let j=1;j<n;j++){\n      dp[i][j] = Math.max(dp[i-1][j],dp[i][j-1]) + cost[i][j];\n    }\n  }\n  return dp[n-1][n-1]/(2*n-1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124040,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let n = cost.length;\n    let dp = new Array(n).fill(0).map(()=>new Array(n).fill(0));\n    dp[0][0] = cost[0][0];\n    for(let i=1;i<n;i++){\n        dp[0][i] = dp[0][i-1] + cost[0][i];\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let i=1;i<n;i++){\n        for(let j=1;j<n;j++){\n            dp[i][j] = Math.max(dp[i-1][j],dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[n-1][n-1]/(2*n-1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1665509918,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let n = cost.length;\n    let dp = new Array(n).fill(0).map(()=>new Array(n).fill(0));\n    dp[0][0] = cost[0][0];\n    for(let i=1;i<n;i++){\n        dp[0][i] = dp[0][i-1] + cost[0][i];\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let i=1;i<n;i++){\n        for(let j=1;j<n;j++){\n            dp[i][j] = Math.max(dp[i-1][j],dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[n-1][n-1]/(2*n-1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1665509918,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n  let n = cost.length;\n  let dp = [];\n  for(let i = 0; i < n; i++){\n    dp.push([]);\n    for(let j = 0; j < n; j++){\n      dp[i].push(0);\n    }\n  }\n  dp[0][0] = cost[0][0];\n  for(let i = 1; i < n; i++){\n    dp[0][i] = dp[0][i-1] + cost[0][i];\n    dp[i][0] = dp[i-1][0] + cost[i][0];\n  }\n  for(let i = 1; i < n; i++){\n    for(let j = 1; j < n; j++){\n      dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n    }\n  }\n  return dp[n-1][n-1]/(2*n-1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124040,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let n = cost.length;\n    let dp = new Array(n).fill(0).map(() => new Array(n).fill(0));\n    dp[0][0] = cost[0][0];\n    for(let i = 1; i < n; i++){\n        dp[0][i] = dp[0][i - 1] + cost[0][i];\n        dp[i][0] = dp[i - 1][0] + cost[i][0];\n    }\n    for(let i = 1; i < n; i++){\n        for(let j = 1; j < n; j++){\n            dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]) + cost[i][j];\n        }\n    }\n    return dp[n - 1][n - 1] / (2 * n - 1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124040,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let n = cost.length;\n    let dp = new Array(n).fill(0).map(() => new Array(n).fill(0));\n    dp[0][0] = cost[0][0];\n    for(let i = 1; i < n; i++){\n        dp[0][i] = dp[0][i-1] + cost[0][i];\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let i = 1; i < n; i++){\n        for(let j = 1; j < n; j++){\n            dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[n-1][n-1] / (2*n - 1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124040,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let n = cost.length;\n    let dp = Array(n).fill(null).map(() => Array(n).fill(0));\n    dp[0][0] = cost[0][0];\n    for(let i = 1; i < n; i++){\n        dp[0][i] = dp[0][i-1] + cost[0][i];\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let i = 1; i < n; i++){\n        for(let j = 1; j < n; j++){\n            dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[n-1][n-1] / (2*n-1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124040,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let n = cost.length;\n    let dp = new Array(n).fill(0).map(() => new Array(n).fill(0));\n    dp[0][0] = cost[0][0];\n    for(let i = 1; i < n; i++){\n        dp[0][i] = dp[0][i-1] + cost[0][i];\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let i = 1; i < n; i++){\n        for(let j = 1; j < n; j++){\n            dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[n-1][n-1] / (2*n - 1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124040,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let n = cost.length;\n    let dp = new Array(n);\n    for(let i=0;i<n;i++){\n        dp[i] = new Array(n);\n    }\n    dp[0][0] = cost[0][0];\n    for(let i=1;i<n;i++){\n        dp[0][i] = dp[0][i-1] + cost[0][i];\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let i=1;i<n;i++){\n        for(let j=1;j<n;j++){\n            dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[n-1][n-1]/(2*n-1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124040,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let n = cost.length;\n    let dp = new Array(n);\n    for(let i = 0; i < n; i++){\n        dp[i] = new Array(n);\n    }\n    dp[0][0] = cost[0][0];\n    for(let i = 1; i < n; i++){\n        dp[0][i] = dp[0][i-1] + cost[0][i];\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let i = 1; i < n; i++){\n        for(let j = 1; j < n; j++){\n            dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[n-1][n-1] / (2*n - 1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1665509918,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let n = cost.length;\n    let dp = new Array(n);\n    for(let i=0;i<n;i++){\n        dp[i] = new Array(n);\n    }\n    dp[0][0] = cost[0][0];\n    for(let i=1;i<n;i++){\n        dp[0][i] = dp[0][i-1] + cost[0][i];\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let i=1;i<n;i++){\n        for(let j=1;j<n;j++){\n            dp[i][j] = Math.max(dp[i-1][j],dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[n-1][n-1]/(2*n-1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124040,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let n = cost.length;\n    let dp = new Array(n);\n    for(let i = 0; i < n; i++){\n        dp[i] = new Array(n);\n    }\n    dp[0][0] = cost[0][0];\n    for(let i = 1; i < n; i++){\n        dp[0][i] = dp[0][i-1] + cost[0][i];\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let i = 1; i < n; i++){\n        for(let j = 1; j < n; j++){\n            dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[n-1][n-1]/(2*n-1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1665509918,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    // Write your code here\n    let n = cost.length;\n    let dp = new Array(n);\n    for(let i = 0; i < n; i++){\n        dp[i] = new Array(n);\n    }\n    dp[0][0] = cost[0][0];\n    for(let i = 1; i < n; i++){\n        dp[0][i] = dp[0][i-1] + cost[0][i];\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let i = 1; i < n; i++){\n        for(let j = 1; j < n; j++){\n            dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[n-1][n-1]/(2*n - 1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124040,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n  let rows = cost.length;\n  let cols = cost[0].length;\n  let dp = new Array(rows);\n  for(let i = 0; i < rows; i++){\n    dp[i] = new Array(cols);\n  }\n  dp[0][0] = cost[0][0];\n  for(let i = 1; i < rows; i++){\n    dp[i][0] = dp[i-1][0] + cost[i][0];\n  }\n  for(let j = 1; j < cols; j++){\n    dp[0][j] = dp[0][j-1] + cost[0][j];\n  }\n  for(let i = 1; i < rows; i++){\n    for(let j = 1; j < cols; j++){\n      dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n    }\n  }\n  return dp[rows-1][cols-1]/(rows+cols-1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124040,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let n = cost.length;\n    let dp = Array(n).fill(0).map(()=>Array(n).fill(0));\n    dp[0][0] = cost[0][0];\n    for(let i=1;i<n;i++){\n        dp[0][i] = dp[0][i-1]+cost[0][i];\n        dp[i][0] = dp[i-1][0]+cost[i][0];\n    }\n    for(let i=1;i<n;i++){\n        for(let j=1;j<n;j++){\n            dp[i][j] = Math.max(dp[i-1][j],dp[i][j-1])+cost[i][j];\n        }\n    }\n    return dp[n-1][n-1]/(2*n-1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124040,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let row = cost.length;\n    let col = cost[0].length;\n    let dp = new Array(row);\n    for(let i = 0; i < row; i++){\n        dp[i] = new Array(col);\n        for(let j = 0; j < col; j++){\n            dp[i][j] = new Array(2);\n        }\n    }\n    dp[0][0][0] = cost[0][0];\n    dp[0][0][1] = 1;\n    for(let i = 1; i < row; i++){\n        dp[i][0][0] = dp[i-1][0][0] + cost[i][0];\n        dp[i][0][1] = dp[i-1][0][1] + 1;\n    }\n    for(let j = 1; j < col; j++){\n        dp[0][j][0] = dp[0][j-1][0] + cost[0][j];\n        dp[0][j][1] = dp[0][j-1][1] + 1;\n    }\n    for(let i = 1; i < row; i++){\n        for(let j = 1; j < col; j++){\n            if(dp[i-1][j][0]/dp[i-1][j][1] > dp[i][j-1][0]/dp[i][j-1][1]){\n                dp[i][j][0] = dp[i-1][j][0] + cost[i][j];\n                dp[i][j][1] = dp[i-1][j][1] + 1;\n            }else{\n                dp[i][j][0] = dp[i][j-1][0] + cost[i][j];\n                dp[i][j][1] = dp[i][j-1][1] + 1;\n            }\n        }\n    }\n    return dp[row-1][col-1][0]/dp[row-1][col-1\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124040,
      "stdout": "",
      "stderr": "/tmp/tmp__hdgutd.js:34\nconst assert = require('node:assert');\n^^^^^\n\nSyntaxError: Unexpected token 'const'\n    at Object.compileFunction (node:vm:360:18)\n    at wrapSafe (node:internal/modules/cjs/loader:1049:15)\n    at Module._compile (node:internal/modules/cjs/loader:1084:27)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47\n\nNode.js v18.7.0\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "//Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let n = cost.length;\n    let dp = new Array(n).fill(0).map(() => new Array(n).fill(0));\n    dp[0][0] = cost[0][0];\n    for(let i = 1; i < n; i++){\n        dp[0][i] = dp[0][i-1] + cost[0][i];\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let i = 1; i < n; i++){\n        for(let j = 1; j < n; j++){\n            dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[n-1][n-1] / (2*n - 1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124040,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let row = cost.length;\n    let col = cost[0].length;\n    let dp = new Array(row);\n    for(let i = 0; i < row; i++){\n        dp[i] = new Array(col);\n    }\n    dp[0][0] = cost[0][0];\n    for(let i = 1; i < row; i++){\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let i = 1; i < col; i++){\n        dp[0][i] = dp[0][i-1] + cost[0][i];\n    }\n    for(let i = 1; i < row; i++){\n        for(let j = 1; j < col; j++){\n            dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[row-1][col-1] / (row + col - 1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1665509918,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n  let n = cost.length;\n  let dp = [];\n  for(let i = 0; i < n; i++){\n    dp.push([]);\n  }\n  dp[0][0] = cost[0][0];\n  for(let i = 1; i < n; i++){\n    dp[0][i] = dp[0][i-1] + cost[0][i];\n    dp[i][0] = dp[i-1][0] + cost[i][0];\n  }\n  for(let i = 1; i < n; i++){\n    for(let j = 1; j < n; j++){\n      dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n    }\n  }\n  return dp[n-1][n-1] / (2*n - 1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124040,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n  let row = cost.length;\n  let col = cost[0].length;\n  let dp = new Array(row).fill(0).map(() => new Array(col).fill(0));\n  dp[0][0] = cost[0][0];\n  for(let i = 1; i < row; i++){\n    dp[i][0] = dp[i-1][0] + cost[i][0];\n  }\n  for(let j = 1; j < col; j++){\n    dp[0][j] = dp[0][j-1] + cost[0][j];\n  }\n  for(let i = 1; i < row; i++){\n    for(let j = 1; j < col; j++){\n      dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n    }\n  }\n  return dp[row-1][col-1]/(row+col-1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124040,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let row = cost.length;\n    let col = cost[0].length;\n    let dp = new Array(row).fill(0).map(()=>new Array(col).fill(0));\n    dp[0][0] = cost[0][0];\n    for(let i = 1; i < row; i++){\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let j = 1; j < col; j++){\n        dp[0][j] = dp[0][j-1] + cost[0][j];\n    }\n    for(let i = 1; i < row; i++){\n        for(let j = 1; j < col; j++){\n            dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[row-1][col-1] / (row + col - 1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124040,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n  let n = cost.length;\n  let dp = [];\n  for(let i = 0; i < n; i++){\n    dp.push([]);\n    for(let j = 0; j < n; j++){\n      dp[i].push(0);\n    }\n  }\n  dp[0][0] = cost[0][0];\n  for(let i = 1; i < n; i++){\n    dp[0][i] = dp[0][i-1] + cost[0][i];\n    dp[i][0] = dp[i-1][0] + cost[i][0];\n  }\n  for(let i = 1; i < n; i++){\n    for(let j = 1; j < n; j++){\n      dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n    }\n  }\n  return dp[n-1][n-1] / (2*n - 1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124040,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n  let n = cost.length;\n  let dp = new Array(n);\n  for(let i = 0; i < n; i++){\n    dp[i] = new Array(n);\n  }\n  dp[0][0] = cost[0][0];\n  for(let i = 1; i < n; i++){\n    dp[0][i] = dp[0][i-1] + cost[0][i];\n    dp[i][0] = dp[i-1][0] + cost[i][0];\n  }\n  for(let i = 1; i < n; i++){\n    for(let j = 1; j < n; j++){\n      dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n    }\n  }\n  return dp[n-1][n-1]/(2*n-1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124040,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let n = cost.length;\n    let dp = new Array(n);\n    for(let i = 0; i < n; i++){\n        dp[i] = new Array(n);\n        dp[i][0] = cost[i][0];\n    }\n    for(let j = 1; j < n; j++){\n        dp[0][j] = cost[0][j];\n    }\n    for(let i = 1; i < n; i++){\n        for(let j = 1; j < n; j++){\n            dp[i][j] = cost[i][j] + Math.max(dp[i-1][j], dp[i][j-1]);\n        }\n    }\n    let max = dp[n-1][n-1];\n    let count = n + n - 2;\n    return max / count;\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124040,
      "stdout": "",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n6\n\nshould loosely deep-equal\n\n5.2\n    at test (/tmp/tmpxwgqjfub.js:27:10)\n    at Object.<anonymous> (/tmp/tmpxwgqjfub.js:33:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: 6,\n  expected: 5.2,\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "exit_code": 1,
      "status": "AssertionError"
    },
    {
      "program": "//Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let n = cost.length;\n    let dp = new Array(n);\n    for(let i = 0; i < n; i++){\n        dp[i] = new Array(n);\n    }\n    dp[0][0] = cost[0][0];\n    for(let i = 1; i < n; i++){\n        dp[0][i] = dp[0][i-1] + cost[0][i];\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let i = 1; i < n; i++){\n        for(let j = 1; j < n; j++){\n            dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[n-1][n-1] / (2*n - 1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1665509918,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n  let rows = cost.length;\n  let cols = cost[0].length;\n  let dp = new Array(rows);\n  for(let i = 0; i < rows; i++){\n    dp[i] = new Array(cols);\n  }\n  dp[0][0] = cost[0][0];\n  for(let i = 1; i < rows; i++){\n    dp[i][0] = dp[i-1][0] + cost[i][0];\n  }\n  for(let i = 1; i < cols; i++){\n    dp[0][i] = dp[0][i-1] + cost[0][i];\n  }\n  for(let i = 1; i < rows; i++){\n    for(let j = 1; j < cols; j++){\n      dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n    }\n  }\n  return dp[rows-1][cols-1]/(rows+cols-1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124040,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let n = cost.length;\n    let dp = new Array(n).fill(0).map(() => new Array(n).fill(0));\n    dp[0][0] = cost[0][0];\n    for(let i = 1; i < n; i++){\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n        dp[0][i] = dp[0][i-1] + cost[0][i];\n    }\n    for(let i = 1; i < n; i++){\n        for(let j = 1; j < n; j++){\n            dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[n-1][n-1] / (2*n-1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124040,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let row = cost.length;\n    let col = cost[0].length;\n    let dp = new Array(row).fill(0).map(()=>new Array(col).fill(0));\n    dp[0][0] = cost[0][0];\n    for(let i=1;i<row;i++){\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let j=1;j<col;j++){\n        dp[0][j] = dp[0][j-1] + cost[0][j];\n    }\n    for(let i=1;i<row;i++){\n        for(let j=1;j<col;j++){\n            dp[i][j] = Math.max(dp[i-1][j],dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[row-1][col-1]/(row+col-1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124040,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let n = cost.length;\n    let dp = new Array(n);\n    for(let i = 0; i < n; i++){\n        dp[i] = new Array(n);\n        for(let j = 0; j < n; j++){\n            dp[i][j] = new Array(2);\n            dp[i][j][0] = 0;\n            dp[i][j][1] = 0;\n        }\n    }\n    dp[0][0][0] = cost[0][0];\n    dp[0][0][1] = 1;\n    for(let i = 1; i < n; i++){\n        dp[0][i][0] = dp[0][i-1][0] + cost[0][i];\n        dp[0][i][1] = dp[0][i-1][1] + 1;\n        dp[i][0][0] = dp[i-1][0][0] + cost[i][0];\n        dp[i][0][1] = dp[i-1][0][1] + 1;\n    }\n    for(let i = 1; i < n; i++){\n        for(let j = 1; j < n; j++){\n            if(dp[i-1][j][0]/dp[i-1][j][1] > dp[i][j-1][0]/dp[i][j-1][1]){\n                dp[i][j][0] = dp[i-1][j][0] + cost[i][j];\n                dp[i][j][1] = dp[i-1][j][1] + 1;\n            }else{\n                dp[i][j][0] = dp[i][j-1][0] + cost[i][j];\n                dp[i][j][1] = dp[i][j-1][1] + 1;\n            }\n        }\n    }\n    return dp[n-1][n-1][0]/dp[n-1][n-1][1\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124040,
      "stdout": "",
      "stderr": "/tmp/tmpmpn2b1j0.js:33\nconst assert = require('node:assert');\n^^^^^\n\nSyntaxError: Unexpected token 'const'\n    at Object.compileFunction (node:vm:360:18)\n    at wrapSafe (node:internal/modules/cjs/loader:1049:15)\n    at Module._compile (node:internal/modules/cjs/loader:1084:27)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47\n\nNode.js v18.7.0\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "//Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n  let n = cost.length;\n  let dp = new Array(n);\n  for(let i = 0; i < n; i++){\n    dp[i] = new Array(n);\n  }\n  dp[0][0] = cost[0][0];\n  for(let i = 1; i < n; i++){\n    dp[0][i] = dp[0][i-1] + cost[0][i];\n    dp[i][0] = dp[i-1][0] + cost[i][0];\n  }\n  for(let i = 1; i < n; i++){\n    for(let j = 1; j < n; j++){\n      dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n    }\n  }\n  return dp[n-1][n-1]/(2*n-1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124040,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n  let n = cost.length;\n  let dp = new Array(n);\n  for(let i = 0; i < n; i++){\n    dp[i] = new Array(n);\n  }\n  dp[0][0] = cost[0][0];\n  for(let i = 1; i < n; i++){\n    dp[0][i] = dp[0][i-1] + cost[0][i];\n    dp[i][0] = dp[i-1][0] + cost[i][0];\n  }\n  for(let i = 1; i < n; i++){\n    for(let j = 1; j < n; j++){\n      dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n    }\n  }\n  return dp[n-1][n-1] / (2*n - 1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124040,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let n = cost.length;\n    let dp = new Array(n).fill(0).map(()=>new Array(n).fill(0));\n    dp[0][0] = cost[0][0];\n    for(let i=1;i<n;i++){\n        dp[0][i] = dp[0][i-1] + cost[0][i];\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let i=1;i<n;i++){\n        for(let j=1;j<n;j++){\n            dp[i][j] = Math.max(dp[i-1][j],dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[n-1][n-1]/(2*n-1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1665509918,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n  let n = cost.length;\n  let dp = new Array(n).fill(0).map(() => new Array(n).fill(0));\n  dp[0][0] = cost[0][0];\n  for(let i = 1; i < n; i++){\n    dp[0][i] = dp[0][i-1] + cost[0][i];\n  }\n  for(let i = 1; i < n; i++){\n    dp[i][0] = dp[i-1][0] + cost[i][0];\n  }\n  for(let i = 1; i < n; i++){\n    for(let j = 1; j < n; j++){\n      dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n    }\n  }\n  return dp[n-1][n-1] / (2*n - 1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124040,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n  let rows = cost.length;\n  let cols = cost[0].length;\n  let dp = new Array(rows).fill(0).map(() => new Array(cols).fill(0));\n  dp[0][0] = cost[0][0];\n  for(let i = 1; i < rows; i++){\n    dp[i][0] = dp[i-1][0] + cost[i][0];\n  }\n  for(let j = 1; j < cols; j++){\n    dp[0][j] = dp[0][j-1] + cost[0][j];\n  }\n  for(let i = 1; i < rows; i++){\n    for(let j = 1; j < cols; j++){\n      dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n    }\n  }\n  return dp[rows-1][cols-1] / (rows + cols - 1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124040,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let n = cost.length;\n    let dp = new Array(n);\n    for(let i = 0; i < n; i++){\n        dp[i] = new Array(n);\n    }\n    dp[0][0] = cost[0][0];\n    for(let i = 1; i < n; i++){\n        dp[0][i] = dp[0][i-1] + cost[0][i];\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let i = 1; i < n; i++){\n        for(let j = 1; j < n; j++){\n            dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[n-1][n-1] / (2*n-1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124040,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let max = 0;\n    let sum = 0;\n    let count = 0;\n    for(let i = 0; i < cost.length; i++){\n        for(let j = 0; j < cost[i].length; j++){\n            sum += cost[i][j];\n            count++;\n            if(i === cost.length - 1 && j === cost[i].length - 1){\n                max = Math.max(max, sum/count);\n            }\n        }\n    }\n    return max;\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124040,
      "stdout": "",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n4.444444444444445\n\nshould loosely deep-equal\n\n5.2\n    at test (/tmp/tmpjt_mkqxf.js:23:10)\n    at Object.<anonymous> (/tmp/tmpjt_mkqxf.js:29:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: 4.444444444444445,\n  expected: 5.2,\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "exit_code": 1,
      "status": "AssertionError"
    },
    {
      "program": "//Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n  let n = cost.length;\n  let dp = new Array(n);\n  for (let i = 0; i < n; i++) {\n    dp[i] = new Array(n);\n  }\n  dp[0][0] = cost[0][0];\n  for (let i = 1; i < n; i++) {\n    dp[0][i] = dp[0][i-1] + cost[0][i];\n    dp[i][0] = dp[i-1][0] + cost[i][0];\n  }\n  for (let i = 1; i < n; i++) {\n    for (let j = 1; j < n; j++) {\n      dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n    }\n  }\n  return dp[n-1][n-1] / (2*n - 1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124040,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let n = cost.length;\n    let dp = new Array(n).fill(0).map(()=>new Array(n).fill(0));\n    dp[0][0] = cost[0][0];\n    for(let i = 1; i < n; i++){\n        dp[0][i] = dp[0][i-1] + cost[0][i];\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let i = 1; i < n; i++){\n        for(let j = 1; j < n; j++){\n            dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[n-1][n-1] / (2*n - 1);\n}\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124040,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let n = cost.length;\n    let dp = new Array(n);\n    for(let i = 0; i < n; i++){\n        dp[i] = new Array(n);\n    }\n    dp[0][0] = cost[0][0];\n    for(let i = 1; i < n; i++){\n        dp[0][i] = dp[0][i-1] + cost[0][i];\n    }\n    for(let i = 1; i < n; i++){\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let i = 1; i < n; i++){\n        for(let j = 1; j < n; j++){\n            dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[n-1][n-1] / (2*n - 1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124040,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let n = cost.length;\n    let dp = new Array(n);\n    for(let i = 0; i < n; i++){\n        dp[i] = new Array(n);\n    }\n    dp[0][0] = cost[0][0];\n    for(let i = 1; i < n; i++){\n        dp[0][i] = dp[0][i-1] + cost[0][i];\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let i = 1; i < n; i++){\n        for(let j = 1; j < n; j++){\n            dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[n-1][n-1]/(2*n-1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1665509918,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let n = cost.length;\n    let dp = new Array(n);\n    for(let i = 0; i < n; i++){\n        dp[i] = new Array(n);\n    }\n    dp[0][0] = cost[0][0];\n    for(let i = 1; i < n; i++){\n        dp[0][i] = dp[0][i-1] + cost[0][i];\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let i = 1; i < n; i++){\n        for(let j = 1; j < n; j++){\n            dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[n-1][n-1] / (2*n - 1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1665509918,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let n = cost.length;\n    let dp = new Array(n);\n    for(let i = 0; i < n; i++){\n        dp[i] = new Array(n);\n    }\n    dp[0][0] = cost[0][0];\n    for(let i = 1; i < n; i++){\n        dp[0][i] = dp[0][i-1] + cost[0][i];\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let i = 1; i < n; i++){\n        for(let j = 1; j < n; j++){\n            dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[n-1][n-1] / (2*n - 1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1665509918,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n  let n = cost.length;\n  let dp = new Array(n).fill(0).map(() => new Array(n).fill(0));\n  dp[0][0] = cost[0][0];\n  for(let i = 1; i < n; i++){\n    dp[0][i] = dp[0][i-1] + cost[0][i];\n    dp[i][0] = dp[i-1][0] + cost[i][0];\n  }\n  for(let i = 1; i < n; i++){\n    for(let j = 1; j < n; j++){\n      dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n    }\n  }\n  return dp[n-1][n-1] / (2 * n - 1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124040,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let maxAverage = 0;\n    let maxPath = [];\n    let path = [];\n    let totalCost = 0;\n    let numCells = 0;\n    let average = 0;\n    let row = 0;\n    let col = 0;\n    let rowMax = cost.length - 1;\n    let colMax = cost[0].length - 1;\n    let pathFound = false;\n    let pathExists = false;\n\n    function findPath(row, col, totalCost, numCells, path){\n        if(row === rowMax && col === colMax){\n            pathFound = true;\n            pathExists = true;\n            average = totalCost / numCells;\n            if(average > maxAverage){\n                maxAverage = average;\n                maxPath = path;\n            }\n        }\n        if(row < rowMax){\n            path.push(cost[row + 1][col]);\n            findPath(row + 1, col, totalCost + cost[row + 1][col], numCells + 1, path);\n            path.pop();\n        }\n        if(col < colMax){\n            path.push(cost[row][col + 1]);\n            findPath(row, col + 1, totalCost + cost[row][col + 1], numCells + 1, path);\n            path.pop();\n        }\n    }\n\n    findPath(row, col, totalCost, numCells, path);\n\n    if(!pathExists){\n        return 'No path exists';\n    }\n\n    return maxPath;\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124040,
      "stdout": "",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n[]\n\nshould loosely deep-equal\n\n5.2\n    at test (/tmp/tmpfd4i3oqz.js:52:10)\n    at Object.<anonymous> (/tmp/tmpfd4i3oqz.js:58:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: [],\n  expected: 5.2,\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "exit_code": 1,
      "status": "AssertionError"
    },
    {
      "program": "//Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let n = cost.length;\n    let dp = new Array(n).fill(0).map(()=>new Array(n).fill(0));\n    dp[0][0] = cost[0][0];\n    for(let i=1;i<n;i++){\n        dp[0][i] = dp[0][i-1] + cost[0][i];\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let i=1;i<n;i++){\n        for(let j=1;j<n;j++){\n            dp[i][j] = Math.max(dp[i-1][j],dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[n-1][n-1]/(2*n-1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1665509918,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let n = cost.length;\n    let dp = new Array(n);\n    for(let i = 0; i < n; i++){\n        dp[i] = new Array(n);\n        for(let j = 0; j < n; j++){\n            dp[i][j] = {\n                cost: 0,\n                count: 0\n            };\n        }\n    }\n    dp[0][0] = {\n        cost: cost[0][0],\n        count: 1\n    };\n    for(let i = 1; i < n; i++){\n        dp[0][i] = {\n            cost: dp[0][i - 1].cost + cost[0][i],\n            count: dp[0][i - 1].count + 1\n        };\n        dp[i][0] = {\n            cost: dp[i - 1][0].cost + cost[i][0],\n            count: dp[i - 1][0].count + 1\n        };\n    }\n    for(let i = 1; i < n; i++){\n        for(let j = 1; j < n; j++){\n            let top = dp[i - 1][j];\n            let left = dp[i][j - 1];\n            if(top.cost / top.count > left.cost / left.count){\n                dp[i][j] = {\n                    cost: top.cost + cost[i][j],\n                    count: top.count + 1\n                };\n            } else {\n                dp[i][j] = {\n                    cost: left.cost + cost[i][j],\n                    count: left.count + 1\n                };\n            }\n        }\n    }\n    return dp[n - 1][n - 1].cost / dp[n - 1][n - 1].count;\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124040,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let n = cost.length;\n    let dp = new Array(n);\n    for(let i = 0; i < n; i++){\n        dp[i] = new Array(n);\n        dp[i][0] = cost[i][0];\n    }\n    for(let j = 0; j < n; j++){\n        dp[0][j] = cost[0][j];\n    }\n    for(let i = 1; i < n; i++){\n        for(let j = 1; j < n; j++){\n            dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[n-1][n-1] / (2*n - 1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124040,
      "stdout": "",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n4.8\n\nshould loosely deep-equal\n\n5.2\n    at test (/tmp/tmp6y9cjt71.js:25:10)\n    at Object.<anonymous> (/tmp/tmp6y9cjt71.js:31:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: 4.8,\n  expected: 5.2,\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "exit_code": 1,
      "status": "AssertionError"
    },
    {
      "program": "//Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n  var n = cost.length;\n  var dp = [];\n  for(var i=0; i<n; i++){\n    dp.push([]);\n    for(var j=0; j<n; j++){\n      dp[i].push(0);\n    }\n  }\n  dp[0][0] = cost[0][0];\n  for(var i=1; i<n; i++){\n    dp[0][i] = dp[0][i-1] + cost[0][i];\n    dp[i][0] = dp[i-1][0] + cost[i][0];\n  }\n  for(var i=1; i<n; i++){\n    for(var j=1; j<n; j++){\n      dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n    }\n  }\n  return dp[n-1][n-1]/(2*n-1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124040,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let n = cost.length;\n    let dp = new Array(n);\n    for(let i = 0; i < n; i++){\n        dp[i] = new Array(n);\n    }\n    dp[0][0] = cost[0][0];\n    for(let i = 1; i < n; i++){\n        dp[0][i] = dp[0][i-1] + cost[0][i];\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let i = 1; i < n; i++){\n        for(let j = 1; j < n; j++){\n            dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[n-1][n-1] / (2*n - 1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1665509918,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n  let n = cost.length;\n  let dp = new Array(n).fill(0).map(()=>new Array(n).fill(0));\n  dp[0][0] = cost[0][0];\n  for(let i = 1; i < n; i++){\n    dp[0][i] = dp[0][i-1] + cost[0][i];\n    dp[i][0] = dp[i-1][0] + cost[i][0];\n  }\n  for(let i = 1; i < n; i++){\n    for(let j = 1; j < n; j++){\n      dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n    }\n  }\n  return dp[n-1][n-1] / (2*n-1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124040,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n  let n = cost.length;\n  let dp = new Array(n);\n  for(let i = 0; i < n; i++){\n    dp[i] = new Array(n);\n  }\n  dp[0][0] = cost[0][0];\n  for(let i = 1; i < n; i++){\n    dp[0][i] = dp[0][i-1] + cost[0][i];\n    dp[i][0] = dp[i-1][0] + cost[i][0];\n  }\n  for(let i = 1; i < n; i++){\n    for(let j = 1; j < n; j++){\n      dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n    }\n  }\n  return dp[n-1][n-1] / (2*n-1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1665509918,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let n = cost.length;\n    let dp = new Array(n).fill(0).map(()=>new Array(n).fill(0));\n    dp[0][0] = cost[0][0];\n    for(let i=1;i<n;i++){\n        dp[0][i] = dp[0][i-1] + cost[0][i];\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let i=1;i<n;i++){\n        for(let j=1;j<n;j++){\n            dp[i][j] = Math.max(dp[i-1][j],dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[n-1][n-1]/(2*n-1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1665509918,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let n = cost.length;\n    let dp = new Array(n);\n    for(let i = 0; i < n; i++){\n        dp[i] = new Array(n);\n    }\n    dp[0][0] = cost[0][0];\n    for(let i = 1; i < n; i++){\n        dp[0][i] = dp[0][i-1] + cost[0][i];\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let i = 1; i < n; i++){\n        for(let j = 1; j < n; j++){\n            dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[n-1][n-1]/(2*n-1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1665509918,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let rows = cost.length;\n    let cols = cost[0].length;\n    let dp = new Array(rows);\n    for(let i = 0; i < rows; i++){\n        dp[i] = new Array(cols);\n    }\n    dp[0][0] = cost[0][0];\n    for(let i = 1; i < rows; i++){\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let i = 1; i < cols; i++){\n        dp[0][i] = dp[0][i-1] + cost[0][i];\n    }\n    for(let i = 1; i < rows; i++){\n        for(let j = 1; j < cols; j++){\n            dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[rows-1][cols-1] / (rows + cols - 1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124040,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let n = cost.length;\n    let dp = new Array(n);\n    for(let i = 0; i < n; i++){\n        dp[i] = new Array(n);\n    }\n    dp[0][0] = cost[0][0];\n    for(let i = 1; i < n; i++){\n        dp[0][i] = dp[0][i-1] + cost[0][i];\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let i = 1; i < n; i++){\n        for(let j = 1; j < n; j++){\n            dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[n-1][n-1]/(2*n-1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1665509918,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n  let n = cost.length;\n  let dp = new Array(n).fill(0).map(() => new Array(n).fill(0));\n  dp[0][0] = cost[0][0];\n  for(let i = 1; i < n; i++){\n    dp[0][i] = dp[0][i-1] + cost[0][i];\n    dp[i][0] = dp[i-1][0] + cost[i][0];\n  }\n  for(let i = 1; i < n; i++){\n    for(let j = 1; j < n; j++){\n      dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n    }\n  }\n  return dp[n-1][n-1] / (2*n - 1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124040,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n  let n = cost.length;\n  let dp = new Array(n).fill(0).map(() => new Array(n).fill(0));\n  dp[0][0] = cost[0][0];\n  for(let i = 1; i < n; i++){\n    dp[0][i] = dp[0][i-1] + cost[0][i];\n    dp[i][0] = dp[i-1][0] + cost[i][0];\n  }\n  for(let i = 1; i < n; i++){\n    for(let j = 1; j < n; j++){\n      dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n    }\n  }\n  return dp[n-1][n-1] / (2*n - 1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124040,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n  let n = cost.length;\n  let dp = new Array(n);\n  for(let i = 0; i < n; i++){\n    dp[i] = new Array(n);\n  }\n  dp[0][0] = cost[0][0];\n  for(let i = 1; i < n; i++){\n    dp[i][0] = dp[i-1][0] + cost[i][0];\n    dp[0][i] = dp[0][i-1] + cost[0][i];\n  }\n  for(let i = 1; i < n; i++){\n    for(let j = 1; j < n; j++){\n      dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n    }\n  }\n  return dp[n-1][n-1] / (2*n-1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124040,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let n = cost.length;\n    let dp = new Array(n).fill(0).map(() => new Array(n).fill(0));\n    dp[0][0] = cost[0][0];\n    for(let i = 1; i < n; i++){\n        dp[0][i] = dp[0][i-1] + cost[0][i];\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let i = 1; i < n; i++){\n        for(let j = 1; j < n; j++){\n            dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[n-1][n-1] / (2*n - 1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124040,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n    let row = cost.length;\n    let col = cost[0].length;\n    let dp = new Array(row);\n    for(let i = 0; i < row; i++){\n        dp[i] = new Array(col).fill(0);\n    }\n    dp[0][0] = cost[0][0];\n    for(let i = 1; i < row; i++){\n        dp[i][0] = dp[i-1][0] + cost[i][0];\n    }\n    for(let i = 1; i < col; i++){\n        dp[0][i] = dp[0][i-1] + cost[0][i];\n    }\n    for(let i = 1; i < row; i++){\n        for(let j = 1; j < col; j++){\n            dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n        }\n    }\n    return dp[row-1][col-1]/(row+col-2);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124040,
      "stdout": "",
      "stderr": "node:assert:124\n  throw new AssertionError(obj);\n  ^\n\nAssertionError [ERR_ASSERTION]: Expected values to be loosely deep-equal:\n\n6.5\n\nshould loosely deep-equal\n\n5.2\n    at test (/tmp/tmp6wiy34q6.js:29:10)\n    at Object.<anonymous> (/tmp/tmp6wiy34q6.js:35:1)\n    at Module._compile (node:internal/modules/cjs/loader:1120:14)\n    at Module._extensions..js (node:internal/modules/cjs/loader:1174:10)\n    at Module.load (node:internal/modules/cjs/loader:998:32)\n    at Module._load (node:internal/modules/cjs/loader:839:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47 {\n  generatedMessage: true,\n  code: 'ERR_ASSERTION',\n  actual: 6.5,\n  expected: 5.2,\n  operator: 'deepEqual'\n}\n\nNode.js v18.7.0\n",
      "exit_code": 1,
      "status": "AssertionError"
    },
    {
      "program": "//Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n  let n = cost.length;\n  let dp = new Array(n);\n  for(let i = 0; i < n; i++){\n    dp[i] = new Array(n);\n    for(let j = 0; j < n; j++){\n      dp[i][j] = 0;\n    }\n  }\n  dp[0][0] = cost[0][0];\n  for(let i = 1; i < n; i++){\n    dp[0][i] = dp[0][i-1] + cost[0][i];\n    dp[i][0] = dp[i-1][0] + cost[i][0];\n  }\n  for(let i = 1; i < n; i++){\n    for(let j = 1; j < n; j++){\n      dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n    }\n  }\n  return dp[n-1][n-1] / (2*n - 1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124040,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunction maxAverageOfPath(cost){\n  let n = cost.length;\n  let m = cost[0].length;\n  let dp = new Array(n);\n  for(let i = 0; i < n; i++){\n    dp[i] = new Array(m);\n  }\n  dp[0][0] = cost[0][0];\n  for(let i = 1; i < n; i++){\n    dp[i][0] = dp[i-1][0] + cost[i][0];\n  }\n  for(let j = 1; j < m; j++){\n    dp[0][j] = dp[0][j-1] + cost[0][j];\n  }\n  for(let i = 1; i < n; i++){\n    for(let j = 1; j < m; j++){\n      dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) + cost[i][j];\n    }\n  }\n  return dp[n-1][m-1] / (n + m - 1);\n}\n\nconst assert = require('node:assert');\n\n\nfunction test() {\n  let candidate = maxAverageOfPath;\n  assert.deepEqual(candidate([[1, 2, 3], [6, 5, 4], [7, 3, 9]]),5.2);\n  assert.deepEqual(candidate([[2, 3, 4], [7, 6, 5], [8, 4, 10]]),6.2);\n  assert.deepEqual(candidate([[3, 4, 5], [8, 7, 6], [9, 5, 11]]),7.2);\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),5.8);\n}\n\ntest();",
      "timestamp": 1666124040,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    }
  ]
}