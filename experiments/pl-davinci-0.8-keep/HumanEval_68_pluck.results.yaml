language: pl
name: HumanEval_68_pluck
results:
- exit_code: 1
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\nsub pluck {\n    my($arr) = @_;\n    my $min = -1;\n    my\
    \ $res = [-1, -1];\n    for my $i (0..@$arr-1) {\n        my $n = $arr->[$i];\n\
    \        if ($n % 2 == 0) {\n            if ($min == -1) {\n                $min\
    \ = $n;\n                $res = [$n, $i];\n            } else {\n            \
    \    if ($n < $min) {\n                    $min = $n;\n                    $res\
    \ = [$n, $i];\n                }\n            }\n        }\n    }\n    return\
    \ $res;\n}\nmy $arr;\n$arr = [4,2,3];\nprint join(',', @{pluck($arr)}), \"\\n\"\
    ;\n$arr = [1,2,3];\nprint join(',', @{pluck($arr)}), \"\\n\";\n$arr = [];\nprint\
    \ join(',', @{pluck($arr)}), \"\\n\";\n$arr = [5, 0, 3, 0, 4, 2];\nprint join(',',\
    \ @{pluck($arr)}), \"\\n\";\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my\
    \ $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1]))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: '2,1

    2,1

    -1,-1

    0,1

    ok!ok!'
  timestamp: 1659821280
- exit_code: 1
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\nsub pluck {\n    my($arr) = @_;\n    my $i = 0;\n    my @ret;\n\
    \    for my $v (@$arr) {\n        push @ret, $v if($v % 2 == 0 && (scalar(@ret)\
    \ == 0 || $v < $ret[0]));\n    }\n    return [ @ret ];\n}\nuse Test::Deep;\n\n\
    \nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\"\
    \ }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[]))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n\
    \        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1659821280
- exit_code: 1
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\nsub pluck {\n    my($arr) = @_;\n    return [] if(!$arr ||\
    \ !@$arr);\n    my $min = 2 ** 32;\n    my $idx = -1;\n    for(my $i = 0; $i <\
    \ @$arr; $i++) {\n        if($arr->[$i] && $arr->[$i] < $min && $arr->[$i] % 2\
    \ == 0) {\n            $min = $arr->[$i];\n            $idx = $i;\n        }\n\
    \    }\n    return [] if($idx == -1);\n    return [$min, $idx];\n}\nuse Test::Deep;\n\
    \n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\"\
    \ }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[]))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n\
    \        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ok!ok!ok!
  timestamp: 1659821280
- exit_code: 1
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\nsub pluck {\n    my($arr) = @_;\n    my @ret;\n    for(my $i=0;\
    \ $i<@$arr; $i++) {\n        my $v = $arr->[$i];\n        if (!@ret || $v % 2\
    \ == 0 && $v < $ret[0]) {\n            @ret = ($v, $i);\n        }\n    }\n  \
    \  return @ret;\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate\
    \ = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n     \
    \   print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1659821280
- exit_code: 1
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\nsub pluck {\n    my($arr) = @_;\n    # Your code here.\n  \
    \  return 0;\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate =\
    \ \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n       \
    \ print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1659821280
- exit_code: 1
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\nsub pluck {\n    my($arr) = @_;\n    my $idx = 0;\n    my $min\
    \ = undef;\n    foreach my $e (@$arr) {\n        if(!$min && $e % 2 == 0) {\n\
    \            $min = $e;\n        } elsif(defined($min) && $e % 2 == 0 && $e <\
    \ $min) {\n            $min = $e;\n        }\n        if(defined($min) && $e ==\
    \ $min) {\n            return [$min, $idx];\n        }\n        $idx++;\n    }\n\
    \    return [];\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate\
    \ = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n     \
    \   print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1659821280
- exit_code: 1
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\nsub pluck {\n    my($arr) = @_;\n    my $idx = 0;\n    my $smallest;\n\
    \    my $found;\n    for my $node (@$arr) {\n        if($node % 2 == 0) {\n  \
    \          if(!defined($smallest) || $node < $smallest) {\n                $smallest\
    \ = $node;\n                $found = [$node, $idx];\n            }\n        }\n\
    \        $idx++;\n    }\n    $found;\n}\nuse Test::Deep;\n\n\nsub testhumaneval\
    \ {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2,\
    \ 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ok!ok!
  timestamp: 1659821280
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\nsub pluck {\n    my($arr) = @_;\n    my @ret = ();\n    my\
    \ $min_even = 0;\n    my $i_min_even = 0;\n    for(my $i=0; $i<@$arr; $i++) {\n\
    \        if($arr->[$i]%2 == 0) {\n            if(@ret==0) {\n                @ret\
    \ = ($arr->[$i], $i);\n            } else {\n                if($arr->[$i] < $ret[0])\
    \ {\n                    @ret = ($arr->[$i], $i);\n                }\n       \
    \     }\n        }\n    }\n    return \\@ret;\n}\nuse Test::Deep;\n\n\nsub testhumaneval\
    \ {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2,\
    \ 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1659821280
- exit_code: 1
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\nsub pluck {\n    my($arr) = @_;\n    my @r;\n    # your code\
    \ goes here\n    return @r;\n}\nprint join(\", \", pluck([4,2,3])), \"\\n\"; #\
    \ 2, 1\nprint join(\", \", pluck([1,2,3])), \"\\n\"; # 2, 1\nprint join(\", \"\
    , pluck([])), \"\\n\"; # \nprint join(\", \", pluck([5, 0, 3, 0, 4, 2])), \"\\\
    n\"; # 0, 1\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\\
    &pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: '




    '
  timestamp: 1659821280
- exit_code: 1
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\nsub pluck {\n    my($arr) = @_;\n    my $min = $_[0];\n   \
    \ my $index = 0;\n    for my $i (0..@$arr-1) {\n        if($arr->[$i] != 0 and\
    \ $arr->[$i]%2 == 0) {\n            if($arr->[$i] < $min) {\n                $min\
    \ = $arr->[$i];\n                $index = $i;\n            }\n        }\n    }\n\
    \    return [$min, $index];\n}\nmy $input = [5, 0, 3, 0, 4, 2];\nmy $result =\
    \ pluck($input);\nprint \"Result = @$result\\n\";\nuse Test::Deep;\n\n\nsub testhumaneval\
    \ {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2,\
    \ 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: 'Result = 2 5

    ok!ok!'
  timestamp: 1659821280
- exit_code: 1
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\nsub pluck {\n    my($arr) = @_;\n    # Your code here\n}\n\
    use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n    \
    \    if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3]),[2,\
    \ 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[]))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n\
    \        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1659821280
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\nsub pluck {\n    my($arr) = @_;\n    # $arr: Array of Integer\n\
    \    # return: Array of Integer\n    use POSIX;\n    my $min = ceil(0xFFFFFFFF);\n\
    \    my $i = 0;\n    my $ind = -1;\n    foreach my $n (@$arr) {\n        if ($n\
    \ == 0) {\n            $ind = $i if ($ind == -1);\n        }\n        if (($n\
    \ < $min) && ($n % 2 == 0)) {\n            $min = $n;\n            $ind = $i;\n\
    \        }\n        $i++;\n    }\n    return [] if ($ind == -1);\n    return [$min,\
    \ $ind];\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\\
    &pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1659821280
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\nsub pluck {\n    my($arr) = @_;\n    my $n = scalar(@$arr);\n\
    \    my $i;\n    my $min_even;\n    my $min_even_index;\n    for ($i=0; $i<$n;\
    \ $i++) {\n        if ($arr->[$i] % 2 == 0) {\n            if (!defined($min_even)\
    \ || $arr->[$i] < $min_even) {\n                $min_even = $arr->[$i];\n    \
    \            $min_even_index = $i;\n            }\n        }\n    }\n    if (defined($min_even))\
    \ {\n        return [$min_even, $min_even_index];\n    } else {\n        return\
    \ [];\n    }\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate =\
    \ \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n       \
    \ print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1659821280
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\nsub pluck {\n    my($arr) = @_;\n    my $even = -1;\n    my\
    \ $eveni = -1;\n    for(my $i=0; $i<=$#$arr; $i++) {\n        my $a = $arr->[$i];\n\
    \        if($a%2==0) {\n            if($even<0 || $a<$even) {\n              \
    \  $even = $a;\n                $eveni = $i;\n            }\n        }\n    }\n\
    \    return ($eveni<0) ? [] : [$even, $eveni];\n}\nuse Test::Deep;\n\n\nsub testhumaneval\
    \ {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2,\
    \ 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1659821280
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\nsub pluck {\n    my($arr) = @_;\n    my($m, $i);\n    for (my\
    \ $j = 0; $j < scalar(@$arr); $j++) {\n        if ($arr->[$j] % 2 == 0) {\n  \
    \          if (defined($m)) {\n                if ($arr->[$j] < $m) {\n      \
    \              $m = $arr->[$j];\n                    $i = $j;\n              \
    \  }\n            } else {\n                $m = $arr->[$j];\n               \
    \ $i = $j;\n            }\n        }\n    }\n    return defined($m) ? [$m, $i]\
    \ : [];\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n\
    \        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n        print \"ok!\"\
    \ }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2,\
    \ 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n \
    \       exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1659821280
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\nsub pluck {\n    my($arr) = @_;\n    my $n = @$arr;\n    my\
    \ @res = ( );\n    if ( $n == 0 ) {\n        return \\@res;\n    }\n    my $i;\n\
    \    my $j = undef;\n    for ( $i = 0; $i < $n; $i++ ) {\n        if ( ( $arr->[$i]\
    \ % 2 ) == 0 ) {\n            if ( not defined($j) or $arr->[$i] < $arr->[$j]\
    \ ) {\n                $j = $i;\n            }\n        }\n    }\n    if ( defined($j)\
    \ ) {\n        @res = ( $arr->[$j], $j );\n    }\n    return \\@res;\n}\nuse Test::Deep;\n\
    \n\nsub testhumaneval {\n    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([1, 2, 3]),[2, 1])) {\n        print \"ok!\"\
    \ }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[]))\
    \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 0, 3, 0, 4, 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n\
    \        }\n        if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n\
    \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1659821280
- exit_code: 1
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\nsub pluck {\n    my($arr) = @_;\n    if (@$arr == 0) {\n  \
    \      return [];\n    }\n    my($smallest_even, $smallest_index) = (undef, undef);\n\
    \    for my $i (0..$#$arr) {\n        my $v = $arr->[$i];\n        if (defined($smallest_even))\
    \ {\n            if ($v < $smallest_even) {\n                $smallest_even =\
    \ $v;\n                $smallest_index = $i;\n            }\n        } else {\n\
    \            if ($v % 2 == 0) {\n                $smallest_even = $v;\n      \
    \          $smallest_index = $i;\n            }\n        }\n    }\n    if (defined($smallest_even))\
    \ {\n        return [$smallest_even, $smallest_index];\n    } else {\n       \
    \ return [];\n    }\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate\
    \ = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n     \
    \   print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!
  timestamp: 1659821280
- exit_code: 1
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\nsub pluck {\n    my($arr) = @_;\n    return [] if (!@$arr);\n\
    \    my $evens = [map {$_ % 2 == 0 ? [$_, $_[$_]] : ()} 0..$#$arr];\n    if (!@$evens)\
    \ {\n        return [];\n    }\n    my $smallest = $evens->[0][0];\n    return\
    \ [$smallest, $evens->[0][1]];\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n\
    \    my $candidate = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2,\
    \ 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1659821280
- exit_code: 1
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\nsub pluck {\n    my($arr) = @_;\n    my @res;\n    my $min\
    \ = $arr->[0];\n    my $idx = 0;\n    foreach my $i (0..$#{$arr}) {\n        if(($arr->[$i]\
    \ < $min) && ($arr->[$i] % 2 == 0)) {\n            $min = $arr->[$i];\n      \
    \      $idx = $i;\n        }\n    }\n    @res = ($min, $idx) if($min % 2 == 0);\n\
    \    return @res;\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate\
    \ = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n     \
    \   print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1659821280
- exit_code: 0
  program: "# \"Given an array representing a branch of a tree that has non-negative\
    \ integer nodes\n# your task is to pluck one of the nodes and return it.\n# The\
    \ plucked node should be the node with the smallest even value.\n# If multiple\
    \ nodes with the same smallest even value are found return the node that has smallest\
    \ index.\n# The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n# If there are no even values or the given array is empty, return\
    \ [].\n# Example 1:\n# Input: [4,2,3]\n# Output: [2, 1]\n# Explanation: 2 has\
    \ the smallest even value, and 2 has the smallest index.\n# Example 2:\n# Input:\
    \ [1,2,3]\n# Output: [2, 1]\n# Explanation: 2 has the smallest even value, and\
    \ 2 has the smallest index. \n# Example 3:\n# Input: []\n# Output: []\n# Example\
    \ 4:\n# Input: [5, 0, 3, 0, 4, 2]\n# Output: [0, 1]\n# Explanation: 0 is the smallest\
    \ value, but  there are two zeros,\n# so we will choose the first zero, which\
    \ has the smallest index.\n# Constraints:\n# * 1 <= nodes.length <= 10000\n# *\
    \ 0 <= node.value\nsub pluck {\n    my($arr) = @_;\n    my($min, $idx);\n    for\
    \ my $i (0..$#$arr) {\n        if ($arr->[$i] % 2 == 0) {\n            if (!defined($min)\
    \ || $arr->[$i] < $min) {\n                $min = $arr->[$i];\n              \
    \  $idx = $i;\n            }\n        }\n    }\n    return defined($min) ? [$min,\
    \ $idx] : [];\n}\nuse Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate\
    \ = \\&pluck;\n        if(eq_deeply($candidate->([4, 2, 3]),[2, 1])) {\n     \
    \   print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1,\
    \ 2, 3]),[2, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    \        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n\
    \        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 0, 3, 0, 4,\
    \ 2]),[0, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n \
    \       if(eq_deeply($candidate->([1, 2, 3, 0, 5, 3]),[0, 3])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
    \ 4, 8, 4, 8]),[4, 1])) {\n        print \"ok!\" }else{\n        exit 1;\n   \
    \     }\n        if(eq_deeply($candidate->([7, 6, 7, 1]),[6, 1])) {\n        print\
    \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([7,\
    \ 9, 7, 1]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
    }\n\ntesthumaneval();"
  status: OK
  stderr: ''
  stdout: ok!ok!ok!ok!ok!ok!ok!ok!
  timestamp: 1659821280
