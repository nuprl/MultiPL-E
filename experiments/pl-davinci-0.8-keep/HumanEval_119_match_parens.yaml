name: HumanEval_119_match_parens
language: pl
prompt: "# You are given a list of two strings, both strings consist of open\n# parentheses\
  \ '(' or close parentheses ')' only.\n# Your job is to check if it is possible to\
  \ concatenate the two strings in\n# some order, that the resulting string will be\
  \ good.\n# A string S is considered to be good if and only if all parentheses in\
  \ S\n# are balanced. For example: the string '(())()' is good, while the string\n\
  # '())' is not.\n# Return 'Yes' if there's a way to make a good string, and return\
  \ 'No' otherwise.\n# Examples:\n# match_parens(['()(', ')']) == 'Yes'\n# match_parens([')',\
  \ ')']) == 'No'\nsub match_parens {\n    my($lst) = @_;\n"
tests: "use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&match_parens;\n\
  \        if(eq_deeply($candidate->([\"()(\", \")\"]),\"Yes\")) {\n        print\
  \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([\"\
  )\", \")\"]),\"No\")) {\n        print \"ok!\" }else{\n        exit 1;\n       \
  \ }\n        if(eq_deeply($candidate->([\"(()(())\", \"())())\"]),\"No\")) {\n \
  \       print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([\"\
  )())\", \"(()()(\"]),\"Yes\")) {\n        print \"ok!\" }else{\n        exit 1;\n\
  \        }\n        if(eq_deeply($candidate->([\"(())))\", \"(()())((\"]),\"Yes\"\
  )) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([\"\
  ()\", \"())\"]),\"No\")) {\n        print \"ok!\" }else{\n        exit 1;\n    \
  \    }\n        if(eq_deeply($candidate->([\"(()(\", \"()))()\"]),\"Yes\")) {\n\
  \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([\"\
  ((((\", \"((())\"]),\"No\")) {\n        print \"ok!\" }else{\n        exit 1;\n\
  \        }\n        if(eq_deeply($candidate->([\")(()\", \"(()(\"]),\"No\")) {\n\
  \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([\"\
  )(\", \")(\"]),\"No\")) {\n        print \"ok!\" }else{\n        exit 1;\n     \
  \   }\n        if(eq_deeply($candidate->([\"(\", \")\"]),\"Yes\")) {\n        print\
  \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([\"\
  )\", \"(\"]),\"Yes\")) {\n        print \"ok!\" }else{\n        exit 1;\n      \
  \  }\n}\n\ntesthumaneval();"
completions: ["    my($closes, $opens) = (0, 0);\n    for my $p (@$lst) {\n      \
    \  my $opens = count_parens($p, '(');\n        my $closes = count_parens($p, ')');\n\
    \        $opens -= $closes;\n        return 'No' if $opens < 0;\n    }\n    $opens\
    \ == 0 ? 'Yes' : 'No';\n}", "    my($s1, $s2) = @$lst;\n    my $n1 = $s1 =~ s/\\\
    (//g;\n    my $n2 = $s2 =~ s/\\(//g;\n    my $n3 = $s1 =~ s/\\)//g;\n    my $n4\
    \ = $s2 =~ s/\\)//g;\n    return ($n1+$n2 == $n3+$n4) ? 'Yes' : 'No';\n}", " \
    \   my($s1, $s2) = @$lst;\n    my($ok) = 'Yes';\n    for my $s ($s1, $s2) {\n\
    \        $ok = 'No' if substr($s, 0, 1) eq ')';\n        my $n = 0;\n        for\
    \ my $ch (split //, $s) {\n            $n++ if $ch eq '(';\n            $n-- if\
    \ $ch eq ')';\n            $ok = 'No' if $n < 0;\n        }\n        $ok = 'No'\
    \ if $n != 0;\n    }\n    return $ok;\n}", "    my @stack;\n    my $first = shift\
    \ @$lst;\n    my $second = shift @$lst;\n    for my $ch (split '', $first) {\n\
    \        push @stack, $ch;\n        if ($ch eq ')') {\n            my $maybe_last\
    \ = pop @stack;\n            return 'No' if ($maybe_last ne '(');\n        }\n\
    \    }\n    for my $ch (split '', $second) {\n        push @stack, $ch;\n    \
    \    if ($ch eq ')') {\n            my $maybe_last = pop @stack;\n           \
    \ return 'No' if ($maybe_last ne '(');\n        }\n    }\n    return 'Yes';\n}",
  "    my($subs) = {};\n    my $str = join('', @$lst);\n    return 'No' if ($str =~\
    \ /^\\)/ or $str =~ /\\($/);\n    $str =~ s/^\\(//;\n    $str =~ s/\\)$//;\n \
    \   return 'Yes' if $str eq '';\n    for my $i (0..length($str)-1) {\n       \
    \ for my $j ($i+1..length($str)) {\n            my $str_sub = substr($str, $i,\
    \ $j-$i);\n            if ($str_sub =~ /^\\((.*)\\)$/) {\n                my $internal\
    \ = $1;\n                $subs->{$internal} = 1;\n            }\n        }\n \
    \   }\n    for my $internal (keys %$subs) {\n        if (match_parens([$internal])\
    \ eq 'Yes') {\n            my $rest = substr($str, length($internal)+2);\n   \
    \         $rest =~ s/^\\(//;\n            $rest =~ s/\\)$//;\n            if (match_parens([$rest])\
    \ eq 'Yes') {\n                return 'Yes';\n            }\n        }\n    }\n\
    \    return 'No';\n}", "    my $parens = join('', @$lst);\n    my $balance = 0;\n\
    \    for my $c (split('', $parens)) {\n        $balance += $c eq '(' ? 1 : -1;\n\
    \        return 'No' if $balance < 0;\n    }\n    $balance == 0 ? 'Yes' : 'No';\n\
    }", "    my $s1 = $lst->[0];\n    my $s2 = $lst->[1];\n    my $s = '';\n    while\
    \ ($s1 =~ s/^\\(// || $s2 =~ s/^\\(//) {\n        $s .= '(';\n    }\n    while\
    \ ($s1 =~ s/^\\)// || $s2 =~ s/^\\)//) {\n        $s .= ')';\n    }\n    return\
    \ 'No' if $s =~ /\\)$/;\n    return 'No' if $s =~ /\\)\\(/;\n    return 'No' if\
    \ $s =~ /\\)+/;\n    return 'No' if $s =~ /\\(+/;\n    return 'Yes';\n}", "  \
    \  my($s1, $s2) = @$lst;\n    my($left, $right) = (0, 0);\n    my($parens) = $s1\
    \ . $s2;\n    for my $p (split('', $parens)) {\n        if ($p eq '(') {\n   \
    \         $left += 1;\n        }\n        elsif ($p eq ')') {\n            if\
    \ ($left > 0) {\n                $left -= 1;\n            }\n            else\
    \ {\n                $right += 1;\n            }\n        }\n    }\n    if ($left\
    \ == 0 && $right == 0) {\n        return 'Yes';\n    }\n    return 'No';\n}",
  "    my($s1, $s2) = @$lst;\n    my($c1, $c2) = (0, 0);\n    for my $c (split('',\
    \ $s1)) {\n        $c == '(' ? $c1++ : $c1--;\n    }\n    for my $c (split('',\
    \ $s2)) {\n        $c == '(' ? $c2++ : $c2--;\n    }\n    my $mismatch = $c1 +\
    \ $c2;\n    return $mismatch < 2 && $mismatch >= 0 ? 'Yes' : 'No';\n}", "    my\
    \ $left = 0;\n    my $right = 0;\n    foreach(@$lst) {\n        $left++ if($_\
    \ eq '(');\n        $right++ if($_ eq ')');\n    }\n    return 'Yes' if(abs($left\
    \ - $right) <= 1);\n    return 'No';\n}", "    my @lst = @$lst;\n    my $left\
    \ = 0;\n    my $right = 0;\n    for my $s (@lst) {\n        my @s = split('',\
    \ $s);\n        my $left2 = 0;\n        my $right2 = 0;\n        for my $c (@s)\
    \ {\n            if ($c eq '(') {\n                $left2++;\n            } else\
    \ {\n                $right2++;\n            }\n        }\n        $left = $left2\
    \ if $left2 > $left;\n        $right = $right2 if $right2 > $right;\n    }\n \
    \   if ($left == $right) {\n        return 'Yes';\n    } else {\n        return\
    \ 'No';\n    }\n}", "    my($x, $y) = @$lst;\n    my($bal) = 0;\n    for my $c\
    \ (split //, $x) {\n        $bal++ if $c eq '(';\n        $bal-- if $c eq ')';\n\
    \        return 'No' if $bal < 0;\n    }\n    for my $c (split //, $y) {\n   \
    \     $bal++ if $c eq '(';\n        $bal-- if $c eq ')';\n        return 'No'\
    \ if $bal < 0;\n    }\n    return 'Yes';\n}", "    my($l) = pop(@$lst);\n    my($r)\
    \ = pop(@$lst);\n    my($l_open, $l_close) = (0, 0);\n    my($r_open, $r_close)\
    \ = (0, 0);\n    for my $c (split(//, $l)) {\n        if ($c eq '(') {\n     \
    \       $l_open++;\n        } else {\n            $l_close++;\n        }\n   \
    \ }\n    for my $c (split(//, $r)) {\n        if ($c eq '(') {\n            $r_open++;\n\
    \        } else {\n            $r_close++;\n        }\n    }\n    return ($l_open\
    \ + $r_open == $l_close + $r_close) ? 'Yes' : 'No';\n}", "    my($left, $right)\
    \ = @$lst;\n    my($balance) = 0;\n    my($left_good) = 0;\n    foreach my $c\
    \ (split(//, $left)) {\n        $balance += $c eq '(' ? 1 : -1;\n        $left_good\
    \ = 1 if $balance > 0;\n    }\n    return \"No\" if $balance < 0;\n    $balance\
    \ = 0;\n    foreach my $c (split(//, $right)) {\n        $balance += $c eq '('\
    \ ? 1 : -1;\n        return \"Yes\" if $balance < 0 && $left_good;\n    }\n  \
    \  return \"No\";\n}", "    my $s = 0;\n    foreach my $str (@$lst) {\n      \
    \  $s += $str =~ tr/\\(/\\(/ - $str =~ tr/\\)/\\)/;\n        return 'No' if $s\
    \ < 0;\n    }\n    $s ? 'No' : 'Yes';\n}", "    my $s = join('', @$lst);\n   \
    \ my $c = 0;\n    while ($s =~ /\\(/g) {\n        ++$c;\n    }\n    while ($s\
    \ =~ /\\)/g) {\n        --$c;\n    }\n    return $c == 0 ? 'Yes' : 'No';\n}",
  "    my $str1 = $$lst[0];\n    my $str2 = $$lst[1];\n    my $i;\n    my $j;\n  \
    \  my $temp_str;\n    my $num1 = 0;\n    my $num2 = 0;\n    for ($i = 0; $i <\
    \ length($str1); $i++) {\n        $temp_str = substr($str1, 0, $i) . $str2 . substr($str1,\
    \ $i);\n        $num1 = 0;\n        for ($j = 0; $j < length($temp_str); $j++)\
    \ {\n            if (substr($temp_str, $j, 1) eq '(') {\n                $num1++;\n\
    \            }\n            elsif (substr($temp_str, $j, 1) eq ')') {\n      \
    \          $num1--;\n            }\n            if ($num1 < 0) {\n           \
    \     last;\n            }\n        }\n        if ($num1 == 0) {\n           \
    \ return 'Yes';\n        }\n    }\n    for ($i = 0; $i < length($str2); $i++)\
    \ {\n        $temp_str = substr($str2, 0, $i) . $str1 . substr($str2, $i);\n \
    \       $num2 = 0;\n        for ($j = 0; $j < length($temp_str); $j++) {\n   \
    \         if (substr($temp_str, $j, 1) eq '(') {\n                $num2++;\n \
    \           }\n            elsif (substr($temp_str, $j, 1) eq ')') {\n       \
    \         $num2--;\n            }\n            if ($num2 < 0) {\n            \
    \    last;\n            }\n        }\n        if ($num2 == 0) {\n            return\
    \ 'Yes';\n        }\n    }\n    return 'No';\n}\nprint(match_parens(['()(', ')']));\n\
    print(\"\\n\");\nprint(match_parens([')', ')']));\nprint(\"\\n\");\nprint(match_parens(['(((()))(()',\
    \ ')']));\nprint(\"\\n\");\nprint(match", "    my $str1 = $lst->[0];\n    my $str2\
    \ = $lst->[1];\n    my @cnt1 = (0, 0);\n    my @cnt2 = (0, 0);\n    for my $c\
    \ (split '', $str1) {\n        if ($c eq '(') {\n            $cnt1[0]++;\n   \
    \     } else {\n            $cnt1[1]++;\n        }\n    }\n    for my $c (split\
    \ '', $str2) {\n        if ($c eq '(') {\n            $cnt2[0]++;\n        } else\
    \ {\n            $cnt2[1]++;\n        }\n    }\n    if ($cnt1[0] == $cnt1[1] ||\
    \ $cnt2[0] == $cnt2[1]) {\n        return 'Yes';\n    } elsif ($cnt1[0] < $cnt1[1]\
    \ && $cnt2[0] < $cnt2[1]) {\n        return 'No';\n    } else {\n        if ($cnt1[0]\
    \ > $cnt1[1]) {\n            return $cnt2[0] - $cnt2[1] > $cnt1[0] - $cnt1[1]\
    \ ? 'No' : 'Yes';\n        } else {\n            return $cnt1[0] - $cnt1[1] >\
    \ $cnt2[0] - $cnt2[1] ? 'No' : 'Yes';\n        }\n    }\n}", "    my($good_count,\
    \ $bad_count) = (0, 0);\n    for my $s (@$lst) {\n        my $bads = $s =~ tr/\\\
    )//;\n        my $goods = $s =~ tr/\\(//;\n        if ($bads > $goods) {\n   \
    \         return 'No' if $good_count == 0;\n            $good_count--;\n     \
    \   }\n        else {\n            $good_count += $goods - $bads;\n        }\n\
    \    }\n    return $good_count ? 'No' : 'Yes';\n}", "    my $s1 = $lst->[0];\n\
    \    my $s2 = $lst->[1];\n    my $s1_pcount = ($s1 =~ tr/\\(/\\(/);\n    my $s2_pcount\
    \ = ($s2 =~ tr/\\(/\\(/);\n    if ($s1_pcount == $s2_pcount) {\n        return\
    \ 'Yes';\n    } else {\n        return 'No';\n    }\n}"]
stop_tokens:
- "\nsub"
- "\n#"
- "\n\n"
