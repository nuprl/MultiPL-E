name: HumanEval_112_reverse_delete
language: pl
prompt: "# Task\n# We are given two strings s and c, you have to deleted all the characters\
  \ in s that are equal to any character in c\n# then check if the result string is\
  \ palindrome.\n# A string is called palindrome if it reads the same backward as\
  \ forward.\n# You should return a tuple containing the result string and True/False\
  \ for the check.\n# Example\n# For s = \"abcde\", c = \"ae\", the result should\
  \ be ('bcd',False)\n# For s = \"abcdef\", c = \"b\"  the result should be ('acdef',False)\n\
  # For s = \"abcdedcba\", c = \"ab\", the result should be ('cdedc',True)\nsub reverse_delete\
  \ {\n    my($s, $c) = @_;\n"
tests: "use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&reverse_delete;\n\
  \        if(eq_deeply($candidate->(\"abcde\", \"ae\"),[\"bcd\", \"\"])) {\n    \
  \    print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"\
  abcdef\", \"b\"),[\"acdef\", \"\"])) {\n        print \"ok!\" }else{\n        exit\
  \ 1;\n        }\n        if(eq_deeply($candidate->(\"abcdedcba\", \"ab\"),[\"cdedc\"\
  , 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"\
  dwik\", \"w\"),[\"dik\", \"\"])) {\n        print \"ok!\" }else{\n        exit 1;\n\
  \        }\n        if(eq_deeply($candidate->(\"a\", \"a\"),[\"\", 1])) {\n    \
  \    print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"\
  abcdedcba\", \"\"),[\"abcdedcba\", 1])) {\n        print \"ok!\" }else{\n      \
  \  exit 1;\n        }\n        if(eq_deeply($candidate->(\"abcdedcba\", \"v\"),[\"\
  abcdedcba\", 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
  \        if(eq_deeply($candidate->(\"vabba\", \"v\"),[\"abba\", 1])) {\n       \
  \ print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"\
  mamma\", \"mia\"),[\"\", 1])) {\n        print \"ok!\" }else{\n        exit 1;\n\
  \        }\n}\n\ntesthumaneval();"
completions: ["    chomp($s);\n    chomp($c);\n    my %hash = map { $_ => 1 } split\
    \ //, $c;\n    my $new_s = join \"\", grep { not exists $hash{$_} } split //,\
    \ $s;\n    my $is_palindrome = $new_s eq reverse $new_s;\n    return $new_s, $is_palindrome;\n\
    }\nmy($s, $c) = (\"abcde\", \"ae\");\nmy ($new_s, $is_palindrome) = reverse_delete($s,\
    \ $c);\nprint \"$new_s $is_palindrome\\n\";", "    my $c_re = join('|', split\
    \ //, $c);\n    my $re = qr/$c_re/;\n    my $tmp = $s;\n    $tmp =~ s/$re//g;\n\
    \    my $res = ($tmp eq reverse $tmp) ? 'True' : 'False';\n    return join(',',\
    \ $tmp, $res);\n}", "    my @rev = split //, $s;\n    $s =~ s/[$c]//g;\n    my\
    \ $is_palindrome = join(\"\", reverse @rev) eq $s;\n    return ($s, $is_palindrome);\n\
    }", "    my %c = map { $_ => 1 } split '', $c;\n    $s =~ s/[$c]//g;\n    my $rev\
    \ = reverse $s;\n    return ($s, $s eq $rev);\n}", "    chomp($s);\n    chomp($c);\n\
    \    my @s = split('', $s);\n    my @c = split('', $c);\n    my @new_s;\n    for\
    \ (my $i = 0; $i < scalar @s; $i++) {\n        my $match = 0;\n        for (my\
    \ $j = 0; $j < scalar @c; $j++) {\n            if ($s[$i] eq $c[$j]) {\n     \
    \           $match = 1;\n            }\n        }\n        if ($match == 0) {\n\
    \            push(@new_s, $s[$i]);\n        }\n    }\n    my $result = join('',\
    \ @new_s);\n    my $length = scalar @new_s;\n    my $reversed = reverse $result;\n\
    \    my $output = ($result eq $reversed) ? 'True' : 'False';\n    return ($result,\
    \ $output);\n}", "    my $new_s = $s;\n    $new_s =~ s/$c//g;\n    if ($new_s\
    \ eq reverse $new_s) {\n        return ($new_s, 1);\n    } else {\n        return\
    \ ($new_s, 0);\n    }\n}", "    $s =~ s/[$c]//g;\n    return [$s, $s eq reverse\
    \ $s];\n}", "    my @s = split(//, $s);\n    my @c = split(//, $c);\n    my %h;\n\
    \    for my $c (@c) {\n        $h{$c} = 1;\n    }\n    for my $i (0..$#s) {\n\
    \        if (defined $h{$s[$i]}) {\n            splice(@s, $i, 1);\n         \
    \   $i--;\n        }\n    }\n    return (join('', @s), $s eq reverse($s));\n}",
  "    my %h;\n    foreach my $ch (split //, $c) {\n        $h{$ch} = 1;\n    }\n\
    \    my $s1 = join '', grep {!$h{$_}} split //, $s;\n    return ($s1, $s1 eq reverse\
    \ $s1);\n}", "    my $r = \"\";\n    my $c_letters = {};\n    for my $l (split(//,\
    \ $c)) {\n        $c_letters->{$l} = 1;\n    }\n    for my $l (split(//, $s))\
    \ {\n        $r .= $l unless $c_letters->{$l};\n    }\n    return ($r, $r eq reverse($r));\n\
    }\nprint \"reverse_delete:\\n\";\nprint Dumper reverse_delete(\"abcde\", \"ae\"\
    );\nprint Dumper reverse_delete(\"abcdef\", \"b\");\nprint Dumper reverse_delete(\"\
    abcdedcba\", \"ab\");\nprint Dumper reverse_delete(\"abcdedcba\", \"ab\");\nprint\
    \ Dumper reverse_delete(\"abcdedcba\", \"ab\");", "    my $a = $s;\n    for(split\
    \ '', $c) {\n        $a =~ s/$_//g;\n    }\n    return ($a, $a eq scalar reverse\
    \ $a);\n}", "    $s =~ s/$c//g;\n    return \"($s,False)\" if $s ne reverse $s;\n\
    \    return \"($s,True)\";\n}\nprint reverse_delete \"abcde\", \"ae\";\nprint\
    \ reverse_delete \"abcdef\", \"b\";\nprint reverse_delete \"abcdedcba\", \"ab\"\
    ;", "    my @list = split //, $s;\n    my %hash = map {$_ => 1} split //, $c;\n\
    \    my @r = reverse @list;\n    @list = grep {!$hash{$_}} @list;\n    @r = grep\
    \ {!$hash{$_}} @r;\n    my $res = (join '', @list) eq (join '', @r);\n    return\
    \ (join '', @list), $res;\n}", "    my @s = split //, $s;\n    my %c = map { $_\
    \ => 1 } split //, $c;\n    my @stack;\n    for my $char (@s) {\n        if (exists\
    \ $c{$char}) {\n            next;\n        }\n        else {\n            push\
    \ @stack, $char;\n        }\n    }\n    my $flag = 0;\n    for (my $i = 0; $i\
    \ < (scalar @stack / 2); $i++) {\n        if ($stack[$i] ne $stack[-($i + 1)])\
    \ {\n            $flag = 1;\n            last;\n        }\n    }\n    return (join\
    \ \"\", @stack, $flag);\n}", "    my $rc = reverse($c);\n    my $tmp = $s;\n \
    \   for my $i (0..length($rc) - 1) {\n        $tmp =~ s/$rc->[$i]//g;\n    }\n\
    \    return ($tmp, $tmp eq reverse($tmp))\n}", "    my @s = split //, $s;\n  \
    \  my @c = split //, $c;\n    my %h; @h{@c} = ();\n    my $rev;\n    foreach my\
    \ $i (reverse @s) {\n        $rev .= $i unless exists $h{$i};\n    }\n    return\
    \ ($rev, $rev eq reverse $rev);\n}", "    my %h = map { $_ => 1 } split //, $c;\n\
    \    my $res = '';\n    for my $ch (split //, $s) {\n        $res .= $ch unless\
    \ $h{$ch};\n    }\n    return ($res, $res eq reverse $res)\n}", "    my $h = {};\n\
    \    map { $h->{$_} = 1 } split(//, $c);\n    my $d = '';\n    map { $d .= $_\
    \ unless $h->{$_} } split(//, $s);\n    $d = reverse $d;\n    return($d, $d eq\
    \ $s);\n}", "    my $t = $s;\n    my $new_string = \"\";\n    for my $char (split\
    \ //, $s) {\n        if ($c !~ /$char/) {\n            $new_string .= $char;\n\
    \        }\n    }\n    return $new_string;\n}", "    my %hash = map { $_ => undef\
    \ } split(//, $c);\n    $s =~ s/[$c]//g;\n    my $reverse = reverse $s;\n    return\
    \ ($s, $s eq $reverse);\n}"]
stop_tokens:
- "\nsub"
- "\n#"
- "\n\n"
