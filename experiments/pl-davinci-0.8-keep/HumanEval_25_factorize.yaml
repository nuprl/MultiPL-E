name: HumanEval_25_factorize
language: pl
prompt: "# Return list of prime factors of given integer in the order from smallest\
  \ to largest.\n# Each of the factors should be listed number of times corresponding\
  \ to how many times it appeares in factorization.\n# Input number should be equal\
  \ to the product of all factors\n# >>> factorize(8)\n# [2, 2, 2]\n# >>> factorize(25)\n\
  # [5, 5]\n# >>> factorize(70)\n# [2, 5, 7]\nsub factorize {\n    my($n) = @_;\n"
tests: "use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&factorize;\n\
  \        if(eq_deeply($candidate->(2),[2])) {\n        print \"ok!\" }else{\n  \
  \      exit 1;\n        }\n        if(eq_deeply($candidate->(4),[2, 2])) {\n   \
  \     print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(8),[2,\
  \ 2, 2])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(57),[3,\
  \ 19])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(3249),[3,\
  \ 3, 19, 19])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n   \
  \     if(eq_deeply($candidate->(185193),[3, 3, 3, 19, 19, 19])) {\n        print\
  \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(20577),[3,\
  \ 19, 19, 19])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n  \
  \      if(eq_deeply($candidate->(18),[2, 3, 3])) {\n        print \"ok!\" }else{\n\
  \        exit 1;\n        }\n}\n\ntesthumaneval();"
completions: ["    my @result;\n    my $i = 2;\n    my $sq = sqrt($n);\n    while\
    \ ($i <= $sq) {\n        if ($n % $i == 0) {\n            push @result, $i;\n\
    \            $n /= $i;\n            $sq = sqrt($n);\n        } else {\n      \
    \      $i++;\n        }\n    }\n    push @result, $n;\n    return @result;\n}",
  "    my @res;\n    # Get the prime factors\n    foreach my $p (@primes) {\n    \
    \    while($n % $p == 0) {\n            push @res, $p;\n            $n /= $p;\n\
    \        }\n    }\n    return @res;\n}", "    my @res;\n    while ($n % 2 == 0)\
    \ {\n        push @res, 2;\n        $n /= 2;\n    }\n    for (my $i = 3; $i <\
    \ $n; $i += 2) {\n        while ($n % $i == 0) {\n            push @res, $i;\n\
    \            $n /= $i;\n        }\n    }\n    return @res;\n}", "    my @result;\n\
    \    my $f = 2;\n    while ($n > 1) {\n        if ($n % $f == 0) {\n         \
    \   $n /= $f;\n            push @result, $f;\n        } else {\n            $f++;\n\
    \        }\n    }\n    return @result;\n}", "    my @res;\n    for my $factor\
    \ (2 .. $n) {\n        while($n % $factor == 0) {\n            push @res, $factor;\n\
    \            $n /= $factor;\n        }\n    }\n    return @res;\n}", "    my @factors;\n\
    \    if ($n<0) {\n        return factorize(-$n);\n    }\n    elsif ($n==0) {\n\
    \        return (1);\n    }\n    while ($n % 2 == 0) {\n        push @factors,\
    \ 2;\n        $n /= 2;\n    }\n    my $i = 3;\n    while ($i <= $n) {\n      \
    \  if ($n % $i == 0) {\n            push @factors, $i;\n            $n /= $i;\n\
    \        }\n        else {\n            $i+=2;\n        }\n    }\n    return @factors;\n\
    }", "    my @res;\n    for my $f (2..$n) {\n        if ($n % $f == 0) {\n    \
    \        push @res, $f;\n            $n /= $f;\n            redo;\n        }\n\
    \    }\n    return @res;\n}", "    my @res;\n    while ($n > 1) {\n        for\
    \ my $prime (@primes) {\n            if ($n % $prime == 0) {\n               \
    \ push @res, $prime;\n                $n /= $prime;\n                last;\n \
    \           }\n        }\n    }\n    return @res;\n}", "    # WRITE YOUR CODE\
    \ HERE\n}", "    my @factors;\n    if (is_prime($n)) {\n        return ($n);\n\
    \    }\n    my $d = find_divisor($n);\n    return factorize($d), factorize($n/$d);\n\
    }", "    my @res;\n    while ($n % 2 == 0) {\n        push @res, 2;\n        $n\
    \ /= 2;\n    }\n    my $sqrt = sqrt($n);\n    my $factor = 3;\n    while ($n >\
    \ 1) {\n        if ($n % $factor == 0) {\n            push @res, $factor;\n  \
    \          $n /= $factor;\n        } else {\n            $factor += 2;\n     \
    \   }\n    }\n    return @res;\n}", "    die 'error: $n must be a positive integer'\
    \ unless $n =~ /^\\d+$/ && $n > 0;\n    my @prime_factors;\n    my $divisor =\
    \ 2;\n    while ($n > 1) {\n        my $exponent = 0;\n        while ($n % $divisor\
    \ == 0) {\n            $n /= $divisor;\n            $exponent++;\n        }\n\
    \        push @prime_factors, ($divisor) x $exponent if $exponent;\n        $divisor++;\n\
    \    }\n    return @prime_factors;\n}", "    my @factors;\n    foreach my $i (2..$n)\
    \ {\n        if ($n % $i == 0) {\n            push @factors, $i;\n           \
    \ $n /= $i;\n            redo;\n        }\n    }\n    return @factors;\n}", " \
    \   my @result;\n    for (my $i = 2; $i <= $n; $i++) {\n        while ($n % $i\
    \ == 0) {\n            push @result, $i;\n            $n /= $i;\n        }\n \
    \   }\n    return @result;\n}", "    my @factors;\n    foreach (1..$n) {\n   \
    \     if ($n % $_ == 0) {\n            push @factors, $_;\n        }\n    }\n\
    \    return @factors;\n}", "    my @factors;\n    foreach my $factor ( 2 .. $n\
    \ ) {\n        while ( $n % $factor == 0 ) {\n            push @factors, $factor;\n\
    \            $n /= $factor;\n        }\n    }\n    @factors;\n}", "    my @result;\n\
    \    while (1) {\n        my $smallest_prime = smallest_prime_factor($n);\n  \
    \      $n /= $smallest_prime;\n        push @result, $smallest_prime;\n      \
    \  last if $n == 1;\n    }\n    return @result;\n}", "    my @factors;\n    while\
    \ ($n % 2 == 0) {\n        push @factors, 2;\n        $n /= 2;\n    }\n    my\
    \ $p = 3;\n    while ($n != 1) {\n        while ($n % $p == 0) {\n           \
    \ push @factors, $p;\n            $n /= $p;\n        }\n        $p += 2;\n   \
    \ }\n    return @factors;\n}", "    my $r = [];\n    my $d = 2;\n    while ($n\
    \ > 1) {\n        while ($n % $d == 0) {\n            push @$r, $d;\n        \
    \    $n /= $d;\n        }\n        $d += 1;\n    }\n    return $r;\n}", "    #\
    \ your code here\n}"]
stop_tokens:
- "\nsub"
- "\n#"
- "\n\n"
