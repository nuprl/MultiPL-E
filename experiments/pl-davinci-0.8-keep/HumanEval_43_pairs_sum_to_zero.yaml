name: HumanEval_43_pairs_sum_to_zero
language: pl
prompt: "# pairs_sum_to_zero takes a list of integers as an input.\n# it returns True\
  \ if there are two distinct elements in the list that\n# sum to zero, and False\
  \ otherwise.\n# >>> pairs_sum_to_zero([1, 3, 5, 0])\n# False\n# >>> pairs_sum_to_zero([1,\
  \ 3, -2, 1])\n# False\n# >>> pairs_sum_to_zero([1, 2, 3, 7])\n# False\n# >>> pairs_sum_to_zero([2,\
  \ 4, -5, 3, 5, 7])\n# True\n# >>> pairs_sum_to_zero([1])\n# False\nsub pairs_sum_to_zero\
  \ {\n    my($l) = @_;\n"
tests: "use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&pairs_sum_to_zero;\n\
  \        if(eq_deeply($candidate->([1, 3, 5, 0]),\"\")) {\n        print \"ok!\"\
  \ }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1, 3, -2,\
  \ 1]),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
  \   if(eq_deeply($candidate->([1, 2, 3, 7]),\"\")) {\n        print \"ok!\" }else{\n\
  \        exit 1;\n        }\n        if(eq_deeply($candidate->([2, 4, -5, 3, 5,\
  \ 7]),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1]),\"\
  \")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([-3,\
  \ 9, -1, 3, 2, 30]),1)) {\n        print \"ok!\" }else{\n        exit 1;\n     \
  \   }\n        if(eq_deeply($candidate->([-3, 9, -1, 3, 2, 31]),1)) {\n        print\
  \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([-3,\
  \ 9, -1, 4, 2, 30]),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n  \
  \      }\n        if(eq_deeply($candidate->([-3, 9, -1, 4, 2, 31]),\"\")) {\n  \
  \      print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
completions: ["    my %count;\n    foreach my $elem (@$l) {\n        $count{$elem}++;\n\
    \    }\n    foreach my $elem (@$l) {\n        if ($elem == 0 && $count{$elem}\
    \ >= 2) {\n            return 1;\n        }\n        elsif ($elem != 0 && $count{-$elem}\
    \ >= 1) {\n            return 1;\n        }\n    }\n    return 0;\n}", "    #\
    \ your code here\n}", "    my %table;\n    foreach my $n (@$l) {\n        if (exists\
    \ $table{$n}) {\n            return 1;\n        } else {\n            $table{-$n}\
    \ = 1;\n        }\n    }\n    return 0;\n}", '    # TODO: fill this in', "   \
    \ my $len = scalar(@$l);\n    for(my $i = 0; $i < $len; $i++){\n        for(my\
    \ $j = $i + 1; $j < $len; $j++){\n            if(($l->[$i] + $l->[$j]) == 0){\n\
    \                return True;\n            }\n        }\n    }\n    return False;\n\
    }", "    my %hash;\n    # check if input is a proper list\n    if(ref($l) ne 'ARRAY')\
    \ {\n        return 'Not a list'\n    }\n    # check if input is empty\n    if(@$l\
    \ == 0) {\n        return 0;\n    }\n    # populate hash with data from input\
    \ list\n    for my $num (@$l) {\n        $hash{$num}++;\n    }\n    # iterate\
    \ over the keys of the hash\n    for my $key (keys %hash) {\n        # check if\
    \ the current key is 0\n        if($key == 0) {\n            # check if the value\
    \ associated with the key is greater than 1\n            if($hash{$key} > 1) {\n\
    \                return 1;\n            }\n        }\n        # check if the current\
    \ key is non-zero\n        if($key != 0) {\n            # look for the negative\
    \ of the current key\n            if(exists $hash{-$key}) {\n                return\
    \ 1;\n            }\n        }\n    }\n    return 0;\n}", "    for (my $i = 0;\
    \ $i < scalar(@$l); $i++) {\n        for (my $j = $i + 1; $j < scalar(@$l); $j++)\
    \ {\n            if ($l->[$i] + $l->[$j] == 0) {\n                return 1;\n\
    \            }\n        }\n    }\n    return 0;\n}", "    for(my $i = 0; $i <\
    \ scalar(@$l) - 1; $i++){\n        for(my $j = $i + 1; $j < scalar(@$l); $j++){\n\
    \            if($l->[$i] + $l->[$j] == 0){\n                return 1;\n      \
    \      }\n        }\n    }\n    return 0;\n}", "    my %numbers;\n    for my $num\
    \ (@$l) {\n        $numbers{$num}++;\n    }\n    for my $num (@$l) {\n       \
    \ if ($numbers{$num} > 0 && $numbers{-$num} > 0) {\n            return 1;\n  \
    \      }\n    }\n    return 0;\n}", "    my @l = @$l;\n    my %h;\n    for my\
    \ $x (@l) {\n        return 1 if defined $h{-$x};\n        $h{$x} = 1;\n    }\n\
    \    return 0;\n}", "    my %hash = ();\n    foreach my $e (@$l) {\n\t# We have\
    \ $e and we want to find -$e\n\tmy $want = -$e;\n\t# If we've already seen $want,\
    \ we're done.\n\tif (exists $hash{$want}) {\n\t    return 1;\n\t}\n\t# Otherwise,\
    \ remember that we've seen $e\n\t$hash{$e} = 1;\n    }\n    # If we get here,\
    \ we haven't found what we want.\n    return 0;\n}", "    $l = [@$l];\n    for\
    \ (my $i = 0; $i < @$l; $i++) {\n        for (my $j = $i + 1; $j < @$l; $j++)\
    \ {\n            if ($l->[$i] + $l->[$j] == 0) {\n                return 1;\n\
    \            }\n        }\n    }\n    return 0;\n}", "    if (scalar(@$l) < 2)\
    \ {\n        return 0;\n    }\n    my %seen;\n    foreach my $x (@$l) {\n    \
    \    if (exists $seen{-$x}) {\n            return 1;\n        }\n        $seen{$x}\
    \ = 1;\n    }\n    return 0;\n}", "    my %set;\n    foreach my $element (@$l)\
    \ {\n        if ( exists $set{$element} ) {\n            return True;\n      \
    \  } else {\n            $set{-$element} = True;\n        }\n    }\n    return\
    \ False;\n}", "    return 0;\n}", "    # Your code here\n    my $length = scalar\
    \ @$l;\n    my $i = 0;\n    my $j = 0;\n    while ($i < $length) {\n        while\
    \ ($j < $length) {\n            if ($i != $j && $l->[$i] + $l->[$j] == 0) {\n\
    \                return 1;\n            }\n            $j++;\n        }\n    \
    \    $i++;\n        $j = 0;\n    }\n    return 0;\n}", "    my $results = {};\n\
    \    foreach my $e (@$l) {\n        if(exists($results->{-$e})) {\n          \
    \  return 1;\n        } else {\n            $results->{$e} = 1;\n        }\n \
    \   }\n    return 0;\n}", "    if (@$l == 0 || @$l == 1) {\n        return 0;\n\
    \    }\n    #--BEGIN CODE--\n    \n    #--END CODE--\n}", "    # ...\n}", "  \
    \  my $sum = 0;\n    #for my $i (0 .. $#{$l}) {\n    #    for my $j ($i+1 .. $#{$l})\
    \ {\n    #        if ($l->[$i] + $l->[$j] == 0) {\n    #            return 1;\n\
    \    #        }\n    #    }\n    #}\n    return 0;\n}"]
stop_tokens:
- "\nsub"
- "\n#"
- "\n\n"
