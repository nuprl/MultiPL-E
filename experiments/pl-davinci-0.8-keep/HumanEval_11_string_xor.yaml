name: HumanEval_11_string_xor
language: pl
prompt: "# Input are two strings a and b consisting only of 1s and 0s.\n# Perform\
  \ binary XOR on these inputs and return result also as a string.\n# >>> string_xor('010',\
  \ '110')\n# '100'\nsub string_xor {\n    my($a, $b) = @_;\n"
tests: "use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&string_xor;\n\
  \        if(eq_deeply($candidate->(\"111000\", \"101010\"),\"010010\")) {\n    \
  \    print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"\
  1\", \"1\"),\"0\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
  \        if(eq_deeply($candidate->(\"0101\", \"0000\"),\"0101\")) {\n        print\
  \ \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
completions: ["    my $c = (OctetString->new($a) ^ OctetString->new($b))->as_string;\n\
    \    return $c;\n}", "    my $len = length($a);\n    my $c = '';\n    for (my\
    \ $i = 0; $i < $len; $i++) {\n        $c .= (substr($a, $i, 1) == substr($b, $i,\
    \ 1)) ? '0' : '1';\n    }\n    return $c;\n}", "    my $result = '';\n    for\
    \ (my $i = 0; $i < length($a); $i++) {\n        if (substr($a, $i, 1) eq substr($b,\
    \ $i, 1)) {\n            $result .= '0';\n        } else {\n            $result\
    \ .= '1';\n        }\n    }\n    return $result;\n}", "    return undef unless(defined($a)\
    \ && defined($b));\n    return undef unless(length($a) == length($b));\n    my\
    \ $ret = '';\n    foreach my $pos (0..length($a)-1) {\n        my $bit1 = substr($a,\
    \ $pos, 1);\n        my $bit2 = substr($b, $pos, 1);\n        $ret .= $bit1 ^\
    \ $bit2;\n    }\n    return $ret;\n}", "    assert('[' . $a . '] is not a valid\
    \ binary string.')\n        if($a !~ /^[01]+$/);\n    assert('[' . $b . '] is\
    \ not a valid binary string.')\n        if($b !~ /^[01]+$/);\n    my $len = _max_length($a,\
    \ $b);\n    $a = '0' x ($len - length($a)) . $a;\n    $b = '0' x ($len - length($b))\
    \ . $b;\n    my $result = '';\n    for(my $i = 0; $i < $len; $i++) {\n       \
    \ my $xor = $a->[$i] ^ $b->[$i];\n        $result .= $xor;\n    }\n    return\
    \ $result;\n}", "    my $res = '';\n    $res .= $_ > $a ^ $_ > $b for 1..length\
    \ $a;\n    return $res;\n}", "    my $res = '';\n    for my $i (0..length($a)-1)\
    \ {\n        $res .= substr($a, $i, 1) ^ substr($b, $i, 1);\n    }\n    return\
    \ $res;\n}", '    my $c = $a ^ $b;', "    my @a = split(//, $a);\n    my @b =\
    \ split(//, $b);\n    my @xor;\n    for my $x (0 .. $#a) {\n        $xor[$x] =\
    \ $a[$x] ^ $b[$x];\n    }\n    return join(\"\", @xor);\n}", "    length($a) ==\
    \ length($b) or croak \"mismatched lengths\";\n    my $res = \"\";\n    my $idx\
    \ = 0;\n    for my $len (length($a) .. -1) {\n        $res .= substr($a, $idx,\
    \ 1) ^ substr($b, $idx, 1);\n        $idx++;\n    }\n    return $res;\n}", " \
    \   my($c, $d);\n    my($i);\n    for($i = 0; $i < length($a); $i++) {\n     \
    \   $c .= (((substr($a, $i, 1) eq '1') && (substr($b, $i, 1) eq '0')) ||\n   \
    \            ((substr($a, $i, 1) eq '0') && (substr($b, $i, 1) eq '1'))) ? '1'\
    \ : '0';\n    }\n    for($i = 0; $i < length($b); $i++) {\n        $d .= (((substr($a,\
    \ $i, 1) eq '1') && (substr($b, $i, 1) eq '0')) ||\n               ((substr($a,\
    \ $i, 1) eq '0') && (substr($b, $i, 1) eq '1'))) ? '1' : '0';\n    }\n    if($c\
    \ ne $d) {\n        print \"error in string_xor\\n\";\n    }\n    return $c;\n\
    }", "    my @a = split('', $a);\n    my @b = split('', $b);\n    my @c;\n    if\
    \ (@a != @b) {\n        die \"string_xor: a and b have different length.\";\n\
    \    }\n    my $i = 0;\n    for $i (0..$#a) {\n        push @c, ($a[$i] == $b[$i])\
    \ ? 0 : 1;\n    }\n    return join('', @c);\n}", "    my $r = '';\n    my $bl\
    \ = int(length($a) / 8);\n    my $al = int(length($b) / 8);\n    my $cl = ($bl\
    \ > $al) ? $bl : $al;\n    foreach my $x (1 .. $cl) {\n        my $a = ord(substr($_[0],\
    \ -8));\n        my $b = ord(substr($_[1], -8));\n        $r = chr($a ^ $b) .\
    \ $r;\n    }\n    return $r;\n}", "    my $length = length($a);\n    my $output\
    \ = \"\";\n    for (my $i = 0; $i < $length; $i++) {\n        $output .= (substr($a,\
    \ $i, 1) ^ substr($b, $i, 1));\n    }\n    return $output;\n}", "    my $length\
    \ = $a > $b ? length($a) : length($b);\n    my @a = split(//, $a);\n    my @b\
    \ = split(//, $b);\n    my @result;\n    while (@a || @b) {\n        my $a = @a\
    \ ? shift(@a) : 0;\n        my $b = @b ? shift(@b) : 0;\n        push(@result,\
    \ ((($a ^ $b) ? 1 : 0) ? '1' : '0'));\n    }\n    return join('', @result);\n}",
  "    my $r = '';\n    my $i = 0;\n    my $l = $b;\n    $l = length($a) if (length($a)\
    \ > length($b));\n    for ($i = 0; $i < $l; $i++) {\n        $r .= (substr($a,\
    \ $i, 1) ^ substr($b, $i, 1));\n    }\n    return $r;\n}", '    my($i, $len, $min_len,
    $max_len, $xor);', "    my $xor = $a ^ $b;\n    my $result = '';\n    my $i =\
    \ 0;\n    while ($i <= length($xor)) {\n        $result .= substr($xor, $i, 1);\n\
    \        $i++;\n    }\n    return $result;\n}", "    my $res = '';\n    for (my\
    \ $i = 0; $i < length($a); $i++) {\n        $res .= (substr($a, $i, 1) ^ substr($b,\
    \ $i, 1)) ? 1 : 0;\n    }\n    return $res;\n}", "    my($aa, $bb, $cc, $xor);\n\
    \    ($aa, $bb) = map { string_to_binary($_) } ($a, $b);\n    $cc = '';\n    while\
    \ ($aa || $bb) {\n        $xor = substr($aa, -1, 1) ^ substr($bb, -1, 1);\n  \
    \      $cc = ($xor ? '1' : '0') . $cc;\n        $aa = substr($aa, 0, -1);\n  \
    \      $bb = substr($bb, 0, -1);\n    }\n    return binary_to_string($cc);\n}"]
stop_tokens:
- "\nsub"
- "\n#"
- "\n\n"
