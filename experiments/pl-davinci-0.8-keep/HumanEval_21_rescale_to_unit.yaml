name: HumanEval_21_rescale_to_unit
language: pl
prompt: "# Given list of numbers (of at least two elements), apply a linear transform\
  \ to that list,\n# such that the smallest number will become 0 and the largest will\
  \ become 1\n# >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n# [0.0, 0.25, 0.5,\
  \ 0.75, 1.0]\nsub rescale_to_unit {\n    my($numbers) = @_;\n"
tests: "use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&rescale_to_unit;\n\
  \        if(eq_deeply($candidate->([2.0, 49.9]),[0.0, 1.0])) {\n        print \"\
  ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([100.0,\
  \ 49.9]),[1.0, 0.0])) {\n        print \"ok!\" }else{\n        exit 1;\n       \
  \ }\n        if(eq_deeply($candidate->([1.0, 2.0, 3.0, 4.0, 5.0]),[0.0, 0.25, 0.5,\
  \ 0.75, 1.0])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n   \
  \     if(eq_deeply($candidate->([2.0, 1.0, 5.0, 3.0, 4.0]),[0.25, 0.0, 1.0, 0.5,\
  \ 0.75])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([12.0,\
  \ 11.0, 15.0, 13.0, 14.0]),[0.25, 0.0, 1.0, 0.5, 0.75])) {\n        print \"ok!\"\
  \ }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
completions: ["    my($min, $max);\n    for my $number (@$numbers) {\n        if (!defined($min)\
    \ || $number < $min) {\n            $min = $number;\n        }\n        if (!defined($max)\
    \ || $number > $max) {\n            $max = $number;\n        }\n    }\n    my\
    \ $diff = $max - $min;\n    return [ map { ($_ - $min) / $diff } @$numbers ];\n\
    }", "    my $min = min(@$numbers);\n    my $max = max(@$numbers);\n    my $range\
    \ = $max - $min;\n    return map { ($_ - $min) / $range } @$numbers;\n}", "  \
    \  die \"Rescale: expect an array ref\" unless ref($numbers) eq 'ARRAY';\n   \
    \ die \"Rescale: expect at least two numbers\" unless @$numbers >= 2;\n    my\
    \ $min = min @$numbers;\n    my $max = max @$numbers;\n    my $range = $max -\
    \ $min;\n    return [map {($_ - $min) / $range} @$numbers];\n}", "    my($min,\
    \ $max) = (List::Util::min(@$numbers), List::Util::max(@$numbers));\n    my($number_range)\
    \ = $max - $min;\n    my(@rescaled) = map {($_ - $min) / $number_range} @$numbers;\n\
    \    return @rescaled;\n}", "    my($min) = List::Util::min(@$numbers);\n    my($max)\
    \ = List::Util::max(@$numbers);\n    if($min == $max) {\n        return map {\
    \ 0.5 } @$numbers;\n    }\n    return map { ($_ - $min) / ($max - $min) } @$numbers;\n\
    }", "    my $min = min(@$numbers);\n    my $max = max(@$numbers);\n    my $span\
    \ = $max - $min;\n    my @result = map { ($_ - $min) / $span } @$numbers;\n  \
    \  return @result;\n}", "    my $min = min(@$numbers);\n    my $max = max(@$numbers);\n\
    \    my $range = $max - $min;\n    my @rescaled = map { ($_ - $min) / $range }\
    \ @$numbers;\n    return @rescaled;\n}", "    die if (@$numbers < 2);\n    my($min,\
    \ $max) = (min(@$numbers), max(@$numbers));\n    my($scale) = 1.0 / ($max - $min);\n\
    \    return [map {($_ - $min) * $scale} @$numbers];\n}", "    my $min = min($numbers);\n\
    \    my $max = max($numbers);\n    my $delta = $max - $min;\n    if ($delta !=\
    \ 0) {\n        return map {($_ - $min) / $delta} @$numbers;\n    } else {\n \
    \       my $mid = int(scalar(@$numbers) / 2);\n        return map {$_ == $mid\
    \ ? 1 : 0} 0..$#$numbers;\n    }\n}", "    my $min = $numbers->[0];\n    my $max\
    \ = $numbers->[0];\n    for my $n (@$numbers) {\n        $min = $n if $n < $min;\n\
    \        $max = $n if $n > $max;\n    }\n    my $range = $max - $min;\n    my\
    \ @ret;\n    for my $n (@$numbers) {\n        my $rescaled = ($n - $min) / $range;\n\
    \        push @ret, $rescaled;\n    }\n    return \\@ret;\n}", "    my($min, $max)\
    \ = ($numbers->[0], $numbers->[0]);\n    foreach (@$numbers) {\n        $min =\
    \ $_ if $_ < $min;\n        $max = $_ if $_ > $max;\n    }\n    my $range = $max\
    \ - $min;\n    [map { ($_ - $min) / $range } @$numbers];\n}", "    my @numbers\
    \ = @$numbers;\n    my $min = min @numbers;\n    my $max = max @numbers;\n   \
    \ return [map { ($_ - $min) / ($max - $min) } @numbers];\n}", "    my($min, $max)\
    \ = minmax(@$numbers);\n    my $range = $max - $min;\n    return [ map {($_ -\
    \ $min) / $range} @$numbers ];\n}", "    my($min, $max) = (min(@$numbers), max(@$numbers));\n\
    \    my @rescaled = map {($_ - $min) / ($max - $min)} @$numbers;\n    return \\\
    @rescaled;\n}", "    my $min_number = min(@$numbers);\n    my $max_number = max(@$numbers);\n\
    \    my $range = $max_number - $min_number;\n    my @result = ();\n    foreach\
    \ my $number (@$numbers) {\n        my $scaled_number = ($number - $min_number)\
    \ / $range;\n        push @result, $scaled_number;\n    }\n    return @result;\n\
    }", "    my @numbers = @$numbers;\n    my($min, $max) = ($numbers[0], $numbers[0]);\n\
    \    foreach my $n (@numbers) {\n        $min = $n if $n < $min;\n        $max\
    \ = $n if $n > $max;\n    }\n    return @numbers if $min == $max;\n    return\
    \ map { ($_ - $min) / ($max - $min) } @numbers;\n}", "    my $min = List::Util::min(@$numbers);\n\
    \    my $max = List::Util::max(@$numbers);\n    my $range = $max - $min;\n   \
    \ my @rescaled = map {\n        ($_ - $min) / $range\n    } @$numbers;\n    return\
    \ @rescaled;\n}", "    my $n = $#$numbers;\n    my $min = min(@$numbers);\n  \
    \  my $max = max(@$numbers);\n    my $denom = $max - $min;\n    my @result = @$numbers;\n\
    \    for (my $i = 0; $i <= $n; $i++) {\n        $result[$i] = ($result[$i] - $min)\
    \ / $denom;\n    }\n    return \\@result;\n}", "    my $min = min(@$numbers);\n\
    \    my $max = max(@$numbers);\n    return map {($_ - $min) / ($max - $min)} @$numbers;\n\
    }", "    my($min, $max) = minmax @$numbers;\n    my $result = [];\n    for (@$numbers)\
    \ {\n        if ($max - $min == 0) {\n            push @$result, 0;\n        }\
    \ else {\n            push @$result, ($_ - $min) / ($max - $min);\n        }\n\
    \    }\n    return $result;\n}"]
stop_tokens:
- "\nsub"
- "\n#"
- "\n\n"
