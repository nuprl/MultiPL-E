name: HumanEval_148_bf
language: pl
prompt: "# There are eight planets in our solar system: the closerst to the Sun \n\
  # is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn, \n# Uranus,\
  \ Neptune.\n# Write a function that takes two planet names as strings planet1 and\
  \ planet2. \n# The function should return a tuple containing all planets whose orbits\
  \ are \n# located between the orbit of planet1 and the orbit of planet2, sorted\
  \ by \n# the proximity to the sun. \n# The function should return an empty tuple\
  \ if planet1 or planet2\n# are not correct planet names. \n# Examples\n# bf(\"Jupiter\"\
  , \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n# bf(\"Earth\", \"Mercury\") ==> (\"\
  Venus\")\n# bf(\"Mercury\", \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"\
  Jupiter\", \"Saturn\")\nsub bf {\n    my($planet1, $planet2) = @_;\n"
tests: "use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&bf;\n   \
  \     if(eq_deeply($candidate->(\"Jupiter\", \"Neptune\"),[\"Saturn\", \"Uranus\"\
  ])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"\
  Earth\", \"Mercury\"),[\"Venus\"])) {\n        print \"ok!\" }else{\n        exit\
  \ 1;\n        }\n        if(eq_deeply($candidate->(\"Mercury\", \"Uranus\"),[\"\
  Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])) {\n        print \"ok!\"\
  \ }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"Neptune\"\
  , \"Venus\"),[\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"])) {\n  \
  \      print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"\
  Earth\", \"Earth\"),[])) {\n        print \"ok!\" }else{\n        exit 1;\n    \
  \    }\n        if(eq_deeply($candidate->(\"Mars\", \"Earth\"),[])) {\n        print\
  \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"\
  Jupiter\", \"Makemake\"),[])) {\n        print \"ok!\" }else{\n        exit 1;\n\
  \        }\n}\n\ntesthumaneval();"
completions: ["    my @planets = (\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\");\n    return () unless grep $_\
    \ eq $planet1, @planets;\n    return () unless grep $_ eq $planet2, @planets;\n\
    \    my $idx1 = first_index {$_ eq $planet1} @planets;\n    my $idx2 = first_index\
    \ {$_ eq $planet2} @planets;\n    return () if $idx1 == $idx2;\n    if ($idx1\
    \ > $idx2) {\n        ($idx1, $idx2) = ($idx2, $idx1);\n    }\n    return @planets[$idx1+1..$idx2-1];\n\
    }", "    my %planets = qw(\n        Mercury 1\n        Venus 2\n        Earth\
    \ 3\n        Mars 4\n        Jupiter 5\n        Saturn 6\n        Uranus 7\n \
    \       Neptune 8\n    );\n    return () unless exists $planets{$planet1} && exists\
    \ $planets{$planet2};\n    my $start = $planets{$planet1};\n    my $end = $planets{$planet2};\n\
    \    if ($start > $end) {\n        $start, $end = $end, $start;\n    }\n    my\
    \ @result;\n    for my $idx ($start .. $end) {\n        my @keys = grep { $planets{$_}\
    \ == $idx } keys %planets;\n        push @result, $keys[0];\n    }\n    return\
    \ @result;\n}", "    my @planets = qw/Mercury Venus Earth Mars Jupiter Saturn\
    \ Uranus Neptune/;\n    my $p1;\n    my $p2;\n    for my $i (0..$#planets) {\n\
    \        if($planets[$i] eq $planet1) {\n            $p1 = $i;\n        }\n  \
    \      if($planets[$i] eq $planet2) {\n            $p2 = $i;\n        }\n    }\n\
    \    if(!$p1 || !$p2) {\n        return ();\n    }\n    my @sorted = sort {$a\
    \ <=> $b} ($p1, $p2);\n    my @b = @planets[$sorted[0]+1..$sorted[1]-1];\n   \
    \ return wantarray ? @b : \\@b;\n}", "    my @planets = qw(Mercury Venus Earth\
    \ Mars Jupiter Saturn Uranus Neptune);\n    my $p1_idx = undef;\n    my $p2_idx\
    \ = undef;\n    for my $idx (0..$#planets) {\n        if ($planets[$idx] eq $planet1)\
    \ {\n            $p1_idx = $idx;\n        }\n        if ($planets[$idx] eq $planet2)\
    \ {\n            $p2_idx = $idx;\n        }\n    }\n    if (defined $p1_idx &&\
    \ defined $p2_idx) {\n        return @planets[$p1_idx+1..$p2_idx-1];\n    }\n\
    \    return ();\n}", "    my $planets = [qw/Mercury Venus Earth Mars Jupiter Saturn\
    \ Uranus Neptune/];\n    my $planet_loc = { map { $planets->[$_] => $_ } 0..$#$planets\
    \ };\n    if (exists $planet_loc->{$planet1} && exists $planet_loc->{$planet2})\
    \ {\n        my @planets = ();\n        my $first = min($planet_loc->{$planet1},\
    \ $planet_loc->{$planet2});\n        my $last = max($planet_loc->{$planet1}, $planet_loc->{$planet2});\n\
    \        @planets = @$planets[$first+1..$last-1];\n        return @planets;\n\
    \    }\n    return ();\n}", "    return () unless $planet1 && $planet2;\n    my\
    \ @ans;\n    my $p1 = index $solar_system, $planet1;\n    my $p2 = index $solar_system,\
    \ $planet2;\n    my $min = $p1 < $p2 ? $p1 : $p2;\n    my $max = $p1 > $p2 ? $p1\
    \ : $p2;\n    for ( my $i = $min + 1; $i < $max; $i++ ) {\n        push @ans,\
    \ substr $solar_system, $i, 1;\n    }\n    return @ans;\n}", "    my @planets\
    \ = qw(Mercury Venus Earth Mars Jupiter Saturn Uranus Neptune);\n    my %planets\
    \ = map { $planets[$_] => $_ } 0..$#planets;\n    if(!exists $planets{$planet1}\
    \ || !exists $planets{$planet2}) {\n        return ();\n    }\n    my @result\
    \ = @planets[$planets{$planet1}+1..$planets{$planet2}-1];\n    $planets{$planet1}\
    \ > $planets{$planet2} ? reverse @result : @result;\n}", "    my @planet_list\
    \ = qw(Mercury Venus Earth Mars Jupiter Saturn Uranus Neptune);\n    my %planet_hash\
    \ = map { $_ => 1 } @planet_list;\n    return () unless (exists $planet_hash{$planet1}\
    \ && exists $planet_hash{$planet2});\n    my $planet1_idx = 0;\n    my $planet2_idx\
    \ = 0;\n    foreach my $idx (0..$#planet_list) {\n        $planet1_idx = $idx\
    \ if ($planet_list[$idx] eq $planet1);\n        $planet2_idx = $idx if ($planet_list[$idx]\
    \ eq $planet2);\n    }\n    if ($planet1_idx < $planet2_idx) {\n        return\
    \ @planet_list[$planet1_idx+1..$planet2_idx-1];\n    } else {\n        return\
    \ @planet_list[$planet2_idx+1..$planet1_idx-1];\n    }\n}", "    my @planets =\
    \ (\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\");\n    my @result;\n    if($planet1 eq \"Mercury\") {\n        for(my\
    \ $i = 0; $i < @planets; $i++) {\n            push(@result, $planets[$i]) if($planets[$i]\
    \ eq $planet2);\n        }\n    } else {\n        my $j;\n        for(my $i =\
    \ 0; $i < @planets; $i++) {\n            $j = $i if($planets[$i] eq $planet1);\n\
    \        }\n        for(my $i = $j+1; $i < @planets; $i++) {\n            push(@result,\
    \ $planets[$i]) if($planets[$i] eq $planet2);\n        }\n    }\n    return @result;\n\
    }\nprint \"@{[bf(\"Mercury\", \"Neptune\")]}\\n\";\nprint \"@{[bf(\"Jupiter\"\
    , \"Neptune\")]}\\n\";\nprint \"@{[bf(\"Earth\", \"Mercury\")]}\\n\";\nprint \"\
    @{[bf(\"Mercury\", \"Uranus\")]}\\n\";", "    my @planets = ('Mercury', 'Venus',\
    \ 'Earth', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune');\n    my @out;\n\
    \    for my $i (0..7) {\n        if ($planets[$i] eq $planet1) {\n           \
    \ for my $j ($i+1..7) {\n                if ($planets[$j] eq $planet2) {\n   \
    \                 return @out;\n                }\n                push @out,\
    \ $planets[$j];\n            }\n        }\n    }\n    return ();\n}", "    my\
    \ %planets = (\n        \"Mercury\" => 0,\n        \"Venus\" => 1,\n        \"\
    Earth\" => 2,\n        \"Mars\" => 3,\n        \"Jupiter\" => 4,\n        \"Saturn\"\
    \ => 5,\n        \"Uranus\" => 6,\n        \"Neptune\" => 7,\n    );\n    my @ordered_planets\
    \ = sort {$planets{$a} <=> $planets{$b}} keys %planets;\n    my $p1 = $planets{$planet1};\n\
    \    my $p2 = $planets{$planet2};\n    if (defined $p1 && defined $p2) {\n   \
    \     if ($p1 > $p2) {\n            return ();\n        } else {\n           \
    \ return @ordered_planets[$p1..$p2-1];\n        }\n    } else {\n        return\
    \ ();\n    }\n}", "    my %planets = (\n        \"Mercury\" => 0,\n        \"\
    Venus\" => 1,\n        \"Earth\" => 2,\n        \"Mars\" => 3,\n        \"Jupiter\"\
    \ => 4,\n        \"Saturn\" => 5,\n        \"Uranus\" => 6,\n        \"Neptune\"\
    \ => 7,\n    );\n    # planets are in the correct order, i.e. first one is closer\
    \ to the sun\n    my @planets = (\"Mercury\", \"Venus\", \"Earth\", \"Mars\",\
    \ \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\");\n    my @sorted_planets =\
    \ ();\n    if (exists $planets{$planet1} && exists $planets{$planet2}) {\n   \
    \     if ($planets{$planet1} < $planets{$planet2}) {\n            @sorted_planets\
    \ = @planets[$planets{$planet1}+1..$planets{$planet2}-1];\n        } else {\n\
    \            @sorted_planets = @planets[$planets{$planet2}+1..$planets{$planet1}-1];\n\
    \        }\n    }\n    return @sorted_planets;\n}", "    my %planets = (\n   \
    \     Mercury => 1,\n        Venus => 2,\n        Earth => 3,\n        Mars =>\
    \ 4,\n        Jupiter => 5,\n        Saturn => 6,\n        Uranus => 7,\n    \
    \    Neptune => 8,\n    );\n    if (exists $planets{$planet1} && exists $planets{$planet2})\
    \ {\n        my @planets = sort { $planets{$a} <=> $planets{$b} } keys %planets;\n\
    \        my $from = $planets{$planet1};\n        my $to = $planets{$planet2};\n\
    \        return () if $from > $to;\n        my @result = @planets[$from..$to-1];\n\
    \        return @result;\n    }\n    return ();\n}", "    my @planets = qw(Mercury\
    \ Venus Earth Mars Jupiter Saturn Uranus Neptune);\n    my $idx1 = 0;\n    my\
    \ $idx2 = 0;\n    my $count = 0;\n    foreach my $planet (@planets) {\n      \
    \  $idx1 = $count if ($planet eq $planet1);\n        $idx2 = $count if ($planet\
    \ eq $planet2);\n        $count++;\n    }\n    if (($idx1 == 0) || ($idx2 == 0))\
    \ {\n        return ();\n    }\n    if ($idx1 < $idx2) {\n        return @planets[$idx1+1..$idx2-1];\n\
    \    } else {\n        return @planets[$idx2+1..$idx1-1];\n    }\n}", "    my\
    \ %planets = (\n        \"Mercury\" => 1,\n        \"Venus\" => 2,\n        \"\
    Earth\" => 3,\n        \"Mars\" => 4,\n        \"Jupiter\" => 5,\n        \"Saturn\"\
    \ => 6,\n        \"Uranus\" => 7,\n        \"Neptune\" => 8,\n    );\n    my @planets\
    \ = qw(Mercury Venus Earth Mars Jupiter Saturn Uranus Neptune);\n    my $p1 =\
    \ $planets{$planet1};\n    my $p2 = $planets{$planet2};\n    if ($p1 && $p2) {\n\
    \        my $tmp = ($p1 < $p2)? $p1 : $p2;\n        $p1 = ($p1 < $p2)? $p2 : $p1;\n\
    \        $p2 = $tmp;\n        my @res = ();\n        foreach (@planets) {\n  \
    \          my $v = $planets{$_};\n            if ($v > $p2 && $v < $p1) {\n  \
    \              push @res, $_;\n            }\n        }\n        return \\@res;\n\
    \    }\n    return [];\n}", "    my %planets = (\n        Mercury => 1,\n    \
    \    Venus => 2,\n        Earth => 3,\n        Mars => 4,\n        Jupiter =>\
    \ 5,\n        Saturn => 6,\n        Uranus => 7,\n        Neptune => 8,\n    );\n\
    \    my $from = $planets{$planet1};\n    my $to = $planets{$planet2};\n    return\
    \ () unless $from and $to;\n    my @planets = keys %planets;\n    if ($from >\
    \ $to) {\n        ($from, $to) = ($to, $from);\n    }\n    my @result = grep {\
    \ $planets{$_} >= $from and $planets{$_} <= $to } @planets;\n    return wantarray\
    \ ? @result : \\@result;\n}", "    my @planets = qw(Mercury Venus Earth Mars Jupiter\
    \ Saturn Uranus Neptune);\n    my @planets1 = my @planets2 = @planets;\n    my\
    \ $pos1 = shift @planets1;\n    my $pos2 = pop @planets2;\n    unless ($planet1\
    \ eq $pos1) {\n        foreach (@planets1) {\n            $pos1 = shift @planets1;\n\
    \            last if $_ eq $planet1;\n        }\n    }\n    unless ($planet2 eq\
    \ $pos2) {\n        foreach (@planets2) {\n            $pos2 = pop @planets2;\n\
    \            last if $_ eq $planet2;\n        }\n    }\n    return unless $pos1\
    \ && $pos2;\n    return $pos1 if $pos1 eq $pos2;\n    return @planets[shift @planets1\
    \ .. pop @planets2];\n}", "    my @planets = (\"Mercury\", \"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\");\n    my %planets\
    \ = map { $planets[$_] => $_ } 0..$#planets;\n    return () unless exists $planets{$planet1}\
    \ && exists $planets{$planet2};\n    my $i1 = $planets{$planet1};\n    my $i2\
    \ = $planets{$planet2};\n    if ($i1 <= $i2) {\n        return @planets[($i1+1)..($i2-1)];\n\
    \    } else {\n        return @planets[($i2+1)..($i1-1)];\n    }\n}", "    my\
    \ @ret;\n    if (grep(/^$planet1$/, @planets) && grep(/^$planet2$/, @planets))\
    \ {\n        my $planet1_idx = get_index($planet1);\n        my $planet2_idx =\
    \ get_index($planet2);\n        my $min = $planet1_idx < $planet2_idx ? $planet1_idx\
    \ : $planet2_idx;\n        my $max = $planet1_idx > $planet2_idx ? $planet1_idx\
    \ : $planet2_idx;\n        for my $i ($min + 1 .. $max - 1) {\n            push\
    \ @ret, $planets[$i];\n        }\n    }\n    return @ret;\n}", "    my $planets\
    \ = {\n        Mercury => 1,\n        Venus => 2,\n        Earth => 3,\n     \
    \   Mars => 4,\n        Jupiter => 5,\n        Saturn => 6,\n        Uranus =>\
    \ 7,\n        Neptune => 8,\n    };\n    if (!exists $planets->{$planet1} || !exists\
    \ $planets->{$planet2}) {\n        return ();\n    }\n    my @planets = keys %$planets;\n\
    \    my $idx1 = index @planets, $planet1;\n    my $idx2 = index @planets, $planet2;\n\
    \    my @between = ();\n    push @between, @planets[$idx1+1..$idx2-1] if $idx1\
    \ < $idx2;\n    push @between, @planets[$idx2+1..$idx1-1] if $idx1 > $idx2;\n\
    \    return @between;\n}\n1;"]
stop_tokens:
- "\nsub"
- "\n#"
- "\n\n"
