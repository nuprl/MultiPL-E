name: HumanEval_93_encode
language: pl
prompt: "# Write a function that takes a message, and encodes in such a \n# way that\
  \ it swaps case of all letters, replaces all vowels in \n# the message with the\
  \ letter that appears 2 places ahead of that \n# vowel in the english alphabet.\
  \ \n# Assume only letters. \n# Examples:\n# >>> encode('test')\n# 'TGST'\n# >>>\
  \ encode('This is a message')\n# 'tHKS KS C MGSSCGG'\nsub encode {\n    my($message)\
  \ = @_;\n"
tests: "use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&encode;\n\
  \        if(eq_deeply($candidate->(\"TEST\"),\"tgst\")) {\n        print \"ok!\"\
  \ }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"Mudasir\"\
  ),\"mWDCSKR\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n  \
  \      if(eq_deeply($candidate->(\"YES\"),\"ygs\")) {\n        print \"ok!\" }else{\n\
  \        exit 1;\n        }\n        if(eq_deeply($candidate->(\"This is a message\"\
  ),\"tHKS KS C MGSSCGG\")) {\n        print \"ok!\" }else{\n        exit 1;\n   \
  \     }\n        if(eq_deeply($candidate->(\"I DoNt KnOw WhAt tO WrItE\"),\"k dQnT\
  \ kNqW wHcT Tq wRkTg\")) {\n        print \"ok!\" }else{\n        exit 1;\n    \
  \    }\n}\n\ntesthumaneval();"
completions: ["    my $r = '';\n    my $i = 0;\n    my $len = length($message);\n\
    \    while ($i < $len) {\n        my $ch = substr($message, $i, 1);\n        if\
    \ ($ch =~ /[a-z]/i) {\n            $ch =~ tr/a-z/A-Z/;\n            $ch =~ tr/A-Z/N-ZA-M/;\n\
    \            $ch =~ tr/A-Z/a-z/;\n        }\n        $r .= $ch;\n        $i++;\n\
    \    }\n    return $r;\n}", "    my @array = split('', $message);\n    my $new_message\
    \ = '';\n    foreach my $letter (@array) {\n        if ($letter =~ /[aeiou]/i)\
    \ {\n            $new_message .= next_letter($letter);\n        } else {\n   \
    \         $new_message .= $letter;\n        }\n    }\n    return $new_message;\n\
    }", "    $message =~ tr/a-zA-Z/A-Za-z/;\n    $message =~ tr/aeiou/cegik/;\n  \
    \  return $message;\n}", "    my @message = split '', $message;\n    my $result\
    \ = '';\n    foreach (@message) {\n        if ($_ =~ /[A-Z]/) {\n            $result\
    \ .= lc $_;\n        } elsif ($_ =~ /[a-z]/) {\n            $result .= uc $_;\n\
    \        } else {\n            $result .= $_;\n        }\n    }\n    @message\
    \ = split '', $result;\n    $result = '';\n    foreach (@message) {\n        if\
    \ ($_ =~ /[AEOIUa]/) {\n            $result .= $_;\n            next;\n      \
    \  } elsif ($_ =~ /[EOIUe]/) {\n            $result .= chr ord($_) + 2;\n    \
    \    } elsif ($_ =~ /[Aa]/) {\n            $result .= 'C';\n        } else {\n\
    \            $result .= $_;\n        }\n    }\n    return $result;\n}", "    my\
    \ $alphabet = 'abcdefghijklmnopqrstuvwxyz';\n    my $encoded;\n    for my $char\
    \ (split //, $message) {\n        if ($char =~ /[A-Z]/) {\n            $encoded\
    \ .= lc($char);\n        } elsif ($char =~ /[a-z]/) {\n            my $position\
    \ = index($alphabet, $char);\n            if ($position >= 0 && $position < 24)\
    \ {\n                $encoded .= substr($alphabet, $position + 2, 1);\n      \
    \      } elsif ($position == 24) {\n                $encoded .= substr($alphabet,\
    \ 0, 1);\n            } elsif ($position == 25) {\n                $encoded .=\
    \ substr($alphabet, 1, 1);\n            }\n        } else {\n            $encoded\
    \ .= $char;\n        }\n    }\n    return $encoded;\n}", "    my $encmessage =\
    \ '';\n    my @alphabet = ('a'..'z');\n    foreach my $char (split(//, $message))\
    \ {\n        if ($char =~ /[a-z]/i) {\n            if ($char =~ /[A-Z]/) {\n \
    \               $encmessage .= lc($char);\n            }\n            else {\n\
    \                $encmessage .= uc($char);\n            }\n        }\n       \
    \ elsif ($char =~ /[aeiou]/i) {\n            my $position = 0;\n            foreach\
    \ my $letter (@alphabet) {\n                if ($letter eq lc($char)) {\n    \
    \                last;\n                }\n                $position++;\n    \
    \        }\n            $encmessage .= $alphabet[($position + 2) % 26];\n    \
    \    }\n        else {\n            $encmessage .= $char;\n        }\n    }\n\
    \    return $encmessage;\n}", "    my @letters = split '', $message;\n    my @vowels\
    \ = qw(a e i o u);\n    my %vowels = map {$_ => 1} @vowels;\n    my @result;\n\
    \    for (@letters) {\n        if ($vowels{lc $_}) {\n            my $letter =\
    \ lc $_;\n            my $i = ord($letter) - ord('a');\n            $i += 2;\n\
    \            $i -= 26 if $i > 25;\n            push @result, chr(ord('a') + $i);\n\
    \        } else {\n            push @result, $_;\n        }\n    }\n    return\
    \ join '', @result;\n}", "    my @res;\n    my %vowels = (\n        'a' => 'c',\n\
    \        'e' => 'g',\n        'i' => 'k',\n        'o' => 'q',\n        'u' =>\
    \ 'y',\n    );\n    my @message = split(//, $message);\n    foreach my $letter\
    \ (@message) {\n        my $lower = lc($letter);\n        if (exists $vowels{$lower})\
    \ {\n            push @res, $vowels{$lower};\n        } else {\n            if\
    \ ($letter eq $lower) {\n                push @res, uc($letter);\n           \
    \ } else {\n                push @res, $letter;\n            }\n        }\n  \
    \  }\n    return join('', @res);\n}", "    my @letters = split(//, $message);\n\
    \    my $result = \"\";\n    my %alphabet = ( \n        'a' => 'c',\n        'b'\
    \ => 'd',\n        'c' => 'e',\n        'd' => 'f',\n        'e' => 'g',\n   \
    \     'f' => 'h',\n        'g' => 'i',\n        'h' => 'j',\n        'i' => 'k',\n\
    \        'j' => 'l',\n        'k' => 'm',\n        'l' => 'n',\n        'm' =>\
    \ 'o',\n        'n' => 'p',\n        'o' => 'q',\n        'p' => 'r',\n      \
    \  'q' => 's',\n        'r' => 't',\n        's' => 'u',\n        't' => 'v',\n\
    \        'u' => 'w',\n        'v' => 'x',\n        'w' => 'y',\n        'x' =>\
    \ 'z',\n        'y' => 'a',\n        'z' => 'b',\n    );\n    foreach my $letter\
    \ (@letters) {\n        if ($letter =~ /[a-z]/i) {\n            $result .= lc\
    \ $letter eq $letter ? $alphabet{lc $letter} : uc $alphabet{lc $letter};\n   \
    \     } else {\n            $result .= $letter;\n        }\n    }\n    return\
    \ $result;\n}\nprint encode(\"test\") . \"\\n\";\nprint encode(\"This is a message\"\
    ) . \"\\n\";", "    my $encoded_message = '';\n    for my $char (split //, $message)\
    \ {\n        if (is_upper($char)) {\n            $encoded_message .= lower($char);\n\
    \        }\n        elsif (is_lower($char)) {\n            $encoded_message .=\
    \ upper($char);\n        }\n        elsif (is_vowel($char)) {\n            $encoded_message\
    \ .= next_vowel($char);\n        }\n        else {\n            $encoded_message\
    \ .= $char;\n        }\n    }\n    return $encoded_message;\n}", "    my $result\
    \ = \"\";\n    for my $char (split //, $message) {\n        if ($char =~ /[a-z]/i)\
    \ {\n            $result .= encode_char($char);\n        } else {\n          \
    \  $result .= $char;\n        }\n    }\n    return $result;\n}", "    my $upper\
    \ = uc($message);\n    my $swap = lc($message);\n    my @upper = split(\"\", $upper);\n\
    \    my @swap = split(\"\", $swap);\n    my @message = split(\"\", $message);\n\
    \    my @codes = @message;\n    my $i = 0;\n    while ($i < scalar(@message))\
    \ {\n        if (exists($vowels{$message[$i]})) {\n            $codes[$i] = $vowels{$message[$i]};\n\
    \        } elsif ($upper[$i] eq $message[$i]) {\n            $codes[$i] = $swap[$i];\n\
    \        } else {\n            $codes[$i] = $upper[$i];\n        }\n        $i++;\n\
    \    }\n    return join(\"\", @codes);\n}", "    $message =~ tr/a-zA-Z/A-Za-z/;\n\
    \    my @chars = split //, $message;\n    my @alphabet = ('a'..'z');\n    my $alphabet_size\
    \ = scalar @alphabet;\n    foreach my $char (@chars) {\n        if ( grep { /$char/\
    \ } @alphabet ) {\n            my $i = 0;\n            my $char_i = 0;\n     \
    \       while ( $i < $alphabet_size ) {\n                if ( $char eq $alphabet[$i]\
    \ ) {\n                    $char_i = $i;\n                    last;\n        \
    \        }\n                $i++;\n            }\n            my $shifted_char_i\
    \ = $char_i + 2;\n            if ( $shifted_char_i >= $alphabet_size ) {\n   \
    \             $shifted_char_i = $shifted_char_i - $alphabet_size;\n          \
    \  }\n            $char = $alphabet[$shifted_char_i];\n        }\n    }\n    return\
    \ join('', @chars);\n}", "    my $encoded = '';\n    my $case = 'up';\n    my\
    \ $cipher = 'ETIAO';", "    # your code here\n}", "    my $encoded_message = '';\n\
    \    my @message_array = split(//, $message);\n    foreach my $letter (@message_array)\
    \ {\n        $encoded_message .=\n            is_vowel($letter) ?\n          \
    \      get_next_vowel($letter) :\n                is_upper($letter) ?\n      \
    \              lc($letter) :\n                    uc($letter);\n    }\n    return\
    \ $encoded_message;\n}", "    my @message_array = split //, $message;\n    my\
    \ $encoded_message = '';\n    for (my $i = 0; $i < scalar @message_array; $i++)\
    \ {\n        if ($message_array[$i] =~ /[a-z]/i) {\n            if ($message_array[$i]\
    \ =~ /[a-z]/) {\n                $message_array[$i] = uc $message_array[$i];\n\
    \            }\n            else {\n                $message_array[$i] = lc $message_array[$i];\n\
    \            }\n            if ($message_array[$i] =~ /[aeiou]/i) {\n        \
    \        if ($message_array[$i] =~ /[a-z]/) {\n                    $message_array[$i]\
    \ = chr (ord('a') + (ord($message_array[$i]) - ord('a') + 2) % 26);\n        \
    \        }\n                else {\n                    $message_array[$i] = chr\
    \ (ord('A') + (ord($message_array[$i]) - ord('A') + 2) % 26);\n              \
    \  }\n            }\n        }\n        $encoded_message .= $message_array[$i];\n\
    \    }\n    return $encoded_message;\n}", "    my $result = '';\n    for my $letter\
    \ (split //, $message) {\n        if ($letter =~ /[A-Z]/) {\n            $result\
    \ .= lc $letter;\n        }\n        elsif ($letter =~ /[a-z]/) {\n          \
    \  $result .= uc $letter;\n        }\n        elsif ($letter =~ /[a,e,i,o,u]/)\
    \ {\n            $result .= chr(ord($letter) + 2);\n        }\n        else {\n\
    \            $result .= $letter;\n        }\n    }\n    return $result;\n}", " \
    \   my $encoded = '';\n    my $alphabet = 'abcdefghijklmnopqrstuvwxyz';\n    my\
    \ $key;\n    my $letter;\n    foreach my $c (split //, $message) {\n        if\
    \ ($c eq ' ') {\n            $encoded .= ' ';\n            next;\n        }\n\
    \        $key = uc($c) eq $c ? 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' : 'abcdefghijklmnopqrstuvwxyz';\n\
    \        $letter = lc($c);\n        if ($key =~ /$letter/) {\n            $encoded\
    \ .= $key =~ /$letter(.{2})/ ? $1 : '';\n        } else {\n            $encoded\
    \ .= $key =~ /($letter)/ ? $1 : '';\n        }\n    }\n    return $encoded;\n}",
  '    $message =~ tr/A-Za-z/a-zA-Z/;']
stop_tokens:
- "\nsub"
- "\n#"
- "\n\n"
