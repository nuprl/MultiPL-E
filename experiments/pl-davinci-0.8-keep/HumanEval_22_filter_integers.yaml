name: HumanEval_22_filter_integers
language: pl
prompt: "# Filter given list of any python values only for integers\n# >>> filter_integers(['a',\
  \ 3.14, 5])\n# [5]\n# >>> filter_integers([1, 2, 3, 'abc', {}, []])\n# [1, 2, 3]\n\
  sub filter_integers {\n    my($values) = @_;\n"
tests: "use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&filter_integers;\n\
  \        if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n  \
  \      exit 1;\n        }\n        if(eq_deeply($candidate->([4, {}, [], 23.2, 9,\
  \ \"adasd\"]),[4, 9])) {\n        print \"ok!\" }else{\n        exit 1;\n      \
  \  }\n        if(eq_deeply($candidate->([3, \"c\", 3, 3, \"a\", \"b\"]),[3, 3, 3]))\
  \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
completions: ["    return grep { Scalar::Util::looks_like_number($_) && int($_) ==\
    \ $_ } @$values;\n}", "    return grep {\n        my $value = $_;\n        return\
    \ 0 if !defined $value;\n        return 1 if Scalar::Util::looks_like_number($value)\
    \ && \"$value\" =~ /^-?\\d+$/;\n        return 0;\n    } @$values;\n}", "    return\
    \ [ grep { is_integer($_) } @$values ];\n}", "    return [ grep { is_integer($_)\
    \ } @$values ];\n}", "    return [ grep { is_number($_) && ($_ == int($_)) } @$values\
    \ ];\n}", "    return [ grep { __PACKAGE__->is_integer($_) } @$values ];\n}",
  "    my @filtered = grep { $_ == int($_) } @$values;\n    return \\@filtered;\n}",
  "    return [ grep {/^\\d+$/} @$values ];\n}", "    my @result = grep { int == $_\
    \ } @$values;\n    return \\@result;\n}", "    return [grep { is_int($_) } @$values];\n\
    }", "    return [ grep { Scalar::Util::looks_like_number($_) && int($_) == $_\
    \ } @$values ];\n}", "    return [grep { _is_integer($_) } @$values];\n}", " \
    \   my @int_values = ();\n    foreach my $val (@$values) {\n        if (scalar(grep\
    \ { $val eq $_ } (0..9))) {\n            push @int_values, $val;\n        }\n\
    \    }\n    return \\@int_values;\n}", "    return grep { ref $_ eq '' and /^\\\
    d+$/ } @$values;\n}", "    return [grep { ref($_) eq 'ARRAY' ? 0 :\n         \
    \             ref($_) eq 'HASH' ? 0 :\n                      Scalar::Util::looks_like_number($_)\
    \ && /^-?\\d+$/ ? 1 : 0\n                  } @$values];\n}", "    # TODO: write\
    \ filter_integers implementation\n    my @integers = grep {\n        ref($_) ?\n\
    \        ref($_) =~ /^(SCALAR|HASH|ARRAY|CODE|REF|GLOB|LVALUE|FORMAT|IO|VSTRING|Regexp|Math::BigInt|Math::BigFloat)$/\
    \ :\n        $_ =~ /^-?\\d+$/\n    } @$values;\n    return \\@integers;\n}", " \
    \   return $values->grep(sub { defined(eval { $_->as_int }) })->flatten;\n}",
  "    my @result = grep { !ref($_) && $_+0 == $_ } @$values;\n    return \\@result;\n\
    }", "    return [ grep { Scalar::Util::looks_like_number($_) } @$values ];\n}",
  "    return grep {\n        !ref($_) && $_ eq int($_)\n    } @$values;\n}"]
stop_tokens:
- "\nsub"
- "\n#"
- "\n\n"
