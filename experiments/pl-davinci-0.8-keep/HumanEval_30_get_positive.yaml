name: HumanEval_30_get_positive
language: pl
prompt: "# Return only positive numbers in the list.\n# >>> get_positive([-1, 2, -4,\
  \ 5, 6])\n# [2, 5, 6]\n# >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\
  # [5, 3, 2, 3, 9, 123, 1]\nsub get_positive {\n    my($l) = @_;\n"
tests: "use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&get_positive;\n\
  \        if(eq_deeply($candidate->([-1, -2, 4, 5, 6]),[4, 5, 6])) {\n        print\
  \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5,\
  \ 3, -5, 2, 3, 3, 9, 0, 123, 1, -10]),[5, 3, 2, 3, 3, 9, 123, 1])) {\n        print\
  \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([-1,\
  \ -2]),[])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n      \
  \  if(eq_deeply($candidate->([]),[])) {\n        print \"ok!\" }else{\n        exit\
  \ 1;\n        }\n}\n\ntesthumaneval();"
completions: ["    @$l = grep $_ > 0, @$l;\n    return $l;\n}", "    my @array = @$l;\n\
    \    my @sorted = sort {$a <=> $b} @array;\n    my @pos = ();\n    foreach my\
    \ $p (@sorted) {\n        if ($p >= 0) {\n            push(@pos, $p);\n      \
    \  }\n    }\n    return @pos;\n}", "    return grep { $_ > 0 } @$l;\n}", "   \
    \ my @ans = grep { $_ > 0 } @$l;\n    return @ans;\n}", "    my $positive = [];\n\
    \    for my $num(@$l) {\n        if($num >= 0) {\n            push @$positive,\
    \ $num;\n        }\n    }\n    return $positive;\n}", "    my @ret = ();\n   \
    \ for my $e (@$l) {\n        if ($e > 0) {\n            push @ret, $e;\n     \
    \   }\n    }\n    return @ret;\n}", "    my @p;\n    foreach my $i (@$l) {\n \
    \       push @p, $i if $i > 0;\n    }\n    return @p;\n}", "    return [ grep\
    \ { $_ > 0 } @$l ];\n}", "    my @list = ();\n    foreach my $i (@$l) {\n    \
    \    if ($i > 0) {\n            push @list, $i;\n        }\n    }\n    return\
    \ @list;\n}", "    my @l = @$l;\n    my @r;\n    for my $i (@l) {\n        if\
    \ ($i > 0) {\n            push @r, $i;\n        }\n    }\n    return @r;\n}",
  "    my @out;\n    for (@$l) {\n        if ($_ > 0) {\n            push @out, $_;\n\
    \        }\n    }\n    return @out;\n}", "    return grep { $_ > 0 } @$l;\n}",
  "    return [grep { $_ > 0 } @$l];\n}", "    return [grep { $_ > 0 } @$l];\n}",
  "    return grep {$_ > 0} @$l;\n}", "    return get_some($l, sub { return $_[0]\
    \ > 0; });\n}", "    return [grep $_ > 0, @$l];\n}", "    return [map { $_ > 0\
    \ ? $_ : () } @$l];\n}", "    my @new_l = ();\n    for my $i (@$l) {\n       \
    \ if ($i > 0) {\n            push @new_l, $i;\n        }\n    }\n    return @new_l;\n\
    }", "    my @ret = ();\n    for my $i (@$l) {\n        if ($i > 0) {\n       \
    \     push @ret, $i;\n        }\n    }\n    return @ret;\n}"]
stop_tokens:
- "\nsub"
- "\n#"
- "\n\n"
