name: HumanEval_100_make_a_pile
language: pl
prompt: "# Given a positive integer n, you have to make a pile of n levels of stones.\n\
  # The first level has n stones.\n# The number of stones in the next level is:\n\
  # - the next odd number if n is odd.\n# - the next even number if n is even.\n#\
  \ Return the number of stones in each level in a list, where element at index\n\
  # i represents the number of stones in the level (i+1).\n# Examples:\n# >>> make_a_pile(3)\n\
  # [3, 5, 7]\nsub make_a_pile {\n    my($n) = @_;\n"
tests: "use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&make_a_pile;\n\
  \        if(eq_deeply($candidate->(3),[3, 5, 7])) {\n        print \"ok!\" }else{\n\
  \        exit 1;\n        }\n        if(eq_deeply($candidate->(4),[4, 6, 8, 10]))\
  \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(5),[5,\
  \ 7, 9, 11, 13])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
  \        if(eq_deeply($candidate->(6),[6, 8, 10, 12, 14, 16])) {\n        print\
  \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(8),[8,\
  \ 10, 12, 14, 16, 18, 20, 22])) {\n        print \"ok!\" }else{\n        exit 1;\n\
  \        }\n}\n\ntesthumaneval();"
completions: ["    my @res;\n    while($n) {\n        push @res, $n;\n        if ($n\
    \ % 2) {\n            $n = $n + 2;\n        } else {\n            $n = $n + 1;\n\
    \        }\n    }\n    return @res;\n}", "    my @result;\n    while ($n > 0)\
    \ {\n        unshift @result, $n;\n        $n = $n % 2 ? $n + 2 : $n + 1;\n  \
    \  }\n    return @result;\n}", "    my @levels;\n    push @levels, $n;\n    while\
    \ ($n) {\n        $n = $n % 2 ? $n + 2 : $n + 1;\n        push @levels, $n;\n\
    \    }\n    return @levels;\n}", "    my @ret;\n    while($n) {\n        push\
    \ @ret, $n;\n        if ($n % 2) {\n            $n += 2;\n        } else {\n \
    \           $n += 1;\n        }\n    }\n    return @ret;\n}", "    my @ret;\n\
    \    my $stones;\n    for (my $i = 0; $i < $n; $i++) {\n        push @ret, $stones;\n\
    \        $stones += ($i % 2 == 0) ? 2 : 1;\n    }\n    return @ret;\n}", "   \
    \ my $series = {1 => 1};\n    return [1] if $n == 1;\n    my $current = $n;\n\
    \    my @result = ($n);\n    while($current > 1) {\n        $current = $current\
    \ % 2 == 0 ? $current / 2 : ($current + 1) / 2;\n        push @result, $current;\n\
    \    }\n    return \\@result;\n}", "    my @levels;\n    while($n > 0) {\n   \
    \     push @levels, $n;\n        $n = $n % 2 == 0 ? $n - 1 : $n - 2;\n    }\n\
    \    return reverse @levels;\n}", "    return [$n, $n + ($n % 2 ? 2 : 1), $n +\
    \ ($n % 2 ? 4 : 3)];\n}", "    my @pile;\n    my $c = $n;\n    for(my $i = 0;\
    \ $i < $n; $i++) {\n        push @pile, $c;\n        if($c % 2 == 0) {\n     \
    \       $c++;\n        } else {\n            $c--;\n        }\n    }\n    return\
    \ @pile;\n}", "    my @result;\n    while ($n) {\n        push @result, $n;\n\
    \        if ($n % 2) {\n            $n = $n * 2 + 1;\n        } else {\n     \
    \       $n = $n * 2;\n        }\n    }\n    return @result;\n}", "    my @pile;\n\
    \    while ($n > 0) {\n        push @pile, $n;\n        $n = $n % 2 ? $n + 2 :\
    \ $n + 1;\n    }\n    return @pile;\n}", "    my @levels;\n    while ($n > 0)\
    \ {\n        push @levels, $n;\n        if ($n % 2 == 0) {\n            $n--;\n\
    \        } else {\n            $n--;\n            $n--;\n        }\n    }\n  \
    \  return reverse @levels;\n}", "    return [$n, $n + 2, $n + 4];\n}", "    my\
    \ @pile;\n    for my $i (0..$n-1) {\n        push @pile, $n+$i*2;\n    }\n   \
    \ return @pile;\n}", "    my @ret = ( $n );\n    $n += $n % 2 ? 2 : 1;\n    push\
    \ @ret, $n;\n    for (1..4) {\n        $n += $n % 2 ? 2 : 1;\n        push @ret,\
    \ $n;\n    }\n    return @ret;\n}", "    return [\n        map {\n           \
    \ $n++\n        } 1..$n\n    ];\n}", "    my @out;\n    my $i = $n;\n    while\
    \ ($i > 0) {\n        push @out, $i;\n        $i = $i % 2 == 0 ? $i / 2 : ($i\
    \ + 1) / 2;\n    }\n    return @out;\n}", "    my @a;\n    while ($n > 0) {\n\
    \        unshift @a, $n;\n        if ($n % 2 == 0) {\n            $n = $n / 2;\n\
    \        } else {\n            $n = int($n / 2);\n        }\n    }\n    return\
    \ @a;\n}", "    my @pile;\n    while ($n > 0) {\n        push @pile, $n;\n   \
    \     if ($n % 2 == 0) {\n            $n -= 1;\n        } else {\n           \
    \ $n -= 2;\n        }\n    }\n    return reverse @pile;\n}", "    my @result;\n\
    \    while ($n > 0) {\n        unshift @result, $n;\n        if ($n % 2 == 0)\
    \ {\n            $n -= 2;\n        } else {\n            $n -= 1;\n        }\n\
    \    }\n    return @result;\n}"]
stop_tokens:
- "\nsub"
- "\n#"
- "\n\n"
