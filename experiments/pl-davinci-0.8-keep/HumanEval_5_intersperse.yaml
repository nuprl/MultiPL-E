name: HumanEval_5_intersperse
language: pl
prompt: "# Insert a number 'delimeter' between every two consecutive elements of input\
  \ list `numbers'\n# >>> intersperse([], 4)\n# []\n# >>> intersperse([1, 2, 3], 4)\n\
  # [1, 4, 2, 4, 3]\nsub intersperse {\n    my($numbers, $delimeter) = @_;\n"
tests: "use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&intersperse;\n\
  \        if(eq_deeply($candidate->([], 7),[])) {\n        print \"ok!\" }else{\n\
  \        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 6, 3, 2], 8),[5,\
  \ 8, 6, 8, 3, 8, 2])) {\n        print \"ok!\" }else{\n        exit 1;\n       \
  \ }\n        if(eq_deeply($candidate->([2, 2, 2], 2),[2, 2, 2, 2, 2])) {\n     \
  \   print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
completions: ["    my @result = ();\n    for my $number (@$numbers) {\n        push\
    \ @result, $number;\n        push @result, $delimeter;\n    }\n    pop @result;\n\
    \    return @result;\n}", "    my @result = ();\n    for my $i (0 .. $#{$numbers})\
    \ {\n        push @result, $numbers->[$i];\n        push @result, $delimeter if\
    \ $i < $#{$numbers};\n    }\n    return @result;\n}", "    my @result = @$numbers;\n\
    \    for(my $i = 1; $i < @result; $i += 2) {\n        splice(@result, $i, 0, $delimeter);\n\
    \    }\n    return @result;\n}", "    my @result = ();\n    foreach my $number\
    \ (@$numbers) {\n        push @result, $number;\n        push @result, $delimeter\
    \ if @result < @$numbers;\n    }\n    return @result;\n}", "    return if $numbers->@*\
    \ == 0;\n    my @all_numbers = $numbers->@*;\n    my @new_numbers = $all_numbers[0];\n\
    \    for my $i (1..$#all_numbers) {\n        push @new_numbers, $delimeter, $all_numbers[$i];\n\
    \    }\n    return \\@new_numbers;\n}", "    my $result = [];\n    if (@$numbers)\
    \ {\n        push @$result, $numbers->[0];\n        foreach my $i (1 .. $#$numbers)\
    \ {\n            push @$result, $delimeter, $numbers->[$i];\n        }\n    }\n\
    \    return $result;\n}", "    return [] if !@$numbers;\n    return [ $numbers->[0]\
    \ ] if @$numbers == 1;\n    return [ $numbers->[0], $delimeter, @{intersperse([@$numbers[1..$#$numbers]],\
    \ $delimeter)} ];\n}", "    my @result = ();\n    for my $i (0 .. $#{$numbers})\
    \ {\n        push @result, $numbers->[$i];\n        push @result, $delimeter if\
    \ $i != $#{$numbers};\n    }\n    return \\@result;\n}", "    my @result = ();\n\
    \    for my $number (@$numbers) {\n        push @result, $number;\n        push\
    \ @result, $delimeter;\n    }\n    pop @result; # Remove the last element (was\
    \ added by mistake since it's the delimeter)\n    return @result;\n}", "    my\
    \ @result = ();\n    for my $i (0 .. $#{$numbers}) {\n        push @result, $numbers->[$i];\n\
    \        push @result, $delimeter if $i < $#{$numbers};\n    }\n    \\@result;\n\
    }", "    if(@$numbers == 0) {\n        return [];\n    } elsif(@$numbers == 1)\
    \ {\n        return [ $numbers->[0] ];\n    } else {\n        my $head = $numbers->[0];\n\
    \        my $tail = intersperse([ @$numbers[1..$#$numbers] ], $delimeter);\n \
    \       my $res = [ $head ];\n        while(@$tail > 0) {\n            push @$res,\
    \ $delimeter;\n            push @$res, shift @$tail;\n        }\n        return\
    \ $res;\n    }\n}", "    my @new_numbers = ();\n    my $iter = natatime 2, @$numbers;\n\
    \    while (my @pair = $iter->()) {\n        push @new_numbers, @pair;\n     \
    \   push @new_numbers, $delimeter;\n    }\n    pop @new_numbers;\n    return @new_numbers;\n\
    }", "    my @lst = ();\n    for my $i (0 .. $#{$numbers}) {\n        push @lst,\
    \ $numbers->[$i];\n        push @lst, $delimeter if $i != $#{$numbers};\n    }\n\
    \    return \\@lst;\n}", "    return [] if !@$numbers;\n    return [$numbers->[0]]\
    \ if @$numbers == 1;\n    my @interspersed = ($numbers->[0]);\n    for my $i (1\
    \ .. $#$numbers) {\n        push @interspersed, $delimeter, $numbers->[$i];\n\
    \    }\n    return \\@interspersed;\n}", "    if (@$numbers == 0) {\n        return\
    \ @$numbers;\n    } else {\n        return reduce { [@$a, $delimeter, @$b] } @$numbers;\n\
    \    }\n}", "    if (scalar(@$numbers) <= 1) {\n        return $numbers;\n   \
    \ }\n    return [ map {$_, $delimeter} @$numbers[0..(scalar(@$numbers)-2)] ]->append($numbers->[-1]);\n\
    }", "    my @nums = @$numbers;\n    my @result = ();\n    for my $i (0..$#nums)\
    \ {\n        push @result, $nums[$i];\n        push @result, $delimeter if $i\
    \ < $#nums;\n    }\n    return @result;\n}", "    my @interspersed;\n    while\
    \ (@$numbers) {\n        push @interspersed, shift @$numbers;\n        push @interspersed,\
    \ $delimeter if @$numbers;\n    }\n    return @interspersed;\n}", "    ##################################################\n\
    \    # INSERT YOUR CODE HERE\n    my @res = ();\n    foreach my $item (@$numbers)\
    \ {\n        push @res, $item;\n        push @res, $delimeter;\n    }\n    pop\
    \ @res;\n    return @res;\n    ##################################################\n\
    }", "    my @x = ();\n    for my $i (0 .. @$numbers - 2) {\n        push @x, $numbers->[$i];\n\
    \        push @x, $delimeter;\n    }\n    push @x, $numbers->[-1];\n    return\
    \ \\@x;\n}"]
stop_tokens:
- "\nsub"
- "\n#"
- "\n\n"
