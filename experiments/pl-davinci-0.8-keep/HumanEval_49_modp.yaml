name: HumanEval_49_modp
language: pl
prompt: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n# >>>\
  \ modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n# >>> modp(100,\
  \ 101)\n# 1\nsub modp {\n    my($n, $p) = @_;\n"
tests: "use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&modp;\n \
  \       if(eq_deeply($candidate->(3, 5),3)) {\n        print \"ok!\" }else{\n  \
  \      exit 1;\n        }\n        if(eq_deeply($candidate->(1101, 101),2)) {\n\
  \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(0,\
  \ 101),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n       \
  \ if(eq_deeply($candidate->(3, 11),8)) {\n        print \"ok!\" }else{\n       \
  \ exit 1;\n        }\n        if(eq_deeply($candidate->(100, 101),1)) {\n      \
  \  print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(30,\
  \ 5),4)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(31,\
  \ 5),3)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
completions: ["    my $m = 1;\n    my $a = 2;\n    my $b = $n;\n    while ($b > 0)\
    \ {\n        if (($b % 2) == 1) {\n            $m = ($m * $a) % $p;\n        }\n\
    \        $a = ($a * $a) % $p;\n        $b = $b / 2;\n    }\n    return $m;\n}",
  "    my $modp = 1;\n    while ($n > 0) {\n        if ($n % 2 == 1) {\n         \
    \   $modp = ($modp * $n) % $p;\n        }\n        $n = int($n / 2);\n    }\n\
    \    return $modp;\n}", "    $n = $n % $p;\n    $n = $n * $n % $p if 2 * $n >\
    \ $p;\n    $n * $n % $p;\n}", "    my $res = 1;\n    $res = ($res * $n) % $p while\
    \ --$n;\n    $res;\n}", '    # ...', "    # with numerics, modulo is actually\
    \ a remainder, not modulo\n    my $x = $n % $p;\n    return ($x<0) ? $x+$p : $x;\n\
    }", "    # Powers of 2 fast algorithm (with modulo calculus)\n    my $r = 1;\n\
    \    while($n) {\n        $r = ($r * 2) % $p if $n & 1;\n        $n >>= 1;\n \
    \   }\n    return $r;\n}", "    my $res = 1;\n    my $i = 0;\n    my $inv = 1/$p;\n\
    \    while ($n > 0) {\n        $res = ($res * (($n & 1) ? $modp_table[$i] : 1))\
    \ % $p;\n        $n >>= 1;\n        $i++;\n    }\n    return $res;\n}", "    my\
    \ $r = 1;\n    while ($n != 0) {\n        $r = ($r * 2) % $p if $n & 1;\n    \
    \    $n >>= 1;\n    }\n    return $r;\n}", "    my($x) = 1;\n    my($t) = 2;\n\
    \    while ($n > 0) {\n\tif ($n & 1) {\n\t    $x = ($x * $t) % $p;\n\t}\n\t$t\
    \ = ($t * $t) % $p;\n\t$n >>= 1;\n    }\n    return $x;\n}", "    die \"modp called\
    \ with bad input: $n\" if $n < 0;\n    die \"modp called with bad input: $p\"\
    \ if $p < 2;\n    return 0 if $n == 0;\n    return 1 if $n == 1 || $n == $p-1;\n\
    \    return 2 if $n == 2 || $n == $p-2;\n    # For what follows, see H. Cohen,\
    \ A Course in Computational Algebraic\n    # Number Theory, section 4.1.1\n  \
    \  my($a, $p_1) = ($n, $p-1);\n    my $s = 0;\n    while($p_1 % 2 == 0) {\n\t\
    $p_1 /= 2;\n\t$s++;\n    }\n    my $p_1_1 = int($p_1/2);\n    my $d = modp($a,\
    \ $p_1);\n    return $d if $d == 1 || $d == $p_1;\n    if($s == 1) {\n\treturn\
    \ ($d * $d) % $p;\n    }\n    for(my $r = 1; $r <= $s-1; $r++) {\n\treturn ($d\
    \ * $d) % $p if modp($d, 2<<$r) == $p_1;\n    }\n    return ($d * $d * $a) % $p;\n\
    }", "    if ($n < $p) {\n        return $n;\n    }\n    my $r = $n % $p;\n   \
    \ if ($r > ($p >> 1)) {\n        $r -= $p;\n    }\n    return $r;\n}", "    return\
    \ 1 if $n == 0;\n    my $r = 1;\n    $r = $r * 2 % $p if $n % 2;\n    $r = $r\
    \ * modp($n / 2, $p) % $p;\n    return $r;\n}", "    my $r = 1;\n    while ($n)\
    \ {\n        if ($n & 1) {\n            $r = ($r * $n) % $p;\n        }\n    \
    \    $n >>= 1;\n    }\n    return $r;\n}", "    croak \"modp(): modulus is zero\"\
    \ if $p == 0;\n    croak \"modp(): exponent is negative\" if $n < 0;\n    return\
    \ 1 if $n == 0;\n    my $r = 1;\n    my $x = 2;\n    my $b = $n;\n    while ($b\
    \ > 0) {\n        if (($b % 2) == 1) {\n            $r = ($r * $x) % $p;\n   \
    \     }\n        $x = ($x * $x) % $p;\n        $b = int($b / 2);\n    }\n    return\
    \ $r;\n}", "    return 0 if $n == 0;\n    return 1 if $n == 1;\n    my $x = modp($n/2,\
    \ $p);\n    $x = ($x * $x) % $p;\n    $x = ($x * 2) % $p if $n % 2 == 1;\n   \
    \ return $x;\n}", "    my $r = 1;\n    $n %= $p;\n    for (my $k = 1; $k <= $n;\
    \ $k++) {\n        $r = ($r * 2) % $p;\n    }\n    return $r;\n}", "    my $val\
    \ = 1;\n    my $x = 2;\n    for (my $i = 0; $i < $n; $i++) {\n        $val = ($val\
    \ * $x) % $p;\n    }\n    return $val;\n}", "    return 1 if $n == 0;\n    return\
    \ modp(2*$n, $p) if $n % 2 == 0;\n    return (2*modp($n-1, $p)) % $p;\n}", " \
    \   if ($n == 0) {\n        return 1;\n    }\n    elsif ($n % 2 == 0) {\n    \
    \    return (modp($n / 2, $p) ** 2) % $p;\n    }\n    else {\n        return ((modp($n\
    \ / 2, $p) ** 2) * 2) % $p;\n    }\n}"]
stop_tokens:
- "\nsub"
- "\n#"
- "\n\n"
