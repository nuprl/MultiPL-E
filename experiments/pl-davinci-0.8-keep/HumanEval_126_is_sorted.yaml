name: HumanEval_126_is_sorted
language: pl
prompt: "# Given a list of numbers, return whether or not they are sorted\n# in ascending\
  \ order. If list has more than 1 duplicate of the same\n# number, return False.\
  \ Assume no negative numbers and only integers.\n# Examples\n# is_sorted([5]) \u279E\
  \ True\n# is_sorted([1, 2, 3, 4, 5]) \u279E True\n# is_sorted([1, 3, 2, 4, 5]) \u279E\
  \ False\n# is_sorted([1, 2, 3, 4, 5, 6]) \u279E True\n# is_sorted([1, 2, 3, 4, 5,\
  \ 6, 7]) \u279E True\n# is_sorted([1, 3, 2, 4, 5, 6, 7]) \u279E False\n# is_sorted([1,\
  \ 2, 2, 3, 3, 4]) \u279E True\n# is_sorted([1, 2, 2, 2, 3, 4]) \u279E False\nsub\
  \ is_sorted {\n    my($lst) = @_;\n"
tests: "use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&is_sorted;\n\
  \        if(eq_deeply($candidate->([5]),1)) {\n        print \"ok!\" }else{\n  \
  \      exit 1;\n        }\n        if(eq_deeply($candidate->([1, 2, 3, 4, 5]),1))\
  \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1,\
  \ 3, 2, 4, 5]),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n       \
  \ }\n        if(eq_deeply($candidate->([1, 2, 3, 4, 5, 6]),1)) {\n        print\
  \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1,\
  \ 2, 3, 4, 5, 6, 7]),1)) {\n        print \"ok!\" }else{\n        exit 1;\n    \
  \    }\n        if(eq_deeply($candidate->([1, 3, 2, 4, 5, 6, 7]),\"\")) {\n    \
  \    print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([]),1))\
  \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1]),1))\
  \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([3,\
  \ 2, 1]),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n  \
  \      if(eq_deeply($candidate->([1, 2, 2, 2, 3, 4]),\"\")) {\n        print \"\
  ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1,\
  \ 2, 3, 3, 3, 4]),\"\")) {\n        print \"ok!\" }else{\n        exit 1;\n    \
  \    }\n        if(eq_deeply($candidate->([1, 2, 2, 3, 3, 4]),1)) {\n        print\
  \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1,\
  \ 2, 3, 4]),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\
  \ntesthumaneval();"
completions: ["    my $m = $lst->[0];\n    my $pre = -1;\n    for my $n (@$lst) {\n\
    \        if ($n == $pre) {\n            return 0;\n        }\n        if ($n <\
    \ $m) {\n            return 0;\n        }\n        $pre = $n;\n    }\n    return\
    \ 1;\n}", "    return 1 if !@$lst;\n    my($cur, $prev) = (undef, undef);\n  \
    \  for my $e (@$lst) {\n        $cur = $e;\n        return 0 if defined $prev\
    \ && $cur == $prev;\n        return 0 if defined $prev && $cur < $prev;\n    \
    \    $prev = $cur;\n    }\n    return 1;\n}", "    my($prev);\n    foreach my\
    \ $i (@$lst) {\n        if(defined($prev) && $i <= $prev) {\n            return\
    \ 0;\n        }\n        $prev = $i;\n    }\n    return 1;\n}", "    for my $i\
    \ (1..@$lst-1) {\n        return 0 if $lst->[$i-1] >= $lst->[$i];\n    }\n   \
    \ return 1;\n}", "    my $cur = 0;\n    for my $val (@$lst) {\n        return\
    \ 0 if $val == $cur;\n        $cur = $val;\n    }\n    return 1;\n}", "    my($last)\
    \ = shift @$lst;\n    for (@$lst) {\n        return False if $last eq $_;\n  \
    \      return False if $last gt $_;\n        $last = $_;\n    }\n    return True;\n\
    }", "    my @arr = @$lst;\n    my $j=0;\n    my $i=0;\n    my $pre=0;\n    my\
    \ $cur=0;\n    my %count=();\n    while($i<@arr) {\n        $pre=$arr[$i];\n \
    \       $cur=$arr[$i+1];\n        if($cur<$pre) {\n            return 0;\n   \
    \     }\n        $i++;\n    }\n    foreach $j(@arr) {\n        $count{$j}++;\n\
    \    }\n    foreach $j(values %count) {\n        if($j>1) {\n            return\
    \ 0;\n        }\n    }\n    return 1;\n}\nmy @arr1 = (1,2,3,4,5);\nmy @arr2 =\
    \ (1,2,2,3,4);\nmy @arr3 = (1,2,3,4,5,6);\nmy @arr4 = (1,3,2,4,5);\nmy @arr5 =\
    \ (1,2,2,2,3,4);\nprint(is_sorted(\\@arr1), \"\\n\");\nprint(is_sorted(\\@arr2),\
    \ \"\\n\");\nprint(is_sorted(\\@arr3), \"\\n\");\nprint(is_sorted(\\@arr4), \"\
    \\n\");\nprint(is_sorted(\\@arr5), \"\\n\");", "    my %found = ();\n    my @srt\
    \ = sort {$a <=> $b} @$lst;\n    foreach (@srt) { $found{$_}++ }\n    if (scalar\
    \ keys %found == scalar @srt) {\n        return \"True\";\n    } else {\n    \
    \    return \"False\";\n    }\n}\nprint is_sorted([1, 2, 2, 3, 3, 4]);", "   \
    \ return 0 if (scalar(@$lst) < 2);\n    my $sorted = 1;\n    my $prev = $lst->[0];\n\
    \    foreach my $x (@$lst[1..$#$lst]) {\n        return 0 if ($x == $prev);\n\
    \        $sorted &= ($x > $prev);\n        $prev = $x;\n    }\n    return $sorted;\n\
    }", "    my $len = scalar @$lst;\n    my $prev = $lst->[0];\n    for my $i (1..$len-1)\
    \ {\n        if ($lst->[$i] < $prev) {\n            return 0;\n        }\n   \
    \     $prev = $lst->[$i];\n    }\n    return 1;\n}", "    if (scalar @$lst ==\
    \ 1) {\n        return 1;\n    }\n    for my $i (0..(scalar @$lst-2)) {\n    \
    \    if ($lst->[$i] >= $lst->[$i+1]) {\n            return 0;\n        }\n   \
    \ }\n    return 1;\n}", "    return undef unless(@$lst > 1);\n    my $prev = $lst->[0];\n\
    \    for my $i (1..@$lst-1) {\n        return undef if($lst->[$i] <= $prev);\n\
    \        $prev = $lst->[$i];\n    }\n    return 1;\n}", "    my $pre = $lst->[0];\n\
    \    for my $cur (@$lst) {\n        return 0 if $pre > $cur;\n        $pre = $cur;\n\
    \    }\n    return 1;\n}", "    my $len = $#{$lst};\n    for (0..$len) {\n   \
    \     if ($_ > 0) {\n            return 0 if $lst->[$_] < $lst->[$_-1];\n    \
    \    }\n    }\n    return 1;\n}", "    # your code goes here\n}", "    my $prev\
    \ = 0;\n    for my $i (0..@$lst-1) {\n        return 0 if $i && $$lst[$i] == $prev;\n\
    \        return 0 if $i && $$lst[$i] < $prev;\n        $prev = $$lst[$i];\n  \
    \  }\n    return 1;\n}", "    my @sorted = sort {$a <=> $b} @$lst;\n    return\
    \ are_equal($lst, \\@sorted);\n}", "    my $prev = shift @$lst;\n    for my $curr\
    \ (@$lst) {\n        return 0 if $curr <= $prev;\n        $prev = $curr;\n   \
    \ }\n    return 1;\n}", "    my @sorted = sort {$a <=> $b} @$lst;\n    for (my\
    \ $i = 0; $i < scalar @$lst; $i++) {\n        return 0 if $lst->[$i] != $sorted[$i];\n\
    \    }\n    return 1;\n}", "    return false unless is_array($lst);\n    my @lst\
    \ = @$lst;\n    return true if @lst == 1;\n    my %h;\n    for (@lst) {\n    \
    \    my $v = $_;\n        return false if exists $h{$v};\n        $h{$v} = 1;\n\
    \    }\n    my $prev = $lst[0];\n    for my $v (@lst[1..$#lst]) {\n        return\
    \ false if $v < $prev;\n        $prev = $v;\n    }\n    return true;\n}"]
stop_tokens:
- "\nsub"
- "\n#"
- "\n\n"
