name: HumanEval_107_even_odd_palindrome
language: pl
prompt: "# Given a positive integer n, return a tuple that has the number of even\
  \ and odd\n# integer palindromes that fall within the range(1, n), inclusive.\n\
  # Example 1:\n# Input: 3\n# Output: (1, 2)\n# Explanation:\n# Integer palindrome\
  \ are 1, 2, 3. one of them is even, and two of them are odd.\n# Example 2:\n# Input:\
  \ 12\n# Output: (4, 6)\n# Explanation:\n# Integer palindrome are 1, 2, 3, 4, 5,\
  \ 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n# Note:\n# 1. 1\
  \ <= n <= 10^3\n# 2. returned tuple has the number of even and odd integer palindromes\
  \ respectively.\nsub even_odd_palindrome {\n    my($n) = @_;\n"
tests: "use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&even_odd_palindrome;\n\
  \        if(eq_deeply($candidate->(123),[8, 13])) {\n        print \"ok!\" }else{\n\
  \        exit 1;\n        }\n        if(eq_deeply($candidate->(12),[4, 6])) {\n\
  \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(3),[1,\
  \ 2])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(63),[6,\
  \ 8])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(25),[5,\
  \ 6])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(19),[4,\
  \ 6])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(9),[4,\
  \ 5])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(1),[0,\
  \ 1])) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
completions: ["    if ($n <= 2) {\n        return (0, $n);\n    }\n    my @return\
    \ = ();\n    push @return, int($n / 2) + 1;\n    push @return, $n - $return[0];\n\
    \    return @return;\n}", "    my @res = (0, 0);\n    foreach my $i (1..$n) {\n\
    \        my $j = reverse($i);\n        next if $i != $j;\n        ++$res[0] if\
    \ $i % 2 == 0;\n        ++$res[1] if $i % 2 == 1;\n    }\n    return @res;\n}",
  "    my($even, $odd) = (0, 0);\n    foreach my $k (1..$n) {\n        if ($k == reverse($k))\
    \ {\n            if ($k % 2 == 0) {\n                $even++;\n            } else\
    \ {\n                $odd++;\n            }\n        }\n    }\n    return ($even,\
    \ $odd);\n}", "    my($e, $o) = (0, 0);\n    # sz: len of number of digits\n \
    \   # dv: digits of the number\n    for (my $sz = 1; $sz <= length($n); $sz++)\
    \ {\n        if ($sz % 2 == 0) {\n            # even number of digits\n      \
    \      # $e += 9 * 10 ** int(($sz - 2) / 2);\n            $e += $sz == 2 ? 1 :\
    \ 9 * 10 ** int(($sz - 2) / 2);\n        } else {\n            # odd number of\
    \ digits\n            # $o += 9 * 10 ** int(($sz - 1) / 2);\n            $o +=\
    \ $sz == 1 ? 1 : 9 * 10 ** int(($sz - 1) / 2);\n        }\n    }\n    return($e,\
    \ $o);\n}", "    my $cnt_even = 0;\n    my $cnt_odd = 0;\n    foreach my $i (1..$n)\
    \ {\n        if (is_palindrome($i)) {\n            if ($i % 2 == 0) {\n      \
    \          $cnt_even++;\n            } else {\n                $cnt_odd++;\n \
    \           }\n        }\n    }\n    return [$cnt_even, $cnt_odd];\n}", "    my\
    \ $even_cnt = 0;\n    my $odd_cnt = 0;\n    for (my $i = 1; $i <= $n; $i++) {\n\
    \        if ($i <= 9) {\n            $odd_cnt++;\n        } elsif ($i >= 10 &&\
    \ $i <= 99) {\n            $even_cnt++;\n        } elsif ($i >= 100 && $i <= 999)\
    \ {\n            if ($i % 11 == 0) {\n                $odd_cnt++;\n          \
    \  } else {\n                $even_cnt++;\n            }\n        }\n    }\n \
    \   return ($even_cnt, $odd_cnt);\n}\nforeach my $n (3, 12) {\n    my ($even_cnt,\
    \ $odd_cnt) = even_odd_palindrome($n);\n    print \"$even_cnt, $odd_cnt\\n\";\n\
    }", "    my $even = int(sqrt($n));\n    my $odd = int(($n - $even) / 2);\n   \
    \ return ($even, $odd);\n}", "    if ($n == 1) {\n        return (1, 0);\n   \
    \ }", "    my $even = 0;\n    my $odd = 0;\n    for my $i (1..$n) {\n        if\
    \ (is_palindrome($i)) {\n            if ($i % 2 == 0) {\n                $even++;\n\
    \            } else {\n                $odd++;\n            }\n        }\n   \
    \ }\n    return ($even, $odd);\n}", "    my $count_even = 0;\n    my $count_odd\
    \ = 0;\n    for (1..$n) {\n        my $palindrome = $_;\n        my $reversed\
    \ = 0;\n        my $num = $_;\n        while ($num > 0) {\n            $reversed\
    \ = 10 * $reversed + $num % 10;\n            $num /= 10;\n        }\n        if\
    \ ($palindrome == $reversed) {\n            if ($palindrome % 2 == 0) {\n    \
    \            $count_even++;\n            } else {\n                $count_odd++;\n\
    \            }\n        }\n    }\n    return ($count_even, $count_odd);\n}\nprint\
    \ Dumper even_odd_palindrome(3);\nprint Dumper even_odd_palindrome(12);", "  \
    \  my($even, $odd) = (0, 0);\n    my $end = int(sqrt($n));\n    for (my $i = 1;\
    \ $i <= $end; $i++) {\n        if ($i % 10 != 0) {\n            my $num = $i;\n\
    \            my $temp = 0;\n            my $count = 0;\n            while ($num\
    \ > 0) {\n                $temp = $temp * 10 + $num % 10;\n                $num\
    \ = int($num / 10);\n                $count++;\n            }\n            if\
    \ ($temp > $n) {\n                next;\n            }\n            if ($count\
    \ & 1) {\n                $odd++;\n            } else {\n                $even++;\n\
    \            }\n        }\n    }\n    return ($even, $odd);\n}", "    my $count\
    \ = 1;\n    my($odd, $even) = (1, 0);\n    for (2..$n) {\n        $count = 0;\n\
    \        my @digits = split('', $_);\n        for (0..$#digits) {\n          \
    \  my $left = $digits[$_];\n            my $right = $digits[-$_ - 1];\n      \
    \      last if $left != $right;\n            $count++ if $left == $right;\n  \
    \      }\n        $odd++ if $count % 2 == 1;\n        $even++ if $count % 2 ==\
    \ 0;\n    }\n    return ($even, $odd);\n}", "    if($n <= 1) {\n        return\
    \ (0, 1);\n    }", "    my @res = (0, 0);\n    for my $i (1..$n) {\n        my\
    \ $j = $i;\n        my $k = 0;\n        while ($j) {\n            $k = $k * 10\
    \ + $j % 10;\n            $j /= 10;\n        }\n        if ($k == $i) {\n    \
    \        $res[$i % 2]++;\n        }\n    }\n    return @res;\n}\nprint Dumper(even_odd_palindrome(3));\n\
    print Dumper(even_odd_palindrome(12));", "    my($odd, $even) = (0, 0);\n    my($i,\
    \ $j, $k);\n    for($i = 1; $i <= $n; $i++) {\n        my($isPalindrome) = 1;\n\
    \        $j = $i;\n        $k = 0;\n        while($j > 0) {\n            $k =\
    \ $k * 10 + $j % 10;\n            $j = int($j / 10);\n        }\n        if($k\
    \ != $i) {\n            $isPalindrome = 0;\n        }\n        if($isPalindrome)\
    \ {\n            if($i % 2 == 0) {\n                $even++;\n            } else\
    \ {\n                $odd++;\n            }\n        }\n    }\n    return ($even,\
    \ $odd);\n}", "    my $odd = 0;\n    my $even = 0;\n    for(my $i = 1; $i <= $n;\
    \ $i++) {\n        if($i < 10) {\n            $odd++;\n        }\n        elsif($i\
    \ % 10 == 0) {\n            $even++;\n        }\n        elsif(is_palindrome($i))\
    \ {\n            if($i % 2 == 0) {\n                $even++;\n            }\n\
    \            else {\n                $odd++;\n            }\n        }\n    }\n\
    \    return ($even, $odd);\n}", "    my $odd = 0;\n    my $even = 0;\n    for\
    \ my $i (1..$n) {\n        if (is_palindrome($i)) {\n            if ($i % 2 ==\
    \ 0) {\n                $even++;\n            } else {\n                $odd++;\n\
    \            }\n        }\n    }\n    return ($even, $odd);\n}", "    my @ret\
    \ = (0, 0);\n    my $i = 1;\n    while ($i <= $n) {\n        if ($i <= 9) {\n\
    \            $ret[1] ++;\n        } elsif ($i == 11) {\n            $ret[0] ++;\n\
    \        } elsif ($i % 2 == 0) {\n            my $tmp = $i;\n            my $reverse\
    \ = 0;\n            while ($tmp > 0) {\n                $reverse = $reverse *\
    \ 10 + $tmp % 10;\n                $tmp /= 10;\n            }\n            if\
    \ ($reverse == $i) {\n                $ret[0] ++;\n            }\n        } else\
    \ {\n            my $tmp = $i;\n            my $reverse = 0;\n            while\
    \ ($tmp > 0) {\n                $reverse = $reverse * 10 + $tmp % 10;\n      \
    \          $tmp /= 10;\n            }\n            if ($reverse == $i) {\n   \
    \             $ret[1] ++;\n            }\n        }\n        $i ++;\n    }\n \
    \   return @ret;\n}", "    if ($n < 10) {\n        return ($n % 2 == 0, $n % 2\
    \ == 1);\n    }\n    my($even, $odd) = (0, 0);\n    # first consider the last\
    \ digit\n    for my $i (0 .. 9) {\n        if ($i % 2 == 0) {\n            $even++;\n\
    \        } else {\n            $odd++;\n        }\n    }\n    # then consider\
    \ the last two digits\n    for my $i (10 .. 99) {\n        if ($i % 2 == 0) {\n\
    \            $even++;\n        } else {\n            $odd++;\n        }\n    }\n\
    \    # then consider the last three digits\n    for my $i (100 .. 999) {\n   \
    \     if ($i % 2 == 0) {\n            $even++;\n        } else {\n           \
    \ $odd++;\n        }\n    }\n    return ($even, $odd);\n}", "    my($c) = 0;\n\
    \    my($d) = 0;\n    for(my($i) = 1; $i <= $n; $i++) {\n        if($i == 1 ||\
    \ $i == 3 || $i == 5 || $i == 7 || $i == 9) {\n            $d++;\n        }\n\
    \        elsif($i == 2 || $i == 4 || $i == 6 || $i == 8 || $i == 11) {\n     \
    \       $c++;\n        }\n        elsif($i == 10) {\n            $d++;\n     \
    \   }\n        else {\n            my($p) = $i;\n            my($q) = $i;\n  \
    \          my($cnt) = 0;\n            while($p > 0) {\n                $cnt =\
    \ $cnt * 10 + $p % 10;\n                $p = int($p / 10);\n            }\n  \
    \          if($cnt == $q) {\n                if($q == 11 || $q == 22 || $q ==\
    \ 33 || $q == 44 || $q == 55 || $q == 66 || $q == 77 || $q == 88 || $q == 99)\
    \ {\n                    $d++;\n                }\n                else {\n  \
    \                  $c++;\n                }\n            }\n        }\n    }\n\
    \    return ($c, $d);\n}\n1;"]
stop_tokens:
- "\nsub"
- "\n#"
- "\n\n"
