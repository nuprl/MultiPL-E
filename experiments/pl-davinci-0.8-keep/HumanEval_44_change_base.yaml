name: HumanEval_44_change_base
language: pl
prompt: "# Change numerical base of input number x to base.\n# return string representation\
  \ after the conversion.\n# base numbers are less than 10.\n# >>> change_base(8,\
  \ 3)\n# '22'\n# >>> change_base(8, 2)\n# '1000'\n# >>> change_base(7, 2)\n# '111'\n\
  sub change_base {\n    my($x, $base) = @_;\n"
tests: "use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&change_base;\n\
  \        if(eq_deeply($candidate->(8, 3),\"22\")) {\n        print \"ok!\" }else{\n\
  \        exit 1;\n        }\n        if(eq_deeply($candidate->(9, 3),\"100\")) {\n\
  \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(234,\
  \ 2),\"11101010\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
  \        if(eq_deeply($candidate->(16, 2),\"10000\")) {\n        print \"ok!\" }else{\n\
  \        exit 1;\n        }\n        if(eq_deeply($candidate->(8, 2),\"1000\"))\
  \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(7,\
  \ 2),\"111\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n   \
  \     if(eq_deeply($candidate->(2, 3),\"2\")) {\n        print \"ok!\" }else{\n\
  \        exit 1;\n        }\n        if(eq_deeply($candidate->(3, 4),\"3\")) {\n\
  \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(4,\
  \ 5),\"4\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
  \   if(eq_deeply($candidate->(5, 6),\"5\")) {\n        print \"ok!\" }else{\n  \
  \      exit 1;\n        }\n        if(eq_deeply($candidate->(6, 7),\"6\")) {\n \
  \       print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(7,\
  \ 8),\"7\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\n\
  testhumaneval();"
completions: ["    my @stack;\n    while ($x > 0) {\n        push @stack, $x % $base;\n\
    \        $x = int($x / $base);\n    }\n    return join('', reverse @stack);\n}",
  "    die \"bad number\" if $x < 0;\n    my @result;\n    while ($x > 0) {\n    \
    \    push @result, $x % $base;\n        $x = int($x / $base);\n    }\n    return\
    \ join('', reverse @result);\n}", "    my $result = '';\n    while($x != 0) {\n\
    \        my $next = $x % $base;\n        $result = $next . $result;\n        $x\
    \ /= $base;\n    }\n    return $result;\n}", "    my $s = \"\";\n    if($x ==\
    \ 0) {\n        return \"0\";\n    } else {\n        while($x > 0) {\n       \
    \     $s = ($x % $base).$s;\n            $x = floor($x / $base);\n        }\n\
    \        return $s;\n    }\n}", "    my @nums = split //, $x;\n    my $sum = 0;\n\
    \    my $magnitude = scalar @nums - 1;\n    for (@nums) {\n        $sum += $_\
    \ * ($base ** $magnitude);\n        $magnitude--;\n    }\n    return $sum;\n}",
  "    my @digits = ();\n    my $d;\n    while ($x > 0) {\n        $d = $x % $base;\n\
    \        push @digits, $d;\n        $x = int($x / $base);\n    }\n    my $s =\
    \ join('', reverse @digits);\n    return $s;\n}", "    return join \"\", (reverse(map\
    \ {$_ % $base} $x + 0, recursive_divide($x, $base)));\n}", "    my $ans = '';\n\
    \    while($x >= $base) {\n        $ans = ($x % $base) . $ans;\n        $x = int($x\
    \ / $base);\n    }\n    return $x . $ans;\n}", "    $x =~ s/(\\d+)/dec_to_base($1,\
    \ $base)/ge;\n    return $x;\n}", "    my $r;\n    my $r1;\n    my $ret;\n   \
    \ do {\n        $r = $x % $base;\n        $x = int($x / $base);\n        $r1 =\
    \ sprintf(\"%02d\", $r);\n        $ret = \"$r1$ret\";\n    } while ($x > 0);\n\
    \    $ret;\n}", "    my $result = '';\n    for (my $i = $x; $i > 0; $i = int($i\
    \ / $base)) {\n        $result = ($i % $base) . $result;\n    }\n    return $result;\n\
    }", "    my $str = '';\n    while ($x > 0) {\n        $str = sprintf(\"%d\", $x\
    \ % $base) . $str;\n        $x = int($x / $base);\n    }\n    return $str;\n}",
  "    my $s = '';\n    while ($x >= $base) {\n        $s = ($x % $base) . $s;\n \
    \       $x = int($x / $base);\n    }\n    $s = $x . $s;\n    return $s;\n}", " \
    \   my $r;\n    my $rbase = 0;\n    do {\n        my $cur = $x % $base;\n    \
    \    $rbase = $cur + $rbase * 10;\n        $x /= $base;\n    } while ($x);\n \
    \   $r = $rbase;\n    $r;\n}", "    return '' if($x == 0);\n    my $r;\n    while($x)\
    \ {\n        $r = ($x % $base) . $r;\n        $x = int($x / $base);\n    }\n \
    \   return $r;\n}", "    die \"base(=$base) has to be 1-9.\" if ( $base > 9 );\n\
    \    my @chars = qw/0 1 2 3 4 5 6 7 8 9/;\n    my $base_str = $chars[$base];\n\
    \    if ($x == 0) {\n        return '0';\n    }\n    my $result = '';\n    while\
    \ ($x > 0) {\n        my $rem = $x % $base;\n        $result = $chars[$rem] .\
    \ $result;\n        $x = int( $x / $base );\n    }\n    return $result;\n}", " \
    \   my $ret = '';\n    while ($x) {\n        $ret = $x % $base . $ret;\n     \
    \   $x = int($x / $base);\n    }\n    return $ret;\n}", "    my $res = \"\";\n\
    \    while($x != 0) {\n        my $rem = $x % $base;\n        $res = $rem . $res;\n\
    \        $x = $x / $base;\n    }\n    return $res;\n}", "    my($y);\n    my($num);\n\
    \    my($val);\n    my($rem);\n    my($quot);\n    $y = '';\n    $num = $x;\n\
    \    while ($num != 0) {\n        $quot = $num / $base;\n        $rem = $num %\
    \ $base;\n        $num = $quot;\n        $val = $rem;\n        $y = $val . $y;\n\
    \    }\n    return $y;\n}", '    my $n = int($x);']
stop_tokens:
- "\nsub"
- "\n#"
- "\n\n"
