name: HumanEval_24_largest_divisor
language: pl
prompt: "# For a given number n, find the largest number that divides n evenly, smaller\
  \ than n\n# >>> largest_divisor(15)\n# 5\nsub largest_divisor {\n    my($n) = @_;\n"
tests: "use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&largest_divisor;\n\
  \        if(eq_deeply($candidate->(3),1)) {\n        print \"ok!\" }else{\n    \
  \    exit 1;\n        }\n        if(eq_deeply($candidate->(7),1)) {\n        print\
  \ \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(10),5))\
  \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(100),50))\
  \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(49),7))\
  \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
completions: ["    my $d = int($n / 2);\n    while ($d > 1) {\n        return $d if\
    \ ($n % $d == 0);\n        $d--;\n    }\n    return 1;\n}", "    for my $i (reverse(2..$n-1))\
    \ {\n        return $i if ($n % $i == 0);\n    }\n    return 1;\n}", "    die(\"\
    Not a positive integer\") unless($n > 0 && $n == int($n));\n    my $max = 1;\n\
    \    for my $i (2..int(sqrt($n))) {\n        $max = $i if($n % $i == 0);\n   \
    \ }\n    return $max;\n}", "    my $i = 2;\n    while($i < $n) {\n        if($n\
    \ % $i == 0) {\n            return $i;\n        }\n        $i++;\n    }\n    return\
    \ 1;\n}", "    my $i = 1;\n    while ($i < $n) {\n        if ($n % $i == 0) {\n\
    \            $largest = $i;\n        }\n        $i++;\n    }\n    return $largest;\n\
    }", "    my $largest = 1;\n    for my $i (2..int($n/2)) {\n        if ( $n % $i\
    \ == 0 ) {\n            $largest = $i;\n        }\n    }\n    return $largest;\n\
    }", "    return $n if $n == 1;\n    return $n/2 if $n % 2 == 0;\n    my $i = 3;\n\
    \    while ($i <= sqrt($n)) {\n        return $n/$i if $n % $i == 0;\n       \
    \ $i += 2;\n    }\n    return 1;\n}", "    return 0 if $n <= 0;\n    foreach (reverse(1..int($n/2)))\
    \ {\n        return $_ if $n % $_ == 0;\n    }\n    return 1;\n}", "    foreach\
    \ (reverse 2..$n-1) {\n        return $_ if $n % $_ == 0;\n    }\n    die \"No\
    \ divisor found for $n\";\n}", "    my $divisor = $n - 1;\n    my $remainder =\
    \ $n % $divisor;\n    while ($remainder != 0) {\n        $divisor -= 1;\n    \
    \    $remainder = $n % $divisor;\n    }\n    return $divisor;\n}", "    for (my\
    \ $d = int(sqrt($n)); $d > 0; $d--) {\n        return $d if $n % $d == 0;\n  \
    \  }\n    return 1;\n}", "    if ($n <= 0) {\n        croak \"largest_divisor:\
    \ input must be a positive integer\";\n    }\n    if ($n == 1) {\n        return\
    \ 0;\n    }\n    my $start = int(sqrt($n));\n    while (1) {\n        if ($n %\
    \ $start == 0) {\n            return $start;\n        }\n        $start--;\n \
    \   }\n}", "    for my $i (reverse 2..sqrt($n)) {\n        return $i if $n % $i\
    \ == 0;\n    }\n    return 1;\n}", "    my $divisor = $n;\n    while($divisor\
    \ > 1) {\n        $divisor--;\n        return $divisor if($n % $divisor == 0);\n\
    \    }\n}", "    my $largest = 0;\n    for my $i (2..$n-1) {\n        if($n %\
    \ $i == 0) {\n            $largest = $i;\n        }\n    }\n    return $largest;\n\
    }", "    my $largest = 0;\n    for my $i ( 1 .. $n-1 ) {\n        $largest = $i\
    \ if $n % $i == 0;\n    }\n    return $largest;\n}", "    my $end = int(sqrt($n));\n\
    \    my $i = $end;\n    for(; $i > 1; $i--) {\n        if($n % $i == 0) {\n  \
    \          return $i;\n        }\n    }\n    return $n;\n}", "    return 1 if($n\
    \ <= 1);\n    my $i = $n - 1;\n    while($i >= 1) {\n        if($n % $i == 0)\
    \ {\n            return $i;\n        }\n        $i--;\n    }\n}", "    foreach\
    \ my $i (2..($n/2)) {\n        return $i if $n % $i == 0;\n    }\n    return 1;\n\
    }", "    my $divisor = $n - 1;\n    while ($divisor > 0) {\n        if ($n % $divisor\
    \ == 0) {\n            return $divisor;\n        }\n        $divisor--;\n    }\n\
    }"]
stop_tokens:
- "\nsub"
- "\n#"
- "\n\n"
