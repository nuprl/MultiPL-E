name: HumanEval_58_common
language: pl
prompt: "# Return sorted unique common elements for two lists.\n# >>> common([1, 4,\
  \ 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n# [1, 5, 653]\n# >>> common([5,\
  \ 3, 2, 8], [3, 2])\n# [2, 3]\nsub common {\n    my($l1, $l2) = @_;\n"
tests: "use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&common;\n\
  \        if(eq_deeply($candidate->([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653,\
  \ 121]),[1, 5, 653])) {\n        print \"ok!\" }else{\n        exit 1;\n       \
  \ }\n        if(eq_deeply($candidate->([5, 3, 2, 8], [3, 2]),[2, 3])) {\n      \
  \  print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([4,\
  \ 3, 2, 8], [3, 2, 4]),[2, 3, 4])) {\n        print \"ok!\" }else{\n        exit\
  \ 1;\n        }\n        if(eq_deeply($candidate->([4, 3, 2, 8], []),[])) {\n  \
  \      print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
completions: ["    my %m;\n    grep { $m{$_}++ } @$l1;\n    my @l3 = grep { $m{$_}\
    \ } @$l2;\n    my %m2;\n    grep { $m2{$_}++ } @l3;\n    return keys %m2;\n}",
  "    my %h;\n    foreach my $i (@$l1) {\n        $h{$i}++;\n    }\n    my @common;\n\
    \    foreach my $i (@$l2) {\n        if (--$h{$i} >= 0) {\n            push @common,\
    \ $i;\n        }\n    }\n    return @common;\n}", "    my %h = ();\n    grep !$h{$_}++,\
    \ (@$l1, @$l2);\n}", "    my $l3 = [sort {$a <=> $b} keys %{{map {$_ => 1} @$l1,\
    \ @$l2}}];\n    return @$l3;\n}", "    my %uniq;\n    ++$uniq{$_} for (@$l1, @$l2);\n\
    \    return sort grep { $uniq{$_} > 1 } keys %uniq;\n}", "    my %hash = map {\
    \ $_ => 1 } @$l1;\n    my @common = grep { $hash{$_} } @$l2;\n    return uniq(@common);\n\
    }", "    my %seen;\n    return sort grep { !$seen{$_}++ } (@$l1, @$l2);\n}", " \
    \   my %h;\n    @h{@$l1} = @$l1;\n    @h{@$l2} = grep { exists $h{$_} } @$l2;\n\
    \    return [keys %h];\n}", "    my %h = ();\n    foreach my $e (@$l1) {\n   \
    \     $h{$e} = 1;\n    }\n    foreach my $e (@$l2) {\n        if ($h{$e}) {\n\
    \            $h{$e} = 2;\n        }\n    }\n    my @res = ();\n    foreach my\
    \ $e (keys %h) {\n        if ($h{$e} == 2) {\n            push @res, $e;\n   \
    \     }\n    }\n    return sort { $a <=> $b } @res;\n}", "    my %count;\n   \
    \ for my $e (@$l1, @$l2) {\n        $count{$e}++;\n    }\n    grep { $count{$_}\
    \ > 1 } keys %count;\n}", "    my %h;\n    my @out;\n    if (ref($l1) eq 'ARRAY')\
    \ {\n        for my $i (@$l1) {\n            $h{$i}++;\n        }\n    } else\
    \ {\n        for my $i (split '', $l1) {\n            $h{$i}++;\n        }\n \
    \   }\n    if (ref($l2) eq 'ARRAY') {\n        for my $i (@$l2) {\n          \
    \  if ($h{$i}) {\n                $h{$i}++;\n            }\n        }\n    } else\
    \ {\n        for my $i (split '', $l2) {\n            if ($h{$i}) {\n        \
    \        $h{$i}++;\n            }\n        }\n    }\n    @out = sort { $a <=>\
    \ $b } grep { $h{$_} > 1 } keys %h;\n    return \\@out;\n}", "    my(%l1, %l2);\n\
    \    %l1 = map { $_ => 1 } @$l1;\n    %l2 = map { $_ => 1 } @$l2;\n    my %uniq\
    \ = (%l1, %l2);\n    return [ sort { $a <=> $b } grep { $l1{$_} && $l2{$_} } keys\
    \ %uniq ];\n}", "    my @l1 = sort @$l1;\n    my @l2 = sort @$l2;\n    my @common;\n\
    \    push @common, shift @l1\n      while @l1 && @l2 && $l1[0] == $l2[0];\n  \
    \  return @common;\n}", "    my %l2; @l2{@$l2} = ();\n    my @common = grep exists\
    \ $l2{$_}, @$l1;\n    return @common;\n}", "    my(%h1, %h2, %h, $key);\n    %h1\
    \ = map {$_ => 1} @$l1;\n    %h2 = map {$_ => 1} @$l2;\n    foreach $key (keys\
    \ %h1) {\n        $h{$key} = 1 if $h2{$key};\n    }\n    return sort keys %h;\n\
    }", "    my(%uniq, @res);\n    @uniq{@$l1} = ();\n    @uniq{@$l2} = ();\n    @res\
    \ = sort keys %uniq;\n    return @res;\n}", "    my(%h);\n    foreach my $el (@$l1)\
    \ {\n        $h{$el}++;\n    }\n    foreach my $el (@$l2) {\n        $h{$el}++;\n\
    \    }\n    my @r = grep {$h{$_} == 2} keys %h;\n    return wantarray ? @r : \\\
    @r;\n}", "    my %common = ();\n    $common{$_}++ for @$l1;\n    $common{$_}++\
    \ for @$l2;\n    my @common = ();\n    push @common, $_ for grep { $common{$_}\
    \ > 1 } keys %common;\n    return @common;\n}", "    my %seen;\n    @seen{@$l1}\
    \ = ();\n    return sort keys %seen if $#$l2 == -1;\n    @seen{@$l2} = ();\n \
    \   return sort grep exists $seen{$_}, @$l1;\n}", "    return () unless defined\
    \ $l1 and defined $l2;\n    my %x = map { $_ => 1 } @$l1;\n    my %y = map { $_\
    \ => 1 } @$l2;\n    my @r = ();\n    for my $k (keys %x) {\n        push @r, $k\
    \ if $y{$k};\n    }\n    return sort @r;\n}"]
stop_tokens:
- "\nsub"
- "\n#"
- "\n\n"
