name: HumanEval_156_int_to_mini_roman
language: pl
prompt: "# Given a positive integer, obtain its roman numeral equivalent as a string,\n\
  # and return it in lowercase.\n# Restrictions: 1 <= num <= 1000\n# Examples:\n#\
  \ >>> int_to_mini_roman(19) == 'xix'\n# >>> int_to_mini_roman(152) == 'clii'\n#\
  \ >>> int_to_mini_roman(426) == 'cdxxvi'\nsub int_to_mini_roman {\n    my($number)\
  \ = @_;\n"
tests: "use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&int_to_mini_roman;\n\
  \        if(eq_deeply($candidate->(19),\"xix\")) {\n        print \"ok!\" }else{\n\
  \        exit 1;\n        }\n        if(eq_deeply($candidate->(152),\"clii\")) {\n\
  \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(251),\"\
  ccli\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(426),\"\
  cdxxvi\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n       \
  \ if(eq_deeply($candidate->(500),\"d\")) {\n        print \"ok!\" }else{\n     \
  \   exit 1;\n        }\n        if(eq_deeply($candidate->(1),\"i\")) {\n       \
  \ print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(4),\"\
  iv\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(43),\"\
  xliii\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(90),\"\
  xc\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(94),\"\
  xciv\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(532),\"\
  dxxxii\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n       \
  \ if(eq_deeply($candidate->(900),\"cm\")) {\n        print \"ok!\" }else{\n    \
  \    exit 1;\n        }\n        if(eq_deeply($candidate->(994),\"cmxciv\")) {\n\
  \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(1000),\"\
  m\")) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
completions: ["    my $roman_numeral = '';\n    my $i = 0;\n    while ($number > 0)\
    \ {\n        $i = keys %{$mini_romans[$number - 1]};\n        $roman_numeral .=\
    \ $mini_romans[$number - 1]->{$i};\n        $number -= $i;\n    }\n    return\
    \ $roman_numeral;\n}", "    $number = int($number);\n    croak(\"int_to_mini_roman:\
    \ Argument $number is outside the bounds of 1 and 1000\")\n        if $number\
    \ < 1 || $number > 1000;\n    my $rom = \"\";\n    my $q;\n    my $r;\n    my\
    \ $n = $number;\n    for my $i (0..$#ROMAN) {\n        $q = int($n / $ROMAN[$i][0]);\n\
    \        $r = $n % $ROMAN[$i][0];\n        if ($q > 0) {\n            $rom .=\
    \ substr($ROMAN[$i][1], 0, $q);\n        }\n        $n = $r;\n    }\n    return\
    \ $rom;\n}", "    my $result = '';\n    $result .= 'i' x ($number % 5);\n    $number\
    \ -= $number % 5;\n    $result = 'v' . $result if ($number % 10 == 4);\n    $number\
    \ -= $number % 10;\n    $result = 'ix' if ($number == 9);\n    $number -= $number\
    \ % 10;\n    $result = 'x' . $result if ($number % 50 == 40);\n    $number -=\
    \ $number % 50;\n    $result = 'l' . $result if ($number % 100 == 90);\n    $number\
    \ -= $number % 100;\n    $result = 'c' . $result if ($number % 500 == 400);\n\
    \    $number -= $number % 500;\n    $result = 'd' . $result if ($number % 1000\
    \ == 900);\n    $number -= $number % 1000;\n    $result = 'm' . $result;\n   \
    \ return $result;\n}", "    # your code here\n    my %map = (\n        1 => 'i',\n\
    \        5 => 'v',\n        10 => 'x',\n        50 => 'l',\n        100 => 'c',\n\
    \        500 => 'd',\n        1000 => 'm',\n    );\n    my @digits = split('',\
    \ reverse(sprintf(\"%04d\", $number)));\n    my $result = '';\n    for (my $i\
    \ = 0; $i < scalar(@digits); $i++) {\n        my $digit = $digits[$i];\n     \
    \   if ($digit == 0) {\n            next;\n        }\n        if ($digit == 9)\
    \ {\n            $result = $map{1 * 10 ** $i} . $map{1 * 10 ** ($i + 1)} . $result;\n\
    \        } elsif ($digit >= 5) {\n            $result = $map{5 * 10 ** $i} . $map{1\
    \ * 10 ** $i} x ($digit - 5) . $result;\n        } elsif ($digit == 4) {\n   \
    \         $result = $map{1 * 10 ** $i} . $map{5 * 10 ** $i} . $result;\n     \
    \   } else {\n            $result = $map{1 * 10 ** $i} x $digit . $result;\n \
    \       }\n    }\n    return $result;\n}", "    my($last_digit);\n    my($result)\
    \ = '';\n    my($thousands);\n    my($units);", "    my $result = '';\n    my\
    \ @symbols = ('m', 'cm', 'd', 'cd', 'c', 'xc', 'l', 'xl', 'x', 'ix', 'v', 'iv',\
    \ 'i');\n    my @numbers = (1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4,\
    \ 1);\n    for(my $i = 0; $i < @numbers; $i++) {\n        if($number >= $numbers[$i])\
    \ {\n            $result .= $symbols[$i];\n            $number -= $numbers[$i];\n\
    \        }\n    }\n    return $result;\n}", "    my $result = \"\";\n    foreach\
    \ my $letter (qw(m cm d cd c xc l xl x ix v iv i)) {\n        my $value = $values{$letter};\n\
    \        next if $value > $number;\n        my $count = int($number / $value);\n\
    \        $result .= lc($letter) x $count;\n        $number -= $value * $count;\n\
    \    }\n    return $result;\n}", "    my($result);\n    my($digit, $roman_digit);\n\
    \    my(@digits) = split(//, reverse($number));\n    foreach $digit (@digits)\
    \ {\n        $roman_digit = int_to_mini_roman_digit($digit);\n        $result\
    \ = $roman_digit . $result;\n    }\n    return $result;\n}", "    die unless defined\
    \ $number;\n    die unless $number > 0;\n    die unless $number <= 1000;\n   \
    \ if ($number >= 900) {\n        return 'cm' . int_to_mini_roman($number - 900);\n\
    \    }\n    if ($number >= 500) {\n        return 'd' . int_to_mini_roman($number\
    \ - 500);\n    }\n    if ($number >= 400) {\n        return 'cd' . int_to_mini_roman($number\
    \ - 400);\n    }\n    if ($number >= 100) {\n        return 'c' . int_to_mini_roman($number\
    \ - 100);\n    }\n    if ($number >= 90) {\n        return 'xc' . int_to_mini_roman($number\
    \ - 90);\n    }\n    if ($number >= 50) {\n        return 'l' . int_to_mini_roman($number\
    \ - 50);\n    }\n    if ($number >= 40) {\n        return 'xl' . int_to_mini_roman($number\
    \ - 40);\n    }\n    if ($number >= 10) {\n        return 'x' . int_to_mini_roman($number\
    \ - 10);\n    }\n    if ($number >= 9) {\n        return 'ix' . int_to_mini_roman($number\
    \ - 9);\n    }\n    if ($number >= 5) {\n        return 'v' . int_to_mini_roman($number\
    \ - 5);\n    }\n    if ($number >= 4) {\n        return 'iv' . int_to_mini_roman($number\
    \ - 4);\n    }\n    if ($number >= 1) {\n        return 'i' . int_to_mini_roman($number\
    \ - 1);\n    }\n    die unless $number == 0;\n    return '';\n}", "    my @parts\
    \ = split(//, int_to_roman($number));\n    return join('', map {$roman_to_mini{$_}}\
    \ @parts);\n}", "    my %mapping = (\n        1 => 'i',\n        5 => 'v',\n \
    \       10 => 'x',\n        50 => 'l',\n        100 => 'c',\n        500 => 'd',\n\
    \        1000 => 'm',\n    );\n    my $roman = '';\n    my $string = $number;\n\
    \    my $current = 1000;\n    while($string > 0) {\n        my $l = $string %\
    \ 10;\n        if ($l > 0) {\n            if ($l <= 3) {\n                $roman\
    \ = $mapping{$current} x $l . $roman;\n            } elsif ($l == 4) {\n     \
    \           $roman = $mapping{$current} . $mapping{$current * 5} . $roman;\n \
    \           } elsif ($l <= 8) {\n                $roman = $mapping{$current *\
    \ 5} . $mapping{$current} x ($l - 5) . $roman;\n            } elsif ($l == 9)\
    \ {\n                $roman = $mapping{$current} . $mapping{$current * 10} . $roman;\n\
    \            }\n        }\n        $string = int($string / 10);\n        $current\
    \ = $current / 10;\n    }\n    return $roman;\n}", "    my $roman;\n    my $length\
    \ = length($number);\n    my @array = split(//, $number);\n    my @result;\n \
    \   foreach my $x (1..$length) {\n        my $tmp = pop(@array);\n        my $digit\
    \ = $length - $x;\n        my $five = 5 * 10**$digit;\n        my $one = 10**$digit;\n\
    \        if($tmp == 5) {\n            push(@result, 'v');\n        }\n       \
    \ elsif($tmp == 10) {\n            push(@result, 'x');\n        }\n        elsif($tmp\
    \ == 0) {\n            push(@result, 'c') if($one == 100);\n            push(@result,\
    \ 'l') if($one == 50);\n            push(@result, 'i') if($one == 1);\n      \
    \  }\n        elsif($tmp < 5) {\n            if($tmp == 4) {\n               \
    \ push(@result, 'iv');\n            }\n            else {\n                push(@result,\
    \ 'i' x $tmp);\n            }\n        }\n        elsif($tmp > 5) {\n        \
    \    my $count = $tmp - 5;\n            push(@result, 'v' . 'i' x $count);\n \
    \       }\n    }\n    return join('', @result);\n}", "    my $result = \"\";\n\
    \    foreach my $numeral (@numeral_order) {\n        while ($number >= $numeral_values{$numeral})\
    \ {\n            $result .= $numeral;\n            $number -= $numeral_values{$numeral};\n\
    \        }\n    }\n    return $result;\n}", "    my $roman;\n    my %roman_digits\
    \ = qw(\n        1 i\n        5 v\n        10 x\n        50 l\n        100 c\n\
    \        500 d\n        1000 m\n    );\n    my @partition;\n    my $thousands\
    \ = int($number / 1000);\n    my $remainder = $number % 1000;\n    while ($thousands\
    \ > 0) {\n        push @partition, 'm';\n        $thousands--;\n    }\n    my\
    \ $hundreds = int($remainder / 100);\n    $remainder = $remainder % 100;\n   \
    \ my $remainder_hundreds = $remainder;\n    if ($hundreds == 9) {\n        push\
    \ @partition, 'cm';\n    }\n    elsif ($hundreds == 4) {\n        push @partition,\
    \ 'cd';\n    }\n    else {\n        if ($hundreds >= 5) {\n            push @partition,\
    \ 'd';\n            $hundreds -= 5;\n        }\n        while ($hundreds > 0)\
    \ {\n            push @partition, 'c';\n            $hundreds--;\n        }\n\
    \    }\n    my $tens = int($remainder / 10);\n    $remainder = $remainder % 10;\n\
    \    my $remainder_tens = $remainder;\n    if ($tens == 9) {\n        push @partition,\
    \ 'xc';\n    }\n    elsif ($tens == 4) {\n        push @partition, 'xl';\n   \
    \ }\n    else {\n        if ($tens >= 5) {\n            push @partition, 'l';\n\
    \            $tens -= 5;\n        }\n        while ($tens > 0) {\n           \
    \ push @partition, 'x';\n            $tens--;\n        }\n    }\n    my $ones\
    \ = int($remainder / 1);\n    $remainder = $remainder % 1;\n    my $remainder_ones\
    \ = $remainder;\n    if ($ones == 9) {\n        push @partition, 'ix';\n    }\n\
    \    elsif ($ones == 4) {\n", "    my %map = (\n        1 => 'i',\n        4 =>\
    \ 'iv',\n        5 => 'v',\n        9 => 'ix',\n        10 => 'x',\n        40\
    \ => 'xl',\n        50 => 'l',\n        90 => 'xc',\n        100 => 'c',\n   \
    \     400 => 'cd',\n        500 => 'd',\n        900 => 'cm',\n        1000 =>\
    \ 'm',\n    );\n    my $result = '';\n    while ($number) {\n        my $i = 1;\n\
    \        while (!exists $map{$i}) {\n            $i *= 10;\n        }\n      \
    \  while ($number >= $i) {\n            $result .= $map{$i};\n            $number\
    \ -= $i;\n        }\n        $i /= 10;\n    }\n    return $result;\n}", "    my\
    \ %symbols = qw(I 1 V 5 X 10 L 50 C 100 D 500 M 1000);\n    my $roman_numeral\
    \ = '';\n    while ($number) {\n        if ($number >= 1000) {\n            $roman_numeral\
    \ .= 'm';\n            $number -= 1000;\n        }\n        elsif ($number >=\
    \ 500) {\n            $roman_numeral .= 'd';\n            $number -= 500;\n  \
    \      }\n        elsif ($number >= 100) {\n            $roman_numeral .= 'c';\n\
    \            $number -= 100;\n        }\n        elsif ($number >= 50) {\n   \
    \         $roman_numeral .= 'l';\n            $number -= 50;\n        }\n    \
    \    elsif ($number >= 10) {\n            $roman_numeral .= 'x';\n           \
    \ $number -= 10;\n        }\n        elsif ($number >= 5) {\n            $roman_numeral\
    \ .= 'v';\n            $number -= 5;\n        }\n        elsif ($number >= 1)\
    \ {\n            $roman_numeral .= 'i';\n            $number -= 1;\n        }\n\
    \    }\n    return $roman_numeral;\n}", "    my($roman) = \"\";\n    my(@numbers)\
    \ = (1000, 500, 100, 50, 10, 5, 1);\n    my(@symbols) = (\"m\", \"d\", \"c\",\
    \ \"l\", \"x\", \"v\", \"i\");\n    my($i);\n    for($i = 0; $i < @numbers; $i++)\
    \ {\n        while($number >= $numbers[$i]) {\n            $roman .= $symbols[$i];\n\
    \            $number -= $numbers[$i];\n        }\n    }\n    $roman =~ s/DCCCC/CM/g;\n\
    \    $roman =~ s/CCCC/CD/g;\n    $roman =~ s/LXXXX/XC/g;\n    $roman =~ s/XXXX/XL/g;\n\
    \    $roman =~ s/VIIII/IX/g;\n    $roman =~ s/IIII/IV/g;\n    return $roman;\n\
    }", "    my $result = '';\n    my @numberals = (\n        [1000, 'm'],\n     \
    \   [900, 'cm'],\n        [500, 'd'],\n        [400, 'cd'],\n        [100, 'c'],\n\
    \        [90, 'xc'],\n        [50, 'l'],\n        [40, 'xl'],\n        [10, 'x'],\n\
    \        [9, 'ix'],\n        [5, 'v'],\n        [4, 'iv'],\n        [1, 'i'],\n\
    \    );\n    for my $numeral (@numberals) {\n        my ($value, $symbol) = @$numeral;\n\
    \        while ($number >= $value) {\n            $result .= $symbol;\n      \
    \      $number -= $value;\n        }\n    }\n    return $result;\n}", "    my\
    \ $roman = \"\";\n    my $roman_numeral = {\n        1 => 'i',\n        4 => 'iv',\n\
    \        5 => 'v',\n        9 => 'ix',\n        10 => 'x',\n        40 => 'xl',\n\
    \        50 => 'l',\n        90 => 'xc',\n        100 => 'c',\n        400 =>\
    \ 'cd',\n        500 => 'd',\n        900 => 'cm',\n        1000 => 'm'\n    };\n\
    \    while ($number > 0) {\n        my $divisor = 0;\n        foreach my $k (sort\
    \ {$b <=> $a} keys %$roman_numeral) {\n            if ($number >= $k) {\n    \
    \            $divisor = $k;\n                last;\n            }\n        }\n\
    \        $roman .= $roman_numeral->{$divisor};\n        $number -= $divisor;\n\
    \    }\n    return $roman;\n}", "    my $out = '';\n    my $lookup = {\n     \
    \   'M' => 1000,\n        'CM' => 900,\n        'D' => 500,\n        'CD' => 400,\n\
    \        'C' => 100,\n        'XC' => 90,\n        'L' => 50,\n        'XL' =>\
    \ 40,\n        'X' => 10,\n        'IX' => 9,\n        'V' => 5,\n        'IV'\
    \ => 4,\n        'I' => 1,\n    };\n    for my $roman (sort { $lookup->{$b} <=>\
    \ $lookup->{$a} } keys %$lookup) {\n        my $int = $lookup->{$roman};\n   \
    \     my $div = int($number / $int);\n        if ($div) {\n            $out .=\
    \ $roman x $div;\n            $number %= $int;\n        }\n    }\n    return lc\
    \ $out;\n}"]
stop_tokens:
- "\nsub"
- "\n#"
- "\n\n"
