name: HumanEval_78_hex_key
language: pl
prompt: "# You have been tasked to write a function that receives \n# a hexadecimal\
  \ number as a string and counts the number of hexadecimal \n# digits that are primes\
  \ (prime number, or a prime, is a natural number \n# greater than 1 that is not\
  \ a product of two smaller natural numbers).\n# Hexadecimal digits are 0, 1, 2,\
  \ 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n# Prime numbers are 2, 3, 5, 7, 11, 13,\
  \ 17,...\n# So you have to determine a number of the following digits: 2, 3, 5,\
  \ 7, \n# B (=decimal 11), D (=decimal 13).\n# Note: you may assume the input is\
  \ always correct or empty string, \n# and symbols A,B,C,D,E,F are always uppercase.\n\
  # Examples:\n# For num = \"AB\" the output should be 1.\n# For num = \"1077E\" the\
  \ output should be 2.\n# For num = \"ABED1A33\" the output should be 4.\n# For num\
  \ = \"123456789ABCDEF0\" the output should be 6.\n# For num = \"2020\" the output\
  \ should be 2.\nsub hex_key {\n    my($num) = @_;\n"
tests: "use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&hex_key;\n\
  \        if(eq_deeply($candidate->(\"AB\"),1)) {\n        print \"ok!\" }else{\n\
  \        exit 1;\n        }\n        if(eq_deeply($candidate->(\"1077E\"),2)) {\n\
  \        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"\
  ABED1A33\"),4)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n  \
  \      if(eq_deeply($candidate->(\"2020\"),2)) {\n        print \"ok!\" }else{\n\
  \        exit 1;\n        }\n        if(eq_deeply($candidate->(\"123456789ABCDEF0\"\
  ),6)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->(\"\
  112233445566778899AABBCCDDEEFF00\"),12)) {\n        print \"ok!\" }else{\n     \
  \   exit 1;\n        }\n}\n\ntesthumaneval();"
completions: ["    my %is_prime = ();\n    $is_prime{$_} = 1 for(2,3,5,7,11,13);\n\
    \    my $count = 0;\n    foreach my $chr (split(//,$num)) {\n        $count++\
    \ if exists $is_prime{uc $chr};\n    }\n    return $count;\n}\nsay hex_key(\"\
    1077E\"); # 2\nsay hex_key(\"ABED1A33\"); # 4\nsay hex_key(\"123456789ABCDEF0\"\
    ); # 6\nsay hex_key(\"2020\"); # 2", "    my $hex_hex = \"0123456789ABCDEF\";\n\
    \    my %hex_dec = ();\n    my $i = 0;\n    while ($i < length($hex_hex)) {\n\
    \        $hex_dec{substr($hex_hex, $i, 1)} = $i;\n        $i++;\n    }\n    my\
    \ $dec_num = 0;\n    $i = 0;\n    while ($i < length($num)) {\n        $dec_num\
    \ += $hex_dec{substr($num, $i, 1)} * 16**(length($num) - $i - 1);\n        $i++;\n\
    \    }\n    return $dec_num;\n}", "    $num =~ s/[^0-9A-F]//g;\n    my $val =\
    \ oct(\"0x$num\");\n    return $val;\n}", "    my $result = 0;\n    my @prime_numbers\
    \ = (2, 3, 5, 7, 11, 13);\n    $num =~ s/[^0-9A-F]//g;\n    foreach my $prime_number\
    \ (@prime_numbers) {\n        my $hex_prime_number = sprintf(\"%X\", $prime_number);\n\
    \        $result += () = $num =~ /\\Q$hex_prime_number\\E/g;\n    }\n    return\
    \ $result;\n}", "    my @res;\n    my @key = split(//, $num);\n    foreach my\
    \ $i (@key) {\n        if($i =~ /[2357BD]/) {\n            push(@res, $i);\n \
    \       }\n    }\n    print \"Hexadecimal digits that are primes are: @res\\n\"\
    ;\n    print \"Number of hexadecimal digits that are primes are: \", scalar(@res),\
    \ \"\\n\";\n}", "    my $count = 0;\n    my %hex_key = (\n        '2' => 1,\n\
    \        '3' => 1,\n        '5' => 1,\n        '7' => 1,\n        'B' => 1,\n\
    \        'D' => 1,\n    );\n    # precompute hash keys for prime hex digits\n\
    \    for my $i (0 .. length($num)-1) {\n        my $char = substr($num, $i, 1);\n\
    \        $count++ if (exists $hex_key{$char});\n    }\n    return $count;\n}",
  "    my $hex = {\n        \"0\" => 1, \"1\" => 1, \"2\" => 1, \"3\" => 1, \"4\"\
    \ => 1, \"5\" => 1,\n        \"6\" => 1, \"7\" => 1, \"8\" => 1, \"9\" => 1, \"\
    A\" => 1, \"B\" => 1,\n        \"C\" => 1, \"D\" => 1, \"E\" => 1, \"F\" => 1,\n\
    \    };\n    my $prime = {\n        \"0\" => 0, \"1\" => 0, \"2\" => 1, \"3\"\
    \ => 1, \"4\" => 0, \"5\" => 1,\n        \"6\" => 0, \"7\" => 1, \"8\" => 0, \"\
    9\" => 0, \"A\" => 0, \"B\" => 1,\n        \"C\" => 0, \"D\" => 1, \"E\" => 0,\
    \ \"F\" => 0,\n    };\n    my $count = 0;\n    foreach my $i (split(\"\",$num))\
    \ {\n        if (exists($hex->{$i}) && $prime->{$i}) {\n            $count++;\n\
    \        }\n    }\n    return $count;\n}\nprint(hex_key(\"ABED1A33\").\"\\n\"\
    );\nprint(hex_key(\"AB\").\"\\n\");\nprint(hex_key(\"1077E\").\"\\n\");\nprint(hex_key(\"\
    ABED1A33\").\"\\n\");\nprint(hex_key(\"123456789ABCDEF0\").\"\\n\");\nprint(hex_key(\"\
    2020\").\"\\n\");", "    my $count = 0;\n    $num =~ tr/A-F//d;\n    my @num =\
    \ split '', $num;\n    for my $i (@num) {\n        if ($i =~ /[2357BDF]/) {\n\
    \            $count++;\n        }\n    }\n    return $count;\n}", "    my @nums\
    \ = split(//,$num);\n    my $count = 0;\n    foreach my $n (@nums) {\n       \
    \ if ($n == 2 || $n == 3 || $n == 5 || $n == 7 || $n == 11 || $n == 13) {\n  \
    \          $count++;\n        }\n    }\n    return $count;\n}\nmy $num = \"AB\"\
    ;\nmy $result = hex_key($num);\nprint $result;", "    my %hex_prime = (\n    \
    \    2 => 0,\n        3 => 0,\n        5 => 0,\n        7 => 0,\n        'B' =>\
    \ 0,\n        'D' => 0,\n    );\n    my @num = split(//,$num);\n    my $key =\
    \ 0;\n    for my $i (@num) {\n        $key++ if exists $hex_prime{$i};\n    }\n\
    \    return $key;\n}\nprint(hex_key(\"AB\").\"\\n\");\nprint(hex_key(\"1077E\"\
    ).\"\\n\");\nprint(hex_key(\"ABED1A33\").\"\\n\");\nprint(hex_key(\"123456789ABCDEF0\"\
    ).\"\\n\");\nprint(hex_key(\"2020\").\"\\n\");", "    my $key = 0;\n    $key +=\
    \ 2 if $num =~ /[2BC]/i;\n    $key += 3 if $num =~ /[3D]/i;\n    $key += 5 if\
    \ $num =~ /[5F]/i;\n    $key += 7 if $num =~ /[7]/i;\n    $key += 11 if $num =~\
    \ /[B]/i;\n    $key += 13 if $num =~ /[D]/i;\n    return $key;\n}", "    my @hexadecimal\
    \ = qw(0 1 2 3 4 5 6 7 8 9 A B C D E F);\n    my @prime_digits = qw(2 3 5 7 B\
    \ D);\n    my $count = 0;\n    foreach my $hex_digit (split //, $num) {\n    \
    \    if (grep(/^$hex_digit$/, @prime_digits)) {\n            $count++;\n     \
    \   }\n    }\n    return $count;\n}", "    my $tst = $num;\n    my $dec = hex($tst);\n\
    \    my $cnt = 0;\n    if($dec <= 1) {\n        return 0;\n    }\n    for(my $i\
    \ = 2; $i < $dec; $i++) {\n        if($dec % $i == 0) {\n            $cnt++;\n\
    \        }\n    }\n    if($cnt == 0) {\n        return 1;\n    }\n    return 0;\n\
    }", "    my %nums = map { $_ => 0 } (0..9,'A'..'F');\n    my $cnt = 0;\n    for\
    \ my $i (split('',$num)) {\n        $cnt++ if(exists $nums{$i});\n    }\n    return\
    \ $cnt;\n}", "    my $hex_key = 0;\n    if ($num =~ /^[0-9A-F]+$/) {\n       \
    \ $hex_key = 1;\n    }\n    return $hex_key;\n}", "    my $hex_key = 0;\n    if\
    \ ($num =~ /^([A-F]{1})$/) {\n        $hex_key = ord($1) - 55;\n    } elsif ($num\
    \ =~ /^([0-9]{1})$/) {\n        $hex_key = $1;\n    } else {\n        die \"Unexpected\
    \ digit: $num\";\n    }\n    return $hex_key;\n}", "    my @hex_k = qw(0 1 2 3\
    \ 4 5 6 7 8 9 A B C D E F);\n    my %hex_v = ();\n    foreach my $n (0..$#hex_k)\
    \ {\n        $hex_v{$hex_k[$n]} = $n;\n    }\n    return %hex_v;\n}", "    my\
    \ $sum = 0;\n    my @c = split //, $num;\n    my @p = (2, 3, 5, 7, 11, 13);\n\
    \    foreach my $c (@c) {\n        foreach my $p (@p) {\n            if (lc($c)\
    \ eq hex($p)) {\n                $sum++;\n            }\n        }\n    }\n  \
    \  return $sum;\n}", "    return ord(uc($num)) - 55;\n}", "    if ($num =~ /^[\\\
    dA-F]+$/) {\n        my @key = split(//, $num);\n        my $output = 0;\n   \
    \     for my $i (@key) {\n            if ($i =~ /2|3|5|7|B|D/) {\n           \
    \     $output ++;\n            }\n        }\n        return $output;\n    }\n\
    \    else {\n        return \"Invalid input: '$num'\\n\";\n    }\n}"]
stop_tokens:
- "\nsub"
- "\n#"
- "\n\n"
