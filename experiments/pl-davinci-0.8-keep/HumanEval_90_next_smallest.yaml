name: HumanEval_90_next_smallest
language: pl
prompt: "# You are given a list of integers.\n# Write a function next_smallest() that\
  \ returns the 2nd smallest element of the list.\n# Return None if there is no such\
  \ element.\n# next_smallest([1, 2, 3, 4, 5]) == 2\n# next_smallest([5, 1, 4, 3,\
  \ 2]) == 2\n# next_smallest([]) == None\n# next_smallest([1, 1]) == None\nsub next_smallest\
  \ {\n    my($lst) = @_;\n"
tests: "use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&next_smallest;\n\
  \        if(eq_deeply($candidate->([1, 2, 3, 4, 5]),2)) {\n        print \"ok!\"\
  \ }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([5, 1, 4,\
  \ 3, 2]),2)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n     \
  \   if(eq_deeply($candidate->([]),undef)) {\n        print \"ok!\" }else{\n    \
  \    exit 1;\n        }\n        if(eq_deeply($candidate->([1, 1]),undef)) {\n \
  \       print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1,\
  \ 1, 1, 1, 0]),1)) {\n        print \"ok!\" }else{\n        exit 1;\n        }\n\
  \        if(eq_deeply($candidate->([1, 1]),undef)) {\n        print \"ok!\" }else{\n\
  \        exit 1;\n        }\n        if(eq_deeply($candidate->([-35, 34, 12, -45]),-35))\
  \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
completions: ["    my $min = min($lst);\n    return min(grep { $_ != $min } @$lst);\n\
    }", "    return undef if scalar(@$lst) < 2;\n    my @sorted = sort { $a <=> $b\
    \ } @$lst;\n    my $curr = $sorted[0];\n    for(my $i = 1; $i < scalar(@sorted);\
    \ $i++) {\n        if($sorted[$i] != $curr) {\n            return $sorted[$i];\n\
    \        }\n    }\n    return undef;\n}", "    return undef if @$lst < 2;\n  \
    \  return undef if $lst->[0] == $lst->[1];\n    return $lst->[1] if @$lst == 2;\n\
    \    my @a = sort { $a <=> $b } @$lst;\n    return $a[1];\n}", "    return undef\
    \ if scalar(@$lst) < 2;\n    my $smallest = $lst->[0];\n    my $next_smallest\
    \ = undef;\n    for my $i (1..$#$lst) {\n        if ($lst->[$i] < $smallest) {\n\
    \            $next_smallest = $smallest;\n            $smallest = $lst->[$i];\n\
    \        } elsif ($lst->[$i] > $smallest) {\n            if (not defined $next_smallest)\
    \ {\n                $next_smallest = $lst->[$i];\n            } elsif ($lst->[$i]\
    \ < $next_smallest) {\n                $next_smallest = $lst->[$i];\n        \
    \    }\n        }\n    }\n    return $next_smallest;\n}", "    my($l, $s, $m)\
    \ = (scalar(@$lst), undef, undef);\n    return undef if $l == 0;\n    return undef\
    \ if $l == 1;\n    for (my $i = 0; $i < $l; $i++) {\n        for (my $j = 0; $j\
    \ < $l; $j++) {\n            if ($lst->[$i] != $lst->[$j]) {\n               \
    \ if ($m eq undef) {\n                    $m = $lst->[$i] < $lst->[$j] ? $lst->[$i]\
    \ : $lst->[$j];\n                }\n                elsif ($lst->[$i] < $lst->[$j])\
    \ {\n                    $m = $m < $lst->[$i] ? $m : $lst->[$i];\n           \
    \     }\n                else {\n                    $m = $m < $lst->[$j] ? $m\
    \ : $lst->[$j];\n                }\n            }\n        }\n    }\n    return\
    \ $m;\n}", "    return unless $lst;\n    return if scalar(@$lst) < 2;\n    my\
    \ @lst = sort { $a <=> $b } @$lst;\n    my %counts;\n    $counts{$_}++ for @lst;\n\
    \    my @unique = sort { $a <=> $b } grep { $counts{$_} == 1 } @lst;\n    return\
    \ $unique[1];\n}", "    my($min, $min2);\n    foreach my $x (@$lst) {\n      \
    \  if (!defined($min) || $x < $min) {\n            $min2 = $min;\n           \
    \ $min = $x;\n        } elsif (!defined($min2) || $x < $min2) {\n            $min2\
    \ = $x;\n        }\n    }\n    $min2;\n}", "    return undef if !@$lst;\n    my\
    \ $mn = $lst->[0];\n    my $smn = undef;\n    for my $i (@$lst) {\n        next\
    \ if $i == $mn;\n        if (!defined $smn) {\n            $smn = $i;\n      \
    \  }\n        elsif ($i < $smn) {\n            $smn = $i;\n        }\n    }\n\
    \    return $smn;\n}", "    return undef if ! @$lst;\n    my @sorted = sort {\
    \ $a <=> $b } @$lst;\n    my $min = shift @sorted;\n    while( @sorted && $sorted[0]\
    \ == $min ) {\n        shift @sorted;\n    }\n    return @sorted ? $sorted[0]\
    \ : undef;\n}", "    my($min1, $min2) = (undef, undef);\n    foreach my $x (@$lst)\
    \ {\n        if (not defined $min1 or $x < $min1) {\n            $min2 = $min1;\n\
    \            $min1 = $x;\n        } elsif (not defined $min2 or $x < $min2) {\n\
    \            $min2 = $x;\n        }\n    }\n    return $min2;\n}", "    return\
    \ undef if @$lst == 0;\n    return undef if @$lst == 1;\n    my($a, $b) = sort\
    \ { $a <=> $b } @$lst;\n    return $a == $b ? undef : $a;\n}", "    my $min =\
    \ $lst->[0];\n    my $min2 = undef;\n    for my $i (1..@$lst-1) {\n        my\
    \ $v = $lst->[$i];\n        if($v < $min) {\n            $min2 = $min;\n     \
    \       $min = $v;\n        } elsif(!defined($min2) || $v < $min2) {\n       \
    \     $min2 = $v;\n        }\n    }\n    return $min2;\n}", "    my $min;\n  \
    \  my $second_min;\n    my $n_elems = 0;\n    for (@$lst) {\n        $n_elems++;\n\
    \        if (!defined $min || $_ < $min) {\n            $second_min = $min;\n\
    \            $min = $_;\n        } elsif (!defined $second_min || $_ < $second_min)\
    \ {\n            $second_min = $_;\n        }\n    }\n    die \"too few elements\
    \ in list\" if $n_elems < 2;\n    return $second_min;\n}", "    return undef if\
    \ !@$lst || @$lst == 1;\n    my $smallest = -1;\n    my $second = -1;\n    for(@$lst)\
    \ {\n        if($_ < $smallest || $smallest == -1) {\n            $second = $smallest;\n\
    \            $smallest = $_;\n        } elsif($_ < $second || $second == -1) {\n\
    \            $second = $_;\n        }\n    }\n    return $second;\n}", "    my\
    \ $min;\n    my $cnt = 0;\n    my $val;\n    for my $x (@$lst) {\n        if (not\
    \ defined $min or $x < $min) {\n            $min = $x;\n            $cnt = 1;\n\
    \        } elsif ($x == $min) {\n            $cnt++;\n        } elsif (not defined\
    \ $val or $x < $val) {\n            $val = $x;\n        }\n    }\n    return $cnt\
    \ == 1 ? $val : undef;\n}", "    my @lst = sort { $a <=> $b } @$lst;\n    my $n\
    \ = scalar @lst;\n    if($n < 2) {\n        return undef;\n    }\n    my $x =\
    \ $lst[0];\n    for(my $i = 1; $i < $n; $i++) {\n        my $y = $lst[$i];\n \
    \       if($x != $y) {\n            return $y;\n        }\n    }\n    return undef;\n\
    }", "    my $min = $lst->[0];\n    my $next = $lst->[1];\n    foreach (@$lst)\
    \ {\n        $min = $_ if $_ < $min;\n        $next = $_ if $_ < $next && $_ >\
    \ $min;\n    }\n    return $next;\n}", "    my $min = $lst->[0];\n    my $min2\
    \ = undef;\n    for my $elem (@$lst) {\n        if($elem < $min) {\n         \
    \   $min2 = $min;\n            $min = $elem;\n        } elsif(defined($min2) &&\
    \ $elem < $min2) {\n            $min2 = $elem;\n        }\n    }\n    return $min2;\n\
    }", "    return undef if @$lst == 0;\n    my($min, $nmin) = ($lst->[0], undef);\n\
    \    foreach my $i (@$lst) {\n        if ($i < $min) {\n            $nmin = $min;\n\
    \            $min = $i;\n        } elsif ($i > $min && (!defined($nmin) || $i\
    \ < $nmin)) {\n            $nmin = $i;\n        }\n    }\n    return $nmin;\n}",
  "    my $small = $lst->[0];\n    my $second_small = undef;\n    foreach my $i (1..@$lst-1)\
    \ {\n        if ($lst->[$i] < $small) {\n            $second_small = $small;\n\
    \            $small = $lst->[$i];\n        } elsif ( $lst->[$i] < $second_small\
    \ ) {\n            $second_small = $lst->[$i];\n        }\n    }\n    return $second_small;\n\
    }"]
stop_tokens:
- "\nsub"
- "\n#"
- "\n\n"
