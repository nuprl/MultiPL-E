name: HumanEval_145_order_by_points
language: pl
prompt: "# Write a function which sorts the given list of integers\n# in ascending\
  \ order according to the sum of their digits.\n# Note: if there are several items\
  \ with similar sum of their digits,\n# order them based on their index in original\
  \ list.\n# For example:\n# >>> order_by_points([1, 11, -1, -11, -12]) == [-1, -11,\
  \ 1, -12, 11]\n# >>> order_by_points([]) == []\nsub order_by_points {\n    my($nums)\
  \ = @_;\n"
tests: "use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&order_by_points;\n\
  \        if(eq_deeply($candidate->([1, 11, -1, -11, -12]),[-1, -11, 1, -12, 11]))\
  \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1234,\
  \ 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46]),[0, 2, 3, 6, 53, 423,\
  \ 423, 423, 1234, 145, 37, 46, 56, 463, 3457])) {\n        print \"ok!\" }else{\n\
  \        exit 1;\n        }\n        if(eq_deeply($candidate->([]),[])) {\n    \
  \    print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1,\
  \ -11, -32, 43, 54, -98, 2, -3]),[-3, -32, -98, -11, 1, 2, 43, 54])) {\n       \
  \ print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([1,\
  \ 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]),[1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9])) {\n   \
  \     print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([0,\
  \ 6, 6, -76, -21, 23, 4]),[-76, -21, 0, 4, 23, 6, 6])) {\n        print \"ok!\"\
  \ }else{\n        exit 1;\n        }\n}\n\ntesthumaneval();"
completions: ["    my %sums;\n    for my $i (0..$#$nums) {\n        $sums{$i} = sum_digits($nums->[$i]);\n\
    \    }\n    return [ map { $nums->[$_] } sort { $sums{$a} <=> $sums{$b} } keys\
    \ %sums ];\n}", "    my @nums = @$nums;\n    my @sorted_num_ids =\n        sort\
    \ {$a <=> $b}\n        map { $_->[0] }\n        sort {$a->[1] <=> $b->[1]}\n \
    \       map { [$_, digits_sum($nums[$_])] } 0..$#nums;\n    return [@nums[@sorted_num_ids]];\n\
    }", "    my @result = sort {sum_digits($a) <=> sum_digits($b) or $a <=> $b} @$nums;\n\
    \    return \\@result;\n}", "    my @nums = @$nums;\n    @nums = sort {\n    \
    \    ($a % 10) + ($a / 10 % 10) <=> ($b % 10) + ($b / 10 % 10)\n        || $a\
    \ <=> $b\n    } @nums;\n    return \\@nums;\n}", "    return @$nums if !@$nums;\n\
    \    return @$nums if @$nums == 1;\n    my %h;\n    my $count = 0;\n    foreach\
    \ my $num (@$nums) {\n        my $sum = 0;\n        my $tmp = $num;\n        while\
    \ ($tmp) {\n            $sum += $tmp % 10;\n            $tmp = int($tmp / 10);\n\
    \        }\n        push @{$h{$sum}}, $num;\n    }\n    my @result;\n    foreach\
    \ my $sum (sort {$a <=> $b} keys %h) {\n        foreach my $item (@{$h{$sum}})\
    \ {\n            push @result, $item;\n        }\n    }\n    return @result;\n\
    }", "    my @nums_sorted = sort {\n        my $sum_a = sum(split(//, $a));\n \
    \       my $sum_b = sum(split(//, $b));\n        return $sum_a <=> $sum_b || $a\
    \ <=> $b;\n    } @$nums;\n    return \\@nums_sorted;\n}", "    my @result = map\
    \ { $nums->[$_] }\n        sort { sum_of_digits($nums->[$a]) <=> sum_of_digits($nums->[$b])\
    \ || $a <=> $b } 0..$#$nums;\n    return \\@result;\n}", "    my @sorted_nums\
    \ = sort { $a <=> $b } @$nums;\n    return \\@sorted_nums;\n}", "    return ()\
    \ unless @$nums;\n    return sort { abs($a) % 10 + abs($a) / 10 % 10 <=> abs($b)\
    \ % 10 + abs($b) / 10 % 10 or $a <=> $b } @$nums;\n}", "    my @sorted =\n   \
    \   map { $_->[0] }\n      sort { $a->[1] <=> $b->[1] || $a->[2] <=> $b->[2] }\n\
    \      map { [$_, sum_of_digits($_), $_] }\n      @$nums;\n    return @sorted;\n\
    }", "    my @sorted_nums = @$nums;\n    my %points;\n    my @digit_sums;\n   \
    \ for my $i (0..$#sorted_nums) {\n        $points{$i} = 0;\n        @digit_sums\
    \ = split(//, $sorted_nums[$i]);\n        for my $digit (@digit_sums) {\n    \
    \        $points{$i} += $digit;\n        }\n    }\n    my @sorted_indexes = sort\
    \ {$points{$a} <=> $points{$b}} keys %points;\n    my @sorted_nums_by_points;\n\
    \    for my $index (@sorted_indexes) {\n        push @sorted_nums_by_points, $sorted_nums[$index];\n\
    \    }\n    return \\@sorted_nums_by_points;\n}", "    my @sorted = sort {$b->[0]\
    \ <=> $a->[0] || $a->[1] <=> $b->[1]}\n        map {[sum_digits($_), $_]} @$nums;\n\
    \    return [map {$_->[1]} @sorted];\n}", "    my @res = sort { $a <=> $b } @$nums;\n\
    \    return \\@res;\n}", "    return [] if not @$nums;\n    my @res = sort {\n\
    \        my $sum_a = sum_of_digits($a);\n        my $sum_b = sum_of_digits($b);\n\
    \        if ($sum_a != $sum_b) {\n            return $sum_a <=> $sum_b;\n    \
    \    } else {\n            my $idx_a = first_index { $_ == $a } @$nums;\n    \
    \        my $idx_b = first_index { $_ == $b } @$nums;\n            return $idx_a\
    \ <=> $idx_b;\n        }\n    } @$nums;\n    return \\@res;\n}", "    my @sorted_index\
    \ = map { $_->[0] } \n        sort { $a->[1] <=> $b->[1] } \n        map { my\
    \ $i = $_; [$i, sum(split(//, $nums->[$i]))] } \n        0..$#$nums;\n    return\
    \ [@{$nums}[@sorted_index]];\n}", "    my @result = sort { $a->[0] <=> $b->[0]\
    \ || $a->[1] <=> $b->[1] }\n                 map { [_sum_digits($_), $_] } @$nums;\n\
    \    return [map { $_->[1] } @result];\n}", "    my $sum = sum(@$nums);\n    my\
    \ @sort;\n    foreach my $num (@$nums) {\n        my $sum_digit = sum(split(//,\
    \ $num));\n        push @sort, $sum_digit;\n    }\n    my @orders = sort { $a\
    \ <=> $b } @sort;\n    my $order = shift @orders;\n    my @array;\n    while ($order)\
    \ {\n        my $index = first_index { $order == sum(split(//, $_)) } @$nums;\n\
    \        push @array, $nums->[$index];\n        $order = shift @orders;\n    }\n\
    \    return \\@array;\n}", "    my @res = sort {\n        $a->[0] <=> $b->[0]\
    \ || $a->[1] <=> $b->[1]\n    } map {\n        my $digit_sum = sum(split //, $_);\n\
    \        [$digit_sum, $_];\n    } @$nums;\n    [map {$_->[1]} @res];\n}", "  \
    \  my %hm;\n    for my $i (0..$#$nums) {\n        my $sum = 0;\n        while\
    \ ($nums->[$i]) {\n            $sum += $nums->[$i] % 10;\n            $nums->[$i]\
    \ /= 10;\n        }\n        $hm{$sum} = [] unless exists $hm{$sum};\n       \
    \ push @{$hm{$sum}}, $i;\n    }\n    my @result;\n    for my $sum (sort {$a <=>\
    \ $b} keys %hm) {\n        for my $i (@{$hm{$sum}}) {\n            push @result,\
    \ $nums->[$i];\n        }\n    }\n    \\@result;\n}", "    return [] if !@$nums;\n\
    \    my @map = map [$_, sum_digits($_)], @$nums;\n    @map = sort { $a->[1] <=>\
    \ $b->[1] || $a->[0] <=> $b->[0] } @map;\n    my @res = map $_->[0], @map;\n \
    \   return \\@res;\n}"]
stop_tokens:
- "\nsub"
- "\n#"
- "\n\n"
