name: HumanEval_115_max_fill
language: pl
prompt: "# You are given a rectangular grid of wells. Each row represents a single\
  \ well,\n# and each 1 in a row represents a single unit of water.\n# Each well has\
  \ a corresponding bucket that can be used to extract water from it, \n# and all\
  \ buckets have the same capacity.\n# Your task is to use the buckets to empty the\
  \ wells.\n# Output the number of times you need to lower the buckets.\n# Example\
  \ 1:\n# Input: \n# grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n# bucket_capacity :\
  \ 1\n# Output: 6\n# Example 2:\n# Input: \n# grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1],\
  \ [0,1,1,1]]\n# bucket_capacity : 2\n# Output: 5\n# Example 3:\n# Input: \n# grid\
  \ : [[0,0,0], [0,0,0]]\n# bucket_capacity : 5\n# Output: 0\n# Constraints:\n# *\
  \ all wells have the same length\n# * 1 <= grid.length <= 10^2\n# * 1 <= grid[:,1].length\
  \ <= 10^2\n# * grid[i][j] -> 0 | 1\n# * 1 <= capacity <= 10\nsub max_fill {\n  \
  \  my($grid, $capacity) = @_;\n"
tests: "use Test::Deep;\n\n\nsub testhumaneval {\n    my $candidate = \\&max_fill;\n\
  \        if(eq_deeply($candidate->([[0, 0, 1, 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1),6))\
  \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[0,\
  \ 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2),5)) {\n        print \"\
  ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[0,\
  \ 0, 0], [0, 0, 0]], 5),0)) {\n        print \"ok!\" }else{\n        exit 1;\n \
  \       }\n        if(eq_deeply($candidate->([[1, 1, 1, 1], [1, 1, 1, 1]], 2),4))\
  \ {\n        print \"ok!\" }else{\n        exit 1;\n        }\n        if(eq_deeply($candidate->([[1,\
  \ 1, 1, 1], [1, 1, 1, 1]], 9),2)) {\n        print \"ok!\" }else{\n        exit\
  \ 1;\n        }\n}\n\ntesthumaneval();"
completions: ["    my $n = scalar(@$grid);\n    my $m = scalar(@{$grid->[0]});\n \
    \   my $total = 0;\n    foreach my $i(0..$n-1) {\n        foreach my $j(0..$m-1)\
    \ {\n            $total += $grid->[$i][$j];\n        }\n    }\n    return 0 if\
    \ $total == 0;\n    return ($total - 1) / $capacity + 1;\n}", "    my $m = scalar(@$grid);\n\
    \    my $n = scalar(@{$grid->[0]});\n    my $num_operations = 0;\n    for my $j\
    \ (0..$n-1) {\n        my $num_buckets = 0;\n        for my $i (0..$m-1) {\n \
    \           $num_buckets += $grid->[$i][$j];\n        }\n        $num_operations\
    \ += int($num_buckets / $capacity);\n        $num_operations += $num_buckets %\
    \ $capacity == 0 ? 0 : 1;\n    }\n    return $num_operations;\n}", "    my $count\
    \ = 0;\n    my $min_fills = 1;\n    for my $r (0..$#$grid) {\n        my $row\
    \ = $grid->[$r];\n        my $fill = 0;\n        for my $c (0..$#$row) {\n   \
    \         my $well = $row->[$c];\n            next if $well == 0;\n          \
    \  $fill += 1;\n            $count += 1;\n            $min_fills = $count if $count\
    \ > $min_fills;\n            if ($fill == $capacity) {\n                $fill\
    \ = 0;\n                $count = 0;\n            }\n        }\n    }\n    $min_fills;\n\
    }", "    my $n = @$grid;\n    my $m = $n > 0 ? @{$grid->[0]} : 0;\n    my $fill\
    \ = 0;\n    my $cols = [map { 0 } 0..$m-1];\n    for my $i(0..$n-1) {\n      \
    \  for my $j(0..$m-1) {\n            my $q = $grid->[$i][$j];\n            my\
    \ $p = $cols->[$j];\n            my $d = $p + $q - $capacity;\n            if($d\
    \ > 0) {\n                $q -= $d;\n                $p -= $d;\n            }\n\
    \            $fill += $q;\n            $cols->[$j] = $p + $q;\n        }\n   \
    \ }\n    return $fill;\n}", "    my $n = @$grid;\n    my $m = @{$grid->[0]};\n\
    \    my $fill = 0;\n    # If a well is empty, continue.\n    # If a well is not\
    \ empty, consider filling the well.\n    # If a well can not be filled, then the\
    \ bucket is at full capacity.\n    for my $i (0..$n-1) {\n        for my $j (0..$m-1)\
    \ {\n            if ($grid->[$i][$j] > 0) {\n                my $take = $capacity\
    \ - $grid->[$i][$j];\n                if ($take > 0) {\n                    $grid->[$i][$j]\
    \ = 0;\n                    $capacity = $take;\n                } else {\n   \
    \                 $grid->[$i][$j] -= $capacity;\n                    $capacity\
    \ = 0;\n                }\n                $fill++;\n            }\n        }\n\
    \    }\n    return $fill;\n}", "    my $res = 0;\n    for my $r (@$grid) {\n \
    \       my $rows = int(sum(@$r) / $capacity);\n        my $sum = $rows * $capacity;\n\
    \        for my $i (0..$#$r) {\n            $r->[$i] -= $rows;\n            if\
    \ ($r->[$i] > 0) {\n                $sum += $r->[$i];\n            }\n       \
    \ }\n        $res += $sum;\n    }\n    return $res;\n}", "    my $n_rows = @$grid;\n\
    \    my $n_cols = @{$grid->[0]};\n    my $i = 0;\n    my $j = 0;\n    my $n_buckets\
    \ = 0;\n    my $row_sum = 0;\n    while ($i < $n_rows) {\n        $row_sum +=\
    \ $grid->[$i][$j];\n        $i++;\n        if ($row_sum == $capacity) {\n    \
    \        $n_buckets++;\n            $row_sum = 0;\n            $i = 0;\n     \
    \       $j++;\n        }\n        if ($row_sum > $capacity) {\n            $n_buckets++;\n\
    \            $row_sum = 0;\n            $i = 0;\n        }\n        last if $j\
    \ == $n_cols;\n    }\n    return $n_buckets;\n}", "    my $num_rows = @$grid;\n\
    \    my $num_cols = $grid->[0]->@*;\n    my $num_empties = $num_rows * $num_cols;\n\
    \    my $count = 0;\n    while ($num_empties > 0) {\n        my $overflowed =\
    \ 0;\n        for my $col (0..$num_cols-1) {\n            if ($capacity <= 0)\
    \ {\n                $overflowed = 1;\n                last;\n            }\n\
    \            $count++;\n            for my $row (0..$num_rows-1) {\n         \
    \       if ($grid->[$row]->[$col] == 1) {\n                    $capacity--;\n\
    \                    $grid->[$row]->[$col] = 0;\n                    $num_empties--;\n\
    \                }\n            }\n        }\n        if ($overflowed) {\n   \
    \         $capacity = 0;\n        }\n    }\n    return $count;\n}", "    my $columns\
    \ = scalar @{$grid->[0]};\n    my $rows = scalar @$grid;\n    my $fill = 0;\n\
    \    my $max_fill = 0;\n    for my $col (0..$columns-1) {\n        for my $row\
    \ (0..$rows-1) {\n            $fill += $grid->[$row][$col];\n            $max_fill\
    \ = $fill if $fill > $max_fill;\n        }\n        $fill = 0;\n    }\n    return\
    \ $max_fill + $capacity - 1;\n}", "    my $rows = @$grid;\n    my $cols = @{$grid->[0]};\n\
    \    my $fill = 0;\n    my $rounds = 0;\n    while ($fill < $rows) {\n       \
    \ $rounds++;\n        $fill = 0;\n        foreach my $row (0..$rows-1) {\n   \
    \         foreach my $col (0..$cols-1) {\n                if ($grid->[$row][$col]\
    \ > 0) {\n                    if ($grid->[$row][$col] > $capacity) {\n       \
    \                 $grid->[$row][$col] -= $capacity;\n                    } else\
    \ {\n                        $grid->[$row][$col] = 0;\n                      \
    \  $fill++;\n                    }\n                }\n            }\n       \
    \ }\n    }\n    return $rounds;\n}\nuse Test::More;\nuse Test::LMU;", "    my\
    \ $count = 0;\n    for my $row (@$grid) {\n        my $fill = 0;\n        for\
    \ my $cell (@$row) {\n            $fill += $cell;\n            if ($fill >= $capacity)\
    \ {\n                $count += ($fill / $capacity);\n                $fill = $fill\
    \ % $capacity;\n            }\n        }\n        $count += ($fill ? 1 : 0);\n\
    \    }\n    return $count;\n}", "    my $max_fill = 0;\n    for my $i (0..$#$grid)\
    \ {\n        my $prev_fill = 0;\n        for my $j (0..$#{$grid->[$i]}) {\n  \
    \          $prev_fill++ if $grid->[$i][$j];\n            $max_fill = $prev_fill\
    \ if $prev_fill > $max_fill;\n        }\n    }\n    $max_fill = $capacity if $max_fill\
    \ > $capacity;\n    return $max_fill;\n}", "    my $nrows = @$grid;\n    my $ncols\
    \ = @{$grid->[0]};\n    my $n_fill = 0;\n    for my $col (0..$ncols-1) {\n   \
    \     for my $row (0..$nrows-1) {\n            my $n_fill_here = $capacity - $grid->[$row][$col];\n\
    \            $n_fill += $n_fill_here if $n_fill_here > 0;\n        }\n    }\n\
    \    return $n_fill;\n}", "    my $n = scalar(@$grid);\n    my $m = scalar(@{$grid->[0]});\n\
    \    my $count = 0;\n    for my $i (0..$n-1) {\n        my $j = 0;\n        my\
    \ $full = 0;\n        while ($j < $m) {\n            if ($grid->[$i][$j] == 1)\
    \ {\n                last;\n            }\n            $j += 1;\n        }\n \
    \       if ($j < $m) {\n            my $p = $i;\n            my $q = $j + 1;\n\
    \            my $fill = $capacity;\n            while ($p >= 0) {\n          \
    \      if ($grid->[$p][$j] == 1) {\n                    last;\n              \
    \  }\n                $fill -= 1;\n                $p -= 1;\n            }\n \
    \           while ($q < $m) {\n                if ($grid->[$i][$q] == 1) {\n \
    \                   last;\n                }\n                $fill -= 1;\n  \
    \              $q += 1;\n            }\n            if ($fill > 0) {\n       \
    \         $count += $fill;\n            }\n        }\n    }\n    return $count;\n\
    }", "    my $count = 0;\n    for my $row (@$grid) {\n        for my $cell (@$row)\
    \ {\n            if ($cell) {\n                $count += $capacity - $cell;\n\
    \            }\n        }\n    }\n    return $count;\n}\nuse Test::More;\nis max_fill([[0,0,1,0],\
    \ [0,1,0,0], [1,1,1,1]], 1), 6;\nis max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1],\
    \ [0,1,1,1]], 2), 5;\nis max_fill([[0,0,0], [0,0,0]], 5), 0;\ndone_testing();",
  "    my $max = 0;\n    for my $row (@$grid) {\n        my $total = 0;\n        for\
    \ my $i (0..$#$row) {\n            if ($row->[$i] == 1) {\n                $total\
    \ += $i+1;\n            }\n        }\n        $max = $total if $total > $max;\n\
    \    }\n    return $max/$capacity;\n}", "    my $n_rows = @$grid;\n    my $n_cols\
    \ = @{$grid->[0]};\n    my $count = 0;\n    for my $row (0..$n_rows-1) {\n   \
    \     for my $col (0..$n_cols-1) {\n            if ($grid->[$row][$col] == 1)\
    \ {\n                my $fill = $capacity;\n                for my $i (0..$n_rows-1)\
    \ {\n                    for my $j (0..$n_cols-1) {\n                        if\
    \ ($grid->[$i][$j] == 1 &&\n                            ($i != $row || $j != $col))\
    \ {\n                            $fill--;\n                            last if\
    \ $fill == 0;\n                        }\n                    }\n            \
    \        last if $fill == 0;\n                }\n                if ($fill > 0)\
    \ {\n                    $count += $fill;\n                    $grid->[$row][$col]\
    \ = 0;\n                }\n            }\n        }\n    }\n    return $count;\n\
    }", "    my $row_num = @$grid;\n    my $col_num = @{$grid->[0]};\n    my $water_num\
    \ = 0;\n    my $bucket_num = 0;\n    for (my $row_idx = 0; $row_idx < $row_num;\
    \ $row_idx++) {\n        for (my $col_idx = 0; $col_idx < $col_num; $col_idx++)\
    \ {\n            if ($grid->[$row_idx][$col_idx] == 1) {\n                $water_num++;\n\
    \            }\n        }\n    }\n    $bucket_num = int($water_num / $capacity);\n\
    \    if ($water_num % $capacity != 0) {\n        $bucket_num++;\n    }\n    return\
    \ $bucket_num;\n}", "    my $max_fill = 0;\n    foreach my $row (@$grid) {\n \
    \       my $fill = 0;\n        foreach my $cell (@$row) {\n            $fill +=\
    \ $cell;\n            $fill = $capacity if $fill > $capacity;\n        }\n   \
    \     $max_fill = $fill if $fill > $max_fill;\n    }\n    return $max_fill;\n}",
  "    my $n = @$grid;\n    my $m = @{$grid->[0]};\n    my $row_max = [];\n    my\
    \ $ans = 0;\n    for (my $i=0; $i<$n; $i++) {\n        my $r = $grid->[$i];\n\
    \        my $row_max = max(map {$r->[$_]} 0..$m-1);\n        for (my $j=0; $j<$m;\
    \ $j++) {\n            my $diff = $row_max - $r->[$j];\n            my $t = $diff\
    \ / $capacity;\n            $ans += $t;\n            $ans += ($diff % $capacity)>0\
    \ ? 1 : 0;\n        }\n    }\n    return $ans;\n}"]
stop_tokens:
- "\nsub"
- "\n#"
- "\n\n"
