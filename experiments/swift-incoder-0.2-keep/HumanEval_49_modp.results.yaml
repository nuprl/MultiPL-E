language: swift
name: HumanEval_49_modp
results:
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n\tif n < 0 {\n\t\tpanic(\"modp called with negative n\")\n\t}\n\tif p < 0\
    \ {\n\t\tpanic(\"modp called with negative p\")\n\t}\n\tif n == 0 {\n\t\treturn\
    \ 1\n\t}\n\tif p == 1 {\n\t\treturn n\n\t}\n\tq := n / p\n\tr := n % p\n\tif r\
    \ == 0 {\n\t\treturn q\n\t}\n\treturn q + modp(q, p)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\n\
    assert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpk3lnjdwz.swift:26:3: error: consecutive statements on a line must\
    \ be separated by ';'\n        q := n / p\n         ^\n         ;\n/tmp/tmpk3lnjdwz.swift:26:4:\
    \ error: expected expression\n        q := n / p\n          ^\n/tmp/tmpk3lnjdwz.swift:15:3:\
    \ error: cannot find 'panic' in scope\n                panic(\"modp called with\
    \ negative n\")\n                ^~~~~\n/tmp/tmpk3lnjdwz.swift:18:3: error: cannot\
    \ find 'panic' in scope\n                panic(\"modp called with negative p\"\
    )\n                ^~~~~\n/tmp/tmpk3lnjdwz.swift:26:2: error: cannot find 'q'\
    \ in scope\n        q := n / p\n        ^\n/tmp/tmpk3lnjdwz.swift:28:5: error:\
    \ cannot find 'r' in scope\n        if r == 0 {\n           ^\n/tmp/tmpk3lnjdwz.swift:29:10:\
    \ error: cannot find 'q' in scope\n                return q\n                \
    \       ^\n/tmp/tmpk3lnjdwz.swift:31:9: error: cannot find 'q' in scope\n    \
    \    return q + modp(q, p)\n               ^\n/tmp/tmpk3lnjdwz.swift:31:18: error:\
    \ cannot find 'q' in scope\n        return q + modp(q, p)\n                  \
    \      ^\n/tmp/tmpk3lnjdwz.swift:31:17: error: missing argument labels 'n:p:'\
    \ in call\n        return q + modp(q, p)\n                       ^\n         \
    \               n: p: \n"
  stdout: ''
  timestamp: 1660014749
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n\tswitch {\n\tcase n < 0:\n\t\treturn modp(abs(n), p)\n\tcase p < 0:\n\t\t\
    return modp(-n, p)\n\tcase p == 0:\n\t\treturn 0\n\tdefault:\n\t\treturn ((n &\
    \ (p - 1)) == 0) ? n : modp(n >> 1, p)\n\t}\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp_8bg_7jy.swift:14:9: error: expected expression in 'switch' statement\n\
    \        switch {\n               ^\n/tmp/tmp_8bg_7jy.swift:16:14: error: missing\
    \ argument labels 'n:p:' in call\n                return modp(abs(n), p)\n   \
    \                        ^\n                            n:      p: \n/tmp/tmp_8bg_7jy.swift:18:14:\
    \ error: missing argument labels 'n:p:' in call\n                return modp(-n,\
    \ p)\n                           ^\n                            n:  p: \n/tmp/tmp_8bg_7jy.swift:22:41:\
    \ error: missing argument labels 'n:p:' in call\n                return ((n &\
    \ (p - 1)) == 0) ? n : modp(n >> 1, p)\n                                     \
    \                 ^\n                                                       n:\
    \      p: \n"
  stdout: ''
  timestamp: 1660014749
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n        return\
    \ p\n    }\n    if p < 0 {\n        return modp(n - 1, p + p)\n    }\n    if p\
    \ > n {\n        return modp(n - 1, p)\n    }\n    if p % 2 == 0 {\n        return\
    \ modp(n / 2, p)\n    }\n    return modp(n / 2, p + p)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\n\
    assert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpiocctc6v.swift:21:20: error: missing argument labels 'n:p:' in\
    \ call\n        return modp(n - 1, p + p)\n                   ^\n            \
    \        n:     p: \n/tmp/tmpiocctc6v.swift:24:20: error: missing argument labels\
    \ 'n:p:' in call\n        return modp(n - 1, p)\n                   ^\n      \
    \              n:     p: \n/tmp/tmpiocctc6v.swift:27:20: error: missing argument\
    \ labels 'n:p:' in call\n        return modp(n / 2, p)\n                   ^\n\
    \                    n:     p: \n/tmp/tmpiocctc6v.swift:29:16: error: missing\
    \ argument labels 'n:p:' in call\n    return modp(n / 2, p + p)\n            \
    \   ^\n                n:     p: \n"
  stdout: ''
  timestamp: 1660014749
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n\tif n < 0 {\n\t\tpanic(\"modp: negative number\")\n\t}\n\tif p < 1 {\n\t\
    \tpanic(\"modp: p < 1\")\n\t}\n\tif p > p {\n\t\tpanic(\"modp: p > p\")\n\t}\n\
    \tif n == 0 {\n\t\treturn 0\n\t}\n\tif n == 1 {\n\t\treturn p\n\t}\n\tif n ==\
    \ p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\t\
    return n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\
    \t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif\
    \ n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\
    \t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn\
    \ n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\
    \tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n ==\
    \ p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\t\
    return n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\
    \t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif\
    \ n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\
    \t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn\
    \ n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\
    \tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n ==\
    \ p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\t\
    return n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\
    \t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif\
    \ n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\
    \t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn\
    \ n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\
    \tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n ==\
    \ p {\n\t\treturn n\n\t}\n\tif n == \n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpg2pxalzs.swift:177:1: error: expected expression after operator\n\
    }\n^\n/tmp/tmpg2pxalzs.swift:15:3: error: cannot find 'panic' in scope\n     \
    \           panic(\"modp: negative number\")\n                ^~~~~\n/tmp/tmpg2pxalzs.swift:18:3:\
    \ error: cannot find 'panic' in scope\n                panic(\"modp: p < 1\")\n\
    \                ^~~~~\n/tmp/tmpg2pxalzs.swift:21:3: error: cannot find 'panic'\
    \ in scope\n                panic(\"modp: p > p\")\n                ^~~~~\n"
  stdout: ''
  timestamp: 1660014749
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    if n < 0 {\n        return modp(abs(n), p)\n    }\n    if p < 0 {\n \
    \       return modp(n, abs(p))\n    }\n    if n == 0 {\n        return 0\n   \
    \ }\n    if p == 0 {\n        return n\n    }\n    if p > n {\n        return\
    \ modp(n, p)\n    }\n    if p < n {\n        return modp(n, p)\n    }\n    if\
    \ n == p {\n        return n\n    }\n    if n == 0 {\n        return 0\n    }\n\
    \    if p == 1 {\n        return n\n    }\n    if n == 1 {\n        return p\n\
    \    }\n    if n == p {\n        return n\n    }\n    if n == p {\n        return\
    \ p\n    }\n    if n == 1 {\n        return p\n    }\n    if n == 0 {\n      \
    \  return 0\n    }\n    if p == 1 {\n        return n\n    }\n    if n == 1 {\n\
    \        return p\n    }\n    if n == p {\n        return n\n    }\n    if n ==\
    \ p {\n        return p\n    }\n    if n == 1 {\n        return p\n    }\n   \
    \ if n == 0 {\n        return 0\n    }\n    if p == 1 {\n        return n\n  \
    \  }\n    if n == 1 {\n        return p\n    }\n    if n == p {\n        return\
    \ n\n    }\n    if n == p {\n        return p\n    }\n    if n == 1 {\n      \
    \  return p\n    }\n    if n == 0 {\n        return 0\n    }\n    if p == 1 {\n\
    \        return n\n    }\n    if n == 1 {\n        return p\n    }\n    if n ==\
    \ p {\n        return n\n    }\n    if n == p {\n        return p\n    }\n   \
    \ if n == 1 {\n        return p\n    }\n    if n == 0 {\n        return 0\n  \
    \  }\n    if p == 1 {\n        return n\n    }\n    if n == 1 {\n        return\
    \ p\n    }\n    if n == p {\n        return n\n    }\n    if n == p {\n      \
    \  return p\n    }\n    if n == 1 {\n        return p\n    }\n    if n == 0 {\n\
    \        return 0\n    }\n    if p == 1 {\n        return n\n    }\n    if n ==\
    \ 1 {\n        return p\n    }\n    if n == p {\n        return n\n    }\n   \
    \ if n == p {\n        return p\n    }\n    if n == 1 {\n        return p\n  \
    \  }\n    if n == 0 {\n        return 0\n    }\n    if p == 1 {\n        return\
    \ n\n    }\n    if n == 1 {\n        return p\n    }\n    if n == p {\n      \
    \  return n\n    }\n    if n == p {\n        return p\n    }\n    if n == 1 {\n\
    \        return p\n    }\n    if n == 0 {\n        return 0\n    }\n    if p ==\
    \ 1 {\n        return n\n    }\n    if n == 1 {\n        return p\n    }\n   \
    \ if n == p {\n        return n\n    }\n    if n == p {\n        return p\n  \
    \  }\n    if n == 1 {\n        return p\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpd66vvfc1.swift:199:31: error: expected '}' at end of brace statement\n\
    assert(modp(n: 31, p: 5) == 3)\n                              ^\n/tmp/tmpd66vvfc1.swift:13:34:\
    \ note: to match this opening '{'\nfunc modp(n: Int, p: Int) -> Int {\n      \
    \                           ^\n/tmp/tmpd66vvfc1.swift:15:20: error: missing argument\
    \ labels 'n:p:' in call\n        return modp(abs(n), p)\n                   ^\n\
    \                    n:      p: \n/tmp/tmpd66vvfc1.swift:18:20: error: missing\
    \ argument labels 'n:p:' in call\n        return modp(n, abs(p))\n           \
    \        ^\n                    n: p: \n/tmp/tmpd66vvfc1.swift:27:20: error: missing\
    \ argument labels 'n:p:' in call\n        return modp(n, p)\n                \
    \   ^\n                    n: p: \n/tmp/tmpd66vvfc1.swift:30:20: error: missing\
    \ argument labels 'n:p:' in call\n        return modp(n, p)\n                \
    \   ^\n                    n: p: \n/tmp/tmpd66vvfc1.swift:181:6: error: operator\
    \ functions can only be declared at global or in type scope\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660014749
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    if n < 0 {\n        return modp(abs(n), p)\n    }\n    if p < 0 {\n \
    \       return modp(n, abs(p))\n    }\n    if n == 0 {\n        return 0\n   \
    \ }\n    if p == 0 {\n        return n\n    }\n    if p == 1 {\n        return\
    \ n\n    }\n    if n == 1 {\n        return p\n    }\n    if n == p {\n      \
    \  return modp(n - 1, p)\n    }\n    if n == p + 1 {\n        return modp(n, p)\n\
    \    }\n    if n == p + 2 {\n        return modp(n, p)\n    }\n    if n == p +\
    \ 3 {\n        return modp(n, p)\n    }\n    if n == p + 4 {\n        return modp(n,\
    \ p)\n    }\n    if n == p + 5 {\n        return modp(n, p)\n    }\n    if n ==\
    \ p + 6 {\n        return modp(n, p)\n    }\n    if n == p + 7 {\n        return\
    \ modp(n, p)\n    }\n    if n == p + 8 {\n        return modp(n, p)\n    }\n \
    \   if n == p + 9 {\n        return modp(n, p)\n    }\n    if n == p + 10 {\n\
    \        return modp(n, p)\n    }\n    if n == p + 11 {\n        return modp(n,\
    \ p)\n    }\n    if n == p + 12 {\n        return modp(n, p)\n    }\n    if n\
    \ == p + 13 {\n        return modp(n, p)\n    }\n    if n == p + 14 {\n      \
    \  return modp(n, p)\n    }\n    if n == p + 15 {\n        return modp(n, p)\n\
    \    }\n    if n == p + 16 {\n        return modp(n, p)\n    }\n    if n == p\
    \ + 17 {\n        return modp(n, p)\n    }\n    if n == p + 18 {\n        return\
    \ modp(n, p)\n    }\n    if n == p + 19 {\n        return modp(n, p)\n    }\n\
    \    if n == p + 20 {\n        return modp(n, p)\n    }\n    if n == p + 21 {\n\
    \        return modp(n, p)\n    }\n    if n == p + 22 {\n        return modp(n,\
    \ p)\n    }\n    if n == p + 23 {\n        return modp(n, p)\n    }\n    if n\
    \ == p + 24 {\n        return modp(n, p)\n    }\n    if n == p + 25 {\n      \
    \  return modp(n, p)\n    }\n    if n == p + 26 {\n        return modp(n, p)\n\
    \    }\n    if n == p + 27 {\n        return modp(n, p)\n    }\n    if n == p\
    \ + 28 {\n        return modp(n, p)\n    }\n    if n == p + 29 {\n        return\
    \ modp(n, p)\n    }\n    if n == p\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmprncx8u02.swift:122:14: error: expected '{' after 'if' condition\n\
    \    if n == p\n             ^\n/tmp/tmprncx8u02.swift:15:20: error: missing argument\
    \ labels 'n:p:' in call\n        return modp(abs(n), p)\n                   ^\n\
    \                    n:      p: \n/tmp/tmprncx8u02.swift:18:20: error: missing\
    \ argument labels 'n:p:' in call\n        return modp(n, abs(p))\n           \
    \        ^\n                    n: p: \n/tmp/tmprncx8u02.swift:33:20: error: missing\
    \ argument labels 'n:p:' in call\n        return modp(n - 1, p)\n            \
    \       ^\n                    n:     p: \n/tmp/tmprncx8u02.swift:36:20: error:\
    \ missing argument labels 'n:p:' in call\n        return modp(n, p)\n        \
    \           ^\n                    n: p: \n/tmp/tmprncx8u02.swift:39:20: error:\
    \ missing argument labels 'n:p:' in call\n        return modp(n, p)\n        \
    \           ^\n                    n: p: \n/tmp/tmprncx8u02.swift:42:20: error:\
    \ missing argument labels 'n:p:' in call\n        return modp(n, p)\n        \
    \           ^\n                    n: p: \n/tmp/tmprncx8u02.swift:45:20: error:\
    \ missing argument labels 'n:p:' in call\n        return modp(n, p)\n        \
    \           ^\n                    n: p: \n/tmp/tmprncx8u02.swift:48:20: error:\
    \ missing argument labels 'n:p:' in call\n        return modp(n, p)\n        \
    \           ^\n                    n: p: \n/tmp/tmprncx8u02.swift:51:20: error:\
    \ missing argument labels 'n:p:' in call\n        return modp(n, p)\n        \
    \           ^\n                    n: p: \n/tmp/tmprncx8u02.swift:54:20: error:\
    \ missing argument labels 'n:p:' in call\n        return modp(n, p)\n        \
    \           ^\n                    n: p: \n/tmp/tmprncx8u02.swift:57:20: error:\
    \ missing argument labels 'n:p:' in call\n        return modp(n, p)\n        \
    \           ^\n                    n: p: \n/tmp/tmprncx8u02.swift:60:20: error:\
    \ missing argument labels 'n:p:' in call\n        return modp(n, p)\n        \
    \           ^\n                    n: p: \n/tmp/tmprncx8u02.swift:63:20: error:\
    \ missing argument labels 'n:p:' in call\n        return modp(n, p)\n        \
    \           ^\n "
  stdout: ''
  timestamp: 1660014749
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n\tif n < 0 {\n\t\tpanic(\"modp: negative number\")\n\t}\n\tif p < 2 {\n\t\
    \tpanic(\"modp: p < 2\")\n\t}\n\tif n == 0 {\n\t\treturn 1\n\t}\n\tif n == 1 {\n\
    \t\treturn p\n\t}\n\tif n == p {\n\t\treturn 1\n\t}\n\tif p < p {\n\t\treturn\
    \ modp(n - 1, p)\n\t}\n\tq := modp(n - 1, p)\n\tif q == p {\n\t\treturn 1\n\t\
    }\n\treturn q\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmps297conv.swift:32:3: error: consecutive statements on a line must\
    \ be separated by ';'\n        q := modp(n - 1, p)\n         ^\n         ;\n/tmp/tmps297conv.swift:32:4:\
    \ error: expected expression\n        q := modp(n - 1, p)\n          ^\n/tmp/tmps297conv.swift:15:3:\
    \ error: cannot find 'panic' in scope\n                panic(\"modp: negative\
    \ number\")\n                ^~~~~\n/tmp/tmps297conv.swift:18:3: error: cannot\
    \ find 'panic' in scope\n                panic(\"modp: p < 2\")\n            \
    \    ^~~~~\n/tmp/tmps297conv.swift:30:14: error: missing argument labels 'n:p:'\
    \ in call\n                return modp(n - 1, p)\n                           ^\n\
    \                            n:     p: \n/tmp/tmps297conv.swift:32:2: error: cannot\
    \ find 'q' in scope\n        q := modp(n - 1, p)\n        ^\n/tmp/tmps297conv.swift:33:5:\
    \ error: cannot find 'q' in scope\n        if q == p {\n           ^\n/tmp/tmps297conv.swift:36:9:\
    \ error: cannot find 'q' in scope\n        return q\n               ^\n"
  stdout: ''
  timestamp: 1660014749
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    if n < 0 {\n        return modp(abs(n), p)\n    }\n    if p < 0 {\n \
    \       return modp(n, abs(p))\n    }\n    if n == 0 {\n        return 0\n   \
    \ }\n    if p == 0 {\n        return n\n    }\n    if p == 1 {\n        return\
    \ n\n    }\n    if n == 1 {\n        return p\n    }\n    if n == p {\n      \
    \  return n\n    }\n    if n == p+1 {\n        return p\n    }\n    if n == p+2\
    \ {\n        return p+1\n    }\n    if n == p+3 {\n        return p+2\n    }\n\
    \    if n == p+4 {\n        return p+3\n    }\n    if n == p+5 {\n        return\
    \ p+4\n    }\n    if n == p+6 {\n        return p+5\n    }\n    if n == p+7 {\n\
    \        return p+6\n    }\n    if n == p+8 {\n        return p+7\n    }\n   \
    \ if n == p+9 {\n        return p+8\n    }\n    if n == p+10 {\n        return\
    \ p+9\n    }\n    if n == p+11 {\n        return p+10\n    }\n    if n == p+12\
    \ {\n        return p+11\n    }\n    if n == p+13 {\n        return p+12\n   \
    \ }\n    if n == p+14 {\n        return p+13\n    }\n    if n == p+15 {\n    \
    \    return p+14\n    }\n    if n == p+16 {\n        return p+15\n    }\n    if\
    \ n == p+17 {\n        return p+16\n    }\n    if n == p+18 {\n        return\
    \ p+17\n    }\n    if n == p+19 {\n        return p+18\n    }\n    if n == p+20\
    \ {\n        return p+19\n    }\n    if n == p+21 {\n        return p+20\n   \
    \ }\n    if n == p+22 {\n        return p+21\n    }\n    if n == p+23 {\n    \
    \    return p+22\n    }\n    if n == p+24 {\n        return p+23\n    }\n    if\
    \ n == p+25 {\n        return p+24\n    }\n    if n == p+26 {\n        return\
    \ p+25\n    }\n    if n == p+27 {\n        return p+26\n    }\n    if n == p+28\
    \ {\n        return p+27\n    }\n    if n == p+29 {\n        return p+28\n   \
    \ }\n    if n == p+30 {\n        return p+29\n    }\n    if n == p+31 {\n    \
    \    return p+30\n    }\n    if n == p+32 {\n        return p+31\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp4pfwxnjc.swift:151:31: error: expected '}' at end of brace statement\n\
    assert(modp(n: 31, p: 5) == 3)\n                              ^\n/tmp/tmp4pfwxnjc.swift:13:34:\
    \ note: to match this opening '{'\nfunc modp(n: Int, p: Int) -> Int {\n      \
    \                           ^\n/tmp/tmp4pfwxnjc.swift:15:20: error: missing argument\
    \ labels 'n:p:' in call\n        return modp(abs(n), p)\n                   ^\n\
    \                    n:      p: \n/tmp/tmp4pfwxnjc.swift:18:20: error: missing\
    \ argument labels 'n:p:' in call\n        return modp(n, abs(p))\n           \
    \        ^\n                    n: p: \n/tmp/tmp4pfwxnjc.swift:133:6: error: operator\
    \ functions can only be declared at global or in type scope\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660014749
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n\tif n < 0 {\n\t\tpanic(\"modp(n,p)\")\n\t}\n\tif p < 1 {\n\t\tpanic(\"modp(n,p)\"\
    )\n\t}\n\tif n == 0 {\n\t\treturn 1\n\t}\n\tif n == 1 {\n\t\treturn p\n\t}\n\t\
    if p > p {\n\t\tpanic(\"modp(n,p)\")\n\t}\n\tx := n\n\ty := p\n\tz := 1\n\tfor\
    \ {\n\t\tif x == 0 {\n\t\t\treturn z\n\t\t}\n\t\tif y == 0 {\n\t\t\treturn z\n\
    \t\t}\n\t\tif x == y {\n\t\t\tbreak\n\t\t}\n\t\tx -= y\n\t\ty %= x\n\t\tz <<=\
    \ 1\n\t}\n\treturn z\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3,\
    \ p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) ==\
    \ 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp785d71md.swift:29:3: error: consecutive statements on a line must\
    \ be separated by ';'\n        x := n\n         ^\n         ;\n/tmp/tmp785d71md.swift:29:4:\
    \ error: expected expression\n        x := n\n          ^\n/tmp/tmp785d71md.swift:32:6:\
    \ error: expected pattern\n        for {\n            ^\n/tmp/tmp785d71md.swift:32:6:\
    \ error: expected Sequence expression for for-each loop\n        for {\n     \
    \       ^\n/tmp/tmp785d71md.swift:15:3: error: cannot find 'panic' in scope\n\
    \                panic(\"modp(n,p)\")\n                ^~~~~\n/tmp/tmp785d71md.swift:18:3:\
    \ error: cannot find 'panic' in scope\n                panic(\"modp(n,p)\")\n\
    \                ^~~~~\n/tmp/tmp785d71md.swift:27:3: error: cannot find 'panic'\
    \ in scope\n                panic(\"modp(n,p)\")\n                ^~~~~\n/tmp/tmp785d71md.swift:29:2:\
    \ error: cannot find 'x' in scope\n        x := n\n        ^\n/tmp/tmp785d71md.swift:46:9:\
    \ error: cannot find 'z' in scope\n        return z\n               ^\n"
  stdout: ''
  timestamp: 1660014749
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    if n < 0 {\n        return modp(abs(n), p)\n    }\n    if p < 0 {\n \
    \       return modp(n, abs(p))\n    }\n    if n == 0 {\n        return 0\n   \
    \ }\n    if p == 0 {\n        return n\n    }\n    if p > n {\n        return\
    \ modp(n, p)\n    }\n    if p < n {\n        return modp(n, p)\n    }\n    if\
    \ n == 1 {\n        return p\n    }\n    if n == p {\n        return n\n    }\n\
    \    if n == p {\n        return p\n    }\n    if n == p+1 {\n        return p\n\
    \    }\n    if n == p-1 {\n        return n\n    }\n    if n == p+2 {\n      \
    \  return p\n    }\n    if n == p-2 {\n        return n\n    }\n    if n == p+3\
    \ {\n        return p\n    }\n    if n == p-3 {\n        return n\n    }\n   \
    \ if n == p+4 {\n        return p\n    }\n    if n == p-4 {\n        return n\n\
    \    }\n    if n == p+5 {\n        return p\n    }\n    if n == p-5 {\n      \
    \  return n\n    }\n    if n == p+6 {\n        return p\n    }\n    if n == p-6\
    \ {\n        return n\n    }\n    if n == p+7 {\n        return p\n    }\n   \
    \ if n == p-7 {\n        return n\n    }\n    if n == p+8 {\n        return p\n\
    \    }\n    if n == p-8 {\n        return n\n    }\n    if n == p+9 {\n      \
    \  return p\n    }\n    if n == p-9 {\n        return n\n    }\n    if n == p+10\
    \ {\n        return p\n    }\n    if n == p-10 {\n        return n\n    }\n  \
    \  if n == p+11 {\n        return p\n    }\n    if n == p-11 {\n        return\
    \ n\n    }\n    if n == p+12 {\n        return p\n    }\n    if n == p-12 {\n\
    \        return n\n    }\n    if n == p+13 {\n        return p\n    }\n    if\
    \ n == p-13 {\n        return n\n    }\n    if n == p+14 {\n        return p\n\
    \    }\n    if n == p-14 {\n        return n\n    }\n    if n == p+15 {\n    \
    \    return p\n    }\n    if n == p-15 {\n        return n\n    }\n    if n ==\
    \ p+16 {\n        return p\n    }\n    if n == p-16 {\n        return n\n    }\n\
    \    if n == p+17 {\n        return p\n    }\n    if n == p-17 {\n        return\
    \ n\n    }\n    if n == p+18 {\n        return p\n    }\n    if n == p-18 {\n\
    \        return n\n    }\n    if n == p+19\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp76sv8y8z.swift:149:17: error: expected '{' after 'if' condition\n\
    \    if n == p+19\n                ^\n/tmp/tmp76sv8y8z.swift:15:20: error: missing\
    \ argument labels 'n:p:' in call\n        return modp(abs(n), p)\n           \
    \        ^\n                    n:      p: \n/tmp/tmp76sv8y8z.swift:18:20: error:\
    \ missing argument labels 'n:p:' in call\n        return modp(n, abs(p))\n   \
    \                ^\n                    n: p: \n/tmp/tmp76sv8y8z.swift:27:20:\
    \ error: missing argument labels 'n:p:' in call\n        return modp(n, p)\n \
    \                  ^\n                    n: p: \n/tmp/tmp76sv8y8z.swift:30:20:\
    \ error: missing argument labels 'n:p:' in call\n        return modp(n, p)\n \
    \                  ^\n                    n: p: \n"
  stdout: ''
  timestamp: 1660014749
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n\tif n < 0 {\n\t\tpanic(\"modp: negative number\")\n\t}\n\tif p < 2 {\n\t\
    \tpanic(\"modp: p < 2\")\n\t}\n\tif n == 0 {\n\t\treturn 1\n\t}\n\tif n == 1 {\n\
    \t\treturn p\n\t}\n\tif p > p {\n\t\tpanic(\"modp: p > p\")\n\t}\n\tq := p / 2\n\
    \tr := p % 2\n\tx := n\n\ty := 1\n\tfor {\n\t\tif x == 0 {\n\t\t\treturn y\n\t\
    \t}\n\t\ty *= x\n\t\tx /= q\n\t\tif x == 0 {\n\t\t\treturn y\n\t\t}\n\t}\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpupflfhss.swift:29:3: error: consecutive statements on a line must\
    \ be separated by ';'\n        q := p / 2\n         ^\n         ;\n/tmp/tmpupflfhss.swift:29:4:\
    \ error: expected expression\n        q := p / 2\n          ^\n/tmp/tmpupflfhss.swift:33:6:\
    \ error: expected pattern\n        for {\n            ^\n/tmp/tmpupflfhss.swift:33:6:\
    \ error: expected Sequence expression for for-each loop\n        for {\n     \
    \       ^\n/tmp/tmpupflfhss.swift:15:3: error: cannot find 'panic' in scope\n\
    \                panic(\"modp: negative number\")\n                ^~~~~\n/tmp/tmpupflfhss.swift:18:3:\
    \ error: cannot find 'panic' in scope\n                panic(\"modp: p < 2\")\n\
    \                ^~~~~\n/tmp/tmpupflfhss.swift:27:3: error: cannot find 'panic'\
    \ in scope\n                panic(\"modp: p > p\")\n                ^~~~~\n/tmp/tmpupflfhss.swift:29:2:\
    \ error: cannot find 'q' in scope\n        q := p / 2\n        ^\n"
  stdout: ''
  timestamp: 1660014749
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    if n == 0 {\n        return 0\n    }\n    if p == 0 {\n        return\
    \ n\n    }\n    if n >= p {\n        return n - p\n    }\n    return p + modp(n\
    \ - p, p)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp042pp6e6.swift:23:20: error: missing argument labels 'n:p:' in\
    \ call\n    return p + modp(n - p, p)\n                   ^\n                \
    \    n:     p: \n"
  stdout: ''
  timestamp: 1660014749
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    if n < 0 {\n        return modp(abs(n), p)\n    }\n    if p < 0 {\n \
    \       return modp(n, abs(p))\n    }\n    if n == 0 {\n        return 0\n   \
    \ }\n    if p == 0 {\n        return n\n    }\n    if p > n {\n        return\
    \ modp(n, p)\n    }\n    if p < n {\n        return modp(n, p)\n    }\n    if\
    \ n == 1 {\n        return p\n    }\n    if n == p {\n        return n\n    }\n\
    \    if n == p {\n        return n\n    }\n    if n == p {\n        return n\n\
    \    }\n    if n == p {\n        return n\n    }\n    if n == p {\n        return\
    \ n\n    }\n    if n == p {\n        return n\n    }\n    if n == p {\n      \
    \  return n\n    }\n    if n == p {\n        return n\n    }\n    if n == p {\n\
    \        return n\n    }\n    if n == p {\n        return n\n    }\n    if n ==\
    \ p {\n        return n\n    }\n    if n == p {\n        return n\n    }\n   \
    \ if n == p {\n        return n\n    }\n    if n == p {\n        return n\n  \
    \  }\n    if n == p {\n        return n\n    }\n    if n == p {\n        return\
    \ n\n    }\n    if n == p {\n        return n\n    }\n    if n == p {\n      \
    \  return n\n    }\n    if n == p {\n        return n\n    }\n    if n == p {\n\
    \        return n\n    }\n    if n == p {\n        return n\n    }\n    if n ==\
    \ p {\n        return n\n    }\n    if n == p {\n        return n\n    }\n   \
    \ if n == p {\n        return n\n    }\n    if n == p {\n        return n\n  \
    \  }\n    if n == p {\n        return n\n    }\n    if n == p {\n        return\
    \ n\n    }\n    if n == p {\n        return n\n    }\n    if n == p {\n      \
    \  return n\n    }\n    if n == p {\n        return n\n    }\n    if n == p {\n\
    \        return n\n    }\n    if n == p {\n        return n\n    }\n    if n ==\
    \ p {\n        return n\n    }\n    if n == p {\n        return n\n    }\n   \
    \ if n == p {\n        return n\n    }\n    if n == p {\n        return n\n  \
    \  }\n    if n == p {\n        return n\n    }\n    if n == p {\n        return\
    \ n\n    }\n    if n == p {\n        return n\n    }\n    if n == p {\n      \
    \  return n\n    }\n    if n == p {\n        return n\n    }\n    if n == p {\n\
    \        return n\n    }\n    if n == p {\n        return n\n    }\n    if n ==\
    \ p {\n        return n\n    }\n    if n == p {\n        return n\n    }\n   \
    \ if n == p {\n        return n\n    }\n    if n == p {\n        return n\n  \
    \  }\n    if n == p {\n        return n\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpsh2vr1jd.swift:199:31: error: expected '}' at end of brace statement\n\
    assert(modp(n: 31, p: 5) == 3)\n                              ^\n/tmp/tmpsh2vr1jd.swift:13:34:\
    \ note: to match this opening '{'\nfunc modp(n: Int, p: Int) -> Int {\n      \
    \                           ^\n/tmp/tmpsh2vr1jd.swift:15:20: error: missing argument\
    \ labels 'n:p:' in call\n        return modp(abs(n), p)\n                   ^\n\
    \                    n:      p: \n/tmp/tmpsh2vr1jd.swift:18:20: error: missing\
    \ argument labels 'n:p:' in call\n        return modp(n, abs(p))\n           \
    \        ^\n                    n: p: \n/tmp/tmpsh2vr1jd.swift:27:20: error: missing\
    \ argument labels 'n:p:' in call\n        return modp(n, p)\n                \
    \   ^\n                    n: p: \n/tmp/tmpsh2vr1jd.swift:30:20: error: missing\
    \ argument labels 'n:p:' in call\n        return modp(n, p)\n                \
    \   ^\n                    n: p: \n/tmp/tmpsh2vr1jd.swift:181:6: error: operator\
    \ functions can only be declared at global or in type scope\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660014749
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    if n < 0 {\n        return modp(-n, p)\n    }\n    if p < 1 {\n     \
    \   return modp(n, p - 1)\n    }\n    if p == 1 {\n        return n\n    }\n \
    \   if n == 0 {\n        return 0\n    }\n    if n == 1 {\n        return p\n\
    \    }\n    if n == p {\n        return modp(n - 1, p)\n    }\n    if n == p -\
    \ 1 {\n        return modp(n, p)\n    }\n    if n == p - 2 {\n        return modp(n,\
    \ p - 1)\n    }\n    if n == p - 3 {\n        return modp(n, p - 2)\n    }\n \
    \   if n == p - 4 {\n        return modp(n, p - 3)\n    }\n    if n == p - 5 {\n\
    \        return modp(n, p - 4)\n    }\n    if n == p - 6 {\n        return modp(n,\
    \ p - 5)\n    }\n    if n == p - 7 {\n        return modp(n, p - 6)\n    }\n \
    \   if n == p - 8 {\n        return modp(n, p - 7)\n    }\n    if n == p - 9 {\n\
    \        return modp(n, p - 8)\n    }\n    if n == p - 10 {\n        return modp(n,\
    \ p - 9)\n    }\n    if n == p - 11 {\n        return modp(n, p - 10)\n    }\n\
    \    if n == p - 12 {\n        return modp(n, p - 11)\n    }\n    if n == p -\
    \ 13 {\n        return modp(n, p - 12)\n    }\n    if n == p - 14 {\n        return\
    \ modp(n, p - 13)\n    }\n    if n == p - 15 {\n        return modp(n, p - 14)\n\
    \    }\n    if n == p - 16 {\n        return modp(n, p - 15)\n    }\n    if n\
    \ == p - 17 {\n        return modp(n, p - 16)\n    }\n    if n == p - 18 {\n \
    \       return modp(n, p - 17)\n    }\n    if n == p - 19 {\n        return modp(n,\
    \ p - 18)\n    }\n    if n == p - 20 {\n        return modp(n, p - 19)\n    }\n\
    \    if n == p - 21 {\n        return modp(n, p - 20)\n    }\n    if n == p -\
    \ 22 {\n        return modp(n, p - 21)\n    }\n    if n == p - 23 {\n        return\
    \ modp(n, p - 22)\n    }\n    if n == p - 24 {\n        return modp(n, p - 23)\n\
    \    }\n    if n == p - 25 {\n        return modp(n, p - 24)\n    }\n    if n\
    \ == p - 26 {\n        return modp(n, p - 25)\n    }\n    if n == p - 27 {\n \
    \       return modp(n, p - 26)\n    }\n    if n == p - 28 {\n        return modp(n,\
    \ p - 27)\n    }\n    if n == p - 29 {\n        return modp(n, p - 28)\n    }\n\
    \    if n == p - 30 {\n        return modp(n, \n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpdg_6009v.swift:121:1: error: expected expression in list of expressions\n\
    }\n^\n/tmp/tmpdg_6009v.swift:142:31: error: expected '}' at end of brace statement\n\
    assert(modp(n: 31, p: 5) == 3)\n                              ^\n/tmp/tmpdg_6009v.swift:13:34:\
    \ note: to match this opening '{'\nfunc modp(n: Int, p: Int) -> Int {\n      \
    \                           ^\n/tmp/tmpdg_6009v.swift:15:20: error: missing argument\
    \ labels 'n:p:' in call\n        return modp(-n, p)\n                   ^\n  \
    \                  n:  p: \n/tmp/tmpdg_6009v.swift:18:20: error: missing argument\
    \ labels 'n:p:' in call\n        return modp(n, p - 1)\n                   ^\n\
    \                    n: p: \n/tmp/tmpdg_6009v.swift:30:20: error: missing argument\
    \ labels 'n:p:' in call\n        return modp(n - 1, p)\n                   ^\n\
    \                    n:     p: \n/tmp/tmpdg_6009v.swift:33:20: error: missing\
    \ argument labels 'n:p:' in call\n        return modp(n, p)\n                \
    \   ^\n                    n: p: \n/tmp/tmpdg_6009v.swift:36:20: error: missing\
    \ argument labels 'n:p:' in call\n        return modp(n, p - 1)\n            \
    \       ^\n                    n: p: \n/tmp/tmpdg_6009v.swift:39:20: error: missing\
    \ argument labels 'n:p:' in call\n        return modp(n, p - 2)\n            \
    \       ^\n                    n: p: \n/tmp/tmpdg_6009v.swift:42:20: error: missing\
    \ argument labels 'n:p:' in call\n        return modp(n, p - 3)\n            \
    \       ^\n                    n: p: \n/tmp/tmpdg_6009v.swift:45:20: error: missing\
    \ argument labels 'n:p:' in call\n        return modp(n, p - 4)\n            \
    \       ^\n                    n: p: \n/tmp/tmpdg_6009v.swift:48:20: error: missing\
    \ argument labels 'n:p:' in call\n        return modp(n, p - 5)\n            \
    \       ^\n                    n: p: \n/tmp/tmpdg_6009v.swift:51:20: error: missing\
    \ argument labels 'n:p:' in call\n        return modp(n, p - 6)\n            \
    \       ^\n                    n: p: \n/tmp/tmpdg_6009v.swift:54:20: error: missing\
    \ argument labels 'n:p:' in call\n        return modp(n, p - 7)\n            \
    \       ^\n                    n: p: \n"
  stdout: ''
  timestamp: 1660014749
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n\tlet n2 = n * n\n\tlet p2 = p * p\n\tlet n3 = n2 * n2\n\tlet p3 = p2 * p\n\
    \tlet n4 = n3 * n3\n\tlet p4 = p3 * p3\n\tlet n5 = n4 * n4\n\tlet p5 = p4 * p4\n\
    \tlet n6 = n5 * n5\n\tlet p6 = p5 * p5\n\tlet n7 = n6 * n6\n\tlet p7 = p6 * p6\n\
    \tlet n8 = (n7 * n7) + p7\n\tlet p8 = (p7 * p7) + p8\n\tlet n9 = (n8 * n8) + p8\n\
    \tlet p9 = (p8 * p8) + p9\n\tlet n10 = (n9 * n9) + p9\n\tlet p10 = (p9 * p9) +\
    \ p10\n\tlet n11 = (n10 * n10) + p10\n\tlet p11 = (p10 * p10) + p11\n\tlet n12\
    \ = (n11 * n11) + p11\n\tlet p12 = (p11 * p11) + p12\n\tlet n13 = (n12 * n12)\
    \ + p12\n\tlet p13 = (p12 * p12) + p13\n\tlet n14 = (n13 * n13) + p13\n\tlet p14\
    \ = (p13 * p13) + p14\n\tlet n15 = (n14 * n14) + p14\n\tlet p15 = (p14 * p14)\
    \ + p15\n\tlet n16 = (n15 * n15) + p15\n\tlet p16 = (p15 * p15) + p16\n\tlet n17\
    \ = (n16 * n16) + p16\n\tlet p17 = (p16 * p16) + p17\n\tlet n18 = (n17 * n17)\
    \ + p17\n\tlet p18 = (p17 * p17) + p18\n\tlet n19 = (n18 * n18) + p18\n\tlet p19\
    \ = (p18 * p18) + p19\n\tlet n20 = (n19 * n19) + p19\n\tlet p20 = (p19 * p19)\
    \ + p20\n\tlet n21 = (n20 * n20) + p20\n\tlet p21 = (p20 * p20) + p21\n\tlet n22\
    \ = (n21 * n21) + p21\n\tlet p22 = (p21\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpu_rvzkxn.swift:56:1: error: expected ')' in expression list\n}\n\
    ^\n/tmp/tmpu_rvzkxn.swift:55:12: note: to match this opening '('\n        let\
    \ p22 = (p21\n                  ^\n/tmp/tmpu_rvzkxn.swift:27:23: error: use of\
    \ local variable 'p8' before its declaration\n        let p8 = (p7 * p7) + p8\n\
    \                             ^\n/tmp/tmpu_rvzkxn.swift:27:6: note: 'p8' declared\
    \ here\n        let p8 = (p7 * p7) + p8\n            ^\n/tmp/tmpu_rvzkxn.swift:29:23:\
    \ error: use of local variable 'p9' before its declaration\n        let p9 = (p8\
    \ * p8) + p9\n                             ^\n/tmp/tmpu_rvzkxn.swift:29:6: note:\
    \ 'p9' declared here\n        let p9 = (p8 * p8) + p9\n            ^\n/tmp/tmpu_rvzkxn.swift:31:24:\
    \ error: use of local variable 'p10' before its declaration\n        let p10 =\
    \ (p9 * p9) + p10\n                              ^\n/tmp/tmpu_rvzkxn.swift:31:6:\
    \ note: 'p10' declared here\n        let p10 = (p9 * p9) + p10\n            ^\n\
    /tmp/tmpu_rvzkxn.swift:33:26: error: use of local variable 'p11' before its declaration\n\
    \        let p11 = (p10 * p10) + p11\n                                ^\n/tmp/tmpu_rvzkxn.swift:33:6:\
    \ note: 'p11' declared here\n        let p11 = (p10 * p10) + p11\n           \
    \ ^\n/tmp/tmpu_rvzkxn.swift:35:26: error: use of local variable 'p12' before its\
    \ declaration\n        let p12 = (p11 * p11) + p12\n                         \
    \       ^\n/tmp/tmpu_rvzkxn.swift:35:6: note: 'p12' declared here\n        let\
    \ p12 = (p11 * p11) + p12\n            ^\n/tmp/tmpu_rvzkxn.swift:37:26: error:\
    \ use of local variable 'p13' before its declaration\n        let p13 = (p12 *\
    \ p12) + p13\n                                ^\n/tmp/tmpu_rvzkxn.swift:37:6:\
    \ note: 'p13' declared here\n        let p13 = (p12 * p12) + p13\n           \
    \ ^\n/tmp/tmpu_rvzkxn.swift:39:26: error: use of local variable 'p14' before its\
    \ declaration\n        let p14 = (p13 * p13) + p14\n                         \
    \       ^\n/tmp/tmpu_rvzkxn.swift:39:6: note: 'p14' declared here\n        let\
    \ p14 = (p13 * p13) + p14\n            ^\n/tmp/tmpu_rvzkxn.swift:41:26: error:\
    \ use of local variable 'p1"
  stdout: ''
  timestamp: 1660014749
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n\tif n < 0 {\n\t\tpanic(\"modp: negative number\")\n\t}\n\tif p < 1 {\n\t\
    \tpanic(\"modp: negative modulus\")\n\t}\n\tif n == 0 {\n\t\treturn 0\n\t}\n\t\
    if n == 1 {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn 1\n\t}\n\tif n == p+1\
    \ {\n\t\treturn p\n\t}\n\tif n == p+2 {\n\t\treturn p + 1\n\t}\n\tif n == p+3\
    \ {\n\t\treturn p + 2\n\t}\n\tif n == p+4 {\n\t\treturn p + 3\n\t}\n\tif n ==\
    \ p+5 {\n\t\treturn p + 4\n\t}\n\tif n == p+6 {\n\t\treturn p + 5\n\t}\n\tif n\
    \ == p+7 {\n\t\treturn p + 6\n\t}\n\tif n == p+8 {\n\t\treturn p + 7\n\t}\n\t\
    if n == p+9 {\n\t\treturn p + 8\n\t}\n\tif n == p+10 {\n\t\treturn p + 9\n\t}\n\
    \tif n == p+11 {\n\t\treturn p + 10\n\t}\n\tif n == p+12 {\n\t\treturn p + 11\n\
    \t}\n\tif n == p+13 {\n\t\treturn p + 12\n\t}\n\tif n == p+14 {\n\t\treturn p\
    \ + 13\n\t}\n\tif n == p+15 {\n\t\treturn p + 14\n\t}\n\tif n == p+16 {\n\t\t\
    return p + 15\n\t}\n\tif n == p+17 {\n\t\treturn p + 16\n\t}\n\tif n == p+18 {\n\
    \t\treturn p + 17\n\t}\n\tif n == p+19 {\n\t\treturn p + 18\n\t}\n\tif n == p+20\
    \ {\n\t\treturn p + 19\n\t}\n\tif n == p+21 {\n\t\treturn p + 20\n\t}\n\tif n\
    \ == p+22 {\n\t\treturn p + 21\n\t}\n\tif n == p+23 {\n\t\treturn p + 22\n\t}\n\
    \tif n == p+24 {\n\t\treturn p + 23\n\t}\n\tif n == p+25 {\n\t\treturn p + 24\n\
    \t}\n\tif n == p+26 {\n\t\treturn p + 25\n\t}\n\tif n == p+27 {\n\t\treturn p\
    \ + 26\n\t}\n\tif n == p+28 {\n\t\treturn p + 27\n\t}\n\tif n == p+29 {\n\t\t\
    return p + 28\n\t}\n\tif n == p+30 {\n\t\treturn p + 29\n\t}\n\tif n == p+31 {\n\
    \t\treturn p + 30\n\t}\n\tif n == p+32 {\n\t\treturn p + 31\n\t}\n\tif n == p+33\
    \ {\n\t\treturn p + \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3,\
    \ p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) ==\
    \ 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpu7_f5fd0.swift:127:1: error: expected expression after operator\n\
    }\n^\n/tmp/tmpu7_f5fd0.swift:148:31: error: expected '}' at end of brace statement\n\
    assert(modp(n: 31, p: 5) == 3)\n                              ^\n/tmp/tmpu7_f5fd0.swift:13:34:\
    \ note: to match this opening '{'\nfunc modp(n: Int, p: Int) -> Int {\n      \
    \                           ^\n/tmp/tmpu7_f5fd0.swift:15:3: error: cannot find\
    \ 'panic' in scope\n                panic(\"modp: negative number\")\n       \
    \         ^~~~~\n/tmp/tmpu7_f5fd0.swift:18:3: error: cannot find 'panic' in scope\n\
    \                panic(\"modp: negative modulus\")\n                ^~~~~\n/tmp/tmpu7_f5fd0.swift:130:6:\
    \ error: operator functions can only be declared at global or in type scope\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660014749
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    if n < 0 {\n        return modp(abs(n), p)\n    }\n    if p < 1 {\n \
    \       return modp(n, p - 1)\n    }\n    if p > p {\n        return modp(n, p\
    \ - p)\n    }\n    return n % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n:\
    \ 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101)\
    \ == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp6_cr0hme.swift:15:20: error: missing argument labels 'n:p:' in\
    \ call\n        return modp(abs(n), p)\n                   ^\n               \
    \     n:      p: \n/tmp/tmp6_cr0hme.swift:18:20: error: missing argument labels\
    \ 'n:p:' in call\n        return modp(n, p - 1)\n                   ^\n      \
    \              n: p: \n/tmp/tmp6_cr0hme.swift:21:20: error: missing argument labels\
    \ 'n:p:' in call\n        return modp(n, p - p)\n                   ^\n      \
    \              n: p: \n"
  stdout: ''
  timestamp: 1660014749
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n\tif n < 0 {\n\t\tpanic(\"modp: negative number\")\n\t}\n\tif p < 2 {\n\t\
    \tpanic(\"modp: p < 2\")\n\t}\n\tif n == 0 {\n\t\treturn 0\n\t}\n\tif n == 1 {\n\
    \t\treturn p\n\t}\n\tif p > p {\n\t\tpanic(\"modp: p > p\")\n\t}\n\tvar ret Int\n\
    \tswitch {\n\tcase n <= p:\n\t\tret = n - 1\n\tcase n >= p - 1:\n\t\tret = p\n\
    \tdefault:\n\t\tret = modp(n - p, p)\n\t}\n\treturn ret\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp_5vlev0n.swift:29:10: error: found an unexpected second identifier\
    \ in variable declaration; is there an accidental break?\n        var ret Int\n\
    \                ^\n/tmp/tmp_5vlev0n.swift:29:10: note: join the identifiers together\n\
    \        var ret Int\n            ~~~~^~~\n            retInt\n/tmp/tmp_5vlev0n.swift:30:9:\
    \ error: expected expression in 'switch' statement\n        switch {\n       \
    \        ^\n/tmp/tmp_5vlev0n.swift:15:3: error: cannot find 'panic' in scope\n\
    \                panic(\"modp: negative number\")\n                ^~~~~\n/tmp/tmp_5vlev0n.swift:18:3:\
    \ error: cannot find 'panic' in scope\n                panic(\"modp: p < 2\")\n\
    \                ^~~~~\n/tmp/tmp_5vlev0n.swift:27:3: error: cannot find 'panic'\
    \ in scope\n                panic(\"modp: p > p\")\n                ^~~~~\n/tmp/tmp_5vlev0n.swift:29:6:\
    \ error: type annotation missing in pattern\n        var ret Int\n           \
    \ ^\n/tmp/tmp_5vlev0n.swift:36:13: error: missing argument labels 'n:p:' in call\n\
    \                ret = modp(n - p, p)\n                          ^\n         \
    \                  n:     p: \n"
  stdout: ''
  timestamp: 1660014749
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n\tif n < 0 {\n\t\tpanic(\"modp: negative number\")\n\t}\n\tif p < 1 {\n\t\
    \tpanic(\"modp: negative modulus\")\n\t}\n\tif n == 0 {\n\t\treturn 0\n\t}\n\t\
    if p == 1 {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn 1\n\t}\n\tif p > p {\n\
    \t\tpanic(\"modp: modulus is greater than p\")\n\t}\n\tif n == 1 {\n\t\treturn\
    \ 0\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\
    \tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n ==\
    \ p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\t\
    return n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\
    \t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif\
    \ n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\
    \t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn\
    \ n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\
    \tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n ==\
    \ p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\t\
    return n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\
    \t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif\
    \ n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\
    \t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn\
    \ n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\
    \tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n ==\
    \ p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\t\
    return n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\
    \t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif\
    \ n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\
    \t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\n\
    assert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpff5gomil.swift:197:31: error: expected '}' at end of brace statement\n\
    assert(modp(n: 31, p: 5) == 3)\n                              ^\n/tmp/tmpff5gomil.swift:13:34:\
    \ note: to match this opening '{'\nfunc modp(n: Int, p: Int) -> Int {\n      \
    \                           ^\n/tmp/tmpff5gomil.swift:15:3: error: cannot find\
    \ 'panic' in scope\n                panic(\"modp: negative number\")\n       \
    \         ^~~~~\n/tmp/tmpff5gomil.swift:18:3: error: cannot find 'panic' in scope\n\
    \                panic(\"modp: negative modulus\")\n                ^~~~~\n/tmp/tmpff5gomil.swift:30:3:\
    \ error: cannot find 'panic' in scope\n                panic(\"modp: modulus is\
    \ greater than p\")\n                ^~~~~\n/tmp/tmpff5gomil.swift:179:6: error:\
    \ operator functions can only be declared at global or in type scope\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660014749
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    if n < 0 {\n        return modp(abs(n), p)\n    }\n    if p < 0 {\n \
    \       return modp(n, abs(p))\n    }\n    if n == 0 {\n        return 0\n   \
    \ }\n    if p == 0 {\n        return n\n    }\n    if p > n {\n        return\
    \ modp(n, p)\n    }\n    if p < n {\n        return modp(n - p, p)\n    }\n  \
    \  return n\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmputrmmgpq.swift:15:20: error: missing argument labels 'n:p:' in\
    \ call\n        return modp(abs(n), p)\n                   ^\n               \
    \     n:      p: \n/tmp/tmputrmmgpq.swift:18:20: error: missing argument labels\
    \ 'n:p:' in call\n        return modp(n, abs(p))\n                   ^\n     \
    \               n: p: \n/tmp/tmputrmmgpq.swift:27:20: error: missing argument\
    \ labels 'n:p:' in call\n        return modp(n, p)\n                   ^\n   \
    \                 n: p: \n/tmp/tmputrmmgpq.swift:30:20: error: missing argument\
    \ labels 'n:p:' in call\n        return modp(n - p, p)\n                   ^\n\
    \                    n:     p: \n"
  stdout: ''
  timestamp: 1660014749
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n\tif n < 0 {\n\t\tpanic(\"modp: negative number\")\n\t}\n\tif p < 1 {\n\t\
    \tpanic(\"modp: p < 1\")\n\t}\n\tif n == 0 {\n\t\treturn 0\n\t}\n\tif n == 1 {\n\
    \t\treturn p\n\t}\n\tif p > p {\n\t\tpanic(\"modp: p > p\")\n\t}\n\tif p > p {\n\
    \t\tpanic(\"modp: p > p\")\n\t}\n\tn -= p - 1\n\tif n == 0 {\n\t\treturn 1\n\t\
    }\n\tif n == 1 {\n\t\treturn p\n\t}\n\tn--\n\tx := 1\n\tfor i := 1; i <= n; i++\
    \ {\n\t\tx *= p\n\t\tx += p\n\t}\n\treturn x\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpsnhy6efr.swift:40:3: error: consecutive statements on a line must\
    \ be separated by ';'\n        x := 1\n         ^\n         ;\n/tmp/tmpsnhy6efr.swift:40:4:\
    \ error: expected expression\n        x := 1\n          ^\n/tmp/tmpsnhy6efr.swift:41:9:\
    \ error: expected type\n        for i := 1; i <= n; i++ {\n               ^\n\
    \                <#type#>\n/tmp/tmpsnhy6efr.swift:41:9: error: expected 'in' after\
    \ for-each pattern\n        for i := 1; i <= n; i++ {\n               ^\n/tmp/tmpsnhy6efr.swift:41:9:\
    \ error: expected Sequence expression for for-each loop\n        for i := 1; i\
    \ <= n; i++ {\n               ^\n/tmp/tmpsnhy6efr.swift:15:3: error: cannot find\
    \ 'panic' in scope\n                panic(\"modp: negative number\")\n       \
    \         ^~~~~\n/tmp/tmpsnhy6efr.swift:18:3: error: cannot find 'panic' in scope\n\
    \                panic(\"modp: p < 1\")\n                ^~~~~\n/tmp/tmpsnhy6efr.swift:27:3:\
    \ error: cannot find 'panic' in scope\n                panic(\"modp: p > p\")\n\
    \                ^~~~~\n/tmp/tmpsnhy6efr.swift:30:3: error: cannot find 'panic'\
    \ in scope\n                panic(\"modp: p > p\")\n                ^~~~~\n/tmp/tmpsnhy6efr.swift:32:4:\
    \ error: left side of mutating operator isn't mutable: 'n' is a 'let' constant\n\
    \        n -= p - 1\n        ~ ^\n/tmp/tmpsnhy6efr.swift:39:3: error: cannot find\
    \ operator '--' in scope; did you mean '-= 1'?\n        n--\n         ^~\n/tmp/tmpsnhy6efr.swift:40:2:\
    \ error: cannot find 'x' in scope\n        x := 1\n        ^\n/tmp/tmpsnhy6efr.swift:45:9:\
    \ error: cannot find 'x' in scope\n        return x\n               ^\n"
  stdout: ''
  timestamp: 1660014749
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n\tif n < 0 {\n\t\tn = -n\n\t\tp = -p\n\t}\n\tif p == 0 {\n\t\treturn 0\n\t\
    }\n\tif p == 1 {\n\t\treturn n\n\t}\n\tif n == 0 {\n\t\treturn 0\n\t}\n\tif n\
    \ == 1 {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn 1\n\t}\n\tif n == p+1 {\n\
    \t\treturn p\n\t}\n\tq := n / p\n\tr := n % p\n\treturn modp(q, p) * p + r\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp6z0rc2wz.swift:36:3: error: consecutive statements on a line must\
    \ be separated by ';'\n        q := n / p\n         ^\n         ;\n/tmp/tmp6z0rc2wz.swift:36:4:\
    \ error: expected expression\n        q := n / p\n          ^\n/tmp/tmp6z0rc2wz.swift:15:3:\
    \ error: cannot assign to value: 'n' is a 'let' constant\n                n =\
    \ -n\n                ^\n/tmp/tmp6z0rc2wz.swift:16:3: error: cannot assign to\
    \ value: 'p' is a 'let' constant\n                p = -p\n                ^\n\
    /tmp/tmp6z0rc2wz.swift:36:2: error: cannot find 'q' in scope\n        q := n /\
    \ p\n        ^\n/tmp/tmp6z0rc2wz.swift:38:14: error: cannot find 'q' in scope\n\
    \        return modp(q, p) * p + r\n                    ^\n/tmp/tmp6z0rc2wz.swift:38:26:\
    \ error: cannot find 'r' in scope\n        return modp(q, p) * p + r\n       \
    \                         ^\n/tmp/tmp6z0rc2wz.swift:38:13: error: missing argument\
    \ labels 'n:p:' in call\n        return modp(q, p) * p + r\n                 \
    \  ^\n                    n: p: \n"
  stdout: ''
  timestamp: 1660014749
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n\tswitch {\n\tcase n < 0:\n\t\treturn modp(abs(n), p)\n\tcase p == 0:\n\t\
    \treturn 0\n\tcase p < 0:\n\t\treturn modp(n - p, p)\n\tdefault:\n\t\treturn ((n\
    \ / p) + 1) * p\n\t}\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3,\
    \ p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) ==\
    \ 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpvs5v_61f.swift:14:9: error: expected expression in 'switch' statement\n\
    \        switch {\n               ^\n/tmp/tmpvs5v_61f.swift:16:14: error: missing\
    \ argument labels 'n:p:' in call\n                return modp(abs(n), p)\n   \
    \                        ^\n                            n:      p: \n/tmp/tmpvs5v_61f.swift:20:14:\
    \ error: missing argument labels 'n:p:' in call\n                return modp(n\
    \ - p, p)\n                           ^\n                            n:     p:\
    \ \n"
  stdout: ''
  timestamp: 1660014749
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n\tlet r = n % p\n\tif r == 0 {\n\t\treturn n\n\t}\n\treturn r\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmpno7dwpla/tmpno7dwpla.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aea9b1a3c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aea9ae9ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aea9ae9a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aea9ae997b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpno7dwpla                        0x000056139f6412cd <unavailable> + 4813

    5    libc.so.6                          0x00002aea9b38f460 __libc_start_main +
    245

    6    tmpno7dwpla                        0x000056139f640ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014750
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n\tlet n = Int(n)\n\tlet p = Int(p)\n\tif n < 0 {\n\t\tpanic(\"modp(n,p)\"\
    )\n\t}\n\tif p < 0 {\n\t\tpanic(\"modp(n,p)\")\n\t}\n\tif n == 0 || p == 0 {\n\
    \t\treturn 0\n\t}\n\tif n == 1 {\n\t\treturn p\n\t}\n\tif p == 1 {\n\t\treturn\
    \ n\n\t}\n\tif p == 0 {\n\t\treturn 1\n\t}\n\tif n == p {\n\t\treturn modp(n -\
    \ 1, p)\n\t}\n\tif n == p + 1 {\n\t\treturn modp(n, p - 1)\n\t}\n\tif n == p -\
    \ 1 {\n\t\treturn modp(n, p)\n\t}\n\tif n == p - 2 {\n\t\treturn modp(n + 1, p)\n\
    \t}\n\tif n == p - 3 {\n\t\treturn modp(n + 1, p - 1)\n\t}\n\tif n == p - 4 {\n\
    \t\treturn modp(n + 1, p - 2)\n\t}\n\tif n == p - 5 {\n\t\treturn modp(n + 1,\
    \ p - 3)\n\t}\n\tif n == p - 6 {\n\t\treturn modp(n + 1, p - 4)\n\t}\n\tif n ==\
    \ p - 7 {\n\t\treturn modp(n + 1, p - 5)\n\t}\n\tif n == p - 8 {\n\t\treturn modp(n\
    \ + 1, p - 6)\n\t}\n\tif n == p - 9 {\n\t\treturn modp(n + 1, p - 7)\n\t}\n\t\
    if n == p - 10 {\n\t\treturn modp(n + 1, p - 8)\n\t}\n\tif n == p - 11 {\n\t\t\
    return modp(n + 1, p - 9)\n\t}\n\tif n == p - 12 {\n\t\treturn modp(n + 1, p -\
    \ 10)\n\t}\n\tif n == p - 13 {\n\t\treturn modp(n + 1, p - 11)\n\t}\n\tif n ==\
    \ p - 14 {\n\t\treturn modp(n + 1, p - 12)\n\t}\n\tif n == p - 15 {\n\t\treturn\
    \ modp(n + 1, p - 13)\n\t}\n\tif n == p - 16 {\n\t\treturn modp(n + 1, p - 14)\n\
    \t}\n\tif n == p - 17 {\n\t\treturn modp(n + 1, p - 15)\n\t}\n\tif n == p - 18\
    \ {\n\t\treturn modp(n + 1, p - 16)\n\t}\n\tif n == p - 19 {\n\t\treturn modp(n\
    \ + 1, p - 17)\n\t}\n\tif n == p - 20 {\n\t\treturn modp(n + 1, p - 18)\n\t}\n\
    \tif n == p - 21 {\n\t\treturn modp(n + 1, p - 19)\n\t}\n\tif n == p - 22 {\n\t\
    \treturn modp(n + 1, p - 20)\n\t}\n\tif n == p - 23 {\n\t\treturn modp(n + 1,\
    \ p - 21)\n\t}\n\tif n == p - 24 {\n\t\treturn modp(n + 1, p - 22)\n\t}\n\tif\
    \ n == p - 25 {\n\t\treturn modp(n + 1, p - 23)\n\t}\n\tif \n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp4sv7f13c.swift:115:4: error: expected expression, var, or let in\
    \ 'if' condition\n        if \n          ^\n/tmp/tmp4sv7f13c.swift:17:3: error:\
    \ cannot find 'panic' in scope\n                panic(\"modp(n,p)\")\n       \
    \         ^~~~~\n/tmp/tmp4sv7f13c.swift:20:3: error: cannot find 'panic' in scope\n\
    \                panic(\"modp(n,p)\")\n                ^~~~~\n/tmp/tmp4sv7f13c.swift:35:14:\
    \ error: missing argument labels 'n:p:' in call\n                return modp(n\
    \ - 1, p)\n                           ^\n                            n:     p:\
    \ \n/tmp/tmp4sv7f13c.swift:38:14: error: missing argument labels 'n:p:' in call\n\
    \                return modp(n, p - 1)\n                           ^\n       \
    \                     n: p: \n/tmp/tmp4sv7f13c.swift:41:14: error: missing argument\
    \ labels 'n:p:' in call\n                return modp(n, p)\n                 \
    \          ^\n                            n: p: \n/tmp/tmp4sv7f13c.swift:44:14:\
    \ error: missing argument labels 'n:p:' in call\n                return modp(n\
    \ + 1, p)\n                           ^\n                            n:     p:\
    \ \n/tmp/tmp4sv7f13c.swift:47:14: error: missing argument labels 'n:p:' in call\n\
    \                return modp(n + 1, p - 1)\n                           ^\n   \
    \                         n:     p: \n/tmp/tmp4sv7f13c.swift:50:14: error: missing\
    \ argument labels 'n:p:' in call\n                return modp(n + 1, p - 2)\n\
    \                           ^\n                            n:     p: \n/tmp/tmp4sv7f13c.swift:53:14:\
    \ error: missing argument labels 'n:p:' in call\n                return modp(n\
    \ + 1, p - 3)\n                           ^\n                            n:  \
    \   p: \n/tmp/tmp4sv7f13c.swift:56:14: error: missing argument labels 'n:p:' in\
    \ call\n                return modp(n + 1, p - 4)\n                          \
    \ ^\n                            n:     p: \n/tmp/tmp4sv7f13c.swift:59:14: error:\
    \ missing argument labels 'n:p:' in call\n                return modp(n + 1, p\
    \ - 5)\n                           ^\n                            n:     p: \n\
    /tmp/tmp4sv7f13c.swift:62:14: error: missing a"
  stdout: ''
  timestamp: 1660014750
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n\tif n < 0 {\n\t\tpanic(\"modp: negative number\")\n\t}\n\tif p < 1 {\n\t\
    \tpanic(\"modp: negative modulus\")\n\t}\n\tif n == 0 {\n\t\treturn 0\n\t}\n\t\
    if n == 1 {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn 1\n\t}\n\tq := n / p\n\
    \tr := n % p\n\tif r == 0 {\n\t\treturn q\n\t}\n\treturn q + modp(q, p)\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpuzlhvgl1.swift:29:3: error: consecutive statements on a line must\
    \ be separated by ';'\n        q := n / p\n         ^\n         ;\n/tmp/tmpuzlhvgl1.swift:29:4:\
    \ error: expected expression\n        q := n / p\n          ^\n/tmp/tmpuzlhvgl1.swift:15:3:\
    \ error: cannot find 'panic' in scope\n                panic(\"modp: negative\
    \ number\")\n                ^~~~~\n/tmp/tmpuzlhvgl1.swift:18:3: error: cannot\
    \ find 'panic' in scope\n                panic(\"modp: negative modulus\")\n \
    \               ^~~~~\n/tmp/tmpuzlhvgl1.swift:29:2: error: cannot find 'q' in\
    \ scope\n        q := n / p\n        ^\n/tmp/tmpuzlhvgl1.swift:31:5: error: cannot\
    \ find 'r' in scope\n        if r == 0 {\n           ^\n/tmp/tmpuzlhvgl1.swift:32:10:\
    \ error: cannot find 'q' in scope\n                return q\n                \
    \       ^\n/tmp/tmpuzlhvgl1.swift:34:9: error: cannot find 'q' in scope\n    \
    \    return q + modp(q, p)\n               ^\n/tmp/tmpuzlhvgl1.swift:34:18: error:\
    \ cannot find 'q' in scope\n        return q + modp(q, p)\n                  \
    \      ^\n/tmp/tmpuzlhvgl1.swift:34:17: error: missing argument labels 'n:p:'\
    \ in call\n        return q + modp(q, p)\n                       ^\n         \
    \               n: p: \n"
  stdout: ''
  timestamp: 1660014749
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    if n < 0 {\n        return modp(abs(n), p)\n    }\n    if p < 0 {\n \
    \       return modp(n, abs(p))\n    }\n    if n == 0 {\n        return 0\n   \
    \ }\n    if p == 0 {\n        return n\n    }\n    if p > n {\n        return\
    \ modp(n, p)\n    }\n    if p < n {\n        return modp(n - p, p)\n    }\n  \
    \  return p % n\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp4ut5bz1x.swift:15:20: error: missing argument labels 'n:p:' in\
    \ call\n        return modp(abs(n), p)\n                   ^\n               \
    \     n:      p: \n/tmp/tmp4ut5bz1x.swift:18:20: error: missing argument labels\
    \ 'n:p:' in call\n        return modp(n, abs(p))\n                   ^\n     \
    \               n: p: \n/tmp/tmp4ut5bz1x.swift:27:20: error: missing argument\
    \ labels 'n:p:' in call\n        return modp(n, p)\n                   ^\n   \
    \                 n: p: \n/tmp/tmp4ut5bz1x.swift:30:20: error: missing argument\
    \ labels 'n:p:' in call\n        return modp(n - p, p)\n                   ^\n\
    \                    n:     p: \n"
  stdout: ''
  timestamp: 1660014749
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n\tswitch {\n\tcase n < p:\n\t\treturn 0\n\tcase n == p:\n\t\treturn 1\n\t\
    case n == 0 || n == p:\n\t\treturn n\n\tdefault:\n\t\treturn (p * modp(n - p,\
    \ p)) % p\n\t}\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpfzmjxi14.swift:14:9: error: expected expression in 'switch' statement\n\
    \        switch {\n               ^\n/tmp/tmpfzmjxi14.swift:22:19: error: missing\
    \ argument labels 'n:p:' in call\n                return (p * modp(n - p, p))\
    \ % p\n                                ^\n                                 n:\
    \     p: \n"
  stdout: ''
  timestamp: 1660014749
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    if n < 0 {\n        return modp(abs(n), p)\n    }\n    if p < 0 {\n \
    \       return modp(n, abs(p))\n    }\n    if n == 0 {\n        return 0\n   \
    \ }\n    if p == 0 {\n        return n\n    }\n    if n == p {\n        return\
    \ n\n    }\n    if p < p {\n        return modp(n - p, p)\n    }\n    if p > p\
    \ {\n        return modp(n, p - p)\n    }\n    if n == 1 {\n        return p\n\
    \    }\n    if n == p {\n        return n\n    }\n    if n == p {\n        return\
    \ n\n    }\n    if n == p {\n        return n\n    }\n    if n == p {\n      \
    \  return n\n    }\n    if n == p {\n        return n\n    }\n    if n == p {\n\
    \        return n\n    }\n    if n == p {\n        return n\n    }\n    if n ==\
    \ p {\n        return n\n    }\n    if n == p {\n        return n\n    }\n   \
    \ if n == p {\n        return n\n    }\n    if n == p {\n        return n\n  \
    \  }\n    if n == p {\n        return n\n    }\n    if n == p {\n        return\
    \ n\n    }\n    if n == p {\n        return n\n    }\n    if n == p {\n      \
    \  return n\n    }\n    if n == p {\n        return n\n    }\n    if n == p {\n\
    \        return n\n    }\n    if n == p {\n        return n\n    }\n    if n ==\
    \ p {\n        return n\n    }\n    if n == p {\n        return n\n    }\n   \
    \ if n == p {\n        return n\n    }\n    if n == p {\n        return n\n  \
    \  }\n    if n == p {\n        return n\n    }\n    if n == p {\n        return\
    \ n\n    }\n    if n == p {\n        return n\n    }\n    if n == p {\n      \
    \  return n\n    }\n    if n == p {\n        return n\n    }\n    if n == p {\n\
    \        return n\n    }\n    if n == p {\n        return n\n    }\n    if n ==\
    \ p {\n        return n\n    }\n    if n == p {\n        return n\n    }\n   \
    \ if n == p {\n        return n\n    }\n    if n == p {\n        return n\n  \
    \  }\n    if n == p {\n        return n\n    }\n    if n == p {\n        return\
    \ n\n    }\n    if n == p {\n        return n\n    }\n    if n == p {\n      \
    \  return n\n    }\n    if n == p {\n        return n\n    }\n    if n == p {\n\
    \        return n\n    }\n    if n == p {\n        return n\n    }\n    if n ==\
    \ p {\n        return n\n    }\n    if n == p {\n        return n\n    }\n   \
    \ if n == p {\n        return n\n    }\n    if n == p {\n        return n\n  \
    \  }\n    if n == p {\n        return n\n    }\n    if n == p {\n        return\
    \ n\n    }\n    if n == p {\n        return n\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpa769yu_i.swift:199:31: error: expected '}' at end of brace statement\n\
    assert(modp(n: 31, p: 5) == 3)\n                              ^\n/tmp/tmpa769yu_i.swift:13:34:\
    \ note: to match this opening '{'\nfunc modp(n: Int, p: Int) -> Int {\n      \
    \                           ^\n/tmp/tmpa769yu_i.swift:15:20: error: missing argument\
    \ labels 'n:p:' in call\n        return modp(abs(n), p)\n                   ^\n\
    \                    n:      p: \n/tmp/tmpa769yu_i.swift:18:20: error: missing\
    \ argument labels 'n:p:' in call\n        return modp(n, abs(p))\n           \
    \        ^\n                    n: p: \n/tmp/tmpa769yu_i.swift:30:20: error: missing\
    \ argument labels 'n:p:' in call\n        return modp(n - p, p)\n            \
    \       ^\n                    n:     p: \n/tmp/tmpa769yu_i.swift:33:20: error:\
    \ missing argument labels 'n:p:' in call\n        return modp(n, p - p)\n    \
    \               ^\n                    n: p: \n/tmp/tmpa769yu_i.swift:181:6: error:\
    \ operator functions can only be declared at global or in type scope\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660014750
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n\tif n < 0 {\n\t\tpanic(\"modp(n, p): n must be positive\")\n\t}\n\tif p\
    \ < 1 {\n\t\tpanic(\"modp(n, p): p must be positive\")\n\t}\n\tif n == 0 {\n\t\
    \treturn 1\n\t}\n\tif n == 1 {\n\t\treturn p\n\t}\n\tif p < 2 {\n\t\treturn modp(n\
    \ - 1, p)\n\t}\n\tq := modp(n - 1, p) // q is q * p % n\n\tr := p // r is p\n\t\
    for {\n\t\tif r == 1 {\n\t\t\treturn q\n\t\t}\n\t\tif r < p {\n\t\t\tr = r * q\
    \ % n\n\t\t} else {\n\t\t\tr = r * q + n % n\n\t\t}\n\t\tq = q * q % n\n\t}\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp2qgqzzpn.swift:29:3: error: consecutive statements on a line must\
    \ be separated by ';'\n        q := modp(n - 1, p) // q is q * p % n\n       \
    \  ^\n         ;\n/tmp/tmp2qgqzzpn.swift:29:4: error: expected expression\n  \
    \      q := modp(n - 1, p) // q is q * p % n\n          ^\n/tmp/tmp2qgqzzpn.swift:31:6:\
    \ error: expected pattern\n        for {\n            ^\n/tmp/tmp2qgqzzpn.swift:31:6:\
    \ error: expected Sequence expression for for-each loop\n        for {\n     \
    \       ^\n/tmp/tmp2qgqzzpn.swift:15:3: error: cannot find 'panic' in scope\n\
    \                panic(\"modp(n, p): n must be positive\")\n                ^~~~~\n\
    /tmp/tmp2qgqzzpn.swift:18:3: error: cannot find 'panic' in scope\n           \
    \     panic(\"modp(n, p): p must be positive\")\n                ^~~~~\n/tmp/tmp2qgqzzpn.swift:27:14:\
    \ error: missing argument labels 'n:p:' in call\n                return modp(n\
    \ - 1, p)\n                           ^\n                            n:     p:\
    \ \n/tmp/tmp2qgqzzpn.swift:29:2: error: cannot find 'q' in scope\n        q :=\
    \ modp(n - 1, p) // q is q * p % n\n        ^\n"
  stdout: ''
  timestamp: 1660014749
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    if n < 0 {\n        return modp(abs(n), p)\n    }\n    if p < 0 {\n \
    \       return modp(-n, p)\n    }\n    if n == 0 || p == 0 {\n        return 0\n\
    \    }\n    if n == p {\n        return n\n    }\n    if n == p {\n        return\
    \ p\n    }\n    if n == 0 {\n        return p\n    }\n    if n == p {\n      \
    \  return n\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n\
    \        return n\n    }\n    if n == p {\n        return p\n    }\n    if n ==\
    \ p {\n        return n\n    }\n    if n == p {\n        return p\n    }\n   \
    \ if n == p {\n        return n\n    }\n    if n == p {\n        return p\n  \
    \  }\n    if n == p {\n        return n\n    }\n    if n == p {\n        return\
    \ p\n    }\n    if n == p {\n        return n\n    }\n    if n == p {\n      \
    \  return p\n    }\n    if n == p {\n        return n\n    }\n    if n == p {\n\
    \        return p\n    }\n    if n == p {\n        return n\n    }\n    if n ==\
    \ p {\n        return p\n    }\n    if n == p {\n        return n\n    }\n   \
    \ if n == p {\n        return p\n    }\n    if n == p {\n        return n\n  \
    \  }\n    if n == p {\n        return p\n    }\n    if n == p {\n        return\
    \ n\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n      \
    \  return n\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n\
    \        return n\n    }\n    if n == p {\n        return p\n    }\n    if n ==\
    \ p {\n        return n\n    }\n    if n == p {\n        return p\n    }\n   \
    \ if n == p {\n        return n\n    }\n    if n == p {\n        return p\n  \
    \  }\n    if n == p {\n        return n\n    }\n    if n == p {\n        return\
    \ p\n    }\n    if n == p {\n        return n\n    }\n    if n == p {\n      \
    \  return p\n    }\n    if n == p {\n        return n\n    }\n    if n == p {\n\
    \        return p\n    }\n    if n == p {\n        return n\n    }\n    if n ==\
    \ p {\n        return p\n    }\n    if n == p {\n        return n\n    }\n   \
    \ if n == p {\n        return p\n    }\n    if n == p {\n        return n\n  \
    \  }\n    if n == p {\n        return p\n    }\n    if n == p {\n        return\
    \ n\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n      \
    \  return n\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n\
    \        return n\n    }\n    if n == p {\n        return p\n    }\n    if n ==\
    \ p {\n        return n\n    }\n    if n == p {\n\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\n\
    assert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp16aqk9eu.swift:202:31: error: expected '}' at end of brace statement\n\
    assert(modp(n: 31, p: 5) == 3)\n                              ^\n/tmp/tmp16aqk9eu.swift:13:34:\
    \ note: to match this opening '{'\nfunc modp(n: Int, p: Int) -> Int {\n      \
    \                           ^\n/tmp/tmp16aqk9eu.swift:15:20: error: missing argument\
    \ labels 'n:p:' in call\n        return modp(abs(n), p)\n                   ^\n\
    \                    n:      p: \n/tmp/tmp16aqk9eu.swift:18:20: error: missing\
    \ argument labels 'n:p:' in call\n        return modp(-n, p)\n               \
    \    ^\n                    n:  p: \n/tmp/tmp16aqk9eu.swift:184:6: error: operator\
    \ functions can only be declared at global or in type scope\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660014750
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n\tif n < 0 {\n\t\tpanic(\"modp: negative number\")\n\t}\n\tif p < 1 {\n\t\
    \tpanic(\"modp: p < 1\")\n\t}\n\tif n == 0 {\n\t\treturn 0\n\t}\n\tif n == 1 {\n\
    \t\treturn p\n\t}\n\tif p < 2 {\n\t\treturn n - modp(n - 1, p) % p\n\t}\n\treturn\
    \ modp(n - 1, p) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3,\
    \ p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) ==\
    \ 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpci6rneyk.swift:15:3: error: cannot find 'panic' in scope\n    \
    \            panic(\"modp: negative number\")\n                ^~~~~\n/tmp/tmpci6rneyk.swift:18:3:\
    \ error: cannot find 'panic' in scope\n                panic(\"modp: p < 1\")\n\
    \                ^~~~~\n/tmp/tmpci6rneyk.swift:27:18: error: missing argument\
    \ labels 'n:p:' in call\n                return n - modp(n - 1, p) % p\n     \
    \                          ^\n                                n:     p: \n/tmp/tmpci6rneyk.swift:29:13:\
    \ error: missing argument labels 'n:p:' in call\n        return modp(n - 1, p)\
    \ % p\n                   ^\n                    n:     p: \n"
  stdout: ''
  timestamp: 1660014750
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n\tif n < 0 {\n\t\tpanic(\"modp: negative number\")\n\t}\n\tif p < 0 {\n\t\
    \tpanic(\"modp: negative modulus\")\n\t}\n\tif n == 0 {\n\t\treturn 0\n\t}\n\t\
    if n == 1 {\n\t\treturn p\n\t}\n\tif p > p {\n\t\tpanic(\"modp: modulus is too\
    \ large\")\n\t}\n\tif p > p {\n\t\tpanic(\"modp: modulus is too large\")\n\t}\n\
    \tn -= p - 1\n\tx := p\n\tfor n > 0 {\n\t\tx = x * p + n\n\t\tn--\n\t}\n\treturn\
    \ x\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n:\
    \ 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11)\
    \ == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmprib71nct.swift:33:3: error: consecutive statements on a line must\
    \ be separated by ';'\n        x := p\n         ^\n         ;\n/tmp/tmprib71nct.swift:33:4:\
    \ error: expected expression\n        x := p\n          ^\n/tmp/tmprib71nct.swift:34:8:\
    \ error: expected 'in' after for-each pattern\n        for n > 0 {\n         \
    \     ^\n/tmp/tmprib71nct.swift:34:8: error: unary operator cannot be separated\
    \ from its operand\n        for n > 0 {\n              ^~\n               \n/tmp/tmprib71nct.swift:15:3:\
    \ error: cannot find 'panic' in scope\n                panic(\"modp: negative\
    \ number\")\n                ^~~~~\n/tmp/tmprib71nct.swift:18:3: error: cannot\
    \ find 'panic' in scope\n                panic(\"modp: negative modulus\")\n \
    \               ^~~~~\n/tmp/tmprib71nct.swift:27:3: error: cannot find 'panic'\
    \ in scope\n                panic(\"modp: modulus is too large\")\n          \
    \      ^~~~~\n/tmp/tmprib71nct.swift:30:3: error: cannot find 'panic' in scope\n\
    \                panic(\"modp: modulus is too large\")\n                ^~~~~\n\
    /tmp/tmprib71nct.swift:32:4: error: left side of mutating operator isn't mutable:\
    \ 'n' is a 'let' constant\n        n -= p - 1\n        ~ ^\n/tmp/tmprib71nct.swift:33:2:\
    \ error: cannot find 'x' in scope\n        x := p\n        ^\n/tmp/tmprib71nct.swift:34:8:\
    \ error: '>' is not a prefix unary operator\n        for n > 0 {\n           \
    \   ^\n/tmp/tmprib71nct.swift:38:9: error: cannot find 'x' in scope\n        return\
    \ x\n               ^\n"
  stdout: ''
  timestamp: 1660014750
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    if n < 0 {\n        return modp(abs(n), p)\n    }\n    if p < 0 {\n \
    \       return modp(n - abs(p), p)\n    }\n    if p > n {\n        return modp(n,\
    \ p)\n    }\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n     \
    \   return p\n    }\n    if n == p {\n        return n\n    }\n    if p % 2 ==\
    \ 0 {\n        return modp(n / 2, p)\n    }\n    return modp(n / 2, p) + modp((n\
    \ - 1) / 2, p)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp1s4ucm3c.swift:15:20: error: missing argument labels 'n:p:' in\
    \ call\n        return modp(abs(n), p)\n                   ^\n               \
    \     n:      p: \n/tmp/tmp1s4ucm3c.swift:18:20: error: missing argument labels\
    \ 'n:p:' in call\n        return modp(n - abs(p), p)\n                   ^\n \
    \                   n:          p: \n/tmp/tmp1s4ucm3c.swift:21:20: error: missing\
    \ argument labels 'n:p:' in call\n        return modp(n, p)\n                \
    \   ^\n                    n: p: \n/tmp/tmp1s4ucm3c.swift:33:20: error: missing\
    \ argument labels 'n:p:' in call\n        return modp(n / 2, p)\n            \
    \       ^\n                    n:     p: \n/tmp/tmp1s4ucm3c.swift:35:16: error:\
    \ missing argument labels 'n:p:' in call\n    return modp(n / 2, p) + modp((n\
    \ - 1) / 2, p)\n               ^\n                n:     p: \n/tmp/tmp1s4ucm3c.swift:35:33:\
    \ error: missing argument labels 'n:p:' in call\n    return modp(n / 2, p) + modp((n\
    \ - 1) / 2, p)\n                                ^\n                          \
    \       n:           p: \n"
  stdout: ''
  timestamp: 1660014750
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n\tif n < 0 {\n\t\tpanic(\"modp: negative number\")\n\t}\n\tif p < 1 {\n\t\
    \tpanic(\"modp: negative modulus\")\n\t}\n\tif n == 0 {\n\t\treturn 0\n\t}\n\t\
    if p == 1 {\n\t\treturn n\n\t}\n\tr := n % p\n\tif r == 0 {\n\t\treturn n\n\t\
    }\n\treturn p - r\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpu2180dh2.swift:26:3: error: consecutive statements on a line must\
    \ be separated by ';'\n        r := n % p\n         ^\n         ;\n/tmp/tmpu2180dh2.swift:26:4:\
    \ error: expected expression\n        r := n % p\n          ^\n/tmp/tmpu2180dh2.swift:15:3:\
    \ error: cannot find 'panic' in scope\n                panic(\"modp: negative\
    \ number\")\n                ^~~~~\n/tmp/tmpu2180dh2.swift:18:3: error: cannot\
    \ find 'panic' in scope\n                panic(\"modp: negative modulus\")\n \
    \               ^~~~~\n/tmp/tmpu2180dh2.swift:26:2: error: cannot find 'r' in\
    \ scope\n        r := n % p\n        ^\n/tmp/tmpu2180dh2.swift:27:5: error: cannot\
    \ find 'r' in scope\n        if r == 0 {\n           ^\n/tmp/tmpu2180dh2.swift:30:13:\
    \ error: cannot find 'r' in scope\n        return p - r\n                   ^\n"
  stdout: ''
  timestamp: 1660014750
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    if n < 0 {\n        return modp(abs(n), p)\n    }\n    if p < 0 {\n \
    \       return modp(-n, p)\n    }\n    if n == 0 {\n        return 0\n    }\n\
    \    if p == 0 {\n        return n\n    }\n    if p == 1 {\n        return n\n\
    \    }\n    if n == 1 {\n        return p\n    }\n    if n == 2 {\n        return\
    \ p + 1\n    }\n    if n == 3 {\n        return p + 2\n    }\n    if n == 4 {\n\
    \        return p + 3\n    }\n    if n == 5 {\n        return p + 4\n    }\n \
    \   if n == 6 {\n        return p + 5\n    }\n    if n == 7 {\n        return\
    \ p + 6\n    }\n    if n == 8 {\n        return p + 7\n    }\n    if n == 9 {\n\
    \        return p + 8\n    }\n    if n == 10 {\n        return p + 9\n    }\n\
    \    if n == 11 {\n        return p + 10\n    }\n    if n == 12 {\n        return\
    \ p + 11\n    }\n    if n == 13 {\n        return p + 12\n    }\n    if n == 14\
    \ {\n        return p + 13\n    }\n    if n == 15 {\n        return p + 14\n \
    \   }\n    if n == 16 {\n        return p + 15\n    }\n    if n == 17 {\n    \
    \    return p + 16\n    }\n    if n == 18 {\n        return p + 17\n    }\n  \
    \  if n == 19 {\n        return p + 18\n    }\n    if n == 20 {\n        return\
    \ p + 19\n    }\n    if n == 21 {\n        return p + 20\n    }\n    if n == 22\
    \ {\n        return p + 21\n    }\n    if n == 23 {\n        return p + 22\n \
    \   }\n    if n == 24 {\n        return p + 23\n    }\n    if n == 25 {\n    \
    \    return p + 24\n    }\n    if n == 26 {\n        return p + 25\n    }\n  \
    \  if n == 27 {\n        return p + 26\n    }\n    if n == 28 {\n        return\
    \ p + 27\n    }\n    if n == 29 {\n        return p + 28\n    }\n    if n == 30\
    \ {\n        return p + 29\n    }\n    if n == 31 {\n        return p + 30\n \
    \   }\n    if n == 32 {\n        return p + 31\n    }\n    if n == 33 {\n    \
    \    return p + 32\n    }\n    if n == 34 {\n        return p + 33\n    }\n  \
    \  if n == 35 {\n        return p + 34\n    }\n    if n == 36 {\n        return\
    \ p + 35\n    }\n    if n == 37 {\n        return p + 36\n    }\n    if n == 38\
    \ {\n        return p + 37\n    }\n    if n == 39 {\n        return p\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp4i9wwmpd.swift:166:31: error: expected '}' at end of brace statement\n\
    assert(modp(n: 31, p: 5) == 3)\n                              ^\n/tmp/tmp4i9wwmpd.swift:13:34:\
    \ note: to match this opening '{'\nfunc modp(n: Int, p: Int) -> Int {\n      \
    \                           ^\n/tmp/tmp4i9wwmpd.swift:15:20: error: missing argument\
    \ labels 'n:p:' in call\n        return modp(abs(n), p)\n                   ^\n\
    \                    n:      p: \n/tmp/tmp4i9wwmpd.swift:18:20: error: missing\
    \ argument labels 'n:p:' in call\n        return modp(-n, p)\n               \
    \    ^\n                    n:  p: \n/tmp/tmp4i9wwmpd.swift:148:6: error: operator\
    \ functions can only be declared at global or in type scope\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660014750
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    if n < 0 {\n        n += p\n    }\n    if n < p {\n        return n\n\
    \    }\n    if n == p {\n        return 0\n    }\n    return p - 1\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmph6v1d2ci.swift:15:11: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n        n += p\n        ~ ^\n"
  stdout: ''
  timestamp: 1660014750
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    if n < 0 {\n        n += p\n    }\n    if n < p {\n        return n\n\
    \    }\n    return n - p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3,\
    \ p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) ==\
    \ 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpoc4fun9h.swift:15:11: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n        n += p\n        ~ ^\n"
  stdout: ''
  timestamp: 1660014750
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    if n < 0 {\n        return modp(abs(n), p)\n    }\n    if p < 0 {\n \
    \       return modp(n - abs(p), p)\n    }\n    if n == 0 {\n        return 0\n\
    \    }\n    if p == 0 {\n        return n\n    }\n    if p > n {\n        return\
    \ modp(n - abs(p), p)\n    }\n    if p < n {\n        return modp(n - abs(p),\
    \ p)\n    }\n    return modp(n - abs(p), p)\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpzsoqr14r.swift:15:20: error: missing argument labels 'n:p:' in\
    \ call\n        return modp(abs(n), p)\n                   ^\n               \
    \     n:      p: \n/tmp/tmpzsoqr14r.swift:18:20: error: missing argument labels\
    \ 'n:p:' in call\n        return modp(n - abs(p), p)\n                   ^\n \
    \                   n:          p: \n/tmp/tmpzsoqr14r.swift:27:20: error: missing\
    \ argument labels 'n:p:' in call\n        return modp(n - abs(p), p)\n       \
    \            ^\n                    n:          p: \n/tmp/tmpzsoqr14r.swift:30:20:\
    \ error: missing argument labels 'n:p:' in call\n        return modp(n - abs(p),\
    \ p)\n                   ^\n                    n:          p: \n/tmp/tmpzsoqr14r.swift:32:16:\
    \ error: missing argument labels 'n:p:' in call\n    return modp(n - abs(p), p)\n\
    \               ^\n                n:          p: \n"
  stdout: ''
  timestamp: 1660014750
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    if n < 0 {\n        return modp(abs(n), p)\n    }\n    if p < 0 {\n \
    \       return modp(abs(n), -p) * p\n    }\n    if n == 0 {\n        return 0\n\
    \    }\n    if p == 0 {\n        return n\n    }\n    if p == 1 {\n        return\
    \ n\n    }\n    if n == 1 {\n        return p\n    }\n    if n == p {\n      \
    \  return modp(n - 1, p)\n    }\n    if n == p - 1 {\n        return modp(n, p)\n\
    \    }\n    if n == p - 2 {\n        return modp(n - 1, p)\n    }\n    if n ==\
    \ p - 3 {\n        return modp(n - 2, p)\n    }\n    if n == p - 4 {\n       \
    \ return modp(n - 3, p)\n    }\n    if n == p - 5 {\n        return modp(n - 4,\
    \ p)\n    }\n    if n == p - 6 {\n        return modp(n - 5, p)\n    }\n    if\
    \ n == p - 7 {\n        return modp(n - 6, p)\n    }\n    if n == p - 8 {\n  \
    \      return modp(n - 7, p)\n    }\n    if n == p - 9 {\n        return modp(n\
    \ - 8, p)\n    }\n    if n == p - 10 {\n        return modp(n - 9, p)\n    }\n\
    \    if n == p - 11 {\n        return modp(n - 10, p)\n    }\n    if n == p -\
    \ 12 {\n        return modp(n - 11, p)\n    }\n    if n == p - 13 {\n        return\
    \ modp(n - 12, p)\n    }\n    if n == p - 14 {\n        return modp(n - 13, p)\n\
    \    }\n    if n == p - 15 {\n        return modp(n - 14, p)\n    }\n    if n\
    \ == p - 16 {\n        return modp(n - 15, p)\n    }\n    if n == p - 17 {\n \
    \       return modp(n - 16, p)\n    }\n    if n == p - 18 {\n        return modp(n\
    \ - 17, p)\n    }\n    if n == p - 19 {\n        return modp(n - 18, p)\n    }\n\
    \    if n == p - 20 {\n        return modp(n - 19, p)\n    }\n    if n == p -\
    \ 21 {\n        return modp(n - 20, p)\n    }\n    if n == p - 22 {\n        return\
    \ modp(n - 21, p)\n    }\n    if n == p - 23 {\n        return modp(n - 22, p)\n\
    \    }\n    if n == p - 24 {\n        return modp(n - 23, p)\n    }\n    if n\
    \ == p - 25 {\n        return modp(n - 24, p)\n    }\n    if n == p - 26 {\n \
    \       return modp(n - 25, p)\n    }\n    if n == p - 27 {\n        return modp(n\
    \ - 26, p)\n    }\n    if n == p - 28 {\n        return modp(n - 27, p)\n    }\n\
    \    if n == p - 29 {\n        return modp(n - 28, p)\n    }\n    if \n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp9n40c8j3.swift:122:7: error: expected expression, var, or let in\
    \ 'if' condition\n    if \n      ^\n/tmp/tmp9n40c8j3.swift:15:20: error: missing\
    \ argument labels 'n:p:' in call\n        return modp(abs(n), p)\n           \
    \        ^\n                    n:      p: \n/tmp/tmp9n40c8j3.swift:18:20: error:\
    \ missing argument labels 'n:p:' in call\n        return modp(abs(n), -p) * p\n\
    \                   ^\n                    n:      p: \n/tmp/tmp9n40c8j3.swift:33:20:\
    \ error: missing argument labels 'n:p:' in call\n        return modp(n - 1, p)\n\
    \                   ^\n                    n:     p: \n/tmp/tmp9n40c8j3.swift:36:20:\
    \ error: missing argument labels 'n:p:' in call\n        return modp(n, p)\n \
    \                  ^\n                    n: p: \n/tmp/tmp9n40c8j3.swift:39:20:\
    \ error: missing argument labels 'n:p:' in call\n        return modp(n - 1, p)\n\
    \                   ^\n                    n:     p: \n/tmp/tmp9n40c8j3.swift:42:20:\
    \ error: missing argument labels 'n:p:' in call\n        return modp(n - 2, p)\n\
    \                   ^\n                    n:     p: \n/tmp/tmp9n40c8j3.swift:45:20:\
    \ error: missing argument labels 'n:p:' in call\n        return modp(n - 3, p)\n\
    \                   ^\n                    n:     p: \n/tmp/tmp9n40c8j3.swift:48:20:\
    \ error: missing argument labels 'n:p:' in call\n        return modp(n - 4, p)\n\
    \                   ^\n                    n:     p: \n/tmp/tmp9n40c8j3.swift:51:20:\
    \ error: missing argument labels 'n:p:' in call\n        return modp(n - 5, p)\n\
    \                   ^\n                    n:     p: \n/tmp/tmp9n40c8j3.swift:54:20:\
    \ error: missing argument labels 'n:p:' in call\n        return modp(n - 6, p)\n\
    \                   ^\n                    n:     p: \n/tmp/tmp9n40c8j3.swift:57:20:\
    \ error: missing argument labels 'n:p:' in call\n        return modp(n - 7, p)\n\
    \                   ^\n                    n:     p: \n/tmp/tmp9n40c8j3.swift:60:20:\
    \ error: missing argument labels 'n:p:' in call\n        return modp(n - 8, p)\n\
    \                   ^\n                    n:     p: \n/tmp/tmp9n40c8j3.swift:63:20:\
    \ error: missing ar"
  stdout: ''
  timestamp: 1660014750
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    if n < 0 {\n        return modp(abs(n), p)\n    }\n    if p < 0 {\n \
    \       return modp(n, abs(p))\n    }\n    if n == 0 {\n        return 0\n   \
    \ }\n    if p == 0 {\n        return n\n    }\n    if p > n {\n        return\
    \ modp(n, p)\n    }\n    if p < n {\n        return modp(n, p)\n    }\n    if\
    \ n == 1 {\n        return p\n    }\n    if n == 2 {\n        return p + 1\n \
    \   }\n    if n == 3 {\n        return p + 2\n    }\n    if n == 4 {\n       \
    \ return p + 3\n    }\n    if n == 5 {\n        return p + 4\n    }\n    if n\
    \ == 6 {\n        return p + 5\n    }\n    if n == 7 {\n        return p + 6\n\
    \    }\n    if n == 8 {\n        return p + 7\n    }\n    if n == 9 {\n      \
    \  return p + 8\n    }\n    if n == 10 {\n        return p + 9\n    }\n    if\
    \ n == 11 {\n        return p + 10\n    }\n    if n == 12 {\n        return p\
    \ + 11\n    }\n    if n == 13 {\n        return p + 12\n    }\n    if n == 14\
    \ {\n        return p + 13\n    }\n    if n == 15 {\n        return p + 14\n \
    \   }\n    if n == 16 {\n        return p + 15\n    }\n    if n == 17 {\n    \
    \    return p + 16\n    }\n    if n == 18 {\n        return p + 17\n    }\n  \
    \  if n == 19 {\n        return p + 18\n    }\n    if n == 20 {\n        return\
    \ p + 19\n    }\n    if n == 21 {\n        return p + 20\n    }\n    if n == 22\
    \ {\n        return p + 21\n    }\n    if n == 23 {\n        return p + 22\n \
    \   }\n    if n == 24 {\n        return p + 23\n    }\n    if n == 25 {\n    \
    \    return p + 24\n    }\n    if n == 26 {\n        return p + 25\n    }\n  \
    \  if n == 27 {\n        return p + 26\n    }\n    if n == 28 {\n        return\
    \ p + 27\n    }\n    if n == 29 {\n        return p + 28\n    }\n    if n == 30\
    \ {\n        return p + 29\n    }\n    if n == 31 {\n        return p + 30\n \
    \   }\n    if n == 32 {\n        return p + 31\n    }\n    if n == 33 {\n    \
    \    return p + 32\n    }\n    if n == 34 {\n        return p + 33\n    }\n  \
    \  if n == 35 {\n        return p + 34\n    }\n    if n == 36 {\n        return\
    \ p + 35\n    }\n    if n == 37 {\n        return p + 36\n    }\n    if \n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpu27wg2ni.swift:143:7: error: expected expression, var, or let in\
    \ 'if' condition\n    if \n      ^\n/tmp/tmpu27wg2ni.swift:15:20: error: missing\
    \ argument labels 'n:p:' in call\n        return modp(abs(n), p)\n           \
    \        ^\n                    n:      p: \n/tmp/tmpu27wg2ni.swift:18:20: error:\
    \ missing argument labels 'n:p:' in call\n        return modp(n, abs(p))\n   \
    \                ^\n                    n: p: \n/tmp/tmpu27wg2ni.swift:27:20:\
    \ error: missing argument labels 'n:p:' in call\n        return modp(n, p)\n \
    \                  ^\n                    n: p: \n/tmp/tmpu27wg2ni.swift:30:20:\
    \ error: missing argument labels 'n:p:' in call\n        return modp(n, p)\n \
    \                  ^\n                    n: p: \n"
  stdout: ''
  timestamp: 1660014750
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n\tlet n = Int(n)\n\tlet p = Int(p)\n\tif n < 0 {\n\t\tpanic(\"modp requires\
    \ positive arguments\")\n\t}\n\tif p < 1 {\n\t\tpanic(\"modp requires positive\
    \ arguments\")\n\t}\n\tif n == 0 {\n\t\treturn 1\n\t}\n\tif p == 1 {\n\t\treturn\
    \ n\n\t}\n\tif p > n {\n\t\tpanic(\"modp requires p <= n\")\n\t}\n\tlet mut n2\
    \ = n * n\n\tn2 %= p\n\tif n2 > p {\n\t\tn2 -= p\n\t}\n\treturn n2\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp3b4cnb_m.swift:31:10: error: found an unexpected second identifier\
    \ in constant declaration; is there an accidental break?\n        let mut n2 =\
    \ n * n\n                ^\n/tmp/tmp3b4cnb_m.swift:31:10: note: join the identifiers\
    \ together\n        let mut n2 = n * n\n            ~~~~^~\n            mutn2\n\
    /tmp/tmp3b4cnb_m.swift:31:10: note: join the identifiers together with camel-case\n\
    \        let mut n2 = n * n\n            ~~~~^~\n            mutN2\n/tmp/tmp3b4cnb_m.swift:17:3:\
    \ error: cannot find 'panic' in scope\n                panic(\"modp requires positive\
    \ arguments\")\n                ^~~~~\n/tmp/tmp3b4cnb_m.swift:20:3: error: cannot\
    \ find 'panic' in scope\n                panic(\"modp requires positive arguments\"\
    )\n                ^~~~~\n/tmp/tmp3b4cnb_m.swift:29:3: error: cannot find 'panic'\
    \ in scope\n                panic(\"modp requires p <= n\")\n                ^~~~~\n\
    /tmp/tmp3b4cnb_m.swift:32:2: error: cannot find 'n2' in scope\n        n2 %= p\n\
    \        ^~\n/tmp/tmp3b4cnb_m.swift:33:5: error: cannot find 'n2' in scope\n \
    \       if n2 > p {\n           ^~\n/tmp/tmp3b4cnb_m.swift:34:3: error: cannot\
    \ find 'n2' in scope\n                n2 -= p\n                ^~\n/tmp/tmp3b4cnb_m.swift:36:9:\
    \ error: cannot find 'n2' in scope\n        return n2\n               ^~\n"
  stdout: ''
  timestamp: 1660014750
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    if n < 0 {\n        return modp(abs(n), p)\n    }\n    if p < 0 {\n \
    \       return modp(n, abs(p))\n    }\n    if n == 0 {\n        return 0\n   \
    \ }\n    if p == 0 {\n        return n\n    }\n    if n == p {\n        return\
    \ n\n    }\n    if n == p {\n        return n\n    }\n    if n == 0 {\n      \
    \  return 0\n    }\n    if n == 1 {\n        return n\n    }\n    if n == 2 {\n\
    \        return n\n    }\n    if n == 3 {\n        return n\n    }\n    if n ==\
    \ 4 {\n        return n\n    }\n    if n == 5 {\n        return n\n    }\n   \
    \ if n == 6 {\n        return n\n    }\n    if n == 7 {\n        return n\n  \
    \  }\n    if n == 8 {\n        return n\n    }\n    if n == 9 {\n        return\
    \ n\n    }\n    if n == 10 {\n        return n\n    }\n    if n == 11 {\n    \
    \    return n\n    }\n    if n == 12 {\n        return n\n    }\n    if n == 13\
    \ {\n        return n\n    }\n    if n == 14 {\n        return n\n    }\n    if\
    \ n == 15 {\n        return n\n    }\n    if n == 16 {\n        return n\n   \
    \ }\n    if n == 17 {\n        return n\n    }\n    if n == 18 {\n        return\
    \ n\n    }\n    if n == 19 {\n        return n\n    }\n    if n == 20 {\n    \
    \    return n\n    }\n    if n == 21 {\n        return n\n    }\n    if n == 22\
    \ {\n        return n\n    }\n    if n == 23 {\n        return n\n    }\n    if\
    \ n == 24 {\n        return n\n    }\n    if n == 25 {\n        return n\n   \
    \ }\n    if n == 26 {\n        return n\n    }\n    if n == 27 {\n        return\
    \ n\n    }\n    if n == 28 {\n        return n\n    }\n    if n == 29 {\n    \
    \    return n\n    }\n    if n == 30 {\n        return n\n    }\n    if n == 31\
    \ {\n        return n\n    }\n    if n == 32 {\n        return n\n    }\n    if\
    \ n == 33 {\n        return n\n    }\n    if n == 34 {\n        return n\n   \
    \ }\n    if n == 35 {\n        return n\n    }\n    if n == 36 {\n        return\
    \ n\n    }\n    if n == 37 {\n        return n\n    }\n    if n == 38 {\n    \
    \    return n\n    }\n    if n == 39 {\n        return n\n    }\n    if n == 40\
    \ {\n        return n\n    }\n    if n == 41 {\n        return n\n    }\n    if\
    \ n == 42 {\n        return n\n    }\n    if n == 43 {\n        return n\n   \
    \ }\n    if n == 44 {\n        return n\n    }\n    if n == 45 {\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpz0yr1acf.swift:189:31: error: expected '}' at end of brace statement\n\
    assert(modp(n: 31, p: 5) == 3)\n                              ^\n/tmp/tmpz0yr1acf.swift:13:34:\
    \ note: to match this opening '{'\nfunc modp(n: Int, p: Int) -> Int {\n      \
    \                           ^\n/tmp/tmpz0yr1acf.swift:15:20: error: missing argument\
    \ labels 'n:p:' in call\n        return modp(abs(n), p)\n                   ^\n\
    \                    n:      p: \n/tmp/tmpz0yr1acf.swift:18:20: error: missing\
    \ argument labels 'n:p:' in call\n        return modp(n, abs(p))\n           \
    \        ^\n                    n: p: \n/tmp/tmpz0yr1acf.swift:171:6: error: operator\
    \ functions can only be declared at global or in type scope\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660014750
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n\tif n < 0 {\n\t\tpanic(\"modp: negative number\")\n\t}\n\tif p < 1 {\n\t\
    \tpanic(\"modp: p < 1\")\n\t}\n\tif n == 0 {\n\t\treturn 1\n\t}\n\tif n == 1 {\n\
    \t\treturn p\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tq := p / n\n\tr := p %\
    \ n\n\treturn modp(q, p) * n + r\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n:\
    \ 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101)\
    \ == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp17l9efxu.swift:29:3: error: consecutive statements on a line must\
    \ be separated by ';'\n        q := p / n\n         ^\n         ;\n/tmp/tmp17l9efxu.swift:29:4:\
    \ error: expected expression\n        q := p / n\n          ^\n/tmp/tmp17l9efxu.swift:15:3:\
    \ error: cannot find 'panic' in scope\n                panic(\"modp: negative\
    \ number\")\n                ^~~~~\n/tmp/tmp17l9efxu.swift:18:3: error: cannot\
    \ find 'panic' in scope\n                panic(\"modp: p < 1\")\n            \
    \    ^~~~~\n/tmp/tmp17l9efxu.swift:29:2: error: cannot find 'q' in scope\n   \
    \     q := p / n\n        ^\n/tmp/tmp17l9efxu.swift:31:14: error: cannot find\
    \ 'q' in scope\n        return modp(q, p) * n + r\n                    ^\n/tmp/tmp17l9efxu.swift:31:26:\
    \ error: cannot find 'r' in scope\n        return modp(q, p) * n + r\n       \
    \                         ^\n/tmp/tmp17l9efxu.swift:31:13: error: missing argument\
    \ labels 'n:p:' in call\n        return modp(q, p) * n + r\n                 \
    \  ^\n                    n: p: \n"
  stdout: ''
  timestamp: 1660014750
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n\tswitch {\n\tcase n < 0:\n\t\treturn modp(abs(n), p)\n\tcase p < 0:\n\t\t\
    return modp(-n, p)\n\tcase p == 0:\n\t\treturn 0\n\tcase p > n:\n\t\treturn modp(n,\
    \ p)\n\t}\n\t\n\tswitch {\n\tcase n >= p:\n\t\treturn n\n\tcase n <= -p:\n\t\t\
    return -p\n\t}\n\t\n\tswitch {\n\tcase n >= p:\n\t\treturn n\n\tcase n <= -p:\n\
    \t\treturn -p\n\tcase n >= -p:\n\t\treturn n\n\tcase n <= p:\n\t\treturn -p\n\t\
    }\n\t\n\tswitch {\n\tcase n >= p:\n\t\treturn n\n\tcase n <= -p:\n\t\treturn -p\n\
    \tcase n >= -p:\n\t\treturn n\n\tcase n <= p:\n\t\treturn -p\n\tcase n >= p:\n\
    \t\treturn n\n\t}\n\t\n\tswitch {\n\tcase n >= p:\n\t\treturn n\n\tcase n <= -p:\n\
    \t\treturn -p\n\tcase n >= -p:\n\t\treturn n\n\tcase n <= p:\n\t\treturn -p\n\t\
    case n >= p:\n\t\treturn n\n\tcase n <= -p:\n\t\treturn -p\n\t}\n\t\n\tswitch\
    \ {\n\tcase n >= p:\n\t\treturn n\n\tcase n <= -p:\n\t\treturn -p\n\tcase n >=\
    \ -p:\n\t\treturn n\n\tcase n <= p:\n\t\treturn -p\n\tcase n >= p:\n\t\treturn\
    \ n\n\tcase n <= -p:\n\t\treturn -p\n\tcase n >= p:\n\t\treturn n\n\t}\n\t\n\t\
    switch {\n\tcase n >= p:\n\t\treturn n\n\tcase n <= -p:\n\t\treturn -p\n\tcase\
    \ n >= -p:\n\t\treturn n\n\tcase n <= p:\n\t\treturn -p\n\tcase n >= p:\n\t\t\
    return n\n\tcase n <= -p:\n\t\treturn -p\n\tcase n >= p:\n\t\treturn n\n\t}\n\t\
    \n\tswitch {\n\tcase n >= p:\n\t\treturn n\n\tcase n <= -p:\n\t\treturn -p\n\t\
    case n >= -p:\n\t\treturn n\n\tcase n <= p:\n\t\treturn -p\n\tcase n >= p:\n\t\
    \treturn n\n\tcase n <= -p:\n\t\treturn -p\n\tcase n >= p:\n\t\treturn n\n\t}\n\
    \t\n\tswitch {\n\tcase n >= p:\n\t\treturn n\n\tcase n <= -p:\n\t\treturn -p\n\
    \tcase n >= -p:\n\t\treturn n\n\tcase n <= p:\n\t\treturn -p\n\tcase \n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmprgf_me7w.swift:14:9: error: expected expression in 'switch' statement\n\
    \        switch {\n               ^\n/tmp/tmprgf_me7w.swift:25:9: error: expected\
    \ expression in 'switch' statement\n        switch {\n               ^\n/tmp/tmprgf_me7w.swift:32:9:\
    \ error: expected expression in 'switch' statement\n        switch {\n       \
    \        ^\n/tmp/tmprgf_me7w.swift:43:9: error: expected expression in 'switch'\
    \ statement\n        switch {\n               ^\n/tmp/tmprgf_me7w.swift:56:9:\
    \ error: expected expression in 'switch' statement\n        switch {\n       \
    \        ^\n/tmp/tmprgf_me7w.swift:71:9: error: expected expression in 'switch'\
    \ statement\n        switch {\n               ^\n/tmp/tmprgf_me7w.swift:88:9:\
    \ error: expected expression in 'switch' statement\n        switch {\n       \
    \        ^\n/tmp/tmprgf_me7w.swift:105:9: error: expected expression in 'switch'\
    \ statement\n        switch {\n               ^\n/tmp/tmprgf_me7w.swift:122:9:\
    \ error: expected expression in 'switch' statement\n        switch {\n       \
    \        ^\n/tmp/tmprgf_me7w.swift:131:6: error: expected pattern\n        case\
    \ \n            ^\n/tmp/tmprgf_me7w.swift:131:6: error: expected ':' after 'case'\n\
    \        case \n            ^\n/tmp/tmprgf_me7w.swift:153:31: error: expected\
    \ '}' at end of brace statement\nassert(modp(n: 31, p: 5) == 3)\n            \
    \                  ^\n/tmp/tmprgf_me7w.swift:13:34: note: to match this opening\
    \ '{'\nfunc modp(n: Int, p: Int) -> Int {\n                                 ^\n\
    /tmp/tmprgf_me7w.swift:16:14: error: missing argument labels 'n:p:' in call\n\
    \                return modp(abs(n), p)\n                           ^\n      \
    \                      n:      p: \n/tmp/tmprgf_me7w.swift:18:14: error: missing\
    \ argument labels 'n:p:' in call\n                return modp(-n, p)\n       \
    \                    ^\n                            n:  p: \n/tmp/tmprgf_me7w.swift:22:14:\
    \ error: missing argument labels 'n:p:' in call\n                return modp(n,\
    \ p)\n                           ^\n                            n: p: \n/tmp/tmprgf_me7w.swift:135:6:\
    \ error: operator functions can"
  stdout: ''
  timestamp: 1660014750
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n\treturn (n & (p - 1)) == 0 ? n : n - 1\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmpcc_zzfak/tmpcc_zzfak.swift:31: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab1c634cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab1c6043b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab1c6043988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab1c60427b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpcc_zzfak                        0x000055ee00e7c23d <unavailable> + 4669

    5    libc.so.6                          0x00002ab1c6538460 __libc_start_main +
    245

    6    tmpcc_zzfak                        0x000055ee00e7be69 <unavailable> + 3689

    '
  stdout: ''
  timestamp: 1660014750
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n\tif n < 0 {\n\t\tpanic(\"modp: negative number\")\n\t}\n\tif p < 0 {\n\t\
    \tpanic(\"modp: negative modulus\")\n\t}\n\tif n == 0 {\n\t\treturn 1\n\t}\n\t\
    if p == 1 {\n\t\treturn n\n\t}\n\tif p > n {\n\t\tpanic(\"modp: modulus is too\
    \ large\")\n\t}\n\tr := 1\n\tfor i := n - 1; i >= 0; i-- {\n\t\tr *= p\n\t\tr\
    \ += n\n\t}\n\treturn r\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3,\
    \ p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) ==\
    \ 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp79g6si4v.swift:29:3: error: consecutive statements on a line must\
    \ be separated by ';'\n        r := 1\n         ^\n         ;\n/tmp/tmp79g6si4v.swift:29:4:\
    \ error: expected expression\n        r := 1\n          ^\n/tmp/tmp79g6si4v.swift:30:9:\
    \ error: expected type\n        for i := n - 1; i >= 0; i-- {\n              \
    \ ^\n                <#type#>\n/tmp/tmp79g6si4v.swift:30:9: error: expected 'in'\
    \ after for-each pattern\n        for i := n - 1; i >= 0; i-- {\n            \
    \   ^\n/tmp/tmp79g6si4v.swift:30:9: error: expected Sequence expression for for-each\
    \ loop\n        for i := n - 1; i >= 0; i-- {\n               ^\n/tmp/tmp79g6si4v.swift:15:3:\
    \ error: cannot find 'panic' in scope\n                panic(\"modp: negative\
    \ number\")\n                ^~~~~\n/tmp/tmp79g6si4v.swift:18:3: error: cannot\
    \ find 'panic' in scope\n                panic(\"modp: negative modulus\")\n \
    \               ^~~~~\n/tmp/tmp79g6si4v.swift:27:3: error: cannot find 'panic'\
    \ in scope\n                panic(\"modp: modulus is too large\")\n          \
    \      ^~~~~\n/tmp/tmp79g6si4v.swift:29:2: error: cannot find 'r' in scope\n \
    \       r := 1\n        ^\n/tmp/tmp79g6si4v.swift:34:9: error: cannot find 'r'\
    \ in scope\n        return r\n               ^\n"
  stdout: ''
  timestamp: 1660014750
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    if n < 0 {\n        return modp(Int(-n), p)\n    }\n    if p < 1 {\n\
    \        return modp(Int(n), p)\n    }\n    if p > p {\n        return modp(Int(n),\
    \ p)\n    }\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n     \
    \   return p\n    }\n    if n == p {\n        return n\n    }\n    if n == p {\n\
    \        return p\n    }\n    if n == p {\n        return p\n    }\n    if n ==\
    \ p {\n        return p\n    }\n    if n == p {\n        return p\n    }\n   \
    \ if n == p {\n        return p\n    }\n    if n == p {\n        return p\n  \
    \  }\n    if n == p {\n        return p\n    }\n    if n == p {\n        return\
    \ p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n      \
    \  return p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n\
    \        return p\n    }\n    if n == p {\n        return p\n    }\n    if n ==\
    \ p {\n        return p\n    }\n    if n == p {\n        return p\n    }\n   \
    \ if n == p {\n        return p\n    }\n    if n == p {\n        return p\n  \
    \  }\n    if n == p {\n        return p\n    }\n    if n == p {\n        return\
    \ p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n      \
    \  return p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n\
    \        return p\n    }\n    if n == p {\n        return p\n    }\n    if n ==\
    \ p {\n        return p\n    }\n    if n == p {\n        return p\n    }\n   \
    \ if n == p {\n        return p\n    }\n    if n == p {\n        return p\n  \
    \  }\n    if n == p {\n        return p\n    }\n    if n == p {\n        return\
    \ p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n      \
    \  return p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n\
    \        return p\n    }\n    if n == p {\n        return p\n    }\n    if n ==\
    \ p {\n        return p\n    }\n    if n == p {\n        return p\n    }\n   \
    \ if n == p {\n        return p\n    }\n    if n == p {\n        return p\n  \
    \  }\n    if n == p {\n        return p\n    }\n    if n == p {\n        return\
    \ p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n      \
    \  return p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n\
    \        return p\n    }\n    if n == p {\n        return p\n    }\n    if n ==\
    \ p {\n        return p\n    }\n    if n == p {\n        return p\n    }\n   \
    \ if n == p {\n        return p\n    }\n    if \n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp1xcsqf4c.swift:179:7: error: expected expression, var, or let in\
    \ 'if' condition\n    if \n      ^\n/tmp/tmp1xcsqf4c.swift:15:20: error: missing\
    \ argument labels 'n:p:' in call\n        return modp(Int(-n), p)\n          \
    \         ^\n                    n:       p: \n/tmp/tmp1xcsqf4c.swift:18:20: error:\
    \ missing argument labels 'n:p:' in call\n        return modp(Int(n), p)\n   \
    \                ^\n                    n:      p: \n/tmp/tmp1xcsqf4c.swift:21:20:\
    \ error: missing argument labels 'n:p:' in call\n        return modp(Int(n), p)\n\
    \                   ^\n                    n:      p: \n"
  stdout: ''
  timestamp: 1660014750
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n\tif n < 0 {\n\t\tn = -n\n\t\tp = -p\n\t}\n\tif p < 0 {\n\t\tpanic(\"modp():\
    \ negative modulus\")\n\t}\n\tif p > p {\n\t\tpanic(\"modp(): modulus is too big\"\
    )\n\t}\n\tif n == 0 {\n\t\treturn 0\n\t}\n\tif n == 1 {\n\t\treturn p\n\t}\n\t\
    if n == p {\n\t\treturn 1\n\t}\n\tq := n / p\n\tr := n % p\n\tif r == 0 {\n\t\t\
    return q\n\t}\n\tif r == p {\n\t\treturn q + 1\n\t}\n\treturn q + modp(q, p)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpiacnyyd0.swift:33:3: error: consecutive statements on a line must\
    \ be separated by ';'\n        q := n / p\n         ^\n         ;\n/tmp/tmpiacnyyd0.swift:33:4:\
    \ error: expected expression\n        q := n / p\n          ^\n/tmp/tmpiacnyyd0.swift:15:3:\
    \ error: cannot assign to value: 'n' is a 'let' constant\n                n =\
    \ -n\n                ^\n/tmp/tmpiacnyyd0.swift:16:3: error: cannot assign to\
    \ value: 'p' is a 'let' constant\n                p = -p\n                ^\n\
    /tmp/tmpiacnyyd0.swift:19:3: error: cannot find 'panic' in scope\n           \
    \     panic(\"modp(): negative modulus\")\n                ^~~~~\n/tmp/tmpiacnyyd0.swift:22:3:\
    \ error: cannot find 'panic' in scope\n                panic(\"modp(): modulus\
    \ is too big\")\n                ^~~~~\n/tmp/tmpiacnyyd0.swift:33:2: error: cannot\
    \ find 'q' in scope\n        q := n / p\n        ^\n/tmp/tmpiacnyyd0.swift:35:5:\
    \ error: cannot find 'r' in scope\n        if r == 0 {\n           ^\n/tmp/tmpiacnyyd0.swift:36:10:\
    \ error: cannot find 'q' in scope\n                return q\n                \
    \       ^\n/tmp/tmpiacnyyd0.swift:38:5: error: cannot find 'r' in scope\n    \
    \    if r == p {\n           ^\n/tmp/tmpiacnyyd0.swift:39:10: error: cannot find\
    \ 'q' in scope\n                return q + 1\n                       ^\n/tmp/tmpiacnyyd0.swift:41:9:\
    \ error: cannot find 'q' in scope\n        return q + modp(q, p)\n           \
    \    ^\n/tmp/tmpiacnyyd0.swift:41:18: error: cannot find 'q' in scope\n      \
    \  return q + modp(q, p)\n                        ^\n/tmp/tmpiacnyyd0.swift:41:17:\
    \ error: missing argument labels 'n:p:' in call\n        return q + modp(q, p)\n\
    \                       ^\n                        n: p: \n"
  stdout: ''
  timestamp: 1660014750
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    if n < 0 {\n        return modp(abs(n), p)\n    }\n    if p < 1 {\n \
    \       return modp(n, p - 1)\n    }\n    if p > p {\n        return modp(n, p\
    \ - p)\n    }\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n   \
    \     return p\n    }\n    if n == p {\n        return n\n    }\n    if n == p\
    \ {\n        return p\n    }\n    if n == p {\n        return p\n    }\n    if\
    \ n == p {\n        return p\n    }\n    if n == p {\n        return p\n    }\n\
    \    if n == p {\n        return p\n    }\n    if n == p {\n        return p\n\
    \    }\n    if n == p {\n        return p\n    }\n    if n == p {\n        return\
    \ p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n      \
    \  return p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n\
    \        return p\n    }\n    if n == p {\n        return p\n    }\n    if n ==\
    \ p {\n        return p\n    }\n    if n == p {\n        return p\n    }\n   \
    \ if n == p {\n        return p\n    }\n    if n == p {\n        return p\n  \
    \  }\n    if n == p {\n        return p\n    }\n    if n == p {\n        return\
    \ p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n      \
    \  return p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n\
    \        return p\n    }\n    if n == p {\n        return p\n    }\n    if n ==\
    \ p {\n        return p\n    }\n    if n == p {\n        return p\n    }\n   \
    \ if n == p {\n        return p\n    }\n    if n == p {\n        return p\n  \
    \  }\n    if n == p {\n        return p\n    }\n    if n == p {\n        return\
    \ p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n      \
    \  return p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n\
    \        return p\n    }\n    if n == p {\n        return p\n    }\n    if n ==\
    \ p {\n        return p\n    }\n    if n == p {\n        return p\n    }\n   \
    \ if n == p {\n        return p\n    }\n    if n == p {\n        return p\n  \
    \  }\n    if n == p {\n        return p\n    }\n    if n == p {\n        return\
    \ p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n      \
    \  return p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n\
    \        return p\n    }\n    if n == p {\n        return p\n    }\n    if n ==\
    \ p {\n        return p\n    }\n    if n == p {\n        return p\n    }\n   \
    \ if n == p {\n        return p\n    }\n    if n == p {\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp3658v1k9.swift:201:31: error: expected '}' at end of brace statement\n\
    assert(modp(n: 31, p: 5) == 3)\n                              ^\n/tmp/tmp3658v1k9.swift:13:34:\
    \ note: to match this opening '{'\nfunc modp(n: Int, p: Int) -> Int {\n      \
    \                           ^\n/tmp/tmp3658v1k9.swift:15:20: error: missing argument\
    \ labels 'n:p:' in call\n        return modp(abs(n), p)\n                   ^\n\
    \                    n:      p: \n/tmp/tmp3658v1k9.swift:18:20: error: missing\
    \ argument labels 'n:p:' in call\n        return modp(n, p - 1)\n            \
    \       ^\n                    n: p: \n/tmp/tmp3658v1k9.swift:21:20: error: missing\
    \ argument labels 'n:p:' in call\n        return modp(n, p - p)\n            \
    \       ^\n                    n: p: \n/tmp/tmp3658v1k9.swift:183:6: error: operator\
    \ functions can only be declared at global or in type scope\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660014750
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n\tif n < 0 {\n\t\tpanic(\"modp: negative number\")\n\t}\n\tif p < 0 {\n\t\
    \tpanic(\"modp: negative modulus\")\n\t}\n\tif n == 0 {\n\t\treturn 1\n\t}\n\t\
    if p == 1 {\n\t\treturn n\n\t}\n\tif p > p {\n\t\tpanic(\"modp: modulus is too\
    \ big\")\n\t}\n\tif n == 1 {\n\t\treturn 0\n\t}\n\tif n == 2 {\n\t\treturn 1\n\
    \t}\n\tif n == 3 {\n\t\treturn 2\n\t}\n\tif n == 4 {\n\t\treturn 3\n\t}\n\tif\
    \ n == 5 {\n\t\treturn 4\n\t}\n\tif n == 6 {\n\t\treturn 5\n\t}\n\tif n == 7 {\n\
    \t\treturn 6\n\t}\n\tif n == 8 {\n\t\treturn 7\n\t}\n\tif n == 9 {\n\t\treturn\
    \ 8\n\t}\n\tif n == 10 {\n\t\treturn 9\n\t}\n\tif n == 11 {\n\t\treturn 10\n\t\
    }\n\tif n == 12 {\n\t\treturn 11\n\t}\n\tif n == 13 {\n\t\treturn 12\n\t}\n\t\
    if n == 14 {\n\t\treturn 13\n\t}\n\tif n == 15 {\n\t\treturn 14\n\t}\n\tif n ==\
    \ 16 {\n\t\treturn 15\n\t}\n\tif n == 17 {\n\t\treturn 16\n\t}\n\tif n == 18 {\n\
    \t\treturn 17\n\t}\n\tif n == 19 {\n\t\treturn 18\n\t}\n\tif n == 20 {\n\t\treturn\
    \ 19\n\t}\n\tif n == 21 {\n\t\treturn 20\n\t}\n\tif n == 22 {\n\t\treturn 21\n\
    \t}\n\tif n == 23 {\n\t\treturn 22\n\t}\n\tif n == 24 {\n\t\treturn 23\n\t}\n\t\
    if n == 25 {\n\t\treturn 24\n\t}\n\tif n == 26 {\n\t\treturn 25\n\t}\n\tif n ==\
    \ 27 {\n\t\treturn 26\n\t}\n\tif n == 28 {\n\t\treturn 27\n\t}\n\tif n == 29 {\n\
    \t\treturn 28\n\t}\n\tif n == 30 {\n\t\treturn 29\n\t}\n\tif n == 31 {\n\t\treturn\
    \ 30\n\t}\n\tif n == 32 {\n\t\treturn 31\n\t}\n\tif n == 33 {\n\t\treturn 32\n\
    \t}\n\tif n == 34 {\n\t\treturn 33\n\t}\n\tif n == 35 {\n\t\treturn 34\n\t}\n\t\
    if n == 36 {\n\t\treturn 35\n\t}\n\tif n == 37 {\n\t\treturn 36\n\t}\n\tif n ==\
    \ 38 {\n\t\treturn 37\n\t}\n\tif n == 39 {\n\t\treturn 38\n\t}\n\tif n == 40 {\n\
    \t\treturn 39\n\t}\n\tif n == 41 {\n\t\treturn 40\n\t}\n\tif n == 42 {\n\t\treturn\
    \ 41\n\t}\n\tif n == 43 {\n\t\treturn 42\n\t}\n\tif n == 44 {\n\t\treturn 43\n\
    \t}\n\tif n == 45\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp_3hgivse.swift:161:12: error: expected '{' after 'if' condition\n\
    \        if n == 45\n                  ^\n/tmp/tmp_3hgivse.swift:15:3: error:\
    \ cannot find 'panic' in scope\n                panic(\"modp: negative number\"\
    )\n                ^~~~~\n/tmp/tmp_3hgivse.swift:18:3: error: cannot find 'panic'\
    \ in scope\n                panic(\"modp: negative modulus\")\n              \
    \  ^~~~~\n/tmp/tmp_3hgivse.swift:27:3: error: cannot find 'panic' in scope\n \
    \               panic(\"modp: modulus is too big\")\n                ^~~~~\n"
  stdout: ''
  timestamp: 1660014750
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n\tif n < 0 {\n\t\tn = -n\n\t}\n\tif p < 0 {\n\t\tp = -p\n\t}\n\tif n == 0\
    \ || p == 0 {\n\t\treturn 0\n\t}\n\tif p > n {\n\t\tp, n = n, p\n\t}\n\tif p >\
    \ 1 {\n\t\tp = p - 1\n\t}\n\tn %= p\n\tif n == 0 {\n\t\treturn 1\n\t}\n\treturn\
    \ p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n:\
    \ 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11)\
    \ == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpbi6pyjwp.swift:24:4: error: consecutive statements on a line must\
    \ be separated by ';'\n                p, n = n, p\n                 ^\n     \
    \            ;\n/tmp/tmpbi6pyjwp.swift:24:4: error: expected expression\n    \
    \            p, n = n, p\n                 ^\n/tmp/tmpbi6pyjwp.swift:15:3: error:\
    \ cannot assign to value: 'n' is a 'let' constant\n                n = -n\n  \
    \              ^\n/tmp/tmpbi6pyjwp.swift:18:3: error: cannot assign to value:\
    \ 'p' is a 'let' constant\n                p = -p\n                ^\n/tmp/tmpbi6pyjwp.swift:24:3:\
    \ warning: expression of type 'Int' is unused\n                p, n = n, p\n \
    \               ^\n/tmp/tmpbi6pyjwp.swift:27:3: error: cannot assign to value:\
    \ 'p' is a 'let' constant\n                p = p - 1\n                ^\n/tmp/tmpbi6pyjwp.swift:29:4:\
    \ error: left side of mutating operator isn't mutable: 'n' is a 'let' constant\n\
    \        n %= p\n        ~ ^\n"
  stdout: ''
  timestamp: 1660014750
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n\tswitch {\n\tcase n < p:\n\t\treturn n\n\tcase n == p:\n\t\treturn 1\n\t\
    case n == 0 || n == p:\n\t\treturn 0\n\tcase n >= p:\n\t\treturn n - p\n\t}\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpsuyqrxr0.swift:14:9: error: expected expression in 'switch' statement\n\
    \        switch {\n               ^\n"
  stdout: ''
  timestamp: 1660014750
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n\treturn (n & (p - 1)) == 0 ? n : n - 1\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmpcc_zzfak/tmpcc_zzfak.swift:31: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab1c634cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab1c6043b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab1c6043988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab1c60427b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpcc_zzfak                        0x000055ee00e7c23d <unavailable> + 4669

    5    libc.so.6                          0x00002ab1c6538460 __libc_start_main +
    245

    6    tmpcc_zzfak                        0x000055ee00e7be69 <unavailable> + 3689

    '
  stdout: ''
  timestamp: 1660014750
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    if n < 0 {\n        return modp(abs(n), p)\n    }\n    if p < 0 {\n \
    \       return modp(abs(p), n)\n    }\n    if n == 0 {\n        return 0\n   \
    \ }\n    if p == 0 {\n        return n\n    }\n    if p > n {\n        return\
    \ modp(n - p, p)\n    }\n    if p < n {\n        return modp(n, p)\n    }\n  \
    \  if n == p {\n        return n\n    }\n    if n == p+1 {\n        return p\n\
    \    }\n    if n == p-1 {\n        return p+1\n    }\n    if n == p+2 {\n    \
    \    return p+2\n    }\n    if n == p+3 {\n        return p+3\n    }\n    if n\
    \ == p+4 {\n        return p+4\n    }\n    if n == p+5 {\n        return p+5\n\
    \    }\n    if n == p+6 {\n        return p+6\n    }\n    if n == p+7 {\n    \
    \    return p+7\n    }\n    if n == p+8 {\n        return p+8\n    }\n    if n\
    \ == p+9 {\n        return p+9\n    }\n    if n == p+10 {\n        return p+10\n\
    \    }\n    if n == p+11 {\n        return p+11\n    }\n    if n == p+12 {\n \
    \       return p+12\n    }\n    if n == p+13 {\n        return p+13\n    }\n \
    \   if n == p+14 {\n        return p+14\n    }\n    if n == p+15 {\n        return\
    \ p+15\n    }\n    if n == p+16 {\n        return p+16\n    }\n    if n == p+17\
    \ {\n        return p+17\n    }\n    if n == p+18 {\n        return p+18\n   \
    \ }\n    if n == p+19 {\n        return p+19\n    }\n    if n == p+20 {\n    \
    \    return p+20\n    }\n    if n == p+21 {\n        return p+21\n    }\n    if\
    \ n == p+22 {\n        return p+22\n    }\n    if n == p+23 {\n        return\
    \ p+23\n    }\n    if n == p+24 {\n        return p+24\n    }\n    if n == p+25\
    \ {\n        return p+25\n    }\n    if n == p+26 {\n        return p+26\n   \
    \ }\n    if n == p+27 {\n        return p+27\n    }\n    if n == p+28 {\n    \
    \    return p+28\n    }\n    if n == p+29 {\n        return p+29\n    }\n    if\
    \ n == p+30 {\n        return p+30\n    }\n    if n == \n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpicm0mz4o.swift:129:1: error: expected expression after operator\n\
    }\n^\n/tmp/tmpicm0mz4o.swift:15:20: error: missing argument labels 'n:p:' in call\n\
    \        return modp(abs(n), p)\n                   ^\n                    n:\
    \      p: \n/tmp/tmpicm0mz4o.swift:18:20: error: missing argument labels 'n:p:'\
    \ in call\n        return modp(abs(p), n)\n                   ^\n            \
    \        n:      p: \n/tmp/tmpicm0mz4o.swift:27:20: error: missing argument labels\
    \ 'n:p:' in call\n        return modp(n - p, p)\n                   ^\n      \
    \              n:     p: \n/tmp/tmpicm0mz4o.swift:30:20: error: missing argument\
    \ labels 'n:p:' in call\n        return modp(n, p)\n                   ^\n   \
    \                 n: p: \n"
  stdout: ''
  timestamp: 1660014750
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n\tif n < 0 {\n\t\tpanic(\"modp(n,p)\")\n\t}\n\tif p < 0 {\n\t\tpanic(\"modp(n,p)\"\
    )\n\t}\n\tif n == 0 {\n\t\treturn 0\n\t}\n\tif p == 1 {\n\t\treturn n\n\t}\n\t\
    if p > p {\n\t\tpanic(\"modp(n,p)\")\n\t}\n\tif n == 1 {\n\t\treturn p\n\t}\n\t\
    if n == 2 {\n\t\treturn p + 1\n\t}\n\tif n == 3 {\n\t\treturn p + 2\n\t}\n\tif\
    \ n == 4 {\n\t\treturn p + 3\n\t}\n\tif n == 5 {\n\t\treturn p + 4\n\t}\n\tif\
    \ n == 6 {\n\t\treturn p + 5\n\t}\n\tif n == 7 {\n\t\treturn p + 6\n\t}\n\tif\
    \ n == 8 {\n\t\treturn p + 7\n\t}\n\tif n == 9 {\n\t\treturn p + 8\n\t}\n\tif\
    \ n == 10 {\n\t\treturn p + 9\n\t}\n\tif n == 11 {\n\t\treturn p + 10\n\t}\n\t\
    if n == 12 {\n\t\treturn p + 11\n\t}\n\tif n == 13 {\n\t\treturn p + 12\n\t}\n\
    \tif n == 14 {\n\t\treturn p + 13\n\t}\n\tif n == 15 {\n\t\treturn p + 14\n\t\
    }\n\tif n == 16 {\n\t\treturn p + 15\n\t}\n\tif n == 17 {\n\t\treturn p + 16\n\
    \t}\n\tif n == 18 {\n\t\treturn p + 17\n\t}\n\tif n == 19 {\n\t\treturn p + 18\n\
    \t}\n\tif n == 20 {\n\t\treturn p + 19\n\t}\n\tif n == 21 {\n\t\treturn p + 20\n\
    \t}\n\tif n == 22 {\n\t\treturn p + 21\n\t}\n\tif n == 23 {\n\t\treturn p + 22\n\
    \t}\n\tif n == 24 {\n\t\treturn p + 23\n\t}\n\tif n == 25 {\n\t\treturn p + 24\n\
    \t}\n\tif n == 26 {\n\t\treturn p + 25\n\t}\n\tif n == 27 {\n\t\treturn p + 26\n\
    \t}\n\tif n == 28 {\n\t\treturn p + 27\n\t}\n\tif n == 29 {\n\t\treturn p + 28\n\
    \t}\n\tif n == 30 {\n\t\treturn p + 29\n\t}\n\tif n == 31 {\n\t\treturn p + 30\n\
    \t}\n\tif n == 32 {\n\t\treturn p + 31\n\t}\n\tif n == 33 {\n\t\treturn p + 32\n\
    \t}\n\tif n == 34 {\n\t\treturn p + 33\n\t}\n\tif n == 35 {\n\t\treturn p + 34\n\
    \t}\n\tif n == 36 {\n\t\treturn p + 35\n\t}\n\tif n == 37 {\n\t\treturn p + 36\n\
    \t}\n\tif n == 38\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp7742yv_k.swift:140:12: error: expected '{' after 'if' condition\n\
    \        if n == 38\n                  ^\n/tmp/tmp7742yv_k.swift:15:3: error:\
    \ cannot find 'panic' in scope\n                panic(\"modp(n,p)\")\n       \
    \         ^~~~~\n/tmp/tmp7742yv_k.swift:18:3: error: cannot find 'panic' in scope\n\
    \                panic(\"modp(n,p)\")\n                ^~~~~\n/tmp/tmp7742yv_k.swift:27:3:\
    \ error: cannot find 'panic' in scope\n                panic(\"modp(n,p)\")\n\
    \                ^~~~~\n"
  stdout: ''
  timestamp: 1660014750
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n\tif n < 0 {\n\t\tpanic(\"modp: negative number\")\n\t}\n\tif p < 1 {\n\t\
    \tpanic(\"modp: p < 1\")\n\t}\n\tif n == 0 {\n\t\treturn 1\n\t}\n\tif n == 1 {\n\
    \t\treturn p\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tq := p\n\tfor {\n\t\tq\
    \ /= 2\n\t\tif q == p {\n\t\t\treturn n\n\t\t}\n\t\tif q > n {\n\t\t\tbreak\n\t\
    \t}\n\t}\n\treturn q\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3,\
    \ p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) ==\
    \ 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpaja0dbfk.swift:29:3: error: consecutive statements on a line must\
    \ be separated by ';'\n        q := p\n         ^\n         ;\n/tmp/tmpaja0dbfk.swift:29:4:\
    \ error: expected expression\n        q := p\n          ^\n/tmp/tmpaja0dbfk.swift:30:6:\
    \ error: expected pattern\n        for {\n            ^\n/tmp/tmpaja0dbfk.swift:30:6:\
    \ error: expected Sequence expression for for-each loop\n        for {\n     \
    \       ^\n/tmp/tmpaja0dbfk.swift:15:3: error: cannot find 'panic' in scope\n\
    \                panic(\"modp: negative number\")\n                ^~~~~\n/tmp/tmpaja0dbfk.swift:18:3:\
    \ error: cannot find 'panic' in scope\n                panic(\"modp: p < 1\")\n\
    \                ^~~~~\n/tmp/tmpaja0dbfk.swift:29:2: error: cannot find 'q' in\
    \ scope\n        q := p\n        ^\n/tmp/tmpaja0dbfk.swift:39:9: error: cannot\
    \ find 'q' in scope\n        return q\n               ^\n"
  stdout: ''
  timestamp: 1660014750
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    if n < 0 {\n        return modp(abs(n), p)\n    }\n    if p < 0 {\n \
    \       return modp(n, abs(p))\n    }\n    if n == 0 {\n        return 0\n   \
    \ }\n    if p == 0 {\n        return n\n    }\n    if p > n {\n        return\
    \ modp(n, p)\n    }\n    if p < n {\n        return modp(n - p, p)\n    }\n  \
    \  return n\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmputrmmgpq.swift:15:20: error: missing argument labels 'n:p:' in\
    \ call\n        return modp(abs(n), p)\n                   ^\n               \
    \     n:      p: \n/tmp/tmputrmmgpq.swift:18:20: error: missing argument labels\
    \ 'n:p:' in call\n        return modp(n, abs(p))\n                   ^\n     \
    \               n: p: \n/tmp/tmputrmmgpq.swift:27:20: error: missing argument\
    \ labels 'n:p:' in call\n        return modp(n, p)\n                   ^\n   \
    \                 n: p: \n/tmp/tmputrmmgpq.swift:30:20: error: missing argument\
    \ labels 'n:p:' in call\n        return modp(n - p, p)\n                   ^\n\
    \                    n:     p: \n"
  stdout: ''
  timestamp: 1660014749
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n\tif n < 0 {\n\t\tpanic(\"modp(n, p): n must be positive\")\n\t}\n\tif p\
    \ < 1 {\n\t\tpanic(\"modp(n, p): p must be positive\")\n\t}\n\tif n == 0 {\n\t\
    \treturn 1\n\t}\n\tif p == 1 {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\
    \t}\n\tif p > p {\n\t\tpanic(\"modp(n, p): p must be smaller than p\")\n\t}\n\t\
    n %= p\n\tif n == 0 {\n\t\treturn 1\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\t\
    if n > p {\n\t\tn -= p\n\t}\n\treturn n\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpi9t00j01.swift:15:3: error: cannot find 'panic' in scope\n    \
    \            panic(\"modp(n, p): n must be positive\")\n                ^~~~~\n\
    /tmp/tmpi9t00j01.swift:18:3: error: cannot find 'panic' in scope\n           \
    \     panic(\"modp(n, p): p must be positive\")\n                ^~~~~\n/tmp/tmpi9t00j01.swift:30:3:\
    \ error: cannot find 'panic' in scope\n                panic(\"modp(n, p): p must\
    \ be smaller than p\")\n                ^~~~~\n/tmp/tmpi9t00j01.swift:32:4: error:\
    \ left side of mutating operator isn't mutable: 'n' is a 'let' constant\n    \
    \    n %= p\n        ~ ^\n/tmp/tmpi9t00j01.swift:40:5: error: left side of mutating\
    \ operator isn't mutable: 'n' is a 'let' constant\n                n -= p\n  \
    \              ~ ^\n"
  stdout: ''
  timestamp: 1660014750
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    if n < 0 {\n        return modp(abs(n), p)\n    }\n    if p < 0 {\n \
    \       return modp(p % n, p)\n    }\n    if n == 0 {\n        return 0\n    }\n\
    \    if p == 1 {\n        return n\n    }\n    if p > p {\n        return modp(p\
    \ / n, p)\n    }\n    if p < p {\n        return modp((n - p) / n, p)\n    }\n\
    \    return modp((n - p) / n, p)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n:\
    \ 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101)\
    \ == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpcq1nasoq.swift:15:20: error: missing argument labels 'n:p:' in\
    \ call\n        return modp(abs(n), p)\n                   ^\n               \
    \     n:      p: \n/tmp/tmpcq1nasoq.swift:18:20: error: missing argument labels\
    \ 'n:p:' in call\n        return modp(p % n, p)\n                   ^\n      \
    \              n:     p: \n/tmp/tmpcq1nasoq.swift:27:20: error: missing argument\
    \ labels 'n:p:' in call\n        return modp(p / n, p)\n                   ^\n\
    \                    n:     p: \n/tmp/tmpcq1nasoq.swift:30:20: error: missing\
    \ argument labels 'n:p:' in call\n        return modp((n - p) / n, p)\n      \
    \             ^\n                    n:           p: \n/tmp/tmpcq1nasoq.swift:32:16:\
    \ error: missing argument labels 'n:p:' in call\n    return modp((n - p) / n,\
    \ p)\n               ^\n                n:           p: \n"
  stdout: ''
  timestamp: 1660014750
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n\tif n < 0 {\n\t\tpanic(\"modp negative number\")\n\t}\n\tif p < 2 {\n\t\t\
    return 0\n\t}\n\tif p > p {\n\t\treturn 1\n\t}\n\tif n == 0 {\n\t\treturn 0\n\t\
    }\n\tif n == 1 {\n\t\treturn 1\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tx :=\
    \ n\n\ty := p\n\tz := 1\n\tfor {\n\t\tif x == 0 {\n\t\t\treturn z\n\t\t}\n\t\t\
    if y == 0 {\n\t\t\treturn z\n\t\t}\n\t\tt = x % y\n\t\tx = y\n\t\ty = t\n\t\t\
    z = z * y\n\t}\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpryqfgc_l.swift:32:3: error: consecutive statements on a line must\
    \ be separated by ';'\n        x := n\n         ^\n         ;\n/tmp/tmpryqfgc_l.swift:32:4:\
    \ error: expected expression\n        x := n\n          ^\n/tmp/tmpryqfgc_l.swift:35:6:\
    \ error: expected pattern\n        for {\n            ^\n/tmp/tmpryqfgc_l.swift:35:6:\
    \ error: expected Sequence expression for for-each loop\n        for {\n     \
    \       ^\n/tmp/tmpryqfgc_l.swift:15:3: error: cannot find 'panic' in scope\n\
    \                panic(\"modp negative number\")\n                ^~~~~\n/tmp/tmpryqfgc_l.swift:32:2:\
    \ error: cannot find 'x' in scope\n        x := n\n        ^\n"
  stdout: ''
  timestamp: 1660014750
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n\tif n < 0 {\n\t\tpanic(\"modp(n,p)\")\n\t}\n\tif p < 0 {\n\t\tpanic(\"modp(n,p)\"\
    )\n\t}\n\tif n == 0 {\n\t\treturn 0\n\t}\n\tif n == 1 {\n\t\treturn p\n\t}\n\t\
    if p < 2 {\n\t\treturn 0\n\t}\n\tif p > p {\n\t\treturn 0\n\t}\n\tr := 1\n\tfor\
    \ i := 1; i <= p; i++ {\n\t\tr *= n\n\t\tif r < p {\n\t\t\tbreak\n\t\t}\n\t}\n\
    \treturn r\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp298x70s0.swift:32:3: error: consecutive statements on a line must\
    \ be separated by ';'\n        r := 1\n         ^\n         ;\n/tmp/tmp298x70s0.swift:32:4:\
    \ error: expected expression\n        r := 1\n          ^\n/tmp/tmp298x70s0.swift:33:9:\
    \ error: expected type\n        for i := 1; i <= p; i++ {\n               ^\n\
    \                <#type#>\n/tmp/tmp298x70s0.swift:33:9: error: expected 'in' after\
    \ for-each pattern\n        for i := 1; i <= p; i++ {\n               ^\n/tmp/tmp298x70s0.swift:33:9:\
    \ error: expected Sequence expression for for-each loop\n        for i := 1; i\
    \ <= p; i++ {\n               ^\n/tmp/tmp298x70s0.swift:15:3: error: cannot find\
    \ 'panic' in scope\n                panic(\"modp(n,p)\")\n                ^~~~~\n\
    /tmp/tmp298x70s0.swift:18:3: error: cannot find 'panic' in scope\n           \
    \     panic(\"modp(n,p)\")\n                ^~~~~\n/tmp/tmp298x70s0.swift:32:2:\
    \ error: cannot find 'r' in scope\n        r := 1\n        ^\n/tmp/tmp298x70s0.swift:39:9:\
    \ error: cannot find 'r' in scope\n        return r\n               ^\n"
  stdout: ''
  timestamp: 1660014750
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n\tif n < 0 {\n\t\tpanic(\"modp(n,p)\")\n\t}\n\tif p < 0 {\n\t\tpanic(\"modp(n,p)\"\
    )\n\t}\n\tif n == 0 || p == 0 {\n\t\treturn 0\n\t}\n\tif n == 1 {\n\t\treturn\
    \ p\n\t}\n\tif p < 2 {\n\t\treturn p\n\t}\n\tif p > p {\n\t\treturn 0\n\t}\n\t\
    q := p / 2\n\tr := p % 2\n\tif r == 0 {\n\t\treturn modp(q, p)\n\t}\n\tif r ==\
    \ 1 {\n\t\treturn modp(q + 1, p)\n\t}\n\treturn modp(q, p) + modp(q + 1, p)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpo1ontwks.swift:32:3: error: consecutive statements on a line must\
    \ be separated by ';'\n        q := p / 2\n         ^\n         ;\n/tmp/tmpo1ontwks.swift:32:4:\
    \ error: expected expression\n        q := p / 2\n          ^\n/tmp/tmpo1ontwks.swift:15:3:\
    \ error: cannot find 'panic' in scope\n                panic(\"modp(n,p)\")\n\
    \                ^~~~~\n/tmp/tmpo1ontwks.swift:18:3: error: cannot find 'panic'\
    \ in scope\n                panic(\"modp(n,p)\")\n                ^~~~~\n/tmp/tmpo1ontwks.swift:32:2:\
    \ error: cannot find 'q' in scope\n        q := p / 2\n        ^\n/tmp/tmpo1ontwks.swift:34:5:\
    \ error: cannot find 'r' in scope\n        if r == 0 {\n           ^\n/tmp/tmpo1ontwks.swift:35:15:\
    \ error: cannot find 'q' in scope\n                return modp(q, p)\n       \
    \                     ^\n/tmp/tmpo1ontwks.swift:35:14: error: missing argument\
    \ labels 'n:p:' in call\n                return modp(q, p)\n                 \
    \          ^\n                            n: p: \n/tmp/tmpo1ontwks.swift:37:5:\
    \ error: cannot find 'r' in scope\n        if r == 1 {\n           ^\n/tmp/tmpo1ontwks.swift:38:15:\
    \ error: cannot find 'q' in scope\n                return modp(q + 1, p)\n   \
    \                         ^\n/tmp/tmpo1ontwks.swift:38:14: error: missing argument\
    \ labels 'n:p:' in call\n                return modp(q + 1, p)\n             \
    \              ^\n                            n:     p: \n/tmp/tmpo1ontwks.swift:40:14:\
    \ error: cannot find 'q' in scope\n        return modp(q, p) + modp(q + 1, p)\n\
    \                    ^\n/tmp/tmpo1ontwks.swift:40:27: error: cannot find 'q' in\
    \ scope\n        return modp(q, p) + modp(q + 1, p)\n                        \
    \         ^\n/tmp/tmpo1ontwks.swift:40:13: error: missing argument labels 'n:p:'\
    \ in call\n        return modp(q, p) + modp(q + 1, p)\n                   ^\n\
    \                    n: p: \n/tmp/tmpo1ontwks.swift:40:26: error: missing argument\
    \ labels 'n:p:' in call\n        return modp(q, p) + modp(q + 1, p)\n        \
    \                        ^\n                                 n:     p: \n"
  stdout: ''
  timestamp: 1660014750
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n\tif n < 0 {\n\t\tpanic(\"modp: negative number\")\n\t}\n\tif p < 0 {\n\t\
    \tpanic(\"modp: negative modulus\")\n\t}\n\tif n == 0 {\n\t\treturn 0\n\t}\n\t\
    if p == 1 {\n\t\treturn n\n\t}\n\tif p > 1 {\n\t\tif n >= p {\n\t\t\treturn modp(n\
    \ - p, p)\n\t\t}\n\t\treturn modp(p, n)\n\t}\n\tif n == 1 {\n\t\treturn 1\n\t\
    }\n\tif n == p {\n\t\treturn 0\n\t}\n\tif n == p {\n\t\treturn 1\n\t}\n\tif n\
    \ == p - 1 {\n\t\treturn modp(n - 1, p)\n\t}\n\tif n == p - 1 {\n\t\treturn 1\n\
    \t}\n\tif n == p - 2 {\n\t\treturn modp(n - 2, p)\n\t}\n\tif n == p - 2 {\n\t\t\
    return modp(n - 1, p)\n\t}\n\tif n == p - 3 {\n\t\treturn modp(n - 3, p)\n\t}\n\
    \tif n == p - 3 {\n\t\treturn modp(n - 2, p)\n\t}\n\tif n == p - 4 {\n\t\treturn\
    \ modp(n - 4, p)\n\t}\n\tif n == p - 4 {\n\t\treturn modp(n - 3, p)\n\t}\n\tif\
    \ n == p - 5 {\n\t\treturn modp(n - 5, p)\n\t}\n\tif n == p - 5 {\n\t\treturn\
    \ modp(n - 4, p)\n\t}\n\tif n == p - 6 {\n\t\treturn modp(n - 6, p)\n\t}\n\tif\
    \ n == p - 6 {\n\t\treturn modp(n - 5, p)\n\t}\n\tif n == p - 7 {\n\t\treturn\
    \ modp(n - 7, p)\n\t}\n\tif n == p - 7 {\n\t\treturn modp(n - 6, p)\n\t}\n\tif\
    \ n == p - 8 {\n\t\treturn modp(n - 8, p)\n\t}\n\tif n == p - 8 {\n\t\treturn\
    \ modp(n - 7, p)\n\t}\n\tif n == p - 9 {\n\t\treturn modp(n - 9, p)\n\t}\n\tif\
    \ n == p - 9 {\n\t\treturn modp(n - 8, p)\n\t}\n\tif n == p - 10 {\n\t\treturn\
    \ modp(n - 10, p)\n\t}\n\tif n == p - 10 {\n\t\treturn modp(n - 9, p)\n\t}\n\t\
    if n == p - 11 {\n\t\treturn modp(n - 11, p)\n\t}\n\tif n == p - 11 {\n\t\treturn\
    \ modp(n - 10, p)\n\t}\n\tif n == p - 12 {\n\t\treturn modp(n - 12, p)\n\t}\n\t\
    if n == p - 12 {\n\t\treturn modp(n - 11, p)\n\t}\n\tif n == p - 13 {\n\t\treturn\
    \ modp(n - 13, p)\n\t}\n\tif n == p - 13 {\n\t\treturn modp(n - 12, p)\n\t}\n\t\
    if n == p - 14 {\n\t\treturn modp(n - 14, p)\n\t}\n\tif n == p - 14 {\n\t\treturn\
    \ modp(n - 13, \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmph2otkg89.swift:124:1: error: expected expression in list of expressions\n\
    }\n^\n/tmp/tmph2otkg89.swift:145:31: error: expected '}' at end of brace statement\n\
    assert(modp(n: 31, p: 5) == 3)\n                              ^\n/tmp/tmph2otkg89.swift:13:34:\
    \ note: to match this opening '{'\nfunc modp(n: Int, p: Int) -> Int {\n      \
    \                           ^\n/tmp/tmph2otkg89.swift:15:3: error: cannot find\
    \ 'panic' in scope\n                panic(\"modp: negative number\")\n       \
    \         ^~~~~\n/tmp/tmph2otkg89.swift:18:3: error: cannot find 'panic' in scope\n\
    \                panic(\"modp: negative modulus\")\n                ^~~~~\n/tmp/tmph2otkg89.swift:28:15:\
    \ error: missing argument labels 'n:p:' in call\n                        return\
    \ modp(n - p, p)\n                                   ^\n                     \
    \               n:     p: \n/tmp/tmph2otkg89.swift:30:14: error: missing argument\
    \ labels 'n:p:' in call\n                return modp(p, n)\n                 \
    \          ^\n                            n: p: \n/tmp/tmph2otkg89.swift:42:14:\
    \ error: missing argument labels 'n:p:' in call\n                return modp(n\
    \ - 1, p)\n                           ^\n                            n:     p:\
    \ \n/tmp/tmph2otkg89.swift:48:14: error: missing argument labels 'n:p:' in call\n\
    \                return modp(n - 2, p)\n                           ^\n       \
    \                     n:     p: \n/tmp/tmph2otkg89.swift:51:14: error: missing\
    \ argument labels 'n:p:' in call\n                return modp(n - 1, p)\n    \
    \                       ^\n                            n:     p: \n/tmp/tmph2otkg89.swift:54:14:\
    \ error: missing argument labels 'n:p:' in call\n                return modp(n\
    \ - 3, p)\n                           ^\n                            n:     p:\
    \ \n/tmp/tmph2otkg89.swift:57:14: error: missing argument labels 'n:p:' in call\n\
    \                return modp(n - 2, p)\n                           ^\n       \
    \                     n:     p: \n/tmp/tmph2otkg89.swift:60:14: error: missing\
    \ argument labels 'n:p:' in call\n                return modp(n - 4, p)\n    \
    \               "
  stdout: ''
  timestamp: 1660014750
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n\tswitch {\n\tcase n < 0 || p < 0 || p > n:\n\t\treturn 0\n\tcase p == n:\n\
    \t\treturn n\n\tcase p == 0:\n\t\treturn 1\n\tcase p == n:\n\t\treturn 0\n\tcase\
    \ p < n:\n\t\tlet q = p / n\n\t\tlet r = p % n\n\t\treturn modp(q, p) + modp(r,\
    \ p)\n\tdefault:\n\t\tlet q = p / n\n\t\tlet r = p % n\n\t\treturn modp(q, p)\
    \ + modp(r, p)\n\t}\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp7wt1bfii.swift:14:9: error: expected expression in 'switch' statement\n\
    \        switch {\n               ^\n/tmp/tmp7wt1bfii.swift:26:14: error: missing\
    \ argument labels 'n:p:' in call\n                return modp(q, p) + modp(r,\
    \ p)\n                           ^\n                            n: p: \n/tmp/tmp7wt1bfii.swift:26:27:\
    \ error: missing argument labels 'n:p:' in call\n                return modp(q,\
    \ p) + modp(r, p)\n                                        ^\n               \
    \                          n: p: \n/tmp/tmp7wt1bfii.swift:30:14: error: missing\
    \ argument labels 'n:p:' in call\n                return modp(q, p) + modp(r,\
    \ p)\n                           ^\n                            n: p: \n/tmp/tmp7wt1bfii.swift:30:27:\
    \ error: missing argument labels 'n:p:' in call\n                return modp(q,\
    \ p) + modp(r, p)\n                                        ^\n               \
    \                          n: p: \n"
  stdout: ''
  timestamp: 1660014750
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    return ((n & (p - 1)) == 0) ? n : ((n & (p - 1)) + p) % p\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmpi233l72q/tmpi233l72q.swift:31: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002afea657bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002afea6272b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002afea6272988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002afea62717b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpi233l72q                        0x00005614be2ee2cd <unavailable> + 4813

    5    libc.so.6                          0x00002afea6767460 __libc_start_main +
    245

    6    tmpi233l72q                        0x00005614be2edef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014750
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    if n == 0 {\n        return 0\n    }\n    if p == 0 {\n        return\
    \ 1\n    }\n    if p > n {\n        return modp(n - p, p)\n    }\n    if p < 0\
    \ {\n        return modp(-p, p)\n    }\n    if n == 1 {\n        return p\n  \
    \  }\n    if n == p {\n        return n\n    }\n    if n == p+1 {\n        return\
    \ p\n    }\n    if n == p+2 {\n        return p+1\n    }\n    if n == p+3 {\n\
    \        return p+2\n    }\n    if n == p+4 {\n        return p+3\n    }\n   \
    \ if n == p+5 {\n        return p+4\n    }\n    if n == p+6 {\n        return\
    \ p+5\n    }\n    if n == p+7 {\n        return p+6\n    }\n    if n == p+8 {\n\
    \        return p+7\n    }\n    if n == p+9 {\n        return p+8\n    }\n   \
    \ if n == p+10 {\n        return p+9\n    }\n    if n == p+11 {\n        return\
    \ p+10\n    }\n    if n == p+12 {\n        return p+11\n    }\n    if n == p+13\
    \ {\n        return p+12\n    }\n    if n == p+14 {\n        return p+13\n   \
    \ }\n    if n == p+15 {\n        return p+14\n    }\n    if n == p+16 {\n    \
    \    return p+15\n    }\n    if n == p+17 {\n        return p+16\n    }\n    if\
    \ n == p+18 {\n        return p+17\n    }\n    if n == p+19 {\n        return\
    \ p+18\n    }\n    if n == p+20 {\n        return p+19\n    }\n    if n == p+21\
    \ {\n        return p+20\n    }\n    if n == p+22 {\n        return p+21\n   \
    \ }\n    if n == p+23 {\n        return p+22\n    }\n    if n == p+24 {\n    \
    \    return p+23\n    }\n    if n == p+25 {\n        return p+24\n    }\n    if\
    \ n == p+26 {\n        return p+25\n    }\n    if n == p+27 {\n        return\
    \ p+26\n    }\n    if n == p+28 {\n        return p+27\n    }\n    if n == p+29\
    \ {\n        return p+28\n    }\n    if n == p+30 {\n        return p+29\n   \
    \ }\n    if n == p+31 {\n        return p+30\n    }\n    if n == p+32 {\n    \
    \    return p+31\n    }\n    if n == p+33 {\n\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp12s9j9pu.swift:151:31: error: expected '}' at end of brace statement\n\
    assert(modp(n: 31, p: 5) == 3)\n                              ^\n/tmp/tmp12s9j9pu.swift:13:34:\
    \ note: to match this opening '{'\nfunc modp(n: Int, p: Int) -> Int {\n      \
    \                           ^\n/tmp/tmp12s9j9pu.swift:21:20: error: missing argument\
    \ labels 'n:p:' in call\n        return modp(n - p, p)\n                   ^\n\
    \                    n:     p: \n/tmp/tmp12s9j9pu.swift:24:20: error: missing\
    \ argument labels 'n:p:' in call\n        return modp(-p, p)\n               \
    \    ^\n                    n:  p: \n/tmp/tmp12s9j9pu.swift:133:6: error: operator\
    \ functions can only be declared at global or in type scope\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660014750
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    return ((n%p) + p) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n:\
    \ 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101)\
    \ == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmpbx91mpfq/tmpbx91mpfq.swift:31: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b117cb67c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b117c85eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b117c85e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b117c85d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpbx91mpfq                        0x000055d7bf6962cd <unavailable> + 4813

    5    libc.so.6                          0x00002b117cd53460 __libc_start_main +
    245

    6    tmpbx91mpfq                        0x000055d7bf695ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014750
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n\tif n < 0 {\n\t\tpanic(\"modp(n,p)\")\n\t}\n\tif p < 0 {\n\t\tpanic(\"modp(n,p)\"\
    )\n\t}\n\tif n == 0 {\n\t\treturn 1\n\t}\n\tif p == 1 {\n\t\treturn n\n\t}\n\t\
    switch {\n\tcase n < 0:\n\t\treturn modp(abs(n), p)\n\tcase p == 0:\n\t\treturn\
    \ 0\n\tcase p == 1:\n\t\treturn n\n\tcase p < 0:\n\t\tpanic(\"modp(n,p)\")\n\t\
    }\n\tswitch {\n\tcase p < 0:\n\t\tpanic(\"modp(n,p)\")\n\tcase n < 0:\n\t\tpanic(\"\
    modp(n,p)\")\n\tcase n <= p:\n\t\treturn modp(n - p, p)\n\tdefault:\n\t\tpanic(\"\
    modp(n,p)\")\n\t}\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp7xwxb53k.swift:26:9: error: expected expression in 'switch' statement\n\
    \        switch {\n               ^\n/tmp/tmp7xwxb53k.swift:36:9: error: expected\
    \ expression in 'switch' statement\n        switch {\n               ^\n/tmp/tmp7xwxb53k.swift:15:3:\
    \ error: cannot find 'panic' in scope\n                panic(\"modp(n,p)\")\n\
    \                ^~~~~\n/tmp/tmp7xwxb53k.swift:18:3: error: cannot find 'panic'\
    \ in scope\n                panic(\"modp(n,p)\")\n                ^~~~~\n/tmp/tmp7xwxb53k.swift:28:14:\
    \ error: missing argument labels 'n:p:' in call\n                return modp(abs(n),\
    \ p)\n                           ^\n                            n:      p: \n\
    /tmp/tmp7xwxb53k.swift:34:3: error: cannot find 'panic' in scope\n           \
    \     panic(\"modp(n,p)\")\n                ^~~~~\n/tmp/tmp7xwxb53k.swift:38:3:\
    \ error: cannot find 'panic' in scope\n                panic(\"modp(n,p)\")\n\
    \                ^~~~~\n/tmp/tmp7xwxb53k.swift:40:3: error: cannot find 'panic'\
    \ in scope\n                panic(\"modp(n,p)\")\n                ^~~~~\n/tmp/tmp7xwxb53k.swift:42:14:\
    \ error: missing argument labels 'n:p:' in call\n                return modp(n\
    \ - p, p)\n                           ^\n                            n:     p:\
    \ \n/tmp/tmp7xwxb53k.swift:44:3: error: cannot find 'panic' in scope\n       \
    \         panic(\"modp(n,p)\")\n                ^~~~~\n"
  stdout: ''
  timestamp: 1660014750
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    if n < 0 {\n        return modp(abs(n), p)\n    }\n    if p < 0 {\n \
    \       return modp(n, abs(p))\n    }\n    if n == 0 {\n        return 0\n   \
    \ }\n    if p == 0 {\n        return n\n    }\n    if p > n {\n        return\
    \ modp(n, p)\n    }\n    if p < n {\n        return modp(n, p)\n    }\n    var\
    \ res = 1\n    for i := n - 1; i >= 0; i-- {\n        res *= p\n        res %=\
    \ p\n    }\n    return res\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3,\
    \ p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) ==\
    \ 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmprlp9d8kf.swift:33:12: error: expected type\n    for i := n - 1;\
    \ i >= 0; i-- {\n           ^\n            <#type#>\n/tmp/tmprlp9d8kf.swift:33:12:\
    \ error: expected 'in' after for-each pattern\n    for i := n - 1; i >= 0; i--\
    \ {\n           ^\n/tmp/tmprlp9d8kf.swift:33:12: error: expected Sequence expression\
    \ for for-each loop\n    for i := n - 1; i >= 0; i-- {\n           ^\n/tmp/tmprlp9d8kf.swift:15:20:\
    \ error: missing argument labels 'n:p:' in call\n        return modp(abs(n), p)\n\
    \                   ^\n                    n:      p: \n/tmp/tmprlp9d8kf.swift:18:20:\
    \ error: missing argument labels 'n:p:' in call\n        return modp(n, abs(p))\n\
    \                   ^\n                    n: p: \n/tmp/tmprlp9d8kf.swift:27:20:\
    \ error: missing argument labels 'n:p:' in call\n        return modp(n, p)\n \
    \                  ^\n                    n: p: \n/tmp/tmprlp9d8kf.swift:30:20:\
    \ error: missing argument labels 'n:p:' in call\n        return modp(n, p)\n \
    \                  ^\n                    n: p: \n"
  stdout: ''
  timestamp: 1660014750
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    if n < 0 {\n        return modp(abs(n), p)\n    }\n    if p < 0 {\n \
    \       return modp(n, abs(p))\n    }\n    if n == 0 {\n        return 0\n   \
    \ }\n    if p == 0 {\n        return n\n    }\n    if p > n {\n        return\
    \ modp(n, p)\n    }\n    if p < n {\n        return modp(n, p)\n    }\n    if\
    \ n == p {\n        return n\n    }\n    if n == 0 {\n        return 0\n    }\n\
    \    if p == 0 {\n        return n\n    }\n    if p > n {\n        return modp(n,\
    \ p)\n    }\n    if p < n {\n        return modp(n, p)\n    }\n    if n == p {\n\
    \        return n\n    }\n    if n == 0 {\n        return 0\n    }\n    if p ==\
    \ 0 {\n        return n\n    }\n    if p > n {\n        return modp(n, p)\n  \
    \  }\n    if p < n {\n        return modp(n, p)\n    }\n    if n == p {\n    \
    \    return n\n    }\n    if n == 0 {\n        return 0\n    }\n    if p == 0\
    \ {\n        return n\n    }\n    if p > n {\n        return modp(n, p)\n    }\n\
    \    if p < n {\n        return modp(n, p)\n    }\n    if n == p {\n        return\
    \ n\n    }\n    if n == 0 {\n        return 0\n    }\n    if p == 0 {\n      \
    \  return n\n    }\n    if p > n {\n        return modp(n, p)\n    }\n    if p\
    \ < n {\n        return modp(n, p)\n    }\n    if n == p {\n        return n\n\
    \    }\n    if n == 0 {\n        return 0\n    }\n    if p == 0 {\n        return\
    \ n\n    }\n    if p > n {\n        return modp(n, p)\n    }\n    if p < n {\n\
    \        return modp(n, p)\n    }\n    if n == p {\n        return n\n    }\n\
    \    if n == 0 {\n        return 0\n    }\n    if p == 0 {\n        return n\n\
    \    }\n    if p > n {\n        return modp(n, p)\n    }\n    if p < n {\n   \
    \     return modp(n, p)\n    }\n    if n == p {\n        return n\n    }\n   \
    \ if n == 0 {\n        return 0\n    }\n    if p == 0 {\n        return n\n  \
    \  }\n    if p > n {\n        return modp(n, p)\n    }\n    if p < n {\n     \
    \   return modp(n, p)\n    }\n    if n == p {\n        return n\n    }\n    if\
    \ n == 0 {\n        return 0\n    }\n    if p == 0 {\n        return n\n    }\n\
    \    if p > n {\n        return modp(n, p)\n    }\n    if p < n {\n        return\
    \ modp(n, p)\n\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpnk3cq5bz.swift:173:31: error: expected '}' at end of brace statement\n\
    assert(modp(n: 31, p: 5) == 3)\n                              ^\n/tmp/tmpnk3cq5bz.swift:13:34:\
    \ note: to match this opening '{'\nfunc modp(n: Int, p: Int) -> Int {\n      \
    \                           ^\n/tmp/tmpnk3cq5bz.swift:15:20: error: missing argument\
    \ labels 'n:p:' in call\n        return modp(abs(n), p)\n                   ^\n\
    \                    n:      p: \n/tmp/tmpnk3cq5bz.swift:18:20: error: missing\
    \ argument labels 'n:p:' in call\n        return modp(n, abs(p))\n           \
    \        ^\n                    n: p: \n/tmp/tmpnk3cq5bz.swift:27:20: error: missing\
    \ argument labels 'n:p:' in call\n        return modp(n, p)\n                \
    \   ^\n                    n: p: \n/tmp/tmpnk3cq5bz.swift:30:20: error: missing\
    \ argument labels 'n:p:' in call\n        return modp(n, p)\n                \
    \   ^\n                    n: p: \n/tmp/tmpnk3cq5bz.swift:42:20: error: missing\
    \ argument labels 'n:p:' in call\n        return modp(n, p)\n                \
    \   ^\n                    n: p: \n/tmp/tmpnk3cq5bz.swift:45:20: error: missing\
    \ argument labels 'n:p:' in call\n        return modp(n, p)\n                \
    \   ^\n                    n: p: \n/tmp/tmpnk3cq5bz.swift:57:20: error: missing\
    \ argument labels 'n:p:' in call\n        return modp(n, p)\n                \
    \   ^\n                    n: p: \n/tmp/tmpnk3cq5bz.swift:60:20: error: missing\
    \ argument labels 'n:p:' in call\n        return modp(n, p)\n                \
    \   ^\n                    n: p: \n/tmp/tmpnk3cq5bz.swift:72:20: error: missing\
    \ argument labels 'n:p:' in call\n        return modp(n, p)\n                \
    \   ^\n                    n: p: \n/tmp/tmpnk3cq5bz.swift:75:20: error: missing\
    \ argument labels 'n:p:' in call\n        return modp(n, p)\n                \
    \   ^\n                    n: p: \n/tmp/tmpnk3cq5bz.swift:87:20: error: missing\
    \ argument labels 'n:p:' in call\n        return modp(n, p)\n                \
    \   ^\n                    n: p: \n/tmp/tmpnk3cq5bz.swift:90:20: error: missing\
    \ argument labels 'n:p:' in call\n        return modp(n, p)\n         "
  stdout: ''
  timestamp: 1660014750
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    if n < 0 {\n        return modp(abs(n), p)\n    }\n    if p < 0 {\n \
    \       return modp(-n, p)\n    }\n    if n == 0 {\n        return 0\n    }\n\
    \    if p == 0 {\n        return n\n    }\n    if p > n {\n        return modp(n,\
    \ p)\n    }\n    if p < n {\n        return modp(n, p)\n    }\n    if n == p {\n\
    \        return n\n    }\n    if n == 0 {\n        return 0\n    }\n    if n ==\
    \ 1 {\n        return p\n    }\n    if n == p {\n        return n\n    }\n   \
    \ if n == p {\n        return p\n    }\n    if n == 1 {\n        return p\n  \
    \  }\n    if n == p {\n        return n\n    }\n    if n == p {\n        return\
    \ p\n    }\n    if n == 1 {\n        return p\n    }\n    if n == p {\n      \
    \  return n\n    }\n    if n == p {\n        return p\n    }\n    if n == 1 {\n\
    \        return p\n    }\n    if n == p {\n        return n\n    }\n    if n ==\
    \ p {\n        return p\n    }\n    if n == 1 {\n        return p\n    }\n   \
    \ if n == p {\n        return n\n    }\n    if n == p {\n        return p\n  \
    \  }\n    if n == 1 {\n        return p\n    }\n    if n == p {\n        return\
    \ n\n    }\n    if n == p {\n        return p\n    }\n    if n == 1 {\n      \
    \  return p\n    }\n    if n == p {\n        return n\n    }\n    if n == p {\n\
    \        return p\n    }\n    if n == 1 {\n        return p\n    }\n    if n ==\
    \ p {\n        return n\n    }\n    if n == p {\n        return p\n    }\n   \
    \ if n == 1 {\n        return p\n    }\n    if n == p {\n        return n\n  \
    \  }\n    if n == p {\n        return p\n    }\n    if n == 1 {\n        return\
    \ p\n    }\n    if n == p {\n        return n\n    }\n    if n == p {\n      \
    \  return p\n    }\n    if n == 1 {\n        return p\n    }\n    if n == p {\n\
    \        return n\n    }\n    if n == p {\n        return p\n    }\n    if n ==\
    \ 1 {\n        return p\n    }\n    if n == p {\n        return n\n    }\n   \
    \ if n == p {\n        return p\n    }\n    if n == 1 {\n        return p\n  \
    \  }\n    if n == p {\n        return n\n    }\n    if n == p {\n        return\
    \ p\n    }\n    if n == 1 {\n        return p\n    }\n    if n == p {\n      \
    \  return n\n    }\n    if n == p {\n        return p\n    }\n    if n == 1 {\n\
    \        return p\n    }\n    if n == p {\n        return n\n    }\n    if n ==\
    \ p {\n        return p\n    }\n    if n == 1 {\n        return p\n    }\n   \
    \ if n == p {\n        return n\n\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n:\
    \ 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101)\
    \ == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpqnj3cqik.swift:200:31: error: expected '}' at end of brace statement\n\
    assert(modp(n: 31, p: 5) == 3)\n                              ^\n/tmp/tmpqnj3cqik.swift:13:34:\
    \ note: to match this opening '{'\nfunc modp(n: Int, p: Int) -> Int {\n      \
    \                           ^\n/tmp/tmpqnj3cqik.swift:15:20: error: missing argument\
    \ labels 'n:p:' in call\n        return modp(abs(n), p)\n                   ^\n\
    \                    n:      p: \n/tmp/tmpqnj3cqik.swift:18:20: error: missing\
    \ argument labels 'n:p:' in call\n        return modp(-n, p)\n               \
    \    ^\n                    n:  p: \n/tmp/tmpqnj3cqik.swift:27:20: error: missing\
    \ argument labels 'n:p:' in call\n        return modp(n, p)\n                \
    \   ^\n                    n: p: \n/tmp/tmpqnj3cqik.swift:30:20: error: missing\
    \ argument labels 'n:p:' in call\n        return modp(n, p)\n                \
    \   ^\n                    n: p: \n/tmp/tmpqnj3cqik.swift:182:6: error: operator\
    \ functions can only be declared at global or in type scope\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660014750
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n\tif n < 0 {\n\t\tn = -n\n\t\tp = -p\n\t}\n\tif p == 0 {\n\t\treturn 0\n\t\
    }\n\tif n == 0 {\n\t\treturn 1\n\t}\n\tif n == 1 {\n\t\treturn p\n\t}\n\tif p\
    \ < 2 {\n\t\treturn 0\n\t}\n\tif p > p {\n\t\treturn 0\n\t}\n\tif n == p {\n\t\
    \treturn 1\n\t}\n\tx := n\n\ty := p\n\tt := 1\n\tfor {\n\t\tif y % 2 == 0 {\n\t\
    \t\tx /= 2\n\t\t\ty /= 2\n\t\t\tt *= x\n\t\t} else {\n\t\t\ty /= 2\n\t\t}\n\t\t\
    if x == 1 {\n\t\t\treturn t\n\t\t}\n\t}\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp2svvvf8j.swift:36:3: error: consecutive statements on a line must\
    \ be separated by ';'\n        x := n\n         ^\n         ;\n/tmp/tmp2svvvf8j.swift:36:4:\
    \ error: expected expression\n        x := n\n          ^\n/tmp/tmp2svvvf8j.swift:39:6:\
    \ error: expected pattern\n        for {\n            ^\n/tmp/tmp2svvvf8j.swift:39:6:\
    \ error: expected Sequence expression for for-each loop\n        for {\n     \
    \       ^\n/tmp/tmp2svvvf8j.swift:15:3: error: cannot assign to value: 'n' is\
    \ a 'let' constant\n                n = -n\n                ^\n/tmp/tmp2svvvf8j.swift:16:3:\
    \ error: cannot assign to value: 'p' is a 'let' constant\n                p =\
    \ -p\n                ^\n/tmp/tmp2svvvf8j.swift:36:2: error: cannot find 'x' in\
    \ scope\n        x := n\n        ^\n"
  stdout: ''
  timestamp: 1660014750
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    if n < 0 {\n        return modp(-n, p)\n    }\n    if p < 1 {\n     \
    \   return modp(n, p - 1)\n    }\n    if p > p {\n        return modp(n, p - p)\n\
    \    }\n    return n % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3,\
    \ p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) ==\
    \ 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp9p5ytywh.swift:15:20: error: missing argument labels 'n:p:' in\
    \ call\n        return modp(-n, p)\n                   ^\n                   \
    \ n:  p: \n/tmp/tmp9p5ytywh.swift:18:20: error: missing argument labels 'n:p:'\
    \ in call\n        return modp(n, p - 1)\n                   ^\n             \
    \       n: p: \n/tmp/tmp9p5ytywh.swift:21:20: error: missing argument labels 'n:p:'\
    \ in call\n        return modp(n, p - p)\n                   ^\n             \
    \       n: p: \n"
  stdout: ''
  timestamp: 1660014750
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n\tif n < 0 {\n\t\tpanic(\"modp: negative number\")\n\t}\n\tif p < 1 {\n\t\
    \tpanic(\"modp: negative modulus\")\n\t}\n\tif n == 0 || p == 0 {\n\t\treturn\
    \ 0\n\t}\n\tswitch {\n\tcase p < 0:\n\t\tpanic(\"modp: negative modulus\")\n\t\
    case p > n:\n\t\tpanic(\"modp: modulus greater than number\")\n\tdefault:\n\t\t\
    n %= p\n\t\tif n == 0 {\n\t\t\treturn 1\n\t\t}\n\t\treturn p\n\t}\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpuzbzyvcq.swift:23:9: error: expected expression in 'switch' statement\n\
    \        switch {\n               ^\n/tmp/tmpuzbzyvcq.swift:15:3: error: cannot\
    \ find 'panic' in scope\n                panic(\"modp: negative number\")\n  \
    \              ^~~~~\n/tmp/tmpuzbzyvcq.swift:18:3: error: cannot find 'panic'\
    \ in scope\n                panic(\"modp: negative modulus\")\n              \
    \  ^~~~~\n/tmp/tmpuzbzyvcq.swift:25:3: error: cannot find 'panic' in scope\n \
    \               panic(\"modp: negative modulus\")\n                ^~~~~\n/tmp/tmpuzbzyvcq.swift:27:3:\
    \ error: cannot find 'panic' in scope\n                panic(\"modp: modulus greater\
    \ than number\")\n                ^~~~~\n/tmp/tmpuzbzyvcq.swift:29:5: error: left\
    \ side of mutating operator isn't mutable: 'n' is a 'let' constant\n         \
    \       n %= p\n                ~ ^\n"
  stdout: ''
  timestamp: 1660014750
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    if n < 0 {\n        return modp(-n, p)\n    }\n    if p < 2 {\n     \
    \   return n\n    }\n    if p > p {\n        return modp(n, p - 2)\n    }\n  \
    \  if n == 0 {\n        return 0\n    }\n    if n == 1 {\n        return p\n \
    \   }\n    if n == p {\n        return n\n    }\n    if n == p {\n        return\
    \ p\n    }\n    if n == p - 1 {\n        return n - 1\n    }\n    if n == p -\
    \ 2 {\n        return n - 2\n    }\n    if n == p - 3 {\n        return n - 3\n\
    \    }\n    if n == p - 4 {\n        return n - 4\n    }\n    if n == p - 5 {\n\
    \        return n - 5\n    }\n    if n == p - 6 {\n        return n - 6\n    }\n\
    \    if n == p - 7 {\n        return n - 7\n    }\n    if n == p - 8 {\n     \
    \   return n - 8\n    }\n    if n == p - 9 {\n        return n - 9\n    }\n  \
    \  if n == p - 10 {\n        return n - 10\n    }\n    if n == p - 11 {\n    \
    \    return n - 11\n    }\n    if n == p - 12 {\n        return n - 12\n    }\n\
    \    if n == p - 13 {\n        return n - 13\n    }\n    if n == p - 14 {\n  \
    \      return n - 14\n    }\n    if n == p - 15 {\n        return n - 15\n   \
    \ }\n    if n == p - 16 {\n        return n - 16\n    }\n    if n == p - 17 {\n\
    \        return n - 17\n    }\n    if n == p - 18 {\n        return n - 18\n \
    \   }\n    if n == p - 19 {\n        return n - 19\n    }\n    if n == p - 20\
    \ {\n        return n - 20\n    }\n    if n == p - 21 {\n        return n - 21\n\
    \    }\n    if n == p - 22 {\n        return n - 22\n    }\n    if n == p - 23\
    \ {\n        return n - 23\n    }\n    if n == p - 24 {\n        return n - 24\n\
    \    }\n    if n == p - 25 {\n        return n - 25\n    }\n    if n == p - 26\
    \ {\n        return n - 26\n    }\n    if n == p - 27 {\n        return n - 27\n\
    \    }\n    if n == p - 28 {\n        return n - 28\n    }\n    if n == p - 29\
    \ {\n        return n - 29\n    }\n    if n == p - 30 {\n        return n - 30\n\
    \    }\n    if n == p - 31 {\n        return n - 31\n    }\n    if n == p - 32\
    \ {\n        return n - 32\n    }\n    if n == p - 33 {\n        return n - 33\n\
    \    }\n    if n == p - 34 {\n        return n - 34\n    }\n    if n == p - 35\
    \ {\n        return n - 35\n    }\n    if n == p - 36 {\n        return n - 36\n\
    \    }\n    if n == p - 37 {\n        return n - 37\n    }\n\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpn9734779.swift:15:20: error: missing argument labels 'n:p:' in\
    \ call\n        return modp(-n, p)\n                   ^\n                   \
    \ n:  p: \n/tmp/tmpn9734779.swift:21:20: error: missing argument labels 'n:p:'\
    \ in call\n        return modp(n, p - 2)\n                   ^\n             \
    \       n: p: \n"
  stdout: ''
  timestamp: 1660014750
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    if n < 0 {\n        return modp(abs(n), p)\n    }\n    if p < 0 {\n \
    \       return modp(n, abs(p))\n    }\n    if n == 0 {\n        return 0\n   \
    \ }\n    if p == 0 {\n        return n\n    }\n    if n == p {\n        return\
    \ n\n    }\n    if n == p {\n        return n\n    }\n    if n == p {\n      \
    \  return n\n    }\n    if n == p {\n        return n\n    }\n    if n == p {\n\
    \        return n\n    }\n    if n == p {\n        return n\n    }\n    if n ==\
    \ p {\n        return n\n    }\n    if n == p {\n        return n\n    }\n   \
    \ if n == p {\n        return n\n    }\n    if n == p {\n        return n\n  \
    \  }\n    if n == p {\n        return n\n    }\n    if n == p {\n        return\
    \ n\n    }\n    if n == p {\n        return n\n    }\n    if n == p {\n      \
    \  return n\n    }\n    if n == p {\n        return n\n    }\n    if n == p {\n\
    \        return n\n    }\n    if n == p {\n        return n\n    }\n    if n ==\
    \ p {\n        return n\n    }\n    if n == p {\n        return n\n    }\n   \
    \ if n == p {\n        return n\n    }\n    if n == p {\n        return n\n  \
    \  }\n    if n == p {\n        return n\n    }\n    if n == p {\n        return\
    \ n\n    }\n    if n == p {\n        return n\n    }\n    if n == p {\n      \
    \  return n\n    }\n    if n == p {\n        return n\n    }\n    if n == p {\n\
    \        return n\n    }\n    if n == p {\n        return n\n    }\n    if n ==\
    \ p {\n        return n\n    }\n    if n == p {\n        return n\n    }\n   \
    \ if n == p {\n        return n\n    }\n    if n == p {\n        return n\n  \
    \  }\n    if n == p {\n        return n\n    }\n    if n == p {\n        return\
    \ n\n    }\n    if n == p {\n        return n\n    }\n    if n == p {\n      \
    \  return n\n    }\n    if n == p {\n        return n\n    }\n    if n == p {\n\
    \        return n\n    }\n    if n == p {\n        return n\n    }\n    if n ==\
    \ p {\n        return n\n    }\n    if n == p {\n        return n\n    }\n   \
    \ if n == p {\n        return n\n    }\n    if n == p {\n        return n\n  \
    \  }\n    if n == p {\n        return n\n    }\n    if n == p {\n        return\
    \ n\n    }\n    if n == p {\n        return n\n    }\n    if n == p {\n      \
    \  return n\n    }\n    if n == p {\n        return n\n    }\n    if n == p {\n\
    \        return n\n    }\n    if n == p {\n        return n\n    }\n    if n ==\
    \ p {\n        return n\n    }\n    if n == p {\n        return n\n\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp68p_gotw.swift:203:31: error: expected '}' at end of brace statement\n\
    assert(modp(n: 31, p: 5) == 3)\n                              ^\n/tmp/tmp68p_gotw.swift:13:34:\
    \ note: to match this opening '{'\nfunc modp(n: Int, p: Int) -> Int {\n      \
    \                           ^\n/tmp/tmp68p_gotw.swift:15:20: error: missing argument\
    \ labels 'n:p:' in call\n        return modp(abs(n), p)\n                   ^\n\
    \                    n:      p: \n/tmp/tmp68p_gotw.swift:18:20: error: missing\
    \ argument labels 'n:p:' in call\n        return modp(n, abs(p))\n           \
    \        ^\n                    n: p: \n/tmp/tmp68p_gotw.swift:185:6: error: operator\
    \ functions can only be declared at global or in type scope\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660014750
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n\tswitch {\n\tcase n < 0 || p < 0 || p > n:\n\t\tpanic(\"modp: invalid arguments\"\
    )\n\tcase p == 0:\n\t\treturn 1\n\tcase p == n:\n\t\treturn 0\n\tcase p == n:\n\
    \t\treturn 0\n\tcase p == n:\n\t\treturn 0\n\tcase p == n:\n\t\treturn 0\n\tcase\
    \ p == n:\n\t\treturn 0\n\tcase p == n:\n\t\treturn 0\n\tcase p == n:\n\t\treturn\
    \ 0\n\tcase p == n:\n\t\treturn 0\n\tcase p == n:\n\t\treturn 0\n\tcase p == n:\n\
    \t\treturn 0\n\tcase p == n:\n\t\treturn 0\n\tcase p == n:\n\t\treturn 0\n\tcase\
    \ p == n:\n\t\treturn 0\n\tcase p == n:\n\t\treturn 0\n\tcase p == n:\n\t\treturn\
    \ 0\n\tcase p == n:\n\t\treturn 0\n\tcase p == n:\n\t\treturn 0\n\tcase p == n:\n\
    \t\treturn 0\n\tcase p == n:\n\t\treturn 0\n\tcase p == n:\n\t\treturn 0\n\tcase\
    \ p == n:\n\t\treturn 0\n\tcase p == n:\n\t\treturn 0\n\tcase p == n:\n\t\treturn\
    \ 0\n\tcase p == n:\n\t\treturn 0\n\tcase p == n:\n\t\treturn 0\n\tcase p == n:\n\
    \t\treturn 0\n\tcase p == n:\n\t\treturn 0\n\tcase p == n:\n\t\treturn 0\n\tcase\
    \ p == n:\n\t\treturn 0\n\tcase p == n:\n\t\treturn 0\n\tcase p == n:\n\t\treturn\
    \ 0\n\tcase p == n:\n\t\treturn 0\n\tcase p == n:\n\t\treturn 0\n\tcase p == n:\n\
    \t\treturn 0\n\tcase p == n:\n\t\treturn 0\n\tcase p == n:\n\t\treturn 0\n\tcase\
    \ p == n:\n\t\treturn 0\n\tcase p == n:\n\t\treturn 0\n\tcase p == n:\n\t\treturn\
    \ 0\n\tcase p == n:\n\t\treturn 0\n\tcase p == n:\n\t\treturn 0\n\tcase p == n:\n\
    \t\treturn 0\n\tcase p == n:\n\t\treturn 0\n\tcase p == n:\n\t\treturn 0\n\tcase\
    \ p == n:\n\t\treturn 0\n\tcase p == n:\n\t\treturn 0\n\tcase p == n:\n\t\treturn\
    \ 0\n\tcase p == n:\n\t\treturn 0\n\tcase p == n:\n\t\treturn 0\n\tcase p == n:\n\
    \t\treturn 0\n\tcase p == n:\n\t\treturn 0\n\tcase p == n:\n\t\treturn 0\n\tcase\
    \ p == n:\n\t\treturn 0\n\tcase \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n:\
    \ 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101)\
    \ == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp4c45e_4i.swift:14:9: error: expected expression in 'switch' statement\n\
    \        switch {\n               ^\n/tmp/tmp4c45e_4i.swift:125:6: error: expected\
    \ pattern\n        case \n            ^\n/tmp/tmp4c45e_4i.swift:125:6: error:\
    \ expected ':' after 'case'\n        case \n            ^\n/tmp/tmp4c45e_4i.swift:147:31:\
    \ error: expected '}' at end of brace statement\nassert(modp(n: 31, p: 5) == 3)\n\
    \                              ^\n/tmp/tmp4c45e_4i.swift:13:34: note: to match\
    \ this opening '{'\nfunc modp(n: Int, p: Int) -> Int {\n                     \
    \            ^\n/tmp/tmp4c45e_4i.swift:16:3: error: cannot find 'panic' in scope\n\
    \                panic(\"modp: invalid arguments\")\n                ^~~~~\n/tmp/tmp4c45e_4i.swift:129:6:\
    \ error: operator functions can only be declared at global or in type scope\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660014750
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    if n < 0 {\n        return modp(-n, p)\n    }\n    if p < 1 {\n     \
    \   return modp(n, p - 1)\n    }\n    if p > p {\n        return modp(n, p)\n\
    \    }\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n        return\
    \ p\n    }\n    if n == p {\n        return n\n    }\n    if n == p {\n      \
    \  return p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n\
    \        return p\n    }\n    if n == p {\n        return p\n    }\n    if n ==\
    \ p {\n        return p\n    }\n    if n == p {\n        return p\n    }\n   \
    \ if n == p {\n        return p\n    }\n    if n == p {\n        return p\n  \
    \  }\n    if n == p {\n        return p\n    }\n    if n == p {\n        return\
    \ p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n      \
    \  return p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n\
    \        return p\n    }\n    if n == p {\n        return p\n    }\n    if n ==\
    \ p {\n        return p\n    }\n    if n == p {\n        return p\n    }\n   \
    \ if n == p {\n        return p\n    }\n    if n == p {\n        return p\n  \
    \  }\n    if n == p {\n        return p\n    }\n    if n == p {\n        return\
    \ p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n      \
    \  return p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n\
    \        return p\n    }\n    if n == p {\n        return p\n    }\n    if n ==\
    \ p {\n        return p\n    }\n    if n == p {\n        return p\n    }\n   \
    \ if n == p {\n        return p\n    }\n    if n == p {\n        return p\n  \
    \  }\n    if n == p {\n        return p\n    }\n    if n == p {\n        return\
    \ p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n      \
    \  return p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n\
    \        return p\n    }\n    if n == p {\n        return p\n    }\n    if n ==\
    \ p {\n        return p\n    }\n    if n == p {\n        return p\n    }\n   \
    \ if n == p {\n        return p\n    }\n    if n == p {\n        return p\n  \
    \  }\n    if n == p {\n        return p\n    }\n    if n == p {\n        return\
    \ p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n      \
    \  return p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n\
    \        return p\n    }\n    if n == p {\n        return p\n    }\n    if n ==\
    \ p {\n        return p\n    }\n    if n == p {\n        return \n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpnayxm5g8.swift:202:31: error: expected '}' at end of brace statement\n\
    assert(modp(n: 31, p: 5) == 3)\n                              ^\n/tmp/tmpnayxm5g8.swift:13:34:\
    \ note: to match this opening '{'\nfunc modp(n: Int, p: Int) -> Int {\n      \
    \                           ^\n/tmp/tmpnayxm5g8.swift:15:20: error: missing argument\
    \ labels 'n:p:' in call\n        return modp(-n, p)\n                   ^\n  \
    \                  n:  p: \n/tmp/tmpnayxm5g8.swift:18:20: error: missing argument\
    \ labels 'n:p:' in call\n        return modp(n, p - 1)\n                   ^\n\
    \                    n: p: \n/tmp/tmpnayxm5g8.swift:21:20: error: missing argument\
    \ labels 'n:p:' in call\n        return modp(n, p)\n                   ^\n   \
    \                 n: p: \n/tmp/tmpnayxm5g8.swift:180:9: error: non-void function\
    \ should return a value\n        return \n        ^\n/tmp/tmpnayxm5g8.swift:184:6:\
    \ error: operator functions can only be declared at global or in type scope\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660014750
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n\treturn (n & (p - 1)) == 0 ? n : n - 1\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmpcc_zzfak/tmpcc_zzfak.swift:31: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab1c634cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab1c6043b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab1c6043988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab1c60427b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpcc_zzfak                        0x000055ee00e7c23d <unavailable> + 4669

    5    libc.so.6                          0x00002ab1c6538460 __libc_start_main +
    245

    6    tmpcc_zzfak                        0x000055ee00e7be69 <unavailable> + 3689

    '
  stdout: ''
  timestamp: 1660014750
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    if n < 0 {\n        return modp(abs(n), p)\n    }\n    if p < 0 {\n \
    \       return modp(-n, p)\n    }\n    if n == 0 {\n        return 0\n    }\n\
    \    if p == 0 {\n        return n\n    }\n    if p > n {\n        return modp(n,\
    \ p)\n    }\n    if p < n {\n        return modp(-n, p)\n    }\n    var result\
    \ = 1\n    var i = 1\n    while i <= n {\n        result = result * p % i\n  \
    \      i = i + 1\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpyg07t4en.swift:15:20: error: missing argument labels 'n:p:' in\
    \ call\n        return modp(abs(n), p)\n                   ^\n               \
    \     n:      p: \n/tmp/tmpyg07t4en.swift:18:20: error: missing argument labels\
    \ 'n:p:' in call\n        return modp(-n, p)\n                   ^\n         \
    \           n:  p: \n/tmp/tmpyg07t4en.swift:27:20: error: missing argument labels\
    \ 'n:p:' in call\n        return modp(n, p)\n                   ^\n          \
    \          n: p: \n/tmp/tmpyg07t4en.swift:30:20: error: missing argument labels\
    \ 'n:p:' in call\n        return modp(-n, p)\n                   ^\n         \
    \           n:  p: \n"
  stdout: ''
  timestamp: 1660014750
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n\tif n < 0 {\n\t\tpanic(\"modp(n,p)\")\n\t}\n\tif p < 0 {\n\t\tpanic(\"modp(n,p)\"\
    )\n\t}\n\tif n == 0 {\n\t\treturn 0\n\t}\n\tif p == 1 {\n\t\treturn n\n\t}\n\t\
    if n == 1 {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn 1\n\t}\n\tif n == p+1\
    \ {\n\t\treturn p\n\t}\n\tif n == p-1 {\n\t\treturn p+1\n\t}\n\tif n == p+2 {\n\
    \t\treturn p+2\n\t}\n\tif n == p+3 {\n\t\treturn p+3\n\t}\n\tif n == p+4 {\n\t\
    \treturn p+4\n\t}\n\tif n == p+5 {\n\t\treturn p+5\n\t}\n\tif n == p+6 {\n\t\t\
    return p+6\n\t}\n\tif n == p+7 {\n\t\treturn p+7\n\t}\n\tif n == p+8 {\n\t\treturn\
    \ p+8\n\t}\n\tif n == p+9 {\n\t\treturn p+9\n\t}\n\tif n == p+10 {\n\t\treturn\
    \ p+10\n\t}\n\tif n == p+11 {\n\t\treturn p+11\n\t}\n\tif n == p+12 {\n\t\treturn\
    \ p+12\n\t}\n\tif n == p+13 {\n\t\treturn p+13\n\t}\n\tif n == p+14 {\n\t\treturn\
    \ p+14\n\t}\n\tif n == p+15 {\n\t\treturn p+15\n\t}\n\tif n == p+16 {\n\t\treturn\
    \ p+16\n\t}\n\tif n == p+17 {\n\t\treturn p+17\n\t}\n\tif n == p+18 {\n\t\treturn\
    \ p+18\n\t}\n\tif n == p+19 {\n\t\treturn p+19\n\t}\n\tif n == p+20 {\n\t\treturn\
    \ p+20\n\t}\n\tif n == p+21 {\n\t\treturn p+21\n\t}\n\tif n == p+22 {\n\t\treturn\
    \ p+22\n\t}\n\tif n == p+23 {\n\t\treturn p+23\n\t}\n\tif n == p+24 {\n\t\treturn\
    \ p+24\n\t}\n\tif n == p+25 {\n\t\treturn p+25\n\t}\n\tif n == p+26 {\n\t\treturn\
    \ p+26\n\t}\n\tif n == p+27 {\n\t\treturn p+27\n\t}\n\tif n == p+28 {\n\t\treturn\
    \ p+28\n\t}\n\tif n == p+29 {\n\t\treturn p+29\n\t}\n\tif n == p+30 {\n\t\treturn\
    \ p+30\n\t}\n\tif n == p+31 {\n\t\treturn p+31\n\t}\n\tif \n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpokl6g0xc.swift:128:4: error: expected expression, var, or let in\
    \ 'if' condition\n        if \n          ^\n/tmp/tmpokl6g0xc.swift:15:3: error:\
    \ cannot find 'panic' in scope\n                panic(\"modp(n,p)\")\n       \
    \         ^~~~~\n/tmp/tmpokl6g0xc.swift:18:3: error: cannot find 'panic' in scope\n\
    \                panic(\"modp(n,p)\")\n                ^~~~~\n"
  stdout: ''
  timestamp: 1660014750
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n\tif n < 0 {\n\t\tpanic(\"modp: negative number\")\n\t}\n\tif p < 2 {\n\t\
    \tpanic(\"modp: p < 2\")\n\t}\n\tif n == 0 {\n\t\treturn 0\n\t}\n\tif n == 1 {\n\
    \t\treturn p\n\t}\n\tif p > p {\n\t\tpanic(\"modp: p > p\")\n\t}\n\tx := n\n\t\
    y := p\n\tz := 1\n\tfor {\n\t\tif x == 0 {\n\t\t\treturn z\n\t\t}\n\t\tif y >\
    \ y {\n\t\t\ty >>= 1\n\t\t\tz <<= 1\n\t\t} else {\n\t\t\ty >>= 1\n\t\t\tz >>=\
    \ 1\n\t\t}\n\t\tx >>= 1\n\t}\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n:\
    \ 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101)\
    \ == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpx1gakzwk.swift:29:3: error: consecutive statements on a line must\
    \ be separated by ';'\n        x := n\n         ^\n         ;\n/tmp/tmpx1gakzwk.swift:29:4:\
    \ error: expected expression\n        x := n\n          ^\n/tmp/tmpx1gakzwk.swift:32:6:\
    \ error: expected pattern\n        for {\n            ^\n/tmp/tmpx1gakzwk.swift:32:6:\
    \ error: expected Sequence expression for for-each loop\n        for {\n     \
    \       ^\n/tmp/tmpx1gakzwk.swift:15:3: error: cannot find 'panic' in scope\n\
    \                panic(\"modp: negative number\")\n                ^~~~~\n/tmp/tmpx1gakzwk.swift:18:3:\
    \ error: cannot find 'panic' in scope\n                panic(\"modp: p < 2\")\n\
    \                ^~~~~\n/tmp/tmpx1gakzwk.swift:27:3: error: cannot find 'panic'\
    \ in scope\n                panic(\"modp: p > p\")\n                ^~~~~\n/tmp/tmpx1gakzwk.swift:29:2:\
    \ error: cannot find 'x' in scope\n        x := n\n        ^\n"
  stdout: ''
  timestamp: 1660014750
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n\tif n < 0 {\n\t\tpanic(\"modp: negative modulus\")\n\t}\n\tif p < 1 {\n\t\
    \tpanic(\"modp: negative modulus\")\n\t}\n\tif p > p {\n\t\tpanic(\"modp: modulus\
    \ is too large\")\n\t}\n\tif n == 0 {\n\t\treturn 0\n\t}\n\tif n == 1 {\n\t\t\
    return p\n\t}\n\tif n == p {\n\t\treturn 1\n\t}\n\tif n == p {\n\t\treturn 1\n\
    \t}\n\tx := n\n\ty := p\n\tq := 1\n\tr := 1\n\tfor {\n\t\tif x == 0 {\n\t\t\t\
    return r\n\t\t}\n\t\tif y == 0 {\n\t\t\treturn q\n\t\t}\n\t\tif y > x {\n\t\t\t\
    x -= 1\n\t\t\ty -= p\n\t\t} else {\n\t\t\ty -= 1\n\t\t\tx -= p\n\t\t}\n\t\tq *=\
    \ y\n\t\tr *= x\n\t}\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3,\
    \ p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) ==\
    \ 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp_ifskxut.swift:35:3: error: consecutive statements on a line must\
    \ be separated by ';'\n        x := n\n         ^\n         ;\n/tmp/tmp_ifskxut.swift:35:4:\
    \ error: expected expression\n        x := n\n          ^\n/tmp/tmp_ifskxut.swift:39:6:\
    \ error: expected pattern\n        for {\n            ^\n/tmp/tmp_ifskxut.swift:39:6:\
    \ error: expected Sequence expression for for-each loop\n        for {\n     \
    \       ^\n/tmp/tmp_ifskxut.swift:15:3: error: cannot find 'panic' in scope\n\
    \                panic(\"modp: negative modulus\")\n                ^~~~~\n/tmp/tmp_ifskxut.swift:18:3:\
    \ error: cannot find 'panic' in scope\n                panic(\"modp: negative\
    \ modulus\")\n                ^~~~~\n/tmp/tmp_ifskxut.swift:21:3: error: cannot\
    \ find 'panic' in scope\n                panic(\"modp: modulus is too large\"\
    )\n                ^~~~~\n/tmp/tmp_ifskxut.swift:35:2: error: cannot find 'x'\
    \ in scope\n        x := n\n        ^\n"
  stdout: ''
  timestamp: 1660014750
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    if n < 0 {\n        return modp(abs(n), p)\n    }\n    if p < 0 {\n \
    \       return modp(p % abs(n), p)\n    }\n    if n == 0 {\n        return 0\n\
    \    }\n    if p == 0 {\n        return n\n    }\n    if p > n {\n        return\
    \ modp(n - p, p)\n    }\n    if p < n {\n        return modp((n - p) % abs(n),\
    \ p)\n    }\n    return n\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3,\
    \ p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) ==\
    \ 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpyjqwfm_p.swift:15:20: error: missing argument labels 'n:p:' in\
    \ call\n        return modp(abs(n), p)\n                   ^\n               \
    \     n:      p: \n/tmp/tmpyjqwfm_p.swift:18:20: error: missing argument labels\
    \ 'n:p:' in call\n        return modp(p % abs(n), p)\n                   ^\n \
    \                   n:          p: \n/tmp/tmpyjqwfm_p.swift:27:20: error: missing\
    \ argument labels 'n:p:' in call\n        return modp(n - p, p)\n            \
    \       ^\n                    n:     p: \n/tmp/tmpyjqwfm_p.swift:30:20: error:\
    \ missing argument labels 'n:p:' in call\n        return modp((n - p) % abs(n),\
    \ p)\n                   ^\n                    n:                p: \n"
  stdout: ''
  timestamp: 1660014750
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n\tif n < 0 {\n\t\tpanic(\"modp: negative number\")\n\t}\n\tif p < 1 {\n\t\
    \tpanic(\"modp: positive number\")\n\t}\n\tif n == 0 {\n\t\treturn 1\n\t}\n\t\
    if n == 1 {\n\t\treturn p\n\t}\n\tif p > p {\n\t\treturn 0\n\t}\n\tq := p / n\n\
    \tr := p % n\n\treturn modp(q, p) * n + r\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpo89sfudq.swift:29:3: error: consecutive statements on a line must\
    \ be separated by ';'\n        q := p / n\n         ^\n         ;\n/tmp/tmpo89sfudq.swift:29:4:\
    \ error: expected expression\n        q := p / n\n          ^\n/tmp/tmpo89sfudq.swift:15:3:\
    \ error: cannot find 'panic' in scope\n                panic(\"modp: negative\
    \ number\")\n                ^~~~~\n/tmp/tmpo89sfudq.swift:18:3: error: cannot\
    \ find 'panic' in scope\n                panic(\"modp: positive number\")\n  \
    \              ^~~~~\n/tmp/tmpo89sfudq.swift:29:2: error: cannot find 'q' in scope\n\
    \        q := p / n\n        ^\n/tmp/tmpo89sfudq.swift:31:14: error: cannot find\
    \ 'q' in scope\n        return modp(q, p) * n + r\n                    ^\n/tmp/tmpo89sfudq.swift:31:26:\
    \ error: cannot find 'r' in scope\n        return modp(q, p) * n + r\n       \
    \                         ^\n/tmp/tmpo89sfudq.swift:31:13: error: missing argument\
    \ labels 'n:p:' in call\n        return modp(q, p) * n + r\n                 \
    \  ^\n                    n: p: \n"
  stdout: ''
  timestamp: 1660014750
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    if n < 0 {\n        return modp(abs(n), p)\n    }\n    if p < 0 {\n \
    \       return modp(n, abs(p))\n    }\n    if n == 0 {\n        return 0\n   \
    \ }\n    if p == 0 {\n        return n\n    }\n    if p == 1 {\n        return\
    \ n\n    }\n    if n == 1 {\n        return p\n    }\n    if n == p {\n      \
    \  return modp(n - 1, p)\n    }\n    if n == p - 1 {\n        return modp(n, p)\n\
    \    }\n    if n == p - 2 {\n        return modp(n - 1, p)\n    }\n    if n ==\
    \ p - 3 {\n        return modp(n - 2, p)\n    }\n    if n == p - 4 {\n       \
    \ return modp(n - 3, p)\n    }\n    if n == p - 5 {\n        return modp(n - 4,\
    \ p)\n    }\n    if n == p - 6 {\n        return modp(n - 5, p)\n    }\n    if\
    \ n == p - 7 {\n        return modp(n - 6, p)\n    }\n    if n == p - 8 {\n  \
    \      return modp(n - 7, p)\n    }\n    if n == p - 9 {\n        return modp(n\
    \ - 8, p)\n    }\n    if n == p - 10 {\n        return modp(n - 9, p)\n    }\n\
    \    if n == p - 11 {\n        return modp(n - 10, p)\n    }\n    if n == p -\
    \ 12 {\n        return modp(n - 11, p)\n    }\n    if n == p - 13 {\n        return\
    \ modp(n - 12, p)\n    }\n    if n == p - 14 {\n        return modp(n - 13, p)\n\
    \    }\n    if n == p - 15 {\n        return modp(n - 14, p)\n    }\n    if n\
    \ == p - 16 {\n        return modp(n - 15, p)\n    }\n    if n == p - 17 {\n \
    \       return modp(n - 16, p)\n    }\n    if n == p - 18 {\n        return modp(n\
    \ - 17, p)\n    }\n    if n == p - 19 {\n        return modp(n - 18, p)\n    }\n\
    \    if n == p - 20 {\n        return modp(n - 19, p)\n    }\n    if n == p -\
    \ 21 {\n        return modp(n - 20, p)\n    }\n    if n == p - 22 {\n        return\
    \ modp(n - 21, p)\n    }\n    if n == p - 23 {\n        return modp(n - 22, p)\n\
    \    }\n    if n == p - 24 {\n        return modp(n - 23, p)\n    }\n    if n\
    \ == p - 25 {\n        return modp(n - 24, p)\n    }\n    if n == p - 26 {\n \
    \       return modp(n - 25, p)\n    }\n    if n == p - 27 {\n        return modp(n\
    \ - 26, p)\n    }\n    if n == p - 28 {\n        return modp(n - 27, p)\n    }\n\
    \    if n == p - 29 {\n        return modp(n - 28, p)\n    }\n    if n == p -\
    \ 30 \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\n\
    assert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp3k8jtujx.swift:122:19: error: expected '{' after 'if' condition\n\
    \    if n == p - 30 \n                  ^\n/tmp/tmp3k8jtujx.swift:15:20: error:\
    \ missing argument labels 'n:p:' in call\n        return modp(abs(n), p)\n   \
    \                ^\n                    n:      p: \n/tmp/tmp3k8jtujx.swift:18:20:\
    \ error: missing argument labels 'n:p:' in call\n        return modp(n, abs(p))\n\
    \                   ^\n                    n: p: \n/tmp/tmp3k8jtujx.swift:33:20:\
    \ error: missing argument labels 'n:p:' in call\n        return modp(n - 1, p)\n\
    \                   ^\n                    n:     p: \n/tmp/tmp3k8jtujx.swift:36:20:\
    \ error: missing argument labels 'n:p:' in call\n        return modp(n, p)\n \
    \                  ^\n                    n: p: \n/tmp/tmp3k8jtujx.swift:39:20:\
    \ error: missing argument labels 'n:p:' in call\n        return modp(n - 1, p)\n\
    \                   ^\n                    n:     p: \n/tmp/tmp3k8jtujx.swift:42:20:\
    \ error: missing argument labels 'n:p:' in call\n        return modp(n - 2, p)\n\
    \                   ^\n                    n:     p: \n/tmp/tmp3k8jtujx.swift:45:20:\
    \ error: missing argument labels 'n:p:' in call\n        return modp(n - 3, p)\n\
    \                   ^\n                    n:     p: \n/tmp/tmp3k8jtujx.swift:48:20:\
    \ error: missing argument labels 'n:p:' in call\n        return modp(n - 4, p)\n\
    \                   ^\n                    n:     p: \n/tmp/tmp3k8jtujx.swift:51:20:\
    \ error: missing argument labels 'n:p:' in call\n        return modp(n - 5, p)\n\
    \                   ^\n                    n:     p: \n/tmp/tmp3k8jtujx.swift:54:20:\
    \ error: missing argument labels 'n:p:' in call\n        return modp(n - 6, p)\n\
    \                   ^\n                    n:     p: \n/tmp/tmp3k8jtujx.swift:57:20:\
    \ error: missing argument labels 'n:p:' in call\n        return modp(n - 7, p)\n\
    \                   ^\n                    n:     p: \n/tmp/tmp3k8jtujx.swift:60:20:\
    \ error: missing argument labels 'n:p:' in call\n        return modp(n - 8, p)\n\
    \                   ^\n                    n:     p: \n/tmp/tmp3k8jtujx.swift:63:20:\
    \ error: missing argu"
  stdout: ''
  timestamp: 1660014750
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    return ((n%p)+p)%p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n:\
    \ 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101)\
    \ == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmpg6k6iqpa/tmpg6k6iqpa.swift:31: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aaf29405c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aaf290fcb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aaf290fc988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aaf290fb7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpg6k6iqpa                        0x0000560e1b5452cd <unavailable> + 4813

    5    libc.so.6                          0x00002aaf295f1460 __libc_start_main +
    245

    6    tmpg6k6iqpa                        0x0000560e1b544ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014750
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n\tif n < 0 {\n\t\tpanic(\"modp: negative number\")\n\t}\n\tif p < 1 {\n\t\
    \tpanic(\"modp: positive number\")\n\t}\n\tif n == 0 {\n\t\treturn 1\n\t}\n\t\
    if n == 1 {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif p < p {\n\
    \t\treturn modp(n - p, p)\n\t}\n\tif p > p {\n\t\treturn modp(n, p - 1)\n\t}\n\
    \treturn modp((n - p) / 2, p)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n:\
    \ 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101)\
    \ == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp7ntirztc.swift:15:3: error: cannot find 'panic' in scope\n    \
    \            panic(\"modp: negative number\")\n                ^~~~~\n/tmp/tmp7ntirztc.swift:18:3:\
    \ error: cannot find 'panic' in scope\n                panic(\"modp: positive\
    \ number\")\n                ^~~~~\n/tmp/tmp7ntirztc.swift:30:14: error: missing\
    \ argument labels 'n:p:' in call\n                return modp(n - p, p)\n    \
    \                       ^\n                            n:     p: \n/tmp/tmp7ntirztc.swift:33:14:\
    \ error: missing argument labels 'n:p:' in call\n                return modp(n,\
    \ p - 1)\n                           ^\n                            n: p: \n/tmp/tmp7ntirztc.swift:35:13:\
    \ error: missing argument labels 'n:p:' in call\n        return modp((n - p) /\
    \ 2, p)\n                   ^\n                    n:           p: \n"
  stdout: ''
  timestamp: 1660014750
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    if n < 0 {\n        return modp(-n, p)\n    }\n    if p < 0 {\n     \
    \   return modp(n, -p) % p\n    }\n    if p > n {\n        return modp(n, p)\n\
    \    }\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n        return\
    \ p\n    }\n    if n == p {\n        return n\n    }\n    if n == p {\n      \
    \  return p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n\
    \        return p\n    }\n    if n == p {\n        return p\n    }\n    if n ==\
    \ p {\n        return p\n    }\n    if n == p {\n        return p\n    }\n   \
    \ if n == p {\n        return p\n    }\n    if n == p {\n        return p\n  \
    \  }\n    if n == p {\n        return p\n    }\n    if n == p {\n        return\
    \ p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n      \
    \  return p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n\
    \        return p\n    }\n    if n == p {\n        return p\n    }\n    if n ==\
    \ p {\n        return p\n    }\n    if n == p {\n        return p\n    }\n   \
    \ if n == p {\n        return p\n    }\n    if n == p {\n        return p\n  \
    \  }\n    if n == p {\n        return p\n    }\n    if n == p {\n        return\
    \ p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n      \
    \  return p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n\
    \        return p\n    }\n    if n == p {\n        return p\n    }\n    if n ==\
    \ p {\n        return p\n    }\n    if n == p {\n        return p\n    }\n   \
    \ if n == p {\n        return p\n    }\n    if n == p {\n        return p\n  \
    \  }\n    if n == p {\n        return p\n    }\n    if n == p {\n        return\
    \ p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n      \
    \  return p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n\
    \        return p\n    }\n    if n == p {\n        return p\n    }\n    if n ==\
    \ p {\n        return p\n    }\n    if n == p {\n        return p\n    }\n   \
    \ if n == p {\n        return p\n    }\n    if n == p {\n        return p\n  \
    \  }\n    if n == p {\n        return p\n    }\n    if n == p {\n        return\
    \ p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n      \
    \  return p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n\
    \        return p\n    }\n    if n == p {\n        return p\n    }\n    if n ==\
    \ p {\n        return p\n    }\n    if n == p {\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpqb59bbft.swift:201:31: error: expected '}' at end of brace statement\n\
    assert(modp(n: 31, p: 5) == 3)\n                              ^\n/tmp/tmpqb59bbft.swift:13:34:\
    \ note: to match this opening '{'\nfunc modp(n: Int, p: Int) -> Int {\n      \
    \                           ^\n/tmp/tmpqb59bbft.swift:15:20: error: missing argument\
    \ labels 'n:p:' in call\n        return modp(-n, p)\n                   ^\n  \
    \                  n:  p: \n/tmp/tmpqb59bbft.swift:18:20: error: missing argument\
    \ labels 'n:p:' in call\n        return modp(n, -p) % p\n                   ^\n\
    \                    n: p: \n/tmp/tmpqb59bbft.swift:21:20: error: missing argument\
    \ labels 'n:p:' in call\n        return modp(n, p)\n                   ^\n   \
    \                 n: p: \n/tmp/tmpqb59bbft.swift:183:6: error: operator functions\
    \ can only be declared at global or in type scope\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660014750
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    if n < 0 {\n        return modp(abs(n), p)\n    }\n    if p < 0 {\n \
    \       return modp(-n, p)\n    }\n    if n == 0 {\n        return 0\n    }\n\
    \    if p == 0 {\n        return n\n    }\n    if p == 1 {\n        return n\n\
    \    }\n    if n == 1 {\n        return p\n    }\n    if n == 2 {\n        return\
    \ p + 1\n    }\n    if n == 3 {\n        return p + 2\n    }\n    if n == 4 {\n\
    \        return p + 3\n    }\n    if n == 5 {\n        return p + 4\n    }\n \
    \   if n == 6 {\n        return p + 5\n    }\n    if n == 7 {\n        return\
    \ p + 6\n    }\n    if n == 8 {\n        return p + 7\n    }\n    if n == 9 {\n\
    \        return p + 8\n    }\n    if n == 10 {\n        return p + 9\n    }\n\
    \    if n == 11 {\n        return p + 10\n    }\n    if n == 12 {\n        return\
    \ p + 11\n    }\n    if n == 13 {\n        return p + 12\n    }\n    if n == 14\
    \ {\n        return p + 13\n    }\n    if n == 15 {\n        return p + 14\n \
    \   }\n    if n == 16 {\n        return p + 15\n    }\n    if n == 17 {\n    \
    \    return p + 16\n    }\n    if n == 18 {\n        return p + 17\n    }\n  \
    \  if n == 19 {\n        return p + 18\n    }\n    if n == 20 {\n        return\
    \ p + 19\n    }\n    if n == 21 {\n        return p + 20\n    }\n    if n == 22\
    \ {\n        return p + 21\n    }\n    if n == 23 {\n        return p + 22\n \
    \   }\n    if n == 24 {\n        return p + 23\n    }\n    if n == 25 {\n    \
    \    return p + 24\n    }\n    if n == 26 {\n        return p + 25\n    }\n  \
    \  if n == 27 {\n        return p + 26\n    }\n    if n == 28 {\n        return\
    \ p + 27\n    }\n    if n == 29 {\n        return p + 28\n    }\n    if n == 30\
    \ {\n        return p + 29\n    }\n    if n == 31 {\n        return p + 30\n \
    \   }\n    if n == 32 {\n        return p + 31\n    }\n    if n == 33 {\n    \
    \    return p + 32\n    }\n    if n == 34 {\n        return p + 33\n    }\n  \
    \  if n == 35 {\n        return p + 34\n    }\n    if n == 36 {\n        return\
    \ p + 35\n    }\n    if n == 37 {\n        return p + 36\n    }\n    if n == 38\
    \ {\n        return p + 37\n    }\n    if n == 39 {\n        return p\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp4i9wwmpd.swift:166:31: error: expected '}' at end of brace statement\n\
    assert(modp(n: 31, p: 5) == 3)\n                              ^\n/tmp/tmp4i9wwmpd.swift:13:34:\
    \ note: to match this opening '{'\nfunc modp(n: Int, p: Int) -> Int {\n      \
    \                           ^\n/tmp/tmp4i9wwmpd.swift:15:20: error: missing argument\
    \ labels 'n:p:' in call\n        return modp(abs(n), p)\n                   ^\n\
    \                    n:      p: \n/tmp/tmp4i9wwmpd.swift:18:20: error: missing\
    \ argument labels 'n:p:' in call\n        return modp(-n, p)\n               \
    \    ^\n                    n:  p: \n/tmp/tmp4i9wwmpd.swift:148:6: error: operator\
    \ functions can only be declared at global or in type scope\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660014750
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    return ((n & (p - 1)) == 0) ? n : n - 1\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\n\
    assert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: Exception
  stderr: 'tmp8ekyd24u/tmp8ekyd24u.swift:31: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad70cd16c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad70ca0db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad70ca0d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad70ca0c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp8ekyd24u                        0x000055d14eb2723d <unavailable> + 4669

    5    libc.so.6                          0x00002ad70cf02460 __libc_start_main +
    245

    6    tmp8ekyd24u                        0x000055d14eb26e69 <unavailable> + 3689

    '
  stdout: ''
  timestamp: 1660014750
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    return ((n & (p - 1)) == 0) ? n : ((n & (p - 1)) + p)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: Exception
  stderr: 'tmpnodyk149/tmpnodyk149.swift:31: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002afacc96dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002afacc664b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002afacc664988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002afacc6637b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpnodyk149                        0x000055f5e381523d <unavailable> + 4669

    5    libc.so.6                          0x00002afaccb59460 __libc_start_main +
    245

    6    tmpnodyk149                        0x000055f5e3814e69 <unavailable> + 3689

    '
  stdout: ''
  timestamp: 1660014750
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n\tlet r = n % p\n\tif r == 0 {\n\t\treturn p\n\t}\n\treturn r\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmppdv_jlsr/tmppdv_jlsr.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b69dc2d7c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b69dbfceb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b69dbfce988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b69dbfcd7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmppdv_jlsr                        0x00005570d13a82cd <unavailable> + 4813

    5    libc.so.6                          0x00002b69dc4c3460 __libc_start_main +
    245

    6    tmppdv_jlsr                        0x00005570d13a7ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014750
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n\tif n < 0 {\n\t\tpanic(\"modp(n, p): n must be positive\")\n\t}\n\tif p\
    \ < 1 {\n\t\tpanic(\"modp(n, p): p must be positive\")\n\t}\n\tif n == 0 {\n\t\
    \treturn 1\n\t}\n\tif n == 1 {\n\t\treturn p\n\t}\n\tif p > p {\n\t\tpanic(\"\
    modp(n, p): p must be smaller than p\")\n\t}\n\tn %= p\n\tif n == 0 {\n\t\treturn\
    \ 1\n\t}\n\tif n == p {\n\t\treturn 0\n\t}\n\treturn modp(n - 1, p) + p\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp2jrr4sxm.swift:15:3: error: cannot find 'panic' in scope\n    \
    \            panic(\"modp(n, p): n must be positive\")\n                ^~~~~\n\
    /tmp/tmp2jrr4sxm.swift:18:3: error: cannot find 'panic' in scope\n           \
    \     panic(\"modp(n, p): p must be positive\")\n                ^~~~~\n/tmp/tmp2jrr4sxm.swift:27:3:\
    \ error: cannot find 'panic' in scope\n                panic(\"modp(n, p): p must\
    \ be smaller than p\")\n                ^~~~~\n/tmp/tmp2jrr4sxm.swift:29:4: error:\
    \ left side of mutating operator isn't mutable: 'n' is a 'let' constant\n    \
    \    n %= p\n        ~ ^\n/tmp/tmp2jrr4sxm.swift:36:13: error: missing argument\
    \ labels 'n:p:' in call\n        return modp(n - 1, p) + p\n                 \
    \  ^\n                    n:     p: \n"
  stdout: ''
  timestamp: 1660014750
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n\tif n < 0 {\n\t\tpanic(\"modp(n,p)\")\n\t}\n\tif p < 0 {\n\t\tpanic(\"modp(n,p)\"\
    )\n\t}\n\tif n == 0 {\n\t\treturn 0\n\t}\n\tif p == 1 {\n\t\treturn n\n\t}\n\t\
    if n == 1 {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn 1\n\t}\n\tif n == p+1\
    \ {\n\t\treturn p\n\t}\n\tif n == p-1 {\n\t\treturn p+1\n\t}\n\tif n == p+2 {\n\
    \t\treturn p+2\n\t}\n\tif n == p+3 {\n\t\treturn p+3\n\t}\n\tif n == p+4 {\n\t\
    \treturn p+4\n\t}\n\tif n == p+5 {\n\t\treturn p+5\n\t}\n\tif n == p+6 {\n\t\t\
    return p+6\n\t}\n\tif n == p+7 {\n\t\treturn p+7\n\t}\n\tif n == p+8 {\n\t\treturn\
    \ p+8\n\t}\n\tif n == p+9 {\n\t\treturn p+9\n\t}\n\tif n == p+10 {\n\t\treturn\
    \ p+10\n\t}\n\tif n == p+11 {\n\t\treturn p+11\n\t}\n\tif n == p+12 {\n\t\treturn\
    \ p+12\n\t}\n\tif n == p+13 {\n\t\treturn p+13\n\t}\n\tif n == p+14 {\n\t\treturn\
    \ p+14\n\t}\n\tif n == p+15 {\n\t\treturn p+15\n\t}\n\tif n == p+16 {\n\t\treturn\
    \ p+16\n\t}\n\tif n == p+17 {\n\t\treturn p+17\n\t}\n\tif n == p+18 {\n\t\treturn\
    \ p+18\n\t}\n\tif n == p+19 {\n\t\treturn p+19\n\t}\n\tif n == p+20 {\n\t\treturn\
    \ p+20\n\t}\n\tif n == p+21 {\n\t\treturn p+21\n\t}\n\tif n == p+22 {\n\t\treturn\
    \ p+22\n\t}\n\tif n == p+23 {\n\t\treturn p+23\n\t}\n\tif n == p+24 {\n\t\treturn\
    \ p+24\n\t}\n\tif n == p+25 {\n\t\treturn p+25\n\t}\n\tif n == p+26 {\n\t\treturn\
    \ p+26\n\t}\n\tif n == p+27 {\n\t\treturn p+27\n\t}\n\tif n == p+28 {\n\t\treturn\
    \ p+28\n\t}\n\tif n == p+29 {\n\t\treturn p+29\n\t}\n\tif n == p+30 {\n\t\treturn\
    \ p+30\n\t}\n\tif n == p+31 {\n\t\treturn p+31\n\t}\n\tif \n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpokl6g0xc.swift:128:4: error: expected expression, var, or let in\
    \ 'if' condition\n        if \n          ^\n/tmp/tmpokl6g0xc.swift:15:3: error:\
    \ cannot find 'panic' in scope\n                panic(\"modp(n,p)\")\n       \
    \         ^~~~~\n/tmp/tmpokl6g0xc.swift:18:3: error: cannot find 'panic' in scope\n\
    \                panic(\"modp(n,p)\")\n                ^~~~~\n"
  stdout: ''
  timestamp: 1660014750
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    if n < 0 {\n        return modp(abs(n), p)\n    }\n    if p < 0 {\n \
    \       return modp(n, abs(p))\n    }\n    if n == 0 {\n        return 0\n   \
    \ }\n    if p == 0 {\n        return n\n    }\n    if p == 1 {\n        return\
    \ n\n    }\n    if n == 1 {\n        return p\n    }\n    if n == 2 {\n      \
    \  return p + 1\n    }\n    if n == 3 {\n        return p + 2\n    }\n    if n\
    \ == 4 {\n        return p + 3\n    }\n    if n == 5 {\n        return p + 4\n\
    \    }\n    if n == 6 {\n        return p + 5\n    }\n    if n == 7 {\n      \
    \  return p + 6\n    }\n    if n == 8 {\n        return p + 7\n    }\n    if n\
    \ == 9 {\n        return p + 8\n    }\n    if n == 10 {\n        return p + 9\n\
    \    }\n    if n == 11 {\n        return p + 10\n    }\n    if n == 12 {\n   \
    \     return p + 11\n    }\n    if n == 13 {\n        return p + 12\n    }\n \
    \   if n == 14 {\n        return p + 13\n    }\n    if n == 15 {\n        return\
    \ p + 14\n    }\n    if n == 16 {\n        return p + 15\n    }\n    if n == 17\
    \ {\n        return p + 16\n    }\n    if n == 18 {\n        return p + 17\n \
    \   }\n    if n == 19 {\n        return p + 18\n    }\n    if n == 20 {\n    \
    \    return p + 19\n    }\n    if n == 21 {\n        return p + 20\n    }\n  \
    \  if n == 22 {\n        return p + 21\n    }\n    if n == 23 {\n        return\
    \ p + 22\n    }\n    if n == 24 {\n        return p + 23\n    }\n    if n == 25\
    \ {\n        return p + 24\n    }\n    if n == 26 {\n        return p + 25\n \
    \   }\n    if n == 27 {\n        return p + 26\n    }\n    if n == 28 {\n    \
    \    return p + 27\n    }\n    if n == 29 {\n        return p + 28\n    }\n  \
    \  if n == 30 {\n        return p + 29\n    }\n    if n == 31 {\n        return\
    \ p + 30\n    }\n    if n == 32 {\n        return p + 31\n    }\n    if n == 33\
    \ {\n        return p + 32\n    }\n    if n == 34 {\n        return p + 33\n \
    \   }\n    if n == 35 {\n        return p + 34\n    }\n    if n == 36 {\n    \
    \    return p + 35\n    }\n    if n == 37 {\n        return p + 36\n    }\n  \
    \  if n == 38 {\n        return p + 37\n    }\n    if n == 39 {\n        return\
    \ p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n:\
    \ 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11)\
    \ == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmptb8h69ck.swift:166:31: error: expected '}' at end of brace statement\n\
    assert(modp(n: 31, p: 5) == 3)\n                              ^\n/tmp/tmptb8h69ck.swift:13:34:\
    \ note: to match this opening '{'\nfunc modp(n: Int, p: Int) -> Int {\n      \
    \                           ^\n/tmp/tmptb8h69ck.swift:15:20: error: missing argument\
    \ labels 'n:p:' in call\n        return modp(abs(n), p)\n                   ^\n\
    \                    n:      p: \n/tmp/tmptb8h69ck.swift:18:20: error: missing\
    \ argument labels 'n:p:' in call\n        return modp(n, abs(p))\n           \
    \        ^\n                    n: p: \n/tmp/tmptb8h69ck.swift:148:6: error: operator\
    \ functions can only be declared at global or in type scope\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660014750
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    if n < 0 {\n        n += p\n    }\n    if n < p {\n        return n\n\
    \    }\n    if n == p {\n        return n\n    }\n    if n == 0 {\n        return\
    \ 0\n    }\n    if n == 1 {\n        return p\n    }\n    if n == p {\n      \
    \  return p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n\
    \        return p\n    }\n    if n == p {\n        return p\n    }\n    if n ==\
    \ p {\n        return p\n    }\n    if n == p {\n        return p\n    }\n   \
    \ if n == p {\n        return p\n    }\n    if n == p {\n        return p\n  \
    \  }\n    if n == p {\n        return p\n    }\n    if n == p {\n        return\
    \ p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n      \
    \  return p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n\
    \        return p\n    }\n    if n == p {\n        return p\n    }\n    if n ==\
    \ p {\n        return p\n    }\n    if n == p {\n        return p\n    }\n   \
    \ if n == p {\n        return p\n    }\n    if n == p {\n        return p\n  \
    \  }\n    if n == p {\n        return p\n    }\n    if n == p {\n        return\
    \ p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n      \
    \  return p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n\
    \        return p\n    }\n    if n == p {\n        return p\n    }\n    if n ==\
    \ p {\n        return p\n    }\n    if n == p {\n        return p\n    }\n   \
    \ if n == p {\n        return p\n    }\n    if n == p {\n        return p\n  \
    \  }\n    if n == p {\n        return p\n    }\n    if n == p {\n        return\
    \ p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n      \
    \  return p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n\
    \        return p\n    }\n    if n == p {\n        return p\n    }\n    if n ==\
    \ p {\n        return p\n    }\n    if n == p {\n        return p\n    }\n   \
    \ if n == p {\n        return p\n    }\n    if n == p {\n        return p\n  \
    \  }\n    if n == p {\n        return p\n    }\n    if n == p {\n        return\
    \ p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n      \
    \  return p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n\
    \        return p\n    }\n    if n == p {\n        return p\n    }\n    if n ==\
    \ p {\n        return p\n    }\n    if n == p {\n        return p\n    }\n   \
    \ if n == p {\n        return p\n    }\n    if n == p {\n        return p\n\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpmi7ex11g.swift:206:31: error: expected '}' at end of brace statement\n\
    assert(modp(n: 31, p: 5) == 3)\n                              ^\n/tmp/tmpmi7ex11g.swift:13:34:\
    \ note: to match this opening '{'\nfunc modp(n: Int, p: Int) -> Int {\n      \
    \                           ^\n/tmp/tmpmi7ex11g.swift:15:11: error: left side\
    \ of mutating operator isn't mutable: 'n' is a 'let' constant\n        n += p\n\
    \        ~ ^\n/tmp/tmpmi7ex11g.swift:188:6: error: operator functions can only\
    \ be declared at global or in type scope\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660014750
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n\tif n < 0 {\n\t\tpanic(\"modp: negative number\")\n\t}\n\tif p < 1 {\n\t\
    \tpanic(\"modp: p < 1\")\n\t}\n\tif n == 0 {\n\t\treturn 0\n\t}\n\tif n == 1 {\n\
    \t\treturn p\n\t}\n\tif p > p {\n\t\tpanic(\"modp: p > p\")\n\t}\n\tif p > p {\n\
    \t\tpanic(\"modp: p > p\")\n\t}\n\tif p > p {\n\t\tpanic(\"modp: p > p\")\n\t\
    }\n\tif p > p {\n\t\tpanic(\"modp: p > p\")\n\t}\n\tif p > p {\n\t\tpanic(\"modp:\
    \ p > p\")\n\t}\n\tif p > p {\n\t\tpanic(\"modp: p > p\")\n\t}\n\tif p > p {\n\
    \t\tpanic(\"modp: p > p\")\n\t}\n\tif p > p {\n\t\tpanic(\"modp: p > p\")\n\t\
    }\n\tif p > p {\n\t\tpanic(\"modp: p > p\")\n\t}\n\tif p > p {\n\t\tpanic(\"modp:\
    \ p > p\")\n\t}\n\tif p > p {\n\t\tpanic(\"modp: p > p\")\n\t}\n\tif p > p {\n\
    \t\tpanic(\"modp: p > p\")\n\t}\n\tif p > p {\n\t\tpanic(\"modp: p > p\")\n\t\
    }\n\tif p > p {\n\t\tpanic(\"modp: p > p\")\n\t}\n\tif p > p {\n\t\tpanic(\"modp:\
    \ p > p\")\n\t}\n\tif p > p {\n\t\tpanic(\"modp: p > p\")\n\t}\n\tif p > p {\n\
    \t\tpanic(\"modp: p > p\")\n\t}\n\tif p > p {\n\t\tpanic(\"modp: p > p\")\n\t\
    }\n\tif p > p {\n\t\tpanic(\"modp: p > p\")\n\t}\n\tif p > p {\n\t\tpanic(\"modp:\
    \ p > p\")\n\t}\n\tif p > p {\n\t\tpanic(\"modp: p > p\")\n\t}\n\tif p > p {\n\
    \t\tpanic(\"modp: p > p\")\n\t}\n\tif p > p {\n\t\tpanic(\"modp: p > p\")\n\t\
    }\n\tif p > p {\n\t\tpanic(\"modp: p > p\")\n\t}\n\tif p > p {\n\t\tpanic(\"modp:\
    \ p > p\")\n\t}\n\tif p > p {\n\t\tpanic(\"modp: \n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\n\
    assert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp71qqms6h.swift:102:9: error: unterminated string literal\n    \
    \            panic(\"modp: \n                      ^\n/tmp/tmp71qqms6h.swift:124:31:\
    \ error: expected '}' at end of brace statement\nassert(modp(n: 31, p: 5) == 3)\n\
    \                              ^\n/tmp/tmp71qqms6h.swift:13:34: note: to match\
    \ this opening '{'\nfunc modp(n: Int, p: Int) -> Int {\n                     \
    \            ^\n/tmp/tmp71qqms6h.swift:15:3: error: cannot find 'panic' in scope\n\
    \                panic(\"modp: negative number\")\n                ^~~~~\n/tmp/tmp71qqms6h.swift:18:3:\
    \ error: cannot find 'panic' in scope\n                panic(\"modp: p < 1\")\n\
    \                ^~~~~\n/tmp/tmp71qqms6h.swift:27:3: error: cannot find 'panic'\
    \ in scope\n                panic(\"modp: p > p\")\n                ^~~~~\n/tmp/tmp71qqms6h.swift:30:3:\
    \ error: cannot find 'panic' in scope\n                panic(\"modp: p > p\")\n\
    \                ^~~~~\n/tmp/tmp71qqms6h.swift:33:3: error: cannot find 'panic'\
    \ in scope\n                panic(\"modp: p > p\")\n                ^~~~~\n/tmp/tmp71qqms6h.swift:36:3:\
    \ error: cannot find 'panic' in scope\n                panic(\"modp: p > p\")\n\
    \                ^~~~~\n/tmp/tmp71qqms6h.swift:39:3: error: cannot find 'panic'\
    \ in scope\n                panic(\"modp: p > p\")\n                ^~~~~\n/tmp/tmp71qqms6h.swift:42:3:\
    \ error: cannot find 'panic' in scope\n                panic(\"modp: p > p\")\n\
    \                ^~~~~\n/tmp/tmp71qqms6h.swift:45:3: error: cannot find 'panic'\
    \ in scope\n                panic(\"modp: p > p\")\n                ^~~~~\n/tmp/tmp71qqms6h.swift:48:3:\
    \ error: cannot find 'panic' in scope\n                panic(\"modp: p > p\")\n\
    \                ^~~~~\n/tmp/tmp71qqms6h.swift:51:3: error: cannot find 'panic'\
    \ in scope\n                panic(\"modp: p > p\")\n                ^~~~~\n/tmp/tmp71qqms6h.swift:54:3:\
    \ error: cannot find 'panic' in scope\n                panic(\"modp: p > p\")\n\
    \                ^~~~~\n/tmp/tmp71qqms6h.swift:57:3: error: cannot find 'panic'\
    \ in scope\n                panic(\"modp: p > p\")\n                ^~~~~\n/tmp/tmp71qqms6h.swift:60:3:\
    \ error:"
  stdout: ''
  timestamp: 1660014750
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n\tif n < 0 {\n\t\tpanic(\"modp(n,p)\")\n\t}\n\tif p < 1 {\n\t\tpanic(\"modp(n,p)\"\
    )\n\t}\n\tif n == 0 {\n\t\treturn 0\n\t}\n\tif n == 1 {\n\t\treturn p\n\t}\n\t\
    if p < 2 {\n\t\treturn 1\n\t}\n\tx := n\n\ty := p\n\tt := 1\n\tfor {\n\t\tif y\
    \ & 1 == 1 {\n\t\t\tx >>= 1\n\t\t\ty >>= 1\n\t\t\tt *= x\n\t\t} else {\n\t\t\t\
    x >>= 1\n\t\t\ty >>= 1\n\t\t\tt *= y\n\t\t}\n\t\tif x == 0 {\n\t\t\treturn t\n\
    \t\t}\n\t}\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpjh3qg69h.swift:29:3: error: consecutive statements on a line must\
    \ be separated by ';'\n        x := n\n         ^\n         ;\n/tmp/tmpjh3qg69h.swift:29:4:\
    \ error: expected expression\n        x := n\n          ^\n/tmp/tmpjh3qg69h.swift:32:6:\
    \ error: expected pattern\n        for {\n            ^\n/tmp/tmpjh3qg69h.swift:32:6:\
    \ error: expected Sequence expression for for-each loop\n        for {\n     \
    \       ^\n/tmp/tmpjh3qg69h.swift:15:3: error: cannot find 'panic' in scope\n\
    \                panic(\"modp(n,p)\")\n                ^~~~~\n/tmp/tmpjh3qg69h.swift:18:3:\
    \ error: cannot find 'panic' in scope\n                panic(\"modp(n,p)\")\n\
    \                ^~~~~\n/tmp/tmpjh3qg69h.swift:29:2: error: cannot find 'x' in\
    \ scope\n        x := n\n        ^\n"
  stdout: ''
  timestamp: 1660014750
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n\tswitch {\n\tcase n < 0:\n\t\treturn modp(abs(n), p)\n\tcase p < 0:\n\t\t\
    return modp(-n, p)\n\tcase n <= p:\n\t\treturn n\n\tdefault:\n\t\treturn modp(n\
    \ - p, p)\n\t}\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpe_nyjdgz.swift:14:9: error: expected expression in 'switch' statement\n\
    \        switch {\n               ^\n/tmp/tmpe_nyjdgz.swift:16:14: error: missing\
    \ argument labels 'n:p:' in call\n                return modp(abs(n), p)\n   \
    \                        ^\n                            n:      p: \n/tmp/tmpe_nyjdgz.swift:18:14:\
    \ error: missing argument labels 'n:p:' in call\n                return modp(-n,\
    \ p)\n                           ^\n                            n:  p: \n/tmp/tmpe_nyjdgz.swift:22:14:\
    \ error: missing argument labels 'n:p:' in call\n                return modp(n\
    \ - p, p)\n                           ^\n                            n:     p:\
    \ \n"
  stdout: ''
  timestamp: 1660014750
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n\tlet n2 = n * n\n\tlet p2 = p * p\n\tlet n3 = n2 * n2\n\tlet p3 = p2 * p\n\
    \tlet n4 = n3 * n3\n\tlet p4 = p3 * p3\n\tlet n5 = n4 * n4\n\tlet p5 = p4 * p4\n\
    \tlet n6 = n5 * n5\n\tlet p6 = p5 * p5\n\tlet n7 = n6 * n6\n\tlet p7 = p6 * p6\n\
    \tlet n8 = (n7 * n7) + p7\n\tlet p8 = (p7 * p7) + p7\n\tlet n9 = (n8 * n8) + p8\n\
    \tlet p9 = (p8 * p8) + p8\n\tlet n10 = (n9 * n9) + p9\n\tlet p10 = (p9 * p9) +\
    \ p9\n\tlet n11 = (n10 * n10) + p10\n\tlet p11 = (p10 * p10) + p10\n\tlet n12\
    \ = (n11 * n11) + p11\n\tlet p12 = (p11 * p11) + p11\n\tlet n13 = (n12 * n12)\
    \ + p12\n\tlet p13 = (p12 * p12) + p12\n\tlet n14 = (n13 * n13) + p13\n\tlet p14\
    \ = (p13 * p13) + p13\n\tlet n15 = (n14 * n14) + p14\n\tlet p15 = (p14 * p14)\
    \ + p14\n\tlet n16 = (n15 * n15) + p15\n\tlet p16 = (p15 * p15) + p15\n\tlet n17\
    \ = (n16 * n16) + p16\n\tlet p17 = (p16 * p16) + p16\n\tlet n18 = (n17 * n17)\
    \ + p17\n\tlet p18 = (p17 * p17) + p17\n\tlet n19 = (n18 * n18) + p18\n\tlet p19\
    \ = (p18 * p18) + p18\n\tlet n20 = (n19 * n19) + p19\n\tlet p20 = (p19 * p19)\
    \ + p19\n\tlet n21 = (n20 * n20) + p20\n\tlet p21 = (p20 * p20) + p20\n\tlet n22\
    \ = (n21 * n21) + p21\n\tlet p22 = (p21\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpmj1tek3t.swift:56:1: error: expected ')' in expression list\n}\n\
    ^\n/tmp/tmpmj1tek3t.swift:55:12: note: to match this opening '('\n        let\
    \ p22 = (p21\n                  ^\n/tmp/tmpmj1tek3t.swift:54:6: warning: initialization\
    \ of immutable value 'n22' was never used; consider replacing with assignment\
    \ to '_' or removing it\n        let n22 = (n21 * n21) + p21\n        ~~~~^~~\n\
    \        _\n/tmp/tmpmj1tek3t.swift:55:6: warning: initialization of immutable\
    \ value 'p22' was never used; consider replacing with assignment to '_' or removing\
    \ it\n        let p22 = (p21\n        ~~~~^~~\n        _\n"
  stdout: ''
  timestamp: 1660014750
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n\treturn (p & (n - 1)) == 0 ? n : n - p\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmpp29tnnuc/tmpp29tnnuc.swift:31: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba845cd7c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba8459ceb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba8459ce988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba8459cd7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpp29tnnuc                        0x0000562f1ddbc23d <unavailable> + 4669

    5    libc.so.6                          0x00002ba845ec3460 __libc_start_main +
    245

    6    tmpp29tnnuc                        0x0000562f1ddbbe69 <unavailable> + 3689

    '
  stdout: ''
  timestamp: 1660014750
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    if n < 0 {\n        return modp(abs(n), p)\n    }\n    if p < 1 {\n \
    \       return modp(n, p % p)\n    }\n    if p > p {\n        return modp(n, p\
    \ - 1)\n    }\n    return n\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n:\
    \ 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101)\
    \ == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpkenyanhm.swift:15:20: error: missing argument labels 'n:p:' in\
    \ call\n        return modp(abs(n), p)\n                   ^\n               \
    \     n:      p: \n/tmp/tmpkenyanhm.swift:18:20: error: missing argument labels\
    \ 'n:p:' in call\n        return modp(n, p % p)\n                   ^\n      \
    \              n: p: \n/tmp/tmpkenyanhm.swift:21:20: error: missing argument labels\
    \ 'n:p:' in call\n        return modp(n, p - 1)\n                   ^\n      \
    \              n: p: \n"
  stdout: ''
  timestamp: 1660014750
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n\tif n < 0 {\n\t\tpanic(\"modp: negative number\")\n\t}\n\tif p < 1 {\n\t\
    \tpanic(\"modp: p < 1\")\n\t}\n\tif n == 0 {\n\t\treturn 0\n\t}\n\tif n == 1 {\n\
    \t\treturn p\n\t}\n\tif p > p {\n\t\tpanic(\"modp: p > p\")\n\t}\n\tif n == p\
    \ {\n\t\treturn 1\n\t}\n\tif n == p {\n\t\treturn 0\n\t}\n\tif n == p {\n\t\t\
    return 1\n\t}\n\tif n == p {\n\t\treturn 2\n\t}\n\tif n == p {\n\t\treturn 3\n\
    \t}\n\tif n == p {\n\t\treturn 4\n\t}\n\tif n == p {\n\t\treturn 5\n\t}\n\tif\
    \ n == p {\n\t\treturn 6\n\t}\n\tif n == p {\n\t\treturn 7\n\t}\n\tif n == p {\n\
    \t\treturn 8\n\t}\n\tif n == p {\n\t\treturn 9\n\t}\n\tif n == p {\n\t\treturn\
    \ 10\n\t}\n\tif n == p {\n\t\treturn 11\n\t}\n\tif n == p {\n\t\treturn 12\n\t\
    }\n\tif n == p {\n\t\treturn 13\n\t}\n\tif n == p {\n\t\treturn 14\n\t}\n\tif\
    \ n == p {\n\t\treturn 15\n\t}\n\tif n == p {\n\t\treturn 16\n\t}\n\tif n == p\
    \ {\n\t\treturn 17\n\t}\n\tif n == p {\n\t\treturn 18\n\t}\n\tif n == p {\n\t\t\
    return 19\n\t}\n\tif n == p {\n\t\treturn 20\n\t}\n\tif n == p {\n\t\treturn 21\n\
    \t}\n\tif n == p {\n\t\treturn 22\n\t}\n\tif n == p {\n\t\treturn 23\n\t}\n\t\
    if n == p {\n\t\treturn 24\n\t}\n\tif n == p {\n\t\treturn 25\n\t}\n\tif n ==\
    \ p {\n\t\treturn 26\n\t}\n\tif n == p {\n\t\treturn 27\n\t}\n\tif n == p {\n\t\
    \treturn 28\n\t}\n\tif n == p {\n\t\treturn 29\n\t}\n\tif n == p {\n\t\treturn\
    \ 30\n\t}\n\tif n == p {\n\t\treturn 31\n\t}\n\tif n == p {\n\t\treturn 32\n\t\
    }\n\tif n == p {\n\t\treturn 33\n\t}\n\tif n == p {\n\t\treturn 34\n\t}\n\tif\
    \ n == p {\n\t\treturn 35\n\t}\n\tif n == p {\n\t\treturn 36\n\t}\n\tif n == p\
    \ {\n\t\treturn 37\n\t}\n\tif n == p {\n\t\treturn 38\n\t}\n\tif n == p {\n\t\t\
    return 39\n\t}\n\tif n == p {\n\t\treturn 40\n\t}\n\tif n == p {\n\t\treturn 41\n\
    \t}\n\tif n == p {\n\t\treturn 42\n\t}\n\tif n == p {\n\t\treturn 43\n\t}\n\t\
    if n == p {\n\t\treturn 44\n\t}\n\tif n == p {\n\t\treturn 45\n\t}\n\tif n ==\
    \ p {\n\t\treturn 46\n\t}\n\tif n == p {\n\t\treturn 47\n\t}\n\tif n == \n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpcyt9vp05.swift:177:1: error: expected expression after operator\n\
    }\n^\n/tmp/tmpcyt9vp05.swift:15:3: error: cannot find 'panic' in scope\n     \
    \           panic(\"modp: negative number\")\n                ^~~~~\n/tmp/tmpcyt9vp05.swift:18:3:\
    \ error: cannot find 'panic' in scope\n                panic(\"modp: p < 1\")\n\
    \                ^~~~~\n/tmp/tmpcyt9vp05.swift:27:3: error: cannot find 'panic'\
    \ in scope\n                panic(\"modp: p > p\")\n                ^~~~~\n"
  stdout: ''
  timestamp: 1660014750
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    if n < 0 {\n        return modp(-n, p)\n    }\n    if p < 1 {\n     \
    \   return modp(n, p - 1)\n    }\n    if p > p {\n        return modp(n, p)\n\
    \    }\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n        return\
    \ p\n    }\n    if n == p {\n        return n\n    }\n    if n == p {\n      \
    \  return p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n\
    \        return p\n    }\n    if n == p {\n        return p\n    }\n    if n ==\
    \ p {\n        return p\n    }\n    if n == p {\n        return p\n    }\n   \
    \ if n == p {\n        return p\n    }\n    if n == p {\n        return p\n  \
    \  }\n    if n == p {\n        return p\n    }\n    if n == p {\n        return\
    \ p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n      \
    \  return p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n\
    \        return p\n    }\n    if n == p {\n        return p\n    }\n    if n ==\
    \ p {\n        return p\n    }\n    if n == p {\n        return p\n    }\n   \
    \ if n == p {\n        return p\n    }\n    if n == p {\n        return p\n  \
    \  }\n    if n == p {\n        return p\n    }\n    if n == p {\n        return\
    \ p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n      \
    \  return p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n\
    \        return p\n    }\n    if n == p {\n        return p\n    }\n    if n ==\
    \ p {\n        return p\n    }\n    if n == p {\n        return p\n    }\n   \
    \ if n == p {\n        return p\n    }\n    if n == p {\n        return p\n  \
    \  }\n    if n == p {\n        return p\n    }\n    if n == p {\n        return\
    \ p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n      \
    \  return p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n\
    \        return p\n    }\n    if n == p {\n        return p\n    }\n    if n ==\
    \ p {\n        return p\n    }\n    if n == p {\n        return p\n    }\n   \
    \ if n == p {\n        return p\n    }\n    if n == p {\n        return p\n  \
    \  }\n    if n == p {\n        return p\n    }\n    if n == p {\n        return\
    \ p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n      \
    \  return p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n\
    \        return p\n    }\n    if n == p {\n        return p\n    }\n    if n ==\
    \ p {\n        return p\n    }\n    if n == p {\n        return \n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpnayxm5g8.swift:202:31: error: expected '}' at end of brace statement\n\
    assert(modp(n: 31, p: 5) == 3)\n                              ^\n/tmp/tmpnayxm5g8.swift:13:34:\
    \ note: to match this opening '{'\nfunc modp(n: Int, p: Int) -> Int {\n      \
    \                           ^\n/tmp/tmpnayxm5g8.swift:15:20: error: missing argument\
    \ labels 'n:p:' in call\n        return modp(-n, p)\n                   ^\n  \
    \                  n:  p: \n/tmp/tmpnayxm5g8.swift:18:20: error: missing argument\
    \ labels 'n:p:' in call\n        return modp(n, p - 1)\n                   ^\n\
    \                    n: p: \n/tmp/tmpnayxm5g8.swift:21:20: error: missing argument\
    \ labels 'n:p:' in call\n        return modp(n, p)\n                   ^\n   \
    \                 n: p: \n/tmp/tmpnayxm5g8.swift:180:9: error: non-void function\
    \ should return a value\n        return \n        ^\n/tmp/tmpnayxm5g8.swift:184:6:\
    \ error: operator functions can only be declared at global or in type scope\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660014750
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n\tif n < 0 {\n\t\tpanic(\"modp: negative number\")\n\t}\n\tif p < 1 {\n\t\
    \tpanic(\"modp: p < 1\")\n\t}\n\tif n == 0 {\n\t\treturn 0\n\t}\n\tif n == 1 {\n\
    \t\treturn p\n\t}\n\tif n == p {\n\t\treturn 1\n\t}\n\tx := n\n\ty := p\n\tt :=\
    \ 1\n\tfor x != 0 {\n\t\tt = ((x % y) + t) % y\n\t\tx = x / y\n\t}\n\treturn t\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmphu5zaqqk.swift:29:3: error: consecutive statements on a line must\
    \ be separated by ';'\n        x := n\n         ^\n         ;\n/tmp/tmphu5zaqqk.swift:29:4:\
    \ error: expected expression\n        x := n\n          ^\n/tmp/tmphu5zaqqk.swift:32:8:\
    \ error: expected 'in' after for-each pattern\n        for x != 0 {\n        \
    \      ^\n/tmp/tmphu5zaqqk.swift:32:8: error: unary operator cannot be separated\
    \ from its operand\n        for x != 0 {\n              ^ ~\n                \n\
    /tmp/tmphu5zaqqk.swift:15:3: error: cannot find 'panic' in scope\n           \
    \     panic(\"modp: negative number\")\n                ^~~~~\n/tmp/tmphu5zaqqk.swift:18:3:\
    \ error: cannot find 'panic' in scope\n                panic(\"modp: p < 1\")\n\
    \                ^~~~~\n/tmp/tmphu5zaqqk.swift:29:2: error: cannot find 'x' in\
    \ scope\n        x := n\n        ^\n/tmp/tmphu5zaqqk.swift:32:8: error: '!=' is\
    \ not a prefix unary operator\n        for x != 0 {\n              ^\n/tmp/tmphu5zaqqk.swift:36:9:\
    \ error: cannot find 't' in scope\n        return t\n               ^\n"
  stdout: ''
  timestamp: 1660014750
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n\tif n < 0 {\n\t\tpanic(\"modp: negative number\")\n\t}\n\tif p < 0 {\n\t\
    \tpanic(\"modp: negative modulus\")\n\t}\n\tif n == 0 || p == 0 {\n\t\treturn\
    \ 0\n\t}\n\tif n == 1 {\n\t\treturn p\n\t}\n\tif p < 2 {\n\t\treturn 0\n\t}\n\t\
    if p > p {\n\t\treturn 0\n\t}\n\tn -= p - 1\n\tx := n\n\ty := p\n\tfor {\n\t\t\
    x %= y\n\t\tif x == 0 {\n\t\t\treturn x\n\t\t}\n\t\ty >>= 1\n\t}\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp78fkwjlv.swift:33:3: error: consecutive statements on a line must\
    \ be separated by ';'\n        x := n\n         ^\n         ;\n/tmp/tmp78fkwjlv.swift:33:4:\
    \ error: expected expression\n        x := n\n          ^\n/tmp/tmp78fkwjlv.swift:35:6:\
    \ error: expected pattern\n        for {\n            ^\n/tmp/tmp78fkwjlv.swift:35:6:\
    \ error: expected Sequence expression for for-each loop\n        for {\n     \
    \       ^\n/tmp/tmp78fkwjlv.swift:15:3: error: cannot find 'panic' in scope\n\
    \                panic(\"modp: negative number\")\n                ^~~~~\n/tmp/tmp78fkwjlv.swift:18:3:\
    \ error: cannot find 'panic' in scope\n                panic(\"modp: negative\
    \ modulus\")\n                ^~~~~\n/tmp/tmp78fkwjlv.swift:32:4: error: left\
    \ side of mutating operator isn't mutable: 'n' is a 'let' constant\n        n\
    \ -= p - 1\n        ~ ^\n/tmp/tmp78fkwjlv.swift:33:2: error: cannot find 'x' in\
    \ scope\n        x := n\n        ^\n"
  stdout: ''
  timestamp: 1660014750
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    if n < 0 {\n        return modp(abs(n), p)\n    }\n    if p < 0 {\n \
    \       return modp(n, abs(p))\n    }\n    if n == 0 {\n        return 0\n   \
    \ }\n    if p == 0 {\n        return n\n    }\n    if n == p {\n        return\
    \ n\n    }\n    if n == p {\n        return n\n    }\n    if n == p {\n      \
    \  return n\n    }\n    if n == p {\n        return n\n    }\n    if n == p {\n\
    \        return n\n    }\n    if n == p {\n        return n\n    }\n    if n ==\
    \ p {\n        return n\n    }\n    if n == p {\n        return n\n    }\n   \
    \ if n == p {\n        return n\n    }\n    if n == p {\n        return n\n  \
    \  }\n    if n == p {\n        return n\n    }\n    if n == p {\n        return\
    \ n\n    }\n    if n == p {\n        return n\n    }\n    if n == p {\n      \
    \  return n\n    }\n    if n == p {\n        return n\n    }\n    if n == p {\n\
    \        return n\n    }\n    if n == p {\n        return n\n    }\n    if n ==\
    \ p {\n        return n\n    }\n    if n == p {\n        return n\n    }\n   \
    \ if n == p {\n        return n\n    }\n    if n == p {\n        return n\n  \
    \  }\n    if n == p {\n        return n\n    }\n    if n == p {\n        return\
    \ n\n    }\n    if n == p {\n        return n\n    }\n    if n == p {\n      \
    \  return n\n    }\n    if n == p {\n        return n\n    }\n    if n == p {\n\
    \        return n\n    }\n    if n == p {\n        return n\n    }\n    if n ==\
    \ p {\n        return n\n    }\n    if n == p {\n        return n\n    }\n   \
    \ if n == p {\n        return n\n    }\n    if n == p {\n        return n\n  \
    \  }\n    if n == p {\n        return n\n    }\n    if n == p {\n        return\
    \ n\n    }\n    if n == p {\n        return n\n    }\n    if n == p {\n      \
    \  return n\n    }\n    if n == p {\n        return n\n    }\n    if n == p {\n\
    \        return n\n    }\n    if n == p {\n        return n\n    }\n    if n ==\
    \ p {\n        return n\n    }\n    if n == p {\n        return n\n    }\n   \
    \ if n == p {\n        return n\n    }\n    if n == p {\n        return n\n  \
    \  }\n    if n == p {\n        return n\n    }\n    if n == p {\n        return\
    \ n\n    }\n    if n == p {\n        return n\n    }\n    if n == p {\n      \
    \  return n\n    }\n    if n == p {\n        return n\n    }\n    if n == p {\n\
    \        return n\n    }\n    if n == p {\n        return n\n    }\n    if n ==\
    \ p {\n        return n\n    }\n    if n == p {\n        return n\n\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp68p_gotw.swift:203:31: error: expected '}' at end of brace statement\n\
    assert(modp(n: 31, p: 5) == 3)\n                              ^\n/tmp/tmp68p_gotw.swift:13:34:\
    \ note: to match this opening '{'\nfunc modp(n: Int, p: Int) -> Int {\n      \
    \                           ^\n/tmp/tmp68p_gotw.swift:15:20: error: missing argument\
    \ labels 'n:p:' in call\n        return modp(abs(n), p)\n                   ^\n\
    \                    n:      p: \n/tmp/tmp68p_gotw.swift:18:20: error: missing\
    \ argument labels 'n:p:' in call\n        return modp(n, abs(p))\n           \
    \        ^\n                    n: p: \n/tmp/tmp68p_gotw.swift:185:6: error: operator\
    \ functions can only be declared at global or in type scope\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660014750
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n\tif n < 0 {\n\t\tpanic(\"modp(n, p): n must be positive\")\n\t}\n\tif p\
    \ < 1 {\n\t\tpanic(\"modp(n, p): p must be positive\")\n\t}\n\tif n == 0 || p\
    \ == 0 {\n\t\treturn 0\n\t}\n\tswitch {\n\tcase p < 0:\n\t\treturn modp(n - 1,\
    \ p)\n\tcase p > n:\n\t\treturn modp(n, p - n)\n\t}\n\tswitch {\n\tcase p < n:\n\
    \t\treturn p % n\n\tdefault:\n\t\treturn n % p\n\t}\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\n\
    assert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp6_r88wh0.swift:23:9: error: expected expression in 'switch' statement\n\
    \        switch {\n               ^\n/tmp/tmp6_r88wh0.swift:29:9: error: expected\
    \ expression in 'switch' statement\n        switch {\n               ^\n/tmp/tmp6_r88wh0.swift:15:3:\
    \ error: cannot find 'panic' in scope\n                panic(\"modp(n, p): n must\
    \ be positive\")\n                ^~~~~\n/tmp/tmp6_r88wh0.swift:18:3: error: cannot\
    \ find 'panic' in scope\n                panic(\"modp(n, p): p must be positive\"\
    )\n                ^~~~~\n/tmp/tmp6_r88wh0.swift:25:14: error: missing argument\
    \ labels 'n:p:' in call\n                return modp(n - 1, p)\n             \
    \              ^\n                            n:     p: \n/tmp/tmp6_r88wh0.swift:27:14:\
    \ error: missing argument labels 'n:p:' in call\n                return modp(n,\
    \ p - n)\n                           ^\n                            n: p: \n"
  stdout: ''
  timestamp: 1660014750
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n\tif n < 0 {\n\t\tpanic(\"modp: negative number\")\n\t}\n\tif p < 1 {\n\t\
    \tpanic(\"modp: p < 1\")\n\t}\n\tif n == 0 {\n\t\treturn 0\n\t}\n\tif n == 1 {\n\
    \t\treturn p\n\t}\n\tif n == p {\n\t\treturn 1\n\t}\n\tq := p / n\n\tr := p -\
    \ q*n\n\tif r > 0 {\n\t\treturn modp(q, p)\n\t}\n\treturn modp(n, p)\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp3ngb0h6k.swift:29:3: error: consecutive statements on a line must\
    \ be separated by ';'\n        q := p / n\n         ^\n         ;\n/tmp/tmp3ngb0h6k.swift:29:4:\
    \ error: expected expression\n        q := p / n\n          ^\n/tmp/tmp3ngb0h6k.swift:15:3:\
    \ error: cannot find 'panic' in scope\n                panic(\"modp: negative\
    \ number\")\n                ^~~~~\n/tmp/tmp3ngb0h6k.swift:18:3: error: cannot\
    \ find 'panic' in scope\n                panic(\"modp: p < 1\")\n            \
    \    ^~~~~\n/tmp/tmp3ngb0h6k.swift:29:2: error: cannot find 'q' in scope\n   \
    \     q := p / n\n        ^\n/tmp/tmp3ngb0h6k.swift:31:5: error: cannot find 'r'\
    \ in scope\n        if r > 0 {\n           ^\n/tmp/tmp3ngb0h6k.swift:32:15: error:\
    \ cannot find 'q' in scope\n                return modp(q, p)\n              \
    \              ^\n/tmp/tmp3ngb0h6k.swift:32:14: error: missing argument labels\
    \ 'n:p:' in call\n                return modp(q, p)\n                        \
    \   ^\n                            n: p: \n/tmp/tmp3ngb0h6k.swift:34:13: error:\
    \ missing argument labels 'n:p:' in call\n        return modp(n, p)\n        \
    \           ^\n                    n: p: \n"
  stdout: ''
  timestamp: 1660014750
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    if n < 0 {\n        return modp(abs(n), p)\n    }\n    if p < 0 {\n \
    \       return modp(abs(p), n)\n    }\n    if n == 0 {\n        return 0\n   \
    \ }\n    if p == 0 {\n        return n\n    }\n    if p > n {\n        return\
    \ modp(n - p, p)\n    }\n    if p < n {\n        return modp(n, p)\n    }\n  \
    \  if n == p {\n        return n\n    }\n    if n == p+1 {\n        return p\n\
    \    }\n    if n == p-1 {\n        return p+1\n    }\n    if n == p+2 {\n    \
    \    return p+2\n    }\n    if n == p-2  {\n        return p-2\n    }\n    if\
    \ n == p+3 {\n        return p+3\n    }\n    if n == p-3  {\n        return p-3\n\
    \    }\n    if n == p+4 {\n        return p+4\n    }\n    if n == p-4  {\n   \
    \     return p-4\n    }\n    if n == p+5 {\n        return p+5\n    }\n    if\
    \ n == p-5  {\n        return p-5\n    }\n    if n == p+6 {\n        return p+6\n\
    \    }\n    if n == p-6  {\n        return p-6\n    }\n    if n == p+7 {\n   \
    \     return p+7\n    }\n    if n == p-7  {\n        return p-7\n    }\n    if\
    \ n == p+8 {\n        return p+8\n    }\n    if n == p-8  {\n        return p-8\n\
    \    }\n    if n == p+9 {\n        return p+9\n    }\n    if n == p-9  {\n   \
    \     return p-9\n    }\n    if n == p+10 {\n        return p+10\n    }\n    if\
    \ n == p-10 {\n        return p-10\n    }\n    if n == p+11 {\n        return\
    \ p+11\n    }\n    if n == p-11 {\n        return p-11\n    }\n    if n == p+12\
    \ {\n        return p+12\n    }\n    if n == p-12 {\n        return p-12\n   \
    \ }\n    if n == p+13 {\n        return p+13\n    }\n    if n == p-13 {\n    \
    \    return p-13\n    }\n    if n == p+14 {\n        return p+14\n    }\n    if\
    \ n == p-14 {\n        return p-14\n    }\n    if n == p+15 {\n        return\
    \ p+15\n    }\n    if n == p-15 {\n        return p-15\n    }\n    if n == p+16\
    \ {\n        return p+16\n    }\n    if n == p-16 {\n        return p-16\n   \
    \ }\n    if n == p+17 {\n        return p+17\n    }\n    if n == p-17\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpsw_3dvac.swift:134:17: error: expected '{' after 'if' condition\n\
    \    if n == p-17\n                ^\n/tmp/tmpsw_3dvac.swift:15:20: error: missing\
    \ argument labels 'n:p:' in call\n        return modp(abs(n), p)\n           \
    \        ^\n                    n:      p: \n/tmp/tmpsw_3dvac.swift:18:20: error:\
    \ missing argument labels 'n:p:' in call\n        return modp(abs(p), n)\n   \
    \                ^\n                    n:      p: \n/tmp/tmpsw_3dvac.swift:27:20:\
    \ error: missing argument labels 'n:p:' in call\n        return modp(n - p, p)\n\
    \                   ^\n                    n:     p: \n/tmp/tmpsw_3dvac.swift:30:20:\
    \ error: missing argument labels 'n:p:' in call\n        return modp(n, p)\n \
    \                  ^\n                    n: p: \n"
  stdout: ''
  timestamp: 1660014750
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n\tlet n2 = n * n\n\tlet p2 = p * p\n\tlet n3 = n2 * n2\n\tlet p3 = p2 * p\n\
    \tlet n4 = n3 * n3\n\tlet p4 = p3 * p3\n\tlet n5 = n4 * n4\n\tlet p5 = p4 * p4\n\
    \tlet n6 = n5 * n5\n\tlet p6 = p5 * p5\n\tlet n7 = n6 * n6\n\tlet p7 = p6 * p6\n\
    \tlet n8 = (n7 * n7) + p7\n\tlet p8 = (p7 * p7) + p7\n\tlet n9 = (n8 * n8) + p8\n\
    \tlet p9 = (p8 * p8) + p8\n\tlet n10 = (n9 * n9) + p9\n\tlet p10 = (p9 * p9) +\
    \ p9\n\tlet n11 = (n10 * n10) + p10\n\tlet p11 = (p10 * p10) + p10\n\tlet n12\
    \ = (n11 * n11) + p11\n\tlet p12 = (p11 * p11) + p11\n\tlet n13 = (n12 * n12)\
    \ + p12\n\tlet p13 = (p12 * p12) + p12\n\tlet n14 = (n13 * n13) + p13\n\tlet p14\
    \ = (p13 * p13) + p13\n\tlet n15 = (n14 * n14) + p14\n\tlet p15 = (p14 * p14)\
    \ + p14\n\tlet n16 = (n15 * n15) + p15\n\tlet p16 = (p15 * p15) + p15\n\tlet n17\
    \ = (n16 * n16) + p16\n\tlet p17 = (p16 * p16) + p16\n\tlet n18 = (n17 * n17)\
    \ + p17\n\tlet p18 = (p17 * p17) + p17\n\tlet n19 = (n18 * n18) + p18\n\tlet p19\
    \ = (p18 * p18) + p18\n\tlet n20 = (n19 * n19) + p19\n\tlet p20 = (p19 * p19)\
    \ + p19\n\tlet n21 = (n20 * n20) + p20\n\tlet p21 = (p20 * p20) + p20\n\tlet n22\
    \ = (n21 * n21) + p21\n\tlet p22 = (p21\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpmj1tek3t.swift:56:1: error: expected ')' in expression list\n}\n\
    ^\n/tmp/tmpmj1tek3t.swift:55:12: note: to match this opening '('\n        let\
    \ p22 = (p21\n                  ^\n/tmp/tmpmj1tek3t.swift:54:6: warning: initialization\
    \ of immutable value 'n22' was never used; consider replacing with assignment\
    \ to '_' or removing it\n        let n22 = (n21 * n21) + p21\n        ~~~~^~~\n\
    \        _\n/tmp/tmpmj1tek3t.swift:55:6: warning: initialization of immutable\
    \ value 'p22' was never used; consider replacing with assignment to '_' or removing\
    \ it\n        let p22 = (p21\n        ~~~~^~~\n        _\n"
  stdout: ''
  timestamp: 1660014750
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    if n < 0 {\n        return modp(abs(n), p)\n    }\n    if p < 0 {\n \
    \       return modp(n, abs(p))\n    }\n    if n == 0 {\n        return 0\n   \
    \ }\n    if p == 0 {\n        return n\n    }\n    if p > n {\n        return\
    \ modp(n, p)\n    }\n    if p < n {\n        return modp(n - p, p)\n    }\n  \
    \  return n\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmputrmmgpq.swift:15:20: error: missing argument labels 'n:p:' in\
    \ call\n        return modp(abs(n), p)\n                   ^\n               \
    \     n:      p: \n/tmp/tmputrmmgpq.swift:18:20: error: missing argument labels\
    \ 'n:p:' in call\n        return modp(n, abs(p))\n                   ^\n     \
    \               n: p: \n/tmp/tmputrmmgpq.swift:27:20: error: missing argument\
    \ labels 'n:p:' in call\n        return modp(n, p)\n                   ^\n   \
    \                 n: p: \n/tmp/tmputrmmgpq.swift:30:20: error: missing argument\
    \ labels 'n:p:' in call\n        return modp(n - p, p)\n                   ^\n\
    \                    n:     p: \n"
  stdout: ''
  timestamp: 1660014749
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n\tif n < 0 {\n\t\tpanic(\"modp: negative number\")\n\t}\n\tif p < 1 {\n\t\
    \tpanic(\"modp: p < 1\")\n\t}\n\tif n == 0 {\n\t\treturn 1\n\t}\n\tif n == 1 {\n\
    \t\treturn p\n\t}\n\tif p > p {\n\t\tpanic(\"modp: p > p\")\n\t}\n\tif n == p\
    \ {\n\t\treturn n\n\t}\n\tq := p / n\n\tr := p % n\n\treturn modp(q, p) * n +\
    \ r\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n:\
    \ 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11)\
    \ == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpe8hd299r.swift:32:3: error: consecutive statements on a line must\
    \ be separated by ';'\n        q := p / n\n         ^\n         ;\n/tmp/tmpe8hd299r.swift:32:4:\
    \ error: expected expression\n        q := p / n\n          ^\n/tmp/tmpe8hd299r.swift:15:3:\
    \ error: cannot find 'panic' in scope\n                panic(\"modp: negative\
    \ number\")\n                ^~~~~\n/tmp/tmpe8hd299r.swift:18:3: error: cannot\
    \ find 'panic' in scope\n                panic(\"modp: p < 1\")\n            \
    \    ^~~~~\n/tmp/tmpe8hd299r.swift:27:3: error: cannot find 'panic' in scope\n\
    \                panic(\"modp: p > p\")\n                ^~~~~\n/tmp/tmpe8hd299r.swift:32:2:\
    \ error: cannot find 'q' in scope\n        q := p / n\n        ^\n/tmp/tmpe8hd299r.swift:34:14:\
    \ error: cannot find 'q' in scope\n        return modp(q, p) * n + r\n       \
    \             ^\n/tmp/tmpe8hd299r.swift:34:26: error: cannot find 'r' in scope\n\
    \        return modp(q, p) * n + r\n                                ^\n/tmp/tmpe8hd299r.swift:34:13:\
    \ error: missing argument labels 'n:p:' in call\n        return modp(q, p) * n\
    \ + r\n                   ^\n                    n: p: \n"
  stdout: ''
  timestamp: 1660014750
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n\tswitch {\n\tcase n < p:\n\t\treturn 0\n\tcase n == p:\n\t\treturn 1\n\t\
    case n >= p:\n\t\treturn n - p\n\t}\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpavad8s6p.swift:14:9: error: expected expression in 'switch' statement\n\
    \        switch {\n               ^\n"
  stdout: ''
  timestamp: 1660014750
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n\tif n < 0 {\n\t\tn = -n\n\t}\n\tif p < 0 {\n\t\tp = -p\n\t}\n\tif n == 0\
    \ || p == 0 {\n\t\treturn 0\n\t}\n\tswitch {\n\tcase p < 0:\n\t\treturn modp(n\
    \ - p, p)\n\tcase p > 0:\n\t\treturn modp(n, p - 1)\n\tdefault:\n\t\treturn n\n\
    \t}\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n:\
    \ 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11)\
    \ == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpj_xugb40.swift:23:9: error: expected expression in 'switch' statement\n\
    \        switch {\n               ^\n/tmp/tmpj_xugb40.swift:15:3: error: cannot\
    \ assign to value: 'n' is a 'let' constant\n                n = -n\n         \
    \       ^\n/tmp/tmpj_xugb40.swift:18:3: error: cannot assign to value: 'p' is\
    \ a 'let' constant\n                p = -p\n                ^\n/tmp/tmpj_xugb40.swift:25:14:\
    \ error: missing argument labels 'n:p:' in call\n                return modp(n\
    \ - p, p)\n                           ^\n                            n:     p:\
    \ \n/tmp/tmpj_xugb40.swift:27:14: error: missing argument labels 'n:p:' in call\n\
    \                return modp(n, p - 1)\n                           ^\n       \
    \                     n: p: \n"
  stdout: ''
  timestamp: 1660014750
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n\tif n < 0 {\n\t\tpanic(\"modp called with negative n\")\n\t}\n\tif p < 0\
    \ {\n\t\tpanic(\"modp called with negative p\")\n\t}\n\tif p == 0 {\n\t\treturn\
    \ 0\n\t}\n\tif n == 0 {\n\t\treturn 1\n\t}\n\tif p > p {\n\t\tpanic(\"modp called\
    \ with p > p\")\n\t}\n\tn %= p\n\tif n == 0 {\n\t\treturn 1\n\t}\n\treturn p\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmplmvx4m0k.swift:15:3: error: cannot find 'panic' in scope\n    \
    \            panic(\"modp called with negative n\")\n                ^~~~~\n/tmp/tmplmvx4m0k.swift:18:3:\
    \ error: cannot find 'panic' in scope\n                panic(\"modp called with\
    \ negative p\")\n                ^~~~~\n/tmp/tmplmvx4m0k.swift:27:3: error: cannot\
    \ find 'panic' in scope\n                panic(\"modp called with p > p\")\n \
    \               ^~~~~\n/tmp/tmplmvx4m0k.swift:29:4: error: left side of mutating\
    \ operator isn't mutable: 'n' is a 'let' constant\n        n %= p\n        ~ ^\n"
  stdout: ''
  timestamp: 1660014750
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n\tif n < 0 {\n\t\tn = -n\n\t\tp = -p\n\t}\n\tif p < 2 {\n\t\treturn 0\n\t\
    }\n\tif p > p {\n\t\tp = p\n\t}\n\tswitch {\n\tcase n < 0:\n\t\treturn 0\n\tcase\
    \ p == 1:\n\t\treturn n\n\tcase p == 2:\n\t\treturn n + 1\n\tcase p == 3:\n\t\t\
    return n + 2\n\tcase p == 4:\n\t\treturn n + 3\n\tcase p == 5:\n\t\treturn n +\
    \ 4\n\tcase p == 6:\n\t\treturn n + 5\n\tcase p == 7:\n\t\treturn n + 6\n\tcase\
    \ p == 8:\n\t\treturn n + 7\n\tcase p == 9:\n\t\treturn n + 8\n\tcase p == 10:\n\
    \t\treturn n + 9\n\tcase p == 11:\n\t\treturn n + 10\n\tcase p == 12:\n\t\treturn\
    \ n + 11\n\tcase p == 13:\n\t\treturn n + 12\n\tcase p == 14:\n\t\treturn n +\
    \ 13\n\tcase p == 15:\n\t\treturn n + 14\n\tcase p == 16:\n\t\treturn n + 15\n\
    \tcase p == 17:\n\t\treturn n + 16\n\tcase p == 18:\n\t\treturn n + 17\n\tcase\
    \ p == 19:\n\t\treturn n + 18\n\tcase p == 20:\n\t\treturn n + 19\n\tcase p ==\
    \ 21:\n\t\treturn n + 20\n\tcase p == 22:\n\t\treturn n + 21\n\tcase p == 23:\n\
    \t\treturn n + 22\n\tcase p == 24:\n\t\treturn n + 23\n\tcase p == 25:\n\t\treturn\
    \ n + 24\n\tcase p == 26:\n\t\treturn n + 25\n\tcase p == 27:\n\t\treturn n +\
    \ 26\n\tcase p == 28:\n\t\treturn n + 27\n\tcase p == 29:\n\t\treturn n + 28\n\
    \tcase p == 30:\n\t\treturn n + 29\n\tcase p == 31:\n\t\treturn n + 30\n\tcase\
    \ p == 32:\n\t\treturn n + 31\n\tcase p == 33:\n\t\treturn n + 32\n\tcase p ==\
    \ 34:\n\t\treturn n + 33\n\tcase p == 35:\n\t\treturn n + 34\n\tcase p == 36:\n\
    \t\treturn n + 35\n\tcase p == 37:\n\t\treturn n + 36\n\tcase p == 38:\n\t\treturn\
    \ n + 37\n\tcase p == 39:\n\t\treturn n + 38\n\tcase p == 40:\n\t\treturn n +\
    \ 39\n\tcase p == 41:\n\t\treturn n + 40\n\tcase p == 42:\n\t\treturn n + 41\n\
    \tcase p == 43:\n\t\treturn n + 42\n\tcase p == 44:\n\t\treturn n + 43\n\tcase\
    \ p == 45:\n\t\treturn n + 44\n\tcase p == 46\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmplf7h_uuz.swift:24:9: error: expected expression in 'switch' statement\n\
    \        switch {\n               ^\n/tmp/tmplf7h_uuz.swift:117:14: error: expected\
    \ ':' after 'case'\n        case p == 46\n                    ^\n/tmp/tmplf7h_uuz.swift:139:31:\
    \ error: expected '}' at end of brace statement\nassert(modp(n: 31, p: 5) == 3)\n\
    \                              ^\n/tmp/tmplf7h_uuz.swift:13:34: note: to match\
    \ this opening '{'\nfunc modp(n: Int, p: Int) -> Int {\n                     \
    \            ^\n/tmp/tmplf7h_uuz.swift:15:3: error: cannot assign to value: 'n'\
    \ is a 'let' constant\n                n = -n\n                ^\n/tmp/tmplf7h_uuz.swift:16:3:\
    \ error: cannot assign to value: 'p' is a 'let' constant\n                p =\
    \ -p\n                ^\n/tmp/tmplf7h_uuz.swift:22:3: error: cannot assign to\
    \ value: 'p' is a 'let' constant\n                p = p\n                ^\n/tmp/tmplf7h_uuz.swift:121:6:\
    \ error: operator functions can only be declared at global or in type scope\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660014751
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    if n < 0 {\n        return modp(abs(n), p)\n    }\n    if p < 0 {\n \
    \       return modp(n, abs(p))\n    }\n    if n == 0 {\n        return 0\n   \
    \ }\n    if p == 0 {\n        return n\n    }\n    if n == p {\n        return\
    \ n\n    }\n    if n == p {\n        return n\n    }\n    if n == p+1 {\n    \
    \    return n\n    }\n    if n == p-1 {\n        return n\n    }\n    if n ==\
    \ p+2 {\n        return n\n    }\n    if n == p-2 {\n        return n\n    }\n\
    \    if n == p+3 {\n        return n\n    }\n    if n == p-3 {\n        return\
    \ n\n    }\n    if n == p+4 {\n        return n\n    }\n    if n == p-4 {\n  \
    \      return n\n    }\n    if n == p+5 {\n        return n\n    }\n    if n ==\
    \ p-5 {\n        return n\n    }\n    if n == p+6 {\n        return n\n    }\n\
    \    if n == p-6 {\n        return n\n    }\n    if n == p+7 {\n        return\
    \ n\n    }\n    if n == p-7 {\n        return n\n    }\n    if n == p+8 {\n  \
    \      return n\n    }\n    if n == p-8 {\n        return n\n    }\n    if n ==\
    \ p+9 {\n        return n\n    }\n    if n == p-9 {\n        return n\n    }\n\
    \    if n == p+10 {\n        return n\n    }\n    if n == p-10 {\n        return\
    \ n\n    }\n    if n == p+11 {\n        return n\n    }\n    if n == p-11 {\n\
    \        return n\n    }\n    if n == p+12 {\n        return n\n    }\n    if\
    \ n == p-12 {\n        return n\n    }\n    if n == p+13 {\n        return n\n\
    \    }\n    if n == p-13 {\n        return n\n    }\n    if n == p+14 {\n    \
    \    return n\n    }\n    if n == p-14 {\n        return n\n    }\n    if n ==\
    \ p+15 {\n        return n\n    }\n    if n == p-15 {\n        return n\n    }\n\
    \    if n == p+16 {\n        return n\n    }\n    if n == p-16 {\n        return\
    \ n\n    }\n    if n == p+17 {\n        return n\n    }\n    if n == p-17 {\n\
    \        return n\n    }\n    if n == p+18 {\n        return n\n    }\n    if\
    \ n == p-18 {\n        return n\n    }\n    if n == p+19 {\n        return n\n\
    \    }\n    if n == p-19 {\n        return n\n    }\n    if n == p+20 {\n    \
    \    return n\n    }\n    if n == p-20 {\n        return \n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp_8stekam.swift:172:31: error: expected '}' at end of brace statement\n\
    assert(modp(n: 31, p: 5) == 3)\n                              ^\n/tmp/tmp_8stekam.swift:13:34:\
    \ note: to match this opening '{'\nfunc modp(n: Int, p: Int) -> Int {\n      \
    \                           ^\n/tmp/tmp_8stekam.swift:15:20: error: missing argument\
    \ labels 'n:p:' in call\n        return modp(abs(n), p)\n                   ^\n\
    \                    n:      p: \n/tmp/tmp_8stekam.swift:18:20: error: missing\
    \ argument labels 'n:p:' in call\n        return modp(n, abs(p))\n           \
    \        ^\n                    n: p: \n/tmp/tmp_8stekam.swift:150:9: error: non-void\
    \ function should return a value\n        return \n        ^\n/tmp/tmp_8stekam.swift:154:6:\
    \ error: operator functions can only be declared at global or in type scope\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660014751
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n\tif n < 0 {\n\t\tpanic(\"modp: negative number\")\n\t}\n\tif p < 1 {\n\t\
    \tpanic(\"modp: p < 1\")\n\t}\n\tif n == 0 {\n\t\treturn 1\n\t}\n\tif p == 1 {\n\
    \t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif p > p {\n\t\tpanic(\"\
    modp: p > p\")\n\t}\n\tq := p\n\tfor {\n\t\tq /= 2\n\t\tif q == 1 {\n\t\t\treturn\
    \ n\n\t\t}\n\t\tif q == p {\n\t\t\treturn q\n\t\t}\n\t}\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpram3tuv4.swift:32:3: error: consecutive statements on a line must\
    \ be separated by ';'\n        q := p\n         ^\n         ;\n/tmp/tmpram3tuv4.swift:32:4:\
    \ error: expected expression\n        q := p\n          ^\n/tmp/tmpram3tuv4.swift:33:6:\
    \ error: expected pattern\n        for {\n            ^\n/tmp/tmpram3tuv4.swift:33:6:\
    \ error: expected Sequence expression for for-each loop\n        for {\n     \
    \       ^\n/tmp/tmpram3tuv4.swift:15:3: error: cannot find 'panic' in scope\n\
    \                panic(\"modp: negative number\")\n                ^~~~~\n/tmp/tmpram3tuv4.swift:18:3:\
    \ error: cannot find 'panic' in scope\n                panic(\"modp: p < 1\")\n\
    \                ^~~~~\n/tmp/tmpram3tuv4.swift:30:3: error: cannot find 'panic'\
    \ in scope\n                panic(\"modp: p > p\")\n                ^~~~~\n/tmp/tmpram3tuv4.swift:32:2:\
    \ error: cannot find 'q' in scope\n        q := p\n        ^\n"
  stdout: ''
  timestamp: 1660014751
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    if n < 0 {\n        n += p\n    }\n    if n < p {\n        return n\n\
    \    }\n    return n - p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3,\
    \ p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) ==\
    \ 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpoc4fun9h.swift:15:11: error: left side of mutating operator isn't\
    \ mutable: 'n' is a 'let' constant\n        n += p\n        ~ ^\n"
  stdout: ''
  timestamp: 1660014750
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    if n < 0 {\n        return modp(abs(n), p)\n    }\n    if p < 0 {\n \
    \       return modp(n, abs(p))\n    }\n    if n == 0 {\n        return 0\n   \
    \ }\n    if p == 0 {\n        return n\n    }\n    if p > n {\n        return\
    \ modp(n, p)\n    }\n    if p < n {\n        return modp(n - p, p)\n    }\n  \
    \  if n == 1 {\n        return p\n    }\n    if n == p {\n        return n\n \
    \   }\n    if n == p {\n        return p\n    }\n    if n == p - 1 {\n       \
    \ return p\n    }\n    if n == p - 1 {\n        return p\n    }\n    if n == p\
    \ - 2 {\n        return p\n    }\n    if n == p - 2 {\n        return p\n    }\n\
    \    if n == p - 3 {\n        return p\n    }\n    if n == p - 3 {\n        return\
    \ p\n    }\n    if n == p - 4 {\n        return p\n    }\n    if n == p - 4 {\n\
    \        return p\n    }\n    if n == p - 5 {\n        return p\n    }\n    if\
    \ n == p - 5 {\n        return p\n    }\n    if n == p - 6 {\n        return p\n\
    \    }\n    if n == p - 6 {\n        return p\n    }\n    if n == p - 7 {\n  \
    \      return p\n    }\n    if n == p - 7 {\n        return p\n    }\n    if n\
    \ == p - 8 {\n        return p\n    }\n    if n == p - 8 {\n        return p\n\
    \    }\n    if n == p - 9 {\n        return p\n    }\n    if n == p - 9 {\n  \
    \      return p\n    }\n    if n == p - 10 {\n        return p\n    }\n    if\
    \ n == p - 10 {\n        return p\n    }\n    if n == p - 11 {\n        return\
    \ p\n    }\n    if n == p - 11 {\n        return p\n    }\n    if n == p - 12\
    \ {\n        return p\n    }\n    if n == p - 12 {\n        return p\n    }\n\
    \    if n == p - 13 {\n        return p\n    }\n    if n == p - 13 {\n       \
    \ return p\n    }\n    if n == p - 14 {\n        return p\n    }\n    if n ==\
    \ p - 14 {\n        return p\n    }\n    if n == p - 15 {\n        return p\n\
    \    }\n    if n == p - 15 {\n        return p\n    }\n    if n == p - 16 {\n\
    \        return p\n    }\n    if n == p - 16 {\n        return p\n    }\n    if\
    \ n == p - 17 {\n        return p\n    }\n    if n == p - 17 {\n        return\
    \ p\n    }\n    if n == p - 18 {\n        return p\n    }\n    if n == p - 18\
    \ {\n        return p\n    }\n    if n == p - 19 {\n        return p\n    }\n\
    \    if n == p - 19 {\n        return p\n    }\n\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\n\
    assert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpsfe96lb2.swift:15:20: error: missing argument labels 'n:p:' in\
    \ call\n        return modp(abs(n), p)\n                   ^\n               \
    \     n:      p: \n/tmp/tmpsfe96lb2.swift:18:20: error: missing argument labels\
    \ 'n:p:' in call\n        return modp(n, abs(p))\n                   ^\n     \
    \               n: p: \n/tmp/tmpsfe96lb2.swift:27:20: error: missing argument\
    \ labels 'n:p:' in call\n        return modp(n, p)\n                   ^\n   \
    \                 n: p: \n/tmp/tmpsfe96lb2.swift:30:20: error: missing argument\
    \ labels 'n:p:' in call\n        return modp(n - p, p)\n                   ^\n\
    \                    n:     p: \n"
  stdout: ''
  timestamp: 1660014751
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    if n < 0 {\n        return modp(abs(n), p)\n    }\n    if p < 0 {\n \
    \       return modp(n, abs(p))\n    }\n    if n == 0 {\n        return 0\n   \
    \ }\n    if p == 0 {\n        return n\n    }\n    if p > n {\n        return\
    \ modp(n, p)\n    }\n    if p < n {\n        return modp(n - p, p)\n    }\n  \
    \  return modp((n - p) / 2, p)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n:\
    \ 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101)\
    \ == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpw4qx9b9h.swift:15:20: error: missing argument labels 'n:p:' in\
    \ call\n        return modp(abs(n), p)\n                   ^\n               \
    \     n:      p: \n/tmp/tmpw4qx9b9h.swift:18:20: error: missing argument labels\
    \ 'n:p:' in call\n        return modp(n, abs(p))\n                   ^\n     \
    \               n: p: \n/tmp/tmpw4qx9b9h.swift:27:20: error: missing argument\
    \ labels 'n:p:' in call\n        return modp(n, p)\n                   ^\n   \
    \                 n: p: \n/tmp/tmpw4qx9b9h.swift:30:20: error: missing argument\
    \ labels 'n:p:' in call\n        return modp(n - p, p)\n                   ^\n\
    \                    n:     p: \n/tmp/tmpw4qx9b9h.swift:32:16: error: missing\
    \ argument labels 'n:p:' in call\n    return modp((n - p) / 2, p)\n          \
    \     ^\n                n:           p: \n"
  stdout: ''
  timestamp: 1660014751
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n\tif n < 0 {\n\t\tpanic(\"modp: negative number\")\n\t}\n\tif p < 1 {\n\t\
    \tpanic(\"modp: p < 1\")\n\t}\n\tif n == 0 {\n\t\treturn 1\n\t}\n\tif n == 1 {\n\
    \t\treturn p\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif p > p {\n\t\tpanic(\"\
    modp: p > p\")\n\t}\n\tx := n\n\ty := p\n\tz := 1\n\tfor {\n\t\tif x == 0 {\n\t\
    \t\treturn z\n\t\t}\n\t\tif y == 0 {\n\t\t\treturn z\n\t\t}\n\t\tt = x % y\n\t\
    \tx = y\n\t\ty = t\n\t\tz = z * y\n\t}\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp_p1f79t8.swift:32:3: error: consecutive statements on a line must\
    \ be separated by ';'\n        x := n\n         ^\n         ;\n/tmp/tmp_p1f79t8.swift:32:4:\
    \ error: expected expression\n        x := n\n          ^\n/tmp/tmp_p1f79t8.swift:35:6:\
    \ error: expected pattern\n        for {\n            ^\n/tmp/tmp_p1f79t8.swift:35:6:\
    \ error: expected Sequence expression for for-each loop\n        for {\n     \
    \       ^\n/tmp/tmp_p1f79t8.swift:15:3: error: cannot find 'panic' in scope\n\
    \                panic(\"modp: negative number\")\n                ^~~~~\n/tmp/tmp_p1f79t8.swift:18:3:\
    \ error: cannot find 'panic' in scope\n                panic(\"modp: p < 1\")\n\
    \                ^~~~~\n/tmp/tmp_p1f79t8.swift:30:3: error: cannot find 'panic'\
    \ in scope\n                panic(\"modp: p > p\")\n                ^~~~~\n/tmp/tmp_p1f79t8.swift:32:2:\
    \ error: cannot find 'x' in scope\n        x := n\n        ^\n"
  stdout: ''
  timestamp: 1660014751
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    if n < 0 {\n        return modp(-n, p)\n    }\n    if p < 2 {\n     \
    \   return n\n    }\n    if p > p {\n        return modp(n - p, p)\n    }\n  \
    \  if n == 0 {\n        return 0\n    }\n    if n == 1 {\n        return p\n \
    \   }\n    if n == p {\n        return n\n    }\n    if n == p {\n        return\
    \ p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n      \
    \  return p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n\
    \        return p\n    }\n    if n == p {\n        return p\n    }\n    if n ==\
    \ p {\n        return p\n    }\n    if n == p {\n        return p\n    }\n   \
    \ if n == p {\n        return p\n    }\n    if n == p {\n        return p\n  \
    \  }\n    if n == p {\n        return p\n    }\n    if n == p {\n        return\
    \ p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n      \
    \  return p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n\
    \        return p\n    }\n    if n == p {\n        return p\n    }\n    if n ==\
    \ p {\n        return p\n    }\n    if n == p {\n        return p\n    }\n   \
    \ if n == p {\n        return p\n    }\n    if n == p {\n        return p\n  \
    \  }\n    if n == p {\n        return p\n    }\n    if n == p {\n        return\
    \ p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n      \
    \  return p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n\
    \        return p\n    }\n    if n == p {\n        return p\n    }\n    if n ==\
    \ p {\n        return p\n    }\n    if n == p {\n        return p\n    }\n   \
    \ if n == p {\n        return p\n    }\n    if n == p {\n        return p\n  \
    \  }\n    if n == p {\n        return p\n    }\n    if n == p {\n        return\
    \ p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n      \
    \  return p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n\
    \        return p\n    }\n    if n == p {\n        return p\n    }\n    if n ==\
    \ p {\n        return p\n    }\n    if n == p {\n        return p\n    }\n   \
    \ if n == p {\n        return p\n    }\n    if n == p {\n        return p\n  \
    \  }\n    if n == p {\n        return p\n    }\n    if n == p {\n        return\
    \ p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n      \
    \  return p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n\
    \        return p\n    }\n    if n == p {\n        return p\n    }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp88cs82ow.swift:15:20: error: missing argument labels 'n:p:' in\
    \ call\n        return modp(-n, p)\n                   ^\n                   \
    \ n:  p: \n/tmp/tmp88cs82ow.swift:21:20: error: missing argument labels 'n:p:'\
    \ in call\n        return modp(n - p, p)\n                   ^\n             \
    \       n:     p: \n"
  stdout: ''
  timestamp: 1660014751
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n\tif n < 0 {\n\t\tpanic(\"modp: negative number\")\n\t}\n\tif p < 1 {\n\t\
    \tpanic(\"modp: negative modulus\")\n\t}\n\tif n == 0 {\n\t\treturn 0\n\t}\n\t\
    if n == 1 {\n\t\treturn p\n\t}\n\tr := n % p\n\tif r == 0 {\n\t\treturn p\n\t\
    }\n\treturn r\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpwjt6gi2k.swift:26:3: error: consecutive statements on a line must\
    \ be separated by ';'\n        r := n % p\n         ^\n         ;\n/tmp/tmpwjt6gi2k.swift:26:4:\
    \ error: expected expression\n        r := n % p\n          ^\n/tmp/tmpwjt6gi2k.swift:15:3:\
    \ error: cannot find 'panic' in scope\n                panic(\"modp: negative\
    \ number\")\n                ^~~~~\n/tmp/tmpwjt6gi2k.swift:18:3: error: cannot\
    \ find 'panic' in scope\n                panic(\"modp: negative modulus\")\n \
    \               ^~~~~\n/tmp/tmpwjt6gi2k.swift:26:2: error: cannot find 'r' in\
    \ scope\n        r := n % p\n        ^\n/tmp/tmpwjt6gi2k.swift:27:5: error: cannot\
    \ find 'r' in scope\n        if r == 0 {\n           ^\n/tmp/tmpwjt6gi2k.swift:30:9:\
    \ error: cannot find 'r' in scope\n        return r\n               ^\n"
  stdout: ''
  timestamp: 1660014751
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n\tswitch {\n\tcase n < 0 || p < 0 || p > n:\n\t\tpanic(\"modp: invalid arguments\"\
    )\n\tcase n == p:\n\t\treturn n\n\tcase n == 0 || p == 0:\n\t\treturn 0\n\tcase\
    \ n >= p:\n\t\treturn n - p\n\t}\n\tswitch {\n\tcase p < 2:\n\t\treturn 0\n\t\
    case p < n:\n\t\treturn p - 1\n\tdefault:\n\t\tlet r = modp(n - p, p)\n\t\treturn\
    \ r * p + r\n\t}\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp7l0_g7ks.swift:14:9: error: expected expression in 'switch' statement\n\
    \        switch {\n               ^\n/tmp/tmp7l0_g7ks.swift:24:9: error: expected\
    \ expression in 'switch' statement\n        switch {\n               ^\n/tmp/tmp7l0_g7ks.swift:16:3:\
    \ error: cannot find 'panic' in scope\n                panic(\"modp: invalid arguments\"\
    )\n                ^~~~~\n/tmp/tmp7l0_g7ks.swift:30:15: error: missing argument\
    \ labels 'n:p:' in call\n                let r = modp(n - p, p)\n            \
    \                ^\n                             n:     p: \n"
  stdout: ''
  timestamp: 1660014751
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n\tif n < 0 {\n\t\tpanic(\"modp(n,p)\")\n\t}\n\tif p < 0 {\n\t\tpanic(\"modp(n,p)\"\
    )\n\t}\n\tif n == 0 || p == 0 {\n\t\treturn 0\n\t}\n\tif n == 1 {\n\t\treturn\
    \ p\n\t}\n\tif p == 1 {\n\t\treturn n\n\t}\n\tq := n / p\n\tr := n % p\n\treturn\
    \ q * p + r\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpumv1ri0u.swift:29:3: error: consecutive statements on a line must\
    \ be separated by ';'\n        q := n / p\n         ^\n         ;\n/tmp/tmpumv1ri0u.swift:29:4:\
    \ error: expected expression\n        q := n / p\n          ^\n/tmp/tmpumv1ri0u.swift:15:3:\
    \ error: cannot find 'panic' in scope\n                panic(\"modp(n,p)\")\n\
    \                ^~~~~\n/tmp/tmpumv1ri0u.swift:18:3: error: cannot find 'panic'\
    \ in scope\n                panic(\"modp(n,p)\")\n                ^~~~~\n/tmp/tmpumv1ri0u.swift:29:2:\
    \ error: cannot find 'q' in scope\n        q := n / p\n        ^\n/tmp/tmpumv1ri0u.swift:31:9:\
    \ error: cannot find 'q' in scope\n        return q * p + r\n               ^\n\
    /tmp/tmpumv1ri0u.swift:31:17: error: cannot find 'r' in scope\n        return\
    \ q * p + r\n                       ^\n"
  stdout: ''
  timestamp: 1660014751
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    return ((n & (p - 1)) == 0) ? n : ((n & (p - 1)) + p) % p\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmpi233l72q/tmpi233l72q.swift:31: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002afea657bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002afea6272b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002afea6272988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002afea62717b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpi233l72q                        0x00005614be2ee2cd <unavailable> + 4813

    5    libc.so.6                          0x00002afea6767460 __libc_start_main +
    245

    6    tmpi233l72q                        0x00005614be2edef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014750
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n\tif n < 0 {\n\t\tpanic(\"modp: negative number\")\n\t}\n\tif p < 1 {\n\t\
    \tpanic(\"modp: negative modulus\")\n\t}\n\tif n == 0 {\n\t\treturn 1\n\t}\n\t\
    if p == 1 {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn 1\n\t}\n\tif n == p+1\
    \ {\n\t\treturn 2\n\t}\n\tif n == p+2 {\n\t\treturn 4\n\t}\n\tif n == p+3 {\n\t\
    \treturn 8\n\t}\n\tif n == p+4 {\n\t\treturn 16\n\t}\n\tif n == p+5 {\n\t\treturn\
    \ 32\n\t}\n\tif n == p+6 {\n\t\treturn 64\n\t}\n\tif n == p+7 {\n\t\treturn 128\n\
    \t}\n\tif n == p+8 {\n\t\treturn 256\n\t}\n\tif n == p+9 {\n\t\treturn 512\n\t\
    }\n\tif n == p+10 {\n\t\treturn 1024\n\t}\n\tif n == p+11 {\n\t\treturn 2048\n\
    \t}\n\tif n == p+12 {\n\t\treturn 4096\n\t}\n\tif n == p+13 {\n\t\treturn 8192\n\
    \t}\n\tif n == p+14 {\n\t\treturn 16384\n\t}\n\tif n == p+15 {\n\t\treturn 32768\n\
    \t}\n\tif n == p+16 {\n\t\treturn 65536\n\t}\n\tif n == p+17 {\n\t\treturn 131072\n\
    \t}\n\tif n == p+18 {\n\t\treturn 262144\n\t}\n\tif n == p+19 {\n\t\treturn 524288\n\
    \t}\n\tif n == p+20 {\n\t\treturn 1048576\n\t}\n\tif n == p+21 {\n\t\treturn 2097152\n\
    \t}\n\tif n == p+22 {\n\t\treturn 4194304\n\t}\n\tif n == p+23 {\n\t\treturn 8388608\n\
    \t}\n\tif n == p+24 {\n\t\treturn 16777216\n\t}\n\tif n == p+25 {\n\t\treturn\
    \ 33554432\n\t}\n\tif n == p+26 {\n\t\treturn 67108864\n\t}\n\tif n == p+27 {\n\
    \t\treturn 134217728\n\t}\n\tif n == p+28 {\n\t\treturn 268435456\n\t}\n\tif n\
    \ == p+29 {\n\t\treturn 536870912\n\t}\n\tif n == p+30 {\n\t\treturn 1073741824\n\
    \t}\n\tif n == p+31 {\n\t\treturn -2147483648\n\t}\n\tpanic(\"unreachable\")\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmptbyzc0d8.swift:15:3: error: cannot find 'panic' in scope\n    \
    \            panic(\"modp: negative number\")\n                ^~~~~\n/tmp/tmptbyzc0d8.swift:18:3:\
    \ error: cannot find 'panic' in scope\n                panic(\"modp: negative\
    \ modulus\")\n                ^~~~~\n/tmp/tmptbyzc0d8.swift:122:2: error: cannot\
    \ find 'panic' in scope\n        panic(\"unreachable\")\n        ^~~~~\n"
  stdout: ''
  timestamp: 1660014751
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n\tif n < 0 {\n\t\tpanic(\"modp: negative number\")\n\t}\n\tif p < 1 {\n\t\
    \tpanic(\"modp: p < 1\")\n\t}\n\tif n == 0 {\n\t\treturn 0\n\t}\n\tif n == 1 {\n\
    \t\treturn p\n\t}\n\tif p > p {\n\t\tpanic(\"modp: p > p\")\n\t}\n\tif p > p {\n\
    \t\tpanic(\"modp: p > p\")\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tr := n %\
    \ p\n\tif r == 0 {\n\t\treturn n\n\t}\n\treturn r\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\n\
    assert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp831l4l37.swift:35:3: error: consecutive statements on a line must\
    \ be separated by ';'\n        r := n % p\n         ^\n         ;\n/tmp/tmp831l4l37.swift:35:4:\
    \ error: expected expression\n        r := n % p\n          ^\n/tmp/tmp831l4l37.swift:15:3:\
    \ error: cannot find 'panic' in scope\n                panic(\"modp: negative\
    \ number\")\n                ^~~~~\n/tmp/tmp831l4l37.swift:18:3: error: cannot\
    \ find 'panic' in scope\n                panic(\"modp: p < 1\")\n            \
    \    ^~~~~\n/tmp/tmp831l4l37.swift:27:3: error: cannot find 'panic' in scope\n\
    \                panic(\"modp: p > p\")\n                ^~~~~\n/tmp/tmp831l4l37.swift:30:3:\
    \ error: cannot find 'panic' in scope\n                panic(\"modp: p > p\")\n\
    \                ^~~~~\n/tmp/tmp831l4l37.swift:35:2: error: cannot find 'r' in\
    \ scope\n        r := n % p\n        ^\n/tmp/tmp831l4l37.swift:36:5: error: cannot\
    \ find 'r' in scope\n        if r == 0 {\n           ^\n/tmp/tmp831l4l37.swift:39:9:\
    \ error: cannot find 'r' in scope\n        return r\n               ^\n"
  stdout: ''
  timestamp: 1660014751
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    if n < 0 {\n        return modp(abs(n), p)\n    }\n    if p < 0 {\n \
    \       return modp(n & (p - 1), p)\n    }\n    if p > n {\n        return modp(n\
    \ & (p - 1), p)\n    }\n    return n & (p - 1)\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpk9lr50q4.swift:15:20: error: missing argument labels 'n:p:' in\
    \ call\n        return modp(abs(n), p)\n                   ^\n               \
    \     n:      p: \n/tmp/tmpk9lr50q4.swift:18:20: error: missing argument labels\
    \ 'n:p:' in call\n        return modp(n & (p - 1), p)\n                   ^\n\
    \                    n:           p: \n/tmp/tmpk9lr50q4.swift:21:20: error: missing\
    \ argument labels 'n:p:' in call\n        return modp(n & (p - 1), p)\n      \
    \             ^\n                    n:           p: \n"
  stdout: ''
  timestamp: 1660014751
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    if n < 0 {\n        return modp(abs(n), p)\n    }\n    if p < 0 {\n \
    \       return modp(n, abs(p))\n    }\n    if n == 0 {\n        return 0\n   \
    \ }\n    if p == 0 {\n        return n\n    }\n    if p > n {\n        return\
    \ modp(n, p)\n    }\n    if p < n {\n        return modp(n - p, p)\n    }\n  \
    \  var result = 1\n    for i := 1; i <= n; i++ {\n        result = result * p\
    \ % i\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n:\
    \ 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101)\
    \ == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmphohzb2tc.swift:33:12: error: expected type\n    for i := 1; i <=\
    \ n; i++ {\n           ^\n            <#type#>\n/tmp/tmphohzb2tc.swift:33:12:\
    \ error: expected 'in' after for-each pattern\n    for i := 1; i <= n; i++ {\n\
    \           ^\n/tmp/tmphohzb2tc.swift:33:12: error: expected Sequence expression\
    \ for for-each loop\n    for i := 1; i <= n; i++ {\n           ^\n/tmp/tmphohzb2tc.swift:15:20:\
    \ error: missing argument labels 'n:p:' in call\n        return modp(abs(n), p)\n\
    \                   ^\n                    n:      p: \n/tmp/tmphohzb2tc.swift:18:20:\
    \ error: missing argument labels 'n:p:' in call\n        return modp(n, abs(p))\n\
    \                   ^\n                    n: p: \n/tmp/tmphohzb2tc.swift:27:20:\
    \ error: missing argument labels 'n:p:' in call\n        return modp(n, p)\n \
    \                  ^\n                    n: p: \n/tmp/tmphohzb2tc.swift:30:20:\
    \ error: missing argument labels 'n:p:' in call\n        return modp(n - p, p)\n\
    \                   ^\n                    n:     p: \n"
  stdout: ''
  timestamp: 1660014751
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    if n == 0 {\n        return 0\n    }\n    if p == 0 {\n        return\
    \ 1\n    }\n    if p > n {\n        return modp(n - p, p)\n    }\n    if p < 0\
    \ {\n        return modp(-p, p)\n    }\n    if n == 1 {\n        return p\n  \
    \  }\n    if n == 2 {\n        return p + p\n    }\n    if n == 3 {\n        return\
    \ p + p + p\n    }\n    if n == 4 {\n        return p + p + p + p\n    }\n   \
    \ if n == 5 {\n        return p + p + p + p + p\n    }\n    if n == 6 {\n    \
    \    return p + p + p + p + p + p\n    }\n    if n == 7 {\n        return p +\
    \ p + p + p + p + p + p\n    }\n    if n == 8 {\n        return p + p + p + p\
    \ + p + p + p + p\n    }\n    if n == 9 {\n        return p + p + p + p + p +\
    \ p + p + p + p\n    }\n    if n == 10 {\n        return p + p + p + p + p + p\
    \ + p + p + p + p\n    }\n    if n == 11 {\n        return p + p + p + p + p +\
    \ p + p + p + p + p + p\n    }\n    if n == 12 {\n        return p + p + p + p\
    \ + p + p + p + p + p + p + p + p\n    }\n    if n == 13 {\n        return p +\
    \ p + p + p + p + p + p + p + p + p + p + p + p\n    }\n    if n == 14 {\n   \
    \     return p + p + p + p + p + p + p + p + p + p + p + p + p + p\n    }\n  \
    \  if n == 15 {\n        return p + p + p + p + p + p + p + p + p + p + p + p\
    \ + p + p + p\n    }\n    if n == 16 {\n        return p + p + p + p + p + p +\
    \ p + p + p + p + p + p + p + p + p + p\n    }\n    if n == 17 {\n        return\
    \ p + p + p + p + p + p + p + p + p + p + p + p + p + p + p + p + p\n    }\n \
    \   if n == 18 {\n        return p + p + p + p + p + p + p + p + p + p + p + \n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp8f7tdxip.swift:79:1: error: expected expression after operator\n\
    }\n^\n/tmp/tmp8f7tdxip.swift:100:31: error: expected '}' at end of brace statement\n\
    assert(modp(n: 31, p: 5) == 3)\n                              ^\n/tmp/tmp8f7tdxip.swift:13:34:\
    \ note: to match this opening '{'\nfunc modp(n: Int, p: Int) -> Int {\n      \
    \                           ^\n/tmp/tmp8f7tdxip.swift:21:20: error: missing argument\
    \ labels 'n:p:' in call\n        return modp(n - p, p)\n                   ^\n\
    \                    n:     p: \n/tmp/tmp8f7tdxip.swift:24:20: error: missing\
    \ argument labels 'n:p:' in call\n        return modp(-p, p)\n               \
    \    ^\n                    n:  p: \n/tmp/tmp8f7tdxip.swift:82:6: error: operator\
    \ functions can only be declared at global or in type scope\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660014751
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n\tif n < 0 {\n\t\tpanic(\"modp called with negative n\")\n\t}\n\tif p < 0\
    \ {\n\t\tpanic(\"modp called with negative p\")\n\t}\n\tif n == 0 {\n\t\treturn\
    \ 1\n\t}\n\tif p == 1 {\n\t\treturn n\n\t}\n\tif p > p {\n\t\treturn 0\n\t}\n\t\
    if p > 1 {\n\t\tp = p - 1\n\t}\n\tq := n / p\n\tr := n % p\n\tif r == 0 {\n\t\t\
    return q\n\t}\n\treturn q + modp(q, p) + r\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpdbhw0dyv.swift:32:3: error: consecutive statements on a line must\
    \ be separated by ';'\n        q := n / p\n         ^\n         ;\n/tmp/tmpdbhw0dyv.swift:32:4:\
    \ error: expected expression\n        q := n / p\n          ^\n/tmp/tmpdbhw0dyv.swift:15:3:\
    \ error: cannot find 'panic' in scope\n                panic(\"modp called with\
    \ negative n\")\n                ^~~~~\n/tmp/tmpdbhw0dyv.swift:18:3: error: cannot\
    \ find 'panic' in scope\n                panic(\"modp called with negative p\"\
    )\n                ^~~~~\n/tmp/tmpdbhw0dyv.swift:30:3: error: cannot assign to\
    \ value: 'p' is a 'let' constant\n                p = p - 1\n                ^\n\
    /tmp/tmpdbhw0dyv.swift:32:2: error: cannot find 'q' in scope\n        q := n /\
    \ p\n        ^\n/tmp/tmpdbhw0dyv.swift:34:5: error: cannot find 'r' in scope\n\
    \        if r == 0 {\n           ^\n/tmp/tmpdbhw0dyv.swift:35:10: error: cannot\
    \ find 'q' in scope\n                return q\n                       ^\n/tmp/tmpdbhw0dyv.swift:37:9:\
    \ error: cannot find 'q' in scope\n        return q + modp(q, p) + r\n       \
    \        ^\n/tmp/tmpdbhw0dyv.swift:37:18: error: cannot find 'q' in scope\n  \
    \      return q + modp(q, p) + r\n                        ^\n/tmp/tmpdbhw0dyv.swift:37:26:\
    \ error: cannot find 'r' in scope\n        return q + modp(q, p) + r\n       \
    \                         ^\n/tmp/tmpdbhw0dyv.swift:37:17: error: missing argument\
    \ labels 'n:p:' in call\n        return q + modp(q, p) + r\n                 \
    \      ^\n                        n: p: \n"
  stdout: ''
  timestamp: 1660014751
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n\tlet r = n % p\n\tif r == 0 {\n\t\treturn p\n\t}\n\treturn r\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmppdv_jlsr/tmppdv_jlsr.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b69dc2d7c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b69dbfceb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b69dbfce988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b69dbfcd7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmppdv_jlsr                        0x00005570d13a82cd <unavailable> + 4813

    5    libc.so.6                          0x00002b69dc4c3460 __libc_start_main +
    245

    6    tmppdv_jlsr                        0x00005570d13a7ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014750
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n\tif n < 0 {\n\t\tpanic(\"modp: negative number\")\n\t}\n\tif p < 1 {\n\t\
    \tpanic(\"modp: p < 1\")\n\t}\n\tif n == 0 {\n\t\treturn 1\n\t}\n\tif n == 1 {\n\
    \t\treturn p\n\t}\n\tif p < 2 {\n\t\treturn 0\n\t}\n\tif p < 3 {\n\t\treturn 1\n\
    \t}\n\tif p < 4 {\n\t\treturn modp(n - 1, p)\n\t}\n\tif p < 5 {\n\t\treturn modp(n\
    \ - 2, p)\n\t}\n\tif p < 6 {\n\t\treturn modp(n - 3, p)\n\t}\n\tif p < 7 {\n\t\
    \treturn modp(n - 4, p)\n\t}\n\tif p < 8 {\n\t\treturn modp(n - 5, p)\n\t}\n\t\
    if p < 9 {\n\t\treturn modp(n - 6, p)\n\t}\n\tif p < 10 {\n\t\treturn modp(n -\
    \ 7, p)\n\t}\n\tif p < 11 {\n\t\treturn modp(n - 8, p)\n\t}\n\tif p < 12 {\n\t\
    \treturn modp(n - 9, p)\n\t}\n\tif p < 13 {\n\t\treturn modp(n - 10, p)\n\t}\n\
    \tif p < 14 {\n\t\treturn modp(n - 11, p)\n\t}\n\tif p < 15 {\n\t\treturn modp(n\
    \ - 12, p)\n\t}\n\tif p < 16 {\n\t\treturn modp(n - 13, p)\n\t}\n\tif p < 17 {\n\
    \t\treturn modp(n - 14, p)\n\t}\n\tif p < 18 {\n\t\treturn modp(n - 15, p)\n\t\
    }\n\tif p < 19 {\n\t\treturn modp(n - 16, p)\n\t}\n\tif p < 20 {\n\t\treturn modp(n\
    \ - 17, p)\n\t}\n\tif p < 21 {\n\t\treturn modp(n - 18, p)\n\t}\n\tif p < 22 {\n\
    \t\treturn modp(n - 19, p)\n\t}\n\tif p < 23 {\n\t\treturn modp(n - 20, p)\n\t\
    }\n\tif p < 24 {\n\t\treturn modp(n - 21, p)\n\t}\n\tif p < 25 {\n\t\treturn modp(n\
    \ - 22, p)\n\t}\n\tif p < 26 {\n\t\treturn modp(n - 23, p)\n\t}\n\tif p < 27 {\n\
    \t\treturn modp(n - 24, p)\n\t}\n\tif p < 28 {\n\t\treturn modp(n - 25, p)\n\t\
    }\n\tif p < 29 {\n\t\treturn modp(n - 26, p)\n\t}\n\tif p < 30 {\n\t\treturn modp(n\
    \ - 27, p)\n\t}\n\tif p < 31 {\n\t\treturn modp(n - 28, p)\n\t}\n\tif p < 32 {\n\
    \t\treturn modp(n - 29, p)\n\t}\n\tif p < 33 {\n\t\treturn \n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpgxrtvuxq.swift:142:31: error: expected '}' at end of brace statement\n\
    assert(modp(n: 31, p: 5) == 3)\n                              ^\n/tmp/tmpgxrtvuxq.swift:13:34:\
    \ note: to match this opening '{'\nfunc modp(n: Int, p: Int) -> Int {\n      \
    \                           ^\n/tmp/tmpgxrtvuxq.swift:15:3: error: cannot find\
    \ 'panic' in scope\n                panic(\"modp: negative number\")\n       \
    \         ^~~~~\n/tmp/tmpgxrtvuxq.swift:18:3: error: cannot find 'panic' in scope\n\
    \                panic(\"modp: p < 1\")\n                ^~~~~\n/tmp/tmpgxrtvuxq.swift:33:14:\
    \ error: missing argument labels 'n:p:' in call\n                return modp(n\
    \ - 1, p)\n                           ^\n                            n:     p:\
    \ \n/tmp/tmpgxrtvuxq.swift:36:14: error: missing argument labels 'n:p:' in call\n\
    \                return modp(n - 2, p)\n                           ^\n       \
    \                     n:     p: \n/tmp/tmpgxrtvuxq.swift:39:14: error: missing\
    \ argument labels 'n:p:' in call\n                return modp(n - 3, p)\n    \
    \                       ^\n                            n:     p: \n/tmp/tmpgxrtvuxq.swift:42:14:\
    \ error: missing argument labels 'n:p:' in call\n                return modp(n\
    \ - 4, p)\n                           ^\n                            n:     p:\
    \ \n/tmp/tmpgxrtvuxq.swift:45:14: error: missing argument labels 'n:p:' in call\n\
    \                return modp(n - 5, p)\n                           ^\n       \
    \                     n:     p: \n/tmp/tmpgxrtvuxq.swift:48:14: error: missing\
    \ argument labels 'n:p:' in call\n                return modp(n - 6, p)\n    \
    \                       ^\n                            n:     p: \n/tmp/tmpgxrtvuxq.swift:51:14:\
    \ error: missing argument labels 'n:p:' in call\n                return modp(n\
    \ - 7, p)\n                           ^\n                            n:     p:\
    \ \n/tmp/tmpgxrtvuxq.swift:54:14: error: missing argument labels 'n:p:' in call\n\
    \                return modp(n - 8, p)\n                           ^\n       \
    \                     n:     p: \n/tmp/tmpgxrtvuxq.swift:57:14: error: missing\
    \ argument labels '"
  stdout: ''
  timestamp: 1660014751
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n\tassert(n >= 0, \"modulus must be non-negative\")\n\tassert(p >= 0, \"modulus\
    \ must be non-negative\")\n\tassert(p <= n, \"modulus must be less than modulus\"\
    )\n\t\n\tlet mut result = 1\n\t\n\twhile n > 0 {\n\t\tresult *= p\n\t\tn -= 1\n\
    \t}\n\t\n\treturn result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3,\
    \ p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) ==\
    \ 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpsenjn3zs.swift:18:10: error: found an unexpected second identifier\
    \ in constant declaration; is there an accidental break?\n        let mut result\
    \ = 1\n                ^\n/tmp/tmpsenjn3zs.swift:18:10: note: join the identifiers\
    \ together\n        let mut result = 1\n            ~~~~^~~~~~\n            mutresult\n\
    /tmp/tmpsenjn3zs.swift:18:10: note: join the identifiers together with camel-case\n\
    \        let mut result = 1\n            ~~~~^~~~~~\n            mutResult\n/tmp/tmpsenjn3zs.swift:21:3:\
    \ error: cannot find 'result' in scope\n                result *= p\n        \
    \        ^~~~~~\n/tmp/tmpsenjn3zs.swift:22:5: error: left side of mutating operator\
    \ isn't mutable: 'n' is a 'let' constant\n                n -= 1\n           \
    \     ~ ^\n/tmp/tmpsenjn3zs.swift:25:9: error: cannot find 'result' in scope\n\
    \        return result\n               ^~~~~~\n"
  stdout: ''
  timestamp: 1660014751
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    if n < 0 {\n        return modp(abs(n), p)\n    }\n    if p < 0 {\n \
    \       return modp(n - abs(p), p)\n    }\n    if n == 0 {\n        return 0\n\
    \    }\n    if p == 0 {\n        return n\n    }\n    if p > n {\n        return\
    \ modp(n - p, p)\n    }\n    if p < n {\n        return modp(n, p)\n    }\n  \
    \  if n == 1 {\n        return p\n    }\n    if n == 2 {\n        return p + 1\n\
    \    }\n    if n == 3 {\n        return p + 2\n    }\n    if n == 4 {\n      \
    \  return p + 3\n    }\n    if n == 5 {\n        return p + 4\n    }\n    if n\
    \ == 6 {\n        return p + 5\n    }\n    if n == 7 {\n        return p + 6\n\
    \    }\n    if n == 8 {\n        return p + 7\n    }\n    if n == 9 {\n      \
    \  return p + 8\n    }\n    if n == 10 {\n        return p + 9\n    }\n    if\
    \ n == 11 {\n        return p + 10\n    }\n    if n == 12 {\n        return p\
    \ + 11\n    }\n    if n == 13 {\n        return p + 12\n    }\n    if n == 14\
    \ {\n        return p + 13\n    }\n    if n == 15 {\n        return p + 14\n \
    \   }\n    if n == 16 {\n        return p + 15\n    }\n    if n == 17 {\n    \
    \    return p + 16\n    }\n    if n == 18 {\n        return p + 17\n    }\n  \
    \  if n == 19 {\n        return p + 18\n    }\n    if n == 20 {\n        return\
    \ p + 19\n    }\n    if n == 21 {\n        return p + 20\n    }\n    if n == 22\
    \ {\n        return p + 21\n    }\n    if n == 23 {\n        return p + 22\n \
    \   }\n    if n == 24 {\n        return p + 23\n    }\n    if n == 25 {\n    \
    \    return p + 24\n    }\n    if n == 26 {\n        return p + 25\n    }\n  \
    \  if n == 27 {\n        return p + 26\n    }\n    if n == 28 {\n        return\
    \ p + 27\n    }\n    if n == 29 {\n        return p + 28\n    }\n    if n == 30\
    \ {\n        return p + 29\n    }\n    if n == 31 {\n        return p + 30\n \
    \   }\n    if n == 32 {\n        return p + 31\n    }\n    if n == 33 {\n    \
    \    return p + 32\n    }\n    if n == 34 {\n        return p + 33\n    }\n  \
    \  if n == 35 {\n        return p + 34\n    }\n    if n == 36 {\n        return\
    \ p + 35\n    }\n    if n == 37 {\n        return p + 36\n\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpjm3eep81.swift:164:31: error: expected '}' at end of brace statement\n\
    assert(modp(n: 31, p: 5) == 3)\n                              ^\n/tmp/tmpjm3eep81.swift:13:34:\
    \ note: to match this opening '{'\nfunc modp(n: Int, p: Int) -> Int {\n      \
    \                           ^\n/tmp/tmpjm3eep81.swift:15:20: error: missing argument\
    \ labels 'n:p:' in call\n        return modp(abs(n), p)\n                   ^\n\
    \                    n:      p: \n/tmp/tmpjm3eep81.swift:18:20: error: missing\
    \ argument labels 'n:p:' in call\n        return modp(n - abs(p), p)\n       \
    \            ^\n                    n:          p: \n/tmp/tmpjm3eep81.swift:27:20:\
    \ error: missing argument labels 'n:p:' in call\n        return modp(n - p, p)\n\
    \                   ^\n                    n:     p: \n/tmp/tmpjm3eep81.swift:30:20:\
    \ error: missing argument labels 'n:p:' in call\n        return modp(n, p)\n \
    \                  ^\n                    n: p: \n/tmp/tmpjm3eep81.swift:146:6:\
    \ error: operator functions can only be declared at global or in type scope\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660014751
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    if n < 0 {\n        return modp(abs(n), p)\n    }\n    if p < 0 {\n \
    \       return modp(n - abs(p), p)\n    }\n    if n == 0 {\n        return 0\n\
    \    }\n    if p == 0 {\n        return n\n    }\n    if n == p {\n        return\
    \ n\n    }\n    if n == 0 {\n        return p\n    }\n    if p == 0 {\n      \
    \  return n\n    }\n    if n == p {\n        return n\n    }\n    if n == 0 {\n\
    \        return p\n    }\n    if p == 0 {\n        return n\n    }\n    if n ==\
    \ p {\n        return n\n    }\n    if n == 0 {\n        return p\n    }\n   \
    \ if p == 0 {\n        return n\n    }\n    if n == p {\n        return n\n  \
    \  }\n    if n == 0 {\n        return p\n    }\n    if p == 0 {\n        return\
    \ n\n    }\n    if n == p {\n        return n\n    }\n    if n == 0 {\n      \
    \  return p\n    }\n    if p == 0 {\n        return n\n    }\n    if n == p {\n\
    \        return n\n    }\n    if n == 0 {\n        return p\n    }\n    if p ==\
    \ 0 {\n        return n\n    }\n    if n == p {\n        return n\n    }\n   \
    \ if n == 0 {\n        return p\n    }\n    if p == 0 {\n        return n\n  \
    \  }\n    if n == p {\n        return n\n    }\n    if n == 0 {\n        return\
    \ p\n    }\n    if p == 0 {\n        return n\n    }\n    if n == p {\n      \
    \  return n\n    }\n    if n == 0 {\n        return p\n    }\n    if p == 0 {\n\
    \        return n\n    }\n    if n == p {\n        return n\n    }\n    if n ==\
    \ 0 {\n        return p\n    }\n    if p == 0 {\n        return n\n    }\n   \
    \ if n == p {\n        return n\n    }\n    if n == 0 {\n        return p\n  \
    \  }\n    if p == 0 {\n        return n\n    }\n    if n == p {\n        return\
    \ n\n    }\n    if n == 0 {\n        return p\n    }\n    if p == 0 {\n      \
    \  return n\n    }\n    if n == p {\n        return n\n    }\n    if n == 0 {\n\
    \        return p\n    }\n    if p == 0 {\n        return n\n    }\n    if n ==\
    \ p {\n        return n\n    }\n    if n == 0 {\n        return p\n    }\n   \
    \ if p == 0 {\n        return n\n    }\n    if n == p {\n        return n\n  \
    \  }\n    if n == 0 {\n        return p\n    }\n    if p == 0 {\n        return\
    \ n\n    }\n    if n == p {\n        return n\n    }\n    if n == 0 {\n      \
    \  return p\n    }\n    if p == 0 {\n        return n\n    }\n    if n == p {\n\
    \        return n\n    }\n    if n == 0 {\n        return p\n\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp3plfrkjq.swift:197:31: error: expected '}' at end of brace statement\n\
    assert(modp(n: 31, p: 5) == 3)\n                              ^\n/tmp/tmp3plfrkjq.swift:13:34:\
    \ note: to match this opening '{'\nfunc modp(n: Int, p: Int) -> Int {\n      \
    \                           ^\n/tmp/tmp3plfrkjq.swift:15:20: error: missing argument\
    \ labels 'n:p:' in call\n        return modp(abs(n), p)\n                   ^\n\
    \                    n:      p: \n/tmp/tmp3plfrkjq.swift:18:20: error: missing\
    \ argument labels 'n:p:' in call\n        return modp(n - abs(p), p)\n       \
    \            ^\n                    n:          p: \n/tmp/tmp3plfrkjq.swift:179:6:\
    \ error: operator functions can only be declared at global or in type scope\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660014751
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n\tif n < 0 {\n\t\tpanic(\"modp: negative number\")\n\t}\n\tif p < 0 {\n\t\
    \tpanic(\"modp: negative modulus\")\n\t}\n\tif n == 0 {\n\t\treturn 0\n\t}\n\t\
    if n == 1 {\n\t\treturn p\n\t}\n\tif p > p {\n\t\tpanic(\"modp: modulus is too\
    \ large\")\n\t}\n\tif p < p {\n\t\treturn 0\n\t}\n\tr := p\n\tfor i := 0; i <\
    \ n; i++ {\n\t\tr = r * p % p\n\t}\n\treturn r\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp8m_1ll71.swift:32:3: error: consecutive statements on a line must\
    \ be separated by ';'\n        r := p\n         ^\n         ;\n/tmp/tmp8m_1ll71.swift:32:4:\
    \ error: expected expression\n        r := p\n          ^\n/tmp/tmp8m_1ll71.swift:33:9:\
    \ error: expected type\n        for i := 0; i < n; i++ {\n               ^\n \
    \               <#type#>\n/tmp/tmp8m_1ll71.swift:33:9: error: expected 'in' after\
    \ for-each pattern\n        for i := 0; i < n; i++ {\n               ^\n/tmp/tmp8m_1ll71.swift:33:9:\
    \ error: expected Sequence expression for for-each loop\n        for i := 0; i\
    \ < n; i++ {\n               ^\n/tmp/tmp8m_1ll71.swift:15:3: error: cannot find\
    \ 'panic' in scope\n                panic(\"modp: negative number\")\n       \
    \         ^~~~~\n/tmp/tmp8m_1ll71.swift:18:3: error: cannot find 'panic' in scope\n\
    \                panic(\"modp: negative modulus\")\n                ^~~~~\n/tmp/tmp8m_1ll71.swift:27:3:\
    \ error: cannot find 'panic' in scope\n                panic(\"modp: modulus is\
    \ too large\")\n                ^~~~~\n/tmp/tmp8m_1ll71.swift:32:2: error: cannot\
    \ find 'r' in scope\n        r := p\n        ^\n/tmp/tmp8m_1ll71.swift:36:9: error:\
    \ cannot find 'r' in scope\n        return r\n               ^\n"
  stdout: ''
  timestamp: 1660014751
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n\tif n < 0 {\n\t\tpanic(\"modp called with negative n\")\n\t}\n\tif p < 0\
    \ {\n\t\tpanic(\"modp called with negative p\")\n\t}\n\tif n == 0 || p == 0 {\n\
    \t\treturn 0\n\t}\n\tif n == 1 {\n\t\treturn p\n\t}\n\tif p == 1 {\n\t\treturn\
    \ n\n\t}\n\tn -= p - 1\n\tif n == 0 {\n\t\treturn p\n\t}\n\treturn modp(n - 1,\
    \ p) + p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpf88y2g_y.swift:15:3: error: cannot find 'panic' in scope\n    \
    \            panic(\"modp called with negative n\")\n                ^~~~~\n/tmp/tmpf88y2g_y.swift:18:3:\
    \ error: cannot find 'panic' in scope\n                panic(\"modp called with\
    \ negative p\")\n                ^~~~~\n/tmp/tmpf88y2g_y.swift:29:4: error: left\
    \ side of mutating operator isn't mutable: 'n' is a 'let' constant\n        n\
    \ -= p - 1\n        ~ ^\n/tmp/tmpf88y2g_y.swift:33:13: error: missing argument\
    \ labels 'n:p:' in call\n        return modp(n - 1, p) + p\n                 \
    \  ^\n                    n:     p: \n"
  stdout: ''
  timestamp: 1660014751
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    if n < 0 {\n        return modp(-n, p)\n    }\n    if p < 2 {\n     \
    \   return n\n    }\n    if p < p {\n        return modp(n - p, p)\n    }\n  \
    \  if p < p {\n        return modp(n, p - 2)\n    }\n    return modp(n, p - 1)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpqrw0ij8l.swift:15:20: error: missing argument labels 'n:p:' in\
    \ call\n        return modp(-n, p)\n                   ^\n                   \
    \ n:  p: \n/tmp/tmpqrw0ij8l.swift:21:20: error: missing argument labels 'n:p:'\
    \ in call\n        return modp(n - p, p)\n                   ^\n             \
    \       n:     p: \n/tmp/tmpqrw0ij8l.swift:24:20: error: missing argument labels\
    \ 'n:p:' in call\n        return modp(n, p - 2)\n                   ^\n      \
    \              n: p: \n/tmp/tmpqrw0ij8l.swift:26:16: error: missing argument labels\
    \ 'n:p:' in call\n    return modp(n, p - 1)\n               ^\n              \
    \  n: p: \n"
  stdout: ''
  timestamp: 1660014751
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    if n < 0 {\n        return modp(-n, p)\n    }\n    if p < 2 {\n     \
    \   return n\n    }\n    if p > p {\n        return modp(n, p - 2)\n    }\n  \
    \  if n == 0 {\n        return 0\n    }\n    if n == 1 {\n        return p\n \
    \   }\n    if n == p {\n        return n\n    }\n    if n == p {\n        return\
    \ p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n      \
    \  return p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n\
    \        return p\n    }\n    if n == p {\n        return p\n    }\n    if n ==\
    \ p {\n        return p\n    }\n    if n == p {\n        return p\n    }\n   \
    \ if n == p {\n        return p\n    }\n    if n == p {\n        return p\n  \
    \  }\n    if n == p {\n        return p\n    }\n    if n == p {\n        return\
    \ p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n      \
    \  return p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n\
    \        return p\n    }\n    if n == p {\n        return p\n    }\n    if n ==\
    \ p {\n        return p\n    }\n    if n == p {\n        return p\n    }\n   \
    \ if n == p {\n        return p\n    }\n    if n == p {\n        return p\n  \
    \  }\n    if n == p {\n        return p\n    }\n    if n == p {\n        return\
    \ p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n      \
    \  return p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n\
    \        return p\n    }\n    if n == p {\n        return p\n    }\n    if n ==\
    \ p {\n        return p\n    }\n    if n == p {\n        return p\n    }\n   \
    \ if n == p {\n        return p\n    }\n    if n == p {\n        return p\n  \
    \  }\n    if n == p {\n        return p\n    }\n    if n == p {\n        return\
    \ p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n      \
    \  return p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n\
    \        return p\n    }\n    if n == p {\n        return p\n    }\n    if n ==\
    \ p {\n        return p\n    }\n    if n == p {\n        return p\n    }\n   \
    \ if n == p {\n        return p\n    }\n    if n == p {\n        return p\n  \
    \  }\n    if n == p {\n        return p\n    }\n    if n == p {\n        return\
    \ p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n      \
    \  return p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n\
    \        return p\n    }\n    if n == p {\n        return p\n    }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp6h6zj828.swift:15:20: error: missing argument labels 'n:p:' in\
    \ call\n        return modp(-n, p)\n                   ^\n                   \
    \ n:  p: \n/tmp/tmp6h6zj828.swift:21:20: error: missing argument labels 'n:p:'\
    \ in call\n        return modp(n, p - 2)\n                   ^\n             \
    \       n: p: \n"
  stdout: ''
  timestamp: 1660014751
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n\tassert(n >= 0)\n\tassert(p >= 0)\n\tassert(n <= p)\n\t\n\tlet mut result\
    \ = 1\n\t\n\twhile n > 0 {\n\t\tlet r = n % p\n\t\t\n\t\tresult = result * r +\
    \ p\n\t\tn = n / p\n\t}\n\t\n\treturn result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpn_9lvcnr.swift:18:10: error: found an unexpected second identifier\
    \ in constant declaration; is there an accidental break?\n        let mut result\
    \ = 1\n                ^\n/tmp/tmpn_9lvcnr.swift:18:10: note: join the identifiers\
    \ together\n        let mut result = 1\n            ~~~~^~~~~~\n            mutresult\n\
    /tmp/tmpn_9lvcnr.swift:18:10: note: join the identifiers together with camel-case\n\
    \        let mut result = 1\n            ~~~~^~~~~~\n            mutResult\n/tmp/tmpn_9lvcnr.swift:23:3:\
    \ error: cannot find 'result' in scope\n                result = result * r +\
    \ p\n                ^~~~~~\n/tmp/tmpn_9lvcnr.swift:23:12: error: cannot find\
    \ 'result' in scope\n                result = result * r + p\n               \
    \          ^~~~~~\n/tmp/tmpn_9lvcnr.swift:24:3: error: cannot assign to value:\
    \ 'n' is a 'let' constant\n                n = n / p\n                ^\n/tmp/tmpn_9lvcnr.swift:27:9:\
    \ error: cannot find 'result' in scope\n        return result\n              \
    \ ^~~~~~\n"
  stdout: ''
  timestamp: 1660014751
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    if n < 0 {\n        return modp(abs(n), p)\n    }\n    if p < 0 {\n \
    \       return modp(n - abs(p), p)\n    }\n    if n == 0 {\n        return 0\n\
    \    }\n    if p == 0 {\n        return n\n    }\n    if p > n {\n        return\
    \ modp(n - p, p)\n    }\n    if p < n {\n        return modp(n - abs(p), p)\n\
    \    }\n    return modp(n - abs(n), p)\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpno9f4_g_.swift:15:20: error: missing argument labels 'n:p:' in\
    \ call\n        return modp(abs(n), p)\n                   ^\n               \
    \     n:      p: \n/tmp/tmpno9f4_g_.swift:18:20: error: missing argument labels\
    \ 'n:p:' in call\n        return modp(n - abs(p), p)\n                   ^\n \
    \                   n:          p: \n/tmp/tmpno9f4_g_.swift:27:20: error: missing\
    \ argument labels 'n:p:' in call\n        return modp(n - p, p)\n            \
    \       ^\n                    n:     p: \n/tmp/tmpno9f4_g_.swift:30:20: error:\
    \ missing argument labels 'n:p:' in call\n        return modp(n - abs(p), p)\n\
    \                   ^\n                    n:          p: \n/tmp/tmpno9f4_g_.swift:32:16:\
    \ error: missing argument labels 'n:p:' in call\n    return modp(n - abs(n), p)\n\
    \               ^\n                n:          p: \n"
  stdout: ''
  timestamp: 1660014751
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n\tswitch {\n\tcase n < 0:\n\t\treturn modp(abs(n), p)\n\tcase n >= p:\n\t\
    \treturn 0\n\tdefault:\n\t\treturn n & (p - 1)\n\t}\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\n\
    assert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp7m76obqu.swift:14:9: error: expected expression in 'switch' statement\n\
    \        switch {\n               ^\n/tmp/tmp7m76obqu.swift:16:14: error: missing\
    \ argument labels 'n:p:' in call\n                return modp(abs(n), p)\n   \
    \                        ^\n                            n:      p: \n"
  stdout: ''
  timestamp: 1660014751
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    return n % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3,\
    \ p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) ==\
    \ 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmpoanpw3il/tmpoanpw3il.swift:31: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b66666e9c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b66663e0b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b66663e0988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b66663df7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpoanpw3il                        0x00005638db6472cd <unavailable> + 4813

    5    libc.so.6                          0x00002b66668d5460 __libc_start_main +
    245

    6    tmpoanpw3il                        0x00005638db646ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014751
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n\tswitch {\n\tcase n < 0 || p < 0 || p > n:\n\t\tpanic(\"modp: invalid arguments\"\
    )\n\tcase n == p:\n\t\treturn n\n\tcase n == 0 || p == 0:\n\t\treturn 0\n\tcase\
    \ p == n:\n\t\treturn 1\n\tdefault:\n\t\tswitch {\n\t\tcase p < n:\n\t\t\treturn\
    \ modp(n - p, p)\n\t\tcase p > n:\n\t\t\treturn modp(n, p - n)\n\t\t}\n\t}\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpyrc2ymwt.swift:14:9: error: expected expression in 'switch' statement\n\
    \        switch {\n               ^\n/tmp/tmpyrc2ymwt.swift:24:10: error: expected\
    \ expression in 'switch' statement\n                switch {\n               \
    \        ^\n/tmp/tmpyrc2ymwt.swift:16:3: error: cannot find 'panic' in scope\n\
    \                panic(\"modp: invalid arguments\")\n                ^~~~~\n/tmp/tmpyrc2ymwt.swift:26:15:\
    \ error: missing argument labels 'n:p:' in call\n                        return\
    \ modp(n - p, p)\n                                   ^\n                     \
    \               n:     p: \n/tmp/tmpyrc2ymwt.swift:28:15: error: missing argument\
    \ labels 'n:p:' in call\n                        return modp(n, p - n)\n     \
    \                              ^\n                                    n: p: \n"
  stdout: ''
  timestamp: 1660014751
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n\tif n < 0 {\n\t\tpanic(\"modp: negative number\")\n\t}\n\tif p < 1 {\n\t\
    \tpanic(\"modp: positive number\")\n\t}\n\tif n == 0 {\n\t\treturn 1\n\t}\n\t\
    if n == 1 {\n\t\treturn p\n\t}\n\tif p < 2 {\n\t\treturn 0\n\t}\n\tif p > p {\n\
    \t\treturn 0\n\t}\n\tx := n\n\ty := p\n\tz := 1\n\tfor {\n\t\tif y > z {\n\t\t\
    \ty -= z\n\t\t\tx %= y\n\t\t\tif x == 0 {\n\t\t\t\treturn x\n\t\t\t}\n\t\t\tz\
    \ = y\n\t\t} else {\n\t\t\tx %= z\n\t\t\tif x == 0 {\n\t\t\t\treturn x\n\t\t\t\
    }\n\t\t\tz = y\n\t\t}\n\t}\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3,\
    \ p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) ==\
    \ 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmph1n12kgq.swift:32:3: error: consecutive statements on a line must\
    \ be separated by ';'\n        x := n\n         ^\n         ;\n/tmp/tmph1n12kgq.swift:32:4:\
    \ error: expected expression\n        x := n\n          ^\n/tmp/tmph1n12kgq.swift:35:6:\
    \ error: expected pattern\n        for {\n            ^\n/tmp/tmph1n12kgq.swift:35:6:\
    \ error: expected Sequence expression for for-each loop\n        for {\n     \
    \       ^\n/tmp/tmph1n12kgq.swift:15:3: error: cannot find 'panic' in scope\n\
    \                panic(\"modp: negative number\")\n                ^~~~~\n/tmp/tmph1n12kgq.swift:18:3:\
    \ error: cannot find 'panic' in scope\n                panic(\"modp: positive\
    \ number\")\n                ^~~~~\n/tmp/tmph1n12kgq.swift:32:2: error: cannot\
    \ find 'x' in scope\n        x := n\n        ^\n"
  stdout: ''
  timestamp: 1660014751
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n\tif n < 0 {\n\t\tpanic(\"modp(n: Int, p: Int): n must be positive\")\n\t\
    }\n\tif p < 1 {\n\t\tpanic(\"modp(n: Int, p: Int): p must be positive\")\n\t}\n\
    \tif n == 0 {\n\t\treturn 1\n\t}\n\tif n == 1 {\n\t\treturn p\n\t}\n\tif n ==\
    \ p {\n\t\treturn n\n\t}\n\tif p > p {\n\t\tpanic(\"modp(n: Int, p: Int): p must\
    \ be smaller than p\")\n\t}\n\tx := n\n\ty := p\n\tt := 0\n\twhile x > 0 {\n\t\
    \tt += y\n\t\tx -= y\n\t\ty <<= 1\n\t}\n\treturn t\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\n\
    assert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpl_57v3ed.swift:32:3: error: consecutive statements on a line must\
    \ be separated by ';'\n        x := n\n         ^\n         ;\n/tmp/tmpl_57v3ed.swift:32:4:\
    \ error: expected expression\n        x := n\n          ^\n/tmp/tmpl_57v3ed.swift:15:3:\
    \ error: cannot find 'panic' in scope\n                panic(\"modp(n: Int, p:\
    \ Int): n must be positive\")\n                ^~~~~\n/tmp/tmpl_57v3ed.swift:18:3:\
    \ error: cannot find 'panic' in scope\n                panic(\"modp(n: Int, p:\
    \ Int): p must be positive\")\n                ^~~~~\n/tmp/tmpl_57v3ed.swift:30:3:\
    \ error: cannot find 'panic' in scope\n                panic(\"modp(n: Int, p:\
    \ Int): p must be smaller than p\")\n                ^~~~~\n/tmp/tmpl_57v3ed.swift:32:2:\
    \ error: cannot find 'x' in scope\n        x := n\n        ^\n/tmp/tmpl_57v3ed.swift:35:8:\
    \ error: cannot find 'x' in scope\n        while x > 0 {\n              ^\n/tmp/tmpl_57v3ed.swift:36:3:\
    \ error: cannot find 't' in scope\n                t += y\n                ^\n\
    /tmp/tmpl_57v3ed.swift:36:8: error: cannot find 'y' in scope\n               \
    \ t += y\n                     ^\n/tmp/tmpl_57v3ed.swift:37:3: error: cannot find\
    \ 'x' in scope\n                x -= y\n                ^\n/tmp/tmpl_57v3ed.swift:37:8:\
    \ error: cannot find 'y' in scope\n                x -= y\n                  \
    \   ^\n/tmp/tmpl_57v3ed.swift:38:3: error: cannot find 'y' in scope\n        \
    \        y <<= 1\n                ^\n/tmp/tmpl_57v3ed.swift:38:5: error: type\
    \ of expression is ambiguous without more context\n                y <<= 1\n \
    \               ~~^~~~~\n/tmp/tmpl_57v3ed.swift:40:9: error: cannot find 't' in\
    \ scope\n        return t\n               ^\n"
  stdout: ''
  timestamp: 1660014751
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n\tif n < 0 {\n\t\tpanic(\"modp requires n >= 0\")\n\t}\n\tif p < 1 {\n\t\t\
    panic(\"modp requires p >= 1\")\n\t}\n\tif n == 0 {\n\t\treturn 1\n\t}\n\tif n\
    \ == 1 {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\treturn modp(n\
    \ - 1, p) * p + p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpumpg9c5w.swift:15:3: error: cannot find 'panic' in scope\n    \
    \            panic(\"modp requires n >= 0\")\n                ^~~~~\n/tmp/tmpumpg9c5w.swift:18:3:\
    \ error: cannot find 'panic' in scope\n                panic(\"modp requires p\
    \ >= 1\")\n                ^~~~~\n/tmp/tmpumpg9c5w.swift:29:13: error: missing\
    \ argument labels 'n:p:' in call\n        return modp(n - 1, p) * p + p\n    \
    \               ^\n                    n:     p: \n"
  stdout: ''
  timestamp: 1660014751
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n\tif n < 0 {\n\t\tpanic(\"modp(n,p)\")\n\t}\n\tif p < 1 {\n\t\tpanic(\"modp(n,p)\"\
    )\n\t}\n\tif n == 0 {\n\t\treturn 1\n\t}\n\tif n == 1 {\n\t\treturn p\n\t}\n\t\
    if p == 1 {\n\t\treturn n\n\t}\n\tr := n % p\n\tif r == 0 {\n\t\treturn n\n\t\
    }\n\treturn p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp0u9isd3t.swift:29:3: error: consecutive statements on a line must\
    \ be separated by ';'\n        r := n % p\n         ^\n         ;\n/tmp/tmp0u9isd3t.swift:29:4:\
    \ error: expected expression\n        r := n % p\n          ^\n/tmp/tmp0u9isd3t.swift:15:3:\
    \ error: cannot find 'panic' in scope\n                panic(\"modp(n,p)\")\n\
    \                ^~~~~\n/tmp/tmp0u9isd3t.swift:18:3: error: cannot find 'panic'\
    \ in scope\n                panic(\"modp(n,p)\")\n                ^~~~~\n/tmp/tmp0u9isd3t.swift:29:2:\
    \ error: cannot find 'r' in scope\n        r := n % p\n        ^\n/tmp/tmp0u9isd3t.swift:30:5:\
    \ error: cannot find 'r' in scope\n        if r == 0 {\n           ^\n"
  stdout: ''
  timestamp: 1660014751
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n\tif n < 0 {\n\t\tpanic(\"modp: negative number\")\n\t}\n\tif p < 0 {\n\t\
    \tpanic(\"modp: negative modulus\")\n\t}\n\tif n == 0 {\n\t\treturn 1\n\t}\n\t\
    if p == 1 {\n\t\treturn n\n\t}\n\tif p > n {\n\t\tpanic(\"modp: modulus is greater\
    \ than the number\")\n\t}\n\tx := n\n\ty := p\n\tfor y != 1 {\n\t\tif y & 1 ==\
    \ 1 {\n\t\t\tx -= x\n\t\t}\n\t\ty >>= 1\n\t}\n\treturn x\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp8qwrrpce.swift:29:3: error: consecutive statements on a line must\
    \ be separated by ';'\n        x := n\n         ^\n         ;\n/tmp/tmp8qwrrpce.swift:29:4:\
    \ error: expected expression\n        x := n\n          ^\n/tmp/tmp8qwrrpce.swift:31:8:\
    \ error: expected 'in' after for-each pattern\n        for y != 1 {\n        \
    \      ^\n/tmp/tmp8qwrrpce.swift:31:8: error: unary operator cannot be separated\
    \ from its operand\n        for y != 1 {\n              ^ ~\n                \n\
    /tmp/tmp8qwrrpce.swift:15:3: error: cannot find 'panic' in scope\n           \
    \     panic(\"modp: negative number\")\n                ^~~~~\n/tmp/tmp8qwrrpce.swift:18:3:\
    \ error: cannot find 'panic' in scope\n                panic(\"modp: negative\
    \ modulus\")\n                ^~~~~\n/tmp/tmp8qwrrpce.swift:27:3: error: cannot\
    \ find 'panic' in scope\n                panic(\"modp: modulus is greater than\
    \ the number\")\n                ^~~~~\n/tmp/tmp8qwrrpce.swift:29:2: error: cannot\
    \ find 'x' in scope\n        x := n\n        ^\n/tmp/tmp8qwrrpce.swift:31:8: error:\
    \ '!=' is not a prefix unary operator\n        for y != 1 {\n              ^\n\
    /tmp/tmp8qwrrpce.swift:37:9: error: cannot find 'x' in scope\n        return x\n\
    \               ^\n"
  stdout: ''
  timestamp: 1660014751
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n\tif n < 0 {\n\t\tpanic(\"modp requires positive n\")\n\t}\n\tif p < 1 {\n\
    \t\tpanic(\"modp requires positive p\")\n\t}\n\tif n == 0 {\n\t\treturn 1\n\t\
    }\n\tif n == 1 {\n\t\treturn p\n\t}\n\tif p < 2 {\n\t\treturn 0\n\t}\n\tif p >\
    \ p {\n\t\treturn 0\n\t}\n\tq := p\n\tfor {\n\t\tq /= 2\n\t\tif q == 1 {\n\t\t\
    \treturn n\n\t\t}\n\t\tif q > n {\n\t\t\treturn 0\n\t\t}\n\t}\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: SyntaxError
  stderr: "/tmp/tmppf8h9sb8.swift:32:3: error: consecutive statements on a line must\
    \ be separated by ';'\n        q := p\n         ^\n         ;\n/tmp/tmppf8h9sb8.swift:32:4:\
    \ error: expected expression\n        q := p\n          ^\n/tmp/tmppf8h9sb8.swift:33:6:\
    \ error: expected pattern\n        for {\n            ^\n/tmp/tmppf8h9sb8.swift:33:6:\
    \ error: expected Sequence expression for for-each loop\n        for {\n     \
    \       ^\n/tmp/tmppf8h9sb8.swift:15:3: error: cannot find 'panic' in scope\n\
    \                panic(\"modp requires positive n\")\n                ^~~~~\n\
    /tmp/tmppf8h9sb8.swift:18:3: error: cannot find 'panic' in scope\n           \
    \     panic(\"modp requires positive p\")\n                ^~~~~\n/tmp/tmppf8h9sb8.swift:32:2:\
    \ error: cannot find 'q' in scope\n        q := p\n        ^\n"
  stdout: ''
  timestamp: 1660014751
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n\tif n < 0 {\n\t\tpanic(\"modp: negative number\")\n\t}\n\tif p < 0 {\n\t\
    \tpanic(\"modp: negative modulus\")\n\t}\n\tif n == 0 {\n\t\treturn 0\n\t}\n\t\
    if p == 1 {\n\t\treturn n\n\t}\n\tif p > n {\n\t\tpanic(\"modp: modulus is too\
    \ large\")\n\t}\n\tr := n % p\n\tif r == 0 {\n\t\treturn n\n\t}\n\treturn p -\
    \ r\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n:\
    \ 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11)\
    \ == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmprr6zgkgy.swift:29:3: error: consecutive statements on a line must\
    \ be separated by ';'\n        r := n % p\n         ^\n         ;\n/tmp/tmprr6zgkgy.swift:29:4:\
    \ error: expected expression\n        r := n % p\n          ^\n/tmp/tmprr6zgkgy.swift:15:3:\
    \ error: cannot find 'panic' in scope\n                panic(\"modp: negative\
    \ number\")\n                ^~~~~\n/tmp/tmprr6zgkgy.swift:18:3: error: cannot\
    \ find 'panic' in scope\n                panic(\"modp: negative modulus\")\n \
    \               ^~~~~\n/tmp/tmprr6zgkgy.swift:27:3: error: cannot find 'panic'\
    \ in scope\n                panic(\"modp: modulus is too large\")\n          \
    \      ^~~~~\n/tmp/tmprr6zgkgy.swift:29:2: error: cannot find 'r' in scope\n \
    \       r := n % p\n        ^\n/tmp/tmprr6zgkgy.swift:30:5: error: cannot find\
    \ 'r' in scope\n        if r == 0 {\n           ^\n/tmp/tmprr6zgkgy.swift:33:13:\
    \ error: cannot find 'r' in scope\n        return p - r\n                   ^\n"
  stdout: ''
  timestamp: 1660014751
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n\tif n < 0 {\n\t\tpanic(\"modp: negative number\")\n\t}\n\tif p < 1 {\n\t\
    \tpanic(\"modp: p < 1\")\n\t}\n\tif n == 0 {\n\t\treturn 0\n\t}\n\tif n == 1 {\n\
    \t\treturn p\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif p > p {\n\t\tpanic(\"\
    modp: p > p\")\n\t}\n\tq := p\n\tfor {\n\t\tq /= 2\n\t\tif q == p {\n\t\t\treturn\
    \ q\n\t\t}\n\t\tif q == 1 {\n\t\t\treturn 1\n\t\t}\n\t}\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpfdup616r.swift:32:3: error: consecutive statements on a line must\
    \ be separated by ';'\n        q := p\n         ^\n         ;\n/tmp/tmpfdup616r.swift:32:4:\
    \ error: expected expression\n        q := p\n          ^\n/tmp/tmpfdup616r.swift:33:6:\
    \ error: expected pattern\n        for {\n            ^\n/tmp/tmpfdup616r.swift:33:6:\
    \ error: expected Sequence expression for for-each loop\n        for {\n     \
    \       ^\n/tmp/tmpfdup616r.swift:15:3: error: cannot find 'panic' in scope\n\
    \                panic(\"modp: negative number\")\n                ^~~~~\n/tmp/tmpfdup616r.swift:18:3:\
    \ error: cannot find 'panic' in scope\n                panic(\"modp: p < 1\")\n\
    \                ^~~~~\n/tmp/tmpfdup616r.swift:30:3: error: cannot find 'panic'\
    \ in scope\n                panic(\"modp: p > p\")\n                ^~~~~\n/tmp/tmpfdup616r.swift:32:2:\
    \ error: cannot find 'q' in scope\n        q := p\n        ^\n"
  stdout: ''
  timestamp: 1660014751
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n\tif n < 0 {\n\t\tpanic(\"modp: negative number\")\n\t}\n\tif p < 1 {\n\t\
    \tpanic(\"modp: p < 1\")\n\t}\n\tif n == 0 {\n\t\treturn 0\n\t}\n\tif n == 1 {\n\
    \t\treturn p\n\t}\n\tq := p / n\n\tr := p % n\n\treturn q * n + r\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp88r8coru.swift:26:3: error: consecutive statements on a line must\
    \ be separated by ';'\n        q := p / n\n         ^\n         ;\n/tmp/tmp88r8coru.swift:26:4:\
    \ error: expected expression\n        q := p / n\n          ^\n/tmp/tmp88r8coru.swift:15:3:\
    \ error: cannot find 'panic' in scope\n                panic(\"modp: negative\
    \ number\")\n                ^~~~~\n/tmp/tmp88r8coru.swift:18:3: error: cannot\
    \ find 'panic' in scope\n                panic(\"modp: p < 1\")\n            \
    \    ^~~~~\n/tmp/tmp88r8coru.swift:26:2: error: cannot find 'q' in scope\n   \
    \     q := p / n\n        ^\n/tmp/tmp88r8coru.swift:28:9: error: cannot find 'q'\
    \ in scope\n        return q * n + r\n               ^\n/tmp/tmp88r8coru.swift:28:17:\
    \ error: cannot find 'r' in scope\n        return q * n + r\n                \
    \       ^\n"
  stdout: ''
  timestamp: 1660014751
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    if n < 0 {\n        return modp(Int(-n), p)\n    }\n    if p < 0 {\n\
    \        return modp(Int(n), Int(-p))\n    }\n    if p > n {\n        return modp(Int(n),\
    \ Int(p))\n    }\n    if n == 0 {\n        return 0\n    }\n    if p == 0 {\n\
    \        return n\n    }\n    if p == 1 {\n        return n\n    }\n    if n ==\
    \ 1 {\n        return p\n    }\n    if n == p {\n        return modp(n - 1, p)\n\
    \    }\n    if n == p - 1 {\n        return modp(n, p)\n    }\n    if n == p -\
    \ 2 {\n        return modp(n - 1, p)\n    }\n    if n == p - 3 {\n        return\
    \ modp(n, p)\n    }\n    if n == p - 4 {\n        return modp(n - 1, p)\n    }\n\
    \    if n == p - 5 {\n        return modp(n, p)\n    }\n    if n == p - 6 {\n\
    \        return modp(n - 1, p)\n    }\n    if n == p - 7 {\n        return modp(n,\
    \ p)\n    }\n    if n == p - 8 {\n        return modp(n - 1, p)\n    }\n    if\
    \ n == p - 9 {\n        return modp(n, p)\n    }\n    if n == p - 10 {\n     \
    \   return modp(n - 1, p)\n    }\n    if n == p - 11 {\n        return modp(n,\
    \ p)\n    }\n    if n == p - 12 {\n        return modp(n - 1, p)\n    }\n    if\
    \ n == p - 13 {\n        return modp(n, p)\n    }\n    if n == p - 14 {\n    \
    \    return modp(n - 1, p)\n    }\n    if n == p - 15 {\n        return modp(n,\
    \ p)\n    }\n    if n == p - 16 {\n        return modp(n - 1, p)\n    }\n    if\
    \ n == p - 17 {\n        return modp(n, p)\n    }\n    if n == p - 18 {\n    \
    \    return modp(n - 1, p)\n    }\n    if n == p - 19 {\n        return modp(n,\
    \ p)\n    }\n    if n == p - 20 {\n        return modp(n - 1, p)\n    }\n    if\
    \ n == p - 21 {\n        return modp(n, p)\n    }\n    if n == p - 22 {\n    \
    \    return modp(n - 1, p)\n    }\n    if n == p - 23 {\n        return modp(n,\
    \ p)\n    }\n    if n == p - 24 {\n        return modp(n - 1, p)\n    }\n    if\
    \ n == p - 25 {\n        return modp(n, p)\n    }\n    if n == p - 26 {\n    \
    \    return modp(n - 1, p)\n    }\n    if n == p - 27 {\n        return modp(n,\
    \ p)\n    }\n    if n == p - 28 {\n        return modp(n - 1, p)\n    }\n    if\
    \ n == p - 29 {\n        return modp(n, p)\n\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpett8_fh1.swift:146:31: error: expected '}' at end of brace statement\n\
    assert(modp(n: 31, p: 5) == 3)\n                              ^\n/tmp/tmpett8_fh1.swift:13:34:\
    \ note: to match this opening '{'\nfunc modp(n: Int, p: Int) -> Int {\n      \
    \                           ^\n/tmp/tmpett8_fh1.swift:15:20: error: missing argument\
    \ labels 'n:p:' in call\n        return modp(Int(-n), p)\n                   ^\n\
    \                    n:       p: \n/tmp/tmpett8_fh1.swift:18:20: error: missing\
    \ argument labels 'n:p:' in call\n        return modp(Int(n), Int(-p))\n     \
    \              ^\n                    n:      p: \n/tmp/tmpett8_fh1.swift:21:20:\
    \ error: missing argument labels 'n:p:' in call\n        return modp(Int(n), Int(p))\n\
    \                   ^\n                    n:      p: \n/tmp/tmpett8_fh1.swift:36:20:\
    \ error: missing argument labels 'n:p:' in call\n        return modp(n - 1, p)\n\
    \                   ^\n                    n:     p: \n/tmp/tmpett8_fh1.swift:39:20:\
    \ error: missing argument labels 'n:p:' in call\n        return modp(n, p)\n \
    \                  ^\n                    n: p: \n/tmp/tmpett8_fh1.swift:42:20:\
    \ error: missing argument labels 'n:p:' in call\n        return modp(n - 1, p)\n\
    \                   ^\n                    n:     p: \n/tmp/tmpett8_fh1.swift:45:20:\
    \ error: missing argument labels 'n:p:' in call\n        return modp(n, p)\n \
    \                  ^\n                    n: p: \n/tmp/tmpett8_fh1.swift:48:20:\
    \ error: missing argument labels 'n:p:' in call\n        return modp(n - 1, p)\n\
    \                   ^\n                    n:     p: \n/tmp/tmpett8_fh1.swift:51:20:\
    \ error: missing argument labels 'n:p:' in call\n        return modp(n, p)\n \
    \                  ^\n                    n: p: \n/tmp/tmpett8_fh1.swift:54:20:\
    \ error: missing argument labels 'n:p:' in call\n        return modp(n - 1, p)\n\
    \                   ^\n                    n:     p: \n/tmp/tmpett8_fh1.swift:57:20:\
    \ error: missing argument labels 'n:p:' in call\n        return modp(n, p)\n \
    \                  ^\n                    n: p: \n/tmp/tmpett8_fh1.swift:60:20:\
    \ error: missing argume"
  stdout: ''
  timestamp: 1660014751
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n\tlet r = n % p\n\tif r == 0 {\n\t\treturn n\n\t}\n\treturn r\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmpno7dwpla/tmpno7dwpla.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aea9b1a3c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aea9ae9ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aea9ae9a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aea9ae997b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpno7dwpla                        0x000056139f6412cd <unavailable> + 4813

    5    libc.so.6                          0x00002aea9b38f460 __libc_start_main +
    245

    6    tmpno7dwpla                        0x000056139f640ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014750
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n\tswitch {\n\tcase n < 0:\n\t\treturn modp(abs(n), p)\n\tcase p < 0:\n\t\t\
    return modp(-n, p)\n\tcase n >= p:\n\t\treturn n\n\tdefault:\n\t\treturn n % p\n\
    \t}\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n:\
    \ 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11)\
    \ == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp1pnr69xs.swift:14:9: error: expected expression in 'switch' statement\n\
    \        switch {\n               ^\n/tmp/tmp1pnr69xs.swift:16:14: error: missing\
    \ argument labels 'n:p:' in call\n                return modp(abs(n), p)\n   \
    \                        ^\n                            n:      p: \n/tmp/tmp1pnr69xs.swift:18:14:\
    \ error: missing argument labels 'n:p:' in call\n                return modp(-n,\
    \ p)\n                           ^\n                            n:  p: \n"
  stdout: ''
  timestamp: 1660014751
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    if n < 0 {\n        return modp(abs(n), p)\n    }\n    if p < 0 {\n \
    \       return modp(-n, p)\n    }\n    if n == 0 {\n        return 0\n    }\n\
    \    if p == 0 {\n        return n\n    }\n    if p == 1 {\n        return n\n\
    \    }\n    if p == 2 {\n        return n + 1\n    }\n    if p == 3 {\n      \
    \  return n + 2\n    }\n    if p == 4 {\n        return n + 3\n    }\n    if p\
    \ == 5 {\n        return n + 4\n    }\n    if p == 6 {\n        return n + 5\n\
    \    }\n    if p == 7 {\n        return n + 6\n    }\n    if p == 8 {\n      \
    \  return n + 7\n    }\n    if p == 9 {\n        return n + 8\n    }\n    if p\
    \ == 10 {\n        return n + 9\n    }\n    if p == 11 {\n        return n + 10\n\
    \    }\n    if p == 12 {\n        return n + 11\n    }\n    if p == 13 {\n   \
    \     return n + 12\n    }\n    if p == 14 {\n        return n + 13\n    }\n \
    \   if p == 15 {\n        return n + 14\n    }\n    if p == 16 {\n        return\
    \ n + 15\n    }\n    if p == 17 {\n        return n + 16\n    }\n    if p == 18\
    \ {\n        return n + 17\n    }\n    if p == 19 {\n        return n + 18\n \
    \   }\n    if p == 20 {\n        return n + 19\n    }\n    if p == 21 {\n    \
    \    return n + 20\n    }\n    if p == 22 {\n        return n + 21\n    }\n  \
    \  if p == 23 {\n        return n + 22\n    }\n    if p == 24 {\n        return\
    \ n + 23\n    }\n    if p == 25 {\n        return n + 24\n    }\n    if p == 26\
    \ {\n        return n + 25\n    }\n    if p == 27 {\n        return n + 26\n \
    \   }\n    if p == 28 {\n        return n + 27\n    }\n    if p == 29 {\n    \
    \    return n + 28\n    }\n    if p == 30 {\n        return n + 29\n    }\n  \
    \  if p == 31 {\n        return n + 30\n    }\n    if p == 32 {\n        return\
    \ n + 31\n    }\n    if p == 33 {\n        return n + 32\n    }\n    if p == 34\
    \ {\n        return n + 33\n    }\n    if p == 35 {\n        return n + 34\n \
    \   }\n    if p == 36 {\n        return n + 35\n    }\n    if p == 37 {\n    \
    \    return n + 36\n    }\n    if p == 38 {\n        return n + 37\n    }\n  \
    \  if p == 39 {\n        return n + 38\n    }\n    if p == 40 {\n        return\
    \ n + 39\n    }\n    if p == 41 {\n        return \n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\n\
    assert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpeuuuvyyw.swift:169:31: error: expected '}' at end of brace statement\n\
    assert(modp(n: 31, p: 5) == 3)\n                              ^\n/tmp/tmpeuuuvyyw.swift:13:34:\
    \ note: to match this opening '{'\nfunc modp(n: Int, p: Int) -> Int {\n      \
    \                           ^\n/tmp/tmpeuuuvyyw.swift:15:20: error: missing argument\
    \ labels 'n:p:' in call\n        return modp(abs(n), p)\n                   ^\n\
    \                    n:      p: \n/tmp/tmpeuuuvyyw.swift:18:20: error: missing\
    \ argument labels 'n:p:' in call\n        return modp(-n, p)\n               \
    \    ^\n                    n:  p: \n/tmp/tmpeuuuvyyw.swift:147:9: error: non-void\
    \ function should return a value\n        return \n        ^\n/tmp/tmpeuuuvyyw.swift:151:6:\
    \ error: operator functions can only be declared at global or in type scope\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660014751
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n\tif n < 0 {\n\t\tpanic(\"modp requires positive argument\")\n\t}\n\tif p\
    \ < 1 {\n\t\tpanic(\"modp requires positive argument\")\n\t}\n\tif n == 0 {\n\t\
    \treturn 1\n\t}\n\tif n == 1 {\n\t\treturn p\n\t}\n\tif p < 2 {\n\t\treturn 0\n\
    \t}\n\tif p > p {\n\t\treturn 1\n\t}\n\tq := p / 2\n\tr := p % 2\n\tt := 1\n\t\
    for i := 0; i < q; i++ {\n\t\tt = t * n\n\t}\n\tif r == 0 {\n\t\treturn t\n\t\
    }\n\treturn t % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpk8whc5sz.swift:32:3: error: consecutive statements on a line must\
    \ be separated by ';'\n        q := p / 2\n         ^\n         ;\n/tmp/tmpk8whc5sz.swift:32:4:\
    \ error: expected expression\n        q := p / 2\n          ^\n/tmp/tmpk8whc5sz.swift:35:9:\
    \ error: expected type\n        for i := 0; i < q; i++ {\n               ^\n \
    \               <#type#>\n/tmp/tmpk8whc5sz.swift:35:9: error: expected 'in' after\
    \ for-each pattern\n        for i := 0; i < q; i++ {\n               ^\n/tmp/tmpk8whc5sz.swift:35:9:\
    \ error: expected Sequence expression for for-each loop\n        for i := 0; i\
    \ < q; i++ {\n               ^\n/tmp/tmpk8whc5sz.swift:15:3: error: cannot find\
    \ 'panic' in scope\n                panic(\"modp requires positive argument\"\
    )\n                ^~~~~\n/tmp/tmpk8whc5sz.swift:18:3: error: cannot find 'panic'\
    \ in scope\n                panic(\"modp requires positive argument\")\n     \
    \           ^~~~~\n/tmp/tmpk8whc5sz.swift:32:2: error: cannot find 'q' in scope\n\
    \        q := p / 2\n        ^\n/tmp/tmpk8whc5sz.swift:38:5: error: cannot find\
    \ 'r' in scope\n        if r == 0 {\n           ^\n/tmp/tmpk8whc5sz.swift:39:10:\
    \ error: cannot find 't' in scope\n                return t\n                \
    \       ^\n/tmp/tmpk8whc5sz.swift:41:9: error: cannot find 't' in scope\n    \
    \    return t % p\n               ^\n"
  stdout: ''
  timestamp: 1660014751
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n\tlet m = powMod(n, p, p)\n\tif m == 1 {\n\t\treturn 0\n\t}\n\treturn m\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp39awkzw0.swift:14:10: error: cannot find 'powMod' in scope\n  \
    \      let m = powMod(n, p, p)\n                ^~~~~~\n"
  stdout: ''
  timestamp: 1660014751
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n\tif n < 0 {\n\t\tpanic(\"modp(n,p)\")\n\t}\n\tif p < 1 {\n\t\tpanic(\"modp(n,p)\"\
    )\n\t}\n\tif n == 0 {\n\t\treturn 0\n\t}\n\tif n == 1 {\n\t\treturn p\n\t}\n\t\
    if p > p {\n\t\treturn modp(n - 1, p) % p\n\t}\n\treturn (n - 1) % p\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpap7u2b6o.swift:15:3: error: cannot find 'panic' in scope\n    \
    \            panic(\"modp(n,p)\")\n                ^~~~~\n/tmp/tmpap7u2b6o.swift:18:3:\
    \ error: cannot find 'panic' in scope\n                panic(\"modp(n,p)\")\n\
    \                ^~~~~\n/tmp/tmpap7u2b6o.swift:27:14: error: missing argument\
    \ labels 'n:p:' in call\n                return modp(n - 1, p) % p\n         \
    \                  ^\n                            n:     p: \n"
  stdout: ''
  timestamp: 1660014751
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    if n < 0 {\n        return modp(-n, p)\n    }\n    if p < 1 {\n     \
    \   return modp(n, p - 1)\n    }\n    if n == 0 {\n        return 0\n    }\n \
    \   if p == 1 {\n        return n\n    }\n    if p == 2 {\n        return n +\
    \ 1\n    }\n    if p == 3 {\n        return n + 2\n    }\n    if p == 4 {\n  \
    \      return n + 3\n    }\n    if p == 5 {\n        return n + 4\n    }\n   \
    \ if p == 6 {\n        return n + 5\n    }\n    if p == 7 {\n        return n\
    \ + 6\n    }\n    if p == 8 {\n        return n + 7\n    }\n    if p == 9 {\n\
    \        return n + 8\n    }\n    if p == 10 {\n        return n + 9\n    }\n\
    \    if p == 11 {\n        return n + 10\n    }\n    if p == 12 {\n        return\
    \ n + 11\n    }\n    if p == 13 {\n        return n + 12\n    }\n    if p == 14\
    \ {\n        return n + 13\n    }\n    if p == 15 {\n        return n + 14\n \
    \   }\n    if p == 16 {\n        return n + 15\n    }\n    if p == 17 {\n    \
    \    return n + 16\n    }\n    if p == 18 {\n        return n + 17\n    }\n  \
    \  if p == 19 {\n        return n + 18\n    }\n    if p == 20 {\n        return\
    \ n + 19\n    }\n    if p == 21 {\n        return n + 20\n    }\n    if p == 22\
    \ {\n        return n + 21\n    }\n    if p == 23 {\n        return n + 22\n \
    \   }\n    if p == 24 {\n        return n + 23\n    }\n    if p == 25 {\n    \
    \    return n + 24\n    }\n    if p == 26 {\n        return n + 25\n    }\n  \
    \  if p == 27 {\n        return n + 26\n    }\n    if p == 28 {\n        return\
    \ n + 27\n    }\n    if p == 29 {\n        return n + 28\n    }\n    if p == 30\
    \ {\n        return n + 29\n    }\n    if p == 31 {\n        return n + 30\n \
    \   }\n    if p == 32 {\n        return n + 31\n    }\n    if p == 33 {\n    \
    \    return n + 32\n    }\n    if p == 34 {\n        return n + 33\n    }\n  \
    \  if p == 35 {\n        return n + 34\n    }\n    if p == 36 {\n        return\
    \ n + 35\n    }\n    if p == 37 {\n        return n + 36\n    }\n    if p == 38\
    \ {\n        return n + 37\n    }\n    if p == 39 {\n        return n + 38\n \
    \   }\n    if p == 40 {\n        return n + 39\n    }\n    if p == 41 {\n    \
    \    return n + 40\n    }\n    if p == 42 {\n        return \n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpuxg7j4qp.swift:169:31: error: expected '}' at end of brace statement\n\
    assert(modp(n: 31, p: 5) == 3)\n                              ^\n/tmp/tmpuxg7j4qp.swift:13:34:\
    \ note: to match this opening '{'\nfunc modp(n: Int, p: Int) -> Int {\n      \
    \                           ^\n/tmp/tmpuxg7j4qp.swift:15:20: error: missing argument\
    \ labels 'n:p:' in call\n        return modp(-n, p)\n                   ^\n  \
    \                  n:  p: \n/tmp/tmpuxg7j4qp.swift:18:20: error: missing argument\
    \ labels 'n:p:' in call\n        return modp(n, p - 1)\n                   ^\n\
    \                    n: p: \n/tmp/tmpuxg7j4qp.swift:147:9: error: non-void function\
    \ should return a value\n        return \n        ^\n/tmp/tmpuxg7j4qp.swift:151:6:\
    \ error: operator functions can only be declared at global or in type scope\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660014751
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n\tif n < 0 {\n\t\tpanic(\"modp: negative number\")\n\t}\n\tif p < 0 {\n\t\
    \tpanic(\"modp: negative modulus\")\n\t}\n\tif n == 0 {\n\t\treturn 1\n\t}\n\t\
    if n == 1 {\n\t\treturn p\n\t}\n\tif p > p {\n\t\tpanic(\"modp: modulus is too\
    \ large\")\n\t}\n\tif p > p {\n\t\tpanic(\"modp: modulus is too large\")\n\t}\n\
    \tn %= p\n\tif n == 0 {\n\t\treturn 1\n\t}\n\treturn p\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\n\
    assert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: SyntaxError
  stderr: "/tmp/tmptbvbnyvl.swift:15:3: error: cannot find 'panic' in scope\n    \
    \            panic(\"modp: negative number\")\n                ^~~~~\n/tmp/tmptbvbnyvl.swift:18:3:\
    \ error: cannot find 'panic' in scope\n                panic(\"modp: negative\
    \ modulus\")\n                ^~~~~\n/tmp/tmptbvbnyvl.swift:27:3: error: cannot\
    \ find 'panic' in scope\n                panic(\"modp: modulus is too large\"\
    )\n                ^~~~~\n/tmp/tmptbvbnyvl.swift:30:3: error: cannot find 'panic'\
    \ in scope\n                panic(\"modp: modulus is too large\")\n          \
    \      ^~~~~\n/tmp/tmptbvbnyvl.swift:32:4: error: left side of mutating operator\
    \ isn't mutable: 'n' is a 'let' constant\n        n %= p\n        ~ ^\n"
  stdout: ''
  timestamp: 1660014751
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    if n < 0 {\n        return modp(abs(n), p)\n    }\n    if p < 0 {\n \
    \       return modp(n, abs(p))\n    }\n    if n == 0 {\n        return 0\n   \
    \ }\n    if p == 0 {\n        return n\n    }\n    if p > n {\n        return\
    \ modp(n, p)\n    }\n    if p < n {\n        return modp(n - p, p)\n    }\n  \
    \  if n == p {\n        return n\n    }\n    if n == 0 {\n        return 0\n \
    \   }\n    if p == 1 {\n        return n\n    }\n    if n == 1 {\n        return\
    \ p\n    }\n    if n == p {\n        return n - 1\n    }\n    if n == p {\n  \
    \      return n - 2\n    }\n    if n == p {\n        return n - 3\n    }\n   \
    \ if n == p {\n        return n - 4\n    }\n    if n == p {\n        return n\
    \ - 5\n    }\n    if n == p {\n        return n - 6\n    }\n    if n == p {\n\
    \        return n - 7\n    }\n    if n == p {\n        return n - 8\n    }\n \
    \   if n == p {\n        return n - 9\n    }\n    if n == p {\n        return\
    \ n - 10\n    }\n    if n == p {\n        return n - 11\n    }\n    if n == p\
    \ {\n        return n - 12\n    }\n    if n == p {\n        return n - 13\n  \
    \  }\n    if n == p {\n        return n - 14\n    }\n    if n == p {\n       \
    \ return n - 15\n    }\n    if n == p {\n        return n - 16\n    }\n    if\
    \ n == p {\n        return n - 17\n    }\n    if n == p {\n        return n -\
    \ 18\n    }\n    if n == p {\n        return n - 19\n    }\n    if n == p {\n\
    \        return n - 20\n    }\n    if n == p {\n        return n - 21\n    }\n\
    \    if n == p {\n        return n - 22\n    }\n    if n == p {\n        return\
    \ n - 23\n    }\n    if n == p {\n        return n - 24\n    }\n    if n == p\
    \ {\n        return n - 25\n    }\n    if n == p {\n        return n - 26\n  \
    \  }\n    if n == p {\n        return n - 27\n    }\n    if n == p {\n       \
    \ return n - 28\n    }\n    if n == p {\n        return n - 29\n    }\n    if\
    \ n == p {\n        return n - 30\n    }\n    if n == p {\n        return n -\
    \ 31\n    }\n    if n == p {\n        return n - 32\n    }\n    if n == p {\n\
    \        return n - 33\n    }\n    if n == p {\n        return n - 34\n    }\n\
    \    if n == p {\n        return n - 35\n    }\n    if n == p {\n        return\
    \ n - 36\n    }\n    if n == p {\n        return n - 37\n    }\n    if n == p\
    \ {\n        return n - 38\n    }\n    if n == p {\n        return n - 39\n  \
    \  }\n    if n == p {\n        return n - 40\n    }\n    if \n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp55ycmjad.swift:164:7: error: expected expression, var, or let in\
    \ 'if' condition\n    if \n      ^\n/tmp/tmp55ycmjad.swift:15:20: error: missing\
    \ argument labels 'n:p:' in call\n        return modp(abs(n), p)\n           \
    \        ^\n                    n:      p: \n/tmp/tmp55ycmjad.swift:18:20: error:\
    \ missing argument labels 'n:p:' in call\n        return modp(n, abs(p))\n   \
    \                ^\n                    n: p: \n/tmp/tmp55ycmjad.swift:27:20:\
    \ error: missing argument labels 'n:p:' in call\n        return modp(n, p)\n \
    \                  ^\n                    n: p: \n/tmp/tmp55ycmjad.swift:30:20:\
    \ error: missing argument labels 'n:p:' in call\n        return modp(n - p, p)\n\
    \                   ^\n                    n:     p: \n"
  stdout: ''
  timestamp: 1660014751
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    if n < 0 {\n        return modp(abs(n), p)\n    }\n    if p < 0 {\n \
    \       return modp(n, abs(p))\n    }\n    if n == 0 {\n        return 0\n   \
    \ }\n    if p == 0 {\n        return n\n    }\n    if p > n {\n        return\
    \ modp(n, p)\n    }\n    if p < n {\n        return modp(n, p)\n    }\n    if\
    \ n == p {\n        return n\n    }\n    if n == 0 {\n        return 0\n    }\n\
    \    if p == 1 {\n        return n\n    }\n    if n == 1 {\n        return n\n\
    \    }\n    if n == p {\n        return n\n    }\n    if n == p {\n        return\
    \ n\n    }\n    if n == p {\n        return n\n    }\n    if n == p {\n      \
    \  return n\n    }\n    if n == p {\n        return n\n    }\n    if n == p {\n\
    \        return n\n    }\n    if n == p {\n        return n\n    }\n    if n ==\
    \ p {\n        return n\n    }\n    if n == p {\n        return n\n    }\n   \
    \ if n == p {\n        return n\n    }\n    if n == p {\n        return n\n  \
    \  }\n    if n == p {\n        return n\n    }\n    if n == p {\n        return\
    \ n\n    }\n    if n == p {\n        return n\n    }\n    if n == p {\n      \
    \  return n\n    }\n    if n == p {\n        return n\n    }\n    if n == p {\n\
    \        return n\n    }\n    if n == p {\n        return n\n    }\n    if n ==\
    \ p {\n        return n\n    }\n    if n == p {\n        return n\n    }\n   \
    \ if n == p {\n        return n\n    }\n    if n == p {\n        return n\n  \
    \  }\n    if n == p {\n        return n\n    }\n    if n == p {\n        return\
    \ n\n    }\n    if n == p {\n        return n\n    }\n    if n == p {\n      \
    \  return n\n    }\n    if n == p {\n        return n\n    }\n    if n == p {\n\
    \        return n\n    }\n    if n == p {\n        return n\n    }\n    if n ==\
    \ p {\n        return n\n    }\n    if n == p {\n        return n\n    }\n   \
    \ if n == p {\n        return n\n    }\n    if n == p {\n        return n\n  \
    \  }\n    if n == p {\n        return n\n    }\n    if n == p {\n        return\
    \ n\n    }\n    if n == p {\n        return n\n    }\n    if n == p {\n      \
    \  return n\n    }\n    if n == p {\n        return n\n    }\n    if n == p {\n\
    \        return n\n    }\n    if n == p {\n        return n\n    }\n    if n ==\
    \ p {\n        return n\n    }\n    if n == p {\n        return n\n    }\n   \
    \ if n == p {\n        return n\n    }\n    if n == p {\n        return n\n  \
    \  }\n    if n == p {\n        return n\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpniv0_m_j.swift:199:31: error: expected '}' at end of brace statement\n\
    assert(modp(n: 31, p: 5) == 3)\n                              ^\n/tmp/tmpniv0_m_j.swift:13:34:\
    \ note: to match this opening '{'\nfunc modp(n: Int, p: Int) -> Int {\n      \
    \                           ^\n/tmp/tmpniv0_m_j.swift:15:20: error: missing argument\
    \ labels 'n:p:' in call\n        return modp(abs(n), p)\n                   ^\n\
    \                    n:      p: \n/tmp/tmpniv0_m_j.swift:18:20: error: missing\
    \ argument labels 'n:p:' in call\n        return modp(n, abs(p))\n           \
    \        ^\n                    n: p: \n/tmp/tmpniv0_m_j.swift:27:20: error: missing\
    \ argument labels 'n:p:' in call\n        return modp(n, p)\n                \
    \   ^\n                    n: p: \n/tmp/tmpniv0_m_j.swift:30:20: error: missing\
    \ argument labels 'n:p:' in call\n        return modp(n, p)\n                \
    \   ^\n                    n: p: \n/tmp/tmpniv0_m_j.swift:181:6: error: operator\
    \ functions can only be declared at global or in type scope\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660014751
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n\tif n < 0 {\n\t\tpanic(\"modp(n,p)\")\n\t}\n\tif p < 1 {\n\t\tpanic(\"modp(n,p)\"\
    )\n\t}\n\tif n == 0 {\n\t\treturn 0\n\t}\n\tif n == 1 {\n\t\treturn p\n\t}\n\t\
    if p < 2 {\n\t\treturn 1\n\t}\n\tif p > p {\n\t\treturn 0\n\t}\n\tx := n\n\ty\
    \ := p\n\tz := 1\n\tfor {\n\t\tif y > z {\n\t\t\tx -= z\n\t\t\ty -= z\n\t\t} else\
    \ {\n\t\t\tx -= y\n\t\t\ty = 0\n\t\t}\n\t\tif x == 0 {\n\t\t\tbreak\n\t\t}\n\t\
    \tz *= x\n\t}\n\treturn z\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3,\
    \ p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) ==\
    \ 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpmjat2b2c.swift:32:3: error: consecutive statements on a line must\
    \ be separated by ';'\n        x := n\n         ^\n         ;\n/tmp/tmpmjat2b2c.swift:32:4:\
    \ error: expected expression\n        x := n\n          ^\n/tmp/tmpmjat2b2c.swift:35:6:\
    \ error: expected pattern\n        for {\n            ^\n/tmp/tmpmjat2b2c.swift:35:6:\
    \ error: expected Sequence expression for for-each loop\n        for {\n     \
    \       ^\n/tmp/tmpmjat2b2c.swift:15:3: error: cannot find 'panic' in scope\n\
    \                panic(\"modp(n,p)\")\n                ^~~~~\n/tmp/tmpmjat2b2c.swift:18:3:\
    \ error: cannot find 'panic' in scope\n                panic(\"modp(n,p)\")\n\
    \                ^~~~~\n/tmp/tmpmjat2b2c.swift:32:2: error: cannot find 'x' in\
    \ scope\n        x := n\n        ^\n/tmp/tmpmjat2b2c.swift:48:9: error: cannot\
    \ find 'z' in scope\n        return z\n               ^\n"
  stdout: ''
  timestamp: 1660014751
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n\tswitch {\n\tcase n < 0:\n\t\treturn modp(abs(n), p)\n\tcase p < 0:\n\t\t\
    return modp(-n, p)\n\tcase p == 0:\n\t\treturn 0\n\tcase p == 1:\n\t\treturn n\n\
    \tcase n == p:\n\t\treturn 1\n\tcase n == p - 1:\n\t\treturn n - 1\n\tcase n ==\
    \ p - 2:\n\t\treturn n - 2\n\tcase n == p - 3:\n\t\treturn n - 3\n\tcase n ==\
    \ p - 4:\n\t\treturn n - 4\n\tcase n == p - 5:\n\t\treturn n - 5\n\tcase n ==\
    \ p - 6:\n\t\treturn n - 6\n\tcase n == p - 7:\n\t\treturn n - 7\n\tcase n ==\
    \ p - 8:\n\t\treturn n - 8\n\tcase n == p - 9:\n\t\treturn n - 9\n\tcase n ==\
    \ p - 10:\n\t\treturn n - 10\n\tcase n == p - 11:\n\t\treturn n - 11\n\tcase n\
    \ == p - 12:\n\t\treturn n - 12\n\tcase n == p - 13:\n\t\treturn n - 13\n\tcase\
    \ n == p - 14:\n\t\treturn n - 14\n\tcase n == p - 15:\n\t\treturn n - 15\n\t\
    case n == p - 16:\n\t\treturn n - 16\n\tcase n == p - 17:\n\t\treturn n - 17\n\
    \tcase n == p - 18:\n\t\treturn n - 18\n\tcase n == p - 19:\n\t\treturn n - 19\n\
    \tcase n == p - 20:\n\t\treturn n - 20\n\tcase n == p - 21:\n\t\treturn n - 21\n\
    \tcase n == p - 22:\n\t\treturn n - 22\n\tcase n == p - 23:\n\t\treturn n - 23\n\
    \tcase n == p - 24:\n\t\treturn n - 24\n\tcase n == p - 25:\n\t\treturn n - 25\n\
    \tcase n == p - 26:\n\t\treturn n - 26\n\tcase n == p - 27:\n\t\treturn n - 27\n\
    \tcase n == p - 28:\n\t\treturn n - 28\n\tcase n == p - 29:\n\t\treturn n - 29\n\
    \tcase n == p - 30:\n\t\treturn n - 30\n\tcase n == p - 31:\n\t\treturn n - 31\n\
    \tcase n == p - 32:\n\t\treturn n - 32\n\tcase n == p - 33:\n\t\treturn n - 33\n\
    \tcase n == p - 34:\n\t\treturn n - 34\n\tcase n == p - 35:\n\t\treturn n - 35\n\
    \tcase n == p - 36:\n\t\treturn n - 36\n\tcase n == p - 37:\n\t\treturn n - 37\n\
    \tcase n == p - 38:\n\t\treturn n - 38\n\tcase n == p - 39:\n\t\treturn n - 39\n\
    \tcase n == p - 40:\n\t\treturn n - 40\n\tcase n == p - 41:\n\t\treturn n - 41\n\
    \tcase n == p - 42:\n\t\treturn n - 42\n\tcase n == p - 43:\n\t\treturn n - 43\n\
    \tcase n == p - 44:\n\t\treturn n - 44\n\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpwk6yg4wd.swift:14:9: error: expected expression in 'switch' statement\n\
    \        switch {\n               ^\n/tmp/tmpwk6yg4wd.swift:135:31: error: expected\
    \ '}' at end of brace statement\nassert(modp(n: 31, p: 5) == 3)\n            \
    \                  ^\n/tmp/tmpwk6yg4wd.swift:13:34: note: to match this opening\
    \ '{'\nfunc modp(n: Int, p: Int) -> Int {\n                                 ^\n\
    /tmp/tmpwk6yg4wd.swift:16:14: error: missing argument labels 'n:p:' in call\n\
    \                return modp(abs(n), p)\n                           ^\n      \
    \                      n:      p: \n/tmp/tmpwk6yg4wd.swift:18:14: error: missing\
    \ argument labels 'n:p:' in call\n                return modp(-n, p)\n       \
    \                    ^\n                            n:  p: \n/tmp/tmpwk6yg4wd.swift:117:6:\
    \ error: operator functions can only be declared at global or in type scope\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660014751
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n\tswitch {\n\tcase n < p:\n\t\treturn 0\n\tcase n == p:\n\t\treturn 1\n\t\
    case n == 0 || n == p:\n\t\treturn n\n\tcase n >= p:\n\t\treturn modp(n - p, p)\n\
    \tdefault:\n\t\treturn modp(n - p, p) + p\n\t}\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpvipj3tjn.swift:14:9: error: expected expression in 'switch' statement\n\
    \        switch {\n               ^\n/tmp/tmpvipj3tjn.swift:22:14: error: missing\
    \ argument labels 'n:p:' in call\n                return modp(n - p, p)\n    \
    \                       ^\n                            n:     p: \n/tmp/tmpvipj3tjn.swift:24:14:\
    \ error: missing argument labels 'n:p:' in call\n                return modp(n\
    \ - p, p) + p\n                           ^\n                            n:  \
    \   p: \n"
  stdout: ''
  timestamp: 1660014751
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n\tif n < 0 {\n\t\tpanic(\"modp: negative number\")\n\t}\n\tif p < 1 {\n\t\
    \tpanic(\"modp: positive number\")\n\t}\n\tif n == 0 {\n\t\treturn 1\n\t}\n\t\
    if n == 1 {\n\t\treturn p\n\t}\n\tif p < 2 {\n\t\treturn 0\n\t}\n\tif p < 3 {\n\
    \t\treturn p - 1\n\t}\n\tif p < p {\n\t\treturn p - 1\n\t}\n\treturn p\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpi57paydn.swift:15:3: error: cannot find 'panic' in scope\n    \
    \            panic(\"modp: negative number\")\n                ^~~~~\n/tmp/tmpi57paydn.swift:18:3:\
    \ error: cannot find 'panic' in scope\n                panic(\"modp: positive\
    \ number\")\n                ^~~~~\n"
  stdout: ''
  timestamp: 1660014751
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n\tif n < 0 {\n\t\tpanic(\"modp(n,p)\")\n\t}\n\tif p < 0 {\n\t\tpanic(\"modp(n,p)\"\
    )\n\t}\n\tif n == 0 {\n\t\treturn 0\n\t}\n\tif n == 1 {\n\t\treturn p\n\t}\n\t\
    if p < 2 {\n\t\treturn n\n\t}\n\tif p > p {\n\t\treturn 0\n\t}\n\tn -= p - 1\n\
    \tx := n\n\tfor x != 0 {\n\t\tx = x & (x - 1)\n\t}\n\treturn p\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpbuvlkhaf.swift:33:3: error: consecutive statements on a line must\
    \ be separated by ';'\n        x := n\n         ^\n         ;\n/tmp/tmpbuvlkhaf.swift:33:4:\
    \ error: expected expression\n        x := n\n          ^\n/tmp/tmpbuvlkhaf.swift:34:8:\
    \ error: expected 'in' after for-each pattern\n        for x != 0 {\n        \
    \      ^\n/tmp/tmpbuvlkhaf.swift:34:8: error: unary operator cannot be separated\
    \ from its operand\n        for x != 0 {\n              ^ ~\n                \n\
    /tmp/tmpbuvlkhaf.swift:15:3: error: cannot find 'panic' in scope\n           \
    \     panic(\"modp(n,p)\")\n                ^~~~~\n/tmp/tmpbuvlkhaf.swift:18:3:\
    \ error: cannot find 'panic' in scope\n                panic(\"modp(n,p)\")\n\
    \                ^~~~~\n/tmp/tmpbuvlkhaf.swift:32:4: error: left side of mutating\
    \ operator isn't mutable: 'n' is a 'let' constant\n        n -= p - 1\n      \
    \  ~ ^\n/tmp/tmpbuvlkhaf.swift:33:2: error: cannot find 'x' in scope\n       \
    \ x := n\n        ^\n/tmp/tmpbuvlkhaf.swift:34:8: error: '!=' is not a prefix\
    \ unary operator\n        for x != 0 {\n              ^\n"
  stdout: ''
  timestamp: 1660014751
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n\tif n < 0 {\n\t\tn = -n\n\t\tp = -p\n\t}\n\tif p == 0 {\n\t\treturn n\n\t\
    }\n\tif n == 0 {\n\t\treturn 0\n\t}\n\tif p > n {\n\t\tp %= n\n\t\treturn modp(n\
    \ - p, p)\n\t}\n\tif p < 0 {\n\t\tp = -p\n\t\tn = -n\n\t}\n\tif n == 1 {\n\t\t\
    return 1\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn n\n\
    \t}\n\tif n == p - 1 {\n\t\treturn n\n\t}\n\tif n == p - 1 {\n\t\treturn n\n\t\
    }\n\tif n == p - 2 {\n\t\treturn n\n\t}\n\tif n == p - 2 {\n\t\treturn n\n\t}\n\
    \tif n == p - 3 {\n\t\treturn n\n\t}\n\tif n == p - 3 {\n\t\treturn n\n\t}\n\t\
    if n == p - 4 {\n\t\treturn n\n\t}\n\tif n == p - 4 {\n\t\treturn n\n\t}\n\tif\
    \ n == p - 5 {\n\t\treturn n\n\t}\n\tif n == p - 5 {\n\t\treturn n\n\t}\n\tif\
    \ n == p - 6 {\n\t\treturn n\n\t}\n\tif n == p - 6 {\n\t\treturn n\n\t}\n\tif\
    \ n == p - 7 {\n\t\treturn n\n\t}\n\tif n == p - 7 {\n\t\treturn n\n\t}\n\tif\
    \ n == p - 8 {\n\t\treturn n\n\t}\n\tif n == p - 8 {\n\t\treturn n\n\t}\n\tif\
    \ n == p - 9 {\n\t\treturn n\n\t}\n\tif n == p - 9 {\n\t\treturn n\n\t}\n\tif\
    \ n == p - 10 {\n\t\treturn n\n\t}\n\tif n == p - 10 {\n\t\treturn n\n\t}\n\t\
    if n == p - 11 {\n\t\treturn n\n\t}\n\tif n == p - 11 {\n\t\treturn n\n\t}\n\t\
    if n == p - 12 {\n\t\treturn n\n\t}\n\tif n == p - 12 {\n\t\treturn n\n\t}\n\t\
    if n == p - 13 {\n\t\treturn n\n\t}\n\tif n == p - 13 {\n\t\treturn n\n\t}\n\t\
    if n == p - 14 {\n\t\treturn n\n\t}\n\tif n == p - 14 {\n\t\treturn n\n\t}\n\t\
    if n == p - 15 {\n\t\treturn n\n\t}\n\tif n == p - 15 {\n\t\treturn n\n\t}\n\t\
    if n == p - 16 {\n\t\treturn n\n\t}\n\tif n == p - 16 {\n\t\treturn n\n\t}\n\t\
    if n == p - 17 {\n\t\treturn n\n\t}\n\tif n == p - 17 {\n\t\treturn n\n\t}\n\t\
    if n == p - 18 {\n\t\treturn n\n\t}\n\tif n == p - 18 {\n\t\treturn n\n\t}\n\t\
    if n == p - 19 {\n\t\treturn n\n\t}\n\tif n == p - 19 {\n\t\treturn n\n\t}\n\t\
    if n == p - 20 {\n\t\treturn \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n:\
    \ 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101)\
    \ == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpj27lfh_3.swift:178:31: error: expected '}' at end of brace statement\n\
    assert(modp(n: 31, p: 5) == 3)\n                              ^\n/tmp/tmpj27lfh_3.swift:13:34:\
    \ note: to match this opening '{'\nfunc modp(n: Int, p: Int) -> Int {\n      \
    \                           ^\n/tmp/tmpj27lfh_3.swift:15:3: error: cannot assign\
    \ to value: 'n' is a 'let' constant\n                n = -n\n                ^\n\
    /tmp/tmpj27lfh_3.swift:16:3: error: cannot assign to value: 'p' is a 'let' constant\n\
    \                p = -p\n                ^\n/tmp/tmpj27lfh_3.swift:25:5: error:\
    \ left side of mutating operator isn't mutable: 'p' is a 'let' constant\n    \
    \            p %= n\n                ~ ^\n/tmp/tmpj27lfh_3.swift:26:14: error:\
    \ missing argument labels 'n:p:' in call\n                return modp(n - p, p)\n\
    \                           ^\n                            n:     p: \n/tmp/tmpj27lfh_3.swift:29:3:\
    \ error: cannot assign to value: 'p' is a 'let' constant\n                p =\
    \ -p\n                ^\n/tmp/tmpj27lfh_3.swift:30:3: error: cannot assign to\
    \ value: 'n' is a 'let' constant\n                n = -n\n                ^\n\
    /tmp/tmpj27lfh_3.swift:156:3: error: non-void function should return a value\n\
    \                return \n                ^\n/tmp/tmpj27lfh_3.swift:160:6: error:\
    \ operator functions can only be declared at global or in type scope\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660014751
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    return ((n & (p - 1)) == 0) ? n : ((n & (p - 1)) + p) % p\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmpi233l72q/tmpi233l72q.swift:31: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002afea657bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002afea6272b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002afea6272988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002afea62717b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpi233l72q                        0x00005614be2ee2cd <unavailable> + 4813

    5    libc.so.6                          0x00002afea6767460 __libc_start_main +
    245

    6    tmpi233l72q                        0x00005614be2edef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014750
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    if n < 0 {\n        return modp(abs(n), p)\n    }\n    if p < 0 {\n \
    \       return modp(n - abs(p), p)\n    }\n    if n == 0 {\n        return 0\n\
    \    }\n    if p == 0 {\n        return n\n    }\n    if p > n {\n        return\
    \ modp(n - abs(p), p)\n    }\n    if p < n {\n        return modp(n - abs(p),\
    \ p)\n    }\n    if p == n {\n        return p\n    }\n    if n == p {\n     \
    \   return n - p\n    }\n    if n == 0 {\n        return n\n    }\n    if n ==\
    \ p {\n        return n - p\n    }\n    if n == p {\n        return n - p\n  \
    \  }\n    if n == p {\n        return n - p\n    }\n    if n == p {\n        return\
    \ n - p\n    }\n    if n == p {\n        return n - p\n    }\n    if n == p {\n\
    \        return n - p\n    }\n    if n == p {\n        return n - p\n    }\n \
    \   if n == p {\n        return n - p\n    }\n    if n == p {\n        return\
    \ n - p\n    }\n    if n == p {\n        return n - p\n    }\n    if n == p {\n\
    \        return n - p\n    }\n    if n == p {\n        return n - p\n    }\n \
    \   if n == p {\n        return n - p\n    }\n    if n == p {\n        return\
    \ n - p\n    }\n    if n == p {\n        return n - p\n    }\n    if n == p {\n\
    \        return n - p\n    }\n    if n == p {\n        return n - p\n    }\n \
    \   if n == p {\n        return n - p\n    }\n    if n == p {\n        return\
    \ n - p\n    }\n    if n == p {\n        return n - p\n    }\n    if n == p {\n\
    \        return n - p\n    }\n    if n == p {\n        return n - p\n    }\n \
    \   if n == p {\n        return n - p\n    }\n    if n == p {\n        return\
    \ n - p\n    }\n    if n == p {\n        return n - p\n    }\n    if n == p {\n\
    \        return n - p\n    }\n    if n == p {\n        return n - p\n    }\n \
    \   if n == p {\n        return n - p\n    }\n    if n == p {\n        return\
    \ n - p\n    }\n    if n == p {\n        return n - p\n    }\n    if n == p {\n\
    \        return n - p\n    }\n    if n == p {\n        return n - p\n    }\n \
    \   if n == p {\n        return n - p\n    }\n    if n == p {\n        return\
    \ n - p\n    }\n    if n == p {\n        return n - p\n    }\n    if n == p {\n\
    \        return n - p\n    }\n    if n == p {\n        return n - p\n    }\n \
    \   if n == p {\n        return n - p\n    }\n    if n == p {\n        return\
    \ n - p\n    }\n    if n == p {\n        return n - p\n    }\n\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpu7xb_423.swift:15:20: error: missing argument labels 'n:p:' in\
    \ call\n        return modp(abs(n), p)\n                   ^\n               \
    \     n:      p: \n/tmp/tmpu7xb_423.swift:18:20: error: missing argument labels\
    \ 'n:p:' in call\n        return modp(n - abs(p), p)\n                   ^\n \
    \                   n:          p: \n/tmp/tmpu7xb_423.swift:27:20: error: missing\
    \ argument labels 'n:p:' in call\n        return modp(n - abs(p), p)\n       \
    \            ^\n                    n:          p: \n/tmp/tmpu7xb_423.swift:30:20:\
    \ error: missing argument labels 'n:p:' in call\n        return modp(n - abs(p),\
    \ p)\n                   ^\n                    n:          p: \n"
  stdout: ''
  timestamp: 1660014751
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n\treturn (n & (p - 1)) == 0 ? n : n - 1\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmpcc_zzfak/tmpcc_zzfak.swift:31: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab1c634cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab1c6043b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab1c6043988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab1c60427b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpcc_zzfak                        0x000055ee00e7c23d <unavailable> + 4669

    5    libc.so.6                          0x00002ab1c6538460 __libc_start_main +
    245

    6    tmpcc_zzfak                        0x000055ee00e7be69 <unavailable> + 3689

    '
  stdout: ''
  timestamp: 1660014750
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    return ((n & (p - 1)) == 0) ? n : ((n & (p - 1)) + p)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: Exception
  stderr: 'tmpnodyk149/tmpnodyk149.swift:31: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002afacc96dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002afacc664b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002afacc664988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002afacc6637b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpnodyk149                        0x000055f5e381523d <unavailable> + 4669

    5    libc.so.6                          0x00002afaccb59460 __libc_start_main +
    245

    6    tmpnodyk149                        0x000055f5e3814e69 <unavailable> + 3689

    '
  stdout: ''
  timestamp: 1660014750
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    return n & (p - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n:\
    \ 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101)\
    \ == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmpuayjmiim/tmpuayjmiim.swift:30: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b292e1f6c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b292deedb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b292deed988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b292deec7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpuayjmiim                        0x000055b5986601bd <unavailable> + 4541

    5    libc.so.6                          0x00002b292e3e2460 __libc_start_main +
    245

    6    tmpuayjmiim                        0x000055b59865fe69 <unavailable> + 3689

    '
  stdout: ''
  timestamp: 1660014751
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    if n < 0 {\n        return modp(abs(n), p)\n    }\n    if p < 0 {\n \
    \       return modp(n, abs(p))\n    }\n    if n == 0 {\n        return 0\n   \
    \ }\n    if p == 0 {\n        return n\n    }\n    if n == p {\n        return\
    \ n\n    }\n    if n == 1 {\n        return p\n    }\n    if p == 1 {\n      \
    \  return n\n    }\n    if n == p {\n        return n\n    }\n    if n == p {\n\
    \        return p\n    }\n    if n == 1 {\n        return p\n    }\n    if p ==\
    \ 1 {\n        return n\n    }\n    if n == p {\n        return p\n    }\n   \
    \ if n == 1 {\n        return p\n    }\n    if p == 1 {\n        return n\n  \
    \  }\n    if n == p {\n        return p\n    }\n    if n == 1 {\n        return\
    \ p\n    }\n    if p == 1 {\n        return n\n    }\n    if n == p {\n      \
    \  return p\n    }\n    if n == 1 {\n        return p\n    }\n    if p == 1 {\n\
    \        return n\n    }\n    if n == p {\n        return p\n    }\n    if n ==\
    \ 1 {\n        return p\n    }\n    if p == 1 {\n        return n\n    }\n   \
    \ if n == p {\n        return p\n    }\n    if n == 1 {\n        return p\n  \
    \  }\n    if p == 1 {\n        return n\n    }\n    if n == p {\n        return\
    \ p\n    }\n    if n == 1 {\n        return p\n    }\n    if p == 1 {\n      \
    \  return n\n    }\n    if n == p {\n        return p\n    }\n    if n == 1 {\n\
    \        return p\n    }\n    if p == 1 {\n        return n\n    }\n    if n ==\
    \ p {\n        return p\n    }\n    if n == 1 {\n        return p\n    }\n   \
    \ if p == 1 {\n        return n\n    }\n    if n == p {\n        return p\n  \
    \  }\n    if n == 1 {\n        return p\n    }\n    if p == 1 {\n        return\
    \ n\n    }\n    if n == p {\n        return p\n    }\n    if n == 1 {\n      \
    \  return p\n    }\n    if p == 1 {\n        return n\n    }\n    if n == p {\n\
    \        return p\n    }\n    if n == 1 {\n        return p\n    }\n    if p ==\
    \ 1 {\n        return n\n    }\n    if n == p {\n        return p\n    }\n   \
    \ if n == 1 {\n        return p\n    }\n    if p == 1 {\n        return n\n  \
    \  }\n    if n == p {\n        return p\n    }\n    if n == 1 {\n        return\
    \ p\n    }\n    if p == 1 {\n        return n\n    }\n    if n == p {\n      \
    \  return p\n    }\n    if n == 1 {\n        return p\n    }\n    if p == 1 {\n\
    \        return n\n    }\n    if n == p {\n        return p\n    }\n\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp_4hekd1l.swift:15:20: error: missing argument labels 'n:p:' in\
    \ call\n        return modp(abs(n), p)\n                   ^\n               \
    \     n:      p: \n/tmp/tmp_4hekd1l.swift:18:20: error: missing argument labels\
    \ 'n:p:' in call\n        return modp(n, abs(p))\n                   ^\n     \
    \               n: p: \n"
  stdout: ''
  timestamp: 1660014751
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n\tif n < 0 {\n\t\tpanic(\"modp(n,p)\")\n\t}\n\tif p < 1 {\n\t\tpanic(\"modp(n,p)\"\
    )\n\t}\n\tif n == 0 {\n\t\treturn 0\n\t}\n\tif n == 1 {\n\t\treturn p\n\t}\n\t\
    if p < 2 {\n\t\treturn n % p\n\t}\n\treturn (n % p + p) % p\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpzic64y56.swift:15:3: error: cannot find 'panic' in scope\n    \
    \            panic(\"modp(n,p)\")\n                ^~~~~\n/tmp/tmpzic64y56.swift:18:3:\
    \ error: cannot find 'panic' in scope\n                panic(\"modp(n,p)\")\n\
    \                ^~~~~\n"
  stdout: ''
  timestamp: 1660014751
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n\tswitch {\n\tcase n < 0:\n\t\treturn modp(abs(n), p)\n\tcase p < 0:\n\t\t\
    return modp(-n, p)\n\tcase n >= p:\n\t\treturn 0\n\tdefault:\n\t\treturn n & (p\
    \ - 1)\n\t}\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmplnmp9od1.swift:14:9: error: expected expression in 'switch' statement\n\
    \        switch {\n               ^\n/tmp/tmplnmp9od1.swift:16:14: error: missing\
    \ argument labels 'n:p:' in call\n                return modp(abs(n), p)\n   \
    \                        ^\n                            n:      p: \n/tmp/tmplnmp9od1.swift:18:14:\
    \ error: missing argument labels 'n:p:' in call\n                return modp(-n,\
    \ p)\n                           ^\n                            n:  p: \n"
  stdout: ''
  timestamp: 1660014751
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    if n < 0 {\n        return modp(abs(n), p)\n    }\n    if p < 0 {\n \
    \       return modp(n & (p - 1), p)\n    }\n    if p > n {\n        return modp(n,\
    \ p)\n    }\n    return n & (p - 1)\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpqm7ns2mc.swift:15:20: error: missing argument labels 'n:p:' in\
    \ call\n        return modp(abs(n), p)\n                   ^\n               \
    \     n:      p: \n/tmp/tmpqm7ns2mc.swift:18:20: error: missing argument labels\
    \ 'n:p:' in call\n        return modp(n & (p - 1), p)\n                   ^\n\
    \                    n:           p: \n/tmp/tmpqm7ns2mc.swift:21:20: error: missing\
    \ argument labels 'n:p:' in call\n        return modp(n, p)\n                \
    \   ^\n                    n: p: \n"
  stdout: ''
  timestamp: 1660014751
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n\tif n < 0 {\n\t\tn = -n\n\t\tp = -p\n\t}\n\tlet mut r = p\n\twhile n > 0\
    \ {\n\t\tr = r * p % n\n\t\tn = n / p\n\t}\n\treturn r\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\n\
    assert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp7tdvjh61.swift:18:10: error: found an unexpected second identifier\
    \ in constant declaration; is there an accidental break?\n        let mut r =\
    \ p\n                ^\n/tmp/tmp7tdvjh61.swift:18:10: note: join the identifiers\
    \ together\n        let mut r = p\n            ~~~~^\n            mutr\n/tmp/tmp7tdvjh61.swift:18:10:\
    \ note: join the identifiers together with camel-case\n        let mut r = p\n\
    \            ~~~~^\n            mutR\n/tmp/tmp7tdvjh61.swift:15:3: error: cannot\
    \ assign to value: 'n' is a 'let' constant\n                n = -n\n         \
    \       ^\n/tmp/tmp7tdvjh61.swift:16:3: error: cannot assign to value: 'p' is\
    \ a 'let' constant\n                p = -p\n                ^\n/tmp/tmp7tdvjh61.swift:20:3:\
    \ error: cannot find 'r' in scope\n                r = r * p % n\n           \
    \     ^\n/tmp/tmp7tdvjh61.swift:20:7: error: cannot find 'r' in scope\n      \
    \          r = r * p % n\n                    ^\n/tmp/tmp7tdvjh61.swift:21:3:\
    \ error: cannot assign to value: 'n' is a 'let' constant\n                n =\
    \ n / p\n                ^\n/tmp/tmp7tdvjh61.swift:23:9: error: cannot find 'r'\
    \ in scope\n        return r\n               ^\n"
  stdout: ''
  timestamp: 1660014751
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    if n < 0 {\n        return modp(-n, p)\n    }\n    if p < 1 {\n     \
    \   return modp(n, p - 1)\n    }\n    if p > p {\n        return modp(n, p - 1)\n\
    \    }\n    if n == 0 {\n        return 0\n    }\n    if n == 1 {\n        return\
    \ p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n      \
    \  return p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n\
    \        return p\n    }\n    if n == p {\n        return p\n    }\n    if n ==\
    \ p {\n        return p\n    }\n    if n == p {\n        return p\n    }\n   \
    \ if n == p {\n        return p\n    }\n    if n == p {\n        return p\n  \
    \  }\n    if n == p {\n        return p\n    }\n    if n == p {\n        return\
    \ p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n      \
    \  return p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n\
    \        return p\n    }\n    if n == p {\n        return p\n    }\n    if n ==\
    \ p {\n        return p\n    }\n    if n == p {\n        return p\n    }\n   \
    \ if n == p {\n        return p\n    }\n    if n == p {\n        return p\n  \
    \  }\n    if n == p {\n        return p\n    }\n    if n == p {\n        return\
    \ p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n      \
    \  return p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n\
    \        return p\n    }\n    if n == p {\n        return p\n    }\n    if n ==\
    \ p {\n        return p\n    }\n    if n == p {\n        return p\n    }\n   \
    \ if n == p {\n        return p\n    }\n    if n == p {\n        return p\n  \
    \  }\n    if n == p {\n        return p\n    }\n    if n == p {\n        return\
    \ p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n      \
    \  return p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n\
    \        return p\n    }\n    if n == p {\n        return p\n    }\n    if n ==\
    \ p {\n        return p\n    }\n    if n == p {\n        return p\n    }\n   \
    \ if n == p {\n        return p\n    }\n    if n == p {\n        return p\n  \
    \  }\n    if n == p {\n        return p\n    }\n    if n == p {\n        return\
    \ p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n      \
    \  return p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n\
    \        return p\n    }\n    if n == p {\n        return p\n    }\n    if n ==\
    \ p {\n        return p\n    }\n    if n == p {\n\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\n\
    assert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpzvoo7cq2.swift:202:31: error: expected '}' at end of brace statement\n\
    assert(modp(n: 31, p: 5) == 3)\n                              ^\n/tmp/tmpzvoo7cq2.swift:13:34:\
    \ note: to match this opening '{'\nfunc modp(n: Int, p: Int) -> Int {\n      \
    \                           ^\n/tmp/tmpzvoo7cq2.swift:15:20: error: missing argument\
    \ labels 'n:p:' in call\n        return modp(-n, p)\n                   ^\n  \
    \                  n:  p: \n/tmp/tmpzvoo7cq2.swift:18:20: error: missing argument\
    \ labels 'n:p:' in call\n        return modp(n, p - 1)\n                   ^\n\
    \                    n: p: \n/tmp/tmpzvoo7cq2.swift:21:20: error: missing argument\
    \ labels 'n:p:' in call\n        return modp(n, p - 1)\n                   ^\n\
    \                    n: p: \n/tmp/tmpzvoo7cq2.swift:184:6: error: operator functions\
    \ can only be declared at global or in type scope\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660014751
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    if n < 0 {\n        return modp(abs(n), p)\n    }\n    if p < 0 {\n \
    \       return modp(n, abs(p))\n    }\n    if n == 0 {\n        return 0\n   \
    \ }\n    if p == 0 {\n        return n\n    }\n    if p == 1 {\n        return\
    \ n\n    }\n    if n == 1 {\n        return p\n    }\n    if n == p {\n      \
    \  return n\n    }\n    if n == p+1 {\n        return p\n    }\n    if n == p+2\
    \ {\n        return p+1\n    }\n    if n == p+3 {\n        return p+2\n    }\n\
    \    if n == p+4 {\n        return p+3\n    }\n    if n == p+5 {\n        return\
    \ p+4\n    }\n    if n == p+6 {\n        return p+5\n    }\n    if n == p+7 {\n\
    \        return p+6\n    }\n    if n == p+8 {\n        return p+7\n    }\n   \
    \ if n == p+9 {\n        return p+8\n    }\n    if n == p+10 {\n        return\
    \ p+9\n    }\n    if n == p+11 {\n        return p+10\n    }\n    if n == p+12\
    \ {\n        return p+11\n    }\n    if n == p+13 {\n        return p+12\n   \
    \ }\n    if n == p+14 {\n        return p+13\n    }\n    if n == p+15 {\n    \
    \    return p+14\n    }\n    if n == p+16 {\n        return p+15\n    }\n    if\
    \ n == p+17 {\n        return p+16\n    }\n    if n == p+18 {\n        return\
    \ p+17\n    }\n    if n == p+19 {\n        return p+18\n    }\n    if n == p+20\
    \ {\n        return p+19\n    }\n    if n == p+21 {\n        return p+20\n   \
    \ }\n    if n == p+22 {\n        return p+21\n    }\n    if n == p+23 {\n    \
    \    return p+22\n    }\n    if n == p+24 {\n        return p+23\n    }\n    if\
    \ n == p+25 {\n        return p+24\n    }\n    if n == p+26 {\n        return\
    \ p+25\n    }\n    if n == p+27 {\n        return p+26\n    }\n    if n == p+28\
    \ {\n        return p+27\n    }\n    if n == p+29 {\n        return p+28\n   \
    \ }\n    if n == p+30 {\n        return p+29\n    }\n    if n == p+31 {\n    \
    \    return p+30\n    }\n    if n == p+32 {\n        return p+31\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp4pfwxnjc.swift:151:31: error: expected '}' at end of brace statement\n\
    assert(modp(n: 31, p: 5) == 3)\n                              ^\n/tmp/tmp4pfwxnjc.swift:13:34:\
    \ note: to match this opening '{'\nfunc modp(n: Int, p: Int) -> Int {\n      \
    \                           ^\n/tmp/tmp4pfwxnjc.swift:15:20: error: missing argument\
    \ labels 'n:p:' in call\n        return modp(abs(n), p)\n                   ^\n\
    \                    n:      p: \n/tmp/tmp4pfwxnjc.swift:18:20: error: missing\
    \ argument labels 'n:p:' in call\n        return modp(n, abs(p))\n           \
    \        ^\n                    n: p: \n/tmp/tmp4pfwxnjc.swift:133:6: error: operator\
    \ functions can only be declared at global or in type scope\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660014749
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n\tif n < 0 {\n\t\tpanic(\"modp called with negative n\")\n\t}\n\tif p < 1\
    \ {\n\t\tpanic(\"modp called with p < 1\")\n\t}\n\tif n == 0 {\n\t\treturn 0\n\
    \t}\n\tif n == 1 {\n\t\treturn p\n\t}\n\tif p == 1 {\n\t\treturn n\n\t}\n\tif\
    \ p == 0 {\n\t\treturn 1\n\t}\n\tif n == p {\n\t\treturn modp(n - 1, p - 1)\n\t\
    }\n\tif p < p {\n\t\tpanic(\"modp called with p < p\")\n\t}\n\tq := modp(n - 1,\
    \ p - 1)\n\tq %= p\n\tif q > 0 {\n\t\tq++\n\t}\n\treturn q\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp406n3q4s.swift:38:3: error: consecutive statements on a line must\
    \ be separated by ';'\n        q := modp(n - 1, p - 1)\n         ^\n         ;\n\
    /tmp/tmp406n3q4s.swift:38:4: error: expected expression\n        q := modp(n -\
    \ 1, p - 1)\n          ^\n/tmp/tmp406n3q4s.swift:15:3: error: cannot find 'panic'\
    \ in scope\n                panic(\"modp called with negative n\")\n         \
    \       ^~~~~\n/tmp/tmp406n3q4s.swift:18:3: error: cannot find 'panic' in scope\n\
    \                panic(\"modp called with p < 1\")\n                ^~~~~\n/tmp/tmp406n3q4s.swift:33:14:\
    \ error: missing argument labels 'n:p:' in call\n                return modp(n\
    \ - 1, p - 1)\n                           ^\n                            n:  \
    \   p: \n/tmp/tmp406n3q4s.swift:36:3: error: cannot find 'panic' in scope\n  \
    \              panic(\"modp called with p < p\")\n                ^~~~~\n/tmp/tmp406n3q4s.swift:38:2:\
    \ error: cannot find 'q' in scope\n        q := modp(n - 1, p - 1)\n        ^\n\
    /tmp/tmp406n3q4s.swift:40:5: error: cannot find 'q' in scope\n        if q > 0\
    \ {\n           ^\n/tmp/tmp406n3q4s.swift:41:4: error: cannot find operator '++'\
    \ in scope; did you mean '+= 1'?\n                q++\n                 ^~\n/tmp/tmp406n3q4s.swift:41:3:\
    \ error: cannot find 'q' in scope\n                q++\n                ^\n/tmp/tmp406n3q4s.swift:43:9:\
    \ error: cannot find 'q' in scope\n        return q\n               ^\n"
  stdout: ''
  timestamp: 1660014751
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n\tif n < 0 {\n\t\tpanic(\"modp(n: Int, p: Int): n must be positive\")\n\t\
    }\n\tif p < 1 {\n\t\tpanic(\"modp(n: Int, p: Int): p must be positive\")\n\t}\n\
    \tif n == 0 {\n\t\treturn 1\n\t}\n\tif n == 1 {\n\t\treturn p\n\t}\n\tif n ==\
    \ p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\t\
    return n\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn n\n\
    \t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif\
    \ n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\
    \t\treturn p\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn\
    \ p\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\
    \tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n ==\
    \ p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\t\
    return n\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn n\n\
    \t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif\
    \ n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\
    \t\treturn p\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn\
    \ p\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\
    \tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n ==\
    \ p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\t\
    return n\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn n\n\
    \t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif\
    \ n == p {\n\t\treturn p\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\
    \t\treturn p\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn\
    \ p\n\t}\n\tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\
    \tif n == p {\n\t\treturn n\n\t}\n\tif n == p {\n\t\treturn p\n\t}\n\tif n ==\
    \ p {\n\t\treturn n\n\t}\n\tif n == p {\n\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpi775oc8_.swift:196:31: error: expected '}' at end of brace statement\n\
    assert(modp(n: 31, p: 5) == 3)\n                              ^\n/tmp/tmpi775oc8_.swift:13:34:\
    \ note: to match this opening '{'\nfunc modp(n: Int, p: Int) -> Int {\n      \
    \                           ^\n/tmp/tmpi775oc8_.swift:15:3: error: cannot find\
    \ 'panic' in scope\n                panic(\"modp(n: Int, p: Int): n must be positive\"\
    )\n                ^~~~~\n/tmp/tmpi775oc8_.swift:18:3: error: cannot find 'panic'\
    \ in scope\n                panic(\"modp(n: Int, p: Int): p must be positive\"\
    )\n                ^~~~~\n/tmp/tmpi775oc8_.swift:178:6: error: operator functions\
    \ can only be declared at global or in type scope\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660014751
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n\tif n < 0 {\n\t\tn = -n\n\t\tp = -p\n\t}\n\tif p < 2 {\n\t\treturn 0\n\t\
    }\n\tif p > p {\n\t\tp = p\n\t}\n\tswitch {\n\tcase n < 0:\n\t\treturn 0\n\tcase\
    \ p == 0:\n\t\treturn 0\n\tcase p == 1:\n\t\treturn n\n\tcase p < 2:\n\t\treturn\
    \ 0\n\t}\n\tn %= p\n\tif n == 0 {\n\t\treturn 1\n\t}\n\treturn modp(n - 1, p)\
    \ + p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\n\
    assert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpxca5vtv7.swift:24:9: error: expected expression in 'switch' statement\n\
    \        switch {\n               ^\n/tmp/tmpxca5vtv7.swift:15:3: error: cannot\
    \ assign to value: 'n' is a 'let' constant\n                n = -n\n         \
    \       ^\n/tmp/tmpxca5vtv7.swift:16:3: error: cannot assign to value: 'p' is\
    \ a 'let' constant\n                p = -p\n                ^\n/tmp/tmpxca5vtv7.swift:22:3:\
    \ error: cannot assign to value: 'p' is a 'let' constant\n                p =\
    \ p\n                ^\n/tmp/tmpxca5vtv7.swift:34:4: error: left side of mutating\
    \ operator isn't mutable: 'n' is a 'let' constant\n        n %= p\n        ~ ^\n\
    /tmp/tmpxca5vtv7.swift:38:13: error: missing argument labels 'n:p:' in call\n\
    \        return modp(n - 1, p) + p\n                   ^\n                   \
    \ n:     p: \n"
  stdout: ''
  timestamp: 1660014751
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    if n < 0 {\n        return modp(-n, p)\n    }\n    if p < 0 {\n     \
    \   return modp(-p, p)\n    }\n    if n == 0 {\n        return 0\n    }\n    if\
    \ p == 0 {\n        return n\n    }\n    if n == p {\n        return n\n    }\n\
    \    if n == p {\n        return p\n    }\n    if n == 0 {\n        return p\n\
    \    }\n    if n == p {\n        return p\n    }\n    if n == p {\n        return\
    \ p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n      \
    \  return p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n\
    \        return p\n    }\n    if n == p {\n        return p\n    }\n    if n ==\
    \ p {\n        return p\n    }\n    if n == p {\n        return p\n    }\n   \
    \ if n == p {\n        return p\n    }\n    if n == p {\n        return p\n  \
    \  }\n    if n == p {\n        return p\n    }\n    if n == p {\n        return\
    \ p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n      \
    \  return p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n\
    \        return p\n    }\n    if n == p {\n        return p\n    }\n    if n ==\
    \ p {\n        return p\n    }\n    if n == p {\n        return p\n    }\n   \
    \ if n == p {\n        return p\n    }\n    if n == p {\n        return p\n  \
    \  }\n    if n == p {\n        return p\n    }\n    if n == p {\n        return\
    \ p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n      \
    \  return p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n\
    \        return p\n    }\n    if n == p {\n        return p\n    }\n    if n ==\
    \ p {\n        return p\n    }\n    if n == p {\n        return p\n    }\n   \
    \ if n == p {\n        return p\n    }\n    if n == p {\n        return p\n  \
    \  }\n    if n == p {\n        return p\n    }\n    if n == p {\n        return\
    \ p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n      \
    \  return p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n\
    \        return p\n    }\n    if n == p {\n        return p\n    }\n    if n ==\
    \ p {\n        return p\n    }\n    if n == p {\n        return p\n    }\n   \
    \ if n == p {\n        return p\n    }\n    if n == p {\n        return p\n  \
    \  }\n    if n == p {\n        return p\n    }\n    if n == p {\n        return\
    \ p\n    }\n    if n == p {\n        return p\n    }\n    if n == p {\n      \
    \  return p\n    }\n    if n == p {\n        return p\n    }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) ==\
    \ 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n:\
    \ 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5)\
    \ == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpq0wyjn7g.swift:15:20: error: missing argument labels 'n:p:' in\
    \ call\n        return modp(-n, p)\n                   ^\n                   \
    \ n:  p: \n/tmp/tmpq0wyjn7g.swift:18:20: error: missing argument labels 'n:p:'\
    \ in call\n        return modp(-p, p)\n                   ^\n                \
    \    n:  p: \n"
  stdout: ''
  timestamp: 1660014751
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    if n < 0 {\n        return modp(abs(n), p)\n    }\n    if p < 0 {\n \
    \       return modp(n, abs(p))\n    }\n    if n == 0 || p == 0 {\n        return\
    \ 0\n    }\n    if p > n {\n        return modp(n, p)\n    }\n    var result =\
    \ 1\n    for i := n - 1; i >= 0; i-- {\n        result = result * p + (n % p)\n\
    \        n = n / p\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpyqtw9i7p.swift:27:12: error: expected type\n    for i := n - 1;\
    \ i >= 0; i-- {\n           ^\n            <#type#>\n/tmp/tmpyqtw9i7p.swift:27:12:\
    \ error: expected 'in' after for-each pattern\n    for i := n - 1; i >= 0; i--\
    \ {\n           ^\n/tmp/tmpyqtw9i7p.swift:27:12: error: expected Sequence expression\
    \ for for-each loop\n    for i := n - 1; i >= 0; i-- {\n           ^\n/tmp/tmpyqtw9i7p.swift:15:20:\
    \ error: missing argument labels 'n:p:' in call\n        return modp(abs(n), p)\n\
    \                   ^\n                    n:      p: \n/tmp/tmpyqtw9i7p.swift:18:20:\
    \ error: missing argument labels 'n:p:' in call\n        return modp(n, abs(p))\n\
    \                   ^\n                    n: p: \n/tmp/tmpyqtw9i7p.swift:24:20:\
    \ error: missing argument labels 'n:p:' in call\n        return modp(n, p)\n \
    \                  ^\n                    n: p: \n"
  stdout: ''
  timestamp: 1660014751
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    if n < 0 {\n        return modp(abs(n), p)\n    }\n    if p < 0 {\n \
    \       return modp(n, abs(p))\n    }\n    if n == 0 {\n        return 0\n   \
    \ }\n    if p == 0 {\n        return n\n    }\n    if n == p {\n        return\
    \ n\n    }\n    if n == p {\n        return n\n    }\n    if n == p {\n      \
    \  return n\n    }\n    if n == p {\n        return n\n    }\n    if n == p {\n\
    \        return n\n    }\n    if n == p {\n        return n\n    }\n    if n ==\
    \ p {\n        return n\n    }\n    if n == p {\n        return n\n    }\n   \
    \ if n == p {\n        return n\n    }\n    if n == p {\n        return n\n  \
    \  }\n    if n == p {\n        return n\n    }\n    if n == p {\n        return\
    \ n\n    }\n    if n == p {\n        return n\n    }\n    if n == p {\n      \
    \  return n\n    }\n    if n == p {\n        return n\n    }\n    if n == p {\n\
    \        return n\n    }\n    if n == p {\n        return n\n    }\n    if n ==\
    \ p {\n        return n\n    }\n    if n == p {\n        return n\n    }\n   \
    \ if n == p {\n        return n\n    }\n    if n == p {\n        return n\n  \
    \  }\n    if n == p {\n        return n\n    }\n    if n == p {\n        return\
    \ n\n    }\n    if n == p {\n        return n\n    }\n    if n == p {\n      \
    \  return n\n    }\n    if n == p {\n        return n\n    }\n    if n == p {\n\
    \        return n\n    }\n    if n == p {\n        return n\n    }\n    if n ==\
    \ p {\n        return n\n    }\n    if n == p {\n        return n\n    }\n   \
    \ if n == p {\n        return n\n    }\n    if n == p {\n        return n\n  \
    \  }\n    if n == p {\n        return n\n    }\n    if n == p {\n        return\
    \ n\n    }\n    if n == p {\n        return n\n    }\n    if n == p {\n      \
    \  return n\n    }\n    if n == p {\n        return n\n    }\n    if n == p {\n\
    \        return n\n    }\n    if n == p {\n        return n\n    }\n    if n ==\
    \ p {\n        return n\n    }\n    if n == p {\n        return n\n    }\n   \
    \ if n == p {\n        return n\n    }\n    if n == p {\n        return n\n  \
    \  }\n    if n == p {\n        return n\n    }\n    if n == p {\n        return\
    \ n\n    }\n    if n == p {\n        return n\n    }\n    if n == p {\n      \
    \  return n\n    }\n    if n == p {\n        return n\n    }\n    if n == p {\n\
    \        return n\n    }\n    if n == p {\n        return n\n    }\n    if n ==\
    \ p {\n        return n\n    }\n    if n == p {\n        return n\n\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p:\
    \ 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\n\
    assert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n:\
    \ 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp68p_gotw.swift:203:31: error: expected '}' at end of brace statement\n\
    assert(modp(n: 31, p: 5) == 3)\n                              ^\n/tmp/tmp68p_gotw.swift:13:34:\
    \ note: to match this opening '{'\nfunc modp(n: Int, p: Int) -> Int {\n      \
    \                           ^\n/tmp/tmp68p_gotw.swift:15:20: error: missing argument\
    \ labels 'n:p:' in call\n        return modp(abs(n), p)\n                   ^\n\
    \                    n:      p: \n/tmp/tmp68p_gotw.swift:18:20: error: missing\
    \ argument labels 'n:p:' in call\n        return modp(n, abs(p))\n           \
    \        ^\n                    n: p: \n/tmp/tmp68p_gotw.swift:185:6: error: operator\
    \ functions can only be declared at global or in type scope\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660014750
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n\tswitch {\n\tcase n < 0:\n\t\treturn modp(abs(n), p)\n\tcase p < 0:\n\t\t\
    return modp(abs(n), -p) * p\n\tcase p == 0:\n\t\treturn 0\n\tdefault:\n\t\treturn\
    \ n / p\n\t}\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpobj0814s.swift:14:9: error: expected expression in 'switch' statement\n\
    \        switch {\n               ^\n/tmp/tmpobj0814s.swift:16:14: error: missing\
    \ argument labels 'n:p:' in call\n                return modp(abs(n), p)\n   \
    \                        ^\n                            n:      p: \n/tmp/tmpobj0814s.swift:18:14:\
    \ error: missing argument labels 'n:p:' in call\n                return modp(abs(n),\
    \ -p) * p\n                           ^\n                            n:      p:\
    \ \n"
  stdout: ''
  timestamp: 1660014751
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n\treturn n % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmpaqapo1ar/tmpaqapo1ar.swift:31: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b2a0e3f6c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b2a0e0edb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b2a0e0ed988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b2a0e0ec7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpaqapo1ar                        0x00005633822222cd <unavailable> + 4813

    5    libc.so.6                          0x00002b2a0e5e2460 __libc_start_main +
    245

    6    tmpaqapo1ar                        0x0000563382221ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014752
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n\tif n < 0 {\n\t\tpanic(\"modp: negative number\")\n\t}\n\tif p < 1 {\n\t\
    \tpanic(\"modp: negative modulus\")\n\t}\n\tif n == 0 {\n\t\treturn 0\n\t}\n\t\
    if n == 1 {\n\t\treturn p\n\t}\n\tif p > p {\n\t\treturn 0\n\t}\n\tx := n\n\t\
    y := p\n\tt := 1\n\tfor {\n\t\tif y & 1 == 1 {\n\t\t\tx >>= 1\n\t\t\ty >>= 1\n\
    \t\t\tt *= x\n\t\t} else {\n\t\t\tx >>= 1\n\t\t\ty >>= 1\n\t\t\tt *= y\n\t\t}\n\
    \t\tif x == 0 {\n\t\t\treturn t\n\t\t}\n\t}\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(modp(n: 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n:\
    \ 0, p: 101) == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101)\
    \ == 1)\nassert(modp(n: 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmp6ycyu_7s.swift:29:3: error: consecutive statements on a line must\
    \ be separated by ';'\n        x := n\n         ^\n         ;\n/tmp/tmp6ycyu_7s.swift:29:4:\
    \ error: expected expression\n        x := n\n          ^\n/tmp/tmp6ycyu_7s.swift:32:6:\
    \ error: expected pattern\n        for {\n            ^\n/tmp/tmp6ycyu_7s.swift:32:6:\
    \ error: expected Sequence expression for for-each loop\n        for {\n     \
    \       ^\n/tmp/tmp6ycyu_7s.swift:15:3: error: cannot find 'panic' in scope\n\
    \                panic(\"modp: negative number\")\n                ^~~~~\n/tmp/tmp6ycyu_7s.swift:18:3:\
    \ error: cannot find 'panic' in scope\n                panic(\"modp: negative\
    \ modulus\")\n                ^~~~~\n/tmp/tmp6ycyu_7s.swift:29:2: error: cannot\
    \ find 'x' in scope\n        x := n\n        ^\n"
  stdout: ''
  timestamp: 1660014751
- exit_code: -4
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n    return ((n%p) + p) % p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(modp(n:\
    \ 3, p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101)\
    \ == 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: Exception
  stderr: 'tmpbx91mpfq/tmpbx91mpfq.swift:31: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b117cb67c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b117c85eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b117c85e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b117c85d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpbx91mpfq                        0x000055d7bf6962cd <unavailable> + 4813

    5    libc.so.6                          0x00002b117cd53460 __libc_start_main +
    245

    6    tmpbx91mpfq                        0x000055d7bf695ef9 <unavailable> + 3833

    '
  stdout: ''
  timestamp: 1660014750
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n\tswitch {\n\tcase n < 0 || p < 0 || p > n:\n\t\treturn 0\n\tcase n == p:\n\
    \t\treturn n\n\tcase n >= p:\n\t\treturn n - p\n\tdefault:\n\t\treturn ((n - p)\
    \ % (p - n)) + p\n\t}\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(modp(n: 3,\
    \ p: 5) == 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) ==\
    \ 1)\nassert(modp(n: 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n:\
    \ 30, p: 5) == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpqeemza65.swift:14:9: error: expected expression in 'switch' statement\n\
    \        switch {\n               ^\n"
  stdout: ''
  timestamp: 1660014751
- exit_code: 1
  program: "\n/// Return 2^n modulo p (be aware of numerics).\n/// >>> modp(3, 5)\n\
    /// 3\n/// >>> modp(1101, 101)\n/// 2\n/// >>> modp(0, 101)\n/// 1\n/// >>> modp(3,\
    \ 11)\n/// 8\n/// >>> modp(100, 101)\n/// 1\nfunc modp(n: Int, p: Int) -> Int\
    \ {\n\tif n < 0 {\n\t\tpanic(\"modp called with negative n\")\n\t}\n\tif p < 0\
    \ {\n\t\tpanic(\"modp called with negative p\")\n\t}\n\tif n == 0 {\n\t\treturn\
    \ 1\n\t}\n\tif p == 0 {\n\t\treturn 0\n\t}\n\tif n == 1 {\n\t\treturn p\n\t}\n\
    \tif p == 1 {\n\t\treturn n\n\t}\n\tr := n % p\n\tif r == 0 {\n\t\treturn n\n\t\
    }\n\treturn p\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(modp(n: 3, p: 5) ==\
    \ 3)\nassert(modp(n: 1101, p: 101) == 2)\nassert(modp(n: 0, p: 101) == 1)\nassert(modp(n:\
    \ 3, p: 11) == 8)\nassert(modp(n: 100, p: 101) == 1)\nassert(modp(n: 30, p: 5)\
    \ == 4)\nassert(modp(n: 31, p: 5) == 3)"
  status: SyntaxError
  stderr: "/tmp/tmpkwvmwtw1.swift:32:3: error: consecutive statements on a line must\
    \ be separated by ';'\n        r := n % p\n         ^\n         ;\n/tmp/tmpkwvmwtw1.swift:32:4:\
    \ error: expected expression\n        r := n % p\n          ^\n/tmp/tmpkwvmwtw1.swift:15:3:\
    \ error: cannot find 'panic' in scope\n                panic(\"modp called with\
    \ negative n\")\n                ^~~~~\n/tmp/tmpkwvmwtw1.swift:18:3: error: cannot\
    \ find 'panic' in scope\n                panic(\"modp called with negative p\"\
    )\n                ^~~~~\n/tmp/tmpkwvmwtw1.swift:32:2: error: cannot find 'r'\
    \ in scope\n        r := n % p\n        ^\n/tmp/tmpkwvmwtw1.swift:33:5: error:\
    \ cannot find 'r' in scope\n        if r == 0 {\n           ^\n"
  stdout: ''
  timestamp: 1660014751
