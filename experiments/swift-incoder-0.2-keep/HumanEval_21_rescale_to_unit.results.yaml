language: swift
name: HumanEval_21_rescale_to_unit
results:
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var scaled: [Double] = []\n    var min: Double = Double.greatestFiniteMagnitude\n\
    \    var max: Double = Double.lowestFiniteMagnitude\n    for number in numbers\
    \ {\n        let scaledNumber = number / max - min\n        scaled.append(scaledNumber)\n\
    \        min = min(min, number)\n        max = max(max, number)\n    }\n    return\
    \ scaled\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpnvjuebgk.swift:9:30: error: type 'Double' has no member 'lowestFiniteMagnitude'\n\
    \    var max: Double = Double.lowestFiniteMagnitude\n                      ~~~~~~\
    \ ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpnvjuebgk.swift:13:15: error: cannot call value\
    \ of non-function type 'Double'\n        min = min(min, number)\n            \
    \  ^\n/tmp/tmpnvjuebgk.swift:14:15: error: cannot call value of non-function type\
    \ 'Double'\n        max = max(max, number)\n              ^\n"
  stdout: ''
  timestamp: 1660013798
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var min: Double = Double(Int.max)\n    var max: Double = Double(Int.min)\n\
    \    for number in numbers {\n        min = min(min, number)\n        max = max(max,\
    \ number)\n    }\n    var result: [Double] = []\n    for number in numbers {\n\
    \        result.append(number - min)\n        result.append(number - max)\n  \
    \  }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpd6kk2qbz.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpd6kk2qbz.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013798
- exit_code: -4
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var rescaled: [Double] = []\n    for number in numbers {\n        rescaled.append(number\
    \ / min(number, 1.0))\n    }\n    return rescaled\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: Exception
  stderr: 'tmp_rm2k2ga/tmp_rm2k2ga.swift:27: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002afbb3671c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002afbb3368b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002afbb3368988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002afbb33677b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp_rm2k2ga                        0x000055e0cfdc4693 <unavailable> + 5779

    5    libc.so.6                          0x00002afbb385d460 __libc_start_main +
    245

    6    tmp_rm2k2ga                        0x000055e0cfdc4299 <unavailable> + 4761

    '
  stdout: ''
  timestamp: 1660013799
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var min: Double = Double.greatestFiniteMagnitude\n    var max: Double\
    \ = Double.leastFiniteMagnitude\n    for number in numbers {\n        if number\
    \ < min {\n            min = number\n        }\n        if number > max {\n  \
    \          max = number\n        }\n    }\n    var result: [Double] = []\n   \
    \ for number in numbers {\n        result.append(number - min)\n        result.append(number\
    \ - max)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpyuyt0kh8.swift:8:30: error: type 'Double' has no member 'leastFiniteMagnitude'\n\
    \    var max: Double = Double.leastFiniteMagnitude\n                      ~~~~~~\
    \ ^~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013798
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var min: Double = Double(Int.max)\n    var max: Double = Double(Int.min)\n\
    \    for number in numbers {\n        min = min(min, number)\n        max = max(max,\
    \ number)\n    }\n    var result: [Double] = []\n    for number in numbers {\n\
    \        result.append(number - min)\n        result.append(number - max)\n  \
    \  }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpd6kk2qbz.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpd6kk2qbz.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013798
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var min: Double = Double(Int.max)\n    var max: Double = Double(Int.min)\n\
    \    for number in numbers {\n        min = min(min, number)\n        max = max(max,\
    \ number)\n    }\n    var result: [Double] = []\n    for number in numbers {\n\
    \        result.append(number - min)\n        result.append(number - max)\n  \
    \  }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpd6kk2qbz.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpd6kk2qbz.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013798
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var min = Double(Int.max)\n    var max = Double(Int.min)\n    for number\
    \ in numbers {\n        min = min(min, number)\n        max = max(max, number)\n\
    \    }\n    var result: [Double] = []\n    for number in numbers {\n        result.append(number\
    \ - min)\n        result.append(number - max)\n    }\n    return result\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpd9hsoeox.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpd9hsoeox.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013798
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var min: Double = Double(Int.max)\n    var max: Double = Double(Int.min)\n\
    \    for number in numbers {\n        min = min(min, number)\n        max = max(max,\
    \ number)\n    }\n    var result: [Double] = []\n    for number in numbers {\n\
    \        result.append(number - min)\n        result.append(number - max)\n  \
    \  }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpd6kk2qbz.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpd6kk2qbz.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013798
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var min: Double = Double(Int.max)\n    var max: Double = Double(Int.min)\n\
    \    for number in numbers {\n        min = min(min, number)\n        max = max(max,\
    \ number)\n    }\n    var result: [Double] = []\n    for number in numbers {\n\
    \        result.append(number - min)\n        result.append(number - max)\n  \
    \  }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpd6kk2qbz.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpd6kk2qbz.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013798
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var min: Double = Double.greatestFiniteMagnitude\n    var max: Double\
    \ = Double.leastFiniteMagnitude\n    for number in numbers {\n        min = min(min,\
    \ number)\n        max = max(max, number)\n    }\n    var result: [Double] = []\n\
    \    for number in numbers {\n        result.append(number - min)\n        result.append(number\
    \ - max)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpqhtwqsbu.swift:8:30: error: type 'Double' has no member 'leastFiniteMagnitude'\n\
    \    var max: Double = Double.leastFiniteMagnitude\n                      ~~~~~~\
    \ ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmpqhtwqsbu.swift:10:15: error: cannot call value\
    \ of non-function type 'Double'\n        min = min(min, number)\n            \
    \  ^\n/tmp/tmpqhtwqsbu.swift:11:15: error: cannot call value of non-function type\
    \ 'Double'\n        max = max(max, number)\n              ^\n"
  stdout: ''
  timestamp: 1660013798
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var min = Double(Int.max)\n    var max = Double(Int.min)\n    for number\
    \ in numbers {\n        min = min(min, number)\n        max = max(max, number)\n\
    \    }\n    var result: [Double] = []\n    for number in numbers {\n        result.append(number\
    \ - min)\n        result.append(number - max)\n    }\n    return result\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpd9hsoeox.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpd9hsoeox.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013798
- exit_code: -4
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    guard numbers.count > 1 else { return numbers }\n    var min: Double\
    \ = Double(numbers[0])\n    var max: Double = Double(numbers[0])\n    for number\
    \ in numbers {\n        if number < min {\n            min = number\n        }\n\
    \        if number > max {\n            max = number\n        }\n    }\n    var\
    \ result: [Double] = []\n    for number in numbers {\n        result.append(number\
    \ - min)\n        result.append(max - number)\n    }\n    return result\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: Exception
  stderr: 'tmpn74nb9wh/tmpn74nb9wh.swift:39: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b2f4fa88c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b2f4f77fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b2f4f77f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b2f4f77e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpn74nb9wh                        0x000055d75f24e703 <unavailable> + 5891

    5    libc.so.6                          0x00002b2f4fc74460 __libc_start_main +
    245

    6    tmpn74nb9wh                        0x000055d75f24e309 <unavailable> + 4873

    '
  stdout: ''
  timestamp: 1660013799
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var min: Double = Double(Int.max)\n    var max: Double = Double(Int.min)\n\
    \    for number in numbers {\n        min = min(min, number)\n        max = max(max,\
    \ number)\n    }\n    var result: [Double] = []\n    for number in numbers {\n\
    \        result.append(number - min)\n        result.append(number - max)\n  \
    \  }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpd6kk2qbz.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpd6kk2qbz.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013798
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var min: Double = Double(Int.max)\n    var max: Double = Double(Int.min)\n\
    \    for number in numbers {\n        min = min(min, number)\n        max = max(max,\
    \ number)\n    }\n    var result: [Double] = []\n    for number in numbers {\n\
    \        result.append(number - min)\n        result.append(number - max)\n  \
    \  }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpd6kk2qbz.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpd6kk2qbz.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013798
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var min = Double(Int.max)\n    var max = Double(Int.min)\n    for number\
    \ in numbers {\n        min = min(min, number)\n        max = max(max, number)\n\
    \    }\n    var result: [Double] = []\n    for number in numbers {\n        result.append(number\
    \ - min)\n        result.append(number - max)\n    }\n    return result\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpd9hsoeox.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpd9hsoeox.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013798
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var min: Double = Double.greatestFiniteMagnitude\n    var max: Double\
    \ = Double.leastFiniteMagnitude\n    for number in numbers {\n        min = min(min,\
    \ number)\n        max = max(max, number)\n    }\n    var scaled: [Double] = []\n\
    \    for number in numbers {\n        scaled.append((number - min) / (max - min))\n\
    \    }\n    return scaled\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmps_8ap6lw.swift:8:30: error: type 'Double' has no member 'leastFiniteMagnitude'\n\
    \    var max: Double = Double.leastFiniteMagnitude\n                      ~~~~~~\
    \ ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmps_8ap6lw.swift:10:15: error: cannot call value\
    \ of non-function type 'Double'\n        min = min(min, number)\n            \
    \  ^\n/tmp/tmps_8ap6lw.swift:11:15: error: cannot call value of non-function type\
    \ 'Double'\n        max = max(max, number)\n              ^\n"
  stdout: ''
  timestamp: 1660013798
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var min = Double(numbers[0])\n    var max = Double(numbers[0])\n    for\
    \ number in numbers {\n        if number < min {\n            min = number\n \
    \       }\n        if number > max {\n            max = number\n        }\n  \
    \  }\n    var result = [Double](repeating: 0.0, count: numbers.count)\n    for\
    \ number in numbers {\n        result[numbers.index(of: number)] = ((number -\
    \ min) / (max - min)) * 1.0\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpyf97bmj6.swift:19:24: error: value of optional type 'Array<Double>.Index?'\
    \ (aka 'Optional<Int>') must be unwrapped to a value of type 'Array<Double>.Index'\
    \ (aka 'Int')\n        result[numbers.index(of: number)] = ((number - min) / (max\
    \ - min)) * 1.0\n                       ^\n/tmp/tmpyf97bmj6.swift:19:24: note:\
    \ coalesce using '??' to provide a default when the optional value contains 'nil'\n\
    \        result[numbers.index(of: number)] = ((number - min) / (max - min)) *\
    \ 1.0\n                       ^\n                                         ?? <#default\
    \ value#>\n/tmp/tmpyf97bmj6.swift:19:24: note: force-unwrap using '!' to abort\
    \ execution if the optional value contains 'nil'\n        result[numbers.index(of:\
    \ number)] = ((number - min) / (max - min)) * 1.0\n                       ^\n\
    \                                        !\n"
  stdout: ''
  timestamp: 1660013798
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var min = Double.greatestFiniteMagnitude\n    var max = Double.leastFiniteMagnitude\n\
    \    for number in numbers {\n        min = min(min, number)\n        max = max(max,\
    \ number)\n    }\n    var result = [Double](repeating: 0.0, count: numbers.count)\n\
    \    for number in numbers {\n        result[numbers.index(of: number)] = number\
    \ / max(max - min, min) * min\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\n\
    assert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmp2fc3ph_9.swift:8:22: error: type 'Double' has no member 'leastFiniteMagnitude'\n\
    \    var max = Double.leastFiniteMagnitude\n              ~~~~~~ ^~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmp2fc3ph_9.swift:10:15: error: cannot call value of non-function type 'Double'\n\
    \        min = min(min, number)\n              ^\n/tmp/tmp2fc3ph_9.swift:15:24:\
    \ error: value of optional type 'Array<Double>.Index?' (aka 'Optional<Int>') must\
    \ be unwrapped to a value of type 'Array<Double>.Index' (aka 'Int')\n        result[numbers.index(of:\
    \ number)] = number / max(max - min, min) * min\n                       ^\n/tmp/tmp2fc3ph_9.swift:15:24:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n        result[numbers.index(of: number)] = number / max(max - min, min)\
    \ * min\n                       ^\n                                         ??\
    \ <#default value#>\n/tmp/tmp2fc3ph_9.swift:15:24: note: force-unwrap using '!'\
    \ to abort execution if the optional value contains 'nil'\n        result[numbers.index(of:\
    \ number)] = number / max(max - min, min) * min\n                       ^\n  \
    \                                      !\n"
  stdout: ''
  timestamp: 1660013798
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var rescaled: [Double] = []\n    var smallest: Double = Double.greatestFiniteMagnitude\n\
    \    var largest: Double = Double.leastFiniteMagnitude\n    for number in numbers\
    \ {\n        rescaled.append(number / largest)\n        smallest = min(smallest,\
    \ number)\n        largest = max(largest, number)\n    }\n    return rescaled\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpsnofjsbp.swift:9:34: error: type 'Double' has no member 'leastFiniteMagnitude'\n\
    \    var largest: Double = Double.leastFiniteMagnitude\n                     \
    \     ~~~~~~ ^~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013798
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var min: Double = Double(Int.max)\n    var max: Double = Double(Int.min)\n\
    \    for number in numbers {\n        min = min(min, number)\n        max = max(max,\
    \ number)\n    }\n    var result: [Double] = []\n    for number in numbers {\n\
    \        result.append(number - min)\n        result.append(number - max)\n  \
    \  }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpd6kk2qbz.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpd6kk2qbz.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013798
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var min: Double = Double.greatestFiniteMagnitude\n    var max: Double\
    \ = Double.leastFiniteMagnitude\n    for number in numbers {\n        min = min(min,\
    \ number)\n        max = max(max, number)\n    }\n    var scaled: [Double] = []\n\
    \    for number in numbers {\n        scaled.append(number - min)\n        scaled.append(number\
    \ - max)\n    }\n    return scaled\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpzgau0uf0.swift:8:30: error: type 'Double' has no member 'leastFiniteMagnitude'\n\
    \    var max: Double = Double.leastFiniteMagnitude\n                      ~~~~~~\
    \ ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmpzgau0uf0.swift:10:15: error: cannot call value\
    \ of non-function type 'Double'\n        min = min(min, number)\n            \
    \  ^\n/tmp/tmpzgau0uf0.swift:11:15: error: cannot call value of non-function type\
    \ 'Double'\n        max = max(max, number)\n              ^\n"
  stdout: ''
  timestamp: 1660013798
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var scaled: [Double] = []\n    for number in numbers {\n        scaled.append((number\
    \ - min(numbers)) / max(numbers) + 0.5)\n    }\n    return scaled\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpva5b_23s.swift:9:44: error: missing argument for parameter #2 in\
    \ call\n        scaled.append((number - min(numbers)) / max(numbers) + 0.5)\n\
    \                                           ^\n                              \
    \             , <#Double#>\nSwift.min:1:24: note: 'min' declared here\n@inlinable\
    \ public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n             \
    \          ^\n/tmp/tmpva5b_23s.swift:9:60: error: missing argument for parameter\
    \ #2 in call\n        scaled.append((number - min(numbers)) / max(numbers) + 0.5)\n\
    \                                                           ^\n              \
    \                                             , <#Double#>\nSwift.max:1:24: note:\
    \ 'max' declared here\n@inlinable public func max<T>(_ x: T, _ y: T) -> T where\
    \ T : Comparable\n                       ^\n/tmp/tmpva5b_23s.swift:9:53: error:\
    \ cannot convert value of type '[Double]' to expected argument type 'Double'\n\
    \        scaled.append((number - min(numbers)) / max(numbers) + 0.5)\n       \
    \                                             ^\n/tmp/tmpva5b_23s.swift:9:37:\
    \ error: cannot convert value of type '[Double]' to expected argument type 'Double'\n\
    \        scaled.append((number - min(numbers)) / max(numbers) + 0.5)\n       \
    \                             ^\n"
  stdout: ''
  timestamp: 1660013813
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var min = Double(Int.max)\n    var max = Double(Int.min)\n    for number\
    \ in numbers {\n        min = min(min, number)\n        max = max(max, number)\n\
    \    }\n    var scaled: [Double] = []\n    for number in numbers {\n        scaled.append(number\
    \ - min)\n        scaled.append(number - max)\n    }\n    return scaled\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmp0fasisov.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmp0fasisov.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013798
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var min: Double = Double(Int.max)\n    var max: Double = Double(Int.min)\n\
    \    for number in numbers {\n        min = min(min, number)\n        max = max(max,\
    \ number)\n    }\n    var result: [Double] = []\n    for number in numbers {\n\
    \        result.append(number - min)\n        result.append(number - max)\n  \
    \  }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpd6kk2qbz.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpd6kk2qbz.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013798
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var min = Double(Int.max)\n    var max = Double(Int.min)\n    for number\
    \ in numbers {\n        min = min(min, number)\n        max = max(max, number)\n\
    \    }\n    var scaled: [Double] = []\n    for number in numbers {\n        scaled.append((number\
    \ - min) / (max - min))\n    }\n    return scaled\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpkqup1axs.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpkqup1axs.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013798
- exit_code: -4
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var rescaled: [Double] = []\n    for number in numbers {\n        rescaled.append(number\
    \ / min(number, 1.0))\n    }\n    return rescaled\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: Exception
  stderr: 'tmp_rm2k2ga/tmp_rm2k2ga.swift:27: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002afbb3671c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002afbb3368b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002afbb3368988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002afbb33677b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp_rm2k2ga                        0x000055e0cfdc4693 <unavailable> + 5779

    5    libc.so.6                          0x00002afbb385d460 __libc_start_main +
    245

    6    tmp_rm2k2ga                        0x000055e0cfdc4299 <unavailable> + 4761

    '
  stdout: ''
  timestamp: 1660013799
- exit_code: -4
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var min: Double = Double(Int.max)\n    var max: Double = Double(Int.min)\n\
    \    for number in numbers {\n        if number < min {\n            min = number\n\
    \        }\n        if number > max {\n            max = number\n        }\n \
    \   }\n    var result: [Double] = []\n    for number in numbers {\n        result.append(number\
    \ - min)\n        result.append(max - number)\n    }\n    return result\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: Exception
  stderr: 'tmpemuv9d9t/tmpemuv9d9t.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b8e774e1c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8e771d8b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b8e771d8988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b8e771d77b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpemuv9d9t                        0x0000558c5752b603 <unavailable> + 5635

    5    libc.so.6                          0x00002b8e776cd460 __libc_start_main +
    245

    6    tmpemuv9d9t                        0x0000558c5752b209 <unavailable> + 4617

    '
  stdout: ''
  timestamp: 1660013799
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var min: Double = Double.greatestFiniteMagnitude\n    var max: Double\
    \ = Double.leastFiniteMagnitude\n    for number in numbers {\n        if number\
    \ < min {\n            min = number\n        }\n        if number > max {\n  \
    \          max = number\n        }\n    }\n    var result: [Double] = []\n   \
    \ for number in numbers {\n        result.append(number - min)\n        result.append(number\
    \ / max - min)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpg2i9bv9r.swift:8:30: error: type 'Double' has no member 'leastFiniteMagnitude'\n\
    \    var max: Double = Double.leastFiniteMagnitude\n                      ~~~~~~\
    \ ^~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013799
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var min: Double = Double(Int.max)\n    var max: Double = Double(Int.min)\n\
    \    for number in numbers {\n        min = min(min, number)\n        max = max(max,\
    \ number)\n    }\n    var scaled: [Double] = []\n    for number in numbers {\n\
    \        scaled.append((number - min) / (max - min))\n    }\n    return scaled\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpwq0ustex.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpwq0ustex.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013798
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var min: Double = Double.greatestFiniteMagnitude\n    var max: Double\
    \ = Double.leastFiniteMagnitude\n    for number in numbers {\n        min = min(min,\
    \ number)\n        max = max(max, number)\n    }\n    var scaled: [Double] = []\n\
    \    for number in numbers {\n        scaled.append(number - min)\n    }\n   \
    \ for number in scaled {\n        number = number / max - min\n    }\n    return\
    \ scaled\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpdlvexikk.swift:8:30: error: type 'Double' has no member 'leastFiniteMagnitude'\n\
    \    var max: Double = Double.leastFiniteMagnitude\n                      ~~~~~~\
    \ ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmpdlvexikk.swift:10:15: error: cannot call value\
    \ of non-function type 'Double'\n        min = min(min, number)\n            \
    \  ^\n/tmp/tmpdlvexikk.swift:11:15: error: cannot call value of non-function type\
    \ 'Double'\n        max = max(max, number)\n              ^\n/tmp/tmpdlvexikk.swift:18:9:\
    \ error: cannot assign to value: 'number' is a 'let' constant\n        number\
    \ = number / max - min\n        ^~~~~~\n"
  stdout: ''
  timestamp: 1660013798
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var min: Double = Double(Int.max)\n    var max: Double = Double(Int.min)\n\
    \    for number in numbers {\n        min = min(min, number)\n        max = max(max,\
    \ number)\n    }\n    var scaled: [Double] = []\n    for number in numbers {\n\
    \        scaled.append((number - min) / (max - min))\n    }\n    return scaled\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpwq0ustex.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpwq0ustex.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013798
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var min: Double = Double(Int.max)\n    var max: Double = Double(Int.min)\n\
    \    for number in numbers {\n        min = min(min, number)\n        max = max(max,\
    \ number)\n    }\n    var result: [Double] = []\n    for number in numbers {\n\
    \        result.append(number - min)\n        result.append(number - max)\n  \
    \  }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpd6kk2qbz.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpd6kk2qbz.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013798
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var min: Double = Double(Int.max)\n    var max: Double = Double(Int.min)\n\
    \    for number in numbers {\n        min = min(min, number)\n        max = max(max,\
    \ number)\n    }\n    var result: [Double] = []\n    for number in numbers {\n\
    \        result.append(number - min)\n        result.append(number - max)\n  \
    \  }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpd6kk2qbz.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpd6kk2qbz.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013798
- exit_code: -4
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var rescaled: [Double] = []\n    for number in numbers {\n        rescaled.append(min(max(number,\
    \ 0.0), 1.0))\n    }\n    return rescaled\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: Exception
  stderr: 'tmpf2da8feh/tmpf2da8feh.swift:27: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac3edc0ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac3ed905b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac3ed905988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac3ed9047b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpf2da8feh                        0x000056511904c6f3 <unavailable> + 5875

    5    libc.so.6                          0x00002ac3eddfa460 __libc_start_main +
    245

    6    tmpf2da8feh                        0x000056511904c2f9 <unavailable> + 4857

    '
  stdout: ''
  timestamp: 1660013799
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var min = Double(Int.max)\n    var max = Double(Int.min)\n    for number\
    \ in numbers {\n        min = min(min, number)\n        max = max(max, number)\n\
    \    }\n    var scaled: [Double] = []\n    for number in numbers {\n        scaled.append(number\
    \ - min)\n        scaled.append(number - max)\n    }\n    return scaled\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmp0fasisov.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmp0fasisov.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013798
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var min = Double(Int.max)\n    var max = Double(Int.min)\n    for number\
    \ in numbers {\n        min = min(min, number)\n        max = max(max, number)\n\
    \    }\n    var scaled: [Double] = []\n    for number in numbers {\n        scaled.append((number\
    \ - min) / (max - min))\n    }\n    return scaled\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpkqup1axs.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpkqup1axs.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013798
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var scaled: [Double] = []\n    for number in numbers {\n        scaled.append(number\
    \ / min(number))\n    }\n    return scaled\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmp4sh9ylys.swift:9:42: error: missing argument for parameter #2 in\
    \ call\n        scaled.append(number / min(number))\n                        \
    \                 ^\n                                         , <#Double#>\nSwift.min:1:24:\
    \ note: 'min' declared here\n@inlinable public func min<T>(_ x: T, _ y: T) ->\
    \ T where T : Comparable\n                       ^\n"
  stdout: ''
  timestamp: 1660013798
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var scaled: [Double] = []\n    for number in numbers {\n        scaled.append(number\
    \ / min(number))\n    }\n    return scaled\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmp4sh9ylys.swift:9:42: error: missing argument for parameter #2 in\
    \ call\n        scaled.append(number / min(number))\n                        \
    \                 ^\n                                         , <#Double#>\nSwift.min:1:24:\
    \ note: 'min' declared here\n@inlinable public func min<T>(_ x: T, _ y: T) ->\
    \ T where T : Comparable\n                       ^\n"
  stdout: ''
  timestamp: 1660013798
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var scaled: [Double] = []\n    var min: Double = Double(Int.max)\n  \
    \  var max: Double = Double(Int.min)\n    for number in numbers {\n        min\
    \ = min(min, number)\n        max = max(max, number)\n    }\n    for number in\
    \ numbers {\n        scaled.append((number - min) / (max - min))\n    }\n    return\
    \ scaled\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpjj3_1qf2.swift:11:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpjj3_1qf2.swift:12:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013798
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var scaled: [Double] = []\n    var min: Double = Double.greatestFiniteMagnitude\n\
    \    var max: Double = Double.lowestFiniteMagnitude\n    for number in numbers\
    \ {\n        min = min(min, number)\n        max = max(max, number)\n    }\n \
    \   for number in numbers {\n        scaled.append(number - min)\n    }\n    for\
    \ number in numbers {\n        scaled.append(number / max - min)\n    }\n    return\
    \ scaled\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpjgm_umgl.swift:9:30: error: type 'Double' has no member 'lowestFiniteMagnitude'\n\
    \    var max: Double = Double.lowestFiniteMagnitude\n                      ~~~~~~\
    \ ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpjgm_umgl.swift:11:15: error: cannot call value\
    \ of non-function type 'Double'\n        min = min(min, number)\n            \
    \  ^\n/tmp/tmpjgm_umgl.swift:12:15: error: cannot call value of non-function type\
    \ 'Double'\n        max = max(max, number)\n              ^\n"
  stdout: ''
  timestamp: 1660013798
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var scaled: [Double] = []\n    var min: Double = Double.greatestFiniteMagnitude\n\
    \    var max: Double = Double.lowestFiniteMagnitude\n    for number in numbers\
    \ {\n        min = min(min, number)\n        max = max(max, number)\n    }\n \
    \   for number in numbers {\n        scaled.append(number * (max - min) / Double(numbers.count))\n\
    \    }\n    return scaled\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmp8fy5y82p.swift:9:30: error: type 'Double' has no member 'lowestFiniteMagnitude'\n\
    \    var max: Double = Double.lowestFiniteMagnitude\n                      ~~~~~~\
    \ ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp8fy5y82p.swift:11:15: error: cannot call value\
    \ of non-function type 'Double'\n        min = min(min, number)\n            \
    \  ^\n/tmp/tmp8fy5y82p.swift:12:15: error: cannot call value of non-function type\
    \ 'Double'\n        max = max(max, number)\n              ^\n"
  stdout: ''
  timestamp: 1660013799
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var min = Double(numbers[0])\n    var max = Double(numbers[0])\n    for\
    \ number in numbers {\n        if number < min {\n            min = number\n \
    \       }\n        if number > max {\n            max = number\n        }\n  \
    \  }\n    var result = [Double](repeating: 0.0, count: numbers.count)\n    for\
    \ number in numbers {\n        result[numbers.index(of: number)] = ((number -\
    \ min) / (max - min)) * 1.0\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpyf97bmj6.swift:19:24: error: value of optional type 'Array<Double>.Index?'\
    \ (aka 'Optional<Int>') must be unwrapped to a value of type 'Array<Double>.Index'\
    \ (aka 'Int')\n        result[numbers.index(of: number)] = ((number - min) / (max\
    \ - min)) * 1.0\n                       ^\n/tmp/tmpyf97bmj6.swift:19:24: note:\
    \ coalesce using '??' to provide a default when the optional value contains 'nil'\n\
    \        result[numbers.index(of: number)] = ((number - min) / (max - min)) *\
    \ 1.0\n                       ^\n                                         ?? <#default\
    \ value#>\n/tmp/tmpyf97bmj6.swift:19:24: note: force-unwrap using '!' to abort\
    \ execution if the optional value contains 'nil'\n        result[numbers.index(of:\
    \ number)] = ((number - min) / (max - min)) * 1.0\n                       ^\n\
    \                                        !\n"
  stdout: ''
  timestamp: 1660013798
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var min = Double(Int.max)\n    var max = Double(Int.min)\n    for number\
    \ in numbers {\n        min = min(min, number)\n        max = max(max, number)\n\
    \    }\n    var scaled: [Double] = []\n    for number in numbers {\n        scaled.append((number\
    \ - min) / (max - min))\n    }\n    return scaled\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpkqup1axs.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpkqup1axs.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013798
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var min: Double = Double(Int.max)\n    var max: Double = Double(Int.min)\n\
    \    for number in numbers {\n        min = min(min, number)\n        max = max(max,\
    \ number)\n    }\n    var scaled: [Double] = []\n    for number in numbers {\n\
    \        scaled.append((number - min) / (max - min))\n    }\n    return scaled\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpwq0ustex.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpwq0ustex.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013798
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var min: Double = Double(Int.max)\n    var max: Double = Double(Int.min)\n\
    \    for number in numbers {\n        min = min(min, number)\n        max = max(max,\
    \ number)\n    }\n    var result: [Double] = []\n    for number in numbers {\n\
    \        result.append(number - min)\n        result.append(number - max)\n  \
    \  }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpd6kk2qbz.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpd6kk2qbz.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013798
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var min: Double = Double(Int.max)\n    var max: Double = Double(Int.min)\n\
    \    for number in numbers {\n        min = min(min, number)\n        max = max(max,\
    \ number)\n    }\n    var result: [Double] = []\n    for number in numbers {\n\
    \        result.append(number - min)\n        result.append(number - max)\n  \
    \  }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpd6kk2qbz.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpd6kk2qbz.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013798
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var rescaled: [Double] = []\n    var min: Double = Double.greatestFiniteMagnitude\n\
    \    var max: Double = Double.lowestFiniteMagnitude\n    for number in numbers\
    \ {\n        rescaled.append(number - min)\n        rescaled.append(number - max)\n\
    \        min = min(min, number)\n        max = max(max, number)\n    }\n    return\
    \ rescaled\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmprbg7ivi1.swift:9:30: error: type 'Double' has no member 'lowestFiniteMagnitude'\n\
    \    var max: Double = Double.lowestFiniteMagnitude\n                      ~~~~~~\
    \ ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmprbg7ivi1.swift:13:15: error: cannot call value\
    \ of non-function type 'Double'\n        min = min(min, number)\n            \
    \  ^\n/tmp/tmprbg7ivi1.swift:14:15: error: cannot call value of non-function type\
    \ 'Double'\n        max = max(max, number)\n              ^\n"
  stdout: ''
  timestamp: 1660013799
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var min = Double(Int.max)\n    var max = Double(Int.min)\n    for number\
    \ in numbers {\n        min = min(min, number)\n        max = max(max, number)\n\
    \    }\n    var result: [Double] = []\n    for number in numbers {\n        result.append(number\
    \ - min)\n        result.append(number - max)\n    }\n    return result\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpd9hsoeox.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpd9hsoeox.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013798
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var min = Double(Int.max)\n    var max = Double(Int.min)\n    for number\
    \ in numbers {\n        min = min(min, number)\n        max = max(max, number)\n\
    \    }\n    var scaled: [Double] = []\n    for number in numbers {\n        scaled.append((number\
    \ - min) / (max - min))\n    }\n    return scaled\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpkqup1axs.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpkqup1axs.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013798
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var min: Double = Double(Int.max)\n    var max: Double = Double(Int.min)\n\
    \    for number in numbers {\n        min = min(min, number)\n        max = max(max,\
    \ number)\n    }\n    var result: [Double] = []\n    for number in numbers {\n\
    \        result.append(number - min)\n        result.append(number - max)\n  \
    \  }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpd6kk2qbz.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpd6kk2qbz.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013798
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var min: Double = Double(Int.max)\n    var max: Double = Double(Int.min)\n\
    \    for number in numbers {\n        min = min(min, number)\n        max = max(max,\
    \ number)\n    }\n    var result: [Double] = []\n    for number in numbers {\n\
    \        result.append(number - min)\n        result.append(number - max)\n  \
    \  }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpd6kk2qbz.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpd6kk2qbz.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013798
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var min: Double = Double(Int.max)\n    var max: Double = Double(Int.min)\n\
    \    for number in numbers {\n        min = min(min, number)\n        max = max(max,\
    \ number)\n    }\n    var result: [Double] = []\n    for number in numbers {\n\
    \        result.append(number - min)\n        result.append(number - max)\n  \
    \  }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpd6kk2qbz.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpd6kk2qbz.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013798
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var scaled: [Double] = []\n    var min: Double = Double.greatestFiniteMagnitude\n\
    \    var max: Double = Double.lowestFiniteMagnitude\n    for number in numbers\
    \ {\n        min = min(min, number)\n        max = max(max, number)\n        scaled.append(number\
    \ - min)\n    }\n    for number in numbers {\n        scaled.append(number / max\
    \ - min)\n    }\n    return scaled\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpwrha_tjs.swift:9:30: error: type 'Double' has no member 'lowestFiniteMagnitude'\n\
    \    var max: Double = Double.lowestFiniteMagnitude\n                      ~~~~~~\
    \ ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpwrha_tjs.swift:11:15: error: cannot call value\
    \ of non-function type 'Double'\n        min = min(min, number)\n            \
    \  ^\n/tmp/tmpwrha_tjs.swift:12:15: error: cannot call value of non-function type\
    \ 'Double'\n        max = max(max, number)\n              ^\n"
  stdout: ''
  timestamp: 1660013799
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var scaled: [Double] = []\n    var smallest: Double = Double.greatestFiniteMagnitude\n\
    \    var largest: Double = Double.leastFiniteMagnitude\n    for number in numbers\
    \ {\n        scaled.append(number / largest)\n        largest = Double(max(largest,\
    \ number))\n        smallest = Double(min(smallest, number))\n    }\n    return\
    \ scaled\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmp1tpai2bh.swift:9:34: error: type 'Double' has no member 'leastFiniteMagnitude'\n\
    \    var largest: Double = Double.leastFiniteMagnitude\n                     \
    \     ~~~~~~ ^~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013799
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var min = Double(Int.max)\n    var max = Double(Int.min)\n    for number\
    \ in numbers {\n        min = min(min, number)\n        max = max(max, number)\n\
    \    }\n    var scaled: [Double] = []\n    for number in numbers {\n        scaled.append((number\
    \ - min) / (max - min))\n    }\n    return scaled\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpkqup1axs.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpkqup1axs.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013798
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    let min = min(numbers)\n    let max = max(numbers)\n    var scaled: [Double]\
    \ = []\n    for number in numbers {\n        scaled.append(number * (max - min)\
    \ / Double(numbers.count))\n    }\n    return scaled\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpnrbatwei.swift:7:26: error: missing argument for parameter #2 in\
    \ call\n    let min = min(numbers)\n                         ^\n             \
    \            , <#[Double]#>\nSwift.min:1:24: note: 'min' declared here\n@inlinable\
    \ public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n             \
    \          ^\n/tmp/tmpnrbatwei.swift:8:26: error: missing argument for parameter\
    \ #2 in call\n    let max = max(numbers)\n                         ^\n       \
    \                  , <#[Double]#>\nSwift.max:1:24: note: 'max' declared here\n\
    @inlinable public func max<T>(_ x: T, _ y: T) -> T where T : Comparable\n    \
    \                   ^\n"
  stdout: ''
  timestamp: 1660013799
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var min: Double = Double.greatestFiniteMagnitude\n    var max: Double\
    \ = Double.leastFiniteMagnitude\n    for number in numbers {\n        min = min(min,\
    \ number)\n        max = max(max, number)\n    }\n    var scaled: [Double] = []\n\
    \    for number in numbers {\n        scaled.append(number - min)\n        scaled.append(number\
    \ - max)\n    }\n    return scaled\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpzgau0uf0.swift:8:30: error: type 'Double' has no member 'leastFiniteMagnitude'\n\
    \    var max: Double = Double.leastFiniteMagnitude\n                      ~~~~~~\
    \ ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmpzgau0uf0.swift:10:15: error: cannot call value\
    \ of non-function type 'Double'\n        min = min(min, number)\n            \
    \  ^\n/tmp/tmpzgau0uf0.swift:11:15: error: cannot call value of non-function type\
    \ 'Double'\n        max = max(max, number)\n              ^\n"
  stdout: ''
  timestamp: 1660013798
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var min: Double = Double(Int.max)\n    var max: Double = Double(Int.min)\n\
    \    for number in numbers {\n        min = min(min, number)\n        max = max(max,\
    \ number)\n    }\n    var result: [Double] = []\n    for number in numbers {\n\
    \        result.append(number - min)\n        result.append(number - max)\n  \
    \  }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpd6kk2qbz.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpd6kk2qbz.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013798
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    let min = min(numbers)\n    let max = max(numbers)\n    var scaled: [Double]\
    \ = []\n    for number in numbers {\n        scaled.append(number - min)\n   \
    \     scaled.append(number - max)\n    }\n    return scaled\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\n\
    assert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmp12gz0g_0.swift:7:26: error: missing argument for parameter #2 in\
    \ call\n    let min = min(numbers)\n                         ^\n             \
    \            , <#[Double]#>\nSwift.min:1:24: note: 'min' declared here\n@inlinable\
    \ public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n             \
    \          ^\n/tmp/tmp12gz0g_0.swift:8:26: error: missing argument for parameter\
    \ #2 in call\n    let max = max(numbers)\n                         ^\n       \
    \                  , <#[Double]#>\nSwift.max:1:24: note: 'max' declared here\n\
    @inlinable public func max<T>(_ x: T, _ y: T) -> T where T : Comparable\n    \
    \                   ^\n"
  stdout: ''
  timestamp: 1660013799
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var min: Double = Double(Int.max)\n    var max: Double = Double(Int.min)\n\
    \    for number in numbers {\n        min = min(min, number)\n        max = max(max,\
    \ number)\n    }\n    var result: [Double] = []\n    for number in numbers {\n\
    \        result.append(number - min)\n        result.append(number - max)\n  \
    \  }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpd6kk2qbz.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpd6kk2qbz.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013798
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var min: Double = Double(Int.max)\n    var max: Double = Double(Int.min)\n\
    \    for number in numbers {\n        min = min(min, number)\n        max = max(max,\
    \ number)\n    }\n    var result: [Double] = []\n    for number in numbers {\n\
    \        result.append(number - min)\n        result.append(number - max)\n  \
    \  }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpd6kk2qbz.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpd6kk2qbz.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013798
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    let min = min(numbers)\n    let max = max(numbers)\n    var scaled: [Double]\
    \ = []\n    for number in numbers {\n        scaled.append((number - min) / (max\
    \ - min))\n    }\n    return scaled\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpp31a_vbo.swift:7:26: error: missing argument for parameter #2 in\
    \ call\n    let min = min(numbers)\n                         ^\n             \
    \            , <#[Double]#>\nSwift.min:1:24: note: 'min' declared here\n@inlinable\
    \ public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n             \
    \          ^\n/tmp/tmpp31a_vbo.swift:8:26: error: missing argument for parameter\
    \ #2 in call\n    let max = max(numbers)\n                         ^\n       \
    \                  , <#[Double]#>\nSwift.max:1:24: note: 'max' declared here\n\
    @inlinable public func max<T>(_ x: T, _ y: T) -> T where T : Comparable\n    \
    \                   ^\n"
  stdout: ''
  timestamp: 1660013799
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var scaled: [Double] = []\n    var smallest: Double = Double.greatestFiniteMagnitude\n\
    \    var largest: Double = Double.leastFiniteMagnitude\n    for number in numbers\
    \ {\n        let scaledNumber = number / largest\n        scaled.append(scaledNumber)\n\
    \        largest = Double(max(largest, scaledNumber))\n        smallest = Double(min(smallest,\
    \ scaledNumber))\n    }\n    return scaled\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpor3o3r6w.swift:9:34: error: type 'Double' has no member 'leastFiniteMagnitude'\n\
    \    var largest: Double = Double.leastFiniteMagnitude\n                     \
    \     ~~~~~~ ^~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013799
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var rescaled: [Double] = []\n    var min: Double = Double.greatestFiniteMagnitude\n\
    \    var max: Double = Double.lowestFiniteMagnitude\n    for number in numbers\
    \ {\n        let rescaled = number / max - min\n        min = min(min, rescaled)\n\
    \        max = max(max, rescaled)\n        rescaled.append(rescaled)\n    }\n\
    \    return rescaled\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpuxq0mjkc.swift:9:30: error: type 'Double' has no member 'lowestFiniteMagnitude'\n\
    \    var max: Double = Double.lowestFiniteMagnitude\n                      ~~~~~~\
    \ ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpuxq0mjkc.swift:12:15: error: cannot call value\
    \ of non-function type 'Double'\n        min = min(min, rescaled)\n          \
    \    ^\n/tmp/tmpuxq0mjkc.swift:13:15: error: cannot call value of non-function\
    \ type 'Double'\n        max = max(max, rescaled)\n              ^\n/tmp/tmpuxq0mjkc.swift:14:18:\
    \ error: value of type 'Double' has no member 'append'\n        rescaled.append(rescaled)\n\
    \        ~~~~~~~~ ^~~~~~\n"
  stdout: ''
  timestamp: 1660013799
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var min = Double(Int.max)\n    var max = Double(Int.min)\n    for number\
    \ in numbers {\n        min = min(min, number)\n        max = max(max, number)\n\
    \    }\n    var result = [Double](repeating: 0, count: numbers.count)\n    for\
    \ number in numbers {\n        result[numbers.index(of: number)] = number / max(max\
    \ - min, Double(1))\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpqgr30nrm.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpqgr30nrm.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n/tmp/tmpqgr30nrm.swift:15:24: error: value of optional\
    \ type 'Array<Double>.Index?' (aka 'Optional<Int>') must be unwrapped to a value\
    \ of type 'Array<Double>.Index' (aka 'Int')\n        result[numbers.index(of:\
    \ number)] = number / max(max - min, Double(1))\n                       ^\n/tmp/tmpqgr30nrm.swift:15:24:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n        result[numbers.index(of: number)] = number / max(max - min, Double(1))\n\
    \                       ^\n                                         ?? <#default\
    \ value#>\n/tmp/tmpqgr30nrm.swift:15:24: note: force-unwrap using '!' to abort\
    \ execution if the optional value contains 'nil'\n        result[numbers.index(of:\
    \ number)] = number / max(max - min, Double(1))\n                       ^\n  \
    \                                      !\n/tmp/tmpqgr30nrm.swift:15:54: error:\
    \ cannot call value of non-function type 'Double'\n        result[numbers.index(of:\
    \ number)] = number / max(max - min, Double(1))\n                            \
    \                         ^\n"
  stdout: ''
  timestamp: 1660013799
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var scaled = [Double](repeating: 0.0, count: numbers.count)\n    var\
    \ smallest = Double.greatestFiniteMagnitude\n    var largest = Double.lowestFiniteMagnitude\n\
    \    for i in 0..<numbers.count {\n        scaled[i] = numbers[i] / largest\n\
    \        smallest = min(smallest, numbers[i])\n        largest = max(largest,\
    \ numbers[i])\n    }\n    for i in 0..<numbers.count {\n        scaled[i] = scaled[i]\
    \ * (largest - smallest) + smallest\n    }\n    return scaled\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\n\
    assert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpsgmaindr.swift:9:26: error: type 'Double' has no member 'lowestFiniteMagnitude'\n\
    \    var largest = Double.lowestFiniteMagnitude\n                  ~~~~~~ ^~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013799
- exit_code: -4
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var rescaled: [Double] = []\n    for number in numbers {\n        rescaled.append(min(max(number,\
    \ 0.0), 1.0))\n    }\n    return rescaled\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: Exception
  stderr: 'tmpf2da8feh/tmpf2da8feh.swift:27: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac3edc0ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac3ed905b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac3ed905988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac3ed9047b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpf2da8feh                        0x000056511904c6f3 <unavailable> + 5875

    5    libc.so.6                          0x00002ac3eddfa460 __libc_start_main +
    245

    6    tmpf2da8feh                        0x000056511904c2f9 <unavailable> + 4857

    '
  stdout: ''
  timestamp: 1660013799
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    guard numbers.count > 1 else {\n        return numbers\n    }\n\n   \
    \ var min: Double = Double(numbers.first!)\n    var max: Double = Double(numbers.last!)\n\
    \    for number in numbers {\n        min = min(min, number)\n        max = max(max,\
    \ number)\n    }\n\n    var scaled: [Double] = []\n    for number in numbers {\n\
    \        scaled.append(number - min)\n    }\n    scaled.append(1.0)\n    scaled.append(max\
    \ - min)\n    return scaled\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpeocnmatq.swift:14:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpeocnmatq.swift:15:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013799
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var scaled: [Double] = []\n    var min: Double = Double.greatestFiniteMagnitude\n\
    \    var max: Double = Double.lowestFiniteMagnitude\n    for number in numbers\
    \ {\n        min = min(min, number)\n        max = max(max, number)\n    }\n \
    \   for number in numbers {\n        scaled.append(number - min)\n        scaled.append(number\
    \ - max)\n    }\n    return scaled\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpope2wffe.swift:9:30: error: type 'Double' has no member 'lowestFiniteMagnitude'\n\
    \    var max: Double = Double.lowestFiniteMagnitude\n                      ~~~~~~\
    \ ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpope2wffe.swift:11:15: error: cannot call value\
    \ of non-function type 'Double'\n        min = min(min, number)\n            \
    \  ^\n/tmp/tmpope2wffe.swift:12:15: error: cannot call value of non-function type\
    \ 'Double'\n        max = max(max, number)\n              ^\n"
  stdout: ''
  timestamp: 1660013799
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var min: Double = Double(Int.max)\n    var max: Double = Double(Int.min)\n\
    \    for number in numbers {\n        min = min(min, number)\n        max = max(max,\
    \ number)\n    }\n    var result: [Double] = []\n    for number in numbers {\n\
    \        result.append(number - min)\n        result.append(number - max)\n  \
    \  }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpd6kk2qbz.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpd6kk2qbz.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013798
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var min: Double = Double(Int.max)\n    var max: Double = Double(Int.min)\n\
    \    for number in numbers {\n        min = min(min, number)\n        max = max(max,\
    \ number)\n    }\n    var result: [Double] = []\n    for number in numbers {\n\
    \        result.append(number - min)\n        result.append(number - max)\n  \
    \  }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpd6kk2qbz.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpd6kk2qbz.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013798
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var min: Double = Double.greatestFiniteMagnitude\n    var max: Double\
    \ = Double.lowestFiniteMagnitude\n    for number in numbers {\n        min = min(min,\
    \ number)\n        max = max(max, number)\n    }\n    var result: [Double] = []\n\
    \    for number in numbers {\n        result.append(number - min)\n        result.append(number\
    \ / max - min)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpur8kmdx3.swift:8:30: error: type 'Double' has no member 'lowestFiniteMagnitude'\n\
    \    var max: Double = Double.lowestFiniteMagnitude\n                      ~~~~~~\
    \ ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpur8kmdx3.swift:10:15: error: cannot call value\
    \ of non-function type 'Double'\n        min = min(min, number)\n            \
    \  ^\n/tmp/tmpur8kmdx3.swift:11:15: error: cannot call value of non-function type\
    \ 'Double'\n        max = max(max, number)\n              ^\n"
  stdout: ''
  timestamp: 1660013799
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var scaled: [Double] = []\n    var min: Double = Double.greatestFiniteMagnitude\n\
    \    var max: Double = Double.lowestFiniteMagnitude\n    for number in numbers\
    \ {\n        let scaledNumber = number / max - min\n        scaled.append(scaledNumber)\n\
    \        min = min(min, number)\n        max = max(max, number)\n    }\n    return\
    \ scaled\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpnvjuebgk.swift:9:30: error: type 'Double' has no member 'lowestFiniteMagnitude'\n\
    \    var max: Double = Double.lowestFiniteMagnitude\n                      ~~~~~~\
    \ ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpnvjuebgk.swift:13:15: error: cannot call value\
    \ of non-function type 'Double'\n        min = min(min, number)\n            \
    \  ^\n/tmp/tmpnvjuebgk.swift:14:15: error: cannot call value of non-function type\
    \ 'Double'\n        max = max(max, number)\n              ^\n"
  stdout: ''
  timestamp: 1660013798
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var min = Double(Int.max)\n    var max = Double(Int.min)\n    for number\
    \ in numbers {\n        min = min(min, number)\n        max = max(max, number)\n\
    \    }\n    var scaled: [Double] = []\n    for number in numbers {\n        scaled.append(number\
    \ - min)\n    }\n    for number in scaled {\n        number = number / max\n \
    \   }\n    return scaled\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpn8vnyjdc.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpn8vnyjdc.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n/tmp/tmpn8vnyjdc.swift:18:9: error: cannot assign\
    \ to value: 'number' is a 'let' constant\n        number = number / max\n    \
    \    ^~~~~~\n"
  stdout: ''
  timestamp: 1660013799
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    guard numbers.count > 1 else { return numbers }\n    var min = Double(numbers.first!)\n\
    \    var max = Double(numbers.last!)\n    for number in numbers {\n        min\
    \ = min(min, number)\n        max = max(max, number)\n    }\n    var scaled: [Double]\
    \ = []\n    for number in numbers {\n        scaled.append(number - min)\n   \
    \ }\n    for number in scaled {\n        number /= max - min\n    }\n    return\
    \ scaled\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpx7v7b0a6.swift:11:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpx7v7b0a6.swift:12:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n/tmp/tmpx7v7b0a6.swift:19:16: error: left side of\
    \ mutating operator isn't mutable: 'number' is a 'let' constant\n        number\
    \ /= max - min\n        ~~~~~~ ^\n"
  stdout: ''
  timestamp: 1660013799
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var min: Double = Double.greatestFiniteMagnitude\n    var max: Double\
    \ = Double.lowestFiniteMagnitude\n    for number in numbers {\n        min = min(min,\
    \ number)\n        max = max(max, number)\n    }\n    var scaled: [Double] = []\n\
    \    for number in numbers {\n        scaled.append(number - min)\n        scaled.append(number\
    \ - max)\n    }\n    return scaled\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpd_n77irr.swift:8:30: error: type 'Double' has no member 'lowestFiniteMagnitude'\n\
    \    var max: Double = Double.lowestFiniteMagnitude\n                      ~~~~~~\
    \ ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpd_n77irr.swift:10:15: error: cannot call value\
    \ of non-function type 'Double'\n        min = min(min, number)\n            \
    \  ^\n/tmp/tmpd_n77irr.swift:11:15: error: cannot call value of non-function type\
    \ 'Double'\n        max = max(max, number)\n              ^\n"
  stdout: ''
  timestamp: 1660013799
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var min: Double = Double.greatestFiniteMagnitude\n    var max: Double\
    \ = Double.leastFiniteMagnitude\n    for number in numbers {\n        min = min(min,\
    \ number)\n        max = max(max, number)\n    }\n    var result: [Double] = []\n\
    \    for number in numbers {\n        result.append(number - min)\n        result.append(number\
    \ - max)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpqhtwqsbu.swift:8:30: error: type 'Double' has no member 'leastFiniteMagnitude'\n\
    \    var max: Double = Double.leastFiniteMagnitude\n                      ~~~~~~\
    \ ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmpqhtwqsbu.swift:10:15: error: cannot call value\
    \ of non-function type 'Double'\n        min = min(min, number)\n            \
    \  ^\n/tmp/tmpqhtwqsbu.swift:11:15: error: cannot call value of non-function type\
    \ 'Double'\n        max = max(max, number)\n              ^\n"
  stdout: ''
  timestamp: 1660013798
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var min: Double = Double.greatestFiniteMagnitude\n    var max: Double\
    \ = Double.leastFiniteMagnitude\n    for number in numbers {\n        min = min(min,\
    \ number)\n        max = max(max, number)\n    }\n    var result: [Double] = []\n\
    \    for number in numbers {\n        result.append(number - min)\n        result.append(number\
    \ / max - min)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpqflvi45k.swift:8:30: error: type 'Double' has no member 'leastFiniteMagnitude'\n\
    \    var max: Double = Double.leastFiniteMagnitude\n                      ~~~~~~\
    \ ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmpqflvi45k.swift:10:15: error: cannot call value\
    \ of non-function type 'Double'\n        min = min(min, number)\n            \
    \  ^\n/tmp/tmpqflvi45k.swift:11:15: error: cannot call value of non-function type\
    \ 'Double'\n        max = max(max, number)\n              ^\n"
  stdout: ''
  timestamp: 1660013799
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var min = Double.max\n    var max = Double.min\n    for number in numbers\
    \ {\n        min = min(min, number)\n        max = max(max, number)\n    }\n \
    \   var result: [Double] = []\n    for number in numbers {\n        result.append(number\
    \ - min)\n        result.append(number - max)\n    }\n    return result\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpa_run13y.swift:7:22: error: type 'Double' has no member 'max'\n\
    \    var min = Double.max\n              ~~~~~~ ^~~\n/tmp/tmpa_run13y.swift:8:22:\
    \ error: type 'Double' has no member 'min'\n    var max = Double.min\n       \
    \       ~~~~~~ ^~~\n"
  stdout: ''
  timestamp: 1660013799
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var min: Double = Double.greatestFiniteMagnitude\n    var max: Double\
    \ = Double.leastFiniteMagnitude\n    for number in numbers {\n        min = min(min,\
    \ number)\n        max = max(max, number)\n    }\n    var result: [Double] = []\n\
    \    for number in numbers {\n        result.append(number - min)\n        result.append(number\
    \ / max - min)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpqflvi45k.swift:8:30: error: type 'Double' has no member 'leastFiniteMagnitude'\n\
    \    var max: Double = Double.leastFiniteMagnitude\n                      ~~~~~~\
    \ ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmpqflvi45k.swift:10:15: error: cannot call value\
    \ of non-function type 'Double'\n        min = min(min, number)\n            \
    \  ^\n/tmp/tmpqflvi45k.swift:11:15: error: cannot call value of non-function type\
    \ 'Double'\n        max = max(max, number)\n              ^\n"
  stdout: ''
  timestamp: 1660013799
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var min = Double(Int.max)\n    var max = Double(Int.min)\n    for number\
    \ in numbers {\n        min = min(min, number)\n        max = max(max, number)\n\
    \    }\n    var scaled: [Double] = []\n    for number in numbers {\n        scaled.append(number\
    \ - min)\n    }\n    for number in scaled {\n        number = number / max\n \
    \   }\n    return scaled\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpn8vnyjdc.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpn8vnyjdc.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n/tmp/tmpn8vnyjdc.swift:18:9: error: cannot assign\
    \ to value: 'number' is a 'let' constant\n        number = number / max\n    \
    \    ^~~~~~\n"
  stdout: ''
  timestamp: 1660013799
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var min: Double = Double(Int.max)\n    var max: Double = Double(Int.min)\n\
    \    for number in numbers {\n        min = min(min, number)\n        max = max(max,\
    \ number)\n    }\n    var result: [Double] = []\n    for number in numbers {\n\
    \        result.append(number - min)\n        result.append(number - max)\n  \
    \  }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpd6kk2qbz.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpd6kk2qbz.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013798
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var min: Double = Double(Int.max)\n    var max: Double = Double(Int.min)\n\
    \    for number in numbers {\n        min = min(min, number)\n        max = max(max,\
    \ number)\n    }\n    var result: [Double] = []\n    for number in numbers {\n\
    \        result.append(number - min)\n        result.append(number - max)\n  \
    \  }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpd6kk2qbz.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpd6kk2qbz.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013798
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var min = Double(Int.max)\n    var max = Double(Int.min)\n    for number\
    \ in numbers {\n        min = min(min, number)\n        max = max(max, number)\n\
    \    }\n    var result: [Double] = []\n    for number in numbers {\n        result.append(number\
    \ - min)\n        result.append(number - max)\n    }\n    return result\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpd9hsoeox.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpd9hsoeox.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013798
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var min = Double(Int.max)\n    var max = Double(Int.min)\n    for number\
    \ in numbers {\n        min = min(min, number)\n        max = max(max, number)\n\
    \    }\n    var result = [Double](repeating: 0.0, count: numbers.count)\n    for\
    \ number in numbers {\n        result[numbers.index(of: number)] = number / max(max\
    \ - min, Double(1))\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmprs5h6yaa.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmprs5h6yaa.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n/tmp/tmprs5h6yaa.swift:15:24: error: value of optional\
    \ type 'Array<Double>.Index?' (aka 'Optional<Int>') must be unwrapped to a value\
    \ of type 'Array<Double>.Index' (aka 'Int')\n        result[numbers.index(of:\
    \ number)] = number / max(max - min, Double(1))\n                       ^\n/tmp/tmprs5h6yaa.swift:15:24:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n        result[numbers.index(of: number)] = number / max(max - min, Double(1))\n\
    \                       ^\n                                         ?? <#default\
    \ value#>\n/tmp/tmprs5h6yaa.swift:15:24: note: force-unwrap using '!' to abort\
    \ execution if the optional value contains 'nil'\n        result[numbers.index(of:\
    \ number)] = number / max(max - min, Double(1))\n                       ^\n  \
    \                                      !\n/tmp/tmprs5h6yaa.swift:15:54: error:\
    \ cannot call value of non-function type 'Double'\n        result[numbers.index(of:\
    \ number)] = number / max(max - min, Double(1))\n                            \
    \                         ^\n"
  stdout: ''
  timestamp: 1660013799
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var min = Double(Int.max)\n    var max = Double(Int.min)\n    for number\
    \ in numbers {\n        min = min(min, number)\n        max = max(max, number)\n\
    \    }\n    var result = [Double](repeating: 0.0, count: numbers.count)\n    for\
    \ number in numbers {\n        result[numbers.index(of: number)] = number / max(max\
    \ - min, Double(1))\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmprs5h6yaa.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmprs5h6yaa.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n/tmp/tmprs5h6yaa.swift:15:24: error: value of optional\
    \ type 'Array<Double>.Index?' (aka 'Optional<Int>') must be unwrapped to a value\
    \ of type 'Array<Double>.Index' (aka 'Int')\n        result[numbers.index(of:\
    \ number)] = number / max(max - min, Double(1))\n                       ^\n/tmp/tmprs5h6yaa.swift:15:24:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n        result[numbers.index(of: number)] = number / max(max - min, Double(1))\n\
    \                       ^\n                                         ?? <#default\
    \ value#>\n/tmp/tmprs5h6yaa.swift:15:24: note: force-unwrap using '!' to abort\
    \ execution if the optional value contains 'nil'\n        result[numbers.index(of:\
    \ number)] = number / max(max - min, Double(1))\n                       ^\n  \
    \                                      !\n/tmp/tmprs5h6yaa.swift:15:54: error:\
    \ cannot call value of non-function type 'Double'\n        result[numbers.index(of:\
    \ number)] = number / max(max - min, Double(1))\n                            \
    \                         ^\n"
  stdout: ''
  timestamp: 1660013799
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var min = Double(Int.max)\n    var max = Double(Int.min)\n    for number\
    \ in numbers {\n        min = min(min, number)\n        max = max(max, number)\n\
    \    }\n    var result = [Double]()\n    for number in numbers {\n        result.append(number\
    \ - min)\n        result.append(number - max)\n    }\n    return result\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmphl4jeit1.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmphl4jeit1.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013799
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var min = Double(Int.max)\n    var max = Double(Int.min)\n    for number\
    \ in numbers {\n        min = min(min, number)\n        max = max(max, number)\n\
    \    }\n    var scaled: [Double] = []\n    for number in numbers {\n        scaled.append((number\
    \ - min) / (max - min))\n    }\n    return scaled\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpkqup1axs.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpkqup1axs.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013798
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var min: Double = Double(Int.max)\n    var max: Double = Double(Int.min)\n\
    \    for number in numbers {\n        min = min(min, number)\n        max = max(max,\
    \ number)\n    }\n    var result: [Double] = []\n    for number in numbers {\n\
    \        result.append(number - min)\n        result.append(number - max)\n  \
    \  }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpd6kk2qbz.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpd6kk2qbz.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013798
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var min = Double(Int.max)\n    var max = Double(Int.min)\n    for number\
    \ in numbers {\n        min = min(min, number)\n        max = max(max, number)\n\
    \    }\n    var scaled: [Double] = []\n    for number in numbers {\n        scaled.append((number\
    \ - min) / (max - min))\n    }\n    return scaled\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpkqup1axs.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpkqup1axs.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013798
- exit_code: -4
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var min = Double(numbers[0])\n    var max = Double(numbers[0])\n    for\
    \ number in numbers {\n        if number < min {\n            min = number\n \
    \       }\n        if number > max {\n            max = number\n        }\n  \
    \  }\n    var result = [Double]()\n    for number in numbers {\n        result.append(number\
    \ - min)\n        result.append(max - number)\n    }\n    return result\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: Exception
  stderr: 'tmpi_c75mwi/tmpi_c75mwi.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b2f5c8e8c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b2f5c5dfb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b2f5c5df988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b2f5c5de7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpi_c75mwi                        0x000055a22c4c8703 <unavailable> + 5891

    5    libc.so.6                          0x00002b2f5cad4460 __libc_start_main +
    245

    6    tmpi_c75mwi                        0x000055a22c4c8309 <unavailable> + 4873

    '
  stdout: ''
  timestamp: 1660013799
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var scaled: [Double] = []\n    var min: Double = Double(Int.max)\n  \
    \  var max: Double = Double(Int.min)\n    for number in numbers {\n        min\
    \ = min(min, number)\n        max = max(max, number)\n    }\n    for number in\
    \ numbers {\n        scaled.append(number - min)\n    }\n    for number in numbers\
    \ {\n        scaled.append(number / max - min)\n    }\n    return scaled\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpxgg6q30s.swift:11:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpxgg6q30s.swift:12:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013799
- exit_code: -4
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var min = Double(numbers[0])\n    var max = Double(numbers[0])\n    for\
    \ number in numbers {\n        if number < min {\n            min = number\n \
    \       }\n        if number > max {\n            max = number\n        }\n  \
    \  }\n    var result: [Double] = []\n    for number in numbers {\n        result.append(number\
    \ - min)\n        result.append(number - max)\n    }\n    return result\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: Exception
  stderr: 'tmp0bl49dvb/tmp0bl49dvb.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b309a743c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b309a43ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b309a43a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b309a4397b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp0bl49dvb                        0x000055ffd620d6a3 <unavailable> + 5795

    5    libc.so.6                          0x00002b309a92f460 __libc_start_main +
    245

    6    tmp0bl49dvb                        0x000055ffd620d2a9 <unavailable> + 4777

    '
  stdout: ''
  timestamp: 1660013799
- exit_code: -4
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var min: Double = Double(Int.max)\n    var max: Double = Double(Int.min)\n\
    \    for number in numbers {\n        if number < min {\n            min = number\n\
    \        }\n        if number > max {\n            max = number\n        }\n \
    \   }\n    var result: [Double] = []\n    for number in numbers {\n        result.append(number\
    \ - min)\n        result.append(number - max)\n    }\n    return result\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: Exception
  stderr: 'tmpbnqh2jsc/tmpbnqh2jsc.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ade10d1ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ade10a15b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ade10a15988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ade10a147b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpbnqh2jsc                        0x00005577a8ba1603 <unavailable> + 5635

    5    libc.so.6                          0x00002ade10f0a460 __libc_start_main +
    245

    6    tmpbnqh2jsc                        0x00005577a8ba1209 <unavailable> + 4617

    '
  stdout: ''
  timestamp: 1660013799
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var min: Double = Double(Int.max)\n    var max: Double = Double(Int.min)\n\
    \    for number in numbers {\n        min = min(min, number)\n        max = max(max,\
    \ number)\n    }\n    var result: [Double] = []\n    for number in numbers {\n\
    \        result.append(number - min)\n        result.append(number - max)\n  \
    \  }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpd6kk2qbz.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpd6kk2qbz.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013798
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    guard numbers.count > 1 else { return numbers }\n    let min = min(numbers)\n\
    \    let max = max(numbers)\n    var scaled: [Double] = []\n    for number in\
    \ numbers {\n        scaled.append((number - min) / (max - min))\n    }\n    return\
    \ scaled\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpel5ukjjo.swift:8:26: error: missing argument for parameter #2 in\
    \ call\n    let min = min(numbers)\n                         ^\n             \
    \            , <#[Double]#>\nSwift.min:1:24: note: 'min' declared here\n@inlinable\
    \ public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n             \
    \          ^\n/tmp/tmpel5ukjjo.swift:9:26: error: missing argument for parameter\
    \ #2 in call\n    let max = max(numbers)\n                         ^\n       \
    \                  , <#[Double]#>\nSwift.max:1:24: note: 'max' declared here\n\
    @inlinable public func max<T>(_ x: T, _ y: T) -> T where T : Comparable\n    \
    \                   ^\n"
  stdout: ''
  timestamp: 1660013799
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var min = Double(Int.max)\n    var max = Double(Int.min)\n    for number\
    \ in numbers {\n        min = min(min, number)\n        max = max(max, number)\n\
    \    }\n    var scaled: [Double] = []\n    for number in numbers {\n        scaled.append((number\
    \ - min) / (max - min))\n    }\n    return scaled\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpkqup1axs.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpkqup1axs.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013798
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    let min = min(numbers)\n    let max = max(numbers)\n    var result: [Double]\
    \ = []\n    for i in 0..<numbers.count {\n        result.append(numbers[i] / max\
    \ - min)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpraoki2yf.swift:7:26: error: missing argument for parameter #2 in\
    \ call\n    let min = min(numbers)\n                         ^\n             \
    \            , <#[Double]#>\nSwift.min:1:24: note: 'min' declared here\n@inlinable\
    \ public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n             \
    \          ^\n/tmp/tmpraoki2yf.swift:8:26: error: missing argument for parameter\
    \ #2 in call\n    let max = max(numbers)\n                         ^\n       \
    \                  , <#[Double]#>\nSwift.max:1:24: note: 'max' declared here\n\
    @inlinable public func max<T>(_ x: T, _ y: T) -> T where T : Comparable\n    \
    \                   ^\n"
  stdout: ''
  timestamp: 1660013799
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    let min = min(numbers)\n    let max = max(numbers)\n    let range = max\
    \ - min\n    let scaled: [Double] = numbers.map { $0 - min / range }\n    return\
    \ scaled\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpx30waid0.swift:7:26: error: missing argument for parameter #2 in\
    \ call\n    let min = min(numbers)\n                         ^\n             \
    \            , <#[Double]#>\nSwift.min:1:24: note: 'min' declared here\n@inlinable\
    \ public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n             \
    \          ^\n/tmp/tmpx30waid0.swift:8:26: error: missing argument for parameter\
    \ #2 in call\n    let max = max(numbers)\n                         ^\n       \
    \                  , <#[Double]#>\nSwift.max:1:24: note: 'max' declared here\n\
    @inlinable public func max<T>(_ x: T, _ y: T) -> T where T : Comparable\n    \
    \                   ^\n/tmp/tmpx30waid0.swift:10:51: error: cannot convert value\
    \ of type 'Duration' to expected argument type 'Double'\n    let scaled: [Double]\
    \ = numbers.map { $0 - min / range }\n                                       \
    \           ^\n"
  stdout: ''
  timestamp: 1660013799
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var min: Double = Double(Int.max)\n    var max: Double = Double(Int.min)\n\
    \    for number in numbers {\n        min = min(min, number)\n        max = max(max,\
    \ number)\n    }\n    var result: [Double] = []\n    for number in numbers {\n\
    \        result.append(number - min)\n        result.append(number - max)\n  \
    \  }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpd6kk2qbz.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpd6kk2qbz.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013798
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var rescaled: [Double] = []\n    var min: Double = Double.greatestFiniteMagnitude\n\
    \    var max: Double = Double.leastFiniteMagnitude\n    for number in numbers\
    \ {\n        rescaled.append(number / max - min)\n        min = min(min, number)\n\
    \        max = max(max, number)\n    }\n    return rescaled\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\n\
    assert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmp9thkepjc.swift:9:30: error: type 'Double' has no member 'leastFiniteMagnitude'\n\
    \    var max: Double = Double.leastFiniteMagnitude\n                      ~~~~~~\
    \ ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmp9thkepjc.swift:12:15: error: cannot call value\
    \ of non-function type 'Double'\n        min = min(min, number)\n            \
    \  ^\n/tmp/tmp9thkepjc.swift:13:15: error: cannot call value of non-function type\
    \ 'Double'\n        max = max(max, number)\n              ^\n"
  stdout: ''
  timestamp: 1660013799
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var scaled: [Double] = []\n    var min: Double = Double.greatestFiniteMagnitude\n\
    \    var max: Double = Double.lowestFiniteMagnitude\n    for number in numbers\
    \ {\n        min = min(min, number)\n        max = max(max, number)\n    }\n \
    \   for number in numbers {\n        scaled.append(number - min)\n        scaled.append(number\
    \ - max)\n    }\n    return scaled\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpope2wffe.swift:9:30: error: type 'Double' has no member 'lowestFiniteMagnitude'\n\
    \    var max: Double = Double.lowestFiniteMagnitude\n                      ~~~~~~\
    \ ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpope2wffe.swift:11:15: error: cannot call value\
    \ of non-function type 'Double'\n        min = min(min, number)\n            \
    \  ^\n/tmp/tmpope2wffe.swift:12:15: error: cannot call value of non-function type\
    \ 'Double'\n        max = max(max, number)\n              ^\n"
  stdout: ''
  timestamp: 1660013799
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var min = Double(Int.max)\n    var max = Double(Int.min)\n    for number\
    \ in numbers {\n        min = min(min, number)\n        max = max(max, number)\n\
    \    }\n    var scaled: [Double] = []\n    for number in numbers {\n        scaled.append((number\
    \ - min) / (max - min))\n    }\n    return scaled\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpkqup1axs.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpkqup1axs.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013798
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var min: Double = Double.greatestFiniteMagnitude\n    var max: Double\
    \ = Double.lowestFiniteMagnitude\n    for number in numbers {\n        min = min(min,\
    \ number)\n        max = max(max, number)\n    }\n    var result: [Double] = []\n\
    \    for number in numbers {\n        result.append(number - min)\n        result.append(number\
    \ / max - min)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpur8kmdx3.swift:8:30: error: type 'Double' has no member 'lowestFiniteMagnitude'\n\
    \    var max: Double = Double.lowestFiniteMagnitude\n                      ~~~~~~\
    \ ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpur8kmdx3.swift:10:15: error: cannot call value\
    \ of non-function type 'Double'\n        min = min(min, number)\n            \
    \  ^\n/tmp/tmpur8kmdx3.swift:11:15: error: cannot call value of non-function type\
    \ 'Double'\n        max = max(max, number)\n              ^\n"
  stdout: ''
  timestamp: 1660013799
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var min = Double.greatestFiniteMagnitude\n    var max = Double.leastFiniteMagnitude\n\
    \    for number in numbers {\n        min = min(min, number)\n        max = max(max,\
    \ number)\n    }\n    var scaled: [Double] = []\n    for number in numbers {\n\
    \        scaled.append((number - min) / (max - min))\n    }\n    return scaled\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmp0zhik5d8.swift:8:22: error: type 'Double' has no member 'leastFiniteMagnitude'\n\
    \    var max = Double.leastFiniteMagnitude\n              ~~~~~~ ^~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmp0zhik5d8.swift:10:15: error: cannot call value of non-function type 'Double'\n\
    \        min = min(min, number)\n              ^\n"
  stdout: ''
  timestamp: 1660013799
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var min = Double(Int.max)\n    var max = Double(Int.min)\n    for number\
    \ in numbers {\n        min = min(min, number)\n        max = max(max, number)\n\
    \    }\n    var result: [Double] = []\n    for number in numbers {\n        result.append(number\
    \ - min)\n        result.append(number - max)\n    }\n    return result\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpd9hsoeox.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpd9hsoeox.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013798
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var min: Double = Double(Int.max)\n    var max: Double = Double(Int.min)\n\
    \    for number in numbers {\n        min = min(min, number)\n        max = max(max,\
    \ number)\n    }\n    var scaled: [Double] = []\n    for number in numbers {\n\
    \        scaled.append(number - min)\n    }\n    for number in scaled {\n    \
    \    number /= max - min\n    }\n    return scaled\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpxbbyb8vz.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpxbbyb8vz.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n/tmp/tmpxbbyb8vz.swift:18:16: error: left side of\
    \ mutating operator isn't mutable: 'number' is a 'let' constant\n        number\
    \ /= max - min\n        ~~~~~~ ^\n"
  stdout: ''
  timestamp: 1660013799
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var min: Double = Double(Int.max)\n    var max: Double = Double(Int.min)\n\
    \    for number in numbers {\n        min = min(min, number)\n        max = max(max,\
    \ number)\n    }\n    var result: [Double] = []\n    for number in numbers {\n\
    \        result.append(number - min)\n        result.append(number - max)\n  \
    \  }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpd6kk2qbz.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpd6kk2qbz.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013798
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var min: Double = Double.greatestFiniteMagnitude\n    var max: Double\
    \ = Double.lowestFiniteMagnitude\n    for number in numbers {\n        min = min(min,\
    \ number)\n        max = max(max, number)\n    }\n    var result: [Double] = []\n\
    \    for number in numbers {\n        result.append(number - min)\n        result.append(number\
    \ / max - min)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpur8kmdx3.swift:8:30: error: type 'Double' has no member 'lowestFiniteMagnitude'\n\
    \    var max: Double = Double.lowestFiniteMagnitude\n                      ~~~~~~\
    \ ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpur8kmdx3.swift:10:15: error: cannot call value\
    \ of non-function type 'Double'\n        min = min(min, number)\n            \
    \  ^\n/tmp/tmpur8kmdx3.swift:11:15: error: cannot call value of non-function type\
    \ 'Double'\n        max = max(max, number)\n              ^\n"
  stdout: ''
  timestamp: 1660013799
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var min = Double(numbers[0])\n    var max = Double(numbers[0])\n    for\
    \ number in numbers {\n        if number < min {\n            min = number\n \
    \       }\n        if number > max {\n            max = number\n        }\n  \
    \  }\n    var scale = (max - min) / (Double(numbers.count) - 1)\n    var result\
    \ = [Double](repeating: 0.0, count: numbers.count)\n    for number in numbers\
    \ {\n        result[numbers.index(of: number)] = number - min + scale\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmp39f4ieos.swift:20:24: error: value of optional type 'Array<Double>.Index?'\
    \ (aka 'Optional<Int>') must be unwrapped to a value of type 'Array<Double>.Index'\
    \ (aka 'Int')\n        result[numbers.index(of: number)] = number - min + scale\n\
    \                       ^\n/tmp/tmp39f4ieos.swift:20:24: note: coalesce using\
    \ '??' to provide a default when the optional value contains 'nil'\n        result[numbers.index(of:\
    \ number)] = number - min + scale\n                       ^\n                \
    \                         ?? <#default value#>\n/tmp/tmp39f4ieos.swift:20:24:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n        result[numbers.index(of: number)] = number - min + scale\n  \
    \                     ^\n                                        !\n"
  stdout: ''
  timestamp: 1660013799
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    guard numbers.count > 1 else { return numbers }\n    let min = numbers.min()\n\
    \    let max = numbers.max()\n    var scaled: [Double] = []\n    for i in 0..<numbers.count\
    \ {\n        scaled.append(numbers[i] - min)\n    }\n    for i in 0..<numbers.count\
    \ {\n        scaled[i] = scaled[i] / (max - min)\n    }\n    return scaled\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmphw1w92x6.swift:12:36: error: value of optional type 'Double?' must\
    \ be unwrapped to a value of type 'Double'\n        scaled.append(numbers[i] -\
    \ min)\n                                   ^\n/tmp/tmphw1w92x6.swift:12:36: note:\
    \ coalesce using '??' to provide a default when the optional value contains 'nil'\n\
    \        scaled.append(numbers[i] - min)\n                                   ^\n\
    \                                   (   ?? <#default value#>)\n/tmp/tmphw1w92x6.swift:12:36:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n        scaled.append(numbers[i] - min)\n                           \
    \        ^\n                                      !\n/tmp/tmphw1w92x6.swift:15:38:\
    \ error: binary operator '-' cannot be applied to two 'Double?' operands\n   \
    \     scaled[i] = scaled[i] / (max - min)\n                                 ~~~\
    \ ^ ~~~\n/tmp/tmphw1w92x6.swift:15:38: note: overloads for '-' exist with these\
    \ partially matching parameter lists: (Double, Double)\n        scaled[i] = scaled[i]\
    \ / (max - min)\n                                     ^\n"
  stdout: ''
  timestamp: 1660013799
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var min: Double = Double(Int.max)\n    var max: Double = Double(Int.min)\n\
    \    for number in numbers {\n        min = min(min, number)\n        max = max(max,\
    \ number)\n    }\n    var result: [Double] = []\n    for number in numbers {\n\
    \        result.append(number - min)\n        result.append(number - max)\n  \
    \  }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpd6kk2qbz.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpd6kk2qbz.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013798
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var min: Double = Double.greatestFiniteMagnitude\n    var max: Double\
    \ = Double.leastFiniteMagnitude\n    for number in numbers {\n        min = min(min,\
    \ number)\n        max = max(max, number)\n    }\n    var scaled: [Double] = []\n\
    \    for number in numbers {\n        scaled.append(number - min)\n        scaled.append(number\
    \ - max)\n    }\n    return scaled\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpzgau0uf0.swift:8:30: error: type 'Double' has no member 'leastFiniteMagnitude'\n\
    \    var max: Double = Double.leastFiniteMagnitude\n                      ~~~~~~\
    \ ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmpzgau0uf0.swift:10:15: error: cannot call value\
    \ of non-function type 'Double'\n        min = min(min, number)\n            \
    \  ^\n/tmp/tmpzgau0uf0.swift:11:15: error: cannot call value of non-function type\
    \ 'Double'\n        max = max(max, number)\n              ^\n"
  stdout: ''
  timestamp: 1660013798
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var scaled: [Double] = []\n    for number in numbers {\n        scaled.append((number\
    \ - min(numbers)) / (max(numbers) - min(numbers)))\n    }\n    return scaled\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpy53wb_li.swift:9:9: error: the compiler is unable to type-check\
    \ this expression in reasonable time; try breaking up the expression into distinct\
    \ sub-expressions\n        scaled.append((number - min(numbers)) / (max(numbers)\
    \ - min(numbers)))\n        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013834
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var scaled: [Double] = []\n    var min: Double = Double.greatestFiniteMagnitude\n\
    \    var max: Double = Double.lowestFiniteMagnitude\n    for number in numbers\
    \ {\n        let scaledNumber = number / max\n        scaled.append(scaledNumber)\n\
    \        if scaledNumber < min {\n            min = scaledNumber\n        }\n\
    \        if scaledNumber > max {\n            max = scaledNumber\n        }\n\
    \    }\n    return scaled\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmp7ee1jygi.swift:9:30: error: type 'Double' has no member 'lowestFiniteMagnitude'\n\
    \    var max: Double = Double.lowestFiniteMagnitude\n                      ~~~~~~\
    \ ^~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013799
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var min: Double = Double(Int.max)\n    var max: Double = Double(Int.min)\n\
    \    for number in numbers {\n        min = min(min, number)\n        max = max(max,\
    \ number)\n    }\n    var result: [Double] = []\n    for number in numbers {\n\
    \        result.append(number - min)\n        result.append(number - max)\n  \
    \  }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpd6kk2qbz.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpd6kk2qbz.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013798
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var min = Double(Int.max)\n    var max = Double(Int.min)\n    for number\
    \ in numbers {\n        min = min(min, number)\n        max = max(max, number)\n\
    \    }\n    var scaled: [Double] = []\n    for number in numbers {\n        scaled.append((number\
    \ - min) / (max - min))\n    }\n    return scaled\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpkqup1axs.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpkqup1axs.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013798
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var min: Double = Double.greatestFiniteMagnitude\n    var max: Double\
    \ = Double.leastFiniteMagnitude\n    for number in numbers {\n        min = min(min,\
    \ number)\n        max = max(max, number)\n    }\n    var result: [Double] = []\n\
    \    for number in numbers {\n        result.append(number - min)\n        result.append(number\
    \ / max - min)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpqflvi45k.swift:8:30: error: type 'Double' has no member 'leastFiniteMagnitude'\n\
    \    var max: Double = Double.leastFiniteMagnitude\n                      ~~~~~~\
    \ ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmpqflvi45k.swift:10:15: error: cannot call value\
    \ of non-function type 'Double'\n        min = min(min, number)\n            \
    \  ^\n/tmp/tmpqflvi45k.swift:11:15: error: cannot call value of non-function type\
    \ 'Double'\n        max = max(max, number)\n              ^\n"
  stdout: ''
  timestamp: 1660013799
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    guard numbers.count > 1 else { return numbers }\n    var min = Double(numbers[0])\n\
    \    var max = Double(numbers[0])\n    for number in numbers {\n        if number\
    \ < min {\n            min = number\n        }\n        if number > max {\n  \
    \          max = number\n        }\n    }\n    var result = [Double](repeating:\
    \ 0.0, count: numbers.count)\n    for number in numbers {\n        result[numbers.index(of:\
    \ number)] = ((number - min) / (max - min)) * 1.0\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpudvo08y7.swift:20:24: error: value of optional type 'Array<Double>.Index?'\
    \ (aka 'Optional<Int>') must be unwrapped to a value of type 'Array<Double>.Index'\
    \ (aka 'Int')\n        result[numbers.index(of: number)] = ((number - min) / (max\
    \ - min)) * 1.0\n                       ^\n/tmp/tmpudvo08y7.swift:20:24: note:\
    \ coalesce using '??' to provide a default when the optional value contains 'nil'\n\
    \        result[numbers.index(of: number)] = ((number - min) / (max - min)) *\
    \ 1.0\n                       ^\n                                         ?? <#default\
    \ value#>\n/tmp/tmpudvo08y7.swift:20:24: note: force-unwrap using '!' to abort\
    \ execution if the optional value contains 'nil'\n        result[numbers.index(of:\
    \ number)] = ((number - min) / (max - min)) * 1.0\n                       ^\n\
    \                                        !\n"
  stdout: ''
  timestamp: 1660013799
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var min = Double(Int.max)\n    var max = Double(Int.min)\n    for number\
    \ in numbers {\n        min = min(min, number)\n        max = max(max, number)\n\
    \    }\n    var result = [Double]()\n    for number in numbers {\n        result.append(number\
    \ - min)\n        result.append(number - max)\n    }\n    return result\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmphl4jeit1.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmphl4jeit1.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013799
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var scaled: [Double] = []\n    var min: Double = Double.greatestFiniteMagnitude\n\
    \    var max: Double = Double.lowestFiniteMagnitude\n    for number in numbers\
    \ {\n        min = min(min, number)\n        max = max(max, number)\n    }\n \
    \   for number in numbers {\n        scaled.append(number - min)\n        scaled.append(number\
    \ - max)\n    }\n    return scaled\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpope2wffe.swift:9:30: error: type 'Double' has no member 'lowestFiniteMagnitude'\n\
    \    var max: Double = Double.lowestFiniteMagnitude\n                      ~~~~~~\
    \ ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpope2wffe.swift:11:15: error: cannot call value\
    \ of non-function type 'Double'\n        min = min(min, number)\n            \
    \  ^\n/tmp/tmpope2wffe.swift:12:15: error: cannot call value of non-function type\
    \ 'Double'\n        max = max(max, number)\n              ^\n"
  stdout: ''
  timestamp: 1660013799
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    guard numbers.count > 1 else {\n        return numbers\n    }\n\n   \
    \ var min: Double = Double(numbers[0])\n    var max: Double = Double(numbers[0])\n\
    \n    for number in numbers {\n        if number < min {\n            min = number\n\
    \        }\n\n        if number > max {\n            max = number\n        }\n\
    \    }\n\n    var scaled: [Double] = []\n\n    for number in numbers {\n     \
    \   scaled.append(number - min)\n    }\n\n    for number in scaled {\n       \
    \ number /= max - min\n    }\n\n    return scaled\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmp5t3tvihc.swift:31:16: error: left side of mutating operator isn't\
    \ mutable: 'number' is a 'let' constant\n        number /= max - min\n       \
    \ ~~~~~~ ^\n"
  stdout: ''
  timestamp: 1660013799
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var min: Double = Double(Int.max)\n    var max: Double = Double(Int.min)\n\
    \    for number in numbers {\n        min = min(min, number)\n        max = max(max,\
    \ number)\n    }\n    var result: [Double] = []\n    for number in numbers {\n\
    \        result.append(number - min)\n        result.append(number - max)\n  \
    \  }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpd6kk2qbz.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpd6kk2qbz.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013798
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    guard numbers.count > 1 else {\n        return numbers\n    }\n\n   \
    \ let min = min(numbers)\n    let max = max(numbers)\n    var scaled: [Double]\
    \ = []\n    for number in numbers {\n        scaled.append(number - min)\n   \
    \ }\n\n    var scaledSum = 0.0\n    for number in scaled {\n        scaledSum\
    \ += number\n    }\n\n    for number in scaled {\n        number /= scaledSum\n\
    \    }\n\n    return scaled\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmp7p8ck8bh.swift:11:26: error: missing argument for parameter #2\
    \ in call\n    let min = min(numbers)\n                         ^\n          \
    \               , <#[Double]#>\nSwift.min:1:24: note: 'min' declared here\n@inlinable\
    \ public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n             \
    \          ^\n/tmp/tmp7p8ck8bh.swift:12:26: error: missing argument for parameter\
    \ #2 in call\n    let max = max(numbers)\n                         ^\n       \
    \                  , <#[Double]#>\nSwift.max:1:24: note: 'max' declared here\n\
    @inlinable public func max<T>(_ x: T, _ y: T) -> T where T : Comparable\n    \
    \                   ^\n/tmp/tmp7p8ck8bh.swift:24:16: error: left side of mutating\
    \ operator isn't mutable: 'number' is a 'let' constant\n        number /= scaledSum\n\
    \        ~~~~~~ ^\n"
  stdout: ''
  timestamp: 1660013799
- exit_code: -4
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var rescaled: [Double] = []\n    for number in numbers {\n        rescaled.append(number\
    \ / min(number, 1.0))\n    }\n    return rescaled\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: Exception
  stderr: 'tmp_rm2k2ga/tmp_rm2k2ga.swift:27: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002afbb3671c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002afbb3368b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002afbb3368988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002afbb33677b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp_rm2k2ga                        0x000055e0cfdc4693 <unavailable> + 5779

    5    libc.so.6                          0x00002afbb385d460 __libc_start_main +
    245

    6    tmp_rm2k2ga                        0x000055e0cfdc4299 <unavailable> + 4761

    '
  stdout: ''
  timestamp: 1660013799
- exit_code: -4
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var rescaled: [Double] = []\n    for number in numbers {\n        rescaled.append(number\
    \ / min(1.0, max(0.0, number)))\n    }\n    return rescaled\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\n\
    assert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: Exception
  stderr: 'tmpvunk_ajb/tmpvunk_ajb.swift:27: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b6e263e0c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6e260d7b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b6e260d7988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b6e260d67b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpvunk_ajb                        0x0000556e0544e6f3 <unavailable> + 5875

    5    libc.so.6                          0x00002b6e265cc460 __libc_start_main +
    245

    6    tmpvunk_ajb                        0x0000556e0544e2f9 <unavailable> + 4857

    '
  stdout: ''
  timestamp: 1660013799
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var min = Double(numbers[0])\n    var max = Double(numbers[0])\n    for\
    \ number in numbers {\n        if number < min {\n            min = number\n \
    \       }\n        if number > max {\n            max = number\n        }\n  \
    \  }\n    var result = [Double](repeating: 0.0, count: numbers.count)\n    for\
    \ number in numbers {\n        result[numbers.index(of: number)] = number - min\n\
    \    }\n    return result.map { number / max }\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmp7od971n1.swift:19:24: error: value of optional type 'Array<Double>.Index?'\
    \ (aka 'Optional<Int>') must be unwrapped to a value of type 'Array<Double>.Index'\
    \ (aka 'Int')\n        result[numbers.index(of: number)] = number - min\n    \
    \                   ^\n/tmp/tmp7od971n1.swift:19:24: note: coalesce using '??'\
    \ to provide a default when the optional value contains 'nil'\n        result[numbers.index(of:\
    \ number)] = number - min\n                       ^\n                        \
    \                 ?? <#default value#>\n/tmp/tmp7od971n1.swift:19:24: note: force-unwrap\
    \ using '!' to abort execution if the optional value contains 'nil'\n        result[numbers.index(of:\
    \ number)] = number - min\n                       ^\n                        \
    \                !\n/tmp/tmp7od971n1.swift:21:25: error: cannot find 'number'\
    \ in scope\n    return result.map { number / max }\n                        ^~~~~~\n"
  stdout: ''
  timestamp: 1660013799
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var min = Double(Int.max)\n    var max = Double(Int.min)\n    for number\
    \ in numbers {\n        min = min(min, number)\n        max = max(max, number)\n\
    \    }\n    var result = [Double](repeating: 0.0, count: numbers.count)\n    for\
    \ number in numbers {\n        result[numbers.index(of: number)] = ((number -\
    \ min) / (max - min))\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpq_58ggur.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpq_58ggur.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n/tmp/tmpq_58ggur.swift:15:24: error: value of optional\
    \ type 'Array<Double>.Index?' (aka 'Optional<Int>') must be unwrapped to a value\
    \ of type 'Array<Double>.Index' (aka 'Int')\n        result[numbers.index(of:\
    \ number)] = ((number - min) / (max - min))\n                       ^\n/tmp/tmpq_58ggur.swift:15:24:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n        result[numbers.index(of: number)] = ((number - min) / (max -\
    \ min))\n                       ^\n                                         ??\
    \ <#default value#>\n/tmp/tmpq_58ggur.swift:15:24: note: force-unwrap using '!'\
    \ to abort execution if the optional value contains 'nil'\n        result[numbers.index(of:\
    \ number)] = ((number - min) / (max - min))\n                       ^\n      \
    \                                  !\n"
  stdout: ''
  timestamp: 1660013799
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var min: Double = Double(Int.max)\n    var max: Double = Double(Int.min)\n\
    \    for number in numbers {\n        min = min(min, number)\n        max = max(max,\
    \ number)\n    }\n    var scaled: [Double] = []\n    for number in numbers {\n\
    \        scaled.append(number - min)\n        scaled.append(number - max)\n  \
    \  }\n    return scaled\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmplm3j67n7.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmplm3j67n7.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013799
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var scaled: [Double] = []\n    var min: Double = Double.greatestFiniteMagnitude\n\
    \    var max: Double = Double.lowestFiniteMagnitude\n    for number in numbers\
    \ {\n        min = min(min, number)\n        max = max(max, number)\n    }\n \
    \   for number in numbers {\n        scaled.append(number - min)\n    }\n    for\
    \ number in numbers {\n        scaled.append(number / max - min)\n    }\n    return\
    \ scaled\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpjgm_umgl.swift:9:30: error: type 'Double' has no member 'lowestFiniteMagnitude'\n\
    \    var max: Double = Double.lowestFiniteMagnitude\n                      ~~~~~~\
    \ ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpjgm_umgl.swift:11:15: error: cannot call value\
    \ of non-function type 'Double'\n        min = min(min, number)\n            \
    \  ^\n/tmp/tmpjgm_umgl.swift:12:15: error: cannot call value of non-function type\
    \ 'Double'\n        max = max(max, number)\n              ^\n"
  stdout: ''
  timestamp: 1660013798
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var scaled: [Double] = []\n    for number in numbers {\n        scaled.append((number\
    \ - min(numbers)) / (max(numbers) - min(numbers)))\n    }\n    return scaled\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpy53wb_li.swift:9:9: error: the compiler is unable to type-check\
    \ this expression in reasonable time; try breaking up the expression into distinct\
    \ sub-expressions\n        scaled.append((number - min(numbers)) / (max(numbers)\
    \ - min(numbers)))\n        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013834
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var min: Double = Double(Int.max)\n    var max: Double = Double(Int.min)\n\
    \    for number in numbers {\n        min = min(min, number)\n        max = max(max,\
    \ number)\n    }\n    var result: [Double] = []\n    for number in numbers {\n\
    \        result.append(number - min)\n        result.append(number - max)\n  \
    \  }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpd6kk2qbz.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpd6kk2qbz.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013798
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var min: Double = Double.greatestFiniteMagnitude\n    var max: Double\
    \ = Double.leastFiniteMagnitude\n    for number in numbers {\n        min = min(min,\
    \ number)\n        max = max(max, number)\n    }\n    var scaled: [Double] = []\n\
    \    for number in numbers {\n        scaled.append((number - min) / (max - min))\n\
    \    }\n    return scaled\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmps_8ap6lw.swift:8:30: error: type 'Double' has no member 'leastFiniteMagnitude'\n\
    \    var max: Double = Double.leastFiniteMagnitude\n                      ~~~~~~\
    \ ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmps_8ap6lw.swift:10:15: error: cannot call value\
    \ of non-function type 'Double'\n        min = min(min, number)\n            \
    \  ^\n/tmp/tmps_8ap6lw.swift:11:15: error: cannot call value of non-function type\
    \ 'Double'\n        max = max(max, number)\n              ^\n"
  stdout: ''
  timestamp: 1660013798
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var min: Double = Double.greatestFiniteMagnitude\n    var max: Double\
    \ = Double.leastFiniteMagnitude\n    for number in numbers {\n        min = min(min,\
    \ number)\n        max = max(max, number)\n    }\n    var scaled: [Double] = []\n\
    \    for number in numbers {\n        scaled.append((number - min) / (max - min))\n\
    \    }\n    return scaled\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmps_8ap6lw.swift:8:30: error: type 'Double' has no member 'leastFiniteMagnitude'\n\
    \    var max: Double = Double.leastFiniteMagnitude\n                      ~~~~~~\
    \ ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmps_8ap6lw.swift:10:15: error: cannot call value\
    \ of non-function type 'Double'\n        min = min(min, number)\n            \
    \  ^\n/tmp/tmps_8ap6lw.swift:11:15: error: cannot call value of non-function type\
    \ 'Double'\n        max = max(max, number)\n              ^\n"
  stdout: ''
  timestamp: 1660013798
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var rescaled: [Double] = []\n    var smallest: Double = Double.greatestFiniteMagnitude\n\
    \    var largest: Double = Double.leastFiniteMagnitude\n    for number in numbers\
    \ {\n        rescaled.append(number / largest)\n        largest = number\n   \
    \ }\n    for number in numbers {\n        rescaled.append(number / smallest)\n\
    \        smallest = number\n    }\n    return rescaled\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmp2cz_klpp.swift:9:34: error: type 'Double' has no member 'leastFiniteMagnitude'\n\
    \    var largest: Double = Double.leastFiniteMagnitude\n                     \
    \     ~~~~~~ ^~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013799
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var min: Double = Double(Int.max)\n    var max: Double = Double(Int.min)\n\
    \    for number in numbers {\n        min = min(min, number)\n        max = max(max,\
    \ number)\n    }\n    var result: [Double] = []\n    for number in numbers {\n\
    \        result.append(number - min)\n        result.append(number - max)\n  \
    \  }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpd6kk2qbz.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpd6kk2qbz.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013798
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var scaled: [Double] = []\n    var min: Double = Double.greatestFiniteMagnitude\n\
    \    var max: Double = Double.lowestFiniteMagnitude\n    for number in numbers\
    \ {\n        min = min(min, number)\n        max = max(max, number)\n    }\n \
    \   for number in numbers {\n        scaled.append(number - min)\n    }\n    for\
    \ number in numbers {\n        scaled.append(number / max - min)\n    }\n    return\
    \ scaled\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpjgm_umgl.swift:9:30: error: type 'Double' has no member 'lowestFiniteMagnitude'\n\
    \    var max: Double = Double.lowestFiniteMagnitude\n                      ~~~~~~\
    \ ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpjgm_umgl.swift:11:15: error: cannot call value\
    \ of non-function type 'Double'\n        min = min(min, number)\n            \
    \  ^\n/tmp/tmpjgm_umgl.swift:12:15: error: cannot call value of non-function type\
    \ 'Double'\n        max = max(max, number)\n              ^\n"
  stdout: ''
  timestamp: 1660013798
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var min: Double = Double.greatestFiniteMagnitude\n    var max: Double\
    \ = Double.leastFiniteMagnitude\n    for number in numbers {\n        min = min(min,\
    \ number)\n        max = max(max, number)\n    }\n    var result: [Double] = []\n\
    \    for number in numbers {\n        result.append(number / max - min)\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmp3xf26xa_.swift:8:30: error: type 'Double' has no member 'leastFiniteMagnitude'\n\
    \    var max: Double = Double.leastFiniteMagnitude\n                      ~~~~~~\
    \ ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmp3xf26xa_.swift:10:15: error: cannot call value\
    \ of non-function type 'Double'\n        min = min(min, number)\n            \
    \  ^\n/tmp/tmp3xf26xa_.swift:11:15: error: cannot call value of non-function type\
    \ 'Double'\n        max = max(max, number)\n              ^\n"
  stdout: ''
  timestamp: 1660013799
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var min = Double(Int.max)\n    var max = Double(Int.min)\n    for number\
    \ in numbers {\n        min = min(min, number)\n        max = max(max, number)\n\
    \    }\n    var result = [Double](repeating: 0.0, count: numbers.count)\n    for\
    \ number in numbers {\n        result[numbers.index(of: number)] = number / max(max\
    \ - min, Double(1.0))\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpzx805umg.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpzx805umg.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n/tmp/tmpzx805umg.swift:15:24: error: value of optional\
    \ type 'Array<Double>.Index?' (aka 'Optional<Int>') must be unwrapped to a value\
    \ of type 'Array<Double>.Index' (aka 'Int')\n        result[numbers.index(of:\
    \ number)] = number / max(max - min, Double(1.0))\n                       ^\n\
    /tmp/tmpzx805umg.swift:15:24: note: coalesce using '??' to provide a default when\
    \ the optional value contains 'nil'\n        result[numbers.index(of: number)]\
    \ = number / max(max - min, Double(1.0))\n                       ^\n         \
    \                                ?? <#default value#>\n/tmp/tmpzx805umg.swift:15:24:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n        result[numbers.index(of: number)] = number / max(max - min, Double(1.0))\n\
    \                       ^\n                                        !\n/tmp/tmpzx805umg.swift:15:54:\
    \ error: cannot call value of non-function type 'Double'\n        result[numbers.index(of:\
    \ number)] = number / max(max - min, Double(1.0))\n                          \
    \                           ^\n"
  stdout: ''
  timestamp: 1660013799
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var min: Double = Double(Int.max)\n    var max: Double = Double(Int.min)\n\
    \    for number in numbers {\n        min = min(min, number)\n        max = max(max,\
    \ number)\n    }\n    var result: [Double] = []\n    for number in numbers {\n\
    \        result.append(number - min)\n        result.append(number - max)\n  \
    \  }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpd6kk2qbz.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpd6kk2qbz.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013798
- exit_code: -4
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var min = Double(numbers[0])\n    var max = Double(numbers[0])\n    for\
    \ number in numbers {\n        if number < min {\n            min = number\n \
    \       }\n        if number > max {\n            max = number\n        }\n  \
    \  }\n    var result: [Double] = []\n    for number in numbers {\n        result.append(number\
    \ - min)\n        result.append(number / max - min)\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: Exception
  stderr: 'tmpra6wtywr/tmpra6wtywr.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b7a30351c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b7a30048b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b7a30048988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b7a300477b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpra6wtywr                        0x000055d5bef886a3 <unavailable> + 5795

    5    libc.so.6                          0x00002b7a3053d460 __libc_start_main +
    245

    6    tmpra6wtywr                        0x000055d5bef882a9 <unavailable> + 4777

    '
  stdout: ''
  timestamp: 1660013799
- exit_code: -4
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var rescaled: [Double] = []\n    for number in numbers {\n        rescaled.append(min(max(number,\
    \ 0.0), 1.0))\n    }\n    return rescaled\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: Exception
  stderr: 'tmpf2da8feh/tmpf2da8feh.swift:27: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac3edc0ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac3ed905b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac3ed905988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac3ed9047b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpf2da8feh                        0x000056511904c6f3 <unavailable> + 5875

    5    libc.so.6                          0x00002ac3eddfa460 __libc_start_main +
    245

    6    tmpf2da8feh                        0x000056511904c2f9 <unavailable> + 4857

    '
  stdout: ''
  timestamp: 1660013799
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var min: Double = Double(Int.max)\n    var max: Double = Double(Int.min)\n\
    \    for number in numbers {\n        min = min(min, number)\n        max = max(max,\
    \ number)\n    }\n    var result: [Double] = []\n    for number in numbers {\n\
    \        result.append(number - min)\n        result.append(number - max)\n  \
    \  }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpd6kk2qbz.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpd6kk2qbz.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013798
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var min = Double(Int.max)\n    var max = Double(Int.min)\n    for number\
    \ in numbers {\n        min = min(min, number)\n        max = max(max, number)\n\
    \    }\n    var result: [Double] = []\n    for number in numbers {\n        result.append(number\
    \ - min)\n        result.append(number - max)\n    }\n    return result\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpd9hsoeox.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpd9hsoeox.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013798
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    guard numbers.count > 1 else { return numbers }\n    var min = Double(numbers[0])\n\
    \    var max = Double(numbers[0])\n    for number in numbers {\n        if number\
    \ < min {\n            min = number\n        }\n        if number > max {\n  \
    \          max = number\n        }\n    }\n    var result = [Double](repeating:\
    \ 0.0, count: numbers.count)\n    for number in numbers {\n        result[numbers.index(of:\
    \ number)] = ((number - min) / (max - min)) * 1.0\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpudvo08y7.swift:20:24: error: value of optional type 'Array<Double>.Index?'\
    \ (aka 'Optional<Int>') must be unwrapped to a value of type 'Array<Double>.Index'\
    \ (aka 'Int')\n        result[numbers.index(of: number)] = ((number - min) / (max\
    \ - min)) * 1.0\n                       ^\n/tmp/tmpudvo08y7.swift:20:24: note:\
    \ coalesce using '??' to provide a default when the optional value contains 'nil'\n\
    \        result[numbers.index(of: number)] = ((number - min) / (max - min)) *\
    \ 1.0\n                       ^\n                                         ?? <#default\
    \ value#>\n/tmp/tmpudvo08y7.swift:20:24: note: force-unwrap using '!' to abort\
    \ execution if the optional value contains 'nil'\n        result[numbers.index(of:\
    \ number)] = ((number - min) / (max - min)) * 1.0\n                       ^\n\
    \                                        !\n"
  stdout: ''
  timestamp: 1660013799
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var min: Double = Double(Int.max)\n    var max: Double = Double(Int.min)\n\
    \    for number in numbers {\n        min = min(min, number)\n        max = max(max,\
    \ number)\n    }\n    var result: [Double] = []\n    for number in numbers {\n\
    \        result.append(number - min)\n        result.append(number - max)\n  \
    \  }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpd6kk2qbz.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpd6kk2qbz.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013798
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var min: Double = Double(Int.max)\n    var max: Double = Double(Int.min)\n\
    \    for number in numbers {\n        min = min(min, number)\n        max = max(max,\
    \ number)\n    }\n    var scaled: [Double] = []\n    for number in numbers {\n\
    \        scaled.append(number - min)\n    }\n    for number in scaled {\n    \
    \    number = number / max - min\n    }\n    return scaled\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\n\
    assert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmppoc4gjj4.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmppoc4gjj4.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n/tmp/tmppoc4gjj4.swift:18:9: error: cannot assign\
    \ to value: 'number' is a 'let' constant\n        number = number / max - min\n\
    \        ^~~~~~\n"
  stdout: ''
  timestamp: 1660013799
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var min: Double = Double(Int.max)\n    var max: Double = Double(Int.min)\n\
    \    for number in numbers {\n        min = min(min, number)\n        max = max(max,\
    \ number)\n    }\n    var result: [Double] = []\n    for number in numbers {\n\
    \        result.append(number - min)\n        result.append(number - max)\n  \
    \  }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpd6kk2qbz.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpd6kk2qbz.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013798
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var scaled: [Double] = []\n    var min: Double = Double.greatestFiniteMagnitude\n\
    \    var max: Double = Double.lowestFiniteMagnitude\n    for number in numbers\
    \ {\n        let scaledNumber = number / max - min\n        scaled.append(scaledNumber)\n\
    \        min = min(min, number)\n        max = max(max, number)\n    }\n    return\
    \ scaled\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpnvjuebgk.swift:9:30: error: type 'Double' has no member 'lowestFiniteMagnitude'\n\
    \    var max: Double = Double.lowestFiniteMagnitude\n                      ~~~~~~\
    \ ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpnvjuebgk.swift:13:15: error: cannot call value\
    \ of non-function type 'Double'\n        min = min(min, number)\n            \
    \  ^\n/tmp/tmpnvjuebgk.swift:14:15: error: cannot call value of non-function type\
    \ 'Double'\n        max = max(max, number)\n              ^\n"
  stdout: ''
  timestamp: 1660013798
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var rescaled: [Double] = []\n    var min: Double = Double(Int.max)\n\
    \    var max: Double = Double(Int.min)\n    for number in numbers {\n        rescaled.append(number\
    \ - min)\n        min = min(min, number)\n        max = max(max, number)\n   \
    \ }\n    for number in numbers {\n        rescaled.append(number / max - min)\n\
    \    }\n    return rescaled\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmp1lzm95bb.swift:12:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmp1lzm95bb.swift:13:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013799
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var rescaled: [Double] = []\n    var smallest: Double = Double.greatestFiniteMagnitude\n\
    \    var largest: Double = Double.leastFiniteMagnitude\n    for number in numbers\
    \ {\n        smallest = min(number, smallest)\n        largest = max(number, largest)\n\
    \        rescaled.append(number - smallest)\n    }\n    return rescaled\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpc8r94of0.swift:9:34: error: type 'Double' has no member 'leastFiniteMagnitude'\n\
    \    var largest: Double = Double.leastFiniteMagnitude\n                     \
    \     ~~~~~~ ^~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013799
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var min: Double = Double.greatestFiniteMagnitude\n    var max: Double\
    \ = Double.leastFiniteMagnitude\n    for number in numbers {\n        min = min(min,\
    \ number)\n        max = max(max, number)\n    }\n    var scaled: [Double] = []\n\
    \    for number in numbers {\n        scaled.append((number - min) / (max - min))\n\
    \    }\n    return scaled\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmps_8ap6lw.swift:8:30: error: type 'Double' has no member 'leastFiniteMagnitude'\n\
    \    var max: Double = Double.leastFiniteMagnitude\n                      ~~~~~~\
    \ ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmps_8ap6lw.swift:10:15: error: cannot call value\
    \ of non-function type 'Double'\n        min = min(min, number)\n            \
    \  ^\n/tmp/tmps_8ap6lw.swift:11:15: error: cannot call value of non-function type\
    \ 'Double'\n        max = max(max, number)\n              ^\n"
  stdout: ''
  timestamp: 1660013798
- exit_code: -4
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var rescaled: [Double] = []\n    for number in numbers {\n        rescaled.append(number\
    \ / min(number, 1.0))\n    }\n    return rescaled\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: Exception
  stderr: 'tmp_rm2k2ga/tmp_rm2k2ga.swift:27: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002afbb3671c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002afbb3368b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002afbb3368988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002afbb33677b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp_rm2k2ga                        0x000055e0cfdc4693 <unavailable> + 5779

    5    libc.so.6                          0x00002afbb385d460 __libc_start_main +
    245

    6    tmp_rm2k2ga                        0x000055e0cfdc4299 <unavailable> + 4761

    '
  stdout: ''
  timestamp: 1660013799
- exit_code: 0
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var min = Double(numbers[0])\n    var max = Double(numbers[0])\n    for\
    \ number in numbers {\n        if number < min {\n            min = number\n \
    \       }\n        if number > max {\n            max = number\n        }\n  \
    \  }\n    var scaled: [Double] = []\n    for number in numbers {\n        scaled.append((number\
    \ - min) / (max - min))\n    }\n    return scaled\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013799
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var min = Double(Int.max)\n    var max = Double(Int.min)\n    for number\
    \ in numbers {\n        min = min(min, number)\n        max = max(max, number)\n\
    \    }\n    var scaled: [Double] = []\n    for number in numbers {\n        scaled.append((number\
    \ - min) / (max - min))\n    }\n    return scaled\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpkqup1axs.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpkqup1axs.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013798
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var min: Double = Double(Int.max)\n    var max: Double = Double(Int.min)\n\
    \    for number in numbers {\n        min = min(min, number)\n        max = max(max,\
    \ number)\n    }\n    var result: [Double] = []\n    for number in numbers {\n\
    \        result.append(number - min)\n        result.append(number - max)\n  \
    \  }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpd6kk2qbz.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpd6kk2qbz.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013798
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var min = Double(numbers[0])\n    var max = Double(numbers[0])\n    for\
    \ number in numbers {\n        if number < min {\n            min = number\n \
    \       }\n        if number > max {\n            max = number\n        }\n  \
    \  }\n    var scaled: [Double] = []\n    for number in numbers {\n        scaled.append(number\
    \ - min)\n    }\n    var scale = (max - min) / Double(scaled.count)\n    for number\
    \ in scaled {\n        number *= scale\n    }\n    return scaled\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmp8_5r50qp.swift:23:16: error: left side of mutating operator isn't\
    \ mutable: 'number' is a 'let' constant\n        number *= scale\n        ~~~~~~\
    \ ^\n"
  stdout: ''
  timestamp: 1660013799
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var min: Double = Double(Int.max)\n    var max: Double = Double(Int.min)\n\
    \    for number in numbers {\n        min = min(min, number)\n        max = max(max,\
    \ number)\n    }\n    var result: [Double] = []\n    for number in numbers {\n\
    \        result.append(number - min)\n        result.append(number - max)\n  \
    \  }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpd6kk2qbz.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpd6kk2qbz.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013798
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var min = Double(Int.max)\n    var max = Double(Int.min)\n    for number\
    \ in numbers {\n        min = min(min, number)\n        max = max(max, number)\n\
    \    }\n    var result = [Double](repeating: 0.0, count: numbers.count)\n    for\
    \ number in numbers {\n        result[numbers.index(of: number)] = number / max(max\
    \ - min, Double(1))\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmprs5h6yaa.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmprs5h6yaa.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n/tmp/tmprs5h6yaa.swift:15:24: error: value of optional\
    \ type 'Array<Double>.Index?' (aka 'Optional<Int>') must be unwrapped to a value\
    \ of type 'Array<Double>.Index' (aka 'Int')\n        result[numbers.index(of:\
    \ number)] = number / max(max - min, Double(1))\n                       ^\n/tmp/tmprs5h6yaa.swift:15:24:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n        result[numbers.index(of: number)] = number / max(max - min, Double(1))\n\
    \                       ^\n                                         ?? <#default\
    \ value#>\n/tmp/tmprs5h6yaa.swift:15:24: note: force-unwrap using '!' to abort\
    \ execution if the optional value contains 'nil'\n        result[numbers.index(of:\
    \ number)] = number / max(max - min, Double(1))\n                       ^\n  \
    \                                      !\n/tmp/tmprs5h6yaa.swift:15:54: error:\
    \ cannot call value of non-function type 'Double'\n        result[numbers.index(of:\
    \ number)] = number / max(max - min, Double(1))\n                            \
    \                         ^\n"
  stdout: ''
  timestamp: 1660013799
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var min: Double = Double(Int.max)\n    var max: Double = Double(Int.min)\n\
    \    for number in numbers {\n        min = min(min, number)\n        max = max(max,\
    \ number)\n    }\n    var scaled: [Double] = []\n    for number in numbers {\n\
    \        scaled.append(number - min)\n    }\n    for number in scaled {\n    \
    \    number /= max - min\n    }\n    return scaled\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpxbbyb8vz.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpxbbyb8vz.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n/tmp/tmpxbbyb8vz.swift:18:16: error: left side of\
    \ mutating operator isn't mutable: 'number' is a 'let' constant\n        number\
    \ /= max - min\n        ~~~~~~ ^\n"
  stdout: ''
  timestamp: 1660013799
- exit_code: -4
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var scaled: [Double] = []\n    for number in numbers {\n        scaled.append(min(max(0.0,\
    \ number), 1.0))\n    }\n    return scaled\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: Exception
  stderr: 'tmpzzc2007_/tmpzzc2007_.swift:27: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b239e3dcc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b239e0d3b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b239e0d3988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b239e0d27b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpzzc2007_                        0x00005591bd3506f3 <unavailable> + 5875

    5    libc.so.6                          0x00002b239e5c8460 __libc_start_main +
    245

    6    tmpzzc2007_                        0x00005591bd3502f9 <unavailable> + 4857

    '
  stdout: ''
  timestamp: 1660013799
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var min: Double = Double(Int.max)\n    var max: Double = Double(Int.min)\n\
    \    for number in numbers {\n        min = min(min, number)\n        max = max(max,\
    \ number)\n    }\n    var result: [Double] = []\n    for number in numbers {\n\
    \        result.append(number - min)\n        result.append(number - max)\n  \
    \  }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpd6kk2qbz.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpd6kk2qbz.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013798
- exit_code: -4
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var rescaled: [Double] = []\n    for number in numbers {\n        rescaled.append(number\
    \ / min(number, 1.0))\n    }\n    return rescaled\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: Exception
  stderr: 'tmp_rm2k2ga/tmp_rm2k2ga.swift:27: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002afbb3671c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002afbb3368b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002afbb3368988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002afbb33677b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp_rm2k2ga                        0x000055e0cfdc4693 <unavailable> + 5779

    5    libc.so.6                          0x00002afbb385d460 __libc_start_main +
    245

    6    tmp_rm2k2ga                        0x000055e0cfdc4299 <unavailable> + 4761

    '
  stdout: ''
  timestamp: 1660013799
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var scaled: [Double] = []\n    var min: Double = Double.greatestFiniteMagnitude\n\
    \    var max: Double = Double.lowestFiniteMagnitude\n    for number in numbers\
    \ {\n        min = min(min, number)\n        max = max(max, number)\n        scaled.append(number\
    \ - min)\n    }\n    for number in numbers {\n        scaled.append(number / max\
    \ - min)\n    }\n    return scaled\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpwrha_tjs.swift:9:30: error: type 'Double' has no member 'lowestFiniteMagnitude'\n\
    \    var max: Double = Double.lowestFiniteMagnitude\n                      ~~~~~~\
    \ ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpwrha_tjs.swift:11:15: error: cannot call value\
    \ of non-function type 'Double'\n        min = min(min, number)\n            \
    \  ^\n/tmp/tmpwrha_tjs.swift:12:15: error: cannot call value of non-function type\
    \ 'Double'\n        max = max(max, number)\n              ^\n"
  stdout: ''
  timestamp: 1660013799
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var min: Double = Double(Int.max)\n    var max: Double = Double(Int.min)\n\
    \    for number in numbers {\n        min = min(min, number)\n        max = max(max,\
    \ number)\n    }\n    var scaled: [Double] = []\n    for number in numbers {\n\
    \        scaled.append((number - min) / (max - min))\n    }\n    return scaled\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpwq0ustex.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpwq0ustex.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013798
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var min = Double(Int.max)\n    var max = Double(Int.min)\n    for number\
    \ in numbers {\n        min = min(min, number)\n        max = max(max, number)\n\
    \    }\n    var result: [Double] = []\n    for number in numbers {\n        result.append(number\
    \ - min)\n        result.append(number - max)\n    }\n    return result\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpd9hsoeox.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpd9hsoeox.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013798
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var min: Double = Double(Int.max)\n    var max: Double = Double(Int.min)\n\
    \    for number in numbers {\n        min = min(min, number)\n        max = max(max,\
    \ number)\n    }\n    var scaled: [Double] = []\n    for number in numbers {\n\
    \        scaled.append((number - min) / (max - min))\n    }\n    return scaled\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpwq0ustex.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpwq0ustex.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013798
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var min = Double(numbers[0])\n    var max = Double(numbers[0])\n    for\
    \ number in numbers {\n        if number < min {\n            min = number\n \
    \       }\n        if number > max {\n            max = number\n        }\n  \
    \  }\n    var result = [Double](repeating: 0.0, count: numbers.count)\n    for\
    \ number in numbers {\n        result[numbers.index(of: number)] = ((number -\
    \ min) / (max - min)) * 1.0\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpyf97bmj6.swift:19:24: error: value of optional type 'Array<Double>.Index?'\
    \ (aka 'Optional<Int>') must be unwrapped to a value of type 'Array<Double>.Index'\
    \ (aka 'Int')\n        result[numbers.index(of: number)] = ((number - min) / (max\
    \ - min)) * 1.0\n                       ^\n/tmp/tmpyf97bmj6.swift:19:24: note:\
    \ coalesce using '??' to provide a default when the optional value contains 'nil'\n\
    \        result[numbers.index(of: number)] = ((number - min) / (max - min)) *\
    \ 1.0\n                       ^\n                                         ?? <#default\
    \ value#>\n/tmp/tmpyf97bmj6.swift:19:24: note: force-unwrap using '!' to abort\
    \ execution if the optional value contains 'nil'\n        result[numbers.index(of:\
    \ number)] = ((number - min) / (max - min)) * 1.0\n                       ^\n\
    \                                        !\n"
  stdout: ''
  timestamp: 1660013798
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var min: Double = Double(Int.max)\n    var max: Double = Double(Int.min)\n\
    \    for number in numbers {\n        min = min(min, number)\n        max = max(max,\
    \ number)\n    }\n    var result: [Double] = []\n    for number in numbers {\n\
    \        result.append(number - min)\n        result.append(number - max)\n  \
    \  }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpd6kk2qbz.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpd6kk2qbz.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013798
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var min = Double(Int.max)\n    var max = Double(Int.min)\n    for number\
    \ in numbers {\n        min = min(min, number)\n        max = max(max, number)\n\
    \    }\n    var result: [Double] = []\n    for number in numbers {\n        result.append(number\
    \ - min)\n        result.append(number - max)\n    }\n    return result\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpd9hsoeox.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpd9hsoeox.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013798
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var rescaled: [Double] = []\n    for number in numbers {\n        rescaled.append(number\
    \ / min(number))\n    }\n    return rescaled\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmp0l79h_sa.swift:9:44: error: missing argument for parameter #2 in\
    \ call\n        rescaled.append(number / min(number))\n                      \
    \                     ^\n                                           , <#Double#>\n\
    Swift.min:1:24: note: 'min' declared here\n@inlinable public func min<T>(_ x:\
    \ T, _ y: T) -> T where T : Comparable\n                       ^\n"
  stdout: ''
  timestamp: 1660013799
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var min: Double = Double(Int.max)\n    var max: Double = Double(Int.min)\n\
    \    for number in numbers {\n        min = min(min, number)\n        max = max(max,\
    \ number)\n    }\n    var result: [Double] = []\n    for number in numbers {\n\
    \        result.append(number - min)\n        result.append(number - max)\n  \
    \  }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpd6kk2qbz.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpd6kk2qbz.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013798
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    let min = min(numbers)\n    let max = max(numbers)\n    var scaled: [Double]\
    \ = []\n    for number in numbers {\n        scaled.append((number - min) / (max\
    \ - min))\n    }\n    return scaled\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpp31a_vbo.swift:7:26: error: missing argument for parameter #2 in\
    \ call\n    let min = min(numbers)\n                         ^\n             \
    \            , <#[Double]#>\nSwift.min:1:24: note: 'min' declared here\n@inlinable\
    \ public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n             \
    \          ^\n/tmp/tmpp31a_vbo.swift:8:26: error: missing argument for parameter\
    \ #2 in call\n    let max = max(numbers)\n                         ^\n       \
    \                  , <#[Double]#>\nSwift.max:1:24: note: 'max' declared here\n\
    @inlinable public func max<T>(_ x: T, _ y: T) -> T where T : Comparable\n    \
    \                   ^\n"
  stdout: ''
  timestamp: 1660013799
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var min = Double(Int.max)\n    var max = Double(Int.min)\n    for number\
    \ in numbers {\n        min = min(min, number)\n        max = max(max, number)\n\
    \    }\n    var scaled: [Double] = []\n    for number in numbers {\n        scaled.append(number\
    \ - min)\n        scaled.append(number - max)\n    }\n    return scaled\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmp0fasisov.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmp0fasisov.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013798
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var rescaled: [Double] = []\n    var min: Double = Double.greatestFiniteMagnitude\n\
    \    var max: Double = Double.leastFiniteMagnitude\n    for number in numbers\
    \ {\n        min = min(min, number)\n        max = max(max, number)\n    }\n \
    \   for number in numbers {\n        rescaled.append(number - min)\n        rescaled.append(number\
    \ - max)\n    }\n    return rescaled\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmppp1dx3w_.swift:9:30: error: type 'Double' has no member 'leastFiniteMagnitude'\n\
    \    var max: Double = Double.leastFiniteMagnitude\n                      ~~~~~~\
    \ ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmppp1dx3w_.swift:11:15: error: cannot call value\
    \ of non-function type 'Double'\n        min = min(min, number)\n            \
    \  ^\n/tmp/tmppp1dx3w_.swift:12:15: error: cannot call value of non-function type\
    \ 'Double'\n        max = max(max, number)\n              ^\n"
  stdout: ''
  timestamp: 1660013799
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var min = Double(Int.max)\n    var max = Double(Int.min)\n    for number\
    \ in numbers {\n        min = min(min, number)\n        max = max(max, number)\n\
    \    }\n    var scaled: [Double] = []\n    for number in numbers {\n        scaled.append((number\
    \ - min) / (max - min))\n    }\n    return scaled\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpkqup1axs.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpkqup1axs.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013798
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var min = Double(numbers[0])\n    var max = Double(numbers[0])\n    for\
    \ number in numbers {\n        if number < min {\n            min = number\n \
    \       }\n        if number > max {\n            max = number\n        }\n  \
    \  }\n    var scaled: [Double] = []\n    for number in numbers {\n        scaled.append(number\
    \ - min)\n    }\n    for number in scaled {\n        number /= max - min\n   \
    \ }\n    return scaled\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpif9z_t7d.swift:22:16: error: left side of mutating operator isn't\
    \ mutable: 'number' is a 'let' constant\n        number /= max - min\n       \
    \ ~~~~~~ ^\n"
  stdout: ''
  timestamp: 1660013799
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var min: Double = Double.greatestFiniteMagnitude\n    var max: Double\
    \ = Double.leastFiniteMagnitude\n    for number in numbers {\n        min = min(min,\
    \ number)\n        max = max(max, number)\n    }\n    var scaled: [Double] = []\n\
    \    for number in numbers {\n        scaled.append(number - min)\n        scaled.append(number\
    \ - max)\n    }\n    return scaled\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpzgau0uf0.swift:8:30: error: type 'Double' has no member 'leastFiniteMagnitude'\n\
    \    var max: Double = Double.leastFiniteMagnitude\n                      ~~~~~~\
    \ ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmpzgau0uf0.swift:10:15: error: cannot call value\
    \ of non-function type 'Double'\n        min = min(min, number)\n            \
    \  ^\n/tmp/tmpzgau0uf0.swift:11:15: error: cannot call value of non-function type\
    \ 'Double'\n        max = max(max, number)\n              ^\n"
  stdout: ''
  timestamp: 1660013798
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var min = Double(Int.max)\n    var max = Double(Int.min)\n    for number\
    \ in numbers {\n        min = min(min, number)\n        max = max(max, number)\n\
    \    }\n    var scaled: [Double] = []\n    for number in numbers {\n        scaled.append((number\
    \ - min) / (max - min))\n    }\n    return scaled\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpkqup1axs.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpkqup1axs.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013798
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var min = Double(Int.max)\n    var max = Double(Int.min)\n    for number\
    \ in numbers {\n        min = min(min, number)\n        max = max(max, number)\n\
    \    }\n    var result: [Double] = []\n    for number in numbers {\n        result.append(number\
    \ - min)\n        result.append(number - max)\n    }\n    return result\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpd9hsoeox.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpd9hsoeox.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013798
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var min: Double = Double(Int.max)\n    var max: Double = Double(Int.min)\n\
    \    for number in numbers {\n        min = min(min, number)\n        max = max(max,\
    \ number)\n    }\n    var result: [Double] = []\n    for number in numbers {\n\
    \        result.append(number - min)\n        result.append(number - max)\n  \
    \  }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpd6kk2qbz.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpd6kk2qbz.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013798
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var min: Double = Double(Int.max)\n    var max: Double = Double(Int.min)\n\
    \    for number in numbers {\n        min = min(min, number)\n        max = max(max,\
    \ number)\n    }\n    var scaled: [Double] = []\n    for number in numbers {\n\
    \        scaled.append((number - min) / (max - min))\n    }\n    return scaled\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpwq0ustex.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpwq0ustex.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013798
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var min: Double = Double(Int.max)\n    var max: Double = Double(Int.min)\n\
    \    for number in numbers {\n        min = min(min, number)\n        max = max(max,\
    \ number)\n    }\n    var result: [Double] = []\n    for number in numbers {\n\
    \        result.append(number - min)\n        result.append(number - max)\n  \
    \  }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpd6kk2qbz.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpd6kk2qbz.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013798
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    let min = min(numbers)\n    let max = max(numbers)\n    var scaled: [Double]\
    \ = []\n    for number in numbers {\n        scaled.append((number - min) / (max\
    \ - min))\n    }\n    return scaled\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpp31a_vbo.swift:7:26: error: missing argument for parameter #2 in\
    \ call\n    let min = min(numbers)\n                         ^\n             \
    \            , <#[Double]#>\nSwift.min:1:24: note: 'min' declared here\n@inlinable\
    \ public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n             \
    \          ^\n/tmp/tmpp31a_vbo.swift:8:26: error: missing argument for parameter\
    \ #2 in call\n    let max = max(numbers)\n                         ^\n       \
    \                  , <#[Double]#>\nSwift.max:1:24: note: 'max' declared here\n\
    @inlinable public func max<T>(_ x: T, _ y: T) -> T where T : Comparable\n    \
    \                   ^\n"
  stdout: ''
  timestamp: 1660013799
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var min: Double = Double(Int.max)\n    var max: Double = Double(Int.min)\n\
    \    for number in numbers {\n        min = min(min, number)\n        max = max(max,\
    \ number)\n    }\n    var result: [Double] = []\n    for number in numbers {\n\
    \        result.append(number - min)\n        result.append(number - max)\n  \
    \  }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpd6kk2qbz.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpd6kk2qbz.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013798
- exit_code: -4
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var min: Double = Double(Int.max)\n    var max: Double = Double(Int.min)\n\
    \    for number in numbers {\n        if number < min {\n            min = number\n\
    \        }\n        if number > max {\n            max = number\n        }\n \
    \   }\n    var result: [Double] = []\n    for number in numbers {\n        result.append(number\
    \ - min)\n        result.append(number - max)\n    }\n    return result\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: Exception
  stderr: 'tmpbnqh2jsc/tmpbnqh2jsc.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ade10d1ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ade10a15b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ade10a15988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ade10a147b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpbnqh2jsc                        0x00005577a8ba1603 <unavailable> + 5635

    5    libc.so.6                          0x00002ade10f0a460 __libc_start_main +
    245

    6    tmpbnqh2jsc                        0x00005577a8ba1209 <unavailable> + 4617

    '
  stdout: ''
  timestamp: 1660013799
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    let min: Double = numbers.min()\n    let max: Double = numbers.max()\n\
    \    let range = max - min\n    let scaled: [Double] = numbers.map { $0 - min\
    \ / range }\n    return scaled\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpm2k5oezm.swift:7:31: error: value of optional type 'Double?' must\
    \ be unwrapped to a value of type 'Double'\n    let min: Double = numbers.min()\n\
    \                              ^\n/tmp/tmpm2k5oezm.swift:7:31: note: coalesce\
    \ using '??' to provide a default when the optional value contains 'nil'\n   \
    \ let min: Double = numbers.min()\n                              ^\n         \
    \                           ?? <#default value#>\n/tmp/tmpm2k5oezm.swift:7:31:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n    let min: Double = numbers.min()\n                              ^\n\
    \                                   !\n/tmp/tmpm2k5oezm.swift:8:31: error: value\
    \ of optional type 'Double?' must be unwrapped to a value of type 'Double'\n \
    \   let max: Double = numbers.max()\n                              ^\n/tmp/tmpm2k5oezm.swift:8:31:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n    let max: Double = numbers.max()\n                              ^\n\
    \                                    ?? <#default value#>\n/tmp/tmpm2k5oezm.swift:8:31:\
    \ note: force-unwrap using '!' to abort execution if the optional value contains\
    \ 'nil'\n    let max: Double = numbers.max()\n                              ^\n\
    \                                   !\n"
  stdout: ''
  timestamp: 1660013799
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var min: Double = Double(Int.max)\n    var max: Double = Double(Int.min)\n\
    \    for number in numbers {\n        min = min(min, number)\n        max = max(max,\
    \ number)\n    }\n    var result: [Double] = []\n    for number in numbers {\n\
    \        result.append(number - min)\n        result.append(number - max)\n  \
    \  }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpd6kk2qbz.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpd6kk2qbz.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013798
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var min = Double(Int.max)\n    var max = Double(Int.min)\n    for number\
    \ in numbers {\n        min = min(min, number)\n        max = max(max, number)\n\
    \    }\n    var result: [Double] = []\n    for number in numbers {\n        result.append(number\
    \ - min)\n        result.append(number - max)\n    }\n    return result\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpd9hsoeox.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpd9hsoeox.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013798
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var min = Double(Int.max)\n    var max = Double(Int.min)\n    for number\
    \ in numbers {\n        min = min(min, number)\n        max = max(max, number)\n\
    \    }\n    var scaled: [Double] = []\n    for number in numbers {\n        scaled.append(number\
    \ - min)\n    }\n    for number in scaled {\n        number = number / max\n \
    \   }\n    return scaled\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpn8vnyjdc.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpn8vnyjdc.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n/tmp/tmpn8vnyjdc.swift:18:9: error: cannot assign\
    \ to value: 'number' is a 'let' constant\n        number = number / max\n    \
    \    ^~~~~~\n"
  stdout: ''
  timestamp: 1660013799
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var min = Double(Int.max)\n    var max = Double(Int.min)\n    for number\
    \ in numbers {\n        min = min(min, number)\n        max = max(max, number)\n\
    \    }\n    var result: [Double] = []\n    for number in numbers {\n        result.append(number\
    \ - min)\n        result.append(number - max)\n    }\n    return result\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpd9hsoeox.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpd9hsoeox.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013798
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var scaled: [Double] = []\n    for number in numbers {\n        scaled.append((number\
    \ - min(numbers)) / (max(numbers) - min(numbers)))\n    }\n    return scaled\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpy53wb_li.swift:9:9: error: the compiler is unable to type-check\
    \ this expression in reasonable time; try breaking up the expression into distinct\
    \ sub-expressions\n        scaled.append((number - min(numbers)) / (max(numbers)\
    \ - min(numbers)))\n        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013834
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var min: Double = Double(Int.max)\n    var max: Double = Double(Int.min)\n\
    \    for number in numbers {\n        min = min(min, number)\n        max = max(max,\
    \ number)\n    }\n    var result: [Double] = []\n    for number in numbers {\n\
    \        result.append(number - min)\n        result.append(number - max)\n  \
    \  }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpd6kk2qbz.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpd6kk2qbz.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013798
- exit_code: -4
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var rescaled: [Double] = []\n    var smallest: Double = Double(Int.max)\n\
    \    var largest: Double = Double(Int.min)\n    for number in numbers {\n    \
    \    rescaled.append(number / largest)\n        smallest = min(smallest, number)\n\
    \        largest = max(largest, number)\n    }\n    return rescaled\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: Exception
  stderr: 'tmph1i2cfqm/tmph1i2cfqm.swift:31: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b8650fc6c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8650cbdb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b8650cbd988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b8650cbc7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmph1i2cfqm                        0x00005584ab3b06f3 <unavailable> + 5875

    5    libc.so.6                          0x00002b86511b2460 __libc_start_main +
    245

    6    tmph1i2cfqm                        0x00005584ab3b02f9 <unavailable> + 4857

    '
  stdout: ''
  timestamp: 1660013799
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var min = Double(Int.max)\n    var max = Double(Int.min)\n    for number\
    \ in numbers {\n        min = min(min, number)\n        max = max(max, number)\n\
    \    }\n    var scaled: [Double] = []\n    for number in numbers {\n        scaled.append((number\
    \ - min) / (max - min))\n    }\n    return scaled\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpkqup1axs.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpkqup1axs.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013798
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var min = Double(Int.max)\n    var max = Double(Int.min)\n    for number\
    \ in numbers {\n        min = min(min, number)\n        max = max(max, number)\n\
    \    }\n    var result = [Double]()\n    for number in numbers {\n        result.append(number\
    \ - min)\n        result.append(max - number)\n    }\n    return result\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpjb7cimwm.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpjb7cimwm.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013799
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var min: Double = Double(Int.max)\n    var max: Double = Double(Int.min)\n\
    \    for number in numbers {\n        min = min(min, number)\n        max = max(max,\
    \ number)\n    }\n    var result: [Double] = []\n    for number in numbers {\n\
    \        result.append(number - min)\n        result.append(number - max)\n  \
    \  }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpd6kk2qbz.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpd6kk2qbz.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013798
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var min: Double = Double.greatestFiniteMagnitude\n    var max: Double\
    \ = Double.leastFiniteMagnitude\n    for number in numbers {\n        min = min(min,\
    \ number)\n        max = max(max, number)\n    }\n    var result: [Double] = []\n\
    \    for number in numbers {\n        result.append(number - min)\n        result.append(number\
    \ - max)\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpqhtwqsbu.swift:8:30: error: type 'Double' has no member 'leastFiniteMagnitude'\n\
    \    var max: Double = Double.leastFiniteMagnitude\n                      ~~~~~~\
    \ ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmpqhtwqsbu.swift:10:15: error: cannot call value\
    \ of non-function type 'Double'\n        min = min(min, number)\n            \
    \  ^\n/tmp/tmpqhtwqsbu.swift:11:15: error: cannot call value of non-function type\
    \ 'Double'\n        max = max(max, number)\n              ^\n"
  stdout: ''
  timestamp: 1660013798
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var min = Double(Int.max)\n    var max = Double(Int.min)\n    for number\
    \ in numbers {\n        min = min(min, number)\n        max = max(max, number)\n\
    \    }\n    var result: [Double] = []\n    for number in numbers {\n        result.append(number\
    \ - min)\n        result.append(number - max)\n    }\n    return result\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(rescale_to_unit(numbers: [2.0, 49.9]) == [0.0,\
    \ 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9]) == [1.0, 0.0])\nassert(rescale_to_unit(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0]) == [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers:\
    \ [2.0, 1.0, 5.0, 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpd9hsoeox.swift:10:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpd9hsoeox.swift:11:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013798
- exit_code: 1
  program: "\n/// Given list of numbers (of at least two elements), apply a linear\
    \ transform to that list,\n/// such that the smallest number will become 0 and\
    \ the largest will become 1\n/// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n\
    /// [0.0, 0.25, 0.5, 0.75, 1.0]\nfunc rescale_to_unit(numbers: [Double]) -> [Double]\
    \ {\n    var scaled: [Double] = []\n    var min: Double = Double(Int.max)\n  \
    \  var max: Double = Double(Int.min)\n    for number in numbers {\n        min\
    \ = min(min, number)\n        max = max(max, number)\n    }\n    for number in\
    \ numbers {\n        scaled.append(number * (max - min) / Double(numbers.count))\n\
    \    }\n    return scaled\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(rescale_to_unit(numbers:\
    \ [2.0, 49.9]) == [0.0, 1.0])\nassert(rescale_to_unit(numbers: [100.0, 49.9])\
    \ == [1.0, 0.0])\nassert(rescale_to_unit(numbers: [1.0, 2.0, 3.0, 4.0, 5.0]) ==\
    \ [0.0, 0.25, 0.5, 0.75, 1.0])\nassert(rescale_to_unit(numbers: [2.0, 1.0, 5.0,\
    \ 3.0, 4.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])\nassert(rescale_to_unit(numbers:\
    \ [12.0, 11.0, 15.0, 13.0, 14.0]) == [0.25, 0.0, 1.0, 0.5, 0.75])"
  status: SyntaxError
  stderr: "/tmp/tmpk28bcdp6.swift:11:15: error: cannot call value of non-function\
    \ type 'Double'\n        min = min(min, number)\n              ^\n/tmp/tmpk28bcdp6.swift:12:15:\
    \ error: cannot call value of non-function type 'Double'\n        max = max(max,\
    \ number)\n              ^\n"
  stdout: ''
  timestamp: 1660013799
