language: swift
name: HumanEval_20_find_closest_elements
results:
- exit_code: -4
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double])\
    \ -> (Double, Double) {\n    var smallest = numbers[0]\n    var largest = numbers[0]\n\
    \    for number in numbers {\n        if number < smallest {\n            smallest\
    \ = number\n        }\n        if number > largest {\n            largest = number\n\
    \        }\n    }\n    return (smallest, largest)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9,\
    \ 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: Exception
  stderr: 'tmpuvdtn9la/tmpuvdtn9la.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002abfe48f1c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002abfe45e8b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002abfe45e8988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002abfe45e77b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpuvdtn9la                        0x0000562f96bb064e <unavailable> + 5710

    5    libc.so.6                          0x00002abfe4add460 __libc_start_main +
    245

    6    tmpuvdtn9la                        0x0000562f96bb0209 <unavailable> + 4617

    '
  stdout: ''
  timestamp: 1660013732
- exit_code: -4
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double])\
    \ -> (Double, Double) {\n    guard numbers.count >= 2 else { return (numbers[0],\
    \ numbers[0]) }\n    guard numbers.count >= 3 else { return (numbers[0], numbers[0])\
    \ }\n\n    var smallest = numbers[0]\n    var largest = numbers[0]\n    var smallestIndex\
    \ = -1\n    var largestIndex = -1\n\n    for i in 1..<numbers.count {\n      \
    \  let currentNumber = numbers[i]\n        if currentNumber < smallest {\n   \
    \         smallest = currentNumber\n            smallestIndex = i\n        }\n\
    \        if currentNumber > largest {\n            largest = currentNumber\n \
    \           largestIndex = i\n        }\n    }\n\n    return (numbers[smallestIndex],\
    \ numbers[largestIndex])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b1e15d62c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b1e15a59561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b1e15a59286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b1e15a5913c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b1e15a58bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b1e15858f44 <unavailable> + 188228

    6    tmpwi0uasus                        0x0000562d5dfaaf4c <unavailable> + 8012

    7    tmpwi0uasus                        0x0000562d5dfaa5cd <unavailable> + 5581

    8    libc.so.6                          0x00002b1e15f4e460 __libc_start_main +
    245

    9    tmpwi0uasus                        0x0000562d5dfaa279 <unavailable> + 4729

    '
  stdout: ''
  timestamp: 1660013732
- exit_code: -4
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double])\
    \ -> (Double, Double) {\n    var smallest = numbers[0]\n    var largest = numbers[0]\n\
    \    for number in numbers {\n        if number < smallest {\n            smallest\
    \ = number\n        }\n        if number > largest {\n            largest = number\n\
    \        }\n    }\n    return (smallest, largest)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9,\
    \ 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: Exception
  stderr: 'tmpuvdtn9la/tmpuvdtn9la.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002abfe48f1c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002abfe45e8b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002abfe45e8988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002abfe45e77b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpuvdtn9la                        0x0000562f96bb064e <unavailable> + 5710

    5    libc.so.6                          0x00002abfe4add460 __libc_start_main +
    245

    6    tmpuvdtn9la                        0x0000562f96bb0209 <unavailable> + 4617

    '
  stdout: ''
  timestamp: 1660013732
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double])\
    \ -> (Double, Double) {\n    let smallest = min(numbers)\n    let largest = max(numbers)\n\
    \    return (smallest, largest)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpbwt_n_vu.swift:9:31: error: missing argument for parameter #2 in\
    \ call\n    let smallest = min(numbers)\n                              ^\n   \
    \                           , <#[Double]#>\nSwift.min:1:24: note: 'min' declared\
    \ here\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n\
    \                       ^\n/tmp/tmpbwt_n_vu.swift:10:30: error: missing argument\
    \ for parameter #2 in call\n    let largest = max(numbers)\n                 \
    \            ^\n                             , <#[Double]#>\nSwift.max:1:24: note:\
    \ 'max' declared here\n@inlinable public func max<T>(_ x: T, _ y: T) -> T where\
    \ T : Comparable\n                       ^\n"
  stdout: ''
  timestamp: 1660013731
- exit_code: -4
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double])\
    \ -> (Double, Double) {\n    var smallest = numbers[0]\n    var largest = numbers[0]\n\
    \    for number in numbers {\n        if number < smallest {\n            smallest\
    \ = number\n        }\n        if number > largest {\n            largest = number\n\
    \        }\n    }\n    return (smallest, largest)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9,\
    \ 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: Exception
  stderr: 'tmpuvdtn9la/tmpuvdtn9la.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002abfe48f1c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002abfe45e8b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002abfe45e8988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002abfe45e77b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpuvdtn9la                        0x0000562f96bb064e <unavailable> + 5710

    5    libc.so.6                          0x00002abfe4add460 __libc_start_main +
    245

    6    tmpuvdtn9la                        0x0000562f96bb0209 <unavailable> + 4617

    '
  stdout: ''
  timestamp: 1660013732
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double])\
    \ -> (Double, Double) {\n    guard numbers.count >= 2 else { return (numbers[0],\
    \ numbers[0]) }\n    guard numbers.count > 2 else { return (numbers[0], numbers[0])\
    \ }\n    guard numbers.count > 3 else { return (numbers[0], numbers[0]) }\n  \
    \  guard numbers.count > 4 else { return (numbers[0], numbers[0]) }\n    guard\
    \ numbers.count > 5 else { return (numbers[0], numbers[0]) }\n    guard numbers.count\
    \ > 6 else { return (numbers[0], numbers[0]) }\n    guard numbers.count > 7 else\
    \ { return (numbers[0], numbers[0]) }\n    guard numbers.count > 8 else { return\
    \ (numbers[0], numbers[0]) }\n    guard numbers.count > 9 else { return (numbers[0],\
    \ numbers[0]) }\n    guard numbers.count > 10 else { return (numbers[0], numbers[0])\
    \ }\n    guard numbers.count > 11 else { return (numbers[0], numbers[0]) }\n \
    \   guard numbers.count > 12 else { return (numbers[0], numbers[0]) }\n    guard\
    \ numbers.count > 13 else { return (numbers[0], numbers[0]) }\n    guard numbers.count\
    \ > 14 else { return (numbers[0], numbers[0]) }\n    guard numbers.count > 15\
    \ else { return (numbers[0], numbers[0]) }\n    guard numbers.count > 16 else\
    \ { return (numbers[0], numbers[0]) }\n    guard numbers.count > 17 else { return\
    \ (numbers[0], numbers[0]) }\n    guard numbers.count > 18 else { return (numbers[0],\
    \ numbers[0]) }\n    guard numbers.count > 19 else { return (numbers[0], numbers[0])\
    \ }\n    guard numbers.count > 20 else { return (numbers[0], numbers[0]) }\n \
    \   guard numbers.count > 21 else { return (numbers[0], numbers[0]) }\n    guard\
    \ numbers.count > 22 else { return (numbers[0], numbers[0]) }\n    guard numbers.count\
    \ > 23 else { return (numbers[0], numbers[0]) }\n    guard numbers.count > 24\
    \ else { return (numbers[0], numbers[0]) }\n    guard numbers.count > 25 else\
    \ { return (numbers[0], numbers[0]) }\n    guard numbers.count > 26 else { return\
    \ (numbers[0], numbers[0]) }\n    guard numbers.count > 27 else { return (numbers[0],\
    \ numbers[0]) }\n    guard numbers.count > 28 else { return (numbers[0], numbers[0])\
    \ }\n    guard numbers.count > 29 else { return (numbers[0], numbers[0]) }\n \
    \   guard numbers.count > 30 else { return (numbers[0], numbers[0]) }\n    guard\
    \ numbers.\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpy_q5khuy.swift:39:18: error: expected member name following '.'\n\
    \    guard numbers.\n                 ^\n/tmp/tmpy_q5khuy.swift:39:19: error:\
    \ expected 'else' after 'guard' condition\n    guard numbers.\n              \
    \    ^\n"
  stdout: ''
  timestamp: 1660013732
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double])\
    \ -> (Double, Double) {\n    let min1 = min(numbers)\n    let min2 = min(numbers)\n\
    \    if min1 < min2 {\n        return (min1, min2)\n    }\n    return (min2, min1)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpu4vmpe9s.swift:9:27: error: missing argument for parameter #2 in\
    \ call\n    let min1 = min(numbers)\n                          ^\n           \
    \               , <#[Double]#>\nSwift.min:1:24: note: 'min' declared here\n@inlinable\
    \ public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n             \
    \          ^\n/tmp/tmpu4vmpe9s.swift:10:27: error: missing argument for parameter\
    \ #2 in call\n    let min2 = min(numbers)\n                          ^\n     \
    \                     , <#[Double]#>\nSwift.min:1:24: note: 'min' declared here\n\
    @inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n    \
    \                   ^\n"
  stdout: ''
  timestamp: 1660013731
- exit_code: -4
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double])\
    \ -> (Double, Double) {\n    if numbers.isEmpty {\n        return (numbers[0],\
    \ numbers[0])\n    }\n    let sortedNumbers = numbers.sorted()\n    let closestToFirst\
    \ = sortedNumbers[0]\n    let closestToSecond = sortedNumbers[1]\n    return (closestToFirst,\
    \ closestToSecond)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: Exception
  stderr: 'tmp9pt5155d/tmp9pt5155d.swift:31: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0fb358fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0fb3286b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0fb3286988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b0fb32857b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp9pt5155d                        0x000055ef5c7a061e <unavailable> + 5662

    5    libc.so.6                          0x00002b0fb377b460 __libc_start_main +
    245

    6    tmp9pt5155d                        0x000055ef5c7a01d9 <unavailable> + 4569

    '
  stdout: ''
  timestamp: 1660013732
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double])\
    \ -> (Double, Double) {\n    guard numbers.count > 2 else {\n        return (0.0,0.0)\n\
    \    }\n    var smallest = numbers[0]\n    var largest = numbers[0]\n    for i\
    \ in 1..numbers.count {\n        if numbers[i] < smallest {\n            smallest\
    \ = numbers[i]\n        }\n        if numbers[i] > largest {\n            largest\
    \ = numbers[i]\n        }\n    }\n    return (smallest, largest)\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmp6z69vm55.swift:14:15: error: cannot find operator '..' in scope;\
    \ did you mean '...'?\n    for i in 1..numbers.count {\n              ^~\n   \
    \           ...\n"
  stdout: ''
  timestamp: 1660013731
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double])\
    \ -> (Double, Double) {\n    let smallest = numbers[0]\n    let largest = numbers[0]\n\
    \    for number in numbers {\n        if number < smallest {\n            smallest\
    \ = number\n        }\n        if number > largest {\n            largest = number\n\
    \        }\n    }\n    return (smallest, largest)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9,\
    \ 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmp5pls_p0p.swift:13:13: error: cannot assign to value: 'smallest'\
    \ is a 'let' constant\n            smallest = number\n            ^~~~~~~~\n/tmp/tmp5pls_p0p.swift:9:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let smallest = numbers[0]\n\
    \    ^~~\n    var\n/tmp/tmp5pls_p0p.swift:16:13: error: cannot assign to value:\
    \ 'largest' is a 'let' constant\n            largest = number\n            ^~~~~~~\n\
    /tmp/tmp5pls_p0p.swift:10:5: note: change 'let' to 'var' to make it mutable\n\
    \    let largest = numbers[0]\n    ^~~\n    var\n"
  stdout: ''
  timestamp: 1660013731
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double])\
    \ -> (Double, Double) {\n    let sortedNumbers = numbers.sorted()\n    let closestIndex\
    \ = sortedNumbers.firstIndex({ $0 > sortedNumbers.last })\n    let closestNumber\
    \ = sortedNumbers[closestIndex]\n    return (closestNumber, sortedNumbers[closestIndex\
    \ + 1])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmp48g6ebjs.swift:10:49: error: missing argument label 'where:' in\
    \ call\n    let closestIndex = sortedNumbers.firstIndex({ $0 > sortedNumbers.last\
    \ })\n                                                ^\n                    \
    \                            where: \n/tmp/tmp48g6ebjs.swift:10:70: error: value\
    \ of optional type 'Double?' must be unwrapped to a value of type 'Double'\n \
    \   let closestIndex = sortedNumbers.firstIndex({ $0 > sortedNumbers.last })\n\
    \                                                                     ^\n/tmp/tmp48g6ebjs.swift:10:70:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n    let closestIndex = sortedNumbers.firstIndex({ $0 > sortedNumbers.last\
    \ })\n                                                                     ^\n\
    \                                                                          ??\
    \ <#default value#>\n/tmp/tmp48g6ebjs.swift:10:70: note: force-unwrap using '!'\
    \ to abort execution if the optional value contains 'nil'\n    let closestIndex\
    \ = sortedNumbers.firstIndex({ $0 > sortedNumbers.last })\n                  \
    \                                                   ^\n                      \
    \                                                   !\n"
  stdout: ''
  timestamp: 1660013731
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double])\
    \ -> (Double, Double) {\n    let min1 = numbers[0]\n    let min2 = numbers[0]\n\
    \    for i in 1..<numbers.count {\n        let current1 = numbers[i]\n       \
    \ let current2 = numbers[i - 1]\n        if current1 < current2 {\n          \
    \  if min1 < current1 {\n                min1 = current1\n            }\n    \
    \        if min2 < current2 {\n                min2 = current2\n            }\n\
    \        } else {\n            if min1 < current2 {\n                min1 = current2\n\
    \            }\n            if min2 < current1 {\n                min2 = current1\n\
    \            }\n        }\n    }\n    return (min1, min2)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9,\
    \ 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmp59wrbqus.swift:16:17: error: cannot assign to value: 'min1' is\
    \ a 'let' constant\n                min1 = current1\n                ^~~~\n/tmp/tmp59wrbqus.swift:9:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let min1 = numbers[0]\n\
    \    ^~~\n    var\n/tmp/tmp59wrbqus.swift:19:17: error: cannot assign to value:\
    \ 'min2' is a 'let' constant\n                min2 = current2\n              \
    \  ^~~~\n/tmp/tmp59wrbqus.swift:10:5: note: change 'let' to 'var' to make it mutable\n\
    \    let min2 = numbers[0]\n    ^~~\n    var\n/tmp/tmp59wrbqus.swift:23:17: error:\
    \ cannot assign to value: 'min1' is a 'let' constant\n                min1 = current2\n\
    \                ^~~~\n/tmp/tmp59wrbqus.swift:9:5: note: change 'let' to 'var'\
    \ to make it mutable\n    let min1 = numbers[0]\n    ^~~\n    var\n/tmp/tmp59wrbqus.swift:26:17:\
    \ error: cannot assign to value: 'min2' is a 'let' constant\n                min2\
    \ = current1\n                ^~~~\n/tmp/tmp59wrbqus.swift:10:5: note: change\
    \ 'let' to 'var' to make it mutable\n    let min2 = numbers[0]\n    ^~~\n    var\n"
  stdout: ''
  timestamp: 1660013731
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double])\
    \ -> (Double, Double) {\n    guard numbers.count >= 2 else {\n        return (0.0,0.0)\n\
    \    }\n    let smallest = numbers[0]\n    let largest = numbers[0]\n    for i\
    \ in 1..<numbers.count {\n        if numbers[i] > largest {\n            largest\
    \ = numbers[i]\n        }\n        if numbers[i] < smallest {\n            smallest\
    \ = numbers[i]\n        }\n    }\n    return (smallest, largest)\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmp7glb58tm.swift:16:13: error: cannot assign to value: 'largest'\
    \ is a 'let' constant\n            largest = numbers[i]\n            ^~~~~~~\n\
    /tmp/tmp7glb58tm.swift:13:5: note: change 'let' to 'var' to make it mutable\n\
    \    let largest = numbers[0]\n    ^~~\n    var\n/tmp/tmp7glb58tm.swift:19:13:\
    \ error: cannot assign to value: 'smallest' is a 'let' constant\n            smallest\
    \ = numbers[i]\n            ^~~~~~~~\n/tmp/tmp7glb58tm.swift:12:5: note: change\
    \ 'let' to 'var' to make it mutable\n    let smallest = numbers[0]\n    ^~~\n\
    \    var\n"
  stdout: ''
  timestamp: 1660013731
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double])\
    \ -> (Double, Double) {\n    let min1 = numbers[0]\n    let max1 = numbers[0]\n\
    \    let min2 = numbers[0]\n    let max2 = numbers[0]\n    for i in 1..<numbers.count\
    \ {\n        let current1 = numbers[i]\n        let current2 = numbers[i - 1]\n\
    \        let current3 = numbers[i - 1]\n        let current4 = numbers[i]\n  \
    \      if current1 < min1 {\n            min1 = current1\n        }\n        if\
    \ current1 > max1 {\n            max1 = current1\n        }\n        if current2\
    \ < min2 {\n            min2 = current2\n        }\n        if current2 > max2\
    \ {\n            max2 = current2\n        }\n        if current3 < min3 {\n  \
    \          min3 = current3\n        }\n        if current3 > max3 {\n        \
    \    max3 = current3\n        }\n        if current4 < min4 {\n            min4\
    \ = current4\n        }\n        if current4 > max4 {\n            max4 = current4\n\
    \        }\n    }\n    return (min1, max1)\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) ==\
    \ (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0])\
    \ == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1,\
    \ 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmppk4enrbt.swift:19:13: error: cannot assign to value: 'min1' is\
    \ a 'let' constant\n            min1 = current1\n            ^~~~\n/tmp/tmppk4enrbt.swift:9:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let min1 = numbers[0]\n\
    \    ^~~\n    var\n/tmp/tmppk4enrbt.swift:22:13: error: cannot assign to value:\
    \ 'max1' is a 'let' constant\n            max1 = current1\n            ^~~~\n\
    /tmp/tmppk4enrbt.swift:10:5: note: change 'let' to 'var' to make it mutable\n\
    \    let max1 = numbers[0]\n    ^~~\n    var\n/tmp/tmppk4enrbt.swift:25:13: error:\
    \ cannot assign to value: 'min2' is a 'let' constant\n            min2 = current2\n\
    \            ^~~~\n/tmp/tmppk4enrbt.swift:11:5: note: change 'let' to 'var' to\
    \ make it mutable\n    let min2 = numbers[0]\n    ^~~\n    var\n/tmp/tmppk4enrbt.swift:28:13:\
    \ error: cannot assign to value: 'max2' is a 'let' constant\n            max2\
    \ = current2\n            ^~~~\n/tmp/tmppk4enrbt.swift:12:5: note: change 'let'\
    \ to 'var' to make it mutable\n    let max2 = numbers[0]\n    ^~~\n    var\n/tmp/tmppk4enrbt.swift:30:23:\
    \ error: cannot find 'min3' in scope\n        if current3 < min3 {\n         \
    \             ^~~~\n/tmp/tmppk4enrbt.swift:31:13: error: cannot find 'min3' in\
    \ scope\n            min3 = current3\n            ^~~~\n/tmp/tmppk4enrbt.swift:33:23:\
    \ error: cannot find 'max3' in scope\n        if current3 > max3 {\n         \
    \             ^~~~\n/tmp/tmppk4enrbt.swift:34:13: error: cannot find 'max3' in\
    \ scope\n            max3 = current3\n            ^~~~\n/tmp/tmppk4enrbt.swift:36:23:\
    \ error: cannot find 'min4' in scope\n        if current4 < min4 {\n         \
    \             ^~~~\n/tmp/tmppk4enrbt.swift:37:13: error: cannot find 'min4' in\
    \ scope\n            min4 = current4\n            ^~~~\n/tmp/tmppk4enrbt.swift:39:23:\
    \ error: cannot find 'max4' in scope\n        if current4 > max4 {\n         \
    \             ^~~~\n/tmp/tmppk4enrbt.swift:40:13: error: cannot find 'max4' in\
    \ scope\n            max4 = current4\n            ^~~~\n"
  stdout: ''
  timestamp: 1660013731
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double])\
    \ -> (Double, Double) {\n    guard numbers.count > 1 else {\n        return (0.0,0.0)\n\
    \    }\n    guard numbers.count >= 2 else {\n        return (0.0,0.0)\n    }\n\
    \    let smallest = numbers[0]\n    let largest = numbers[0]\n    for i in 1..<numbers.count\
    \ {\n        if numbers[i] > largest {\n            largest = numbers[i]\n   \
    \     }\n        if numbers[i] < smallest {\n            smallest = numbers[i]\n\
    \        }\n    }\n    return (smallest, largest)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9,\
    \ 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpxlibwjxd.swift:19:13: error: cannot assign to value: 'largest'\
    \ is a 'let' constant\n            largest = numbers[i]\n            ^~~~~~~\n\
    /tmp/tmpxlibwjxd.swift:16:5: note: change 'let' to 'var' to make it mutable\n\
    \    let largest = numbers[0]\n    ^~~\n    var\n/tmp/tmpxlibwjxd.swift:22:13:\
    \ error: cannot assign to value: 'smallest' is a 'let' constant\n            smallest\
    \ = numbers[i]\n            ^~~~~~~~\n/tmp/tmpxlibwjxd.swift:15:5: note: change\
    \ 'let' to 'var' to make it mutable\n    let smallest = numbers[0]\n    ^~~\n\
    \    var\n"
  stdout: ''
  timestamp: 1660013731
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double])\
    \ -> (Double, Double) {\n    let smallest = min(numbers)\n    let largest = max(numbers)\n\
    \    return (smallest, largest)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpbwt_n_vu.swift:9:31: error: missing argument for parameter #2 in\
    \ call\n    let smallest = min(numbers)\n                              ^\n   \
    \                           , <#[Double]#>\nSwift.min:1:24: note: 'min' declared\
    \ here\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n\
    \                       ^\n/tmp/tmpbwt_n_vu.swift:10:30: error: missing argument\
    \ for parameter #2 in call\n    let largest = max(numbers)\n                 \
    \            ^\n                             , <#[Double]#>\nSwift.max:1:24: note:\
    \ 'max' declared here\n@inlinable public func max<T>(_ x: T, _ y: T) -> T where\
    \ T : Comparable\n                       ^\n"
  stdout: ''
  timestamp: 1660013731
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double])\
    \ -> (Double, Double) {\n    let smallest = numbers[0]\n    let largest = numbers[0]\n\
    \    for number in numbers {\n        if number < smallest {\n            smallest\
    \ = number\n        }\n        if number > largest {\n            largest = number\n\
    \        }\n    }\n    return (smallest, largest)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9,\
    \ 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmp5pls_p0p.swift:13:13: error: cannot assign to value: 'smallest'\
    \ is a 'let' constant\n            smallest = number\n            ^~~~~~~~\n/tmp/tmp5pls_p0p.swift:9:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let smallest = numbers[0]\n\
    \    ^~~\n    var\n/tmp/tmp5pls_p0p.swift:16:13: error: cannot assign to value:\
    \ 'largest' is a 'let' constant\n            largest = number\n            ^~~~~~~\n\
    /tmp/tmp5pls_p0p.swift:10:5: note: change 'let' to 'var' to make it mutable\n\
    \    let largest = numbers[0]\n    ^~~\n    var\n"
  stdout: ''
  timestamp: 1660013731
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double])\
    \ -> (Double, Double) {\n    let min1 = min(numbers)\n    let max1 = max(numbers)\n\
    \    let min2 = min(min1, max1)\n    let max2 = max(min1, max1)\n    return (min2,\
    \ max2)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmposbee4ho.swift:9:27: error: missing argument for parameter #2 in\
    \ call\n    let min1 = min(numbers)\n                          ^\n           \
    \               , <#[Double]#>\nSwift.min:1:24: note: 'min' declared here\n@inlinable\
    \ public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n             \
    \          ^\n/tmp/tmposbee4ho.swift:10:27: error: missing argument for parameter\
    \ #2 in call\n    let max1 = max(numbers)\n                          ^\n     \
    \                     , <#[Double]#>\nSwift.max:1:24: note: 'max' declared here\n\
    @inlinable public func max<T>(_ x: T, _ y: T) -> T where T : Comparable\n    \
    \                   ^\n"
  stdout: ''
  timestamp: 1660013731
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double])\
    \ -> (Double, Double) {\n    let smallest = numbers[0]\n    let largest = numbers[0]\n\
    \    for number in numbers {\n        if number < smallest {\n            smallest\
    \ = number\n        } else if number > largest {\n            largest = number\n\
    \        }\n    }\n    return (smallest, largest)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9,\
    \ 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpq9xkdvr3.swift:13:13: error: cannot assign to value: 'smallest'\
    \ is a 'let' constant\n            smallest = number\n            ^~~~~~~~\n/tmp/tmpq9xkdvr3.swift:9:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let smallest = numbers[0]\n\
    \    ^~~\n    var\n/tmp/tmpq9xkdvr3.swift:15:13: error: cannot assign to value:\
    \ 'largest' is a 'let' constant\n            largest = number\n            ^~~~~~~\n\
    /tmp/tmpq9xkdvr3.swift:10:5: note: change 'let' to 'var' to make it mutable\n\
    \    let largest = numbers[0]\n    ^~~\n    var\n"
  stdout: ''
  timestamp: 1660013731
- exit_code: -4
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double])\
    \ -> (Double, Double) {\n    if numbers.isEmpty {\n        return (0.0, 0.0)\n\
    \    }\n\n    let sortedNumbers = numbers.sorted()\n    let closestToFirst = sortedNumbers.first!\n\
    \    let closestToSecond = sortedNumbers.last!\n\n    return (closestToFirst,\
    \ closestToSecond)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: Exception
  stderr: 'tmp80amuyvp/tmp80amuyvp.swift:33: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab84d4ecc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab84d1e3b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab84d1e3988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab84d1e27b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp80amuyvp                        0x0000560b66ba074e <unavailable> + 5966

    5    libc.so.6                          0x00002ab84d6d8460 __libc_start_main +
    245

    6    tmp80amuyvp                        0x0000560b66ba0309 <unavailable> + 4873

    '
  stdout: ''
  timestamp: 1660013732
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double])\
    \ -> (Double, Double) {\n    let smallest = numbers[0]\n    let largest = numbers[0]\n\
    \    for number in numbers {\n        if number < smallest {\n            smallest\
    \ = number\n        }\n        if number > largest {\n            largest = number\n\
    \        }\n    }\n    return (smallest, largest)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9,\
    \ 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmp5pls_p0p.swift:13:13: error: cannot assign to value: 'smallest'\
    \ is a 'let' constant\n            smallest = number\n            ^~~~~~~~\n/tmp/tmp5pls_p0p.swift:9:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let smallest = numbers[0]\n\
    \    ^~~\n    var\n/tmp/tmp5pls_p0p.swift:16:13: error: cannot assign to value:\
    \ 'largest' is a 'let' constant\n            largest = number\n            ^~~~~~~\n\
    /tmp/tmp5pls_p0p.swift:10:5: note: change 'let' to 'var' to make it mutable\n\
    \    let largest = numbers[0]\n    ^~~\n    var\n"
  stdout: ''
  timestamp: 1660013731
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double])\
    \ -> (Double, Double) {\n    let min1 = numbers.min()\n    let max1 = numbers.max()\n\
    \    let min2 = numbers.min()\n    let max2 = numbers.max()\n    if min1 == max1\
    \ {\n        return (min1, min2)\n    }\n    if min2 == max2 {\n        return\
    \ (min2, min1)\n    }\n    if min1 < min2 {\n        return (min1, max2)\n   \
    \ }\n    if min2 < min1 {\n        return (min2, max1)\n    }\n    if max1 > max2\
    \ {\n        return (max1, max2)\n    }\n    if max2 > max1 {\n        return\
    \ (max2, max1)\n    }\n    return (min1, max2)\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) ==\
    \ (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0])\
    \ == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1,\
    \ 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpo2d3c2rn.swift:14:16: error: cannot convert return expression of\
    \ type '(Double?, Double?)' to return type '(Double, Double)'\n        return\
    \ (min1, min2)\n               ^\n/tmp/tmpo2d3c2rn.swift:17:16: error: cannot\
    \ convert return expression of type '(Double?, Double?)' to return type '(Double,\
    \ Double)'\n        return (min2, min1)\n               ^\n/tmp/tmpo2d3c2rn.swift:19:13:\
    \ error: binary operator '<' cannot be applied to two 'Double?' operands\n   \
    \ if min1 < min2 {\n       ~~~~ ^ ~~~~\n/tmp/tmpo2d3c2rn.swift:20:16: error: cannot\
    \ convert return expression of type '(Double?, Double?)' to return type '(Double,\
    \ Double)'\n        return (min1, max2)\n               ^\n/tmp/tmpo2d3c2rn.swift:22:13:\
    \ error: binary operator '<' cannot be applied to two 'Double?' operands\n   \
    \ if min2 < min1 {\n       ~~~~ ^ ~~~~\n/tmp/tmpo2d3c2rn.swift:23:16: error: cannot\
    \ convert return expression of type '(Double?, Double?)' to return type '(Double,\
    \ Double)'\n        return (min2, max1)\n               ^\n/tmp/tmpo2d3c2rn.swift:25:13:\
    \ error: binary operator '>' cannot be applied to two 'Double?' operands\n   \
    \ if max1 > max2 {\n       ~~~~ ^ ~~~~\n/tmp/tmpo2d3c2rn.swift:26:16: error: cannot\
    \ convert return expression of type '(Double?, Double?)' to return type '(Double,\
    \ Double)'\n        return (max1, max2)\n               ^\n/tmp/tmpo2d3c2rn.swift:28:13:\
    \ error: binary operator '>' cannot be applied to two 'Double?' operands\n   \
    \ if max2 > max1 {\n       ~~~~ ^ ~~~~\n/tmp/tmpo2d3c2rn.swift:29:16: error: cannot\
    \ convert return expression of type '(Double?, Double?)' to return type '(Double,\
    \ Double)'\n        return (max2, max1)\n               ^\n/tmp/tmpo2d3c2rn.swift:31:12:\
    \ error: cannot convert return expression of type '(Double?, Double?)' to return\
    \ type '(Double, Double)'\n    return (min1, max2)\n           ^\n"
  stdout: ''
  timestamp: 1660013731
- exit_code: -4
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double])\
    \ -> (Double, Double) {\n    if numbers.isEmpty {\n        return (0.0,0.0)\n\
    \    }\n    var smallest = numbers[0]\n    var largest = numbers[0]\n    for number\
    \ in numbers {\n        if number < smallest {\n            smallest = number\n\
    \        }\n        if number > largest {\n            largest = number\n    \
    \    }\n    }\n    return (smallest, largest)\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) ==\
    \ (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0])\
    \ == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1,\
    \ 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: Exception
  stderr: 'tmpwqvpatg1/tmpwqvpatg1.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b92ff079c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b92fed70b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b92fed70988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b92fed6f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpwqvpatg1                        0x000055bbf3bf269e <unavailable> + 5790

    5    libc.so.6                          0x00002b92ff265460 __libc_start_main +
    245

    6    tmpwqvpatg1                        0x000055bbf3bf2259 <unavailable> + 4697

    '
  stdout: ''
  timestamp: 1660013732
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double])\
    \ -> (Double, Double) {\n    guard numbers.count > 1 else {\n        return (0.0,0.0)\n\
    \    }\n    let smallest = numbers[0]\n    let largest = numbers[0]\n    for number\
    \ in numbers {\n        if number < smallest {\n            smallest = number\n\
    \        }\n        if number > largest {\n            largest = number\n    \
    \    }\n    }\n    return (smallest, largest)\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) ==\
    \ (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0])\
    \ == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1,\
    \ 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpbot7rs96.swift:16:13: error: cannot assign to value: 'smallest'\
    \ is a 'let' constant\n            smallest = number\n            ^~~~~~~~\n/tmp/tmpbot7rs96.swift:12:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let smallest = numbers[0]\n\
    \    ^~~\n    var\n/tmp/tmpbot7rs96.swift:19:13: error: cannot assign to value:\
    \ 'largest' is a 'let' constant\n            largest = number\n            ^~~~~~~\n\
    /tmp/tmpbot7rs96.swift:13:5: note: change 'let' to 'var' to make it mutable\n\
    \    let largest = numbers[0]\n    ^~~\n    var\n"
  stdout: ''
  timestamp: 1660013731
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double])\
    \ -> (Double, Double) {\n    let smallest = numbers[0]\n    let largest = numbers[0]\n\
    \    for number in numbers {\n        if number < smallest {\n            smallest\
    \ = number\n        }\n        if number > largest {\n            largest = number\n\
    \        }\n    }\n    return (smallest, largest)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9,\
    \ 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmp5pls_p0p.swift:13:13: error: cannot assign to value: 'smallest'\
    \ is a 'let' constant\n            smallest = number\n            ^~~~~~~~\n/tmp/tmp5pls_p0p.swift:9:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let smallest = numbers[0]\n\
    \    ^~~\n    var\n/tmp/tmp5pls_p0p.swift:16:13: error: cannot assign to value:\
    \ 'largest' is a 'let' constant\n            largest = number\n            ^~~~~~~\n\
    /tmp/tmp5pls_p0p.swift:10:5: note: change 'let' to 'var' to make it mutable\n\
    \    let largest = numbers[0]\n    ^~~\n    var\n"
  stdout: ''
  timestamp: 1660013731
- exit_code: -4
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double])\
    \ -> (Double, Double) {\n    guard numbers.count >= 2 else {\n        return (0.0,0.0)\n\
    \    }\n    guard numbers.count <= 100 else {\n        return (0.0,0.0)\n    }\n\
    \    guard numbers.count >= 10000 else {\n        return (0.0,0.0)\n    }\n  \
    \  \n    var smallest = numbers[0]\n    var largest = numbers[0]\n    var smallestIndex\
    \ = -1\n    var largestIndex = -1\n    \n    for i in 1..<numbers.count {\n  \
    \      if numbers[i] < smallest {\n            smallest = numbers[i]\n       \
    \     smallestIndex = i\n        }\n        if numbers[i] > largest {\n      \
    \      largest = numbers[i]\n            largestIndex = i\n        }\n    }\n\
    \    \n    return (smallest, largest)\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9,\
    \ 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0,\
    \ 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\
    \ == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1,\
    \ 4.1, 5.1]) == (2.2, 3.1))"
  status: Exception
  stderr: 'tmp40crrgjn/tmp40crrgjn.swift:51: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab68b8fac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab68b5f1b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab68b5f1988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab68b5f07b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp40crrgjn                        0x000055a5850026be <unavailable> + 5822

    5    libc.so.6                          0x00002ab68bae6460 __libc_start_main +
    245

    6    tmp40crrgjn                        0x000055a585002279 <unavailable> + 4729

    '
  stdout: ''
  timestamp: 1660013732
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double])\
    \ -> (Double, Double) {\n    guard numbers.count > 1 else {\n        return (0.0,0.0)\n\
    \    }\n    guard numbers.count < 3 else {\n        return (0.0,0.0)\n    }\n\
    \    guard numbers.count > 2 else {\n        return (0.0,0.0)\n    }\n    var\
    \ smallest = numbers[0]\n    var largest = numbers[0]\n    for i in 1..numbers.count\
    \ {\n        if numbers[i] < smallest {\n            smallest = numbers[i]\n \
    \       }\n        if numbers[i] > largest {\n            largest = numbers[i]\n\
    \        }\n    }\n    return (smallest, largest)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9,\
    \ 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmphowesgaf.swift:20:15: error: cannot find operator '..' in scope;\
    \ did you mean '...'?\n    for i in 1..numbers.count {\n              ^~\n   \
    \           ...\n"
  stdout: ''
  timestamp: 1660013731
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double])\
    \ -> (Double, Double) {\n    let min = min(numbers)\n    let max = max(numbers)\n\
    \    return (min, max)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmp6y1l4z39.swift:9:26: error: missing argument for parameter #2 in\
    \ call\n    let min = min(numbers)\n                         ^\n             \
    \            , <#[Double]#>\nSwift.min:1:24: note: 'min' declared here\n@inlinable\
    \ public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n             \
    \          ^\n/tmp/tmp6y1l4z39.swift:10:26: error: missing argument for parameter\
    \ #2 in call\n    let max = max(numbers)\n                         ^\n       \
    \                  , <#[Double]#>\nSwift.max:1:24: note: 'max' declared here\n\
    @inlinable public func max<T>(_ x: T, _ y: T) -> T where T : Comparable\n    \
    \                   ^\n"
  stdout: ''
  timestamp: 1660013731
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double])\
    \ -> (Double, Double) {\n    let min = min(numbers)\n    let max = max(numbers)\n\
    \    if min == max {\n        return (min, min)\n    }\n    if min == numbers[0]\
    \ {\n        return (numbers[0], min)\n    }\n    if max == numbers[numbers.count\
    \ - 1] {\n        return (numbers[numbers.count - 1], max)\n    }\n    if min\
    \ == numbers[numbers.count - 1] {\n        return (numbers[numbers.count - 1],\
    \ max)\n    }\n    if max == numbers[0] {\n        return (min, numbers[0])\n\
    \    }\n    if min == numbers[numbers.count - 2] {\n        return (numbers[numbers.count\
    \ - 2], max)\n    }\n    if max == numbers[numbers.count - 2] {\n        return\
    \ (min, numbers[numbers.count - 2])\n    }\n    if min == numbers[0] {\n     \
    \   return (numbers[0], min)\n    }\n    if max == numbers[numbers.count - 1]\
    \ {\n        return (numbers[numbers.count - 1], max)\n    }\n    if min == numbers[numbers.count\
    \ - 2] {\n        return (numbers[numbers.count - 2], max)\n    }\n    if max\
    \ == numbers[0] {\n        return (min, numbers[0])\n    }\n    if min == numbers[numbers.count\
    \ - 1] {\n        return (numbers[numbers.count - 1], max)\n    }\n    if max\
    \ == numbers[numbers.count - 1] {\n        return (numbers[numbers.count - 1],\
    \ max)\n    }\n    if min == numbers[0] {\n        return (min, min)\n    }\n\
    \    if max == numbers[numbers.count - 1] {\n        return (numbers[numbers.count\
    \ - 1], max)\n    }\n    if min == numbers[numbers.count - 2] {\n        return\
    \ (numbers[numbers.count - 2], max)\n    }\n    if max == numbers[numbers.count\
    \ - 2] {\n        return (min, numbers[numbers.count - 2])\n    }\n    if min\
    \ == numbers[0] {\n        return (numbers[0], min)\n    }\n    if max == numbers[numbers.count\
    \ - 1] {\n        return (numbers[numbers.count - 1], max)\n    }\n    if min\
    \ == numbers[numbers.count - 2] {\n        return (numbers[numbers.count - 2],\
    \ max)\n    }\n    if max == numbers[0] {\n        return (min, numbers[0])\n\
    \    }\n    if min == numbers[numbers.count - 1] {\n        return (numbers[numbers.count\
    \ - 1], max)\n    }\n    if max == numbers[numbers.count - 1] {\n        return\
    \ (numbers[numbers.count - 1], max)\n    }\n    if min == numbers[0] {\n     \
    \   return (min, min)\n    }\n    if max == numbers[numbers.count - 1] {\n   \
    \     return (numbers[numbers.count - 1], max)\n    }\n    if min == numbers[numbers.count\
    \ - 2] {\n        return (numbers[numbers.count - 2], max)\n    }\n    if max\
    \ == number\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpe6r6woza.swift:89:21: error: expected '{' after 'if' condition\n\
    \    if max == number\n                    ^\n/tmp/tmpe6r6woza.swift:9:26: error:\
    \ missing argument for parameter #2 in call\n    let min = min(numbers)\n    \
    \                     ^\n                         , <#[Double]#>\nSwift.min:1:24:\
    \ note: 'min' declared here\n@inlinable public func min<T>(_ x: T, _ y: T) ->\
    \ T where T : Comparable\n                       ^\n/tmp/tmpe6r6woza.swift:10:26:\
    \ error: missing argument for parameter #2 in call\n    let max = max(numbers)\n\
    \                         ^\n                         , <#[Double]#>\nSwift.max:1:24:\
    \ note: 'max' declared here\n@inlinable public func max<T>(_ x: T, _ y: T) ->\
    \ T where T : Comparable\n                       ^\n/tmp/tmpe6r6woza.swift:89:15:\
    \ error: cannot find 'number' in scope\n    if max == number\n              ^~~~~~\n"
  stdout: ''
  timestamp: 1660013732
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double])\
    \ -> (Double, Double) {\n    let min = numbers.min()\n    let max = numbers.max()\n\
    \    if min == max {\n        return (min, min)\n    }\n    let mid = (min + max)\
    \ / 2\n    return (mid, numbers.filter {\n        abs($0 - mid) < abs($0 - min)\n\
    \    }.min())\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpvvishj_b.swift:12:16: error: cannot convert return expression of\
    \ type '(Double?, Double?)' to return type '(Double, Double)'\n        return\
    \ (min, min)\n               ^\n/tmp/tmpvvishj_b.swift:14:20: error: binary operator\
    \ '+' cannot be applied to two 'Double?' operands\n    let mid = (min + max) /\
    \ 2\n               ~~~ ^ ~~~\n/tmp/tmpvvishj_b.swift:14:20: note: overloads for\
    \ '+' exist with these partially matching parameter lists: (Double, Double)\n\
    \    let mid = (min + max) / 2\n                   ^\n/tmp/tmpvvishj_b.swift:15:12:\
    \ error: cannot convert return expression of type '(Double, Double?)' to return\
    \ type '(Double, Double)'\n    return (mid, numbers.filter {\n           ^\n/tmp/tmpvvishj_b.swift:16:34:\
    \ error: value of optional type 'Double?' must be unwrapped to a value of type\
    \ 'Double'\n        abs($0 - mid) < abs($0 - min)\n                          \
    \       ^\n/tmp/tmpvvishj_b.swift:16:34: note: coalesce using '??' to provide\
    \ a default when the optional value contains 'nil'\n        abs($0 - mid) < abs($0\
    \ - min)\n                                 ^\n                               \
    \  (   ?? <#default value#>)\n/tmp/tmpvvishj_b.swift:16:34: note: force-unwrap\
    \ using '!' to abort execution if the optional value contains 'nil'\n        abs($0\
    \ - mid) < abs($0 - min)\n                                 ^\n               \
    \                     !\n"
  stdout: ''
  timestamp: 1660013733
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double])\
    \ -> (Double, Double) {\n    guard numbers.count >= 2 else {\n        return (0.0,0.0)\n\
    \    }\n    guard numbers.count > 1 else {\n        return numbers[0], numbers[0]\n\
    \    }\n    let smallest = numbers[0]\n    let largest = numbers[0]\n    for i\
    \ in 1..<numbers.count {\n        if numbers[i] < smallest {\n            smallest\
    \ = numbers[i]\n        }\n        if numbers[i] > largest {\n            largest\
    \ = numbers[i]\n        }\n    }\n    return (smallest, largest)\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmp9q0swffd.swift:13:26: error: consecutive statements on a line must\
    \ be separated by ';'\n        return numbers[0], numbers[0]\n               \
    \          ^\n                         ;\n/tmp/tmp9q0swffd.swift:13:26: error:\
    \ expected expression\n        return numbers[0], numbers[0]\n               \
    \          ^\n/tmp/tmp9q0swffd.swift:13:23: error: cannot convert return expression\
    \ of type 'Double' to return type '(Double, Double)'\n        return numbers[0],\
    \ numbers[0]\n               ~~~~~~~^~~\n/tmp/tmp9q0swffd.swift:19:13: error:\
    \ cannot assign to value: 'smallest' is a 'let' constant\n            smallest\
    \ = numbers[i]\n            ^~~~~~~~\n/tmp/tmp9q0swffd.swift:15:5: note: change\
    \ 'let' to 'var' to make it mutable\n    let smallest = numbers[0]\n    ^~~\n\
    \    var\n/tmp/tmp9q0swffd.swift:22:13: error: cannot assign to value: 'largest'\
    \ is a 'let' constant\n            largest = numbers[i]\n            ^~~~~~~\n\
    /tmp/tmp9q0swffd.swift:16:5: note: change 'let' to 'var' to make it mutable\n\
    \    let largest = numbers[0]\n    ^~~\n    var\n"
  stdout: ''
  timestamp: 1660013732
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double])\
    \ -> (Double, Double) {\n    let smallest = numbers[0]\n    let largest = numbers[0]\n\
    \    for number in numbers {\n        if number < smallest {\n            smallest\
    \ = number\n        }\n        if number > largest {\n            largest = number\n\
    \        }\n    }\n    return (smallest, largest)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9,\
    \ 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmp5pls_p0p.swift:13:13: error: cannot assign to value: 'smallest'\
    \ is a 'let' constant\n            smallest = number\n            ^~~~~~~~\n/tmp/tmp5pls_p0p.swift:9:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let smallest = numbers[0]\n\
    \    ^~~\n    var\n/tmp/tmp5pls_p0p.swift:16:13: error: cannot assign to value:\
    \ 'largest' is a 'let' constant\n            largest = number\n            ^~~~~~~\n\
    /tmp/tmp5pls_p0p.swift:10:5: note: change 'let' to 'var' to make it mutable\n\
    \    let largest = numbers[0]\n    ^~~\n    var\n"
  stdout: ''
  timestamp: 1660013731
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double])\
    \ -> (Double, Double) {\n    let min = min(numbers)\n    let max = max(numbers)\n\
    \    let closest = (min + max) / 2\n    return (closest, closest)\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmp5kd6r3nh.swift:9:26: error: missing argument for parameter #2 in\
    \ call\n    let min = min(numbers)\n                         ^\n             \
    \            , <#[Double]#>\nSwift.min:1:24: note: 'min' declared here\n@inlinable\
    \ public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n             \
    \          ^\n/tmp/tmp5kd6r3nh.swift:10:26: error: missing argument for parameter\
    \ #2 in call\n    let max = max(numbers)\n                         ^\n       \
    \                  , <#[Double]#>\nSwift.max:1:24: note: 'max' declared here\n\
    @inlinable public func max<T>(_ x: T, _ y: T) -> T where T : Comparable\n    \
    \                   ^\n/tmp/tmp5kd6r3nh.swift:11:24: error: cannot convert value\
    \ of type 'String' to expected argument type 'Int'\n    let closest = (min + max)\
    \ / 2\n                       ^\n"
  stdout: ''
  timestamp: 1660013732
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double])\
    \ -> (Double, Double) {\n    let min1 = min(numbers)\n    let min2 = min(numbers)\n\
    \    if min1 < min2 {\n        return (min1, min2)\n    }\n    return (min2, min1)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpu4vmpe9s.swift:9:27: error: missing argument for parameter #2 in\
    \ call\n    let min1 = min(numbers)\n                          ^\n           \
    \               , <#[Double]#>\nSwift.min:1:24: note: 'min' declared here\n@inlinable\
    \ public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n             \
    \          ^\n/tmp/tmpu4vmpe9s.swift:10:27: error: missing argument for parameter\
    \ #2 in call\n    let min2 = min(numbers)\n                          ^\n     \
    \                     , <#[Double]#>\nSwift.min:1:24: note: 'min' declared here\n\
    @inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n    \
    \                   ^\n"
  stdout: ''
  timestamp: 1660013731
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double])\
    \ -> (Double, Double) {\n    guard numbers.count >= 2 else { return (numbers[0],\
    \ numbers[0]) }\n    var smallest = numbers[0]\n    var largest = numbers[0]\n\
    \    for i in 1..numbers.count {\n        if numbers[i] < smallest {\n       \
    \     smallest = numbers[i]\n        } else if numbers[i] > largest {\n      \
    \      largest = numbers[i]\n        }\n    }\n    return (smallest, largest)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpt6jhoiyu.swift:12:15: error: cannot find operator '..' in scope;\
    \ did you mean '...'?\n    for i in 1..numbers.count {\n              ^~\n   \
    \           ...\n"
  stdout: ''
  timestamp: 1660013732
- exit_code: -4
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double])\
    \ -> (Double, Double) {\n    var smallest = numbers[0]\n    var largest = numbers[0]\n\
    \    for number in numbers {\n        if number < smallest {\n            smallest\
    \ = number\n        }\n        if number > largest {\n            largest = number\n\
    \        }\n    }\n    return (smallest, largest)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9,\
    \ 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: Exception
  stderr: 'tmpuvdtn9la/tmpuvdtn9la.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002abfe48f1c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002abfe45e8b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002abfe45e8988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002abfe45e77b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpuvdtn9la                        0x0000562f96bb064e <unavailable> + 5710

    5    libc.so.6                          0x00002abfe4add460 __libc_start_main +
    245

    6    tmpuvdtn9la                        0x0000562f96bb0209 <unavailable> + 4617

    '
  stdout: ''
  timestamp: 1660013732
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double])\
    \ -> (Double, Double) {\n    guard numbers.count >= 2 else {\n        return (0.0,0.0)\n\
    \    }\n    var smallest = numbers[0]\n    var largest = numbers[0]\n    for i\
    \ in 1..numbers.count {\n        if numbers[i] < smallest {\n            smallest\
    \ = numbers[i]\n        }\n        if numbers[i] > largest {\n            largest\
    \ = numbers[i]\n        }\n    }\n    return (smallest, largest)\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpikpg64cw.swift:14:15: error: cannot find operator '..' in scope;\
    \ did you mean '...'?\n    for i in 1..numbers.count {\n              ^~\n   \
    \           ...\n"
  stdout: ''
  timestamp: 1660013732
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double])\
    \ -> (Double, Double) {\n    let smallest = numbers[0]\n    let largest = numbers[0]\n\
    \    for i in 1..<numbers.count {\n        if numbers[i] < smallest {\n      \
    \      smallest = numbers[i]\n        }\n        if numbers[i] > largest {\n \
    \           largest = numbers[i]\n        }\n    }\n    return (smallest, largest)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpooyhxm2y.swift:13:13: error: cannot assign to value: 'smallest'\
    \ is a 'let' constant\n            smallest = numbers[i]\n            ^~~~~~~~\n\
    /tmp/tmpooyhxm2y.swift:9:5: note: change 'let' to 'var' to make it mutable\n \
    \   let smallest = numbers[0]\n    ^~~\n    var\n/tmp/tmpooyhxm2y.swift:16:13:\
    \ error: cannot assign to value: 'largest' is a 'let' constant\n            largest\
    \ = numbers[i]\n            ^~~~~~~\n/tmp/tmpooyhxm2y.swift:10:5: note: change\
    \ 'let' to 'var' to make it mutable\n    let largest = numbers[0]\n    ^~~\n \
    \   var\n"
  stdout: ''
  timestamp: 1660013732
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double])\
    \ -> (Double, Double) {\n    let sortedNumbers = numbers.sorted()\n    let closestIndex\
    \ = sortedNumbers.firstIndex({ $0 > sortedNumbers.last })\n    return (sortedNumbers[closestIndex],\
    \ sortedNumbers[closestIndex + 1])\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9,\
    \ 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0,\
    \ 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\
    \ == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1,\
    \ 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpmxqrnp00.swift:10:49: error: missing argument label 'where:' in\
    \ call\n    let closestIndex = sortedNumbers.firstIndex({ $0 > sortedNumbers.last\
    \ })\n                                                ^\n                    \
    \                            where: \n/tmp/tmpmxqrnp00.swift:10:70: error: value\
    \ of optional type 'Double?' must be unwrapped to a value of type 'Double'\n \
    \   let closestIndex = sortedNumbers.firstIndex({ $0 > sortedNumbers.last })\n\
    \                                                                     ^\n/tmp/tmpmxqrnp00.swift:10:70:\
    \ note: coalesce using '??' to provide a default when the optional value contains\
    \ 'nil'\n    let closestIndex = sortedNumbers.firstIndex({ $0 > sortedNumbers.last\
    \ })\n                                                                     ^\n\
    \                                                                          ??\
    \ <#default value#>\n/tmp/tmpmxqrnp00.swift:10:70: note: force-unwrap using '!'\
    \ to abort execution if the optional value contains 'nil'\n    let closestIndex\
    \ = sortedNumbers.firstIndex({ $0 > sortedNumbers.last })\n                  \
    \                                                   ^\n                      \
    \                                                   !\n"
  stdout: ''
  timestamp: 1660013732
- exit_code: -4
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double])\
    \ -> (Double, Double) {\n    guard numbers.count > 1 else { return (numbers[0],\
    \ numbers[0]) }\n    guard numbers.count > 2 else { return (numbers[0], numbers[1])\
    \ }\n    var smallest = numbers[0]\n    var largest = numbers[0]\n    for number\
    \ in numbers {\n        if number < smallest {\n            smallest = number\n\
    \        } else if number > largest {\n            largest = number\n        }\n\
    \    }\n    return (smallest, largest)\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9,\
    \ 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0,\
    \ 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\
    \ == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1,\
    \ 4.1, 5.1]) == (2.2, 3.1))"
  status: Exception
  stderr: 'tmpykvvw9_v/tmpykvvw9_v.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b6a337eec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6a334e5b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b6a334e5988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b6a334e47b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpykvvw9_v                        0x000056167ef0369e <unavailable> + 5790

    5    libc.so.6                          0x00002b6a339da460 __libc_start_main +
    245

    6    tmpykvvw9_v                        0x000056167ef03259 <unavailable> + 4697

    '
  stdout: ''
  timestamp: 1660013732
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double])\
    \ -> (Double, Double) {\n    let min1 = min(numbers)\n    let max1 = max(numbers)\n\
    \    let min2 = min(numbers)\n    let max2 = max(numbers)\n    if min1 == max1\
    \ {\n        return (min1, min2)\n    }\n    if min2 == max2 {\n        return\
    \ (min2, min1)\n    }\n    if min1 < min2 {\n        return (min1, max2)\n   \
    \ }\n    if min2 < min1 {\n        return (min2, max1)\n    }\n    return (min1,\
    \ min2)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmptoizdyc3.swift:9:27: error: missing argument for parameter #2 in\
    \ call\n    let min1 = min(numbers)\n                          ^\n           \
    \               , <#[Double]#>\nSwift.min:1:24: note: 'min' declared here\n@inlinable\
    \ public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n             \
    \          ^\n/tmp/tmptoizdyc3.swift:10:27: error: missing argument for parameter\
    \ #2 in call\n    let max1 = max(numbers)\n                          ^\n     \
    \                     , <#[Double]#>\nSwift.max:1:24: note: 'max' declared here\n\
    @inlinable public func max<T>(_ x: T, _ y: T) -> T where T : Comparable\n    \
    \                   ^\n/tmp/tmptoizdyc3.swift:11:27: error: missing argument for\
    \ parameter #2 in call\n    let min2 = min(numbers)\n                        \
    \  ^\n                          , <#[Double]#>\nSwift.min:1:24: note: 'min' declared\
    \ here\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n\
    \                       ^\n/tmp/tmptoizdyc3.swift:12:27: error: missing argument\
    \ for parameter #2 in call\n    let max2 = max(numbers)\n                    \
    \      ^\n                          , <#[Double]#>\nSwift.max:1:24: note: 'max'\
    \ declared here\n@inlinable public func max<T>(_ x: T, _ y: T) -> T where T :\
    \ Comparable\n                       ^\n"
  stdout: ''
  timestamp: 1660013732
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double])\
    \ -> (Double, Double) {\n    guard numbers.count >= 2 else {\n        return (0.0,0.0)\n\
    \    }\n    var smallest = numbers[0]\n    var largest = numbers[0]\n    for i\
    \ in 1..numbers.count {\n        if numbers[i] < smallest {\n            smallest\
    \ = numbers[i]\n        }\n        if numbers[i] > largest {\n            largest\
    \ = numbers[i]\n        }\n    }\n    return (smallest, largest)\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpikpg64cw.swift:14:15: error: cannot find operator '..' in scope;\
    \ did you mean '...'?\n    for i in 1..numbers.count {\n              ^~\n   \
    \           ...\n"
  stdout: ''
  timestamp: 1660013732
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double])\
    \ -> (Double, Double) {\n    let sortedNumbers = numbers.sorted()\n    let closestIndex\
    \ = sortedNumbers.firstIndex({ $0 > sortedNumbers[1] })\n    let closestNumber\
    \ = sortedNumbers[closestIndex]\n    let secondClosestIndex = sortedNumbers.firstIndex({\
    \ $0 > closestNumber })\n    let secondClosestNumber = sortedNumbers[secondClosestIndex]\n\
    \    return (closestNumber, secondClosestNumber)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9,\
    \ 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpipfngft6.swift:10:49: error: missing argument label 'where:' in\
    \ call\n    let closestIndex = sortedNumbers.firstIndex({ $0 > sortedNumbers[1]\
    \ })\n                                                ^\n                    \
    \                            where: \n/tmp/tmpipfngft6.swift:12:55: error: missing\
    \ argument label 'where:' in call\n    let secondClosestIndex = sortedNumbers.firstIndex({\
    \ $0 > closestNumber })\n                                                    \
    \  ^\n                                                      where: \n"
  stdout: ''
  timestamp: 1660013732
- exit_code: -4
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double])\
    \ -> (Double, Double) {\n    if numbers.isEmpty {\n        return (0.0,0.0)\n\
    \    }\n    var smallest = numbers[0]\n    var largest = numbers[0]\n    for number\
    \ in numbers {\n        if number < smallest {\n            smallest = number\n\
    \        }\n        if number > largest {\n            largest = number\n    \
    \    }\n    }\n    return (smallest, largest)\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) ==\
    \ (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0])\
    \ == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1,\
    \ 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: Exception
  stderr: 'tmpwqvpatg1/tmpwqvpatg1.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b92ff079c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b92fed70b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b92fed70988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b92fed6f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpwqvpatg1                        0x000055bbf3bf269e <unavailable> + 5790

    5    libc.so.6                          0x00002b92ff265460 __libc_start_main +
    245

    6    tmpwqvpatg1                        0x000055bbf3bf2259 <unavailable> + 4697

    '
  stdout: ''
  timestamp: 1660013732
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double])\
    \ -> (Double, Double) {\n    if numbers.isEmpty {\n        return (0.5, 0.5)\n\
    \    }\n    let sortedNumbers = numbers.sorted()\n    let closestIndex = sortedNumbers.firstIndex({\
    \ $0 < $1 })\n    let closestValue = sortedNumbers[closestIndex]\n    let closestValueIndex\
    \ = sortedNumbers.firstIndex({ $0 === closestValue })\n    return (closestValue,\
    \ closestValueIndex)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpef71vim6.swift:13:49: error: missing argument label 'where:' in\
    \ call\n    let closestIndex = sortedNumbers.firstIndex({ $0 < $1 })\n       \
    \                                         ^\n                                \
    \                where: \n/tmp/tmpef71vim6.swift:15:54: error: missing argument\
    \ label 'where:' in call\n    let closestValueIndex = sortedNumbers.firstIndex({\
    \ $0 === closestValue })\n                                                   \
    \  ^\n                                                     where: \n/tmp/tmpef71vim6.swift:15:56:\
    \ error: argument type 'Double' expected to be an instance of a class or class-constrained\
    \ type\n    let closestValueIndex = sortedNumbers.firstIndex({ $0 === closestValue\
    \ })\n                                                       ^\n"
  stdout: ''
  timestamp: 1660013732
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double])\
    \ -> (Double, Double) {\n    let smallest = numbers[0]\n    let largest = numbers[0]\n\
    \    for number in numbers {\n        if number < smallest {\n            smallest\
    \ = number\n        }\n        if number > largest {\n            largest = number\n\
    \        }\n    }\n    return (smallest, largest)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9,\
    \ 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmp5pls_p0p.swift:13:13: error: cannot assign to value: 'smallest'\
    \ is a 'let' constant\n            smallest = number\n            ^~~~~~~~\n/tmp/tmp5pls_p0p.swift:9:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let smallest = numbers[0]\n\
    \    ^~~\n    var\n/tmp/tmp5pls_p0p.swift:16:13: error: cannot assign to value:\
    \ 'largest' is a 'let' constant\n            largest = number\n            ^~~~~~~\n\
    /tmp/tmp5pls_p0p.swift:10:5: note: change 'let' to 'var' to make it mutable\n\
    \    let largest = numbers[0]\n    ^~~\n    var\n"
  stdout: ''
  timestamp: 1660013731
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double])\
    \ -> (Double, Double) {\n    let smallest = numbers[0]\n    let largest = numbers[0]\n\
    \    for i in 1..<numbers.count {\n        if numbers[i] < smallest {\n      \
    \      smallest = numbers[i]\n        } else if numbers[i] > largest {\n     \
    \       largest = numbers[i]\n        }\n    }\n    return (smallest, largest)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpsmpywoll.swift:13:13: error: cannot assign to value: 'smallest'\
    \ is a 'let' constant\n            smallest = numbers[i]\n            ^~~~~~~~\n\
    /tmp/tmpsmpywoll.swift:9:5: note: change 'let' to 'var' to make it mutable\n \
    \   let smallest = numbers[0]\n    ^~~\n    var\n/tmp/tmpsmpywoll.swift:15:13:\
    \ error: cannot assign to value: 'largest' is a 'let' constant\n            largest\
    \ = numbers[i]\n            ^~~~~~~\n/tmp/tmpsmpywoll.swift:10:5: note: change\
    \ 'let' to 'var' to make it mutable\n    let largest = numbers[0]\n    ^~~\n \
    \   var\n"
  stdout: ''
  timestamp: 1660013732
- exit_code: -4
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double])\
    \ -> (Double, Double) {\n    var smallest = numbers[0]\n    var largest = numbers[0]\n\
    \    for number in numbers {\n        if number < smallest {\n            smallest\
    \ = number\n        }\n        if number > largest {\n            largest = number\n\
    \        }\n    }\n    return (smallest, largest)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9,\
    \ 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: Exception
  stderr: 'tmpuvdtn9la/tmpuvdtn9la.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002abfe48f1c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002abfe45e8b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002abfe45e8988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002abfe45e77b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpuvdtn9la                        0x0000562f96bb064e <unavailable> + 5710

    5    libc.so.6                          0x00002abfe4add460 __libc_start_main +
    245

    6    tmpuvdtn9la                        0x0000562f96bb0209 <unavailable> + 4617

    '
  stdout: ''
  timestamp: 1660013732
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double])\
    \ -> (Double, Double) {\n    guard numbers.count >= 2 else {\n        return (0.0,0.0)\n\
    \    }\n    guard numbers.count > 1 else {\n        return (0.0,numbers[0])\n\
    \    }\n    let smallest = numbers[0]\n    let largest = numbers[0]\n    for i\
    \ in 1..<numbers.count {\n        if numbers[i] < smallest {\n            smallest\
    \ = numbers[i]\n        }\n        if numbers[i] > largest {\n            largest\
    \ = numbers[i]\n        }\n    }\n    return (smallest, largest)\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpjjnknyjh.swift:19:13: error: cannot assign to value: 'smallest'\
    \ is a 'let' constant\n            smallest = numbers[i]\n            ^~~~~~~~\n\
    /tmp/tmpjjnknyjh.swift:15:5: note: change 'let' to 'var' to make it mutable\n\
    \    let smallest = numbers[0]\n    ^~~\n    var\n/tmp/tmpjjnknyjh.swift:22:13:\
    \ error: cannot assign to value: 'largest' is a 'let' constant\n            largest\
    \ = numbers[i]\n            ^~~~~~~\n/tmp/tmpjjnknyjh.swift:16:5: note: change\
    \ 'let' to 'var' to make it mutable\n    let largest = numbers[0]\n    ^~~\n \
    \   var\n"
  stdout: ''
  timestamp: 1660013732
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double])\
    \ -> (Double, Double) {\n    let smallest = numbers[0]\n    let largest = numbers[0]\n\
    \    for number in numbers {\n        if number < smallest {\n            smallest\
    \ = number\n        }\n        if number > largest {\n            largest = number\n\
    \        }\n    }\n    return (smallest, largest)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9,\
    \ 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmp5pls_p0p.swift:13:13: error: cannot assign to value: 'smallest'\
    \ is a 'let' constant\n            smallest = number\n            ^~~~~~~~\n/tmp/tmp5pls_p0p.swift:9:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let smallest = numbers[0]\n\
    \    ^~~\n    var\n/tmp/tmp5pls_p0p.swift:16:13: error: cannot assign to value:\
    \ 'largest' is a 'let' constant\n            largest = number\n            ^~~~~~~\n\
    /tmp/tmp5pls_p0p.swift:10:5: note: change 'let' to 'var' to make it mutable\n\
    \    let largest = numbers[0]\n    ^~~\n    var\n"
  stdout: ''
  timestamp: 1660013731
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double])\
    \ -> (Double, Double) {\n    guard numbers.count >= 2 else {\n        return (0.0,0.0)\n\
    \    }\n    let smallest = numbers[0]\n    let largest = numbers[0]\n    for i\
    \ in 1..<numbers.count {\n        if numbers[i] < smallest {\n            smallest\
    \ = numbers[i]\n        }\n        if numbers[i] > largest {\n            largest\
    \ = numbers[i]\n        }\n    }\n    return (smallest, largest)\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpittqridb.swift:16:13: error: cannot assign to value: 'smallest'\
    \ is a 'let' constant\n            smallest = numbers[i]\n            ^~~~~~~~\n\
    /tmp/tmpittqridb.swift:12:5: note: change 'let' to 'var' to make it mutable\n\
    \    let smallest = numbers[0]\n    ^~~\n    var\n/tmp/tmpittqridb.swift:19:13:\
    \ error: cannot assign to value: 'largest' is a 'let' constant\n            largest\
    \ = numbers[i]\n            ^~~~~~~\n/tmp/tmpittqridb.swift:13:5: note: change\
    \ 'let' to 'var' to make it mutable\n    let largest = numbers[0]\n    ^~~\n \
    \   var\n"
  stdout: ''
  timestamp: 1660013732
- exit_code: -4
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double])\
    \ -> (Double, Double) {\n    var smallest = numbers[0]\n    var largest = numbers[0]\n\
    \    for number in numbers {\n        if number < smallest {\n            smallest\
    \ = number\n        }\n        if number > largest {\n            largest = number\n\
    \        }\n    }\n    return (smallest, largest)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9,\
    \ 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: Exception
  stderr: 'tmpuvdtn9la/tmpuvdtn9la.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002abfe48f1c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002abfe45e8b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002abfe45e8988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002abfe45e77b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpuvdtn9la                        0x0000562f96bb064e <unavailable> + 5710

    5    libc.so.6                          0x00002abfe4add460 __libc_start_main +
    245

    6    tmpuvdtn9la                        0x0000562f96bb0209 <unavailable> + 4617

    '
  stdout: ''
  timestamp: 1660013732
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double])\
    \ -> (Double, Double) {\n    guard numbers.count >= 2 else {\n        return (0.0,0.0)\n\
    \    }\n    \n    var smallest = numbers[0]\n    var largest = numbers[0]\n  \
    \  \n    for i in 1..numbers.count {\n        if numbers[i] < smallest {\n   \
    \         smallest = numbers[i]\n        }\n        if numbers[i] > largest {\n\
    \            largest = numbers[i]\n        }\n    }\n    \n    return (smallest,\
    \ largest)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpum27rtrx.swift:16:15: error: cannot find operator '..' in scope;\
    \ did you mean '...'?\n    for i in 1..numbers.count {\n              ^~\n   \
    \           ...\n"
  stdout: ''
  timestamp: 1660013732
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double])\
    \ -> (Double, Double) {\n    guard numbers.count >= 2 else {\n        return (0.0,0.0)\n\
    \    }\n    let smallest = numbers[0]\n    let largest = numbers[0]\n    for i\
    \ in 1..numbers.count {\n        let current = numbers[i]\n        if current\
    \ < smallest {\n            smallest = current\n        } else if current > largest\
    \ {\n            largest = current\n        }\n    }\n    return (smallest, largest)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpbvdfi0od.swift:14:15: error: cannot find operator '..' in scope;\
    \ did you mean '...'?\n    for i in 1..numbers.count {\n              ^~\n   \
    \           ...\n"
  stdout: ''
  timestamp: 1660013732
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double])\
    \ -> (Double, Double) {\n    let min1 = numbers.min()\n    let max1 = numbers.max()\n\
    \    let min2 = numbers.min()\n    let max2 = numbers.max()\n    if min1 < min2\
    \ {\n        return (min1, min2)\n    }\n    if max1 > max2 {\n        return\
    \ (max1, max2)\n    }\n    return (min2, max2)\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) ==\
    \ (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0])\
    \ == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1,\
    \ 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmp094dva9u.swift:13:13: error: binary operator '<' cannot be applied\
    \ to two 'Double?' operands\n    if min1 < min2 {\n       ~~~~ ^ ~~~~\n/tmp/tmp094dva9u.swift:14:16:\
    \ error: cannot convert return expression of type '(Double?, Double?)' to return\
    \ type '(Double, Double)'\n        return (min1, min2)\n               ^\n/tmp/tmp094dva9u.swift:16:13:\
    \ error: binary operator '>' cannot be applied to two 'Double?' operands\n   \
    \ if max1 > max2 {\n       ~~~~ ^ ~~~~\n/tmp/tmp094dva9u.swift:17:16: error: cannot\
    \ convert return expression of type '(Double?, Double?)' to return type '(Double,\
    \ Double)'\n        return (max1, max2)\n               ^\n/tmp/tmp094dva9u.swift:19:12:\
    \ error: cannot convert return expression of type '(Double?, Double?)' to return\
    \ type '(Double, Double)'\n    return (min2, max2)\n           ^\n"
  stdout: ''
  timestamp: 1660013732
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double])\
    \ -> (Double, Double) {\n    let min1 = numbers.min()\n    let max1 = numbers.max()\n\
    \    let min2 = numbers.min()\n    let max2 = numbers.max()\n    if min1 < min2\
    \ {\n        return (min1, min2)\n    }\n    if max1 > max2 {\n        return\
    \ (max1, max2)\n    }\n    return (min2, max2)\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) ==\
    \ (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0])\
    \ == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1,\
    \ 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmp094dva9u.swift:13:13: error: binary operator '<' cannot be applied\
    \ to two 'Double?' operands\n    if min1 < min2 {\n       ~~~~ ^ ~~~~\n/tmp/tmp094dva9u.swift:14:16:\
    \ error: cannot convert return expression of type '(Double?, Double?)' to return\
    \ type '(Double, Double)'\n        return (min1, min2)\n               ^\n/tmp/tmp094dva9u.swift:16:13:\
    \ error: binary operator '>' cannot be applied to two 'Double?' operands\n   \
    \ if max1 > max2 {\n       ~~~~ ^ ~~~~\n/tmp/tmp094dva9u.swift:17:16: error: cannot\
    \ convert return expression of type '(Double?, Double?)' to return type '(Double,\
    \ Double)'\n        return (max1, max2)\n               ^\n/tmp/tmp094dva9u.swift:19:12:\
    \ error: cannot convert return expression of type '(Double?, Double?)' to return\
    \ type '(Double, Double)'\n    return (min2, max2)\n           ^\n"
  stdout: ''
  timestamp: 1660013732
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double])\
    \ -> (Double, Double) {\n    let min1 = numbers.min()\n    let max1 = numbers.max()\n\
    \    let min2 = numbers.min()\n    let max2 = numbers.max()\n    if min1 < min2\
    \ {\n        return (min1, min2)\n    }\n    if max1 > max2 {\n        return\
    \ (max1, max2)\n    }\n    return (min1, max1)\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) ==\
    \ (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0])\
    \ == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1,\
    \ 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmp7f0iusr9.swift:13:13: error: binary operator '<' cannot be applied\
    \ to two 'Double?' operands\n    if min1 < min2 {\n       ~~~~ ^ ~~~~\n/tmp/tmp7f0iusr9.swift:14:16:\
    \ error: cannot convert return expression of type '(Double?, Double?)' to return\
    \ type '(Double, Double)'\n        return (min1, min2)\n               ^\n/tmp/tmp7f0iusr9.swift:16:13:\
    \ error: binary operator '>' cannot be applied to two 'Double?' operands\n   \
    \ if max1 > max2 {\n       ~~~~ ^ ~~~~\n/tmp/tmp7f0iusr9.swift:17:16: error: cannot\
    \ convert return expression of type '(Double?, Double?)' to return type '(Double,\
    \ Double)'\n        return (max1, max2)\n               ^\n/tmp/tmp7f0iusr9.swift:19:12:\
    \ error: cannot convert return expression of type '(Double?, Double?)' to return\
    \ type '(Double, Double)'\n    return (min1, max1)\n           ^\n"
  stdout: ''
  timestamp: 1660013732
- exit_code: -4
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double])\
    \ -> (Double, Double) {\n    var smallest = numbers[0]\n    var largest = numbers[0]\n\
    \    for number in numbers {\n        if number < smallest {\n            smallest\
    \ = number\n        }\n        if number > largest {\n            largest = number\n\
    \        }\n    }\n    return (smallest, largest)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9,\
    \ 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: Exception
  stderr: 'tmpuvdtn9la/tmpuvdtn9la.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002abfe48f1c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002abfe45e8b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002abfe45e8988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002abfe45e77b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpuvdtn9la                        0x0000562f96bb064e <unavailable> + 5710

    5    libc.so.6                          0x00002abfe4add460 __libc_start_main +
    245

    6    tmpuvdtn9la                        0x0000562f96bb0209 <unavailable> + 4617

    '
  stdout: ''
  timestamp: 1660013732
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double])\
    \ -> (Double, Double) {\n    if numbers.isEmpty {\n        return (0.0,0.0)\n\
    \    }\n    let minValue = numbers[0]\n    let maxValue = numbers[0]\n    for\
    \ i in 1..<numbers.count {\n        let value = numbers[i]\n        if value <\
    \ minValue {\n            minValue = value\n        } else if value > maxValue\
    \ {\n            maxValue = value\n        }\n    }\n    return (minValue, maxValue)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpasu2cln8.swift:17:13: error: cannot assign to value: 'minValue'\
    \ is a 'let' constant\n            minValue = value\n            ^~~~~~~~\n/tmp/tmpasu2cln8.swift:12:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let minValue = numbers[0]\n\
    \    ^~~\n    var\n/tmp/tmpasu2cln8.swift:19:13: error: cannot assign to value:\
    \ 'maxValue' is a 'let' constant\n            maxValue = value\n            ^~~~~~~~\n\
    /tmp/tmpasu2cln8.swift:13:5: note: change 'let' to 'var' to make it mutable\n\
    \    let maxValue = numbers[0]\n    ^~~\n    var\n"
  stdout: ''
  timestamp: 1660013732
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double])\
    \ -> (Double, Double) {\n    let smallest = numbers[0]\n    let largest = numbers[0]\n\
    \    for number in numbers {\n        if number < smallest {\n            smallest\
    \ = number\n        }\n        if number > largest {\n            largest = number\n\
    \        }\n    }\n    return (smallest, largest)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9,\
    \ 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmp5pls_p0p.swift:13:13: error: cannot assign to value: 'smallest'\
    \ is a 'let' constant\n            smallest = number\n            ^~~~~~~~\n/tmp/tmp5pls_p0p.swift:9:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let smallest = numbers[0]\n\
    \    ^~~\n    var\n/tmp/tmp5pls_p0p.swift:16:13: error: cannot assign to value:\
    \ 'largest' is a 'let' constant\n            largest = number\n            ^~~~~~~\n\
    /tmp/tmp5pls_p0p.swift:10:5: note: change 'let' to 'var' to make it mutable\n\
    \    let largest = numbers[0]\n    ^~~\n    var\n"
  stdout: ''
  timestamp: 1660013731
- exit_code: -4
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double])\
    \ -> (Double, Double) {\n    guard numbers.count >= 2 else { return (numbers[0],\
    \ numbers[0]) }\n    guard numbers.count >= 3 else { return (numbers[0], numbers[0])\
    \ }\n\n    var smallest = numbers[0]\n    var largest = numbers[0]\n    var smallestIndex\
    \ = -1\n    var largestIndex = -1\n\n    for i in 1..<numbers.count {\n      \
    \  if numbers[i] < smallest {\n            smallest = numbers[i]\n           \
    \ smallestIndex = i\n        }\n        if numbers[i] > largest {\n          \
    \  largest = numbers[i]\n            largestIndex = i\n        }\n    }\n\n  \
    \  return (numbers[smallestIndex], numbers[largestIndex])\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9,\
    \ 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002ab738d50c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab738a47561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ab738a47286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ab738a4713c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ab738a46bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002ab738846f44 <unavailable> + 188228

    6    tmpj6pkmvhc                        0x000055c6bb635f7e <unavailable> + 8062

    7    tmpj6pkmvhc                        0x000055c6bb6355cd <unavailable> + 5581

    8    libc.so.6                          0x00002ab738f3c460 __libc_start_main +
    245

    9    tmpj6pkmvhc                        0x000055c6bb635279 <unavailable> + 4729

    '
  stdout: ''
  timestamp: 1660013732
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double])\
    \ -> (Double, Double) {\n    let smallest = min(numbers)\n    let largest = max(numbers)\n\
    \    return (smallest, largest)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpbwt_n_vu.swift:9:31: error: missing argument for parameter #2 in\
    \ call\n    let smallest = min(numbers)\n                              ^\n   \
    \                           , <#[Double]#>\nSwift.min:1:24: note: 'min' declared\
    \ here\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n\
    \                       ^\n/tmp/tmpbwt_n_vu.swift:10:30: error: missing argument\
    \ for parameter #2 in call\n    let largest = max(numbers)\n                 \
    \            ^\n                             , <#[Double]#>\nSwift.max:1:24: note:\
    \ 'max' declared here\n@inlinable public func max<T>(_ x: T, _ y: T) -> T where\
    \ T : Comparable\n                       ^\n"
  stdout: ''
  timestamp: 1660013731
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double])\
    \ -> (Double, Double) {\n    let smallest = numbers[0]\n    let largest = numbers[0]\n\
    \    for number in numbers {\n        if number < smallest {\n            smallest\
    \ = number\n        }\n        if number > largest {\n            largest = number\n\
    \        }\n    }\n    return (smallest, largest)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9,\
    \ 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmp5pls_p0p.swift:13:13: error: cannot assign to value: 'smallest'\
    \ is a 'let' constant\n            smallest = number\n            ^~~~~~~~\n/tmp/tmp5pls_p0p.swift:9:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let smallest = numbers[0]\n\
    \    ^~~\n    var\n/tmp/tmp5pls_p0p.swift:16:13: error: cannot assign to value:\
    \ 'largest' is a 'let' constant\n            largest = number\n            ^~~~~~~\n\
    /tmp/tmp5pls_p0p.swift:10:5: note: change 'let' to 'var' to make it mutable\n\
    \    let largest = numbers[0]\n    ^~~\n    var\n"
  stdout: ''
  timestamp: 1660013731
- exit_code: -4
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double])\
    \ -> (Double, Double) {\n    var smallest = numbers[0]\n    var largest = numbers[0]\n\
    \    for number in numbers {\n        if number < smallest {\n            smallest\
    \ = number\n        } else if number > largest {\n            largest = number\n\
    \        }\n    }\n    return (smallest, largest)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9,\
    \ 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: Exception
  stderr: 'tmp4fjhum4f/tmp4fjhum4f.swift:34: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b57daddcc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b57daad3b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b57daad3988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b57daad27b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp4fjhum4f                        0x000055bfb59df64e <unavailable> + 5710

    5    libc.so.6                          0x00002b57dafc8460 __libc_start_main +
    245

    6    tmp4fjhum4f                        0x000055bfb59df209 <unavailable> + 4617

    '
  stdout: ''
  timestamp: 1660013732
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double])\
    \ -> (Double, Double) {\n    let min = min(numbers)\n    let max = max(numbers)\n\
    \    return (min, max)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmp6y1l4z39.swift:9:26: error: missing argument for parameter #2 in\
    \ call\n    let min = min(numbers)\n                         ^\n             \
    \            , <#[Double]#>\nSwift.min:1:24: note: 'min' declared here\n@inlinable\
    \ public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n             \
    \          ^\n/tmp/tmp6y1l4z39.swift:10:26: error: missing argument for parameter\
    \ #2 in call\n    let max = max(numbers)\n                         ^\n       \
    \                  , <#[Double]#>\nSwift.max:1:24: note: 'max' declared here\n\
    @inlinable public func max<T>(_ x: T, _ y: T) -> T where T : Comparable\n    \
    \                   ^\n"
  stdout: ''
  timestamp: 1660013731
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double])\
    \ -> (Double, Double) {\n    let smallest = min(numbers)\n    let largest = max(numbers)\n\
    \    return (smallest, largest)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpbwt_n_vu.swift:9:31: error: missing argument for parameter #2 in\
    \ call\n    let smallest = min(numbers)\n                              ^\n   \
    \                           , <#[Double]#>\nSwift.min:1:24: note: 'min' declared\
    \ here\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n\
    \                       ^\n/tmp/tmpbwt_n_vu.swift:10:30: error: missing argument\
    \ for parameter #2 in call\n    let largest = max(numbers)\n                 \
    \            ^\n                             , <#[Double]#>\nSwift.max:1:24: note:\
    \ 'max' declared here\n@inlinable public func max<T>(_ x: T, _ y: T) -> T where\
    \ T : Comparable\n                       ^\n"
  stdout: ''
  timestamp: 1660013731
- exit_code: -4
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double])\
    \ -> (Double, Double) {\n    var smallest = numbers[0]\n    var largest = numbers[0]\n\
    \    for number in numbers {\n        if number < smallest {\n            smallest\
    \ = number\n        }\n        if number > largest {\n            largest = number\n\
    \        }\n    }\n    return (smallest, largest)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9,\
    \ 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: Exception
  stderr: 'tmpuvdtn9la/tmpuvdtn9la.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002abfe48f1c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002abfe45e8b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002abfe45e8988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002abfe45e77b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpuvdtn9la                        0x0000562f96bb064e <unavailable> + 5710

    5    libc.so.6                          0x00002abfe4add460 __libc_start_main +
    245

    6    tmpuvdtn9la                        0x0000562f96bb0209 <unavailable> + 4617

    '
  stdout: ''
  timestamp: 1660013732
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double])\
    \ -> (Double, Double) {\n    let min1 = numbers[0]\n    let max1 = numbers[0]\n\
    \    let min2 = numbers[0]\n    let max2 = numbers[0]\n\n    for number in numbers\
    \ {\n        if number < min1 {\n            min1 = number\n        } else if\
    \ number > max1 {\n            max1 = number\n        }\n\n        if number <\
    \ min2 {\n            min2 = number\n        } else if number > max2 {\n     \
    \       max2 = number\n        }\n    }\n\n    return (min1, max1)\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmphhn01bcx.swift:16:13: error: cannot assign to value: 'min1' is\
    \ a 'let' constant\n            min1 = number\n            ^~~~\n/tmp/tmphhn01bcx.swift:9:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let min1 = numbers[0]\n\
    \    ^~~\n    var\n/tmp/tmphhn01bcx.swift:18:13: error: cannot assign to value:\
    \ 'max1' is a 'let' constant\n            max1 = number\n            ^~~~\n/tmp/tmphhn01bcx.swift:10:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let max1 = numbers[0]\n\
    \    ^~~\n    var\n/tmp/tmphhn01bcx.swift:22:13: error: cannot assign to value:\
    \ 'min2' is a 'let' constant\n            min2 = number\n            ^~~~\n/tmp/tmphhn01bcx.swift:11:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let min2 = numbers[0]\n\
    \    ^~~\n    var\n/tmp/tmphhn01bcx.swift:24:13: error: cannot assign to value:\
    \ 'max2' is a 'let' constant\n            max2 = number\n            ^~~~\n/tmp/tmphhn01bcx.swift:12:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let max2 = numbers[0]\n\
    \    ^~~\n    var\n"
  stdout: ''
  timestamp: 1660013732
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double])\
    \ -> (Double, Double) {\n    guard numbers.count >= 2 else {\n        return (0.0,0.0)\n\
    \    }\n    let smallest = numbers[0]\n    let largest = numbers[0]\n    for number\
    \ in numbers {\n        if number < smallest {\n            smallest = number\n\
    \        }\n        if number > largest {\n            largest = number\n    \
    \    }\n    }\n    return (smallest, largest)\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) ==\
    \ (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0])\
    \ == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1,\
    \ 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmp8rcjv646.swift:16:13: error: cannot assign to value: 'smallest'\
    \ is a 'let' constant\n            smallest = number\n            ^~~~~~~~\n/tmp/tmp8rcjv646.swift:12:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let smallest = numbers[0]\n\
    \    ^~~\n    var\n/tmp/tmp8rcjv646.swift:19:13: error: cannot assign to value:\
    \ 'largest' is a 'let' constant\n            largest = number\n            ^~~~~~~\n\
    /tmp/tmp8rcjv646.swift:13:5: note: change 'let' to 'var' to make it mutable\n\
    \    let largest = numbers[0]\n    ^~~\n    var\n"
  stdout: ''
  timestamp: 1660013732
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double])\
    \ -> (Double, Double) {\n    guard numbers.count >= 2 else {\n        return (0.0,0.0)\n\
    \    }\n    let smallest = numbers[0]\n    let largest = numbers[0]\n    for i\
    \ in 1..<numbers.count {\n        if numbers[i] < smallest {\n            smallest\
    \ = numbers[i]\n        }\n        if numbers[i] > largest {\n            largest\
    \ = numbers[i]\n        }\n    }\n    return (smallest, largest)\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpittqridb.swift:16:13: error: cannot assign to value: 'smallest'\
    \ is a 'let' constant\n            smallest = numbers[i]\n            ^~~~~~~~\n\
    /tmp/tmpittqridb.swift:12:5: note: change 'let' to 'var' to make it mutable\n\
    \    let smallest = numbers[0]\n    ^~~\n    var\n/tmp/tmpittqridb.swift:19:13:\
    \ error: cannot assign to value: 'largest' is a 'let' constant\n            largest\
    \ = numbers[i]\n            ^~~~~~~\n/tmp/tmpittqridb.swift:13:5: note: change\
    \ 'let' to 'var' to make it mutable\n    let largest = numbers[0]\n    ^~~\n \
    \   var\n"
  stdout: ''
  timestamp: 1660013732
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double])\
    \ -> (Double, Double) {\n    let smallest = numbers[0]\n    let largest = numbers[0]\n\
    \    for number in numbers {\n        if number < smallest {\n            smallest\
    \ = number\n        }\n        if number > largest {\n            largest = number\n\
    \        }\n    }\n    return (smallest, largest)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9,\
    \ 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmp5pls_p0p.swift:13:13: error: cannot assign to value: 'smallest'\
    \ is a 'let' constant\n            smallest = number\n            ^~~~~~~~\n/tmp/tmp5pls_p0p.swift:9:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let smallest = numbers[0]\n\
    \    ^~~\n    var\n/tmp/tmp5pls_p0p.swift:16:13: error: cannot assign to value:\
    \ 'largest' is a 'let' constant\n            largest = number\n            ^~~~~~~\n\
    /tmp/tmp5pls_p0p.swift:10:5: note: change 'let' to 'var' to make it mutable\n\
    \    let largest = numbers[0]\n    ^~~\n    var\n"
  stdout: ''
  timestamp: 1660013731
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double])\
    \ -> (Double, Double) {\n    let sortedNumbers = numbers.sorted()\n    if sortedNumbers.count\
    \ < 2 {\n        return sortedNumbers[0], sortedNumbers[0]\n    }\n    if sortedNumbers.count\
    \ == 2 {\n        return sortedNumbers[0], sortedNumbers[1]\n    }\n    if sortedNumbers.count\
    \ == 3 {\n        return sortedNumbers[0], sortedNumbers[1]\n    }\n    if sortedNumbers.count\
    \ == 4 {\n        return sortedNumbers[0], sortedNumbers[1]\n    }\n    if sortedNumbers.count\
    \ == 5 {\n        return sortedNumbers[0], sortedNumbers[1]\n    }\n    if sortedNumbers.count\
    \ == 6 {\n        return sortedNumbers[0], sortedNumbers[1]\n    }\n    if sortedNumbers.count\
    \ == 7 {\n        return sortedNumbers[0], sortedNumbers[1]\n    }\n    if sortedNumbers.count\
    \ == 8 {\n        return sortedNumbers[0], sortedNumbers[1]\n    }\n    if sortedNumbers.count\
    \ == 9 {\n        return sortedNumbers[0], sortedNumbers[1]\n    }\n    if sortedNumbers.count\
    \ == 10 {\n        return sortedNumbers[0], sortedNumbers[1]\n    }\n    if sortedNumbers.count\
    \ == 11 {\n        return sortedNumbers[0], sortedNumbers[1]\n    }\n    if sortedNumbers.count\
    \ == 12 {\n        return sortedNumbers[0], sortedNumbers[1]\n    }\n    if sortedNumbers.count\
    \ == 13 {\n        return sortedNumbers[0], sortedNumbers[1]\n    }\n    if sortedNumbers.count\
    \ == 14 {\n        return sortedNumbers[0], sortedNumbers[1]\n    }\n    if sortedNumbers.count\
    \ == 15 {\n        return sortedNumbers[0], sortedNumbers[1]\n    }\n    if sortedNumbers.count\
    \ == 16 {\n        return sortedNumbers[0], sortedNumbers[1]\n    }\n    if sortedNumbers.count\
    \ == 17 {\n        return sortedNumbers[0], sortedNumbers[1]\n    }\n    if sortedNumbers.count\
    \ == 18 {\n        return sortedNumbers[0], sortedNumbers[1]\n    }\n    if sortedNumbers.count\
    \ == 19 {\n        return sortedNumbers[0], sortedNumbers[1]\n    }\n    if sortedNumbers.count\
    \ == 20 {\n        return sortedNumbers[0], sortedNumbers[1]\n    }\n    if sortedNumbers.count\
    \ == 21 {\n        return sortedNumbers[0], sortedNumbers[1]\n    }\n    if sortedNumbers.count\
    \ == 22 {\n        return sortedNumbers[0], sortedNumbers[1]\n    }\n    if sortedNumbers.count\
    \ == 23 {\n        return sortedNumbers[0], sortedNumbers[1]\n    }\n    if sortedNumbers.count\
    \ == 24 {\n        return sortedNumbers[0], sortedNumbers[1]\n    }\n    if sortedNumbers.count\
    \ == 25 {\n        return sortedNumbers[0], sortedNumbers[1]\n    }\n    if sortedNumbers.count\
    \ == 26 {\n        return sortedNumbers[0], sortedNumbers[1]\n    }\n    if sortedNumbers.count\
    \ == 27 {\n        return sortedNumbers[0], sortedNumbers[1]\n    }\n    if sortedNumbers.count\
    \ == 28 {\n        return sortedNumbers[0], sortedNumbers[1]\n    }\n    if sortedNumber\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpmzyceces.swift:11:32: error: consecutive statements on a line must\
    \ be separated by ';'\n        return sortedNumbers[0], sortedNumbers[0]\n   \
    \                            ^\n                               ;\n/tmp/tmpmzyceces.swift:11:32:\
    \ error: expected expression\n        return sortedNumbers[0], sortedNumbers[0]\n\
    \                               ^\n/tmp/tmpmzyceces.swift:14:32: error: consecutive\
    \ statements on a line must be separated by ';'\n        return sortedNumbers[0],\
    \ sortedNumbers[1]\n                               ^\n                       \
    \        ;\n/tmp/tmpmzyceces.swift:14:32: error: expected expression\n       \
    \ return sortedNumbers[0], sortedNumbers[1]\n                               ^\n\
    /tmp/tmpmzyceces.swift:17:32: error: consecutive statements on a line must be\
    \ separated by ';'\n        return sortedNumbers[0], sortedNumbers[1]\n      \
    \                         ^\n                               ;\n/tmp/tmpmzyceces.swift:17:32:\
    \ error: expected expression\n        return sortedNumbers[0], sortedNumbers[1]\n\
    \                               ^\n/tmp/tmpmzyceces.swift:20:32: error: consecutive\
    \ statements on a line must be separated by ';'\n        return sortedNumbers[0],\
    \ sortedNumbers[1]\n                               ^\n                       \
    \        ;\n/tmp/tmpmzyceces.swift:20:32: error: expected expression\n       \
    \ return sortedNumbers[0], sortedNumbers[1]\n                               ^\n\
    /tmp/tmpmzyceces.swift:23:32: error: consecutive statements on a line must be\
    \ separated by ';'\n        return sortedNumbers[0], sortedNumbers[1]\n      \
    \                         ^\n                               ;\n/tmp/tmpmzyceces.swift:23:32:\
    \ error: expected expression\n        return sortedNumbers[0], sortedNumbers[1]\n\
    \                               ^\n/tmp/tmpmzyceces.swift:26:32: error: consecutive\
    \ statements on a line must be separated by ';'\n        return sortedNumbers[0],\
    \ sortedNumbers[1]\n                               ^\n                       \
    \        ;\n/tmp/tmpmzyceces.swift:26:32: error: expected expression\n       \
    \ return sortedNumb"
  stdout: ''
  timestamp: 1660013732
- exit_code: -4
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double])\
    \ -> (Double, Double) {\n    var smallest = numbers[0]\n    var largest = numbers[0]\n\
    \    for number in numbers {\n        if number < smallest {\n            smallest\
    \ = number\n        }\n        if number > largest {\n            largest = number\n\
    \        }\n    }\n    return (smallest, largest)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9,\
    \ 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: Exception
  stderr: 'tmpuvdtn9la/tmpuvdtn9la.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002abfe48f1c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002abfe45e8b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002abfe45e8988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002abfe45e77b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpuvdtn9la                        0x0000562f96bb064e <unavailable> + 5710

    5    libc.so.6                          0x00002abfe4add460 __libc_start_main +
    245

    6    tmpuvdtn9la                        0x0000562f96bb0209 <unavailable> + 4617

    '
  stdout: ''
  timestamp: 1660013732
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double])\
    \ -> (Double, Double) {\n    guard numbers.count >= 2 else {\n        return (0.0,0.0)\n\
    \    }\n    let min1 = numbers[0]\n    let min2 = numbers[1]\n    let max1 = numbers[0]\n\
    \    let max2 = numbers[1]\n    for i in 2..<numbers.count {\n        let current1\
    \ = numbers[i]\n        let current2 = numbers[i - 1]\n        let current3 =\
    \ numbers[i - 2]\n        let current4 = numbers[i - 3]\n        let current5\
    \ = numbers[i - 4]\n        let current6 = numbers[i - 5]\n        let current7\
    \ = numbers[i - 6]\n        let current8 = numbers[i - 7]\n        let current9\
    \ = numbers[i - 8]\n        let current10 = numbers[i - 9]\n        let current11\
    \ = numbers[i - 10]\n        let current12 = numbers[i - 11]\n        let current13\
    \ = numbers[i - 12]\n        let current14 = numbers[i - 13]\n        let current15\
    \ = numbers[i - 14]\n        let current16 = numbers[i - 15]\n        let current17\
    \ = numbers[i - 16]\n        let current18 = numbers[i - 17]\n        let current19\
    \ = numbers[i - 18]\n        let current20 = numbers[i - 19]\n        let current21\
    \ = numbers[i - 20]\n        let current22 = numbers[i - 21]\n        let current23\
    \ = numbers[i - 22]\n        let current24 = numbers[i - 23]\n        let current25\
    \ = numbers[i - 24]\n        let current26 = numbers[i - 25]\n        let current27\
    \ = numbers[i - 26]\n        let current28 = numbers[i - 27]\n        let current29\
    \ = numbers[i - 28]\n        let current30 = numbers[i - 29]\n        let current31\
    \ = numbers[i - 30]\n        let current32 = numbers[i - 31]\n        let current33\
    \ = numbers[i - 32]\n        let current34 = numbers[i - 33]\n        let current35\
    \ = numbers[i - 34]\n        let current36 = numbers[i - 35]\n        let current37\
    \ = numbers[i - 36]\n        let current38 = numbers[i - 37]\n        let current39\
    \ = numbers[i - 38]\n        let current40 = numbers[i - 39]\n        let current41\
    \ = numbers[i - 40]\n        let current42 = numbers[i - 41]\n        let current43\
    \ = numbers[i - 42]\n        let current44 = numbers[i - 43]\n        let current45\
    \ = numbers[i - 44]\n        let current46 = numbers[i - 45]\n        let current47\
    \ = numbers[i - 46]\n        let current48 = numbers[i - 47]\n        let current49\
    \ = numbers[i - 48]\n\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpmkzjyf17.swift:86:80: error: expected '}' at end of brace statement\n\
    assert(find_closest_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))\n\
    \                                                                            \
    \   ^\n/tmp/tmpmkzjyf17.swift:8:67: note: to match this opening '{'\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n                                          \
    \                        ^\n/tmp/tmpmkzjyf17.swift:70:6: error: operator functions\
    \ can only be declared at global or in type scope\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n     ^\n/tmp/tmpmkzjyf17.swift:12:9: warning:\
    \ initialization of immutable value 'min1' was never used; consider replacing\
    \ with assignment to '_' or removing it\n    let min1 = numbers[0]\n    ~~~~^~~~\n\
    \    _\n/tmp/tmpmkzjyf17.swift:13:9: warning: initialization of immutable value\
    \ 'min2' was never used; consider replacing with assignment to '_' or removing\
    \ it\n    let min2 = numbers[1]\n    ~~~~^~~~\n    _\n/tmp/tmpmkzjyf17.swift:14:9:\
    \ warning: initialization of immutable value 'max1' was never used; consider replacing\
    \ with assignment to '_' or removing it\n    let max1 = numbers[0]\n    ~~~~^~~~\n\
    \    _\n/tmp/tmpmkzjyf17.swift:15:9: warning: initialization of immutable value\
    \ 'max2' was never used; consider replacing with assignment to '_' or removing\
    \ it\n    let max2 = numbers[1]\n    ~~~~^~~~\n    _\n/tmp/tmpmkzjyf17.swift:17:13:\
    \ warning: initialization of immutable value 'current1' was never used; consider\
    \ replacing with assignment to '_' or removing it\n        let current1 = numbers[i]\n\
    \        ~~~~^~~~~~~~\n        _\n/tmp/tmpmkzjyf17.swift:18:13: warning: initialization\
    \ of immutable value 'current2' was never used; consider replacing with assignment\
    \ to '_' or removing it\n        let current2 = numbers[i - 1]\n        ~~~~^~~~~~~~\n\
    \        _\n/tmp/tmpmkzjyf17.swift:19:13: warning: initialization of immutable\
    \ value 'current3' was never used; consider replacing with assignment to '_' or\
    \ removing it\n        let current3 = numbers[i - 2]\n        ~~~~^~"
  stdout: ''
  timestamp: 1660013732
- exit_code: -4
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double])\
    \ -> (Double, Double) {\n    var smallest = numbers[0]\n    var largest = numbers[0]\n\
    \    for number in numbers {\n        if number < smallest {\n            smallest\
    \ = number\n        }\n        if number > largest {\n            largest = number\n\
    \        }\n    }\n    return (smallest, largest)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9,\
    \ 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: Exception
  stderr: 'tmpuvdtn9la/tmpuvdtn9la.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002abfe48f1c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002abfe45e8b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002abfe45e8988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002abfe45e77b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpuvdtn9la                        0x0000562f96bb064e <unavailable> + 5710

    5    libc.so.6                          0x00002abfe4add460 __libc_start_main +
    245

    6    tmpuvdtn9la                        0x0000562f96bb0209 <unavailable> + 4617

    '
  stdout: ''
  timestamp: 1660013732
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double])\
    \ -> (Double, Double) {\n    guard numbers.count > 1 else {\n        return (0.0,0.0)\n\
    \    }\n\n    let smallest = numbers[0]\n    let largest = numbers[0]\n    for\
    \ i in 1..<numbers.count {\n        if numbers[i] < smallest {\n            smallest\
    \ = numbers[i]\n        }\n        if numbers[i] > largest {\n            largest\
    \ = numbers[i]\n        }\n    }\n    return (smallest, largest)\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmp2kn6rvb3.swift:17:13: error: cannot assign to value: 'smallest'\
    \ is a 'let' constant\n            smallest = numbers[i]\n            ^~~~~~~~\n\
    /tmp/tmp2kn6rvb3.swift:13:5: note: change 'let' to 'var' to make it mutable\n\
    \    let smallest = numbers[0]\n    ^~~\n    var\n/tmp/tmp2kn6rvb3.swift:20:13:\
    \ error: cannot assign to value: 'largest' is a 'let' constant\n            largest\
    \ = numbers[i]\n            ^~~~~~~\n/tmp/tmp2kn6rvb3.swift:14:5: note: change\
    \ 'let' to 'var' to make it mutable\n    let largest = numbers[0]\n    ^~~\n \
    \   var\n"
  stdout: ''
  timestamp: 1660013732
- exit_code: -4
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double])\
    \ -> (Double, Double) {\n    if numbers.isEmpty {\n        return (0.0,0.0)\n\
    \    }\n    var smallest = numbers[0]\n    var largest = numbers[0]\n    for number\
    \ in numbers {\n        if number < smallest {\n            smallest = number\n\
    \        }\n        if number > largest {\n            largest = number\n    \
    \    }\n    }\n    return (smallest, largest)\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) ==\
    \ (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0])\
    \ == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1,\
    \ 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: Exception
  stderr: 'tmpwqvpatg1/tmpwqvpatg1.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b92ff079c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b92fed70b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b92fed70988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b92fed6f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpwqvpatg1                        0x000055bbf3bf269e <unavailable> + 5790

    5    libc.so.6                          0x00002b92ff265460 __libc_start_main +
    245

    6    tmpwqvpatg1                        0x000055bbf3bf2259 <unavailable> + 4697

    '
  stdout: ''
  timestamp: 1660013732
- exit_code: -4
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double])\
    \ -> (Double, Double) {\n    let sortedNumbers = numbers.sorted()\n    let closest1\
    \ = sortedNumbers.first!\n    let closest2 = sortedNumbers.last!\n    return (closest1,\
    \ closest2)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: Exception
  stderr: 'tmp10nj03s_/tmp10nj03s_.swift:28: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b4cb64f3c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b4cb61eab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b4cb61ea988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b4cb61e97b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp10nj03s_                        0x000055a6c3b5a6fe <unavailable> + 5886

    5    libc.so.6                          0x00002b4cb66df460 __libc_start_main +
    245

    6    tmp10nj03s_                        0x000055a6c3b5a2b9 <unavailable> + 4793

    '
  stdout: ''
  timestamp: 1660013732
- exit_code: -4
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double])\
    \ -> (Double, Double) {\n    guard numbers.count >= 2 else {\n        return (0.0,0.0)\n\
    \    }\n    var smallest = numbers[0]\n    var largest = numbers[0]\n    for number\
    \ in numbers {\n        if number < smallest {\n            smallest = number\n\
    \        }\n        if number > largest {\n            largest = number\n    \
    \    }\n    }\n    return (smallest, largest)\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) ==\
    \ (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0])\
    \ == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1,\
    \ 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: Exception
  stderr: 'tmp1xhx_psi/tmp1xhx_psi.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae13eaa7c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae13e79eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae13e79e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae13e79d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp1xhx_psi                        0x000055d2086d069e <unavailable> + 5790

    5    libc.so.6                          0x00002ae13ec93460 __libc_start_main +
    245

    6    tmp1xhx_psi                        0x000055d2086d0259 <unavailable> + 4697

    '
  stdout: ''
  timestamp: 1660013732
- exit_code: -4
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double])\
    \ -> (Double, Double) {\n    guard numbers.count >= 2 else {\n        return (0.0,0.0)\n\
    \    }\n    let sortedNumbers = numbers.sorted()\n    let firstNumber = sortedNumbers[0]\n\
    \    let secondNumber = sortedNumbers[1]\n    if firstNumber == secondNumber {\n\
    \        return (firstNumber, firstNumber)\n    }\n    if firstNumber > secondNumber\
    \ {\n        return (secondNumber, firstNumber)\n    }\n    return (firstNumber,\
    \ secondNumber)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: Exception
  stderr: 'tmplw5a8hdg/tmplw5a8hdg.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b26e4c26c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b26e491db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b26e491d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b26e491c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmplw5a8hdg                        0x000055deb978c5de <unavailable> + 5598

    5    libc.so.6                          0x00002b26e4e12460 __libc_start_main +
    245

    6    tmplw5a8hdg                        0x000055deb978c199 <unavailable> + 4505

    '
  stdout: ''
  timestamp: 1660013732
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double])\
    \ -> (Double, Double) {\n    if numbers.isEmpty {\n        return (0.0,0.0)\n\
    \    }\n    \n    let min1 = numbers[0]\n    let max1 = numbers[0]\n    \n   \
    \ for n in numbers {\n        if n < min1 {\n            min1 = n\n        } else\
    \ if n > max1 {\n            max1 = n\n        }\n    }\n    \n    return (min1,\
    \ max1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmppbc0atl1.swift:18:13: error: cannot assign to value: 'min1' is\
    \ a 'let' constant\n            min1 = n\n            ^~~~\n/tmp/tmppbc0atl1.swift:13:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let min1 = numbers[0]\n\
    \    ^~~\n    var\n/tmp/tmppbc0atl1.swift:20:13: error: cannot assign to value:\
    \ 'max1' is a 'let' constant\n            max1 = n\n            ^~~~\n/tmp/tmppbc0atl1.swift:14:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let max1 = numbers[0]\n\
    \    ^~~\n    var\n"
  stdout: ''
  timestamp: 1660013732
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double])\
    \ -> (Double, Double) {\n    guard numbers.count >= 2 else {\n        return (0.0,0.0)\n\
    \    }\n    let smallest = numbers[0]\n    let largest = numbers[0]\n    for number\
    \ in numbers {\n        if number < smallest {\n            smallest = number\n\
    \        }\n        if number > largest {\n            largest = number\n    \
    \    }\n    }\n    return (smallest, largest)\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) ==\
    \ (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0])\
    \ == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1,\
    \ 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmp8rcjv646.swift:16:13: error: cannot assign to value: 'smallest'\
    \ is a 'let' constant\n            smallest = number\n            ^~~~~~~~\n/tmp/tmp8rcjv646.swift:12:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let smallest = numbers[0]\n\
    \    ^~~\n    var\n/tmp/tmp8rcjv646.swift:19:13: error: cannot assign to value:\
    \ 'largest' is a 'let' constant\n            largest = number\n            ^~~~~~~\n\
    /tmp/tmp8rcjv646.swift:13:5: note: change 'let' to 'var' to make it mutable\n\
    \    let largest = numbers[0]\n    ^~~\n    var\n"
  stdout: ''
  timestamp: 1660013732
- exit_code: -4
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double])\
    \ -> (Double, Double) {\n    var smallest = numbers[0]\n    var largest = numbers[0]\n\
    \    for number in numbers {\n        if number < smallest {\n            smallest\
    \ = number\n        }\n        if number > largest {\n            largest = number\n\
    \        }\n    }\n    return (smallest, largest)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9,\
    \ 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: Exception
  stderr: 'tmpuvdtn9la/tmpuvdtn9la.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002abfe48f1c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002abfe45e8b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002abfe45e8988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002abfe45e77b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpuvdtn9la                        0x0000562f96bb064e <unavailable> + 5710

    5    libc.so.6                          0x00002abfe4add460 __libc_start_main +
    245

    6    tmpuvdtn9la                        0x0000562f96bb0209 <unavailable> + 4617

    '
  stdout: ''
  timestamp: 1660013732
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double])\
    \ -> (Double, Double) {\n    let min1 = numbers.min()\n    let max1 = numbers.max()\n\
    \    let min2 = numbers.min()\n    let max2 = numbers.max()\n    if min1 == max1\
    \ {\n        return (min1, min2)\n    }\n    if min2 == max2 {\n        return\
    \ (min2, min1)\n    }\n    if min1 < min2 {\n        return (min1, max2)\n   \
    \ }\n    if min2 < min1 {\n        return (min2, max1)\n    }\n    if max1 > max2\
    \ {\n        return (max1, max2)\n    }\n    return (max1, min2)\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpkejl2qp5.swift:14:16: error: cannot convert return expression of\
    \ type '(Double?, Double?)' to return type '(Double, Double)'\n        return\
    \ (min1, min2)\n               ^\n/tmp/tmpkejl2qp5.swift:17:16: error: cannot\
    \ convert return expression of type '(Double?, Double?)' to return type '(Double,\
    \ Double)'\n        return (min2, min1)\n               ^\n/tmp/tmpkejl2qp5.swift:19:13:\
    \ error: binary operator '<' cannot be applied to two 'Double?' operands\n   \
    \ if min1 < min2 {\n       ~~~~ ^ ~~~~\n/tmp/tmpkejl2qp5.swift:20:16: error: cannot\
    \ convert return expression of type '(Double?, Double?)' to return type '(Double,\
    \ Double)'\n        return (min1, max2)\n               ^\n/tmp/tmpkejl2qp5.swift:22:13:\
    \ error: binary operator '<' cannot be applied to two 'Double?' operands\n   \
    \ if min2 < min1 {\n       ~~~~ ^ ~~~~\n/tmp/tmpkejl2qp5.swift:23:16: error: cannot\
    \ convert return expression of type '(Double?, Double?)' to return type '(Double,\
    \ Double)'\n        return (min2, max1)\n               ^\n/tmp/tmpkejl2qp5.swift:25:13:\
    \ error: binary operator '>' cannot be applied to two 'Double?' operands\n   \
    \ if max1 > max2 {\n       ~~~~ ^ ~~~~\n/tmp/tmpkejl2qp5.swift:26:16: error: cannot\
    \ convert return expression of type '(Double?, Double?)' to return type '(Double,\
    \ Double)'\n        return (max1, max2)\n               ^\n/tmp/tmpkejl2qp5.swift:28:12:\
    \ error: cannot convert return expression of type '(Double?, Double?)' to return\
    \ type '(Double, Double)'\n    return (max1, min2)\n           ^\n"
  stdout: ''
  timestamp: 1660013732
- exit_code: -4
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double])\
    \ -> (Double, Double) {\n    var smallest = numbers[0]\n    var largest = numbers[0]\n\
    \    for number in numbers {\n        if number < smallest {\n            smallest\
    \ = number\n        } else if number > largest {\n            largest = number\n\
    \        }\n    }\n    return (smallest, largest)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9,\
    \ 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: Exception
  stderr: 'tmp4fjhum4f/tmp4fjhum4f.swift:34: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b57daddcc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b57daad3b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b57daad3988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b57daad27b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp4fjhum4f                        0x000055bfb59df64e <unavailable> + 5710

    5    libc.so.6                          0x00002b57dafc8460 __libc_start_main +
    245

    6    tmp4fjhum4f                        0x000055bfb59df209 <unavailable> + 4617

    '
  stdout: ''
  timestamp: 1660013732
- exit_code: -4
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double])\
    \ -> (Double, Double) {\n    guard numbers.count >= 2 else {\n        return (0.0,0.0)\n\
    \    }\n    var smallest = numbers[0]\n    var largest = numbers[0]\n    for number\
    \ in numbers {\n        if number < smallest {\n            smallest = number\n\
    \        }\n        if number > largest {\n            largest = number\n    \
    \    }\n    }\n    return (smallest, largest)\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) ==\
    \ (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0])\
    \ == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1,\
    \ 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: Exception
  stderr: 'tmp1xhx_psi/tmp1xhx_psi.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae13eaa7c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae13e79eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae13e79e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae13e79d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp1xhx_psi                        0x000055d2086d069e <unavailable> + 5790

    5    libc.so.6                          0x00002ae13ec93460 __libc_start_main +
    245

    6    tmp1xhx_psi                        0x000055d2086d0259 <unavailable> + 4697

    '
  stdout: ''
  timestamp: 1660013732
- exit_code: -4
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double])\
    \ -> (Double, Double) {\n    guard numbers.count >= 2 else {\n        return (0.0,0.0)\n\
    \    }\n    var smallest = numbers[0]\n    var largest = numbers[0]\n    for number\
    \ in numbers {\n        if number < smallest {\n            smallest = number\n\
    \        }\n        if number > largest {\n            largest = number\n    \
    \    }\n    }\n    return (smallest, largest)\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) ==\
    \ (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0])\
    \ == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1,\
    \ 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: Exception
  stderr: 'tmp1xhx_psi/tmp1xhx_psi.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae13eaa7c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae13e79eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae13e79e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae13e79d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp1xhx_psi                        0x000055d2086d069e <unavailable> + 5790

    5    libc.so.6                          0x00002ae13ec93460 __libc_start_main +
    245

    6    tmp1xhx_psi                        0x000055d2086d0259 <unavailable> + 4697

    '
  stdout: ''
  timestamp: 1660013732
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double])\
    \ -> (Double, Double) {\n    guard numbers.count >= 2 else {\n        return (0.0,0.0)\n\
    \    }\n    \n    var smallest = numbers[0]\n    var largest = numbers[0]\n  \
    \  \n    for i in 1..numbers.count {\n        if numbers[i] < smallest {\n   \
    \         smallest = numbers[i]\n        }\n        if numbers[i] > largest {\n\
    \            largest = numbers[i]\n        }\n    }\n    \n    return (smallest,\
    \ largest)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpum27rtrx.swift:16:15: error: cannot find operator '..' in scope;\
    \ did you mean '...'?\n    for i in 1..numbers.count {\n              ^~\n   \
    \           ...\n"
  stdout: ''
  timestamp: 1660013732
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double])\
    \ -> (Double, Double) {\n    let min1 = numbers[0]\n    let max1 = numbers[0]\n\
    \    let min2 = numbers[0]\n    let max2 = numbers[0]\n\n    for n in numbers\
    \ {\n        if n < min1 {\n            min1 = n\n        } else if n > max1 {\n\
    \            max1 = n\n        }\n\n        if n < min2 {\n            min2 =\
    \ n\n        } else if n > max2 {\n            max2 = n\n        }\n    }\n\n\
    \    return (min1, max1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmp_t068c_e.swift:16:13: error: cannot assign to value: 'min1' is\
    \ a 'let' constant\n            min1 = n\n            ^~~~\n/tmp/tmp_t068c_e.swift:9:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let min1 = numbers[0]\n\
    \    ^~~\n    var\n/tmp/tmp_t068c_e.swift:18:13: error: cannot assign to value:\
    \ 'max1' is a 'let' constant\n            max1 = n\n            ^~~~\n/tmp/tmp_t068c_e.swift:10:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let max1 = numbers[0]\n\
    \    ^~~\n    var\n/tmp/tmp_t068c_e.swift:22:13: error: cannot assign to value:\
    \ 'min2' is a 'let' constant\n            min2 = n\n            ^~~~\n/tmp/tmp_t068c_e.swift:11:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let min2 = numbers[0]\n\
    \    ^~~\n    var\n/tmp/tmp_t068c_e.swift:24:13: error: cannot assign to value:\
    \ 'max2' is a 'let' constant\n            max2 = n\n            ^~~~\n/tmp/tmp_t068c_e.swift:12:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let max2 = numbers[0]\n\
    \    ^~~\n    var\n"
  stdout: ''
  timestamp: 1660013732
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double])\
    \ -> (Double, Double) {\n    let min1 = numbers.min()\n    let max1 = numbers.max()\n\
    \    let min2 = numbers.min()\n    let max2 = numbers.max()\n    if min1 == max1\
    \ {\n        return (min1, min2)\n    }\n    if min2 == max2 {\n        return\
    \ (min2, min1)\n    }\n    if min1 < min2 {\n        return (min1, max2)\n   \
    \ }\n    if min2 < min1 {\n        return (min2, max1)\n    }\n    return (min1,\
    \ min2)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpwdkwqrd0.swift:14:16: error: cannot convert return expression of\
    \ type '(Double?, Double?)' to return type '(Double, Double)'\n        return\
    \ (min1, min2)\n               ^\n/tmp/tmpwdkwqrd0.swift:17:16: error: cannot\
    \ convert return expression of type '(Double?, Double?)' to return type '(Double,\
    \ Double)'\n        return (min2, min1)\n               ^\n/tmp/tmpwdkwqrd0.swift:19:13:\
    \ error: binary operator '<' cannot be applied to two 'Double?' operands\n   \
    \ if min1 < min2 {\n       ~~~~ ^ ~~~~\n/tmp/tmpwdkwqrd0.swift:20:16: error: cannot\
    \ convert return expression of type '(Double?, Double?)' to return type '(Double,\
    \ Double)'\n        return (min1, max2)\n               ^\n/tmp/tmpwdkwqrd0.swift:22:13:\
    \ error: binary operator '<' cannot be applied to two 'Double?' operands\n   \
    \ if min2 < min1 {\n       ~~~~ ^ ~~~~\n/tmp/tmpwdkwqrd0.swift:23:16: error: cannot\
    \ convert return expression of type '(Double?, Double?)' to return type '(Double,\
    \ Double)'\n        return (min2, max1)\n               ^\n/tmp/tmpwdkwqrd0.swift:25:12:\
    \ error: cannot convert return expression of type '(Double?, Double?)' to return\
    \ type '(Double, Double)'\n    return (min1, min2)\n           ^\n"
  stdout: ''
  timestamp: 1660013732
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double])\
    \ -> (Double, Double) {\n    let smallest = numbers[0]\n    let largest = numbers[0]\n\
    \    for i in 1..<numbers.count {\n        if numbers[i] < smallest {\n      \
    \      smallest = numbers[i]\n        }\n        if numbers[i] > largest {\n \
    \           largest = numbers[i]\n        }\n    }\n    return (smallest, largest)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpooyhxm2y.swift:13:13: error: cannot assign to value: 'smallest'\
    \ is a 'let' constant\n            smallest = numbers[i]\n            ^~~~~~~~\n\
    /tmp/tmpooyhxm2y.swift:9:5: note: change 'let' to 'var' to make it mutable\n \
    \   let smallest = numbers[0]\n    ^~~\n    var\n/tmp/tmpooyhxm2y.swift:16:13:\
    \ error: cannot assign to value: 'largest' is a 'let' constant\n            largest\
    \ = numbers[i]\n            ^~~~~~~\n/tmp/tmpooyhxm2y.swift:10:5: note: change\
    \ 'let' to 'var' to make it mutable\n    let largest = numbers[0]\n    ^~~\n \
    \   var\n"
  stdout: ''
  timestamp: 1660013732
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double])\
    \ -> (Double, Double) {\n    if numbers.isEmpty {\n        return (0.0, 0.0)\n\
    \    }\n    if numbers.count < 2 {\n        return (numbers[0], numbers[0])\n\
    \    }\n    let smallest = numbers[0]\n    let largest = numbers[0]\n    for i\
    \ in 1..<numbers.count {\n        if numbers[i] < smallest {\n            smallest\
    \ = numbers[i]\n        }\n        if numbers[i] > largest {\n            largest\
    \ = numbers[i]\n        }\n    }\n    return (smallest, largest)\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpnzrvj1wb.swift:19:13: error: cannot assign to value: 'smallest'\
    \ is a 'let' constant\n            smallest = numbers[i]\n            ^~~~~~~~\n\
    /tmp/tmpnzrvj1wb.swift:15:5: note: change 'let' to 'var' to make it mutable\n\
    \    let smallest = numbers[0]\n    ^~~\n    var\n/tmp/tmpnzrvj1wb.swift:22:13:\
    \ error: cannot assign to value: 'largest' is a 'let' constant\n            largest\
    \ = numbers[i]\n            ^~~~~~~\n/tmp/tmpnzrvj1wb.swift:16:5: note: change\
    \ 'let' to 'var' to make it mutable\n    let largest = numbers[0]\n    ^~~\n \
    \   var\n"
  stdout: ''
  timestamp: 1660013732
- exit_code: -4
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double])\
    \ -> (Double, Double) {\n    guard numbers.count >= 2 else { return (numbers[0],\
    \ numbers[0]) }\n    guard numbers.count >= 3 else { return (numbers[0], numbers[0])\
    \ }\n    guard numbers.count >= 4 else { return (numbers[0], numbers[0]) }\n \
    \   guard numbers.count >= 5 else { return (numbers[0], numbers[0]) }\n    guard\
    \ numbers.count >= 6 else { return (numbers[0], numbers[0]) }\n\n    var smallest\
    \ = numbers[0]\n    var largest = numbers[0]\n    var smallestIndex = -1\n   \
    \ var largestIndex = -1\n\n    for i in 1..<numbers.count {\n        if numbers[i]\
    \ > largest {\n            largest = numbers[i]\n            largestIndex = i\n\
    \        }\n        if numbers[i] < smallest {\n            smallest = numbers[i]\n\
    \            smallestIndex = i\n        }\n    }\n\n    return (smallest, largest)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: Exception
  stderr: 'tmp2ecptt6r/tmp2ecptt6r.swift:47: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002abb27491c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002abb27188b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002abb27188988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002abb271877b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp2ecptt6r                        0x000055e548fac6be <unavailable> + 5822

    5    libc.so.6                          0x00002abb2767d460 __libc_start_main +
    245

    6    tmp2ecptt6r                        0x000055e548fac279 <unavailable> + 4729

    '
  stdout: ''
  timestamp: 1660013732
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double])\
    \ -> (Double, Double) {\n    guard numbers.count > 1 else {\n        return (0.0,0.0)\n\
    \    }\n\n    var smallest = numbers[0]\n    var largest = numbers[0]\n    for\
    \ i in 1..numbers.count {\n        if numbers[i] < smallest {\n            smallest\
    \ = numbers[i]\n        }\n        if numbers[i] > largest {\n            largest\
    \ = numbers[i]\n        }\n    }\n    return (smallest, largest)\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmp6kowz17x.swift:15:15: error: cannot find operator '..' in scope;\
    \ did you mean '...'?\n    for i in 1..numbers.count {\n              ^~\n   \
    \           ...\n"
  stdout: ''
  timestamp: 1660013732
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double])\
    \ -> (Double, Double) {\n    let smallest = numbers[0]\n    let largest = numbers[0]\n\
    \    for i in 1..numbers.count {\n        if numbers[i] < smallest {\n       \
    \     smallest = numbers[i]\n        }\n        if numbers[i] > largest {\n  \
    \          largest = numbers[i]\n        }\n    }\n    return (smallest, largest)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmprbm9q1bq.swift:11:15: error: cannot find operator '..' in scope;\
    \ did you mean '...'?\n    for i in 1..numbers.count {\n              ^~\n   \
    \           ...\n"
  stdout: ''
  timestamp: 1660013732
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double])\
    \ -> (Double, Double) {\n    guard numbers.count >= 2 else {\n        return (0.0,0.0)\n\
    \    }\n    let smallest = numbers[0]\n    let largest = numbers[0]\n    for i\
    \ in 1..<numbers.count {\n        if numbers[i] < smallest {\n            smallest\
    \ = numbers[i]\n        }\n        if numbers[i] > largest {\n            largest\
    \ = numbers[i]\n        }\n    }\n    return (smallest, largest)\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpittqridb.swift:16:13: error: cannot assign to value: 'smallest'\
    \ is a 'let' constant\n            smallest = numbers[i]\n            ^~~~~~~~\n\
    /tmp/tmpittqridb.swift:12:5: note: change 'let' to 'var' to make it mutable\n\
    \    let smallest = numbers[0]\n    ^~~\n    var\n/tmp/tmpittqridb.swift:19:13:\
    \ error: cannot assign to value: 'largest' is a 'let' constant\n            largest\
    \ = numbers[i]\n            ^~~~~~~\n/tmp/tmpittqridb.swift:13:5: note: change\
    \ 'let' to 'var' to make it mutable\n    let largest = numbers[0]\n    ^~~\n \
    \   var\n"
  stdout: ''
  timestamp: 1660013732
- exit_code: -4
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double])\
    \ -> (Double, Double) {\n    if numbers.isEmpty {\n        return (0.0,0.0)\n\
    \    }\n    \n    var smallest = numbers[0]\n    var largest = numbers[0]\n  \
    \  \n    for number in numbers {\n        if number < smallest {\n           \
    \ smallest = number\n        }\n        if number > largest {\n            largest\
    \ = number\n        }\n    }\n    \n    return (smallest, largest)\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: Exception
  stderr: 'tmprxe5lfbx/tmprxe5lfbx.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab388234c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab387f2bb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab387f2b988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab387f2a7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmprxe5lfbx                        0x000055756974d69e <unavailable> + 5790

    5    libc.so.6                          0x00002ab388420460 __libc_start_main +
    245

    6    tmprxe5lfbx                        0x000055756974d259 <unavailable> + 4697

    '
  stdout: ''
  timestamp: 1660013732
- exit_code: -4
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double])\
    \ -> (Double, Double) {\n    guard numbers.count >= 2 else { return (numbers[0],\
    \ numbers[0]) }\n    guard numbers.count >= 3 else { return (numbers[0], numbers[0])\
    \ }\n\n    var smallest = numbers[0]\n    var largest = numbers[0]\n    var smallestIndex\
    \ = -1\n    var largestIndex = -1\n\n    for i in 1..<numbers.count {\n      \
    \  let currentNumber = numbers[i]\n        if currentNumber < smallest {\n   \
    \         smallest = currentNumber\n            smallestIndex = i\n        }\n\
    \        if currentNumber > largest {\n            largest = currentNumber\n \
    \           largestIndex = i\n        }\n    }\n\n    return (numbers[smallestIndex],\
    \ numbers[largestIndex])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b1e15d62c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b1e15a59561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b1e15a59286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b1e15a5913c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b1e15a58bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b1e15858f44 <unavailable> + 188228

    6    tmpwi0uasus                        0x0000562d5dfaaf4c <unavailable> + 8012

    7    tmpwi0uasus                        0x0000562d5dfaa5cd <unavailable> + 5581

    8    libc.so.6                          0x00002b1e15f4e460 __libc_start_main +
    245

    9    tmpwi0uasus                        0x0000562d5dfaa279 <unavailable> + 4729

    '
  stdout: ''
  timestamp: 1660013732
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double])\
    \ -> (Double, Double) {\n    guard numbers.count >= 2 else { return (numbers[0],\
    \ numbers[0]) }\n    guard numbers.count >= 3 else { return (numbers[0], numbers[0])\
    \ }\n\n    let smallest = numbers[0]\n    let largest = numbers[0]\n    for number\
    \ in numbers {\n        if number < smallest {\n            smallest = number\n\
    \        }\n        if number > largest {\n            largest = number\n    \
    \    }\n    }\n    return (smallest, largest)\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) ==\
    \ (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0])\
    \ == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1,\
    \ 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpkapuvhn7.swift:16:13: error: cannot assign to value: 'smallest'\
    \ is a 'let' constant\n            smallest = number\n            ^~~~~~~~\n/tmp/tmpkapuvhn7.swift:12:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let smallest = numbers[0]\n\
    \    ^~~\n    var\n/tmp/tmpkapuvhn7.swift:19:13: error: cannot assign to value:\
    \ 'largest' is a 'let' constant\n            largest = number\n            ^~~~~~~\n\
    /tmp/tmpkapuvhn7.swift:13:5: note: change 'let' to 'var' to make it mutable\n\
    \    let largest = numbers[0]\n    ^~~\n    var\n"
  stdout: ''
  timestamp: 1660013732
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double])\
    \ -> (Double, Double) {\n    let smallest = numbers[0]\n    let largest = numbers[0]\n\
    \    for number in numbers {\n        if number < smallest {\n            smallest\
    \ = number\n        }\n        if number > largest {\n            largest = number\n\
    \        }\n    }\n    return (smallest, largest)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9,\
    \ 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmp5pls_p0p.swift:13:13: error: cannot assign to value: 'smallest'\
    \ is a 'let' constant\n            smallest = number\n            ^~~~~~~~\n/tmp/tmp5pls_p0p.swift:9:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let smallest = numbers[0]\n\
    \    ^~~\n    var\n/tmp/tmp5pls_p0p.swift:16:13: error: cannot assign to value:\
    \ 'largest' is a 'let' constant\n            largest = number\n            ^~~~~~~\n\
    /tmp/tmp5pls_p0p.swift:10:5: note: change 'let' to 'var' to make it mutable\n\
    \    let largest = numbers[0]\n    ^~~\n    var\n"
  stdout: ''
  timestamp: 1660013731
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double])\
    \ -> (Double, Double) {\n    let smallest = numbers[0]\n    let largest = numbers[0]\n\
    \    for number in numbers {\n        if number < smallest {\n            smallest\
    \ = number\n        } else if number > largest {\n            largest = number\n\
    \        }\n    }\n    return (smallest, largest)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9,\
    \ 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpq9xkdvr3.swift:13:13: error: cannot assign to value: 'smallest'\
    \ is a 'let' constant\n            smallest = number\n            ^~~~~~~~\n/tmp/tmpq9xkdvr3.swift:9:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let smallest = numbers[0]\n\
    \    ^~~\n    var\n/tmp/tmpq9xkdvr3.swift:15:13: error: cannot assign to value:\
    \ 'largest' is a 'let' constant\n            largest = number\n            ^~~~~~~\n\
    /tmp/tmpq9xkdvr3.swift:10:5: note: change 'let' to 'var' to make it mutable\n\
    \    let largest = numbers[0]\n    ^~~\n    var\n"
  stdout: ''
  timestamp: 1660013731
- exit_code: -4
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double])\
    \ -> (Double, Double) {\n    let sortedNumbers = numbers.sorted()\n    return\
    \ (sortedNumbers[0], sortedNumbers[1])\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9,\
    \ 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0,\
    \ 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\
    \ == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1,\
    \ 4.1, 5.1]) == (2.2, 3.1))"
  status: Exception
  stderr: 'tmpgo8n6a32/tmpgo8n6a32.swift:26: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002adf90fd7c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002adf90cceb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002adf90cce988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002adf90ccd7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpgo8n6a32                        0x00005615f574957e <unavailable> + 5502

    5    libc.so.6                          0x00002adf911c3460 __libc_start_main +
    245

    6    tmpgo8n6a32                        0x00005615f5749139 <unavailable> + 4409

    '
  stdout: ''
  timestamp: 1660013732
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double])\
    \ -> (Double, Double) {\n    let smallest = numbers[0]\n    let largest = numbers[0]\n\
    \    for i in 1..<numbers.count {\n        if numbers[i] < smallest {\n      \
    \      smallest = numbers[i]\n        }\n        if numbers[i] > largest {\n \
    \           largest = numbers[i]\n        }\n    }\n    return (smallest, largest)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpooyhxm2y.swift:13:13: error: cannot assign to value: 'smallest'\
    \ is a 'let' constant\n            smallest = numbers[i]\n            ^~~~~~~~\n\
    /tmp/tmpooyhxm2y.swift:9:5: note: change 'let' to 'var' to make it mutable\n \
    \   let smallest = numbers[0]\n    ^~~\n    var\n/tmp/tmpooyhxm2y.swift:16:13:\
    \ error: cannot assign to value: 'largest' is a 'let' constant\n            largest\
    \ = numbers[i]\n            ^~~~~~~\n/tmp/tmpooyhxm2y.swift:10:5: note: change\
    \ 'let' to 'var' to make it mutable\n    let largest = numbers[0]\n    ^~~\n \
    \   var\n"
  stdout: ''
  timestamp: 1660013732
- exit_code: -4
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double])\
    \ -> (Double, Double) {\n    var smallest = numbers[0]\n    var largest = numbers[0]\n\
    \    for number in numbers {\n        if number < smallest {\n            smallest\
    \ = number\n        } else if number > largest {\n            largest = number\n\
    \        }\n    }\n    return (smallest, largest)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9,\
    \ 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: Exception
  stderr: 'tmp4fjhum4f/tmp4fjhum4f.swift:34: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b57daddcc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b57daad3b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b57daad3988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b57daad27b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp4fjhum4f                        0x000055bfb59df64e <unavailable> + 5710

    5    libc.so.6                          0x00002b57dafc8460 __libc_start_main +
    245

    6    tmp4fjhum4f                        0x000055bfb59df209 <unavailable> + 4617

    '
  stdout: ''
  timestamp: 1660013732
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double])\
    \ -> (Double, Double) {\n    let smallest = min(numbers)\n    let largest = max(numbers)\n\
    \    return (smallest, largest)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpbwt_n_vu.swift:9:31: error: missing argument for parameter #2 in\
    \ call\n    let smallest = min(numbers)\n                              ^\n   \
    \                           , <#[Double]#>\nSwift.min:1:24: note: 'min' declared\
    \ here\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n\
    \                       ^\n/tmp/tmpbwt_n_vu.swift:10:30: error: missing argument\
    \ for parameter #2 in call\n    let largest = max(numbers)\n                 \
    \            ^\n                             , <#[Double]#>\nSwift.max:1:24: note:\
    \ 'max' declared here\n@inlinable public func max<T>(_ x: T, _ y: T) -> T where\
    \ T : Comparable\n                       ^\n"
  stdout: ''
  timestamp: 1660013731
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double])\
    \ -> (Double, Double) {\n    let min1 = min(numbers)\n    let max1 = max(numbers)\n\
    \    let min2 = min(numbers)\n    let max2 = max(numbers)\n    if min1 < min2\
    \ {\n        return (min1, min2)\n    }\n    if max1 > max2 {\n        return\
    \ (max1, max2)\n    }\n    return (min1, max2)\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) ==\
    \ (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0])\
    \ == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1,\
    \ 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmp9go4x6v_.swift:9:27: error: missing argument for parameter #2 in\
    \ call\n    let min1 = min(numbers)\n                          ^\n           \
    \               , <#[Double]#>\nSwift.min:1:24: note: 'min' declared here\n@inlinable\
    \ public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n             \
    \          ^\n/tmp/tmp9go4x6v_.swift:10:27: error: missing argument for parameter\
    \ #2 in call\n    let max1 = max(numbers)\n                          ^\n     \
    \                     , <#[Double]#>\nSwift.max:1:24: note: 'max' declared here\n\
    @inlinable public func max<T>(_ x: T, _ y: T) -> T where T : Comparable\n    \
    \                   ^\n/tmp/tmp9go4x6v_.swift:11:27: error: missing argument for\
    \ parameter #2 in call\n    let min2 = min(numbers)\n                        \
    \  ^\n                          , <#[Double]#>\nSwift.min:1:24: note: 'min' declared\
    \ here\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n\
    \                       ^\n/tmp/tmp9go4x6v_.swift:12:27: error: missing argument\
    \ for parameter #2 in call\n    let max2 = max(numbers)\n                    \
    \      ^\n                          , <#[Double]#>\nSwift.max:1:24: note: 'max'\
    \ declared here\n@inlinable public func max<T>(_ x: T, _ y: T) -> T where T :\
    \ Comparable\n                       ^\n"
  stdout: ''
  timestamp: 1660013732
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double])\
    \ -> (Double, Double) {\n    let smallest = numbers[0]\n    let largest = numbers[0]\n\
    \    for number in numbers {\n        if number < smallest {\n            smallest\
    \ = number\n        }\n        if number > largest {\n            largest = number\n\
    \        }\n    }\n    return (smallest, largest)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9,\
    \ 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmp5pls_p0p.swift:13:13: error: cannot assign to value: 'smallest'\
    \ is a 'let' constant\n            smallest = number\n            ^~~~~~~~\n/tmp/tmp5pls_p0p.swift:9:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let smallest = numbers[0]\n\
    \    ^~~\n    var\n/tmp/tmp5pls_p0p.swift:16:13: error: cannot assign to value:\
    \ 'largest' is a 'let' constant\n            largest = number\n            ^~~~~~~\n\
    /tmp/tmp5pls_p0p.swift:10:5: note: change 'let' to 'var' to make it mutable\n\
    \    let largest = numbers[0]\n    ^~~\n    var\n"
  stdout: ''
  timestamp: 1660013731
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double])\
    \ -> (Double, Double) {\n    guard numbers.count > 1 else { return (numbers[0],\
    \ numbers[0]) }\n    guard numbers.count > 2 else { return (numbers[0], numbers[1])\
    \ }\n    guard numbers.count > 3 else { return (numbers[0], numbers[2]) }\n  \
    \  guard numbers.count > 4 else { return (numbers[0], numbers[3]) }\n    guard\
    \ numbers.count > 5 else { return (numbers[0], numbers[4]) }\n    guard numbers.count\
    \ > 6 else { return (numbers[0], numbers[5]) }\n    guard numbers.count > 7 else\
    \ { return (numbers[0], numbers[6]) }\n    guard numbers.count > 8 else { return\
    \ (numbers[0], numbers[7]) }\n    guard numbers.count > 9 else { return (numbers[0],\
    \ numbers[8]) }\n    guard numbers.count > 10 else { return (numbers[0], numbers[9])\
    \ }\n    guard numbers.count > 11 else { return (numbers[0], numbers[10]) }\n\
    \    guard numbers.count > 12 else { return (numbers[0], numbers[11]) }\n    guard\
    \ numbers.count > 13 else { return (numbers[0], numbers[12]) }\n    guard numbers.count\
    \ > 14 else { return (numbers[0], numbers[13]) }\n    guard numbers.count > 15\
    \ else { return (numbers[0], numbers[14]) }\n    guard numbers.count > 16 else\
    \ { return (numbers[0], numbers[15]) }\n    guard numbers.count > 17 || numbers.count\
    \ < 2 else { return (numbers[0], numbers[16]) }\n    guard numbers.count > 18\
    \ || numbers.count < 2 else { return (numbers[0], numbers[17]) }\n    guard numbers.count\
    \ > 19 || numbers.count < 2 else { return (numbers[0], numbers[18]) }\n    guard\
    \ numbers.count > 20 || numbers.count < 2 else { return (numbers[0], numbers[19])\
    \ }\n    guard numbers.count > 21 || numbers.count < 2 else { return (numbers[0],\
    \ numbers[20]) }\n    guard numbers.count > 22 || numbers.count < 2 else { return\
    \ (numbers[0], numbers[21]) }\n    guard numbers.count > 23 || numbers.count <\
    \ 2 else { return (numbers[0], numbers[22]) }\n    guard numbers.count > 24 ||\
    \ numbers.count < 2 else { return (numbers[0], numbers[23]) }\n    guard numbers.count\
    \ > 25 || numbers.count < 2 else { return (numbers[0], numbers[24]) }\n    guard\
    \ numbers.count > 26 || numbers.count < 2 else { return (numbers[0], numbers[25])\
    \ }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: '/tmp/tmp2_77rl81.swift:35:1: error: missing return in global function expected
    to return ''(Double, Double)''

    }

    ^

    '
  stdout: ''
  timestamp: 1660013732
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double])\
    \ -> (Double, Double) {\n    let smallest = numbers[0]\n    let largest = numbers[0]\n\
    \    for i in 1..<numbers.count {\n        if numbers[i] > largest {\n       \
    \     largest = numbers[i]\n        } else if numbers[i] < smallest {\n      \
    \      smallest = numbers[i]\n        }\n    }\n    return (smallest, largest)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpgy7p4jtw.swift:13:13: error: cannot assign to value: 'largest'\
    \ is a 'let' constant\n            largest = numbers[i]\n            ^~~~~~~\n\
    /tmp/tmpgy7p4jtw.swift:10:5: note: change 'let' to 'var' to make it mutable\n\
    \    let largest = numbers[0]\n    ^~~\n    var\n/tmp/tmpgy7p4jtw.swift:15:13:\
    \ error: cannot assign to value: 'smallest' is a 'let' constant\n            smallest\
    \ = numbers[i]\n            ^~~~~~~~\n/tmp/tmpgy7p4jtw.swift:9:5: note: change\
    \ 'let' to 'var' to make it mutable\n    let smallest = numbers[0]\n    ^~~\n\
    \    var\n"
  stdout: ''
  timestamp: 1660013732
- exit_code: -4
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double])\
    \ -> (Double, Double) {\n    guard numbers.count >= 2 else {\n        return (0.0,0.0)\n\
    \    }\n    var smallest = numbers[0]\n    var largest = numbers[0]\n    for number\
    \ in numbers {\n        if number < smallest {\n            smallest = number\n\
    \        }\n        if number > largest {\n            largest = number\n    \
    \    }\n    }\n    return (smallest, largest)\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) ==\
    \ (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0])\
    \ == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1,\
    \ 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: Exception
  stderr: 'tmp1xhx_psi/tmp1xhx_psi.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae13eaa7c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae13e79eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae13e79e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae13e79d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp1xhx_psi                        0x000055d2086d069e <unavailable> + 5790

    5    libc.so.6                          0x00002ae13ec93460 __libc_start_main +
    245

    6    tmp1xhx_psi                        0x000055d2086d0259 <unavailable> + 4697

    '
  stdout: ''
  timestamp: 1660013732
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double])\
    \ -> (Double, Double) {\n    let smallest = numbers[0]\n    let largest = numbers[0]\n\
    \    for number in numbers {\n        if number < smallest {\n            smallest\
    \ = number\n        }\n        if number > largest {\n            largest = number\n\
    \        }\n    }\n    return (smallest, largest)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9,\
    \ 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmp5pls_p0p.swift:13:13: error: cannot assign to value: 'smallest'\
    \ is a 'let' constant\n            smallest = number\n            ^~~~~~~~\n/tmp/tmp5pls_p0p.swift:9:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let smallest = numbers[0]\n\
    \    ^~~\n    var\n/tmp/tmp5pls_p0p.swift:16:13: error: cannot assign to value:\
    \ 'largest' is a 'let' constant\n            largest = number\n            ^~~~~~~\n\
    /tmp/tmp5pls_p0p.swift:10:5: note: change 'let' to 'var' to make it mutable\n\
    \    let largest = numbers[0]\n    ^~~\n    var\n"
  stdout: ''
  timestamp: 1660013731
- exit_code: -4
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double])\
    \ -> (Double, Double) {\n    var smallest = numbers[0]\n    var largest = numbers[0]\n\
    \    for number in numbers {\n        if number < smallest {\n            smallest\
    \ = number\n        }\n        if number > largest {\n            largest = number\n\
    \        }\n    }\n    return (smallest, largest)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9,\
    \ 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: Exception
  stderr: 'tmpuvdtn9la/tmpuvdtn9la.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002abfe48f1c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002abfe45e8b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002abfe45e8988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002abfe45e77b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpuvdtn9la                        0x0000562f96bb064e <unavailable> + 5710

    5    libc.so.6                          0x00002abfe4add460 __libc_start_main +
    245

    6    tmpuvdtn9la                        0x0000562f96bb0209 <unavailable> + 4617

    '
  stdout: ''
  timestamp: 1660013732
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double])\
    \ -> (Double, Double) {\n    let smallest = numbers[0]\n    let largest = numbers[0]\n\
    \    for number in numbers {\n        if number < smallest {\n            smallest\
    \ = number\n        }\n        if number > largest {\n            largest = number\n\
    \        }\n    }\n    return (smallest, largest)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9,\
    \ 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmp5pls_p0p.swift:13:13: error: cannot assign to value: 'smallest'\
    \ is a 'let' constant\n            smallest = number\n            ^~~~~~~~\n/tmp/tmp5pls_p0p.swift:9:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let smallest = numbers[0]\n\
    \    ^~~\n    var\n/tmp/tmp5pls_p0p.swift:16:13: error: cannot assign to value:\
    \ 'largest' is a 'let' constant\n            largest = number\n            ^~~~~~~\n\
    /tmp/tmp5pls_p0p.swift:10:5: note: change 'let' to 'var' to make it mutable\n\
    \    let largest = numbers[0]\n    ^~~\n    var\n"
  stdout: ''
  timestamp: 1660013731
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double])\
    \ -> (Double, Double) {\n    let smallest = numbers[0]\n    let largest = numbers[0]\n\
    \    for i in 1..numbers.count {\n        if numbers[i] < smallest {\n       \
    \     smallest = numbers[i]\n        }\n        if numbers[i] > largest {\n  \
    \          largest = numbers[i]\n        }\n    }\n    return (smallest, largest)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmprbm9q1bq.swift:11:15: error: cannot find operator '..' in scope;\
    \ did you mean '...'?\n    for i in 1..numbers.count {\n              ^~\n   \
    \           ...\n"
  stdout: ''
  timestamp: 1660013732
- exit_code: -4
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double])\
    \ -> (Double, Double) {\n    var smallest = numbers[0]\n    var largest = numbers[0]\n\
    \    for number in numbers {\n        if number < smallest {\n            smallest\
    \ = number\n        }\n        if number > largest {\n            largest = number\n\
    \        }\n    }\n    return (smallest, largest)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9,\
    \ 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: Exception
  stderr: 'tmpuvdtn9la/tmpuvdtn9la.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002abfe48f1c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002abfe45e8b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002abfe45e8988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002abfe45e77b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpuvdtn9la                        0x0000562f96bb064e <unavailable> + 5710

    5    libc.so.6                          0x00002abfe4add460 __libc_start_main +
    245

    6    tmpuvdtn9la                        0x0000562f96bb0209 <unavailable> + 4617

    '
  stdout: ''
  timestamp: 1660013732
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double])\
    \ -> (Double, Double) {\n    let smallest = numbers[0]\n    let largest = numbers[0]\n\
    \    for number in numbers {\n        if number < smallest {\n            smallest\
    \ = number\n        }\n        if number > largest {\n            largest = number\n\
    \        }\n    }\n    return (smallest, largest)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9,\
    \ 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmp5pls_p0p.swift:13:13: error: cannot assign to value: 'smallest'\
    \ is a 'let' constant\n            smallest = number\n            ^~~~~~~~\n/tmp/tmp5pls_p0p.swift:9:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let smallest = numbers[0]\n\
    \    ^~~\n    var\n/tmp/tmp5pls_p0p.swift:16:13: error: cannot assign to value:\
    \ 'largest' is a 'let' constant\n            largest = number\n            ^~~~~~~\n\
    /tmp/tmp5pls_p0p.swift:10:5: note: change 'let' to 'var' to make it mutable\n\
    \    let largest = numbers[0]\n    ^~~\n    var\n"
  stdout: ''
  timestamp: 1660013731
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double])\
    \ -> (Double, Double) {\n    let min = numbers[0]\n    let max = numbers[0]\n\
    \    for i in 1..<numbers.count {\n        let current = numbers[i]\n        if\
    \ current < min {\n            min = current\n        } else if current > max\
    \ {\n            max = current\n        }\n    }\n    return (min, max)\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmp75wrf599.swift:14:13: error: cannot assign to value: 'min' is a\
    \ 'let' constant\n            min = current\n            ^~~\n/tmp/tmp75wrf599.swift:9:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let min = numbers[0]\n \
    \   ^~~\n    var\n/tmp/tmp75wrf599.swift:16:13: error: cannot assign to value:\
    \ 'max' is a 'let' constant\n            max = current\n            ^~~\n/tmp/tmp75wrf599.swift:10:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let max = numbers[0]\n \
    \   ^~~\n    var\n"
  stdout: ''
  timestamp: 1660013732
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double])\
    \ -> (Double, Double) {\n    let smallest = numbers[0]\n    let largest = numbers[0]\n\
    \    for i in 1..<numbers.count {\n        if numbers[i] < smallest {\n      \
    \      smallest = numbers[i]\n        } else if numbers[i] > largest {\n     \
    \       largest = numbers[i]\n        }\n    }\n    return (smallest, largest)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpsmpywoll.swift:13:13: error: cannot assign to value: 'smallest'\
    \ is a 'let' constant\n            smallest = numbers[i]\n            ^~~~~~~~\n\
    /tmp/tmpsmpywoll.swift:9:5: note: change 'let' to 'var' to make it mutable\n \
    \   let smallest = numbers[0]\n    ^~~\n    var\n/tmp/tmpsmpywoll.swift:15:13:\
    \ error: cannot assign to value: 'largest' is a 'let' constant\n            largest\
    \ = numbers[i]\n            ^~~~~~~\n/tmp/tmpsmpywoll.swift:10:5: note: change\
    \ 'let' to 'var' to make it mutable\n    let largest = numbers[0]\n    ^~~\n \
    \   var\n"
  stdout: ''
  timestamp: 1660013732
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double])\
    \ -> (Double, Double) {\n    guard numbers.count >= 2 else {\n        return (0.0,0.0)\n\
    \    }\n    let min1 = numbers[0]\n    let max1 = numbers[0]\n    let min2 = numbers[0]\n\
    \    let max2 = numbers[0]\n    for i in 1..<numbers.count {\n        if numbers[i]\
    \ < min1 {\n            min1 = numbers[i]\n        } else if numbers[i] > max1\
    \ {\n            max1 = numbers[i]\n        }\n        if numbers[i] < min2 {\n\
    \            min2 = numbers[i]\n        } else if numbers[i] > max2 {\n      \
    \      max2 = numbers[i]\n        }\n    }\n    return (min1, max1)\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmp4cwv914x.swift:18:13: error: cannot assign to value: 'min1' is\
    \ a 'let' constant\n            min1 = numbers[i]\n            ^~~~\n/tmp/tmp4cwv914x.swift:12:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let min1 = numbers[0]\n\
    \    ^~~\n    var\n/tmp/tmp4cwv914x.swift:20:13: error: cannot assign to value:\
    \ 'max1' is a 'let' constant\n            max1 = numbers[i]\n            ^~~~\n\
    /tmp/tmp4cwv914x.swift:13:5: note: change 'let' to 'var' to make it mutable\n\
    \    let max1 = numbers[0]\n    ^~~\n    var\n/tmp/tmp4cwv914x.swift:23:13: error:\
    \ cannot assign to value: 'min2' is a 'let' constant\n            min2 = numbers[i]\n\
    \            ^~~~\n/tmp/tmp4cwv914x.swift:14:5: note: change 'let' to 'var' to\
    \ make it mutable\n    let min2 = numbers[0]\n    ^~~\n    var\n/tmp/tmp4cwv914x.swift:25:13:\
    \ error: cannot assign to value: 'max2' is a 'let' constant\n            max2\
    \ = numbers[i]\n            ^~~~\n/tmp/tmp4cwv914x.swift:15:5: note: change 'let'\
    \ to 'var' to make it mutable\n    let max2 = numbers[0]\n    ^~~\n    var\n"
  stdout: ''
  timestamp: 1660013732
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double])\
    \ -> (Double, Double) {\n    let sortedNumbers = numbers.sorted()\n    let closestIndex\
    \ = sortedNumbers.firstIndex({ $0 < $1 })\n    return (sortedNumbers[closestIndex],\
    \ sortedNumbers[closestIndex + 1])\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9,\
    \ 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0,\
    \ 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\
    \ == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1,\
    \ 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpj0aa1_ye.swift:10:49: error: missing argument label 'where:' in\
    \ call\n    let closestIndex = sortedNumbers.firstIndex({ $0 < $1 })\n       \
    \                                         ^\n                                \
    \                where: \n"
  stdout: ''
  timestamp: 1660013732
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double])\
    \ -> (Double, Double) {\n    let smallest = numbers[0]\n    let largest = numbers[0]\n\
    \    for number in numbers {\n        if number < smallest {\n            smallest\
    \ = number\n        } else if number > largest {\n            largest = number\n\
    \        }\n    }\n    return (smallest, largest)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9,\
    \ 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpq9xkdvr3.swift:13:13: error: cannot assign to value: 'smallest'\
    \ is a 'let' constant\n            smallest = number\n            ^~~~~~~~\n/tmp/tmpq9xkdvr3.swift:9:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let smallest = numbers[0]\n\
    \    ^~~\n    var\n/tmp/tmpq9xkdvr3.swift:15:13: error: cannot assign to value:\
    \ 'largest' is a 'let' constant\n            largest = number\n            ^~~~~~~\n\
    /tmp/tmpq9xkdvr3.swift:10:5: note: change 'let' to 'var' to make it mutable\n\
    \    let largest = numbers[0]\n    ^~~\n    var\n"
  stdout: ''
  timestamp: 1660013731
- exit_code: -4
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double])\
    \ -> (Double, Double) {\n    if numbers.isEmpty {\n        return (0.0,0.0)\n\
    \    }\n    var smallest = numbers[0]\n    var largest = numbers[0]\n    for number\
    \ in numbers {\n        if number < smallest {\n            smallest = number\n\
    \        }\n        if number > largest {\n            largest = number\n    \
    \    }\n    }\n    return (smallest, largest)\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) ==\
    \ (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0])\
    \ == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1,\
    \ 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: Exception
  stderr: 'tmpwqvpatg1/tmpwqvpatg1.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b92ff079c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b92fed70b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b92fed70988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b92fed6f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpwqvpatg1                        0x000055bbf3bf269e <unavailable> + 5790

    5    libc.so.6                          0x00002b92ff265460 __libc_start_main +
    245

    6    tmpwqvpatg1                        0x000055bbf3bf2259 <unavailable> + 4697

    '
  stdout: ''
  timestamp: 1660013732
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double])\
    \ -> (Double, Double) {\n    let min1 = numbers[0]\n    let min2 = numbers[0]\n\
    \    for i in 1..<numbers.count {\n        if numbers[i] < min1 {\n          \
    \  min1 = numbers[i]\n        }\n        if numbers[i] > min2 {\n            min2\
    \ = numbers[i]\n        }\n    }\n    return min1, min2\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9,\
    \ 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpoa1zs9g6.swift:19:16: error: consecutive statements on a line must\
    \ be separated by ';'\n    return min1, min2\n               ^\n             \
    \  ;\n/tmp/tmpoa1zs9g6.swift:19:16: error: expected expression\n    return min1,\
    \ min2\n               ^\n/tmp/tmpoa1zs9g6.swift:13:13: error: cannot assign to\
    \ value: 'min1' is a 'let' constant\n            min1 = numbers[i]\n         \
    \   ^~~~\n/tmp/tmpoa1zs9g6.swift:9:5: note: change 'let' to 'var' to make it mutable\n\
    \    let min1 = numbers[0]\n    ^~~\n    var\n/tmp/tmpoa1zs9g6.swift:16:13: error:\
    \ cannot assign to value: 'min2' is a 'let' constant\n            min2 = numbers[i]\n\
    \            ^~~~\n/tmp/tmpoa1zs9g6.swift:10:5: note: change 'let' to 'var' to\
    \ make it mutable\n    let min2 = numbers[0]\n    ^~~\n    var\n/tmp/tmpoa1zs9g6.swift:19:12:\
    \ error: cannot convert return expression of type 'Double' to return type '(Double,\
    \ Double)'\n    return min1, min2\n           ^~~~\n"
  stdout: ''
  timestamp: 1660013732
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double])\
    \ -> (Double, Double) {\n    let min = min(numbers)\n    let max = max(numbers)\n\
    \    return (min, max)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmp6y1l4z39.swift:9:26: error: missing argument for parameter #2 in\
    \ call\n    let min = min(numbers)\n                         ^\n             \
    \            , <#[Double]#>\nSwift.min:1:24: note: 'min' declared here\n@inlinable\
    \ public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n             \
    \          ^\n/tmp/tmp6y1l4z39.swift:10:26: error: missing argument for parameter\
    \ #2 in call\n    let max = max(numbers)\n                         ^\n       \
    \                  , <#[Double]#>\nSwift.max:1:24: note: 'max' declared here\n\
    @inlinable public func max<T>(_ x: T, _ y: T) -> T where T : Comparable\n    \
    \                   ^\n"
  stdout: ''
  timestamp: 1660013731
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double])\
    \ -> (Double, Double) {\n    let min1 = numbers.min()\n    let max1 = numbers.max()\n\
    \    let min2 = numbers.min()\n    let max2 = numbers.max()\n    if min1 == min2\
    \ {\n        return (min1, max1)\n    }\n    if max1 == max2 {\n        return\
    \ (min2, max2)\n    }\n    if min1 < min2 {\n        return (min1, max2)\n   \
    \ }\n    return (min2, max1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmp564997gw.swift:14:16: error: cannot convert return expression of\
    \ type '(Double?, Double?)' to return type '(Double, Double)'\n        return\
    \ (min1, max1)\n               ^\n/tmp/tmp564997gw.swift:17:16: error: cannot\
    \ convert return expression of type '(Double?, Double?)' to return type '(Double,\
    \ Double)'\n        return (min2, max2)\n               ^\n/tmp/tmp564997gw.swift:19:13:\
    \ error: binary operator '<' cannot be applied to two 'Double?' operands\n   \
    \ if min1 < min2 {\n       ~~~~ ^ ~~~~\n/tmp/tmp564997gw.swift:20:16: error: cannot\
    \ convert return expression of type '(Double?, Double?)' to return type '(Double,\
    \ Double)'\n        return (min1, max2)\n               ^\n/tmp/tmp564997gw.swift:22:12:\
    \ error: cannot convert return expression of type '(Double?, Double?)' to return\
    \ type '(Double, Double)'\n    return (min2, max1)\n           ^\n"
  stdout: ''
  timestamp: 1660013732
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double])\
    \ -> (Double, Double) {\n    let smallest = numbers[0]\n    let largest = numbers[0]\n\
    \    for number in numbers {\n        if number < smallest {\n            smallest\
    \ = number\n        }\n        if number > largest {\n            largest = number\n\
    \        }\n    }\n    return (smallest, largest)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9,\
    \ 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmp5pls_p0p.swift:13:13: error: cannot assign to value: 'smallest'\
    \ is a 'let' constant\n            smallest = number\n            ^~~~~~~~\n/tmp/tmp5pls_p0p.swift:9:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let smallest = numbers[0]\n\
    \    ^~~\n    var\n/tmp/tmp5pls_p0p.swift:16:13: error: cannot assign to value:\
    \ 'largest' is a 'let' constant\n            largest = number\n            ^~~~~~~\n\
    /tmp/tmp5pls_p0p.swift:10:5: note: change 'let' to 'var' to make it mutable\n\
    \    let largest = numbers[0]\n    ^~~\n    var\n"
  stdout: ''
  timestamp: 1660013731
- exit_code: -4
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double])\
    \ -> (Double, Double) {\n    var smallest = numbers[0]\n    var largest = numbers[0]\n\
    \    for number in numbers {\n        if number < smallest {\n            smallest\
    \ = number\n        }\n        if number > largest {\n            largest = number\n\
    \        }\n    }\n    return (smallest, largest)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9,\
    \ 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: Exception
  stderr: 'tmpuvdtn9la/tmpuvdtn9la.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002abfe48f1c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002abfe45e8b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002abfe45e8988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002abfe45e77b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpuvdtn9la                        0x0000562f96bb064e <unavailable> + 5710

    5    libc.so.6                          0x00002abfe4add460 __libc_start_main +
    245

    6    tmpuvdtn9la                        0x0000562f96bb0209 <unavailable> + 4617

    '
  stdout: ''
  timestamp: 1660013732
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double])\
    \ -> (Double, Double) {\n    guard numbers.count >= 2 else {\n        return (0.0,0.0)\n\
    \    }\n    var smallest = numbers[0]\n    var largest = numbers[0]\n    for i\
    \ in 1..numbers.count {\n        if numbers[i] < smallest {\n            smallest\
    \ = numbers[i]\n        }\n        if numbers[i] > largest {\n            largest\
    \ = numbers[i]\n        }\n    }\n    return (smallest, largest)\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpikpg64cw.swift:14:15: error: cannot find operator '..' in scope;\
    \ did you mean '...'?\n    for i in 1..numbers.count {\n              ^~\n   \
    \           ...\n"
  stdout: ''
  timestamp: 1660013732
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double])\
    \ -> (Double, Double) {\n    let smallest = numbers[0]\n    let largest = numbers[0]\n\
    \    for number in numbers {\n        if number < smallest {\n            smallest\
    \ = number\n        }\n        if number > largest {\n            largest = number\n\
    \        }\n    }\n    return (smallest, largest)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9,\
    \ 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmp5pls_p0p.swift:13:13: error: cannot assign to value: 'smallest'\
    \ is a 'let' constant\n            smallest = number\n            ^~~~~~~~\n/tmp/tmp5pls_p0p.swift:9:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let smallest = numbers[0]\n\
    \    ^~~\n    var\n/tmp/tmp5pls_p0p.swift:16:13: error: cannot assign to value:\
    \ 'largest' is a 'let' constant\n            largest = number\n            ^~~~~~~\n\
    /tmp/tmp5pls_p0p.swift:10:5: note: change 'let' to 'var' to make it mutable\n\
    \    let largest = numbers[0]\n    ^~~\n    var\n"
  stdout: ''
  timestamp: 1660013731
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double])\
    \ -> (Double, Double) {\n    let min1 = numbers.min()\n    let max1 = numbers.max()\n\
    \    let min2 = numbers.min()\n    let max2 = numbers.max()\n    if min1 < min2\
    \ {\n        return (min1, max2)\n    }\n    if max1 > max2 {\n        return\
    \ (max1, min2)\n    }\n    return (min1, max1)\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) ==\
    \ (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0])\
    \ == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1,\
    \ 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpf1vsero9.swift:13:13: error: binary operator '<' cannot be applied\
    \ to two 'Double?' operands\n    if min1 < min2 {\n       ~~~~ ^ ~~~~\n/tmp/tmpf1vsero9.swift:14:16:\
    \ error: cannot convert return expression of type '(Double?, Double?)' to return\
    \ type '(Double, Double)'\n        return (min1, max2)\n               ^\n/tmp/tmpf1vsero9.swift:16:13:\
    \ error: binary operator '>' cannot be applied to two 'Double?' operands\n   \
    \ if max1 > max2 {\n       ~~~~ ^ ~~~~\n/tmp/tmpf1vsero9.swift:17:16: error: cannot\
    \ convert return expression of type '(Double?, Double?)' to return type '(Double,\
    \ Double)'\n        return (max1, min2)\n               ^\n/tmp/tmpf1vsero9.swift:19:12:\
    \ error: cannot convert return expression of type '(Double?, Double?)' to return\
    \ type '(Double, Double)'\n    return (min1, max1)\n           ^\n"
  stdout: ''
  timestamp: 1660013732
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double])\
    \ -> (Double, Double) {\n    let min1 = min(numbers)\n    let max1 = max(numbers)\n\
    \    let min2 = min(numbers)\n    let max2 = max(numbers)\n    if min1 == max1\
    \ {\n        return (min1, min2)\n    }\n    if min2 == max2 {\n        return\
    \ (min2, min1)\n    }\n    if min1 < min2 {\n        return (min1, max2)\n   \
    \ }\n    return (min2, max1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmplx5dh8um.swift:9:27: error: missing argument for parameter #2 in\
    \ call\n    let min1 = min(numbers)\n                          ^\n           \
    \               , <#[Double]#>\nSwift.min:1:24: note: 'min' declared here\n@inlinable\
    \ public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n             \
    \          ^\n/tmp/tmplx5dh8um.swift:10:27: error: missing argument for parameter\
    \ #2 in call\n    let max1 = max(numbers)\n                          ^\n     \
    \                     , <#[Double]#>\nSwift.max:1:24: note: 'max' declared here\n\
    @inlinable public func max<T>(_ x: T, _ y: T) -> T where T : Comparable\n    \
    \                   ^\n/tmp/tmplx5dh8um.swift:11:27: error: missing argument for\
    \ parameter #2 in call\n    let min2 = min(numbers)\n                        \
    \  ^\n                          , <#[Double]#>\nSwift.min:1:24: note: 'min' declared\
    \ here\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n\
    \                       ^\n/tmp/tmplx5dh8um.swift:12:27: error: missing argument\
    \ for parameter #2 in call\n    let max2 = max(numbers)\n                    \
    \      ^\n                          , <#[Double]#>\nSwift.max:1:24: note: 'max'\
    \ declared here\n@inlinable public func max<T>(_ x: T, _ y: T) -> T where T :\
    \ Comparable\n                       ^\n"
  stdout: ''
  timestamp: 1660013732
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double])\
    \ -> (Double, Double) {\n    let smallest = numbers[0]\n    let largest = numbers[0]\n\
    \    for number in numbers {\n        if number < smallest {\n            smallest\
    \ = number\n        }\n        if number > largest {\n            largest = number\n\
    \        }\n    }\n    return (smallest, largest)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9,\
    \ 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmp5pls_p0p.swift:13:13: error: cannot assign to value: 'smallest'\
    \ is a 'let' constant\n            smallest = number\n            ^~~~~~~~\n/tmp/tmp5pls_p0p.swift:9:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let smallest = numbers[0]\n\
    \    ^~~\n    var\n/tmp/tmp5pls_p0p.swift:16:13: error: cannot assign to value:\
    \ 'largest' is a 'let' constant\n            largest = number\n            ^~~~~~~\n\
    /tmp/tmp5pls_p0p.swift:10:5: note: change 'let' to 'var' to make it mutable\n\
    \    let largest = numbers[0]\n    ^~~\n    var\n"
  stdout: ''
  timestamp: 1660013731
- exit_code: -4
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double])\
    \ -> (Double, Double) {\n    var smallest = numbers[0]\n    var largest = numbers[0]\n\
    \    for number in numbers {\n        if number < smallest {\n            smallest\
    \ = number\n        }\n        if number > largest {\n            largest = number\n\
    \        }\n    }\n    return (smallest, largest)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9,\
    \ 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: Exception
  stderr: 'tmpuvdtn9la/tmpuvdtn9la.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002abfe48f1c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002abfe45e8b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002abfe45e8988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002abfe45e77b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpuvdtn9la                        0x0000562f96bb064e <unavailable> + 5710

    5    libc.so.6                          0x00002abfe4add460 __libc_start_main +
    245

    6    tmpuvdtn9la                        0x0000562f96bb0209 <unavailable> + 4617

    '
  stdout: ''
  timestamp: 1660013732
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double])\
    \ -> (Double, Double) {\n    let min1 = min(numbers)\n    let max1 = max(numbers)\n\
    \    let min2 = min(numbers)\n    let max2 = max(numbers)\n    if min1 == min2\
    \ && max1 == max2 {\n        return (min1, max1)\n    }\n    if min1 == min2 {\n\
    \        return (min1, min2)\n    }\n    if max1 == max2 {\n        return (max1,\
    \ max2)\n    }\n    if min1 < min2 {\n        return (min1, max2)\n    }\n   \
    \ return (min2, max1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmp1ub028v6.swift:9:27: error: missing argument for parameter #2 in\
    \ call\n    let min1 = min(numbers)\n                          ^\n           \
    \               , <#[Double]#>\nSwift.min:1:24: note: 'min' declared here\n@inlinable\
    \ public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n             \
    \          ^\n/tmp/tmp1ub028v6.swift:10:27: error: missing argument for parameter\
    \ #2 in call\n    let max1 = max(numbers)\n                          ^\n     \
    \                     , <#[Double]#>\nSwift.max:1:24: note: 'max' declared here\n\
    @inlinable public func max<T>(_ x: T, _ y: T) -> T where T : Comparable\n    \
    \                   ^\n/tmp/tmp1ub028v6.swift:11:27: error: missing argument for\
    \ parameter #2 in call\n    let min2 = min(numbers)\n                        \
    \  ^\n                          , <#[Double]#>\nSwift.min:1:24: note: 'min' declared\
    \ here\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n\
    \                       ^\n/tmp/tmp1ub028v6.swift:12:27: error: missing argument\
    \ for parameter #2 in call\n    let max2 = max(numbers)\n                    \
    \      ^\n                          , <#[Double]#>\nSwift.max:1:24: note: 'max'\
    \ declared here\n@inlinable public func max<T>(_ x: T, _ y: T) -> T where T :\
    \ Comparable\n                       ^\n"
  stdout: ''
  timestamp: 1660013732
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double])\
    \ -> (Double, Double) {\n    guard numbers.count >= 2 else {\n        return (0.0,0.0)\n\
    \    }\n    var smallest = numbers[0]\n    var largest = numbers[0]\n    for i\
    \ in 1..numbers.count {\n        if numbers[i] < smallest {\n            smallest\
    \ = numbers[i]\n        }\n        if numbers[i] > largest {\n            largest\
    \ = numbers[i]\n        }\n    }\n    return (smallest, largest)\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpikpg64cw.swift:14:15: error: cannot find operator '..' in scope;\
    \ did you mean '...'?\n    for i in 1..numbers.count {\n              ^~\n   \
    \           ...\n"
  stdout: ''
  timestamp: 1660013732
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double])\
    \ -> (Double, Double) {\n    guard numbers.count >= 2 else {\n        return (0.0,0.0)\n\
    \    }\n    \n    var smallest = numbers[0]\n    var largest = numbers[0]\n  \
    \  \n    for i in 1..numbers.count {\n        if numbers[i] < smallest {\n   \
    \         smallest = numbers[i]\n        }\n        if numbers[i] > largest {\n\
    \            largest = numbers[i]\n        }\n    }\n    \n    return (smallest,\
    \ largest)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpum27rtrx.swift:16:15: error: cannot find operator '..' in scope;\
    \ did you mean '...'?\n    for i in 1..numbers.count {\n              ^~\n   \
    \           ...\n"
  stdout: ''
  timestamp: 1660013732
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double])\
    \ -> (Double, Double) {\n    let smallest = numbers[0]\n    let largest = numbers[0]\n\
    \    for number in numbers {\n        if number < smallest {\n            smallest\
    \ = number\n        }\n        if number > largest {\n            largest = number\n\
    \        }\n    }\n    return (smallest, largest)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9,\
    \ 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmp5pls_p0p.swift:13:13: error: cannot assign to value: 'smallest'\
    \ is a 'let' constant\n            smallest = number\n            ^~~~~~~~\n/tmp/tmp5pls_p0p.swift:9:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let smallest = numbers[0]\n\
    \    ^~~\n    var\n/tmp/tmp5pls_p0p.swift:16:13: error: cannot assign to value:\
    \ 'largest' is a 'let' constant\n            largest = number\n            ^~~~~~~\n\
    /tmp/tmp5pls_p0p.swift:10:5: note: change 'let' to 'var' to make it mutable\n\
    \    let largest = numbers[0]\n    ^~~\n    var\n"
  stdout: ''
  timestamp: 1660013731
- exit_code: -4
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double])\
    \ -> (Double, Double) {\n    if numbers.isEmpty {\n        return (0.0,0.0)\n\
    \    }\n    var smallest = numbers[0]\n    var largest = numbers[0]\n    for number\
    \ in numbers {\n        if number < smallest {\n            smallest = number\n\
    \        }\n        if number > largest {\n            largest = number\n    \
    \    }\n    }\n    return (smallest, largest)\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) ==\
    \ (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0])\
    \ == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1,\
    \ 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: Exception
  stderr: 'tmpwqvpatg1/tmpwqvpatg1.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b92ff079c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b92fed70b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b92fed70988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b92fed6f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpwqvpatg1                        0x000055bbf3bf269e <unavailable> + 5790

    5    libc.so.6                          0x00002b92ff265460 __libc_start_main +
    245

    6    tmpwqvpatg1                        0x000055bbf3bf2259 <unavailable> + 4697

    '
  stdout: ''
  timestamp: 1660013732
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double])\
    \ -> (Double, Double) {\n    let smallest = min(numbers)\n    let largest = max(numbers)\n\
    \    return (smallest, largest)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpbwt_n_vu.swift:9:31: error: missing argument for parameter #2 in\
    \ call\n    let smallest = min(numbers)\n                              ^\n   \
    \                           , <#[Double]#>\nSwift.min:1:24: note: 'min' declared\
    \ here\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n\
    \                       ^\n/tmp/tmpbwt_n_vu.swift:10:30: error: missing argument\
    \ for parameter #2 in call\n    let largest = max(numbers)\n                 \
    \            ^\n                             , <#[Double]#>\nSwift.max:1:24: note:\
    \ 'max' declared here\n@inlinable public func max<T>(_ x: T, _ y: T) -> T where\
    \ T : Comparable\n                       ^\n"
  stdout: ''
  timestamp: 1660013731
- exit_code: -4
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double])\
    \ -> (Double, Double) {\n    if numbers.isEmpty {\n        return (0, 0)\n   \
    \ }\n    if numbers.count < 2 {\n        return (0, 0)\n    }\n    var smallest\
    \ = numbers[0]\n    var largest = numbers[0]\n    for number in numbers {\n  \
    \      if number < smallest {\n            smallest = number\n        }\n    \
    \    if number > largest {\n            largest = number\n        }\n    }\n \
    \   return (smallest, largest)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: Exception
  stderr: 'tmpwenzt34l/tmpwenzt34l.swift:41: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002afb4ae3ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002afb4ab31b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002afb4ab31988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002afb4ab307b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpwenzt34l                        0x00005600258ae6fe <unavailable> + 5886

    5    libc.so.6                          0x00002afb4b026460 __libc_start_main +
    245

    6    tmpwenzt34l                        0x00005600258ae2b9 <unavailable> + 4793

    '
  stdout: ''
  timestamp: 1660013733
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double])\
    \ -> (Double, Double) {\n    let smallest = numbers[0]\n    let largest = numbers[0]\n\
    \    for i in 1..<numbers.count {\n        if numbers[i] < smallest {\n      \
    \      smallest = numbers[i]\n        }\n        if numbers[i] > largest {\n \
    \           largest = numbers[i]\n        }\n    }\n    return (smallest, largest)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpooyhxm2y.swift:13:13: error: cannot assign to value: 'smallest'\
    \ is a 'let' constant\n            smallest = numbers[i]\n            ^~~~~~~~\n\
    /tmp/tmpooyhxm2y.swift:9:5: note: change 'let' to 'var' to make it mutable\n \
    \   let smallest = numbers[0]\n    ^~~\n    var\n/tmp/tmpooyhxm2y.swift:16:13:\
    \ error: cannot assign to value: 'largest' is a 'let' constant\n            largest\
    \ = numbers[i]\n            ^~~~~~~\n/tmp/tmpooyhxm2y.swift:10:5: note: change\
    \ 'let' to 'var' to make it mutable\n    let largest = numbers[0]\n    ^~~\n \
    \   var\n"
  stdout: ''
  timestamp: 1660013732
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double])\
    \ -> (Double, Double) {\n    let smallest = numbers[0]\n    let largest = numbers[0]\n\
    \    for number in numbers {\n        if number < smallest {\n            smallest\
    \ = number\n        }\n        if number > largest {\n            largest = number\n\
    \        }\n    }\n    return (smallest, largest)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9,\
    \ 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmp5pls_p0p.swift:13:13: error: cannot assign to value: 'smallest'\
    \ is a 'let' constant\n            smallest = number\n            ^~~~~~~~\n/tmp/tmp5pls_p0p.swift:9:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let smallest = numbers[0]\n\
    \    ^~~\n    var\n/tmp/tmp5pls_p0p.swift:16:13: error: cannot assign to value:\
    \ 'largest' is a 'let' constant\n            largest = number\n            ^~~~~~~\n\
    /tmp/tmp5pls_p0p.swift:10:5: note: change 'let' to 'var' to make it mutable\n\
    \    let largest = numbers[0]\n    ^~~\n    var\n"
  stdout: ''
  timestamp: 1660013731
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double])\
    \ -> (Double, Double) {\n    guard numbers.count >= 2 else {\n        return (0.0,0.0)\n\
    \    }\n    \n    var smallest = numbers[0]\n    var largest = numbers[0]\n  \
    \  \n    for i in 1..numbers.count {\n        if numbers[i] < smallest {\n   \
    \         smallest = numbers[i]\n        }\n        if numbers[i] > largest {\n\
    \            largest = numbers[i]\n        }\n    }\n    \n    return (smallest,\
    \ largest)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpum27rtrx.swift:16:15: error: cannot find operator '..' in scope;\
    \ did you mean '...'?\n    for i in 1..numbers.count {\n              ^~\n   \
    \           ...\n"
  stdout: ''
  timestamp: 1660013732
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double])\
    \ -> (Double, Double) {\n    let smallest = min(numbers)\n    let largest = max(numbers)\n\
    \    return (smallest, largest)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpbwt_n_vu.swift:9:31: error: missing argument for parameter #2 in\
    \ call\n    let smallest = min(numbers)\n                              ^\n   \
    \                           , <#[Double]#>\nSwift.min:1:24: note: 'min' declared\
    \ here\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n\
    \                       ^\n/tmp/tmpbwt_n_vu.swift:10:30: error: missing argument\
    \ for parameter #2 in call\n    let largest = max(numbers)\n                 \
    \            ^\n                             , <#[Double]#>\nSwift.max:1:24: note:\
    \ 'max' declared here\n@inlinable public func max<T>(_ x: T, _ y: T) -> T where\
    \ T : Comparable\n                       ^\n"
  stdout: ''
  timestamp: 1660013731
- exit_code: -4
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double])\
    \ -> (Double, Double) {\n    var smallest = numbers[0]\n    var largest = numbers[0]\n\
    \    for number in numbers {\n        if number < smallest {\n            smallest\
    \ = number\n        }\n        if number > largest {\n            largest = number\n\
    \        }\n    }\n    return (smallest, largest)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9,\
    \ 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: Exception
  stderr: 'tmpuvdtn9la/tmpuvdtn9la.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002abfe48f1c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002abfe45e8b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002abfe45e8988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002abfe45e77b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpuvdtn9la                        0x0000562f96bb064e <unavailable> + 5710

    5    libc.so.6                          0x00002abfe4add460 __libc_start_main +
    245

    6    tmpuvdtn9la                        0x0000562f96bb0209 <unavailable> + 4617

    '
  stdout: ''
  timestamp: 1660013732
- exit_code: -4
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double])\
    \ -> (Double, Double) {\n    if numbers.isEmpty {\n        return (0.0,0.0)\n\
    \    }\n    var smallest = numbers[0]\n    var largest = numbers[0]\n    for number\
    \ in numbers {\n        if number < smallest {\n            smallest = number\n\
    \        }\n        if number > largest {\n            largest = number\n    \
    \    }\n    }\n    return (smallest, largest)\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) ==\
    \ (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0])\
    \ == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1,\
    \ 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: Exception
  stderr: 'tmpwqvpatg1/tmpwqvpatg1.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b92ff079c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b92fed70b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b92fed70988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b92fed6f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpwqvpatg1                        0x000055bbf3bf269e <unavailable> + 5790

    5    libc.so.6                          0x00002b92ff265460 __libc_start_main +
    245

    6    tmpwqvpatg1                        0x000055bbf3bf2259 <unavailable> + 4697

    '
  stdout: ''
  timestamp: 1660013732
- exit_code: -4
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double])\
    \ -> (Double, Double) {\n    var smallest = numbers[0]\n    var largest = numbers[0]\n\
    \    for number in numbers {\n        if number < smallest {\n            smallest\
    \ = number\n        }\n        if number > largest {\n            largest = number\n\
    \        }\n    }\n    return (smallest, largest)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9,\
    \ 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: Exception
  stderr: 'tmpuvdtn9la/tmpuvdtn9la.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002abfe48f1c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002abfe45e8b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002abfe45e8988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002abfe45e77b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpuvdtn9la                        0x0000562f96bb064e <unavailable> + 5710

    5    libc.so.6                          0x00002abfe4add460 __libc_start_main +
    245

    6    tmpuvdtn9la                        0x0000562f96bb0209 <unavailable> + 4617

    '
  stdout: ''
  timestamp: 1660013732
- exit_code: -4
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double])\
    \ -> (Double, Double) {\n    var smallest = numbers[0]\n    var largest = numbers[0]\n\
    \    for number in numbers {\n        if number < smallest {\n            smallest\
    \ = number\n        }\n        if number > largest {\n            largest = number\n\
    \        }\n    }\n    return (smallest, largest)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9,\
    \ 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: Exception
  stderr: 'tmpuvdtn9la/tmpuvdtn9la.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002abfe48f1c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002abfe45e8b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002abfe45e8988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002abfe45e77b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpuvdtn9la                        0x0000562f96bb064e <unavailable> + 5710

    5    libc.so.6                          0x00002abfe4add460 __libc_start_main +
    245

    6    tmpuvdtn9la                        0x0000562f96bb0209 <unavailable> + 4617

    '
  stdout: ''
  timestamp: 1660013732
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double])\
    \ -> (Double, Double) {\n    guard numbers.count >= 2 else {\n        return (0.0,0.0)\n\
    \    }\n    let smallest = numbers[0]\n    let largest = numbers[0]\n    for number\
    \ in numbers {\n        if number < smallest {\n            smallest = number\n\
    \        }\n        if number > largest {\n            largest = number\n    \
    \    }\n    }\n    return (smallest, largest)\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) ==\
    \ (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0])\
    \ == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1,\
    \ 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmp8rcjv646.swift:16:13: error: cannot assign to value: 'smallest'\
    \ is a 'let' constant\n            smallest = number\n            ^~~~~~~~\n/tmp/tmp8rcjv646.swift:12:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let smallest = numbers[0]\n\
    \    ^~~\n    var\n/tmp/tmp8rcjv646.swift:19:13: error: cannot assign to value:\
    \ 'largest' is a 'let' constant\n            largest = number\n            ^~~~~~~\n\
    /tmp/tmp8rcjv646.swift:13:5: note: change 'let' to 'var' to make it mutable\n\
    \    let largest = numbers[0]\n    ^~~\n    var\n"
  stdout: ''
  timestamp: 1660013732
- exit_code: -4
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double])\
    \ -> (Double, Double) {\n    guard numbers.count >= 2 else { return (numbers[0],\
    \ numbers[0]) }\n    var smallest = numbers[0]\n    var largest = numbers[0]\n\
    \    for number in numbers {\n        if number < smallest {\n            smallest\
    \ = number\n        } else if number > largest {\n            largest = number\n\
    \        }\n    }\n    return (smallest, largest)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9,\
    \ 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: Exception
  stderr: 'tmpc3e8xpty/tmpc3e8xpty.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af75cf0ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af75cc05b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af75cc05988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af75cc047b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpc3e8xpty                        0x0000563ffa26a69e <unavailable> + 5790

    5    libc.so.6                          0x00002af75d0fa460 __libc_start_main +
    245

    6    tmpc3e8xpty                        0x0000563ffa26a259 <unavailable> + 4697

    '
  stdout: ''
  timestamp: 1660013733
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double])\
    \ -> (Double, Double) {\n    guard numbers.count >= 2 else {\n        return (0.0,0.0)\n\
    \    }\n    guard numbers.count <= 100 else {\n        return (0.0,0.0)\n    }\n\
    \    var smallest = numbers[0]\n    var largest = numbers[0]\n    for i in 1..numbers.count\
    \ {\n        if numbers[i] < smallest {\n            smallest = numbers[i]\n \
    \       }\n        if numbers[i] > largest {\n            largest = numbers[i]\n\
    \        }\n    }\n    return (smallest, largest)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9,\
    \ 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmp9sax41ue.swift:17:15: error: cannot find operator '..' in scope;\
    \ did you mean '...'?\n    for i in 1..numbers.count {\n              ^~\n   \
    \           ...\n"
  stdout: ''
  timestamp: 1660013732
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double])\
    \ -> (Double, Double) {\n    guard numbers.count >= 2 else {\n        return (0.0,0.0)\n\
    \    }\n\n    let smallest = numbers[0]\n    let largest = numbers[0]\n    for\
    \ i in 1..numbers.count {\n        if numbers[i] < smallest {\n            smallest\
    \ = numbers[i]\n        }\n        if numbers[i] > largest {\n            largest\
    \ = numbers[i]\n        }\n    }\n\n    return (smallest, largest)\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmphucvdnuf.swift:15:15: error: cannot find operator '..' in scope;\
    \ did you mean '...'?\n    for i in 1..numbers.count {\n              ^~\n   \
    \           ...\n"
  stdout: ''
  timestamp: 1660013732
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double])\
    \ -> (Double, Double) {\n    let min1 = min(numbers)\n    let max1 = max(numbers)\n\
    \    let min2 = min(numbers)\n    let max2 = max(numbers)\n    if min1 == max1\
    \ {\n        return (min1, min2)\n    }\n    if min2 == max2 {\n        return\
    \ (min2, min1)\n    }\n    if min1 < min2 {\n        return (min1, max2)\n   \
    \ }\n    if min2 < min1 {\n        return (min2, max1)\n    }\n    if min1 ==\
    \ min2 {\n        return (min1, min2)\n    }\n    if min2 == max2 {\n        return\
    \ (min2, min1)\n    }\n    if max1 < max2 {\n        return (max1, max2)\n   \
    \ }\n    if max2 < max1 {\n        return (max2, max1)\n    }\n    return (min1,\
    \ max2)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmp6lmyn0vv.swift:9:27: error: missing argument for parameter #2 in\
    \ call\n    let min1 = min(numbers)\n                          ^\n           \
    \               , <#[Double]#>\nSwift.min:1:24: note: 'min' declared here\n@inlinable\
    \ public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n             \
    \          ^\n/tmp/tmp6lmyn0vv.swift:10:27: error: missing argument for parameter\
    \ #2 in call\n    let max1 = max(numbers)\n                          ^\n     \
    \                     , <#[Double]#>\nSwift.max:1:24: note: 'max' declared here\n\
    @inlinable public func max<T>(_ x: T, _ y: T) -> T where T : Comparable\n    \
    \                   ^\n/tmp/tmp6lmyn0vv.swift:11:27: error: missing argument for\
    \ parameter #2 in call\n    let min2 = min(numbers)\n                        \
    \  ^\n                          , <#[Double]#>\nSwift.min:1:24: note: 'min' declared\
    \ here\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n\
    \                       ^\n/tmp/tmp6lmyn0vv.swift:12:27: error: missing argument\
    \ for parameter #2 in call\n    let max2 = max(numbers)\n                    \
    \      ^\n                          , <#[Double]#>\nSwift.max:1:24: note: 'max'\
    \ declared here\n@inlinable public func max<T>(_ x: T, _ y: T) -> T where T :\
    \ Comparable\n                       ^\n"
  stdout: ''
  timestamp: 1660013732
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double])\
    \ -> (Double, Double) {\n    guard numbers.count >= 2 else {\n        return (0.0,0.0)\n\
    \    }\n    let smallest = numbers[0]\n    let largest = numbers[0]\n    for i\
    \ in 1..numbers.count {\n        let current = numbers[i]\n        if current\
    \ < smallest {\n            smallest = current\n        } else if current > largest\
    \ {\n            largest = current\n        }\n    }\n    return (smallest, largest)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpbvdfi0od.swift:14:15: error: cannot find operator '..' in scope;\
    \ did you mean '...'?\n    for i in 1..numbers.count {\n              ^~\n   \
    \           ...\n"
  stdout: ''
  timestamp: 1660013732
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double])\
    \ -> (Double, Double) {\n    guard numbers.count >= 2 else {\n        return (0.0,0.0)\n\
    \    }\n    guard numbers.count > 1 else {\n        return (0.0,numbers[0])\n\
    \    }\n    var smallest = numbers[0]\n    var largest = numbers[0]\n    for i\
    \ in 1..numbers.count {\n        if numbers[i] < smallest {\n            smallest\
    \ = numbers[i]\n        }\n        if numbers[i] > largest {\n            largest\
    \ = numbers[i]\n        }\n    }\n    return (smallest, largest)\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmp8nvh_s05.swift:17:15: error: cannot find operator '..' in scope;\
    \ did you mean '...'?\n    for i in 1..numbers.count {\n              ^~\n   \
    \           ...\n"
  stdout: ''
  timestamp: 1660013732
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double])\
    \ -> (Double, Double) {\n    let smallest = numbers[0]\n    let largest = numbers[0]\n\
    \    for i in 1..<numbers.count {\n        if numbers[i] < smallest {\n      \
    \      smallest = numbers[i]\n        }\n        if numbers[i] > largest {\n \
    \           largest = numbers[i]\n        }\n    }\n    return (smallest, largest)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpooyhxm2y.swift:13:13: error: cannot assign to value: 'smallest'\
    \ is a 'let' constant\n            smallest = numbers[i]\n            ^~~~~~~~\n\
    /tmp/tmpooyhxm2y.swift:9:5: note: change 'let' to 'var' to make it mutable\n \
    \   let smallest = numbers[0]\n    ^~~\n    var\n/tmp/tmpooyhxm2y.swift:16:13:\
    \ error: cannot assign to value: 'largest' is a 'let' constant\n            largest\
    \ = numbers[i]\n            ^~~~~~~\n/tmp/tmpooyhxm2y.swift:10:5: note: change\
    \ 'let' to 'var' to make it mutable\n    let largest = numbers[0]\n    ^~~\n \
    \   var\n"
  stdout: ''
  timestamp: 1660013732
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double])\
    \ -> (Double, Double) {\n    guard numbers.count > 2 else {\n        return (0.0,0.0)\n\
    \    }\n    let min1 = numbers[0]\n    let max1 = numbers[0]\n    let min2 = numbers[0]\n\
    \    let max2 = numbers[0]\n    for i in 1..<numbers.count {\n        let current1\
    \ = numbers[i]\n        let current2 = numbers[i - 1]\n        let current3 =\
    \ numbers[i - 1]\n        let current4 = numbers[i]\n        let current5 = numbers[i\
    \ - 1]\n        let current6 = numbers[i]\n        let current7 = numbers[i -\
    \ 1]\n        let current8 = numbers[i]\n        let current9 = numbers[i - 1]\n\
    \        let current10 = numbers[i]\n        let current11 = numbers[i - 1]\n\
    \        let current12 = numbers[i]\n        let current13 = numbers[i - 1]\n\
    \        let current14 = numbers[i]\n        let current15 = numbers[i - 1]\n\
    \        let current16 = numbers[i]\n        let current17 = numbers[i - 1]\n\
    \        let current18 = numbers[i]\n        let current19 = numbers[i - 1]\n\
    \        let current20 = numbers[i]\n        let current21 = numbers[i - 1]\n\
    \        let current22 = numbers[i]\n        let current23 = numbers[i - 1]\n\
    \        let current24 = numbers[i]\n        let current25 = numbers[i - 1]\n\
    \        let current26 = numbers[i]\n        let current27 = numbers[i - 1]\n\
    \        let current28 = numbers[i]\n        let current29 = numbers[i - 1]\n\
    \        let current30 = numbers[i]\n        let current31 = numbers[i - 1]\n\
    \        let current32 = numbers[i]\n        let current33 = numbers[i - 1]\n\
    \        let current34 = numbers[i]\n        let current35 = numbers[i - 1]\n\
    \        let current36 = numbers[i]\n        let current37 = numbers[i - 1]\n\
    \        let current38 = numbers[i]\n        let current39 = numbers[i - 1]\n\
    \        let current40 = numbers[i]\n        let current41 = numbers[i - 1]\n\
    \        let current42 = numbers[i]\n        let current43 = numbers[i - 1]\n\
    \        let current44 = numbers[i]\n        let current45 = numbers[i - 1]\n\
    \        let current46 = numbers[i]\n        let current47 = numbers[i - 1]\n\
    \        let current48 = numbers[i]\n        let current49 = numbers[i - 1]\n\
    \        let current50 = numbers[i]\n        let current51 = numbers[i - 1]\n\
    \        let current52 = numbers[i]\n        let current53 = numbers[i - 1]\n\
    \        let current54 = numbers[i]\n        let current55 = numbers[i - 1]\n\
    \        let current56 = numbers[i]\n        let current57 = numbers[i - 1]\n\
    \        let current58 = numbers[i]\n        let current59 = numbers[i - 1]\n\
    \        let current60 = numbers[i]\n        let current61 = numbers[i - 1]\n\
    \        let current62 = numbers[i]\n        let current63 = numbers[i - 1]\n\
    \        let current64\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpnzxdak_2.swift:100:80: error: expected '}' at end of brace statement\n\
    assert(find_closest_elements(numbers: [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))\n\
    \                                                                            \
    \   ^\n/tmp/tmpnzxdak_2.swift:8:67: note: to match this opening '{'\nfunc find_closest_elements(numbers:\
    \ [Double]) -> (Double, Double) {\n                                          \
    \                        ^\n/tmp/tmpnzxdak_2.swift:80:13: error: type annotation\
    \ missing in pattern\n        let current64\n            ^\n/tmp/tmpnzxdak_2.swift:84:6:\
    \ error: operator functions can only be declared at global or in type scope\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660013733
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double])\
    \ -> (Double, Double) {\n    guard numbers.count >= 2 else { return (numbers[0],\
    \ numbers[0]) }\n    guard numbers.count >= 3 else { return (numbers[0], numbers[0])\
    \ }\n\n    var smallest = numbers[0]\n    var largest = numbers[0]\n    var smallestIndex\
    \ = -1\n    var largestIndex = -1\n\n    for i in 1..numbers.count {\n       \
    \ if numbers[i] < smallest {\n            smallest = numbers[i]\n            smallestIndex\
    \ = i\n        }\n        if numbers[i] > largest {\n            largest = numbers[i]\n\
    \            largestIndex = i\n        }\n    }\n\n    return (numbers[smallestIndex],\
    \ numbers[largestIndex])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpc9bitu8v.swift:17:15: error: cannot find operator '..' in scope;\
    \ did you mean '...'?\n    for i in 1..numbers.count {\n              ^~\n   \
    \           ...\n"
  stdout: ''
  timestamp: 1660013732
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double])\
    \ -> (Double, Double) {\n    let min1 = numbers[0]\n    let max1 = numbers[0]\n\
    \    let min2 = numbers[0]\n    let max2 = numbers[0]\n    for number in numbers\
    \ {\n        if number < min1 {\n            min1 = number\n        } else if\
    \ number > max1 {\n            max1 = number\n        }\n        if number < min2\
    \ {\n            min2 = number\n        } else if number > max2 {\n          \
    \  max2 = number\n        }\n    }\n    return (min1, max1)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9,\
    \ 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmp6ph79e_7.swift:15:13: error: cannot assign to value: 'min1' is\
    \ a 'let' constant\n            min1 = number\n            ^~~~\n/tmp/tmp6ph79e_7.swift:9:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let min1 = numbers[0]\n\
    \    ^~~\n    var\n/tmp/tmp6ph79e_7.swift:17:13: error: cannot assign to value:\
    \ 'max1' is a 'let' constant\n            max1 = number\n            ^~~~\n/tmp/tmp6ph79e_7.swift:10:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let max1 = numbers[0]\n\
    \    ^~~\n    var\n/tmp/tmp6ph79e_7.swift:20:13: error: cannot assign to value:\
    \ 'min2' is a 'let' constant\n            min2 = number\n            ^~~~\n/tmp/tmp6ph79e_7.swift:11:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let min2 = numbers[0]\n\
    \    ^~~\n    var\n/tmp/tmp6ph79e_7.swift:22:13: error: cannot assign to value:\
    \ 'max2' is a 'let' constant\n            max2 = number\n            ^~~~\n/tmp/tmp6ph79e_7.swift:12:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let max2 = numbers[0]\n\
    \    ^~~\n    var\n"
  stdout: ''
  timestamp: 1660013733
- exit_code: -4
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double])\
    \ -> (Double, Double) {\n    var smallest = numbers[0]\n    var largest = numbers[0]\n\
    \    for number in numbers {\n        if number < smallest {\n            smallest\
    \ = number\n        }\n        if number > largest {\n            largest = number\n\
    \        }\n    }\n    return (smallest, largest)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9,\
    \ 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: Exception
  stderr: 'tmpuvdtn9la/tmpuvdtn9la.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002abfe48f1c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002abfe45e8b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002abfe45e8988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002abfe45e77b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpuvdtn9la                        0x0000562f96bb064e <unavailable> + 5710

    5    libc.so.6                          0x00002abfe4add460 __libc_start_main +
    245

    6    tmpuvdtn9la                        0x0000562f96bb0209 <unavailable> + 4617

    '
  stdout: ''
  timestamp: 1660013732
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double])\
    \ -> (Double, Double) {\n    let smallest = min(numbers)\n    let largest = max(numbers)\n\
    \    return (smallest, largest)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpbwt_n_vu.swift:9:31: error: missing argument for parameter #2 in\
    \ call\n    let smallest = min(numbers)\n                              ^\n   \
    \                           , <#[Double]#>\nSwift.min:1:24: note: 'min' declared\
    \ here\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n\
    \                       ^\n/tmp/tmpbwt_n_vu.swift:10:30: error: missing argument\
    \ for parameter #2 in call\n    let largest = max(numbers)\n                 \
    \            ^\n                             , <#[Double]#>\nSwift.max:1:24: note:\
    \ 'max' declared here\n@inlinable public func max<T>(_ x: T, _ y: T) -> T where\
    \ T : Comparable\n                       ^\n"
  stdout: ''
  timestamp: 1660013731
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double])\
    \ -> (Double, Double) {\n    guard numbers.count >= 2 else {\n        return (0.0,0.0)\n\
    \    }\n    guard numbers.count <= Float.greatestFiniteMagnitude else {\n    \
    \    return (0.0,0.0)\n    }\n    let smallest = numbers[0]\n    let largest =\
    \ numbers[0]\n    for number in numbers {\n        if number < smallest {\n  \
    \          smallest = number\n        }\n        if number > largest {\n     \
    \       largest = number\n        }\n    }\n    return (smallest, largest)\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpyo08ru6v.swift:12:25: error: binary operator '<=' cannot be applied\
    \ to operands of type 'Int' and 'Float'\n    guard numbers.count <= Float.greatestFiniteMagnitude\
    \ else {\n          ~~~~~~~~~~~~~ ^  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpyo08ru6v.swift:12:25:\
    \ note: overloads for '<=' exist with these partially matching parameter lists:\
    \ (Int, Int)\n    guard numbers.count <= Float.greatestFiniteMagnitude else {\n\
    \                        ^\n/tmp/tmpyo08ru6v.swift:19:13: error: cannot assign\
    \ to value: 'smallest' is a 'let' constant\n            smallest = number\n  \
    \          ^~~~~~~~\n/tmp/tmpyo08ru6v.swift:15:5: note: change 'let' to 'var'\
    \ to make it mutable\n    let smallest = numbers[0]\n    ^~~\n    var\n/tmp/tmpyo08ru6v.swift:22:13:\
    \ error: cannot assign to value: 'largest' is a 'let' constant\n            largest\
    \ = number\n            ^~~~~~~\n/tmp/tmpyo08ru6v.swift:16:5: note: change 'let'\
    \ to 'var' to make it mutable\n    let largest = numbers[0]\n    ^~~\n    var\n"
  stdout: ''
  timestamp: 1660013733
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double])\
    \ -> (Double, Double) {\n    let smallest = numbers[0]\n    let largest = numbers[0]\n\
    \    for i in 1..<numbers.count {\n        if numbers[i] > largest {\n       \
    \     largest = numbers[i]\n        } else if numbers[i] < smallest {\n      \
    \      smallest = numbers[i]\n        }\n    }\n    return (smallest, largest)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpgy7p4jtw.swift:13:13: error: cannot assign to value: 'largest'\
    \ is a 'let' constant\n            largest = numbers[i]\n            ^~~~~~~\n\
    /tmp/tmpgy7p4jtw.swift:10:5: note: change 'let' to 'var' to make it mutable\n\
    \    let largest = numbers[0]\n    ^~~\n    var\n/tmp/tmpgy7p4jtw.swift:15:13:\
    \ error: cannot assign to value: 'smallest' is a 'let' constant\n            smallest\
    \ = numbers[i]\n            ^~~~~~~~\n/tmp/tmpgy7p4jtw.swift:9:5: note: change\
    \ 'let' to 'var' to make it mutable\n    let smallest = numbers[0]\n    ^~~\n\
    \    var\n"
  stdout: ''
  timestamp: 1660013732
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double])\
    \ -> (Double, Double) {\n    guard numbers.count > 1 else {\n        return (0.0,0.0)\n\
    \    }\n    let smallest = numbers[0]\n    let largest = numbers[0]\n    for number\
    \ in numbers {\n        if number < smallest {\n            smallest = number\n\
    \        }\n        if number > largest {\n            largest = number\n    \
    \    }\n    }\n    return (smallest, largest)\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) ==\
    \ (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0])\
    \ == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1,\
    \ 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpbot7rs96.swift:16:13: error: cannot assign to value: 'smallest'\
    \ is a 'let' constant\n            smallest = number\n            ^~~~~~~~\n/tmp/tmpbot7rs96.swift:12:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let smallest = numbers[0]\n\
    \    ^~~\n    var\n/tmp/tmpbot7rs96.swift:19:13: error: cannot assign to value:\
    \ 'largest' is a 'let' constant\n            largest = number\n            ^~~~~~~\n\
    /tmp/tmpbot7rs96.swift:13:5: note: change 'let' to 'var' to make it mutable\n\
    \    let largest = numbers[0]\n    ^~~\n    var\n"
  stdout: ''
  timestamp: 1660013731
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double])\
    \ -> (Double, Double) {\n    guard numbers.count >= 2 else {\n        return (0.0,0.0)\n\
    \    }\n    let smallest = numbers[0]\n    let largest = numbers[0]\n    for i\
    \ in 1..numbers.count {\n        if numbers[i] < smallest {\n            smallest\
    \ = numbers[i]\n        }\n        if numbers[i] > largest {\n            largest\
    \ = numbers[i]\n        }\n    }\n    return (smallest, largest)\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpl9gdgn3q.swift:14:15: error: cannot find operator '..' in scope;\
    \ did you mean '...'?\n    for i in 1..numbers.count {\n              ^~\n   \
    \           ...\n"
  stdout: ''
  timestamp: 1660013732
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double])\
    \ -> (Double, Double) {\n    guard numbers.count >= 2 else { return (numbers[0],\
    \ numbers[0]) }\n    guard numbers.count > 2 else { return (numbers[0], numbers[0])\
    \ }\n    guard numbers.count > 3 else { return (numbers[0], numbers[0]) }\n  \
    \  guard numbers.count > 4 else { return (numbers[0], numbers[0]) }\n    guard\
    \ numbers.count > 5 else { return (numbers[0], numbers[0]) }\n    guard numbers.count\
    \ > 6 else { return (numbers[0], numbers[0]) }\n    guard numbers.count > 7 else\
    \ { return (numbers[0], numbers[0]) }\n    guard numbers.count > 8 else { return\
    \ (numbers[0], numbers[0]) }\n    guard numbers.count > 9 else { return (numbers[0],\
    \ numbers[0]) }\n    guard numbers.count > 10 else { return (numbers[0], numbers[0])\
    \ }\n    guard numbers.count > 11 else { return (numbers[0], numbers[0]) }\n \
    \   guard numbers.count > 12 else { return (numbers[0], numbers[0]) }\n    guard\
    \ numbers.count > 13 else { return (numbers[0], numbers[0]) }\n    guard numbers.count\
    \ > 14 else { return (numbers[0], numbers[0]) }\n    guard numbers.count > 15\
    \ else { return (numbers[0], numbers[0]) }\n    guard numbers.count > 16 else\
    \ { return (numbers[0], numbers[0]) }\n    guard numbers.count > 17 else { return\
    \ (numbers[0], numbers[0]) }\n    guard numbers.count > 18 else { return (numbers[0],\
    \ numbers[0]) }\n    guard numbers.count > 19 else { return (numbers[0], numbers[0])\
    \ }\n    guard numbers.count > 20 else { return (numbers[0], numbers[0]) }\n \
    \   guard numbers.count > 21 else { return (numbers[0], numbers[0]) }\n    guard\
    \ numbers.count > 22 else { return (numbers[0], numbers[0]) }\n    guard numbers.count\
    \ > 23 else { return (numbers[0], numbers[0]) }\n    guard numbers.count > 24\
    \ else { return (numbers[0], numbers[0]) }\n    guard numbers.count > 25 else\
    \ { return (numbers[0], numbers[0]) }\n    guard numbers.count > 26 else { return\
    \ (numbers[0], numbers[0]) }\n    guard numbers.count > 27 else { return (numbers[0],\
    \ numbers[0]) }\n    guard numbers.count > 28 else { return (numbers[0], numbers[0])\
    \ }\n    guard numbers.count > 29 else { return (numbers[0], numbers[0]) }\n \
    \   guard numbers.count > 30 else { return (numbers[0], numbers[0]) }\n    guard\
    \ numbers.\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpy_q5khuy.swift:39:18: error: expected member name following '.'\n\
    \    guard numbers.\n                 ^\n/tmp/tmpy_q5khuy.swift:39:19: error:\
    \ expected 'else' after 'guard' condition\n    guard numbers.\n              \
    \    ^\n"
  stdout: ''
  timestamp: 1660013732
- exit_code: -4
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double])\
    \ -> (Double, Double) {\n    let sortedNumbers = numbers.sorted()\n    var closest1\
    \ = sortedNumbers[0]\n    var closest2 = sortedNumbers[0]\n    for i in 1..<sortedNumbers.count\
    \ {\n        let currentClosest1 = sortedNumbers[i]\n        let currentClosest2\
    \ = sortedNumbers[i - 1]\n        if currentClosest1 < closest1 {\n          \
    \  closest1 = currentClosest1\n        }\n        if currentClosest2 < closest2\
    \ {\n            closest2 = currentClosest2\n        }\n    }\n    return (closest1,\
    \ closest2)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: Exception
  stderr: 'tmpl97kf6co/tmpl97kf6co.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0140d26c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0140a1db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0140a1d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b0140a1c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpl97kf6co                        0x000055b18269575e <unavailable> + 5982

    5    libc.so.6                          0x00002b0140f12460 __libc_start_main +
    245

    6    tmpl97kf6co                        0x000055b182695319 <unavailable> + 4889

    '
  stdout: ''
  timestamp: 1660013733
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double])\
    \ -> (Double, Double) {\n    guard numbers.count >= 2 else { return (numbers[0],\
    \ numbers[0]) }\n    guard numbers.count >= 3 else { return (numbers[0], numbers[0])\
    \ }\n    guard numbers.count >= 4 else { return (numbers[0], numbers[0]) }\n \
    \   guard numbers.count >= 5 else { return (numbers[0], numbers[0]) }\n    guard\
    \ numbers.count >= 6 else { return (numbers[0], numbers[0]) }\n    guard numbers.count\
    \ >= 7 else { return (numbers[0], numbers[0]) }\n    guard numbers.count >= 8\
    \ else { return (numbers[0], numbers[0]) }\n    guard numbers.count >= 9 else\
    \ { return (numbers[0], numbers[0]) }\n    guard numbers.count >= 10 else { return\
    \ (numbers[0], numbers[0]) }\n    guard numbers.count >= 11 else { return (numbers[0],\
    \ numbers[0]) }\n    guard numbers.count >= 12 else { return (numbers[0], numbers[0])\
    \ }\n    guard numbers.count >= 13 else { return (numbers[0], numbers[0]) }\n\
    \    guard numbers.count >= 14 else { return (numbers[0], numbers[0]) }\n    guard\
    \ numbers.count >= 15 else { return (numbers[0], numbers[0]) }\n    guard numbers.count\
    \ >= 16 else { return (numbers[0], numbers[0]) }\n    guard numbers.count >= 17\
    \ else { return (numbers[0], numbers[0]) }\n    guard numbers.count >= 18 else\
    \ { return (numbers[0], numbers[0]) }\n    guard numbers.count >= 19 else { return\
    \ (numbers[0], numbers[0]) }\n    guard numbers.count >= 20 else { return (numbers[0],\
    \ numbers[0]) }\n    guard numbers.count >= 21 else { return (numbers[0], numbers[0])\
    \ }\n    guard numbers.count >= 22 else { return (numbers[0], numbers[0]) }\n\
    \    guard numbers.count >= 23 else { return (numbers[0], numbers[0]) }\n    guard\
    \ numbers.count >= 24 else { return (numbers[0], numbers[0]) }\n    guard numbers.count\
    \ >= 25 else { return (numbers[0], numbers[0]) }\n    guard numbers.count >= 26\
    \ else { return (numbers[0], numbers[0]) }\n    guard numbers.count >= 27 else\
    \ { return (numbers[0], numbers[0]) }\n    guard numbers.count >= 28 else { return\
    \ (numbers[0], numbers[0]) }\n    guard numbers.count >= 29 else { return (numbers[0],\
    \ numbers[0]) }\n    guard numbers.count >= 30 else { return (numbers[0], numbers[0])\
    \ }\n    guard numbers.count >= 31 else { return (numbers[0], numbers[0]) }\n\
    \    guard \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpbwb6o780.swift:39:10: error: expected expression, var, let or case\
    \ in 'guard' condition\n    guard \n         ^\n"
  stdout: ''
  timestamp: 1660013733
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double])\
    \ -> (Double, Double) {\n    let smallest = numbers[0]\n    let largest = numbers[0]\n\
    \    for i in 1..numbers.count {\n        if numbers[i] < smallest {\n       \
    \     smallest = numbers[i]\n        }\n        if numbers[i] > largest {\n  \
    \          largest = numbers[i]\n        }\n    }\n    return (smallest, largest)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmprbm9q1bq.swift:11:15: error: cannot find operator '..' in scope;\
    \ did you mean '...'?\n    for i in 1..numbers.count {\n              ^~\n   \
    \           ...\n"
  stdout: ''
  timestamp: 1660013732
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double])\
    \ -> (Double, Double) {\n    guard numbers.count >= 2 else { return (numbers[0],\
    \ numbers[0]) }\n    guard numbers.count >= 3 else { return (numbers[0], numbers[0])\
    \ }\n    guard numbers.count >= 4 else { return (numbers[0], numbers[0]) }\n \
    \   guard numbers.count >= 5 else { return (numbers[0], numbers[0]) }\n    guard\
    \ numbers.count >= 6 else { return (numbers[0], numbers[0]) }\n    guard numbers.count\
    \ >= 7 else { return (numbers[0], numbers[0]) }\n    guard numbers.count >= 8\
    \ else { return (numbers[0], numbers[0]) }\n    guard numbers.count >= 9 else\
    \ { return (numbers[0], numbers[0]) }\n    guard numbers.count >= 10 else { return\
    \ (numbers[0], numbers[0]) }\n    guard numbers.count >= 11 else { return (numbers[0],\
    \ numbers[0]) }\n    guard numbers.count >= 12 else { return (numbers[0], numbers[0])\
    \ }\n    guard numbers.count >= 13 else { return (numbers[0], numbers[0]) }\n\
    \    guard numbers.count >= 14 else { return (numbers[0], numbers[0]) }\n    guard\
    \ numbers.count >= 15 else { return (numbers[0], numbers[0]) }\n    guard numbers.count\
    \ >= 16 else { return (numbers[0], numbers[0]) }\n    guard numbers.count >= 17\
    \ else { return (numbers[0], numbers[0]) }\n    guard numbers.count >= 18 else\
    \ { return (numbers[0], numbers[0]) }\n    guard numbers.count >= 19 else { return\
    \ (numbers[0], numbers[0]) }\n    guard numbers.count >= 20 else { return (numbers[0],\
    \ numbers[0]) }\n    guard numbers.count >= 21 else { return (numbers[0], numbers[0])\
    \ }\n    guard numbers.count >= 22 else { return (numbers[0], numbers[0]) }\n\
    \    guard numbers.count >= 23 else { return (numbers[0], numbers[0]) }\n    guard\
    \ numbers.count >= 24 else { return (numbers[0], numbers[0]) }\n    guard numbers.count\
    \ >= 25 else { return (numbers[0], numbers[0]) }\n    guard numbers.count >= 26\
    \ else { return (numbers[0], numbers[0]) }\n    guard numbers.count >= 27 else\
    \ { return (numbers[0], numbers[0]) }\n    guard numbers.count >= 28 else { return\
    \ (numbers[0], numbers[0]) }\n    guard numbers.count >= 29 else { return (numbers[0],\
    \ numbers[0]) }\n    guard numbers.count >= 30 else { return (numbers[0], numbers[0])\
    \ }\n    guard numbers.count >= 31 else { return (numbers[0], numbers[0]) }\n\
    \    guard \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpbwb6o780.swift:39:10: error: expected expression, var, let or case\
    \ in 'guard' condition\n    guard \n         ^\n"
  stdout: ''
  timestamp: 1660013733
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double])\
    \ -> (Double, Double) {\n    guard numbers.count >= 2 else { return (numbers[0],\
    \ numbers[0]) }\n    guard numbers.count >= 3 else { return (numbers[0], numbers[0])\
    \ }\n\n    let smallest = numbers[0]\n    let largest = numbers[0]\n    for i\
    \ in 1..numbers.count {\n        if numbers[i] < smallest {\n            smallest\
    \ = numbers[i]\n        } else if numbers[i] > largest {\n            largest\
    \ = numbers[i]\n        }\n    }\n    return (smallest, largest)\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpzei7uf3i.swift:14:15: error: cannot find operator '..' in scope;\
    \ did you mean '...'?\n    for i in 1..numbers.count {\n              ^~\n   \
    \           ...\n"
  stdout: ''
  timestamp: 1660013733
- exit_code: -4
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double])\
    \ -> (Double, Double) {\n    let sortedNumbers = numbers.sorted()\n    if sortedNumbers.count\
    \ < 2 {\n        return (sortedNumbers[0], sortedNumbers[1])\n    }\n    let closest1\
    \ = sortedNumbers.first!\n    let closest2 = sortedNumbers.last!\n    if closest1\
    \ < closest2 {\n        return (closest1, closest2)\n    }\n    return (closest2,\
    \ closest1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: Exception
  stderr: 'tmpjcs_czs7/tmpjcs_czs7.swift:34: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b808bfd8c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b808bccfb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b808bccf988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b808bcce7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpjcs_czs7                        0x000055dc214b87ae <unavailable> + 6062

    5    libc.so.6                          0x00002b808c1c4460 __libc_start_main +
    245

    6    tmpjcs_czs7                        0x000055dc214b8369 <unavailable> + 4969

    '
  stdout: ''
  timestamp: 1660013733
- exit_code: -4
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double])\
    \ -> (Double, Double) {\n    var smallest = numbers[0]\n    var largest = numbers[0]\n\
    \    for number in numbers {\n        if number < smallest {\n            smallest\
    \ = number\n        }\n        if number > largest {\n            largest = number\n\
    \        }\n    }\n    return (smallest, largest)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9,\
    \ 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: Exception
  stderr: 'tmpuvdtn9la/tmpuvdtn9la.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002abfe48f1c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002abfe45e8b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002abfe45e8988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002abfe45e77b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpuvdtn9la                        0x0000562f96bb064e <unavailable> + 5710

    5    libc.so.6                          0x00002abfe4add460 __libc_start_main +
    245

    6    tmpuvdtn9la                        0x0000562f96bb0209 <unavailable> + 4617

    '
  stdout: ''
  timestamp: 1660013732
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double])\
    \ -> (Double, Double) {\n    guard numbers.count >= 2 else {\n        return (0.0,0.0)\n\
    \    }\n    let smallest = numbers[0]\n    let largest = numbers[0]\n    for i\
    \ in 1..<numbers.count {\n        if numbers[i] < smallest {\n            smallest\
    \ = numbers[i]\n        }\n        if numbers[i] > largest {\n            largest\
    \ = numbers[i]\n        }\n    }\n    return (smallest, largest)\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpittqridb.swift:16:13: error: cannot assign to value: 'smallest'\
    \ is a 'let' constant\n            smallest = numbers[i]\n            ^~~~~~~~\n\
    /tmp/tmpittqridb.swift:12:5: note: change 'let' to 'var' to make it mutable\n\
    \    let smallest = numbers[0]\n    ^~~\n    var\n/tmp/tmpittqridb.swift:19:13:\
    \ error: cannot assign to value: 'largest' is a 'let' constant\n            largest\
    \ = numbers[i]\n            ^~~~~~~\n/tmp/tmpittqridb.swift:13:5: note: change\
    \ 'let' to 'var' to make it mutable\n    let largest = numbers[0]\n    ^~~\n \
    \   var\n"
  stdout: ''
  timestamp: 1660013732
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double])\
    \ -> (Double, Double) {\n    guard numbers.count >= 2 else { return (numbers[0],\
    \ numbers[0]) }\n    guard numbers.count >= 3 else { return (numbers[0], numbers[0])\
    \ }\n    guard numbers.count >= 4 else { return (numbers[0], numbers[0]) }\n \
    \   guard numbers.count >= 5 else { return (numbers[0], numbers[0]) }\n    guard\
    \ numbers.count >= 6 else { return (numbers[0], numbers[0]) }\n    guard numbers.count\
    \ >= 7 else { return (numbers[0], numbers[0]) }\n    guard numbers.count >= 8\
    \ else { return (numbers[0], numbers[0]) }\n    guard numbers.count >= 9 else\
    \ { return (numbers[0], numbers[0]) }\n    guard numbers.count >= 10 else { return\
    \ (numbers[0], numbers[0]) }\n    guard numbers.count >= 11 else { return (numbers[0],\
    \ numbers[0]) }\n    guard numbers.count >= 12 else { return (numbers[0], numbers[0])\
    \ }\n    guard numbers.count >= 13 else { return (numbers[0], numbers[0]) }\n\
    \    guard numbers.count >= 14 else { return (numbers[0], numbers[0]) }\n    guard\
    \ numbers.count >= 15 else { return (numbers[0], numbers[0]) }\n    guard numbers.count\
    \ >= 16 else { return (numbers[0], numbers[0]) }\n    guard numbers.count >= 17\
    \ else { return (numbers[0], numbers[0]) }\n    guard numbers.count >= 18 else\
    \ { return (numbers[0], numbers[0]) }\n    guard numbers.count >= 19 else { return\
    \ (numbers[0], numbers[0]) }\n    guard numbers.count >= 20 else { return (numbers[0],\
    \ numbers[0]) }\n    guard numbers.count >= 21 else { return (numbers[0], numbers[0])\
    \ }\n    guard numbers.count >= 22 else { return (numbers[0], numbers[0]) }\n\
    \    guard numbers.count >= 23 else { return (numbers[0], numbers[0]) }\n    guard\
    \ numbers.count >= 24 else { return (numbers[0], numbers[0]) }\n    guard numbers.count\
    \ >= 25 else { return (numbers[0], numbers[0]) }\n    guard numbers.count >= 26\
    \ else { return (numbers[0], numbers[0]) }\n    guard numbers.count >= 27 else\
    \ { return (numbers[0], numbers[0]) }\n    guard numbers.count >= 28 else { return\
    \ (numbers[0], numbers[0]) }\n    guard numbers.count >= 29 else { return (numbers[0],\
    \ numbers[0]) }\n    guard numbers.count >= 30 else { return (numbers[0], numbers[0])\
    \ }\n    guard numbers.count >= 31 else { return (numbers[0], numbers[0]) }\n\
    \    guard \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpbwb6o780.swift:39:10: error: expected expression, var, let or case\
    \ in 'guard' condition\n    guard \n         ^\n"
  stdout: ''
  timestamp: 1660013733
- exit_code: -4
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double])\
    \ -> (Double, Double) {\n    let sortedNumbers = numbers.sorted()\n    var closest1\
    \ = sortedNumbers[0]\n    var closest2 = sortedNumbers[0]\n    for number in sortedNumbers\
    \ {\n        if number < closest1 {\n            closest1 = number\n        }\
    \ else if number > closest2 {\n            closest2 = number\n        }\n    }\n\
    \    return (closest1, closest2)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: Exception
  stderr: 'tmp1mria4d1/tmp1mria4d1.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002afd63e65c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002afd63b5cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002afd63b5c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002afd63b5b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp1mria4d1                        0x000055d35762b6ee <unavailable> + 5870

    5    libc.so.6                          0x00002afd64051460 __libc_start_main +
    245

    6    tmp1mria4d1                        0x000055d35762b2a9 <unavailable> + 4777

    '
  stdout: ''
  timestamp: 1660013733
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double])\
    \ -> (Double, Double) {\n    guard numbers.count > 1 else { return (numbers[0],\
    \ numbers[0]) }\n    var smallest = numbers[0]\n    var largest = numbers[0]\n\
    \    for i in 1..numbers.count {\n        if numbers[i] < smallest {\n       \
    \     smallest = numbers[i]\n        } else if numbers[i] > largest {\n      \
    \      largest = numbers[i]\n        }\n    }\n    return (smallest, largest)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpibdvbxx8.swift:12:15: error: cannot find operator '..' in scope;\
    \ did you mean '...'?\n    for i in 1..numbers.count {\n              ^~\n   \
    \           ...\n"
  stdout: ''
  timestamp: 1660013733
- exit_code: -4
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double])\
    \ -> (Double, Double) {\n    var smallest = numbers[0]\n    var largest = numbers[0]\n\
    \    for number in numbers {\n        if number < smallest {\n            smallest\
    \ = number\n        }\n        if number > largest {\n            largest = number\n\
    \        }\n    }\n    return (smallest, largest)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9,\
    \ 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: Exception
  stderr: 'tmpuvdtn9la/tmpuvdtn9la.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002abfe48f1c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002abfe45e8b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002abfe45e8988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002abfe45e77b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpuvdtn9la                        0x0000562f96bb064e <unavailable> + 5710

    5    libc.so.6                          0x00002abfe4add460 __libc_start_main +
    245

    6    tmpuvdtn9la                        0x0000562f96bb0209 <unavailable> + 4617

    '
  stdout: ''
  timestamp: 1660013732
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double])\
    \ -> (Double, Double) {\n    guard numbers.count >= 2 else { return (numbers[0],\
    \ numbers[0]) }\n    var smallest = numbers[0]\n    var largest = numbers[0]\n\
    \    for i in 1..numbers.count {\n        if numbers[i] < smallest {\n       \
    \     smallest = numbers[i]\n        } else if numbers[i] > largest {\n      \
    \      largest = numbers[i]\n        }\n    }\n    return (smallest, largest)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpt6jhoiyu.swift:12:15: error: cannot find operator '..' in scope;\
    \ did you mean '...'?\n    for i in 1..numbers.count {\n              ^~\n   \
    \           ...\n"
  stdout: ''
  timestamp: 1660013732
- exit_code: -4
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double])\
    \ -> (Double, Double) {\n    var smallest = numbers[0]\n    var largest = numbers[0]\n\
    \    for number in numbers {\n        if number < smallest {\n            smallest\
    \ = number\n        }\n        if number > largest {\n            largest = number\n\
    \        }\n    }\n    return (smallest, largest)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9,\
    \ 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: Exception
  stderr: 'tmpuvdtn9la/tmpuvdtn9la.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002abfe48f1c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002abfe45e8b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002abfe45e8988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002abfe45e77b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpuvdtn9la                        0x0000562f96bb064e <unavailable> + 5710

    5    libc.so.6                          0x00002abfe4add460 __libc_start_main +
    245

    6    tmpuvdtn9la                        0x0000562f96bb0209 <unavailable> + 4617

    '
  stdout: ''
  timestamp: 1660013732
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double])\
    \ -> (Double, Double) {\n    let smallest = numbers[0]\n    let largest = numbers[0]\n\
    \    for number in numbers {\n        if number < smallest {\n            smallest\
    \ = number\n        }\n        if number > largest {\n            largest = number\n\
    \        }\n    }\n    return (smallest, largest)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9,\
    \ 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmp5pls_p0p.swift:13:13: error: cannot assign to value: 'smallest'\
    \ is a 'let' constant\n            smallest = number\n            ^~~~~~~~\n/tmp/tmp5pls_p0p.swift:9:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let smallest = numbers[0]\n\
    \    ^~~\n    var\n/tmp/tmp5pls_p0p.swift:16:13: error: cannot assign to value:\
    \ 'largest' is a 'let' constant\n            largest = number\n            ^~~~~~~\n\
    /tmp/tmp5pls_p0p.swift:10:5: note: change 'let' to 'var' to make it mutable\n\
    \    let largest = numbers[0]\n    ^~~\n    var\n"
  stdout: ''
  timestamp: 1660013731
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double])\
    \ -> (Double, Double) {\n    let smallest = numbers[0]\n    let largest = numbers[0]\n\
    \    for number in numbers {\n        if number < smallest {\n            smallest\
    \ = number\n        }\n        if number > largest {\n            largest = number\n\
    \        }\n    }\n    return (smallest, largest)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9,\
    \ 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmp5pls_p0p.swift:13:13: error: cannot assign to value: 'smallest'\
    \ is a 'let' constant\n            smallest = number\n            ^~~~~~~~\n/tmp/tmp5pls_p0p.swift:9:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let smallest = numbers[0]\n\
    \    ^~~\n    var\n/tmp/tmp5pls_p0p.swift:16:13: error: cannot assign to value:\
    \ 'largest' is a 'let' constant\n            largest = number\n            ^~~~~~~\n\
    /tmp/tmp5pls_p0p.swift:10:5: note: change 'let' to 'var' to make it mutable\n\
    \    let largest = numbers[0]\n    ^~~\n    var\n"
  stdout: ''
  timestamp: 1660013731
- exit_code: -4
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double])\
    \ -> (Double, Double) {\n    var smallest = numbers[0]\n    var largest = numbers[0]\n\
    \    for number in numbers {\n        if number < smallest {\n            smallest\
    \ = number\n        }\n        if number > largest {\n            largest = number\n\
    \        }\n    }\n    return (smallest, largest)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9,\
    \ 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: Exception
  stderr: 'tmpuvdtn9la/tmpuvdtn9la.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002abfe48f1c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002abfe45e8b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002abfe45e8988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002abfe45e77b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpuvdtn9la                        0x0000562f96bb064e <unavailable> + 5710

    5    libc.so.6                          0x00002abfe4add460 __libc_start_main +
    245

    6    tmpuvdtn9la                        0x0000562f96bb0209 <unavailable> + 4617

    '
  stdout: ''
  timestamp: 1660013732
- exit_code: -4
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double])\
    \ -> (Double, Double) {\n    let sortedNumbers = numbers.sorted()\n    if sortedNumbers.count\
    \ < 2 {\n        return (sortedNumbers[0], sortedNumbers[1])\n    }\n    let closestToFirst\
    \ = sortedNumbers.first!\n    let closestToSecond = sortedNumbers.last!\n    return\
    \ (closestToFirst, closestToSecond)\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9,\
    \ 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0,\
    \ 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\
    \ == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1, 2.2, 3.1,\
    \ 4.1, 5.1]) == (2.2, 3.1))"
  status: Exception
  stderr: 'tmpjqlq0ntk/tmpjqlq0ntk.swift:31: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aec73346c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aec7303db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aec7303d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aec7303c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpjqlq0ntk                        0x000056516e2947ae <unavailable> + 6062

    5    libc.so.6                          0x00002aec73532460 __libc_start_main +
    245

    6    tmpjqlq0ntk                        0x000056516e294369 <unavailable> + 4969

    '
  stdout: ''
  timestamp: 1660013733
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double])\
    \ -> (Double, Double) {\n    guard numbers.count >= 2 else {\n        return (0.0,0.0)\n\
    \    }\n    guard numbers.count > 1 else {\n        return numbers[0], numbers[0]\n\
    \    }\n    let smallest = numbers[0]\n    let largest = numbers[0]\n    for i\
    \ in 1..<numbers.count {\n        if numbers[i] > largest {\n            largest\
    \ = numbers[i]\n        }\n        if numbers[i] < smallest {\n            smallest\
    \ = numbers[i]\n        }\n    }\n    return (smallest, largest)\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpa3dbtaic.swift:13:26: error: consecutive statements on a line must\
    \ be separated by ';'\n        return numbers[0], numbers[0]\n               \
    \          ^\n                         ;\n/tmp/tmpa3dbtaic.swift:13:26: error:\
    \ expected expression\n        return numbers[0], numbers[0]\n               \
    \          ^\n/tmp/tmpa3dbtaic.swift:13:23: error: cannot convert return expression\
    \ of type 'Double' to return type '(Double, Double)'\n        return numbers[0],\
    \ numbers[0]\n               ~~~~~~~^~~\n/tmp/tmpa3dbtaic.swift:19:13: error:\
    \ cannot assign to value: 'largest' is a 'let' constant\n            largest =\
    \ numbers[i]\n            ^~~~~~~\n/tmp/tmpa3dbtaic.swift:16:5: note: change 'let'\
    \ to 'var' to make it mutable\n    let largest = numbers[0]\n    ^~~\n    var\n\
    /tmp/tmpa3dbtaic.swift:22:13: error: cannot assign to value: 'smallest' is a 'let'\
    \ constant\n            smallest = numbers[i]\n            ^~~~~~~~\n/tmp/tmpa3dbtaic.swift:15:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let smallest = numbers[0]\n\
    \    ^~~\n    var\n"
  stdout: ''
  timestamp: 1660013733
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double])\
    \ -> (Double, Double) {\n    let smallest = numbers[0]\n    let largest = numbers[0]\n\
    \    for number in numbers {\n        if number < smallest {\n            smallest\
    \ = number\n        }\n        if number > largest {\n            largest = number\n\
    \        }\n    }\n    return (smallest, largest)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9,\
    \ 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmp5pls_p0p.swift:13:13: error: cannot assign to value: 'smallest'\
    \ is a 'let' constant\n            smallest = number\n            ^~~~~~~~\n/tmp/tmp5pls_p0p.swift:9:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let smallest = numbers[0]\n\
    \    ^~~\n    var\n/tmp/tmp5pls_p0p.swift:16:13: error: cannot assign to value:\
    \ 'largest' is a 'let' constant\n            largest = number\n            ^~~~~~~\n\
    /tmp/tmp5pls_p0p.swift:10:5: note: change 'let' to 'var' to make it mutable\n\
    \    let largest = numbers[0]\n    ^~~\n    var\n"
  stdout: ''
  timestamp: 1660013731
- exit_code: -4
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double])\
    \ -> (Double, Double) {\n    guard numbers.count >= 2 else { return (numbers[0],\
    \ numbers[0]) }\n    var smallest = numbers[0]\n    var largest = numbers[0]\n\
    \    for number in numbers {\n        if number < smallest {\n            smallest\
    \ = number\n        }\n        if number > largest {\n            largest = number\n\
    \        }\n    }\n    return (smallest, largest)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9,\
    \ 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: Exception
  stderr: 'tmpog360l6j/tmpog360l6j.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1f52c7ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b1f52975b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b1f52975988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b1f529747b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpog360l6j                        0x000055705c6f669e <unavailable> + 5790

    5    libc.so.6                          0x00002b1f52e6a460 __libc_start_main +
    245

    6    tmpog360l6j                        0x000055705c6f6259 <unavailable> + 4697

    '
  stdout: ''
  timestamp: 1660013733
- exit_code: -4
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double])\
    \ -> (Double, Double) {\n    guard numbers.count >= 2 else {\n        return (0.0,0.0)\n\
    \    }\n    var smallest = numbers[0]\n    var largest = numbers[0]\n    for number\
    \ in numbers {\n        if number < smallest {\n            smallest = number\n\
    \        }\n        if number > largest {\n            largest = number\n    \
    \    }\n    }\n    return (smallest, largest)\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) ==\
    \ (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9, 4.0, 5.0])\
    \ == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0, 4.0, 5.0,\
    \ 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers: [1.1,\
    \ 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: Exception
  stderr: 'tmp1xhx_psi/tmp1xhx_psi.swift:38: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae13eaa7c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae13e79eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae13e79e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae13e79d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp1xhx_psi                        0x000055d2086d069e <unavailable> + 5790

    5    libc.so.6                          0x00002ae13ec93460 __libc_start_main +
    245

    6    tmp1xhx_psi                        0x000055d2086d0259 <unavailable> + 4697

    '
  stdout: ''
  timestamp: 1660013732
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double])\
    \ -> (Double, Double) {\n    let smallest = numbers[0]\n    let largest = numbers[0]\n\
    \    for i in 1..<numbers.count {\n        if numbers[i] < smallest {\n      \
    \      smallest = numbers[i]\n        }\n        if numbers[i] > largest {\n \
    \           largest = numbers[i]\n        }\n    }\n    return (smallest, largest)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpooyhxm2y.swift:13:13: error: cannot assign to value: 'smallest'\
    \ is a 'let' constant\n            smallest = numbers[i]\n            ^~~~~~~~\n\
    /tmp/tmpooyhxm2y.swift:9:5: note: change 'let' to 'var' to make it mutable\n \
    \   let smallest = numbers[0]\n    ^~~\n    var\n/tmp/tmpooyhxm2y.swift:16:13:\
    \ error: cannot assign to value: 'largest' is a 'let' constant\n            largest\
    \ = numbers[i]\n            ^~~~~~~\n/tmp/tmpooyhxm2y.swift:10:5: note: change\
    \ 'let' to 'var' to make it mutable\n    let largest = numbers[0]\n    ^~~\n \
    \   var\n"
  stdout: ''
  timestamp: 1660013732
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double])\
    \ -> (Double, Double) {\n    let smallest = numbers[0]\n    let largest = numbers[0]\n\
    \    for number in numbers {\n        if number < smallest {\n            smallest\
    \ = number\n        } else if number > largest {\n            largest = number\n\
    \        }\n    }\n    return (smallest, largest)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9,\
    \ 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpq9xkdvr3.swift:13:13: error: cannot assign to value: 'smallest'\
    \ is a 'let' constant\n            smallest = number\n            ^~~~~~~~\n/tmp/tmpq9xkdvr3.swift:9:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let smallest = numbers[0]\n\
    \    ^~~\n    var\n/tmp/tmpq9xkdvr3.swift:15:13: error: cannot assign to value:\
    \ 'largest' is a 'let' constant\n            largest = number\n            ^~~~~~~\n\
    /tmp/tmpq9xkdvr3.swift:10:5: note: change 'let' to 'var' to make it mutable\n\
    \    let largest = numbers[0]\n    ^~~\n    var\n"
  stdout: ''
  timestamp: 1660013731
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double])\
    \ -> (Double, Double) {\n    let smallest = min(numbers)\n    let largest = max(numbers)\n\
    \    return (smallest, largest)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpbwt_n_vu.swift:9:31: error: missing argument for parameter #2 in\
    \ call\n    let smallest = min(numbers)\n                              ^\n   \
    \                           , <#[Double]#>\nSwift.min:1:24: note: 'min' declared\
    \ here\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n\
    \                       ^\n/tmp/tmpbwt_n_vu.swift:10:30: error: missing argument\
    \ for parameter #2 in call\n    let largest = max(numbers)\n                 \
    \            ^\n                             , <#[Double]#>\nSwift.max:1:24: note:\
    \ 'max' declared here\n@inlinable public func max<T>(_ x: T, _ y: T) -> T where\
    \ T : Comparable\n                       ^\n"
  stdout: ''
  timestamp: 1660013731
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double])\
    \ -> (Double, Double) {\n    let min1 = min(numbers)\n    let max1 = max(numbers)\n\
    \    let min2 = min(numbers, min1)\n    let max2 = max(numbers, max1)\n    return\
    \ (min1, max1), (min2, max2)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmp9s606pmu.swift:13:24: error: consecutive statements on a line must\
    \ be separated by ';'\n    return (min1, max1), (min2, max2)\n               \
    \        ^\n                       ;\n/tmp/tmp9s606pmu.swift:13:24: error: expected\
    \ expression\n    return (min1, max1), (min2, max2)\n                       ^\n\
    /tmp/tmp9s606pmu.swift:9:27: error: missing argument for parameter #2 in call\n\
    \    let min1 = min(numbers)\n                          ^\n                  \
    \        , <#[Double]#>\nSwift.min:1:24: note: 'min' declared here\n@inlinable\
    \ public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n             \
    \          ^\n/tmp/tmp9s606pmu.swift:10:27: error: missing argument for parameter\
    \ #2 in call\n    let max1 = max(numbers)\n                          ^\n     \
    \                     , <#[Double]#>\nSwift.max:1:24: note: 'max' declared here\n\
    @inlinable public func max<T>(_ x: T, _ y: T) -> T where T : Comparable\n    \
    \                   ^\n"
  stdout: ''
  timestamp: 1660013733
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double])\
    \ -> (Double, Double) {\n    let smallest = min(numbers)\n    let largest = max(numbers)\n\
    \    return (smallest, largest)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpbwt_n_vu.swift:9:31: error: missing argument for parameter #2 in\
    \ call\n    let smallest = min(numbers)\n                              ^\n   \
    \                           , <#[Double]#>\nSwift.min:1:24: note: 'min' declared\
    \ here\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n\
    \                       ^\n/tmp/tmpbwt_n_vu.swift:10:30: error: missing argument\
    \ for parameter #2 in call\n    let largest = max(numbers)\n                 \
    \            ^\n                             , <#[Double]#>\nSwift.max:1:24: note:\
    \ 'max' declared here\n@inlinable public func max<T>(_ x: T, _ y: T) -> T where\
    \ T : Comparable\n                       ^\n"
  stdout: ''
  timestamp: 1660013731
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double])\
    \ -> (Double, Double) {\n    let min = numbers[0]\n    let max = numbers[0]\n\
    \    for number in numbers {\n        if number < min {\n            min = number\n\
    \        } else if number > max {\n            max = number\n        }\n    }\n\
    \    return (min, max)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmphqko5kpa.swift:13:13: error: cannot assign to value: 'min' is a\
    \ 'let' constant\n            min = number\n            ^~~\n/tmp/tmphqko5kpa.swift:9:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let min = numbers[0]\n \
    \   ^~~\n    var\n/tmp/tmphqko5kpa.swift:15:13: error: cannot assign to value:\
    \ 'max' is a 'let' constant\n            max = number\n            ^~~\n/tmp/tmphqko5kpa.swift:10:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let max = numbers[0]\n \
    \   ^~~\n    var\n"
  stdout: ''
  timestamp: 1660013733
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double])\
    \ -> (Double, Double) {\n    let smallest = numbers[0]\n    let largest = numbers[0]\n\
    \    for number in numbers {\n        if number < smallest {\n            smallest\
    \ = number\n        }\n        if number > largest {\n            largest = number\n\
    \        }\n    }\n    return (smallest, largest)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9,\
    \ 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmp5pls_p0p.swift:13:13: error: cannot assign to value: 'smallest'\
    \ is a 'let' constant\n            smallest = number\n            ^~~~~~~~\n/tmp/tmp5pls_p0p.swift:9:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let smallest = numbers[0]\n\
    \    ^~~\n    var\n/tmp/tmp5pls_p0p.swift:16:13: error: cannot assign to value:\
    \ 'largest' is a 'let' constant\n            largest = number\n            ^~~~~~~\n\
    /tmp/tmp5pls_p0p.swift:10:5: note: change 'let' to 'var' to make it mutable\n\
    \    let largest = numbers[0]\n    ^~~\n    var\n"
  stdout: ''
  timestamp: 1660013731
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double])\
    \ -> (Double, Double) {\n    let smallest = numbers[0]\n    let largest = numbers[0]\n\
    \    for number in numbers {\n        if number < smallest {\n            smallest\
    \ = number\n        }\n        if number > largest {\n            largest = number\n\
    \        }\n    }\n    return (smallest, largest)\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9,\
    \ 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmp5pls_p0p.swift:13:13: error: cannot assign to value: 'smallest'\
    \ is a 'let' constant\n            smallest = number\n            ^~~~~~~~\n/tmp/tmp5pls_p0p.swift:9:5:\
    \ note: change 'let' to 'var' to make it mutable\n    let smallest = numbers[0]\n\
    \    ^~~\n    var\n/tmp/tmp5pls_p0p.swift:16:13: error: cannot assign to value:\
    \ 'largest' is a 'let' constant\n            largest = number\n            ^~~~~~~\n\
    /tmp/tmp5pls_p0p.swift:10:5: note: change 'let' to 'var' to make it mutable\n\
    \    let largest = numbers[0]\n    ^~~\n    var\n"
  stdout: ''
  timestamp: 1660013731
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double])\
    \ -> (Double, Double) {\n    guard numbers.count >= 2 else {\n        return (0.0,0.0)\n\
    \    }\n    \n    let smallest = numbers[0]\n    let largest = numbers[0]\n  \
    \  \n    for i in 1..<numbers.count {\n        if numbers[i] > largest {\n   \
    \         largest = numbers[i]\n        }\n        if numbers[i] < smallest {\n\
    \            smallest = numbers[i]\n        }\n    }\n    \n    return (smallest,\
    \ largest)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpepidffpw.swift:18:13: error: cannot assign to value: 'largest'\
    \ is a 'let' constant\n            largest = numbers[i]\n            ^~~~~~~\n\
    /tmp/tmpepidffpw.swift:14:5: note: change 'let' to 'var' to make it mutable\n\
    \    let largest = numbers[0]\n    ^~~\n    var\n/tmp/tmpepidffpw.swift:21:13:\
    \ error: cannot assign to value: 'smallest' is a 'let' constant\n            smallest\
    \ = numbers[i]\n            ^~~~~~~~\n/tmp/tmpepidffpw.swift:13:5: note: change\
    \ 'let' to 'var' to make it mutable\n    let smallest = numbers[0]\n    ^~~\n\
    \    var\n"
  stdout: ''
  timestamp: 1660013733
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double])\
    \ -> (Double, Double) {\n    let smallest = min(numbers)\n    let largest = max(numbers)\n\
    \    return (smallest, largest)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpbwt_n_vu.swift:9:31: error: missing argument for parameter #2 in\
    \ call\n    let smallest = min(numbers)\n                              ^\n   \
    \                           , <#[Double]#>\nSwift.min:1:24: note: 'min' declared\
    \ here\n@inlinable public func min<T>(_ x: T, _ y: T) -> T where T : Comparable\n\
    \                       ^\n/tmp/tmpbwt_n_vu.swift:10:30: error: missing argument\
    \ for parameter #2 in call\n    let largest = max(numbers)\n                 \
    \            ^\n                             , <#[Double]#>\nSwift.max:1:24: note:\
    \ 'max' declared here\n@inlinable public func max<T>(_ x: T, _ y: T) -> T where\
    \ T : Comparable\n                       ^\n"
  stdout: ''
  timestamp: 1660013731
- exit_code: -4
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double])\
    \ -> (Double, Double) {\n    guard numbers.count >= 2 else { return (numbers[0],\
    \ numbers[0]) }\n    guard numbers.count >= 3 else { return (numbers[0], numbers[0])\
    \ }\n\n    var smallest = numbers[0]\n    var largest = numbers[0]\n    var smallestIndex\
    \ = -1\n    var largestIndex = -1\n\n    for i in 1..<numbers.count {\n      \
    \  if numbers[i] < smallest {\n            smallest = numbers[i]\n           \
    \ smallestIndex = i\n        }\n        if numbers[i] > largest {\n          \
    \  largest = numbers[i]\n            largestIndex = i\n        }\n    }\n\n  \
    \  return (numbers[smallestIndex], numbers[largestIndex])\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9, 4.0, 5.0,\
    \ 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0, 2.0, 5.9,\
    \ 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0, 2.0,\
    \ 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002ab738d50c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab738a47561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ab738a47286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ab738a4713c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ab738a46bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002ab738846f44 <unavailable> + 188228

    6    tmpj6pkmvhc                        0x000055c6bb635f7e <unavailable> + 8062

    7    tmpj6pkmvhc                        0x000055c6bb6355cd <unavailable> + 5581

    8    libc.so.6                          0x00002ab738f3c460 __libc_start_main +
    245

    9    tmpj6pkmvhc                        0x000055c6bb635279 <unavailable> + 4729

    '
  stdout: ''
  timestamp: 1660013732
- exit_code: 1
  program: "\n/// From a supplied list of numbers (of length at least two) select\
    \ and return two that are the closest to each\n/// other and return them in order\
    \ (smaller number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0,\
    \ 4.0, 5.0, 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double])\
    \ -> (Double, Double) {\n    guard numbers.count >= 2 else {\n        return (0.0,0.0)\n\
    \    }\n    let smallest = numbers[0]\n    let largest = numbers[0]\n    for i\
    \ in 1..<numbers.count {\n        if numbers[i] < smallest {\n            smallest\
    \ = numbers[i]\n        }\n        if numbers[i] > largest {\n            largest\
    \ = numbers[i]\n        }\n    }\n    return (smallest, largest)\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0, 3.9,\
    \ 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
    \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
    \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
    \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
  status: SyntaxError
  stderr: "/tmp/tmpittqridb.swift:16:13: error: cannot assign to value: 'smallest'\
    \ is a 'let' constant\n            smallest = numbers[i]\n            ^~~~~~~~\n\
    /tmp/tmpittqridb.swift:12:5: note: change 'let' to 'var' to make it mutable\n\
    \    let smallest = numbers[0]\n    ^~~\n    var\n/tmp/tmpittqridb.swift:19:13:\
    \ error: cannot assign to value: 'largest' is a 'let' constant\n            largest\
    \ = numbers[i]\n            ^~~~~~~\n/tmp/tmpittqridb.swift:13:5: note: change\
    \ 'let' to 'var' to make it mutable\n    let largest = numbers[0]\n    ^~~\n \
    \   var\n"
  stdout: ''
  timestamp: 1660013732
