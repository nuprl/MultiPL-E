language: swift
name: HumanEval_12_longest
results:
- exit_code: -4
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    var longest = strings[0]\n    for s in strings {\n\
    \        if s.count > longest.count {\n            longest = s\n        }\n  \
    \  }\n    return longest\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(longest(strings:\
    \ [] as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"\
    x\")\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"\
    abc\"]) == \"zzzz\")"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b09c306cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b09c2d63561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b09c2d63286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b09c2d6313c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b09c2d62bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b09c2b62fc3 <unavailable> + 188355

    6    tmppj_u88gq                        0x0000563c7c97cdd2 <unavailable> + 7634

    7    tmppj_u88gq                        0x0000563c7c97c590 <unavailable> + 5520

    8    libc.so.6                          0x00002b09c3258460 __libc_start_main +
    245

    9    tmppj_u88gq                        0x0000563c7c97c299 <unavailable> + 4761

    '
  stdout: ''
  timestamp: 1660013921
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longest = strings[0]\n    for s in strings {\n        if longest.count\
    \ < s.count {\n            longest = s\n        }\n    }\n    return longest\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013921
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longest = strings[0]\n    for s in strings {\n        if longest.count\
    \ < s.count {\n            longest = s\n        }\n    }\n    return longest\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013921
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longest = strings[0]\n    for s in strings {\n        if longest.count\
    \ < s.count {\n            longest = s\n        }\n    }\n    return longest\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013921
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longest = strings[0]\n    for s in strings {\n        if s.count > longest.count\
    \ {\n            longest = s\n        }\n    }\n    return longest\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013921
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \n    var longest = strings[0]\n    for string in strings {\n        if string.count\
    \ > longest.count {\n            longest = string\n        }\n    }\n\n    return\
    \ longest\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(longest(strings: []\
    \ as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"x\"\
    )\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"\
    ]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013921
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longest = strings[0]\n    for s in strings {\n        if longest.count\
    \ < s.count {\n            longest = s\n        }\n    }\n    return longest\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013921
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longest = strings[0]\n    for s in strings {\n        if s.count > longest.count\
    \ {\n            longest = s\n        }\n    }\n    return longest\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013921
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \n    var longest = strings[0]\n    for s in strings {\n        if longest.count\
    \ < s.count {\n            longest = s\n        }\n    }\n\n    return longest\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013921
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longest = strings[0]\n    for s in strings {\n        if longest.count\
    \ < s.count {\n            longest = s\n        }\n    }\n    return longest\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013921
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longest = strings[0]\n    for s in strings {\n        if longest.count\
    \ < s.count {\n            longest = s\n        }\n    }\n    return longest\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013921
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \n    var longest = strings[0]\n    for s in strings {\n        if s.count > longest.count\
    \ {\n            longest = s\n        }\n    }\n    return longest\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013921
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \n    var longest = strings[0]\n    for s in strings {\n        if s.count > longest.count\
    \ {\n            longest = s\n        }\n    }\n    return longest\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013921
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    let longest = strings.reduce(\"\") {\n        if $0.count < $1.count {\n\
    \            return $1\n        } else {\n            return $0\n        }\n \
    \   }\n    return longest\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(longest(strings:\
    \ [] as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"\
    x\")\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"\
    abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013921
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longest = strings[0]\n    for s in strings {\n        if longest.count\
    \ < s.count {\n            longest = s\n        }\n    }\n    return longest\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013921
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longest = strings[0]\n    for s in strings {\n        if s.count > longest.count\
    \ {\n            longest = s\n        }\n    }\n    return longest\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013921
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longest = strings[0]\n    for string in strings {\n        if string.count\
    \ > longest.count {\n            longest = string\n        }\n    }\n    return\
    \ longest\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(longest(strings: []\
    \ as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"x\"\
    )\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"\
    ]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013769
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longest = strings[0]\n    for s in strings {\n        if s.count > longest.count\
    \ {\n            longest = s\n        }\n    }\n    return longest\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013921
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longest = strings[0]\n    for s in strings {\n        if longest.count\
    \ < s.count {\n            longest = s\n        }\n    }\n    return longest\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013921
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longest = strings[0]\n    for s in strings {\n        if s.count > longest.count\
    \ {\n            longest = s\n        }\n    }\n    return longest\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013921
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longest = strings[0]\n    for s in strings {\n        if s.count > longest.count\
    \ {\n            longest = s\n        }\n    }\n    return longest\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013921
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longest = strings[0]\n    for s in strings {\n        if longest.count\
    \ < s.count {\n            longest = s\n        }\n    }\n    return longest\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013921
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longest = strings[0]\n    for s in strings {\n        if s.count > longest.count\
    \ {\n            longest = s\n        }\n    }\n    return longest\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013921
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \n    var longest = strings[0]\n    for s in strings {\n        if s.count > longest.count\
    \ {\n            longest = s\n        }\n    }\n\n    return longest\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013921
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longest = strings[0]\n    for s in strings {\n        if s.count > longest.count\
    \ {\n            longest = s\n        }\n    }\n    return longest\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013921
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longest = strings[0]\n    for string in strings {\n        if string.count\
    \ > longest.count {\n            longest = string\n        }\n    }\n    return\
    \ longest\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(longest(strings: []\
    \ as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"x\"\
    )\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"\
    ]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013769
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longest = strings[0]\n    for s in strings {\n        if longest.count\
    \ < s.count {\n            longest = s\n        }\n    }\n    return longest\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013921
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longest = strings[0]\n    for s in strings {\n        if s.count > longest.count\
    \ {\n            longest = s\n        }\n    }\n    return longest\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013921
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    let longest = strings.reduce(\"\") { (result, string) -> String in\n    \
    \    if result.count < string.count {\n            return string\n        } else\
    \ {\n            return result\n        }\n    }\n    return longest\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013921
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longest = strings[0]\n    for s in strings {\n        if s.count > longest.count\
    \ {\n            longest = s\n        }\n    }\n    return longest\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013921
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longest = strings[0]\n    for s in strings {\n        if longest.count\
    \ < s.count {\n            longest = s\n        }\n    }\n    return longest\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013921
- exit_code: -4
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    var longest = strings[0]\n    for s in strings {\n\
    \        if longest.count < s.count {\n            longest = s\n        }\n  \
    \  }\n    return longest\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(longest(strings:\
    \ [] as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"\
    x\")\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"\
    abc\"]) == \"zzzz\")"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b7c7b6b6c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b7c7b3ad561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b7c7b3ad286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b7c7b3ad13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b7c7b3acbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b7c7b1acfc3 <unavailable> + 188355

    6    tmpkxcyoeiq                        0x000055918c464dd2 <unavailable> + 7634

    7    tmpkxcyoeiq                        0x000055918c464590 <unavailable> + 5520

    8    libc.so.6                          0x00002b7c7b8a2460 __libc_start_main +
    245

    9    tmpkxcyoeiq                        0x000055918c464299 <unavailable> + 4761

    '
  stdout: ''
  timestamp: 1660013921
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longest = strings[0]\n    for s in strings {\n        if longest.count\
    \ < s.count {\n            longest = s\n        }\n    }\n    return longest\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013921
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longest = strings[0]\n    for string in strings {\n        if string.count\
    \ > longest.count {\n            longest = string\n        }\n    }\n    return\
    \ longest\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(longest(strings: []\
    \ as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"x\"\
    )\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"\
    ]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013769
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longest = strings[0]\n    for s in strings {\n        if longest.count\
    \ < s.count {\n            longest = s\n        }\n    }\n    return longest\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013921
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longest = strings[0]\n    for s in strings {\n        if s.count > longest.count\
    \ {\n            longest = s\n        }\n    }\n    return longest\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013921
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longest = strings[0]\n    for s in strings {\n        if s.count > longest.count\
    \ {\n            longest = s\n        }\n    }\n    return longest\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013921
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longest = strings[0]\n    for s in strings {\n        if longest.count\
    \ < s.count {\n            longest = s\n        }\n    }\n    return longest\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013921
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longest = strings[0]\n    for s in strings {\n        if longest.count\
    \ < s.count {\n            longest = s\n        }\n    }\n    return longest\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013921
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longest = strings[0]\n    for s in strings {\n        if s.count > longest.count\
    \ {\n            longest = s\n        }\n    }\n    return longest\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013921
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longest = strings[0]\n    for string in strings {\n        if string.count\
    \ > longest.count {\n            longest = string\n        }\n    }\n    return\
    \ longest\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(longest(strings: []\
    \ as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"x\"\
    )\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"\
    ]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013769
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \n    var longest = strings[0]\n    for s in strings {\n        if s.count > longest.count\
    \ {\n            longest = s\n        }\n    }\n\n    return longest\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013921
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longest = strings[0]\n    for s in strings {\n        if longest.count\
    \ < s.count {\n            longest = s\n        }\n    }\n    return longest\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013921
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longest = strings[0]\n    for s in strings {\n        if s.count > longest.count\
    \ {\n            longest = s\n        }\n    }\n    return longest\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013921
- exit_code: -4
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    var longest = strings[0]\n    for string in strings.dropFirst()\
    \ {\n        if string.count > longest.count {\n            longest = string\n\
    \        }\n    }\n    return longest\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(longest(strings: [] as [String]) == nil)\nassert(longest(strings: [\"x\"\
    , \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\"\
    , \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b2b6fb96c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b2b6f88d561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b2b6f88d286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b2b6f88d13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b2b6f88cbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b2b6f68cfc3 <unavailable> + 188355

    6    tmplc0to5b6                        0x000055b45d7f1ecb <unavailable> + 7883

    7    tmplc0to5b6                        0x000055b45d7f1680 <unavailable> + 5760

    8    libc.so.6                          0x00002b2b6fd82460 __libc_start_main +
    245

    9    tmplc0to5b6                        0x000055b45d7f1389 <unavailable> + 5001

    '
  stdout: ''
  timestamp: 1660013921
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longest = strings[0]\n    for string in strings {\n        if string.count\
    \ > longest.count {\n            longest = string\n        }\n    }\n    return\
    \ longest\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(longest(strings: []\
    \ as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"x\"\
    )\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"\
    ]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013769
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longest = strings[0]\n    for string in strings {\n        if string.count\
    \ > longest.count {\n            longest = string\n        }\n    }\n    return\
    \ longest\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(longest(strings: []\
    \ as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"x\"\
    )\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"\
    ]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013769
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longest = strings[0]\n    for s in strings {\n        if longest.count\
    \ < s.count {\n            longest = s\n        }\n    }\n    return longest\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013921
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longest = strings[0]\n    for string in strings.dropFirst() {\n     \
    \   if string.count > longest.count {\n            longest = string\n        }\n\
    \    }\n    return longest\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(longest(strings:\
    \ [] as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"\
    x\")\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"\
    abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013921
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longest = strings[0]\n    for s in strings {\n        if longest.count\
    \ < s.count {\n            longest = s\n        }\n    }\n    return longest\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013921
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longest = strings[0]\n    for string in strings {\n        if string.count\
    \ > longest.count {\n            longest = string\n        }\n    }\n    return\
    \ longest\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(longest(strings: []\
    \ as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"x\"\
    )\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"\
    ]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013769
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longest = strings[0]\n    for s in strings {\n        if s.count > longest.count\
    \ {\n            longest = s\n        }\n    }\n    return longest\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013921
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longest = strings[0]\n    for s in strings {\n        if s.count > longest.count\
    \ {\n            longest = s\n        }\n    }\n    return longest\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013921
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longest = strings[0]\n    for string in strings {\n        if string.count\
    \ > longest.count {\n            longest = string\n        }\n    }\n    return\
    \ longest\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(longest(strings: []\
    \ as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"x\"\
    )\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"\
    ]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013769
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \n    var longest = strings[0]\n    for s in strings {\n        if s.count > longest.count\
    \ {\n            longest = s\n        }\n    }\n\n    return longest\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013921
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longest = strings[0]\n    for string in strings {\n        if string.count\
    \ > longest.count {\n            longest = string\n        }\n    }\n    return\
    \ longest\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(longest(strings: []\
    \ as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"x\"\
    )\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"\
    ]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013769
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longest = strings[0]\n    for string in strings {\n        if string.count\
    \ > longest.count {\n            longest = string\n        }\n    }\n    return\
    \ longest\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(longest(strings: []\
    \ as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"x\"\
    )\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"\
    ]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013769
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longest = strings[0]\n    for s in strings {\n        if s.count > longest.count\
    \ {\n            longest = s\n        }\n    }\n    return longest\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013921
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    let longest = strings.reduce(\"\") { (result, string) in\n        if result.count\
    \ < string.count {\n            return string\n        } else {\n            return\
    \ result\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013921
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longest = strings[0]\n    for s in strings {\n        if longest.count\
    \ < s.count {\n            longest = s\n        }\n    }\n    return longest\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013921
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longest = strings[0]\n    for string in strings {\n        if string.count\
    \ > longest.count {\n            longest = string\n        }\n    }\n    return\
    \ longest\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(longest(strings: []\
    \ as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"x\"\
    )\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"\
    ]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013769
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longest = strings[0]\n    for s in strings {\n        if s.count > longest.count\
    \ {\n            longest = s\n        }\n    }\n    return longest\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013921
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longest = strings[0]\n    for s in strings {\n        if s.count > longest.count\
    \ {\n            longest = s\n        }\n    }\n    return longest\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013921
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \n    var longest = strings[0]\n    for string in strings {\n        if string.count\
    \ > longest.count {\n            longest = string\n        }\n    }\n\n    return\
    \ longest\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(longest(strings: []\
    \ as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"x\"\
    )\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"\
    ]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013921
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longest = strings[0]\n    for s in strings {\n        if s.count > longest.count\
    \ {\n            longest = s\n        }\n    }\n    return longest\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013921
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longest = strings[0]\n    for s in strings {\n        if s.count > longest.count\
    \ {\n            longest = s\n        }\n    }\n    return longest\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013921
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longest = strings[0]\n    for s in strings {\n        if longest.count\
    \ < s.count {\n            longest = s\n        }\n    }\n    return longest\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013921
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longest = strings[0]\n    for s in strings {\n        if s.count > longest.count\
    \ {\n            longest = s\n        }\n    }\n    return longest\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013921
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longest = strings[0]\n    for s in strings {\n        if s.count > longest.count\
    \ {\n            longest = s\n        }\n    }\n    return longest\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013921
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \n    var longest = strings[0]\n    for s in strings {\n        if s.count > longest.count\
    \ {\n            longest = s\n        }\n    }\n\n    return longest\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013921
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longest = strings[0]\n    for s in strings {\n        if s.count > longest.count\
    \ {\n            longest = s\n        }\n    }\n    return longest\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013921
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longest = strings[0]\n    for s in strings {\n        if longest.count\
    \ < s.count {\n            longest = s\n        }\n    }\n    return longest\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013921
- exit_code: -4
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    var longest = strings[0]\n    for s in strings {\n\
    \        if longest.count < s.count {\n            longest = s\n        }\n  \
    \  }\n    return longest\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(longest(strings:\
    \ [] as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"\
    x\")\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"\
    abc\"]) == \"zzzz\")"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b7c7b6b6c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b7c7b3ad561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b7c7b3ad286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b7c7b3ad13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b7c7b3acbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b7c7b1acfc3 <unavailable> + 188355

    6    tmpkxcyoeiq                        0x000055918c464dd2 <unavailable> + 7634

    7    tmpkxcyoeiq                        0x000055918c464590 <unavailable> + 5520

    8    libc.so.6                          0x00002b7c7b8a2460 __libc_start_main +
    245

    9    tmpkxcyoeiq                        0x000055918c464299 <unavailable> + 4761

    '
  stdout: ''
  timestamp: 1660013921
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longest = strings[0]\n    for s in strings {\n        if s.count > longest.count\
    \ {\n            longest = s\n        }\n    }\n    return longest\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013921
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longest = strings[0]\n    for string in strings {\n        if string.count\
    \ > longest.count {\n            longest = string\n        }\n    }\n    return\
    \ longest\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(longest(strings: []\
    \ as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"x\"\
    )\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"\
    ]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013769
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longest = strings[0]\n    for s in strings {\n        if longest.count\
    \ < s.count {\n            longest = s\n        }\n    }\n    return longest\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013921
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longest = strings[0]\n    for s in strings {\n        if s.count > longest.count\
    \ {\n            longest = s\n        }\n    }\n    return longest\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013921
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longest = strings[0]\n    for string in strings {\n        if string.count\
    \ > longest.count {\n            longest = string\n        }\n    }\n    return\
    \ longest\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(longest(strings: []\
    \ as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"x\"\
    )\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"\
    ]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013769
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longest = strings[0]\n    for string in strings {\n        if string.count\
    \ > longest.count {\n            longest = string\n        }\n    }\n    return\
    \ longest\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(longest(strings: []\
    \ as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"x\"\
    )\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"\
    ]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013769
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \n    var longest = strings[0]\n    for s in strings {\n        if s.count > longest.count\
    \ {\n            longest = s\n        }\n    }\n    return longest\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013921
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \n    var longest = strings[0]\n    for s in strings {\n        if s.count > longest.count\
    \ {\n            longest = s\n        }\n    }\n    return longest\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013921
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longest = strings[0]\n    for string in strings {\n        if string.count\
    \ > longest.count {\n            longest = string\n        }\n    }\n    return\
    \ longest\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(longest(strings: []\
    \ as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"x\"\
    )\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"\
    ]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013769
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longest = strings[0]\n    for s in strings {\n        if s.count > longest.count\
    \ {\n            longest = s\n        }\n    }\n    return longest\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013921
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \n    var longest = strings[0]\n    for s in strings {\n        if s.count > longest.count\
    \ {\n            longest = s\n        }\n    }\n\n    return longest\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013921
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longest = strings[0]\n    for s in strings {\n        if longest.count\
    \ < s.count {\n            longest = s\n        }\n    }\n    return longest\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013921
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \n    var longest = strings[0]\n    for s in strings {\n        if s.count > longest.count\
    \ {\n            longest = s\n        }\n    }\n\n    return longest\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013921
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longest = strings[0]\n    for string in strings {\n        if string.count\
    \ > longest.count {\n            longest = string\n        }\n    }\n    return\
    \ longest\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(longest(strings: []\
    \ as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"x\"\
    )\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"\
    ]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013769
- exit_code: -4
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    var longest = strings[0]\n    for s in strings {\n\
    \        if s.count > longest.count {\n            longest = s\n        }\n  \
    \  }\n    return longest\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(longest(strings:\
    \ [] as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"\
    x\")\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"\
    abc\"]) == \"zzzz\")"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b09c306cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b09c2d63561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b09c2d63286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b09c2d6313c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b09c2d62bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b09c2b62fc3 <unavailable> + 188355

    6    tmppj_u88gq                        0x0000563c7c97cdd2 <unavailable> + 7634

    7    tmppj_u88gq                        0x0000563c7c97c590 <unavailable> + 5520

    8    libc.so.6                          0x00002b09c3258460 __libc_start_main +
    245

    9    tmppj_u88gq                        0x0000563c7c97c299 <unavailable> + 4761

    '
  stdout: ''
  timestamp: 1660013921
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longest = strings[0]\n    for s in strings {\n        if s.count > longest.count\
    \ {\n            longest = s\n        }\n    }\n    return longest\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013921
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longest = strings[0]\n    for s in strings {\n        if s.count > longest.count\
    \ {\n            longest = s\n        }\n    }\n    return longest\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013921
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longest = strings[0]\n    for s in strings {\n        if s.count > longest.count\
    \ {\n            longest = s\n        }\n    }\n    return longest\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013921
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longest = strings[0]\n    for s in strings {\n        if s.count > longest.count\
    \ {\n            longest = s\n        }\n    }\n    return longest\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013921
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \n    var longest = strings[0]\n    for string in strings {\n        if string.count\
    \ > longest.count {\n            longest = string\n        }\n    }\n    return\
    \ longest\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(longest(strings: []\
    \ as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"x\"\
    )\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"\
    ]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013921
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \n    var longest = strings[0]\n    for string in strings {\n        if string.count\
    \ > longest.count {\n            longest = string\n        }\n    }\n    return\
    \ longest\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(longest(strings: []\
    \ as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"x\"\
    )\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"\
    ]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013921
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longest = strings[0]\n    for string in strings {\n        if string.count\
    \ > longest.count {\n            longest = string\n        }\n    }\n    return\
    \ longest\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(longest(strings: []\
    \ as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"x\"\
    )\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"\
    ]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013769
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longest = strings[0]\n    for string in strings {\n        if string.count\
    \ > longest.count {\n            longest = string\n        }\n    }\n    return\
    \ longest\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(longest(strings: []\
    \ as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"x\"\
    )\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"\
    ]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013769
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \n    var longest = strings[0]\n    for s in strings {\n        if s.count > longest.count\
    \ {\n            longest = s\n        }\n    }\n\n    return longest\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013921
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longest = strings[0]\n    for s in strings {\n        if longest.count\
    \ < s.count {\n            longest = s\n        }\n    }\n    return longest\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013921
- exit_code: -4
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    var longest = strings[0]\n    for s in strings {\n\
    \        if longest.count < s.count {\n            longest = s\n        }\n  \
    \  }\n    return longest\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(longest(strings:\
    \ [] as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"\
    x\")\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"\
    abc\"]) == \"zzzz\")"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b7c7b6b6c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b7c7b3ad561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b7c7b3ad286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b7c7b3ad13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b7c7b3acbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b7c7b1acfc3 <unavailable> + 188355

    6    tmpkxcyoeiq                        0x000055918c464dd2 <unavailable> + 7634

    7    tmpkxcyoeiq                        0x000055918c464590 <unavailable> + 5520

    8    libc.so.6                          0x00002b7c7b8a2460 __libc_start_main +
    245

    9    tmpkxcyoeiq                        0x000055918c464299 <unavailable> + 4761

    '
  stdout: ''
  timestamp: 1660013921
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \n    var longest = strings[0]\n    for string in strings {\n        if string.count\
    \ > longest.count {\n            longest = string\n        }\n    }\n    return\
    \ longest\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(longest(strings: []\
    \ as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"x\"\
    )\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"\
    ]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013921
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longest = strings[0]\n    for s in strings {\n        if longest.count\
    \ < s.count {\n            longest = s\n        }\n    }\n    return longest\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013921
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longest = strings[0]\n    for s in strings {\n        if s.count > longest.count\
    \ {\n            longest = s\n        }\n    }\n    return longest\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013921
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longest = strings[0]\n    for s in strings {\n        if longest.count\
    \ < s.count {\n            longest = s\n        }\n    }\n    return longest\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013921
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longest = strings[0]\n    for s in strings {\n        if longest.count\
    \ < s.count {\n            longest = s\n        }\n    }\n    return longest\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013921
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longest = strings[0]\n    for s in strings {\n        if s.count > longest.count\
    \ {\n            longest = s\n        }\n    }\n    return longest\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013921
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \n    var longest = strings[0]\n    for s in strings {\n        if s.count > longest.count\
    \ {\n            longest = s\n        }\n    }\n\n    return longest\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013921
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longest = strings[0]\n    for string in strings {\n        if string.count\
    \ > longest.count {\n            longest = string\n        }\n    }\n    return\
    \ longest\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(longest(strings: []\
    \ as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"x\"\
    )\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"\
    ]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013769
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longest = strings[0]\n    for s in strings {\n        if s.count > longest.count\
    \ {\n            longest = s\n        }\n    }\n    return longest\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013921
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longest = strings[0]\n    for s in strings {\n        if s.count > longest.count\
    \ {\n            longest = s\n        }\n    }\n    return longest\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013921
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longest = strings[0]\n    for s in strings {\n        if s.count > longest.count\
    \ {\n            longest = s\n        }\n    }\n    return longest\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013921
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    let longest = strings.reduce(\"\") {\n        if $0.count < $1.count {\n\
    \            return $1\n        } else {\n            return $0\n        }\n \
    \   }\n    return longest\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(longest(strings:\
    \ [] as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"\
    x\")\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"\
    abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013921
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longest = strings[0]\n    for s in strings {\n        if longest.count\
    \ < s.count {\n            longest = s\n        }\n    }\n    return longest\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013921
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longest = strings[0]\n    for s in strings {\n        if s.count > longest.count\
    \ {\n            longest = s\n        }\n    }\n    return longest\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013921
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longest = strings[0]\n    for string in strings {\n        if string.count\
    \ > longest.count {\n            longest = string\n        }\n    }\n    return\
    \ longest\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(longest(strings: []\
    \ as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"x\"\
    )\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"\
    ]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013769
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longest = strings[0]\n    for s in strings {\n        if longest.count\
    \ < s.count {\n            longest = s\n        }\n    }\n    return longest\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013921
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longest = strings[0]\n    for string in strings {\n        if string.count\
    \ > longest.count {\n            longest = string\n        }\n    }\n    return\
    \ longest\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(longest(strings: []\
    \ as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"x\"\
    )\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"\
    ]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013769
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \n    var longest = strings[0]\n    for string in strings {\n        if string.count\
    \ > longest.count {\n            longest = string\n        }\n    }\n\n    return\
    \ longest\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(longest(strings: []\
    \ as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"x\"\
    )\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"\
    ]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013921
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \n    var longest = strings[0]\n    for string in strings {\n        if string.count\
    \ > longest.count {\n            longest = string\n        }\n    }\n    return\
    \ longest\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(longest(strings: []\
    \ as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"x\"\
    )\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"\
    ]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013921
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longest = strings[0]\n    for s in strings {\n        if s.count > longest.count\
    \ {\n            longest = s\n        }\n    }\n    return longest\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013921
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longest = strings[0]\n    for s in strings {\n        if s.count > longest.count\
    \ {\n            longest = s\n        }\n    }\n    return longest\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013921
- exit_code: -4
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    var longest = strings[0]\n    for s in strings {\n\
    \        if longest.count < s.count {\n            longest = s\n        }\n  \
    \  }\n    return longest\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(longest(strings:\
    \ [] as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"\
    x\")\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"\
    abc\"]) == \"zzzz\")"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b7c7b6b6c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b7c7b3ad561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b7c7b3ad286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b7c7b3ad13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b7c7b3acbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b7c7b1acfc3 <unavailable> + 188355

    6    tmpkxcyoeiq                        0x000055918c464dd2 <unavailable> + 7634

    7    tmpkxcyoeiq                        0x000055918c464590 <unavailable> + 5520

    8    libc.so.6                          0x00002b7c7b8a2460 __libc_start_main +
    245

    9    tmpkxcyoeiq                        0x000055918c464299 <unavailable> + 4761

    '
  stdout: ''
  timestamp: 1660013921
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longest = strings[0]\n    for s in strings {\n        if longest.count\
    \ < s.count {\n            longest = s\n        }\n    }\n    return longest\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013921
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longest = strings[0]\n    for s in strings {\n        if s.count > longest.count\
    \ {\n            longest = s\n        }\n    }\n    return longest\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013921
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longest = strings[0]\n    for s in strings {\n        if s.count > longest.count\
    \ {\n            longest = s\n        }\n    }\n    return longest\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013921
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \n    var longest = strings[0]\n    for s in strings {\n        if s.count > longest.count\
    \ {\n            longest = s\n        }\n    }\n\n    return longest\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013921
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longest = strings[0]\n    for s in strings {\n        if longest.count\
    \ < s.count {\n            longest = s\n        }\n    }\n    return longest\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013921
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longest = strings[0]\n    for s in strings {\n        if longest.count\
    \ < s.count {\n            longest = s\n        }\n    }\n    return longest\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013921
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    let longest = strings.reduce(\"\") {\n        if $0.count < $1.count {\n\
    \            return $1\n        } else {\n            return $0\n        }\n \
    \   }\n    return longest\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(longest(strings:\
    \ [] as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"\
    x\")\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"\
    abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013921
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longest = strings[0]\n    for s in strings {\n        if s.count > longest.count\
    \ {\n            longest = s\n        }\n    }\n    return longest\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013921
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longest = strings[0]\n    for string in strings {\n        if string.count\
    \ > longest.count {\n            longest = string\n        }\n    }\n    return\
    \ longest\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(longest(strings: []\
    \ as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"x\"\
    )\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"\
    ]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013769
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longest = strings[0]\n    for s in strings {\n        if s.count > longest.count\
    \ {\n            longest = s\n        }\n    }\n    return longest\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013921
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longest = strings[0]\n    for string in strings {\n        if string.count\
    \ > longest.count {\n            longest = string\n        }\n    }\n    return\
    \ longest\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(longest(strings: []\
    \ as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"x\"\
    )\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"\
    ]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013769
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longest = strings[0]\n    for s in strings {\n        if s.count > longest.count\
    \ {\n            longest = s\n        }\n    }\n    return longest\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013921
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longest = strings[0]\n    for s in strings {\n        if longest.count\
    \ < s.count {\n            longest = s\n        }\n    }\n    return longest\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013921
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longest = strings[0]\n    for s in strings {\n        if s.count > longest.count\
    \ {\n            longest = s\n        }\n    }\n    return longest\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013921
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    let longest = strings.reduce(\"\") {\n        if $0.count < $1.count {\n\
    \            return $1\n        } else {\n            return $0\n        }\n \
    \   }\n    return longest\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(longest(strings:\
    \ [] as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"\
    x\")\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"\
    abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013921
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longest = strings[0]\n    for s in strings {\n        if s.count > longest.count\
    \ {\n            longest = s\n        }\n    }\n    return longest\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013921
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longest = strings[0]\n    for s in strings {\n        if s.count > longest.count\
    \ {\n            longest = s\n        }\n    }\n    return longest\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013921
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    let longest = strings.reduce(\"\") { (result, string) in\n        if result.count\
    \ < string.count {\n            return string\n        } else {\n            return\
    \ result\n        }\n    }\n    return longest\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013921
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \n    var longest = strings[0]\n    for s in strings {\n        if s.count > longest.count\
    \ {\n            longest = s\n        }\n    }\n\n    return longest\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013921
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \n    var longest = strings[0]\n    for string in strings {\n        if string.count\
    \ > longest.count {\n            longest = string\n        }\n    }\n    return\
    \ longest\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(longest(strings: []\
    \ as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"x\"\
    )\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"\
    ]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013921
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longest = strings[0]\n    for s in strings {\n        if s.count > longest.count\
    \ {\n            longest = s\n        }\n    }\n    return longest\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013921
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longest = strings[0]\n    for s in strings {\n        if s.count > longest.count\
    \ {\n            longest = s\n        }\n    }\n    return longest\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013921
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longest = strings[0]\n    for s in strings {\n        if longest.count\
    \ < s.count {\n            longest = s\n        }\n    }\n    return longest\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013921
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longest = strings[0]\n    for s in strings {\n        if longest.count\
    \ < s.count {\n            longest = s\n        }\n    }\n    return longest\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013921
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longest = strings[0]\n    for s in strings {\n        if s.count > longest.count\
    \ {\n            longest = s\n        }\n    }\n    return longest\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013921
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longest = strings[0]\n    for string in strings {\n        if string.count\
    \ > longest.count {\n            longest = string\n        }\n    }\n    return\
    \ longest\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(longest(strings: []\
    \ as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"x\"\
    )\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"\
    ]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013769
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longest = strings[0]\n    for s in strings {\n        if longest.count\
    \ < s.count {\n            longest = s\n        }\n    }\n    return longest\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013921
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longest = strings[0]\n    for string in strings {\n        if string.count\
    \ > longest.count {\n            longest = string\n        }\n    }\n    return\
    \ longest\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(longest(strings: []\
    \ as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"x\"\
    )\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"\
    ]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013769
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \n    var longest = strings[0]\n    for s in strings {\n        if s.count > longest.count\
    \ {\n            longest = s\n        }\n    }\n    return longest\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013921
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longest = strings[0]\n    for string in strings {\n        if string.count\
    \ > longest.count {\n            longest = string\n        }\n    }\n    return\
    \ longest\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(longest(strings: []\
    \ as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"x\"\
    )\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"\
    ]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013769
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \n    var longest = strings[0]\n    for s in strings {\n        if longest.count\
    \ < s.count {\n            longest = s\n        }\n    }\n    return longest\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013921
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \n    var longest = strings[0]\n    for s in strings {\n        if s.count > longest.count\
    \ {\n            longest = s\n        }\n    }\n\n    return longest\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013921
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longest = strings[0]\n    for s in strings {\n        if longest.count\
    \ < s.count {\n            longest = s\n        }\n    }\n    return longest\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013921
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longest = strings[0]\n    for s in strings {\n        if longest.count\
    \ < s.count {\n            longest = s\n        }\n    }\n    return longest\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013921
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \n    var longest = strings[0]\n    for string in strings {\n        if string.count\
    \ > longest.count {\n            longest = string\n        }\n    }\n\n    return\
    \ longest\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(longest(strings: []\
    \ as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"x\"\
    )\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"\
    ]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013921
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \n    var longest = strings[0]\n    for s in strings {\n        if s.count > longest.count\
    \ {\n            longest = s\n        }\n    }\n\n    return longest\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013921
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longest = strings[0]\n    for s in strings {\n        if longest.count\
    \ < s.count {\n            longest = s\n        }\n    }\n    return longest\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013921
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longest = strings[0]\n    for s in strings {\n        if s.count > longest.count\
    \ {\n            longest = s\n        }\n    }\n    return longest\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013921
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \n    var longest = strings[0]\n    for s in strings {\n        if s.count > longest.count\
    \ {\n            longest = s\n        }\n    }\n\n    return longest\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013921
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longest = strings[0]\n    for s in strings {\n        if s.count > longest.count\
    \ {\n            longest = s\n        }\n    }\n    return longest\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013921
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longest = strings[0]\n    for s in strings {\n        if s.count > longest.count\
    \ {\n            longest = s\n        }\n    }\n    return longest\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013921
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longest = strings[0]\n    for s in strings {\n        if s.count > longest.count\
    \ {\n            longest = s\n        }\n    }\n    return longest\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013921
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longest = strings[0]\n    for s in strings {\n        if s.count > longest.count\
    \ {\n            longest = s\n        }\n    }\n    return longest\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013921
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longest = strings[0]\n    for s in strings {\n        if s.count > longest.count\
    \ {\n            longest = s\n        }\n    }\n    return longest\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013921
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longest = strings[0]\n    for s in strings {\n        if s.count > longest.count\
    \ {\n            longest = s\n        }\n    }\n    return longest\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013921
- exit_code: -4
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    var longest = strings[0]\n    for s in strings {\n\
    \        if longest.count < s.count {\n            longest = s\n        }\n  \
    \  }\n    return longest\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(longest(strings:\
    \ [] as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"\
    x\")\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"\
    abc\"]) == \"zzzz\")"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b7c7b6b6c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b7c7b3ad561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b7c7b3ad286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b7c7b3ad13c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b7c7b3acbb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b7c7b1acfc3 <unavailable> + 188355

    6    tmpkxcyoeiq                        0x000055918c464dd2 <unavailable> + 7634

    7    tmpkxcyoeiq                        0x000055918c464590 <unavailable> + 5520

    8    libc.so.6                          0x00002b7c7b8a2460 __libc_start_main +
    245

    9    tmpkxcyoeiq                        0x000055918c464299 <unavailable> + 4761

    '
  stdout: ''
  timestamp: 1660013921
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longest = strings[0]\n    for s in strings {\n        if s.count > longest.count\
    \ {\n            longest = s\n        }\n    }\n    return longest\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013921
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longest = strings[0]\n    for string in strings {\n        if string.count\
    \ > longest.count {\n            longest = string\n        }\n    }\n    return\
    \ longest\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(longest(strings: []\
    \ as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"x\"\
    )\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"\
    ]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013769
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \n    var longest = strings[0]\n    for s in strings {\n        if s.count > longest.count\
    \ {\n            longest = s\n        }\n    }\n\n    return longest\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013921
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longest = strings[0]\n    for s in strings {\n        if s.count > longest.count\
    \ {\n            longest = s\n        }\n    }\n    return longest\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013921
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \n    var longest = strings[0]\n    for string in strings {\n        if string.count\
    \ > longest.count {\n            longest = string\n        }\n    }\n    return\
    \ longest\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(longest(strings: []\
    \ as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"x\"\
    )\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"\
    ]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013921
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longest = strings[0]\n    for s in strings {\n        if longest.count\
    \ < s.count {\n            longest = s\n        }\n    }\n    return longest\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013921
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longest = strings[0]\n    for s in strings {\n        if s.count > longest.count\
    \ {\n            longest = s\n        }\n    }\n    return longest\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013921
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longest = strings[0]\n    for s in strings {\n        if s.count > longest.count\
    \ {\n            longest = s\n        }\n    }\n    return longest\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013921
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longest = strings[0]\n    for s in strings {\n        if s.count > longest.count\
    \ {\n            longest = s\n        }\n    }\n    return longest\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013921
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \n    var longest = strings[0]\n    for s in strings {\n        if s.count > longest.count\
    \ {\n            longest = s\n        }\n    }\n    return longest\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013921
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longest = strings[0]\n    for s in strings {\n        if s.count > longest.count\
    \ {\n            longest = s\n        }\n    }\n    return longest\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013921
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longest = strings[0]\n    for s in strings {\n        if s.count > longest.count\
    \ {\n            longest = s\n        }\n    }\n    return longest\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013921
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longest = strings[0]\n    for s in strings {\n        if s.count > longest.count\
    \ {\n            longest = s\n        }\n    }\n    return longest\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013921
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longest = strings[0]\n    for s in strings {\n        if longest.count\
    \ < s.count {\n            longest = s\n        }\n    }\n    return longest\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013921
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longest = strings[0]\n    for s in strings {\n        if longest.count\
    \ < s.count {\n            longest = s\n        }\n    }\n    return longest\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013921
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longest = strings[0]\n    for s in strings {\n        if s.count > longest.count\
    \ {\n            longest = s\n        }\n    }\n    return longest\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013921
- exit_code: -4
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    var longest = strings[0]\n    for s in strings {\n\
    \        if s.count > longest.count {\n            longest = s\n        }\n  \
    \  }\n    return longest\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(longest(strings:\
    \ [] as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"\
    x\")\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"\
    abc\"]) == \"zzzz\")"
  status: Exception
  stderr: 'Swift/ContiguousArrayBuffer.swift:600: Fatal error: Index out of range

    Current stack trace:

    0    libswiftCore.so                    0x00002b09c306cc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b09c2d63561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002b09c2d63286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002b09c2d6313c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002b09c2d62bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftSwiftOnoneSupport.so       0x00002b09c2b62fc3 <unavailable> + 188355

    6    tmppj_u88gq                        0x0000563c7c97cdd2 <unavailable> + 7634

    7    tmppj_u88gq                        0x0000563c7c97c590 <unavailable> + 5520

    8    libc.so.6                          0x00002b09c3258460 __libc_start_main +
    245

    9    tmppj_u88gq                        0x0000563c7c97c299 <unavailable> + 4761

    '
  stdout: ''
  timestamp: 1660013921
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longest = strings[0]\n    for s in strings {\n        if longest.count\
    \ < s.count {\n            longest = s\n        }\n    }\n    return longest\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013921
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longest = strings[0]\n    for s in strings {\n        if longest.count\
    \ < s.count {\n            longest = s\n        }\n    }\n    return longest\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013921
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \n    var longest = strings[0]\n    for s in strings {\n        if s.count > longest.count\
    \ {\n            longest = s\n        }\n    }\n\n    return longest\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013921
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longest = strings[0]\n    for s in strings {\n        if s.count > longest.count\
    \ {\n            longest = s\n        }\n    }\n    return longest\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013921
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \n    var longest = strings[0]\n    for string in strings {\n        if string.count\
    \ > longest.count {\n            longest = string\n        }\n    }\n\n    return\
    \ longest\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(longest(strings: []\
    \ as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"x\"\
    )\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"\
    ]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013921
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longest = strings[0]\n    for s in strings {\n        if s.count > longest.count\
    \ {\n            longest = s\n        }\n    }\n    return longest\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013921
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    let longest = strings.reduce(\"\") { (result, string) in\n        if result.count\
    \ < string.count {\n            return string\n        }\n        return result\n\
    \    }\n    return longest\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(longest(strings:\
    \ [] as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"\
    x\")\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"\
    abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013921
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longest = strings[0]\n    for s in strings {\n        if longest.count\
    \ < s.count {\n            longest = s\n        }\n    }\n    return longest\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013921
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longest = strings[0]\n    for string in strings {\n        if string.count\
    \ > longest.count {\n            longest = string\n        }\n    }\n    return\
    \ longest\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(longest(strings: []\
    \ as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"x\"\
    )\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"\
    ]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013769
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \n    var longest = strings[0]\n    for string in strings {\n        if string.count\
    \ > longest.count {\n            longest = string\n        }\n    }\n    return\
    \ longest\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(longest(strings: []\
    \ as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"x\"\
    )\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"\
    ]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013921
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longest = strings[0]\n    for s in strings {\n        if longest.count\
    \ < s.count {\n            longest = s\n        }\n    }\n    return longest\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013921
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longest = strings[0]\n    for s in strings {\n        if longest.count\
    \ < s.count {\n            longest = s\n        }\n    }\n    return longest\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013921
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longest = strings[0]\n    for s in strings {\n        if longest.count\
    \ < s.count {\n            longest = s\n        }\n    }\n    return longest\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013921
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \n    var longest = strings[0]\n    for s in strings {\n        if s.count > longest.count\
    \ {\n            longest = s\n        }\n    }\n\n    return longest\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013921
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longest = strings[0]\n    for s in strings {\n        if longest.count\
    \ < s.count {\n            longest = s\n        }\n    }\n    return longest\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(longest(strings: [] as [String]) == nil)\nassert(longest(strings:\
    \ [\"x\", \"y\", \"z\"]) == \"x\")\nassert(longest(strings: [\"x\", \"yyy\", \"\
    zzzz\", \"www\", \"kkkk\", \"abc\"]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013921
- exit_code: 0
  program: "\n/// Out of list of strings, return the longest one. Return the first\
    \ one in case of multiple\n/// strings of the same length. Return None in case\
    \ the input list is empty.\n/// >>> longest([])\n/// >>> longest(['a', 'b', 'c'])\n\
    /// 'a'\n/// >>> longest(['a', 'bb', 'ccc'])\n/// 'ccc'\nfunc longest(strings:\
    \ [String]) -> String? {\n    if strings.isEmpty {\n        return nil\n    }\n\
    \    var longest = strings[0]\n    for string in strings {\n        if string.count\
    \ > longest.count {\n            longest = string\n        }\n    }\n    return\
    \ longest\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(longest(strings: []\
    \ as [String]) == nil)\nassert(longest(strings: [\"x\", \"y\", \"z\"]) == \"x\"\
    )\nassert(longest(strings: [\"x\", \"yyy\", \"zzzz\", \"www\", \"kkkk\", \"abc\"\
    ]) == \"zzzz\")"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013769
