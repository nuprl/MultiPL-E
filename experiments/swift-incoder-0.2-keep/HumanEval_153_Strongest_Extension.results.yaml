language: swift
name: HumanEval_153_Strongest_Extension
results:
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfunc Strongest_Extension(class_name: String,\
    \ extensions: [String]) -> String {\n    var strongest_extension = \"\"\n    var\
    \ strength = -1\n    for extension in extensions {\n        var class_name_extension\
    \ = class_name + extension\n        var class_name_extension_lowercase = class_name_extension.lowercased()\n\
    \        var class_name_extension_lowercase_index = class_name_extension_lowercase.characters.count\n\
    \        var class_name_extension_lowercase_index = class_name_extension_lowercase_index\
    \ - class_name_extension_lowercase_index.characters.count\n        var class_name_extension_lowercase_index\
    \ = class_name_extension_lowercase_index / 2\n        var class_name_extension_lowercase_index\
    \ = class_name_extension_lowercase_index % 2\n        var class_name_extension_lowercase_index\
    \ = class_name_extension_lowercase_index + class_name_extension_lowercase.characters.count\n\
    \        var class_name_extension_lowercase_index = class_name_extension_lowercase_index\
    \ - class_name_extension_lowercase_index.characters.count\n        var class_name_extension_lowercase_index\
    \ = class_name_extension_lowercase_index / 2\n        var class_name_extension_lowercase_index\
    \ = class_name_extension_lowercase_index % 2\n        var class_name_extension_lowercase_index\
    \ = class_name_extension_lowercase_index + class_name_extension_lowercase.characters.count\n\
    \        var class_name_extension_lowercase_index = class_name_extension_lowercase_index\
    \ - class_name_extension_lowercase_index.characters.count\n        var class_name_extension_lowercase_index\
    \ = class_name_extension_lowercase_index / 2\n        var class_name_extension_lowercase_index\
    \ = class_name_extension_lowercase_index % 2\n        var class_name_extension_lowercase_index\
    \ = class_name_extension_lowercase_index + class_name_extension_lowercase.characters.count\n\
    \        var class_name_extension_lowercase_index = class_name_extension_lowercase_index\
    \ - class_name_extension_lowercase_index.characters.count\n        var class_name_extension_lowercase_index\
    \ = class_name_extension_lowercase_index / 2\n        var class_name_extension_lowercase_index\
    \ = class_name_extension_lowercase_index % 2\n        var class_name_extension_lowercase_index\
    \ = class_name_extension_lowercase_index + class_name_extension_lowercase.characters.count\n\
    \        var class_name_extension_lowercase_index = class_name_extension_lowercase_index\
    \ - class_name_extension_lowercase_index.characters.count\n        var class_name_extension_lowercase_index\
    \ = class_name_extension_lowercase_index / 2\n        var class_name_extension_lowercase_index\
    \ = class_name_extension_lowercase_index % 2\n        var class_name_extension_lowercase_index\
    \ = class_name_extension_lowercase_index + class_name_extension_lowercase.characters.count\n\
    \        var class_name_extension_lowercase_index = class_name_extension_lowercase_index\
    \ - class_name_extension_lowercase_index.characters.count\n        var class_name_extension_lowercase_index\
    \ = class_name_extension_lowercase_index / 2\n        var class_name_extension_lowercase_index\
    \ = class_name_extension_lowercase_index % 2\n        var class_name_extension_\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpylnzuj7k.swift:20:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpylnzuj7k.swift:20:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpylnzuj7k.swift:20:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpylnzuj7k.swift:21:49:\
    \ error: expected expression after operator\n        var class_name_extension\
    \ = class_name + extension\n                                                ^\n\
    /tmp/tmpylnzuj7k.swift:21:48: error: consecutive statements on a line must be\
    \ separated by ';'\n        var class_name_extension = class_name + extension\n\
    \                                               ^\n                          \
    \                     ;\n/tmp/tmpylnzuj7k.swift:22:9: error: expected type name\
    \ in extension declaration\n        var class_name_extension_lowercase = class_name_extension.lowercased()\n\
    \        ^\n/tmp/tmpylnzuj7k.swift:21:58: error: expected '{' in extension\n \
    \       var class_name_extension = class_name + extension\n                  \
    \                                       ^\n/tmp/tmpylnzuj7k.swift:21:49: error:\
    \ declaration is only valid at file scope\n        var class_name_extension =\
    \ class_name + extension\n                                                ^\n\
    /tmp/tmpylnzuj7k.swift:71:91: error: expected '}' at end of brace statement\n\
    assert(Strongest_Extension(class_name: \"Sp\", extensions: [\"671235\", \"Bb\"\
    ]) == \"Sp.671235\")\n                                                       \
    \                                   ^\n/tmp/tmpylnzuj7k.swift:17:78: note: to\
    \ match this opening '{'\nfunc Strongest_Extension(class_name: String, extensions:\
    \ [String]) -> String {\n                                                    \
    \                         ^\n/tmp/tmpylnzuj7k.swift:51:6: error: operator functions\
    \ can only be declared at global or in type scope\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n     ^\n/tmp/tmpylnzuj7k.swift:47:13: error:\
    \ type annotation missing in pattern\n        var"
  stdout: ''
  timestamp: 1659820881
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfunc Strongest_Extension(class_name: String,\
    \ extensions: [String]) -> String {\n    var strongest_extension = \"\"\n    var\
    \ strength = -1\n    for extension in extensions {\n        let class_name_components\
    \ = class_name.components(separatedBy: \".\")\n        let extension_components\
    \ = extension.components(separatedBy: \".\")\n        let class_name_length =\
    \ class_name_components.count\n        let extension_length = extension_components.count\n\
    \        let class_name_components_count = class_name_length + extension_length\n\
    \        let class_name_components_count_upper = class_name_components_count -\
    \ class_name_components.count\n        let class_name_components_count_lower =\
    \ class_name_components_count - class_name_components.count + class_name_components.count\n\
    \        let class_name_components_count_cap = class_name_components_count - class_name_components.count\
    \ + class_name_components.count + class_name_components.count\n        let class_name_components_count_sm\
    \ = class_name_components_count - class_name_components.count + class_name_components.count\
    \ + class_name_components.count + class_name_components.count + class_name_components.count\
    \ + class_name_components.count + class_name_components.count + class_name_components.count\
    \ + class_name_components.count + class_name_components.count + class_name_components.count\
    \ + class_name_components.count + class_name_components.count + class_name_components.count\
    \ + class_name_components.count + class_name_components.count + class_name_components.count\
    \ + class_name_components.count + class_name_components.count + class_name_components.count\
    \ + class_name_components.count + class_name_components.count + class_name_components.count\
    \ + class_name_components.count + class_name_components.count + class_name_components.count\
    \ + class_name_components.count + class_name_components.count + class_name_components.count\
    \ + class_name_components.count + class_name_components.count + class_name_components.count\
    \ + class_name_components.count + class_name_components.count + class_name_components.count\
    \ + class_name_components.count + class_name_components.count + class_name_components.count\
    \ + class_name_components.count + class_name_components.count + class_name_components.count\
    \ + class_name_components.count + class_name_components.count + class_name_components.count\
    \ + class_name_components.count + class_name_components.count + class_name_components.count\
    \ + class_name_components.count + class_name_components.count + class_name_components.count\
    \ + class_name_components.count + class_name_components.count + class_name_components.count\
    \ + class_name_components.count + class_name_components.count + class_name_components.count\
    \ + class_name_components.count + class_name_components.count + class_name_components.count\
    \ + class_name_components.count + class_name_components.count + class_name_components.count\
    \ + class_name_components.count + class_name_components.count + class_name_components.count\
    \ + class_name_components.count + class_name_components.count + class_name_components.count\
    \ + class_name_components.count + class_name_\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(Strongest_Extension(class_name: \"Watashi\", extensions: [\"tEN\"\
    , \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp_826kjy8.swift:20:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmp_826kjy8.swift:20:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmp_826kjy8.swift:20:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmp_826kjy8.swift:22:36:\
    \ error: expected initial value after '='\n        let extension_components =\
    \ extension.components(separatedBy: \".\")\n                                 \
    \  ^\n/tmp/tmp_826kjy8.swift:22:35: error: consecutive statements on a line must\
    \ be separated by ';'\n        let extension_components = extension.components(separatedBy:\
    \ \".\")\n                                  ^\n                              \
    \    ;\n/tmp/tmp_826kjy8.swift:22:45: error: expected type name in extension declaration\n\
    \        let extension_components = extension.components(separatedBy: \".\")\n\
    \                                            ^\n/tmp/tmp_826kjy8.swift:22:45:\
    \ error: expected '{' in extension\n        let extension_components = extension.components(separatedBy:\
    \ \".\")\n                                            ^\n/tmp/tmp_826kjy8.swift:22:36:\
    \ error: declaration is only valid at file scope\n        let extension_components\
    \ = extension.components(separatedBy: \".\")\n                               \
    \    ^\n/tmp/tmp_826kjy8.swift:53:91: error: expected '}' at end of brace statement\n\
    assert(Strongest_Extension(class_name: \"Sp\", extensions: [\"671235\", \"Bb\"\
    ]) == \"Sp.671235\")\n                                                       \
    \                                   ^\n/tmp/tmp_826kjy8.swift:17:78: note: to\
    \ match this opening '{'\nfunc Strongest_Extension(class_name: String, extensions:\
    \ [String]) -> String {\n                                                    \
    \                         ^\n/tmp/tmp_826kjy8.swift:33:6: error: operator functions\
    \ can only be declared at global or in type scope\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n     ^\n/tmp/tmp_826kjy8.swift:21:48: error:\
    \ value of type 'St"
  stdout: ''
  timestamp: 1659820979
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfunc Strongest_Extension(class_name: String,\
    \ extensions: [String]) -> String {\n    var strongest_extension = \"\"\n    var\
    \ strongest_extension_strength = -1\n    for extension in extensions {\n     \
    \   let extension_strength = extension.countUpToUppercase() - extension.countUpToLowercase()\n\
    \        if extension_strength > strongest_extension_strength {\n            strongest_extension_strength\
    \ = extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpkhpb8s88.swift:20:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpkhpb8s88.swift:20:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpkhpb8s88.swift:20:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpkhpb8s88.swift:21:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUpToUppercase()\
    \ - extension.countUpToLowercase()\n                                 ^\n/tmp/tmpkhpb8s88.swift:21:33:\
    \ error: consecutive statements on a line must be separated by ';'\n        let\
    \ extension_strength = extension.countUpToUppercase() - extension.countUpToLowercase()\n\
    \                                ^\n                                ;\n/tmp/tmpkhpb8s88.swift:21:43:\
    \ error: expected type name in extension declaration\n        let extension_strength\
    \ = extension.countUpToUppercase() - extension.countUpToLowercase()\n        \
    \                                  ^\n/tmp/tmpkhpb8s88.swift:21:43: error: expected\
    \ '{' in extension\n        let extension_strength = extension.countUpToUppercase()\
    \ - extension.countUpToLowercase()\n                                         \
    \ ^\n/tmp/tmpkhpb8s88.swift:21:34: error: declaration is only valid at file scope\n\
    \        let extension_strength = extension.countUpToUppercase() - extension.countUpToLowercase()\n\
    \                                 ^\n/tmp/tmpkhpb8s88.swift:21:76: error: expected\
    \ type name in extension declaration\n        let extension_strength = extension.countUpToUppercase()\
    \ - extension.countUpToLowercase()\n                                         \
    \                                  ^\n/tmp/tmpkhpb8s88.swift:21:76: error: expected\
    \ '{' in extension\n        let extension_strength = extension.countUpToUppercase()\
    \ - extension.countUpToLowercase()\n                                         \
    \                                  ^\n/tmp/tmpkhpb8s88.swift:21:67: error: declaration\
    \ is only valid at file scope\n        let extension_strength"
  stdout: ''
  timestamp: 1659820881
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfunc Strongest_Extension(class_name: String,\
    \ extensions: [String]) -> String {\n    var strongest_extension = \"\"\n    var\
    \ max_strength = -1\n    for extension in extensions {\n        let class_name_components\
    \ = class_name.components(separatedBy: \".\")\n        let extension_components\
    \ = extension.components(separatedBy: \".\")\n        let class_name = class_name_components.last!\n\
    \        let extension = extension_components.last!\n        let class_name_components_count\
    \ = class_name_components.count\n        let extension_components_count = extension_components.count\n\
    \        let class_name_components_count_cap = class_name_components_count - class_name_components_count.count\n\
    \        let extension_components_count_cap = extension_components_count - extension_components_count.count\n\
    \        let class_name_components_count_sm = class_name_components_count + class_name_components_count.count\n\
    \        let extension_components_count_sm = extension_components_count + extension_components_count.count\n\
    \        let class_name_components_count_cap_sm = (class_name_components_count_cap\
    \ - class_name_components_count_sm)\n        let extension_components_count_cap_sm\
    \ = (extension_components_count_cap - extension_components_count_sm)\n       \
    \ let class_name_components_count_cap_sm_ratio = class_name_components_count_cap_sm\
    \ / class_name_components_count_sm\n        let extension_components_count_cap_sm_ratio\
    \ = extension_components_count_cap_sm / extension_components_count_sm\n      \
    \  let strength = class_name_components_count_cap_sm_ratio - extension_components_count_cap_sm_ratio\n\
    \        if strength > max_strength {\n            max_strength = strength\n \
    \           strongest_extension = extension\n        }\n    }\n    return class_name\
    \ + \".\" + strongest_extension\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpqx8qvwxi.swift:20:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpqx8qvwxi.swift:20:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpqx8qvwxi.swift:20:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpqx8qvwxi.swift:22:36:\
    \ error: expected initial value after '='\n        let extension_components =\
    \ extension.components(separatedBy: \".\")\n                                 \
    \  ^\n/tmp/tmpqx8qvwxi.swift:22:35: error: consecutive statements on a line must\
    \ be separated by ';'\n        let extension_components = extension.components(separatedBy:\
    \ \".\")\n                                  ^\n                              \
    \    ;\n/tmp/tmpqx8qvwxi.swift:22:45: error: expected type name in extension declaration\n\
    \        let extension_components = extension.components(separatedBy: \".\")\n\
    \                                            ^\n/tmp/tmpqx8qvwxi.swift:22:45:\
    \ error: expected '{' in extension\n        let extension_components = extension.components(separatedBy:\
    \ \".\")\n                                            ^\n/tmp/tmpqx8qvwxi.swift:22:36:\
    \ error: declaration is only valid at file scope\n        let extension_components\
    \ = extension.components(separatedBy: \".\")\n                               \
    \    ^\n/tmp/tmpqx8qvwxi.swift:24:13: error: keyword 'extension' cannot be used\
    \ as an identifier here\n        let extension = extension_components.last!\n\
    \            ^\n/tmp/tmpqx8qvwxi.swift:24:13: note: if this name is unavoidable,\
    \ use backticks to escape it\n        let extension = extension_components.last!\n\
    \            ^~~~~~~~~\n            `extension`\n/tmp/tmpqx8qvwxi.swift:38:35:\
    \ error: expected expression in assignment\n            strongest_extension =\
    \ extension\n                                  ^\n/tmp/tmpqx8qvwxi.swift:39:9:\
    \ error: expected type name in extension declaration\n        }\n        ^\n/tmp/tmpqx8qvwxi.swift:38:44:\
    \ error: expected '{' in extension\n            strongest_extension = extens"
  stdout: ''
  timestamp: 1659820881
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfunc Strongest_Extension(class_name: String,\
    \ extensions: [String]) -> String {\n    var strongest_extension = \"\"\n    var\
    \ strongest_extension_strength = -1\n    for extension in extensions {\n     \
    \   let extension_strength = extension.countUpToCapitalLetters()\n        if extension_strength\
    \ > strongest_extension_strength {\n            strongest_extension_strength =\
    \ extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp2w9v7wh_.swift:20:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmp2w9v7wh_.swift:20:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmp2w9v7wh_.swift:20:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmp2w9v7wh_.swift:21:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUpToCapitalLetters()\n\
    \                                 ^\n/tmp/tmp2w9v7wh_.swift:21:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        let extension_strength\
    \ = extension.countUpToCapitalLetters()\n                                ^\n \
    \                               ;\n/tmp/tmp2w9v7wh_.swift:21:43: error: expected\
    \ type name in extension declaration\n        let extension_strength = extension.countUpToCapitalLetters()\n\
    \                                          ^\n/tmp/tmp2w9v7wh_.swift:21:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.countUpToCapitalLetters()\n\
    \                                          ^\n/tmp/tmp2w9v7wh_.swift:21:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.countUpToCapitalLetters()\n\
    \                                 ^\n/tmp/tmp2w9v7wh_.swift:24:35: error: expected\
    \ expression in assignment\n            strongest_extension = extension\n    \
    \                              ^\n/tmp/tmp2w9v7wh_.swift:25:9: error: expected\
    \ type name in extension declaration\n        }\n        ^\n/tmp/tmp2w9v7wh_.swift:24:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           ^\n/tmp/tmp2w9v7wh_.swift:24:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                                  ^\n"
  stdout: ''
  timestamp: 1659820881
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfunc Strongest_Extension(class_name: String,\
    \ extensions: [String]) -> String {\n    var strongest_extension = \"\"\n    var\
    \ strongest_extension_strength = -1\n    for extension in extensions {\n     \
    \   let extension_strength = extension.countUpToCapitalLetters - extension.countLowercaseLetters\n\
    \        if extension_strength > strongest_extension_strength {\n            strongest_extension_strength\
    \ = extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp_pj_tx6g.swift:20:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmp_pj_tx6g.swift:20:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmp_pj_tx6g.swift:20:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmp_pj_tx6g.swift:21:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUpToCapitalLetters\
    \ - extension.countLowercaseLetters\n                                 ^\n/tmp/tmp_pj_tx6g.swift:21:33:\
    \ error: consecutive statements on a line must be separated by ';'\n        let\
    \ extension_strength = extension.countUpToCapitalLetters - extension.countLowercaseLetters\n\
    \                                ^\n                                ;\n/tmp/tmp_pj_tx6g.swift:21:43:\
    \ error: expected type name in extension declaration\n        let extension_strength\
    \ = extension.countUpToCapitalLetters - extension.countLowercaseLetters\n    \
    \                                      ^\n/tmp/tmp_pj_tx6g.swift:21:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.countUpToCapitalLetters\
    \ - extension.countLowercaseLetters\n                                        \
    \  ^\n/tmp/tmp_pj_tx6g.swift:21:34: error: declaration is only valid at file scope\n\
    \        let extension_strength = extension.countUpToCapitalLetters - extension.countLowercaseLetters\n\
    \                                 ^\n/tmp/tmp_pj_tx6g.swift:21:79: error: expected\
    \ type name in extension declaration\n        let extension_strength = extension.countUpToCapitalLetters\
    \ - extension.countLowercaseLetters\n                                        \
    \                                      ^\n/tmp/tmp_pj_tx6g.swift:21:79: error:\
    \ expected '{' in extension\n        let extension_strength = extension.countUpToCapitalLetters\
    \ - extension.countLowercaseLetters\n                                        \
    \                                      ^\n/tmp/tmp_pj_tx6g.swift:21:70: error:\
    \ declaration is only valid at file sc"
  stdout: ''
  timestamp: 1659820881
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfunc Strongest_Extension(class_name: String,\
    \ extensions: [String]) -> String {\n    var strongest_extension = \"\"\n    var\
    \ strongest_extension_strength = -1\n    for extension in extensions {\n     \
    \   let extension_strength = extension.characters.count\n        if extension_strength\
    \ > strongest_extension_strength {\n            strongest_extension_strength =\
    \ extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpg801yqsz.swift:20:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpg801yqsz.swift:20:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpg801yqsz.swift:20:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpg801yqsz.swift:21:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.characters.count\n\
    \                                 ^\n/tmp/tmpg801yqsz.swift:21:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        let extension_strength\
    \ = extension.characters.count\n                                ^\n          \
    \                      ;\n/tmp/tmpg801yqsz.swift:21:43: error: expected type name\
    \ in extension declaration\n        let extension_strength = extension.characters.count\n\
    \                                          ^\n/tmp/tmpg801yqsz.swift:21:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.characters.count\n\
    \                                          ^\n/tmp/tmpg801yqsz.swift:21:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.characters.count\n\
    \                                 ^\n/tmp/tmpg801yqsz.swift:24:35: error: expected\
    \ expression in assignment\n            strongest_extension = extension\n    \
    \                              ^\n/tmp/tmpg801yqsz.swift:25:9: error: expected\
    \ type name in extension declaration\n        }\n        ^\n/tmp/tmpg801yqsz.swift:24:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           ^\n/tmp/tmpg801yqsz.swift:24:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                                  ^\n"
  stdout: ''
  timestamp: 1659820881
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfunc Strongest_Extension(class_name: String,\
    \ extensions: [String]) -> String {\n    var strongest_extension = \"\"\n    var\
    \ strongest_extension_strength = -1\n    for extension in extensions {\n     \
    \   var extension_strength = extension.count\n        for character in extension\
    \ {\n            if character == character.lowercased() {\n                extension_strength\
    \ -= 1\n            }\n        }\n        if extension_strength > strongest_extension_strength\
    \ {\n            strongest_extension_strength = extension_strength\n         \
    \   strongest_extension = extension\n        }\n    }\n    return class_name +\
    \ \".\" + strongest_extension\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpyqk7216q.swift:20:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpyqk7216q.swift:20:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpyqk7216q.swift:20:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpyqk7216q.swift:21:34:\
    \ error: expected initial value after '='\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmpyqk7216q.swift:21:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        var extension_strength\
    \ = extension.count\n                                ^\n                     \
    \           ;\n/tmp/tmpyqk7216q.swift:21:43: error: expected type name in extension\
    \ declaration\n        var extension_strength = extension.count\n            \
    \                              ^\n/tmp/tmpyqk7216q.swift:21:43: error: expected\
    \ '{' in extension\n        var extension_strength = extension.count\n       \
    \                                   ^\n/tmp/tmpyqk7216q.swift:21:34: error: declaration\
    \ is only valid at file scope\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmpyqk7216q.swift:22:26: error: expected\
    \ Sequence expression for for-each loop\n        for character in extension {\n\
    \                         ^\n/tmp/tmpyqk7216q.swift:22:26: error: expected '{'\
    \ to start the body of for-each loop\n        for character in extension {\n \
    \                        ^\n/tmp/tmpyqk7216q.swift:29:35: error: expected expression\
    \ in assignment\n            strongest_extension = extension\n               \
    \                   ^\n/tmp/tmpyqk7216q.swift:30:9: error: expected type name\
    \ in extension declaration\n        }\n        ^\n/tmp/tmpyqk7216q.swift:29:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           ^\n/tmp/tmpyqk7216q.swift:29:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                  "
  stdout: ''
  timestamp: 1659820881
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfunc Strongest_Extension(class_name: String,\
    \ extensions: [String]) -> String {\n    var strongest_extension = \"\"\n    var\
    \ strongest_extension_strength = -1\n    for extension in extensions {\n     \
    \   let extension_strength = extension.countUpToLowercaseLetters()\n        if\
    \ extension_strength > strongest_extension_strength {\n            strongest_extension_strength\
    \ = extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp6jifw92_.swift:20:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmp6jifw92_.swift:20:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmp6jifw92_.swift:20:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmp6jifw92_.swift:21:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmp6jifw92_.swift:21:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        let extension_strength\
    \ = extension.countUpToLowercaseLetters()\n                                ^\n\
    \                                ;\n/tmp/tmp6jifw92_.swift:21:43: error: expected\
    \ type name in extension declaration\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmp6jifw92_.swift:21:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmp6jifw92_.swift:21:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmp6jifw92_.swift:24:35: error: expected\
    \ expression in assignment\n            strongest_extension = extension\n    \
    \                              ^\n/tmp/tmp6jifw92_.swift:25:9: error: expected\
    \ type name in extension declaration\n        }\n        ^\n/tmp/tmp6jifw92_.swift:24:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           ^\n/tmp/tmp6jifw92_.swift:24:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                                  ^\n"
  stdout: ''
  timestamp: 1659820881
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfunc Strongest_Extension(class_name: String,\
    \ extensions: [String]) -> String {\n    var strongest_extension = \"\"\n    var\
    \ strongest_extension_strength = -1\n    for extension in extensions {\n     \
    \   var extension_strength = extension.count\n        for letter in extension\
    \ {\n            if letter.isUppercase {\n                extension_strength -=\
    \ 1\n            }\n            if letter.isLowercase {\n                extension_strength\
    \ += 1\n            }\n        }\n        if extension_strength > strongest_extension_strength\
    \ {\n            strongest_extension_strength = extension_strength\n         \
    \   strongest_extension = extension\n        }\n    }\n    return class_name +\
    \ \".\" + strongest_extension\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp4hxin3ab.swift:20:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmp4hxin3ab.swift:20:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmp4hxin3ab.swift:20:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmp4hxin3ab.swift:21:34:\
    \ error: expected initial value after '='\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmp4hxin3ab.swift:21:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        var extension_strength\
    \ = extension.count\n                                ^\n                     \
    \           ;\n/tmp/tmp4hxin3ab.swift:21:43: error: expected type name in extension\
    \ declaration\n        var extension_strength = extension.count\n            \
    \                              ^\n/tmp/tmp4hxin3ab.swift:21:43: error: expected\
    \ '{' in extension\n        var extension_strength = extension.count\n       \
    \                                   ^\n/tmp/tmp4hxin3ab.swift:21:34: error: declaration\
    \ is only valid at file scope\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmp4hxin3ab.swift:22:23: error: expected\
    \ Sequence expression for for-each loop\n        for letter in extension {\n \
    \                     ^\n/tmp/tmp4hxin3ab.swift:22:23: error: expected '{' to\
    \ start the body of for-each loop\n        for letter in extension {\n       \
    \               ^\n/tmp/tmp4hxin3ab.swift:32:35: error: expected expression in\
    \ assignment\n            strongest_extension = extension\n                  \
    \                ^\n/tmp/tmp4hxin3ab.swift:33:9: error: expected type name in\
    \ extension declaration\n        }\n        ^\n/tmp/tmp4hxin3ab.swift:32:44: error:\
    \ expected '{' in extension\n            strongest_extension = extension\n   \
    \                                        ^\n/tmp/tmp4hxin3ab.swift:32:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                              "
  stdout: ''
  timestamp: 1659820881
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfunc Strongest_Extension(class_name: String,\
    \ extensions: [String]) -> String {\n    var strongest_extension = \"\"\n    var\
    \ strongest_extension_strength = -1\n    for extension in extensions {\n     \
    \   var extension_strength = count_capital_letters(extension) - count_capital_letters(extension.lowercaseString)\n\
    \        if extension_strength > strongest_extension_strength {\n            strongest_extension_strength\
    \ = extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp2hy52o8j.swift:20:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmp2hy52o8j.swift:20:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmp2hy52o8j.swift:20:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmp2hy52o8j.swift:21:56:\
    \ error: expected expression in list of expressions\n        var extension_strength\
    \ = count_capital_letters(extension) - count_capital_letters(extension.lowercaseString)\n\
    \                                                       ^\n/tmp/tmp2hy52o8j.swift:21:56:\
    \ error: consecutive statements on a line must be separated by ';'\n        var\
    \ extension_strength = count_capital_letters(extension) - count_capital_letters(extension.lowercaseString)\n\
    \                                                       ^\n                  \
    \                                     ;\n/tmp/tmp2hy52o8j.swift:21:65: error:\
    \ expected type name in extension declaration\n        var extension_strength\
    \ = count_capital_letters(extension) - count_capital_letters(extension.lowercaseString)\n\
    \                                                                ^\n         \
    \                                                        <#type#>\n/tmp/tmp2hy52o8j.swift:21:65:\
    \ error: expected '{' in extension\n        var extension_strength = count_capital_letters(extension)\
    \ - count_capital_letters(extension.lowercaseString)\n                       \
    \                                         ^\n/tmp/tmp2hy52o8j.swift:21:56: error:\
    \ declaration is only valid at file scope\n        var extension_strength = count_capital_letters(extension)\
    \ - count_capital_letters(extension.lowercaseString)\n                       \
    \                                ^\n/tmp/tmp2hy52o8j.swift:24:35: error: expected\
    \ expression in assignment\n            strongest_extension = extension\n    \
    \                              ^\n/tmp/tmp2hy52o8j.swift:25:9: error: expected\
    \ type name in extension declaration\n        }\n        ^\n/tmp/tmp2hy52o8j.swift:24:44: "
  stdout: ''
  timestamp: 1659820881
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfunc Strongest_Extension(class_name: String,\
    \ extensions: [String]) -> String {\n    var strongest_extension = \"\"\n    var\
    \ strongest_extension_strength = -1\n    for extension in extensions {\n     \
    \   let extension_strength = extension.countUpToLowercaseLetters()\n        if\
    \ extension_strength > strongest_extension_strength {\n            strongest_extension\
    \ = class_name\n            strongest_extension_strength = extension_strength\n\
    \        }\n    }\n    return strongest_extension\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpwji3car2.swift:20:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpwji3car2.swift:20:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpwji3car2.swift:20:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpwji3car2.swift:21:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmpwji3car2.swift:21:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        let extension_strength\
    \ = extension.countUpToLowercaseLetters()\n                                ^\n\
    \                                ;\n/tmp/tmpwji3car2.swift:21:43: error: expected\
    \ type name in extension declaration\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmpwji3car2.swift:21:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmpwji3car2.swift:21:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n"
  stdout: ''
  timestamp: 1659820881
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfunc Strongest_Extension(class_name: String,\
    \ extensions: [String]) -> String {\n    var strongest_extension = \"\"\n    var\
    \ strength = -1\n    for extension in extensions {\n        let extension_upper\
    \ = extension.uppercased()\n        let extension_lower = extension.lowercased()\n\
    \        let extension_length = extension_upper.count - extension_lower.count\n\
    \        let extension_strength = extension_upper.count - extension_lower.count\n\
    \        if strength == -1 || strength > extension_strength {\n            strength\
    \ = extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp2ijllyor.swift:20:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmp2ijllyor.swift:20:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmp2ijllyor.swift:20:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmp2ijllyor.swift:21:31:\
    \ error: expected initial value after '='\n        let extension_upper = extension.uppercased()\n\
    \                              ^\n/tmp/tmp2ijllyor.swift:21:30: error: consecutive\
    \ statements on a line must be separated by ';'\n        let extension_upper =\
    \ extension.uppercased()\n                             ^\n                   \
    \          ;\n/tmp/tmp2ijllyor.swift:21:40: error: expected type name in extension\
    \ declaration\n        let extension_upper = extension.uppercased()\n        \
    \                               ^\n/tmp/tmp2ijllyor.swift:21:40: error: expected\
    \ '{' in extension\n        let extension_upper = extension.uppercased()\n   \
    \                                    ^\n/tmp/tmp2ijllyor.swift:21:31: error: declaration\
    \ is only valid at file scope\n        let extension_upper = extension.uppercased()\n\
    \                              ^\n/tmp/tmp2ijllyor.swift:22:31: error: expected\
    \ initial value after '='\n        let extension_lower = extension.lowercased()\n\
    \                              ^\n/tmp/tmp2ijllyor.swift:22:30: error: consecutive\
    \ statements on a line must be separated by ';'\n        let extension_lower =\
    \ extension.lowercased()\n                             ^\n                   \
    \          ;\n/tmp/tmp2ijllyor.swift:22:40: error: expected type name in extension\
    \ declaration\n        let extension_lower = extension.lowercased()\n        \
    \                               ^\n/tmp/tmp2ijllyor.swift:22:40: error: expected\
    \ '{' in extension\n        let extension_lower = extension.lowercased()\n   \
    \                                    ^\n/tmp/tmp2ijllyor.swift:22:31: error: declaration\
    \ is only valid at file scope\n        let extension_lower = extension.lowercased()\n\
    \          "
  stdout: ''
  timestamp: 1659820881
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfunc Strongest_Extension(class_name: String,\
    \ extensions: [String]) -> String {\n    var strongest_extension = \"\"\n    var\
    \ strongest_extension_strength = -1\n    for extension in extensions {\n     \
    \   var extension_strength = extension.count\n        for letter in extension\
    \ {\n            if letter.isUpper() {\n                extension_strength -=\
    \ 1\n            }\n        }\n        if extension_strength > strongest_extension_strength\
    \ {\n            strongest_extension_strength = extension_strength\n         \
    \   strongest_extension = extension\n        }\n    }\n    return class_name +\
    \ \".\" + strongest_extension\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpdc2q9gnv.swift:20:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpdc2q9gnv.swift:20:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpdc2q9gnv.swift:20:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpdc2q9gnv.swift:21:34:\
    \ error: expected initial value after '='\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmpdc2q9gnv.swift:21:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        var extension_strength\
    \ = extension.count\n                                ^\n                     \
    \           ;\n/tmp/tmpdc2q9gnv.swift:21:43: error: expected type name in extension\
    \ declaration\n        var extension_strength = extension.count\n            \
    \                              ^\n/tmp/tmpdc2q9gnv.swift:21:43: error: expected\
    \ '{' in extension\n        var extension_strength = extension.count\n       \
    \                                   ^\n/tmp/tmpdc2q9gnv.swift:21:34: error: declaration\
    \ is only valid at file scope\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmpdc2q9gnv.swift:22:23: error: expected\
    \ Sequence expression for for-each loop\n        for letter in extension {\n \
    \                     ^\n/tmp/tmpdc2q9gnv.swift:22:23: error: expected '{' to\
    \ start the body of for-each loop\n        for letter in extension {\n       \
    \               ^\n/tmp/tmpdc2q9gnv.swift:29:35: error: expected expression in\
    \ assignment\n            strongest_extension = extension\n                  \
    \                ^\n/tmp/tmpdc2q9gnv.swift:30:9: error: expected type name in\
    \ extension declaration\n        }\n        ^\n/tmp/tmpdc2q9gnv.swift:29:44: error:\
    \ expected '{' in extension\n            strongest_extension = extension\n   \
    \                                        ^\n/tmp/tmpdc2q9gnv.swift:29:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                              "
  stdout: ''
  timestamp: 1659820881
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfunc Strongest_Extension(class_name: String,\
    \ extensions: [String]) -> String {\n    var strongest_extension = \"\"\n    var\
    \ max_strength = -1\n    for extension in extensions {\n        let extension_strength\
    \ = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n  \
    \      if extension_strength > max_strength {\n            max_strength = extension_strength\n\
    \            strongest_extension = extension\n        }\n    }\n    return class_name\
    \ + \".\" + strongest_extension\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpgp9i3pnc.swift:20:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpgp9i3pnc.swift:20:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpgp9i3pnc.swift:20:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpgp9i3pnc.swift:21:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUppercaseLetters()\
    \ - extension.countLowercaseLetters()\n                                 ^\n/tmp/tmpgp9i3pnc.swift:21:33:\
    \ error: consecutive statements on a line must be separated by ';'\n        let\
    \ extension_strength = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n\
    \                                ^\n                                ;\n/tmp/tmpgp9i3pnc.swift:21:43:\
    \ error: expected type name in extension declaration\n        let extension_strength\
    \ = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n  \
    \                                        ^\n/tmp/tmpgp9i3pnc.swift:21:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.countUppercaseLetters()\
    \ - extension.countLowercaseLetters()\n                                      \
    \    ^\n/tmp/tmpgp9i3pnc.swift:21:34: error: declaration is only valid at file\
    \ scope\n        let extension_strength = extension.countUppercaseLetters() -\
    \ extension.countLowercaseLetters()\n                                 ^\n/tmp/tmpgp9i3pnc.swift:21:79:\
    \ error: expected type name in extension declaration\n        let extension_strength\
    \ = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n  \
    \                                                                            ^\n\
    /tmp/tmpgp9i3pnc.swift:21:79: error: expected '{' in extension\n        let extension_strength\
    \ = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n  \
    \                                                                            ^\n\
    /tmp/tmpgp9i3pnc.swift:21:70: error: declaration is only va"
  stdout: ''
  timestamp: 1659820881
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfunc Strongest_Extension(class_name: String,\
    \ extensions: [String]) -> String {\n    var strongest_extension = \"\"\n    var\
    \ strength = -1\n    for extension in extensions {\n        var class_name_components\
    \ = class_name.components(separatedBy: \".\")\n        var extension_components\
    \ = extension.components(separatedBy: \".\")\n        var class_name = class_name_components[class_name_components.count\
    \ - 1]\n        var extension = extension_components[extension_components.count\
    \ - 1]\n        var class_name_components_count = class_name_components.count\n\
    \        var extension_components_count = extension_components.count\n       \
    \ var class_name_components_count = class_name_components.count\n        var extension_components_count\
    \ = extension_components.count\n        var class_name_components_count = class_name_components.count\n\
    \        var extension_components_count = extension_components.count\n       \
    \ var class_name_components_count = class_name_components.count\n        var extension_components_count\
    \ = extension_components.count\n        var class_name_components_count = class_name_components.count\n\
    \        var extension_components_count = extension_components.count\n       \
    \ var class_name_components_count = class_name_components.count\n        var extension_components_count\
    \ = extension_components.count\n        var class_name_components_count = class_name_components.count\n\
    \        var extension_components_count = extension_components.count\n       \
    \ var class_name_components_count = class_name_components.count\n        var extension_components_count\
    \ = extension_components.count\n        var class_name_components_count = class_name_components.count\n\
    \        var extension_components_count = extension_components.count\n       \
    \ var class_name_components_count = class_name_components.count\n        var extension_components_count\
    \ = extension_components.count\n        var class_name_components_count = class_name_components.count\n\
    \        var extension_components_count = extension_components.count\n       \
    \ var class_name_components_count = class_name_components.count\n        var extension_components_count\
    \ = extension_components.count\n        var class_name_components_count = class_name_components.count\n\
    \        var extension_components_count = extension_components.count\n       \
    \ var class_name_components_count = class_name_components.count\n        var extension_components_count\
    \ = extension_components.count\n        var class_name_components_count = class_name_components.count\n\
    \        var extension_components_count = extension_components.count\n       \
    \ var class_name_components_count = class_name_components.count\n        var extension_components_count\
    \ = extension_components.count\n        var class_name_components_count = class_name_components.count\n\
    \        var extension_components_count = extension_components.count\n       \
    \ var class_name_components_count = class_name_components.count\n        var extension_components_count\
    \ = extension_components.count\n        var class_name_components_count = class_name_components.count\n\
    \        var extension_components_count = extension_components.count\n       \
    \ var class_name_components_count = class_name_components.count\n        var extension_components_count\
    \ = extension_\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpxt66wl25.swift:20:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpxt66wl25.swift:20:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpxt66wl25.swift:20:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpxt66wl25.swift:22:36:\
    \ error: expected initial value after '='\n        var extension_components =\
    \ extension.components(separatedBy: \".\")\n                                 \
    \  ^\n/tmp/tmpxt66wl25.swift:22:35: error: consecutive statements on a line must\
    \ be separated by ';'\n        var extension_components = extension.components(separatedBy:\
    \ \".\")\n                                  ^\n                              \
    \    ;\n/tmp/tmpxt66wl25.swift:22:45: error: expected type name in extension declaration\n\
    \        var extension_components = extension.components(separatedBy: \".\")\n\
    \                                            ^\n/tmp/tmpxt66wl25.swift:22:45:\
    \ error: expected '{' in extension\n        var extension_components = extension.components(separatedBy:\
    \ \".\")\n                                            ^\n/tmp/tmpxt66wl25.swift:22:36:\
    \ error: declaration is only valid at file scope\n        var extension_components\
    \ = extension.components(separatedBy: \".\")\n                               \
    \    ^\n/tmp/tmpxt66wl25.swift:24:13: error: keyword 'extension' cannot be used\
    \ as an identifier here\n        var extension = extension_components[extension_components.count\
    \ - 1]\n            ^\n/tmp/tmpxt66wl25.swift:24:13: note: if this name is unavoidable,\
    \ use backticks to escape it\n        var extension = extension_components[extension_components.count\
    \ - 1]\n            ^~~~~~~~~\n            `extension`\n/tmp/tmpxt66wl25.swift:88:91:\
    \ error: expected '}' at end of brace statement\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")\n              \
    \                                                                            ^\n\
    /tmp/tmpxt66wl25.swift:17:78: note: to matc"
  stdout: ''
  timestamp: 1659820881
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfunc Strongest_Extension(class_name: String,\
    \ extensions: [String]) -> String {\n    var strongest_extension = \"\"\n    var\
    \ strongest_extension_strength = -1\n    for extension in extensions {\n     \
    \   let extension_strength = extension.countUpToLowercaseLetters()\n        if\
    \ extension_strength > strongest_extension_strength {\n            strongest_extension_strength\
    \ = extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp6jifw92_.swift:20:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmp6jifw92_.swift:20:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmp6jifw92_.swift:20:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmp6jifw92_.swift:21:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmp6jifw92_.swift:21:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        let extension_strength\
    \ = extension.countUpToLowercaseLetters()\n                                ^\n\
    \                                ;\n/tmp/tmp6jifw92_.swift:21:43: error: expected\
    \ type name in extension declaration\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmp6jifw92_.swift:21:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmp6jifw92_.swift:21:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmp6jifw92_.swift:24:35: error: expected\
    \ expression in assignment\n            strongest_extension = extension\n    \
    \                              ^\n/tmp/tmp6jifw92_.swift:25:9: error: expected\
    \ type name in extension declaration\n        }\n        ^\n/tmp/tmp6jifw92_.swift:24:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           ^\n/tmp/tmp6jifw92_.swift:24:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                                  ^\n"
  stdout: ''
  timestamp: 1659820881
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfunc Strongest_Extension(class_name: String,\
    \ extensions: [String]) -> String {\n    var strongest_extension = \"\"\n    var\
    \ max_strength = -1\n    for extension in extensions {\n        let extension_strength\
    \ = extension.characters.reduce(0) { (sum, letter) -> Int in\n            sum\
    \ += letter.uppercased() - letter.lowercased()\n            return sum\n     \
    \   }\n        if extension_strength > max_strength {\n            max_strength\
    \ = extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpntmd0fhu.swift:20:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpntmd0fhu.swift:20:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpntmd0fhu.swift:20:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpntmd0fhu.swift:21:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.characters.reduce(0)\
    \ { (sum, letter) -> Int in\n                                 ^\n/tmp/tmpntmd0fhu.swift:21:33:\
    \ error: consecutive statements on a line must be separated by ';'\n        let\
    \ extension_strength = extension.characters.reduce(0) { (sum, letter) -> Int in\n\
    \                                ^\n                                ;\n/tmp/tmpntmd0fhu.swift:21:43:\
    \ error: expected type name in extension declaration\n        let extension_strength\
    \ = extension.characters.reduce(0) { (sum, letter) -> Int in\n               \
    \                           ^\n/tmp/tmpntmd0fhu.swift:21:43: error: expected '{'\
    \ in extension\n        let extension_strength = extension.characters.reduce(0)\
    \ { (sum, letter) -> Int in\n                                          ^\n/tmp/tmpntmd0fhu.swift:21:34:\
    \ error: declaration is only valid at file scope\n        let extension_strength\
    \ = extension.characters.reduce(0) { (sum, letter) -> Int in\n               \
    \                  ^\n/tmp/tmpntmd0fhu.swift:27:35: error: expected expression\
    \ in assignment\n            strongest_extension = extension\n               \
    \                   ^\n/tmp/tmpntmd0fhu.swift:28:9: error: expected type name\
    \ in extension declaration\n        }\n        ^\n/tmp/tmpntmd0fhu.swift:27:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           ^\n/tmp/tmpntmd0fhu.swift:27:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                                  ^\n"
  stdout: ''
  timestamp: 1659820881
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfunc Strongest_Extension(class_name: String,\
    \ extensions: [String]) -> String {\n    var strongest_extension = \"\"\n    var\
    \ strongest_extension_strength = -1\n    for extension in extensions {\n     \
    \   var extension_strength = extension.count\n        for letter in extension\
    \ {\n            if letter.isUppercase {\n                extension_strength -=\
    \ 1\n            }\n            if letter.isLowercase {\n                extension_strength\
    \ += 1\n            }\n        }\n        if extension_strength > strongest_extension_strength\
    \ {\n            strongest_extension_strength = extension_strength\n         \
    \   strongest_extension = extension\n        }\n    }\n    return class_name +\
    \ \".\" + strongest_extension\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp4hxin3ab.swift:20:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmp4hxin3ab.swift:20:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmp4hxin3ab.swift:20:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmp4hxin3ab.swift:21:34:\
    \ error: expected initial value after '='\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmp4hxin3ab.swift:21:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        var extension_strength\
    \ = extension.count\n                                ^\n                     \
    \           ;\n/tmp/tmp4hxin3ab.swift:21:43: error: expected type name in extension\
    \ declaration\n        var extension_strength = extension.count\n            \
    \                              ^\n/tmp/tmp4hxin3ab.swift:21:43: error: expected\
    \ '{' in extension\n        var extension_strength = extension.count\n       \
    \                                   ^\n/tmp/tmp4hxin3ab.swift:21:34: error: declaration\
    \ is only valid at file scope\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmp4hxin3ab.swift:22:23: error: expected\
    \ Sequence expression for for-each loop\n        for letter in extension {\n \
    \                     ^\n/tmp/tmp4hxin3ab.swift:22:23: error: expected '{' to\
    \ start the body of for-each loop\n        for letter in extension {\n       \
    \               ^\n/tmp/tmp4hxin3ab.swift:32:35: error: expected expression in\
    \ assignment\n            strongest_extension = extension\n                  \
    \                ^\n/tmp/tmp4hxin3ab.swift:33:9: error: expected type name in\
    \ extension declaration\n        }\n        ^\n/tmp/tmp4hxin3ab.swift:32:44: error:\
    \ expected '{' in extension\n            strongest_extension = extension\n   \
    \                                        ^\n/tmp/tmp4hxin3ab.swift:32:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                              "
  stdout: ''
  timestamp: 1659820881
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfunc Strongest_Extension(class_name: String,\
    \ extensions: [String]) -> String {\n    var strongest_extension = \"\"\n    var\
    \ strongest_extension_strength = -1\n    for extension in extensions {\n     \
    \   var extension_strength = extension.count\n        for character in extension\
    \ {\n            if character == character.lowercased() {\n                extension_strength\
    \ -= 1\n            }\n        }\n        if extension_strength > strongest_extension_strength\
    \ {\n            strongest_extension_strength = extension_strength\n         \
    \   strongest_extension = extension\n        }\n    }\n    return class_name +\
    \ \".\" + strongest_extension\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpyqk7216q.swift:20:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpyqk7216q.swift:20:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpyqk7216q.swift:20:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpyqk7216q.swift:21:34:\
    \ error: expected initial value after '='\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmpyqk7216q.swift:21:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        var extension_strength\
    \ = extension.count\n                                ^\n                     \
    \           ;\n/tmp/tmpyqk7216q.swift:21:43: error: expected type name in extension\
    \ declaration\n        var extension_strength = extension.count\n            \
    \                              ^\n/tmp/tmpyqk7216q.swift:21:43: error: expected\
    \ '{' in extension\n        var extension_strength = extension.count\n       \
    \                                   ^\n/tmp/tmpyqk7216q.swift:21:34: error: declaration\
    \ is only valid at file scope\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmpyqk7216q.swift:22:26: error: expected\
    \ Sequence expression for for-each loop\n        for character in extension {\n\
    \                         ^\n/tmp/tmpyqk7216q.swift:22:26: error: expected '{'\
    \ to start the body of for-each loop\n        for character in extension {\n \
    \                        ^\n/tmp/tmpyqk7216q.swift:29:35: error: expected expression\
    \ in assignment\n            strongest_extension = extension\n               \
    \                   ^\n/tmp/tmpyqk7216q.swift:30:9: error: expected type name\
    \ in extension declaration\n        }\n        ^\n/tmp/tmpyqk7216q.swift:29:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           ^\n/tmp/tmpyqk7216q.swift:29:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                  "
  stdout: ''
  timestamp: 1659820881
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfunc Strongest_Extension(class_name: String,\
    \ extensions: [String]) -> String {\n    var strongest_extension = \"\"\n    var\
    \ max_strength = -1\n    for extension in extensions {\n        let class_name_components\
    \ = class_name.components(separatedBy: \".\")\n        let extension_components\
    \ = extension.components(separatedBy: \".\")\n        let class_name_length =\
    \ class_name_components.count\n        let extension_length = extension_components.count\n\
    \        let class_name_components_count = class_name_components.count\n     \
    \   let extension_components_count = extension_components.count\n        let class_name_components_count_upper\
    \ = class_name_components_count - class_name_components.count\n        let extension_components_count_upper\
    \ = extension_components_count - extension_components.count\n        let class_name_components_count_lower\
    \ = class_name_components.count - class_name_components_count_upper\n        let\
    \ extension_components_count_lower = extension_components.count - extension_components_count_upper\n\
    \        let class_name_components_count_lower_upper = class_name_components_count_lower\
    \ - class_name_components_count_upper\n        let extension_components_count_lower_upper\
    \ = extension_components_count_lower - extension_components_count_upper\n    \
    \    let class_name_components_count_lower_upper_sm = class_name_components_count_lower_upper\
    \ - class_name_components_count_upper\n        let extension_components_count_lower_upper_sm\
    \ = extension_components_count_lower_upper - extension_components_count_upper\n\
    \        let class_name_components_count_lower_upper_cap = class_name_components_count_lower_upper\
    \ - class_name_components_count_upper_sm\n        let extension_components_count_lower_upper_cap\
    \ = extension_components_count_lower_upper - extension_components_count_upper_sm\n\
    \        let class_name_components_count_lower_upper_sm_cap = class_name_components_count_lower_upper_sm\
    \ - class_name_components_count_upper_cap\n        let extension_components_count_lower_upper_sm_cap\
    \ = extension_components_count_lower_upper_sm - extension_components_count_upper_cap\n\
    \        let class_name_components_count_lower_upper_sm_cap_sm = class_name_components_count_lower_upper_sm_cap\
    \ - class_name_components_count_lower_upper_sm\n        let extension_components_count_lower_upper_sm_cap_sm\
    \ = extension_components_count_lower_upper_sm_cap - extension_components_count_lower_upper_sm\n\
    \        let class_name_components_count_lower_upper_sm_cap_sm_sm = class_name_components_count_lower_upper_sm_cap_sm\
    \ - class_name_components_count_lower_upper_sm\n        let extension_components_count_lower_upper_sm_cap_sm_sm\
    \ = extension_components_count_lower_upper_sm_cap_sm - extension_components_count_lower_upper_sm\n\
    \        let class_\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp6ohpb1f7.swift:20:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmp6ohpb1f7.swift:20:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmp6ohpb1f7.swift:20:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmp6ohpb1f7.swift:22:36:\
    \ error: expected initial value after '='\n        let extension_components =\
    \ extension.components(separatedBy: \".\")\n                                 \
    \  ^\n/tmp/tmp6ohpb1f7.swift:22:35: error: consecutive statements on a line must\
    \ be separated by ';'\n        let extension_components = extension.components(separatedBy:\
    \ \".\")\n                                  ^\n                              \
    \    ;\n/tmp/tmp6ohpb1f7.swift:22:45: error: expected type name in extension declaration\n\
    \        let extension_components = extension.components(separatedBy: \".\")\n\
    \                                            ^\n/tmp/tmp6ohpb1f7.swift:22:45:\
    \ error: expected '{' in extension\n        let extension_components = extension.components(separatedBy:\
    \ \".\")\n                                            ^\n/tmp/tmp6ohpb1f7.swift:22:36:\
    \ error: declaration is only valid at file scope\n        let extension_components\
    \ = extension.components(separatedBy: \".\")\n                               \
    \    ^\n/tmp/tmp6ohpb1f7.swift:67:91: error: expected '}' at end of brace statement\n\
    assert(Strongest_Extension(class_name: \"Sp\", extensions: [\"671235\", \"Bb\"\
    ]) == \"Sp.671235\")\n                                                       \
    \                                   ^\n/tmp/tmp6ohpb1f7.swift:17:78: note: to\
    \ match this opening '{'\nfunc Strongest_Extension(class_name: String, extensions:\
    \ [String]) -> String {\n                                                    \
    \                         ^\n/tmp/tmp6ohpb1f7.swift:47:6: error: operator functions\
    \ can only be declared at global or in type scope\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n     ^\n/tmp/tmp6ohpb1f7.swift:21:48: error:\
    \ value of type 'St"
  stdout: ''
  timestamp: 1659820881
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfunc Strongest_Extension(class_name: String,\
    \ extensions: [String]) -> String {\n    var strongest_extension = \"\"\n    var\
    \ strongest_extension_strength = -1\n    for extension in extensions {\n     \
    \   let extension_strength = extension.characters.reduce(0) { (sum, char) -> Int\
    \ in\n            let char_upper = char.uppercaseString\n            let char_lower\
    \ = char.lowercaseString\n            return sum + char_upper.characters.count\
    \ - char_lower.characters.count\n        }\n        if extension_strength > strongest_extension_strength\
    \ {\n            strongest_extension_strength = extension_strength\n         \
    \   strongest_extension = extension\n        }\n    }\n    return class_name +\
    \ \".\" + strongest_extension\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpeanpy3us.swift:20:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpeanpy3us.swift:20:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpeanpy3us.swift:20:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpeanpy3us.swift:21:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.characters.reduce(0)\
    \ { (sum, char) -> Int in\n                                 ^\n/tmp/tmpeanpy3us.swift:21:33:\
    \ error: consecutive statements on a line must be separated by ';'\n        let\
    \ extension_strength = extension.characters.reduce(0) { (sum, char) -> Int in\n\
    \                                ^\n                                ;\n/tmp/tmpeanpy3us.swift:21:43:\
    \ error: expected type name in extension declaration\n        let extension_strength\
    \ = extension.characters.reduce(0) { (sum, char) -> Int in\n                 \
    \                         ^\n/tmp/tmpeanpy3us.swift:21:43: error: expected '{'\
    \ in extension\n        let extension_strength = extension.characters.reduce(0)\
    \ { (sum, char) -> Int in\n                                          ^\n/tmp/tmpeanpy3us.swift:21:34:\
    \ error: declaration is only valid at file scope\n        let extension_strength\
    \ = extension.characters.reduce(0) { (sum, char) -> Int in\n                 \
    \                ^\n/tmp/tmpeanpy3us.swift:28:35: error: expected expression in\
    \ assignment\n            strongest_extension = extension\n                  \
    \                ^\n/tmp/tmpeanpy3us.swift:29:9: error: expected type name in\
    \ extension declaration\n        }\n        ^\n/tmp/tmpeanpy3us.swift:28:44: error:\
    \ expected '{' in extension\n            strongest_extension = extension\n   \
    \                                        ^\n/tmp/tmpeanpy3us.swift:28:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                                  ^\n"
  stdout: ''
  timestamp: 1659820881
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfunc Strongest_Extension(class_name: String,\
    \ extensions: [String]) -> String {\n    var strongest_extension = \"\"\n    var\
    \ strongest_extension_strength = -1\n    for extension in extensions {\n     \
    \   let extension_strength = extension.countUpToLowercaseLetters()\n        if\
    \ extension_strength > strongest_extension_strength {\n            strongest_extension_strength\
    \ = extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp6jifw92_.swift:20:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmp6jifw92_.swift:20:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmp6jifw92_.swift:20:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmp6jifw92_.swift:21:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmp6jifw92_.swift:21:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        let extension_strength\
    \ = extension.countUpToLowercaseLetters()\n                                ^\n\
    \                                ;\n/tmp/tmp6jifw92_.swift:21:43: error: expected\
    \ type name in extension declaration\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmp6jifw92_.swift:21:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmp6jifw92_.swift:21:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmp6jifw92_.swift:24:35: error: expected\
    \ expression in assignment\n            strongest_extension = extension\n    \
    \                              ^\n/tmp/tmp6jifw92_.swift:25:9: error: expected\
    \ type name in extension declaration\n        }\n        ^\n/tmp/tmp6jifw92_.swift:24:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           ^\n/tmp/tmp6jifw92_.swift:24:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                                  ^\n"
  stdout: ''
  timestamp: 1659820881
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfunc Strongest_Extension(class_name: String,\
    \ extensions: [String]) -> String {\n    var strongest_extension = \"\"\n    var\
    \ strongest_extension_strength = -1\n    for extension in extensions {\n     \
    \   let extension_strength = extension.countUpToUppercaseLetters - extension.countUpToLowercaseLetters\n\
    \        if extension_strength > strongest_extension_strength {\n            strongest_extension_strength\
    \ = extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpxhz_h2fn.swift:20:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpxhz_h2fn.swift:20:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpxhz_h2fn.swift:20:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpxhz_h2fn.swift:21:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUpToUppercaseLetters\
    \ - extension.countUpToLowercaseLetters\n                                 ^\n\
    /tmp/tmpxhz_h2fn.swift:21:33: error: consecutive statements on a line must be\
    \ separated by ';'\n        let extension_strength = extension.countUpToUppercaseLetters\
    \ - extension.countUpToLowercaseLetters\n                                ^\n \
    \                               ;\n/tmp/tmpxhz_h2fn.swift:21:43: error: expected\
    \ type name in extension declaration\n        let extension_strength = extension.countUpToUppercaseLetters\
    \ - extension.countUpToLowercaseLetters\n                                    \
    \      ^\n/tmp/tmpxhz_h2fn.swift:21:43: error: expected '{' in extension\n   \
    \     let extension_strength = extension.countUpToUppercaseLetters - extension.countUpToLowercaseLetters\n\
    \                                          ^\n/tmp/tmpxhz_h2fn.swift:21:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.countUpToUppercaseLetters\
    \ - extension.countUpToLowercaseLetters\n                                 ^\n\
    /tmp/tmpxhz_h2fn.swift:21:81: error: expected type name in extension declaration\n\
    \        let extension_strength = extension.countUpToUppercaseLetters - extension.countUpToLowercaseLetters\n\
    \                                                                            \
    \    ^\n/tmp/tmpxhz_h2fn.swift:21:81: error: expected '{' in extension\n     \
    \   let extension_strength = extension.countUpToUppercaseLetters - extension.countUpToLowercaseLetters\n\
    \                                                                            \
    \    ^\n/tmp/tmpxhz_h2fn.swift:21:7"
  stdout: ''
  timestamp: 1659820881
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfunc Strongest_Extension(class_name: String,\
    \ extensions: [String]) -> String {\n    var strongest_extension = \"\"\n    var\
    \ strongest_extension_strength = -1\n    for extension in extensions {\n     \
    \   let class_name_components = class_name.components(separatedBy: \".\")\n  \
    \      let extension_components = extension.components(separatedBy: \".\")\n \
    \       let class_name_components_count = class_name_components.count\n      \
    \  let extension_components_count = extension_components.count\n        let class_name_components_count_upper\
    \ = class_name_components.filter({ $0.isUppercase}).count\n        let extension_components_count_lower\
    \ = extension_components.filter({ $0.isLowercase}).count\n        let class_name_components_count_upper_small\
    \ = class_name_components_count_upper - class_name_components_count_lower\n  \
    \      let extension_components_count_lower_small = extension_components_count_lower\
    \ - extension_components_count_upper\n        let class_name_components_count_lower_small\
    \ = class_name_components_count_lower - class_name_components_count_upper_small\n\
    \        let extension_components_count_upper_small = extension_components_count_upper\
    \ - extension_components_count_lower_small\n        let extension_components_count_lower_small\
    \ = extension_components_count_lower - extension_components_count_upper_small\n\
    \        let extension_components_count_equal_small = extension_components_count_lower\
    \ == extension_components_count_upper\n        let extension_components_count_equal_small\
    \ = extension_components_count_lower == extension_components_count_upper_small\n\
    \        let extension_components_count_equal_small = extension_components_count_lower\
    \ == extension_components_count_lower_small\n        let extension_components_count_equal_small\
    \ = extension_components_count_lower == extension_components_count_upper_small\n\
    \        let extension_components_count_equal_small = extension_components_count_lower\
    \ == extension_components_count_lower_small\n        let extension_components_count_equal_small\
    \ = extension_components_count_lower == extension_components_count_upper_small\n\
    \        let extension_components_count_equal_small = extension_components_count_lower\
    \ == extension_components_count_lower_small\n        let extension_components_count_equal_small\
    \ = extension_components_count_lower == extension_components_count_upper_small\n\
    \        let extension_components_count_equal_small = extension_components_count_lower\
    \ == extension_components_count_lower_small\n        let extension_components_count_equal_small\
    \ = extension_components_count_lower == extension_components_count_upper_small\n\
    \        let extension_components_count_equal_small = extension_components_count_lower\
    \ == extension_components_count_lower_small\n        let extension_\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpvcc4_o00.swift:20:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpvcc4_o00.swift:20:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpvcc4_o00.swift:20:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpvcc4_o00.swift:22:36:\
    \ error: expected initial value after '='\n        let extension_components =\
    \ extension.components(separatedBy: \".\")\n                                 \
    \  ^\n/tmp/tmpvcc4_o00.swift:22:35: error: consecutive statements on a line must\
    \ be separated by ';'\n        let extension_components = extension.components(separatedBy:\
    \ \".\")\n                                  ^\n                              \
    \    ;\n/tmp/tmpvcc4_o00.swift:22:45: error: expected type name in extension declaration\n\
    \        let extension_components = extension.components(separatedBy: \".\")\n\
    \                                            ^\n/tmp/tmpvcc4_o00.swift:22:45:\
    \ error: expected '{' in extension\n        let extension_components = extension.components(separatedBy:\
    \ \".\")\n                                            ^\n/tmp/tmpvcc4_o00.swift:22:36:\
    \ error: declaration is only valid at file scope\n        let extension_components\
    \ = extension.components(separatedBy: \".\")\n                               \
    \    ^\n/tmp/tmpvcc4_o00.swift:67:91: error: expected '}' at end of brace statement\n\
    assert(Strongest_Extension(class_name: \"Sp\", extensions: [\"671235\", \"Bb\"\
    ]) == \"Sp.671235\")\n                                                       \
    \                                   ^\n/tmp/tmpvcc4_o00.swift:17:78: note: to\
    \ match this opening '{'\nfunc Strongest_Extension(class_name: String, extensions:\
    \ [String]) -> String {\n                                                    \
    \                         ^\n/tmp/tmpvcc4_o00.swift:47:6: error: operator functions\
    \ can only be declared at global or in type scope\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n     ^\n/tmp/tmpvcc4_o00.swift:21:48: error:\
    \ value of type 'St"
  stdout: ''
  timestamp: 1659820881
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfunc Strongest_Extension(class_name: String,\
    \ extensions: [String]) -> String {\n    var strongest_extension = \"\"\n    var\
    \ max_strength = -1\n    for extension in extensions {\n        let extension_strength\
    \ = extension.characters.count\n        if extension_strength > max_strength {\n\
    \            max_strength = extension_strength\n            strongest_extension\
    \ = extension\n        }\n    }\n    return class_name + \".\" + strongest_extension\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp_yurf75k.swift:20:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmp_yurf75k.swift:20:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmp_yurf75k.swift:20:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmp_yurf75k.swift:21:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.characters.count\n\
    \                                 ^\n/tmp/tmp_yurf75k.swift:21:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        let extension_strength\
    \ = extension.characters.count\n                                ^\n          \
    \                      ;\n/tmp/tmp_yurf75k.swift:21:43: error: expected type name\
    \ in extension declaration\n        let extension_strength = extension.characters.count\n\
    \                                          ^\n/tmp/tmp_yurf75k.swift:21:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.characters.count\n\
    \                                          ^\n/tmp/tmp_yurf75k.swift:21:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.characters.count\n\
    \                                 ^\n/tmp/tmp_yurf75k.swift:24:35: error: expected\
    \ expression in assignment\n            strongest_extension = extension\n    \
    \                              ^\n/tmp/tmp_yurf75k.swift:25:9: error: expected\
    \ type name in extension declaration\n        }\n        ^\n/tmp/tmp_yurf75k.swift:24:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           ^\n/tmp/tmp_yurf75k.swift:24:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                                  ^\n"
  stdout: ''
  timestamp: 1659820881
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfunc Strongest_Extension(class_name: String,\
    \ extensions: [String]) -> String {\n    var strongest_extension = \"\"\n    var\
    \ strongest_extension_strength = -1\n    for extension in extensions {\n     \
    \   let extension_strength = extension.countUpToLowercaseLetters()\n        if\
    \ extension_strength > strongest_extension_strength {\n            strongest_extension_strength\
    \ = extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp6jifw92_.swift:20:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmp6jifw92_.swift:20:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmp6jifw92_.swift:20:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmp6jifw92_.swift:21:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmp6jifw92_.swift:21:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        let extension_strength\
    \ = extension.countUpToLowercaseLetters()\n                                ^\n\
    \                                ;\n/tmp/tmp6jifw92_.swift:21:43: error: expected\
    \ type name in extension declaration\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmp6jifw92_.swift:21:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmp6jifw92_.swift:21:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmp6jifw92_.swift:24:35: error: expected\
    \ expression in assignment\n            strongest_extension = extension\n    \
    \                              ^\n/tmp/tmp6jifw92_.swift:25:9: error: expected\
    \ type name in extension declaration\n        }\n        ^\n/tmp/tmp6jifw92_.swift:24:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           ^\n/tmp/tmp6jifw92_.swift:24:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                                  ^\n"
  stdout: ''
  timestamp: 1659820881
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfunc Strongest_Extension(class_name: String,\
    \ extensions: [String]) -> String {\n    var strongest_extension = \"\"\n    var\
    \ strongest_extension_strength = -1\n    for extension in extensions {\n     \
    \   var extension_strength = extension.count\n        for letter in extension\
    \ {\n            if letter.isUpper() {\n                extension_strength -=\
    \ 1\n            }\n        }\n        if extension_strength > strongest_extension_strength\
    \ {\n            strongest_extension_strength = extension_strength\n         \
    \   strongest_extension = extension\n        }\n    }\n    return class_name +\
    \ \".\" + strongest_extension\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpdc2q9gnv.swift:20:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpdc2q9gnv.swift:20:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpdc2q9gnv.swift:20:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpdc2q9gnv.swift:21:34:\
    \ error: expected initial value after '='\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmpdc2q9gnv.swift:21:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        var extension_strength\
    \ = extension.count\n                                ^\n                     \
    \           ;\n/tmp/tmpdc2q9gnv.swift:21:43: error: expected type name in extension\
    \ declaration\n        var extension_strength = extension.count\n            \
    \                              ^\n/tmp/tmpdc2q9gnv.swift:21:43: error: expected\
    \ '{' in extension\n        var extension_strength = extension.count\n       \
    \                                   ^\n/tmp/tmpdc2q9gnv.swift:21:34: error: declaration\
    \ is only valid at file scope\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmpdc2q9gnv.swift:22:23: error: expected\
    \ Sequence expression for for-each loop\n        for letter in extension {\n \
    \                     ^\n/tmp/tmpdc2q9gnv.swift:22:23: error: expected '{' to\
    \ start the body of for-each loop\n        for letter in extension {\n       \
    \               ^\n/tmp/tmpdc2q9gnv.swift:29:35: error: expected expression in\
    \ assignment\n            strongest_extension = extension\n                  \
    \                ^\n/tmp/tmpdc2q9gnv.swift:30:9: error: expected type name in\
    \ extension declaration\n        }\n        ^\n/tmp/tmpdc2q9gnv.swift:29:44: error:\
    \ expected '{' in extension\n            strongest_extension = extension\n   \
    \                                        ^\n/tmp/tmpdc2q9gnv.swift:29:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                              "
  stdout: ''
  timestamp: 1659820881
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfunc Strongest_Extension(class_name: String,\
    \ extensions: [String]) -> String {\n    var strongest_extension = \"\"\n    var\
    \ strongest_extension_strength = -1\n    for extension in extensions {\n     \
    \   let extension_strength = extension.countUpToLowercaseLetters()\n        if\
    \ extension_strength > strongest_extension_strength {\n            strongest_extension_strength\
    \ = extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp6jifw92_.swift:20:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmp6jifw92_.swift:20:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmp6jifw92_.swift:20:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmp6jifw92_.swift:21:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmp6jifw92_.swift:21:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        let extension_strength\
    \ = extension.countUpToLowercaseLetters()\n                                ^\n\
    \                                ;\n/tmp/tmp6jifw92_.swift:21:43: error: expected\
    \ type name in extension declaration\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmp6jifw92_.swift:21:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmp6jifw92_.swift:21:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmp6jifw92_.swift:24:35: error: expected\
    \ expression in assignment\n            strongest_extension = extension\n    \
    \                              ^\n/tmp/tmp6jifw92_.swift:25:9: error: expected\
    \ type name in extension declaration\n        }\n        ^\n/tmp/tmp6jifw92_.swift:24:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           ^\n/tmp/tmp6jifw92_.swift:24:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                                  ^\n"
  stdout: ''
  timestamp: 1659820881
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfunc Strongest_Extension(class_name: String,\
    \ extensions: [String]) -> String {\n    var strongest_extension = \"\"\n    var\
    \ strongest_extension_strength = -1\n    for extension in extensions {\n     \
    \   var extension_strength = extension.count\n        for letter in extension\
    \ {\n            if letter.isUpper() {\n                extension_strength -=\
    \ 1\n            }\n        }\n        if extension_strength > strongest_extension_strength\
    \ {\n            strongest_extension_strength = extension_strength\n         \
    \   strongest_extension = extension\n        }\n    }\n    return class_name +\
    \ \".\" + strongest_extension\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpdc2q9gnv.swift:20:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpdc2q9gnv.swift:20:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpdc2q9gnv.swift:20:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpdc2q9gnv.swift:21:34:\
    \ error: expected initial value after '='\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmpdc2q9gnv.swift:21:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        var extension_strength\
    \ = extension.count\n                                ^\n                     \
    \           ;\n/tmp/tmpdc2q9gnv.swift:21:43: error: expected type name in extension\
    \ declaration\n        var extension_strength = extension.count\n            \
    \                              ^\n/tmp/tmpdc2q9gnv.swift:21:43: error: expected\
    \ '{' in extension\n        var extension_strength = extension.count\n       \
    \                                   ^\n/tmp/tmpdc2q9gnv.swift:21:34: error: declaration\
    \ is only valid at file scope\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmpdc2q9gnv.swift:22:23: error: expected\
    \ Sequence expression for for-each loop\n        for letter in extension {\n \
    \                     ^\n/tmp/tmpdc2q9gnv.swift:22:23: error: expected '{' to\
    \ start the body of for-each loop\n        for letter in extension {\n       \
    \               ^\n/tmp/tmpdc2q9gnv.swift:29:35: error: expected expression in\
    \ assignment\n            strongest_extension = extension\n                  \
    \                ^\n/tmp/tmpdc2q9gnv.swift:30:9: error: expected type name in\
    \ extension declaration\n        }\n        ^\n/tmp/tmpdc2q9gnv.swift:29:44: error:\
    \ expected '{' in extension\n            strongest_extension = extension\n   \
    \                                        ^\n/tmp/tmpdc2q9gnv.swift:29:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                              "
  stdout: ''
  timestamp: 1659820881
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfunc Strongest_Extension(class_name: String,\
    \ extensions: [String]) -> String {\n    var strongest_extension = \"\"\n    var\
    \ max_strength = -1\n    for extension in extensions {\n        var strength =\
    \ count_capital_letters(extension) - count_capital_letters(extension.lowercaseString)\n\
    \        if strength > max_strength {\n            max_strength = strength\n \
    \           strongest_extension = extension\n        }\n    }\n    return class_name\
    \ + \".\" + strongest_extension\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpuqiu69ui.swift:20:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpuqiu69ui.swift:20:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpuqiu69ui.swift:20:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpuqiu69ui.swift:21:46:\
    \ error: expected expression in list of expressions\n        var strength = count_capital_letters(extension)\
    \ - count_capital_letters(extension.lowercaseString)\n                       \
    \                      ^\n/tmp/tmpuqiu69ui.swift:21:46: error: consecutive statements\
    \ on a line must be separated by ';'\n        var strength = count_capital_letters(extension)\
    \ - count_capital_letters(extension.lowercaseString)\n                       \
    \                      ^\n                                             ;\n/tmp/tmpuqiu69ui.swift:21:55:\
    \ error: expected type name in extension declaration\n        var strength = count_capital_letters(extension)\
    \ - count_capital_letters(extension.lowercaseString)\n                       \
    \                               ^\n                                          \
    \             <#type#>\n/tmp/tmpuqiu69ui.swift:21:55: error: expected '{' in extension\n\
    \        var strength = count_capital_letters(extension) - count_capital_letters(extension.lowercaseString)\n\
    \                                                      ^\n/tmp/tmpuqiu69ui.swift:21:46:\
    \ error: declaration is only valid at file scope\n        var strength = count_capital_letters(extension)\
    \ - count_capital_letters(extension.lowercaseString)\n                       \
    \                      ^\n/tmp/tmpuqiu69ui.swift:24:35: error: expected expression\
    \ in assignment\n            strongest_extension = extension\n               \
    \                   ^\n/tmp/tmpuqiu69ui.swift:25:9: error: expected type name\
    \ in extension declaration\n        }\n        ^\n/tmp/tmpuqiu69ui.swift:24:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           "
  stdout: ''
  timestamp: 1659820881
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfunc Strongest_Extension(class_name: String,\
    \ extensions: [String]) -> String {\n    var strongest_extension = \"\"\n    var\
    \ strongest_extension_strength = -1\n    for extension in extensions {\n     \
    \   var extension_strength = extension.count\n        for letter in extension\
    \ {\n            if letter.isUpper() {\n                extension_strength -=\
    \ 1\n            }\n        }\n        if extension_strength > strongest_extension_strength\
    \ {\n            strongest_extension_strength = extension_strength\n         \
    \   strongest_extension = extension\n        }\n    }\n    return class_name +\
    \ \".\" + strongest_extension\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpdc2q9gnv.swift:20:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpdc2q9gnv.swift:20:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpdc2q9gnv.swift:20:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpdc2q9gnv.swift:21:34:\
    \ error: expected initial value after '='\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmpdc2q9gnv.swift:21:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        var extension_strength\
    \ = extension.count\n                                ^\n                     \
    \           ;\n/tmp/tmpdc2q9gnv.swift:21:43: error: expected type name in extension\
    \ declaration\n        var extension_strength = extension.count\n            \
    \                              ^\n/tmp/tmpdc2q9gnv.swift:21:43: error: expected\
    \ '{' in extension\n        var extension_strength = extension.count\n       \
    \                                   ^\n/tmp/tmpdc2q9gnv.swift:21:34: error: declaration\
    \ is only valid at file scope\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmpdc2q9gnv.swift:22:23: error: expected\
    \ Sequence expression for for-each loop\n        for letter in extension {\n \
    \                     ^\n/tmp/tmpdc2q9gnv.swift:22:23: error: expected '{' to\
    \ start the body of for-each loop\n        for letter in extension {\n       \
    \               ^\n/tmp/tmpdc2q9gnv.swift:29:35: error: expected expression in\
    \ assignment\n            strongest_extension = extension\n                  \
    \                ^\n/tmp/tmpdc2q9gnv.swift:30:9: error: expected type name in\
    \ extension declaration\n        }\n        ^\n/tmp/tmpdc2q9gnv.swift:29:44: error:\
    \ expected '{' in extension\n            strongest_extension = extension\n   \
    \                                        ^\n/tmp/tmpdc2q9gnv.swift:29:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                              "
  stdout: ''
  timestamp: 1659820881
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfunc Strongest_Extension(class_name: String,\
    \ extensions: [String]) -> String {\n    var strongest_extension = \"\"\n    var\
    \ strongest_extension_strength = -1\n    for extension in extensions {\n     \
    \   let class_name_components = class_name.components(separatedBy: \".\")\n  \
    \      let extension_components = extension.components(separatedBy: \".\")\n \
    \       let class_name_components_count = class_name_components.count\n      \
    \  let extension_components_count = extension_components.count\n        let class_name_components_count_cap\
    \ = class_name_components.map { $0.isUppercase }.count\n        let extension_components_count_cap\
    \ = extension_components.map { $0.isUppercase }.count\n        let class_name_components_count_sm\
    \ = class_name_components.map { $0.isLowercase }.count\n        let extension_components_count_sm\
    \ = extension_components.map { $0.isLowercase }.count\n        let class_name_components_count_cap_sm\
    \ = (class_name_components_count_cap - class_name_components_count_sm)\n     \
    \   let extension_components_count_cap_sm = (extension_components_count_cap -\
    \ extension_components_count_sm)\n        let class_name_components_count_cap_sm_ratio\
    \ = class_name_components_count_cap_sm / class_name_components_count_sm\n    \
    \    let extension_components_count_cap_sm_ratio = extension_components_count_cap_sm\
    \ / extension_components_count_sm\n        let class_name_components_count_cap_sm_ratio_power\
    \ = class_name_components_count_cap_sm_ratio * class_name_components_count_cap\n\
    \        let extension_components_count_cap_sm_ratio_power = extension_components_count_cap_sm_ratio\
    \ * extension_components_count_cap\n        let class_name_components_count_cap_sm_ratio_power_power\
    \ = class_name_components_count_cap_sm_ratio_power * class_name_components_count_cap\n\
    \        let extension_components_count_cap_sm_ratio_power_power = extension_components_count_cap_sm_ratio_power\
    \ * extension_components_count_cap\n        let class_name_components_count_cap_sm_ratio_power_power_power\
    \ = class_name_components_count_cap_sm_ratio_power_power * class_name_components_count_cap\n\
    \        let extension_components_count_cap_sm_ratio_power_power_power = extension_components_count_cap_sm_ratio_power_power\
    \ * extension_components_count_cap\n        let class_name_components_count_cap_sm_ratio_power_power_power_power\
    \ = class_name_components_count_cap_sm_ratio_power_power_power * class_name_components_count_cap\n\
    \        let extension_components_count_cap_sm_ratio_power_power_power_power =\
    \ extension_components_count_cap_sm_ratio_power_power_power * extension_component\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp6r2wonra.swift:20:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmp6r2wonra.swift:20:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmp6r2wonra.swift:20:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmp6r2wonra.swift:22:36:\
    \ error: expected initial value after '='\n        let extension_components =\
    \ extension.components(separatedBy: \".\")\n                                 \
    \  ^\n/tmp/tmp6r2wonra.swift:22:35: error: consecutive statements on a line must\
    \ be separated by ';'\n        let extension_components = extension.components(separatedBy:\
    \ \".\")\n                                  ^\n                              \
    \    ;\n/tmp/tmp6r2wonra.swift:22:45: error: expected type name in extension declaration\n\
    \        let extension_components = extension.components(separatedBy: \".\")\n\
    \                                            ^\n/tmp/tmp6r2wonra.swift:22:45:\
    \ error: expected '{' in extension\n        let extension_components = extension.components(separatedBy:\
    \ \".\")\n                                            ^\n/tmp/tmp6r2wonra.swift:22:36:\
    \ error: declaration is only valid at file scope\n        let extension_components\
    \ = extension.components(separatedBy: \".\")\n                               \
    \    ^\n/tmp/tmp6r2wonra.swift:64:91: error: expected '}' at end of brace statement\n\
    assert(Strongest_Extension(class_name: \"Sp\", extensions: [\"671235\", \"Bb\"\
    ]) == \"Sp.671235\")\n                                                       \
    \                                   ^\n/tmp/tmp6r2wonra.swift:17:78: note: to\
    \ match this opening '{'\nfunc Strongest_Extension(class_name: String, extensions:\
    \ [String]) -> String {\n                                                    \
    \                         ^\n/tmp/tmp6r2wonra.swift:44:6: error: operator functions\
    \ can only be declared at global or in type scope\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n     ^\n/tmp/tmp6r2wonra.swift:21:48: error:\
    \ value of type 'St"
  stdout: ''
  timestamp: 1659820882
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfunc Strongest_Extension(class_name: String,\
    \ extensions: [String]) -> String {\n    var strongest_extension = \"\"\n    var\
    \ strongest_extension_strength = -1\n    for extension in extensions {\n     \
    \   var extension_strength = extension.count\n        for letter in extension\
    \ {\n            if letter.isUpper() {\n                extension_strength -=\
    \ 1\n            }\n        }\n        if extension_strength > strongest_extension_strength\
    \ {\n            strongest_extension = class_name\n            strongest_extension_strength\
    \ = extension_strength\n        }\n    }\n    return strongest_extension\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpc77nuunh.swift:20:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpc77nuunh.swift:20:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpc77nuunh.swift:20:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpc77nuunh.swift:21:34:\
    \ error: expected initial value after '='\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmpc77nuunh.swift:21:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        var extension_strength\
    \ = extension.count\n                                ^\n                     \
    \           ;\n/tmp/tmpc77nuunh.swift:21:43: error: expected type name in extension\
    \ declaration\n        var extension_strength = extension.count\n            \
    \                              ^\n/tmp/tmpc77nuunh.swift:21:43: error: expected\
    \ '{' in extension\n        var extension_strength = extension.count\n       \
    \                                   ^\n/tmp/tmpc77nuunh.swift:21:34: error: declaration\
    \ is only valid at file scope\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmpc77nuunh.swift:22:23: error: expected\
    \ Sequence expression for for-each loop\n        for letter in extension {\n \
    \                     ^\n/tmp/tmpc77nuunh.swift:22:23: error: expected '{' to\
    \ start the body of for-each loop\n        for letter in extension {\n       \
    \               ^\n"
  stdout: ''
  timestamp: 1659820882
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfunc Strongest_Extension(class_name: String,\
    \ extensions: [String]) -> String {\n    var strongest_extension = \"\"\n    var\
    \ strongest_extension_strength = -1\n    for extension in extensions {\n     \
    \   var extension_strength = extension.count\n        for letter in extension\
    \ {\n            if letter.isUpper() {\n                extension_strength -=\
    \ 1\n            }\n        }\n        if extension_strength > strongest_extension_strength\
    \ {\n            strongest_extension_strength = extension_strength\n         \
    \   strongest_extension = extension\n        }\n    }\n    return class_name +\
    \ \".\" + strongest_extension\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpdc2q9gnv.swift:20:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpdc2q9gnv.swift:20:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpdc2q9gnv.swift:20:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpdc2q9gnv.swift:21:34:\
    \ error: expected initial value after '='\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmpdc2q9gnv.swift:21:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        var extension_strength\
    \ = extension.count\n                                ^\n                     \
    \           ;\n/tmp/tmpdc2q9gnv.swift:21:43: error: expected type name in extension\
    \ declaration\n        var extension_strength = extension.count\n            \
    \                              ^\n/tmp/tmpdc2q9gnv.swift:21:43: error: expected\
    \ '{' in extension\n        var extension_strength = extension.count\n       \
    \                                   ^\n/tmp/tmpdc2q9gnv.swift:21:34: error: declaration\
    \ is only valid at file scope\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmpdc2q9gnv.swift:22:23: error: expected\
    \ Sequence expression for for-each loop\n        for letter in extension {\n \
    \                     ^\n/tmp/tmpdc2q9gnv.swift:22:23: error: expected '{' to\
    \ start the body of for-each loop\n        for letter in extension {\n       \
    \               ^\n/tmp/tmpdc2q9gnv.swift:29:35: error: expected expression in\
    \ assignment\n            strongest_extension = extension\n                  \
    \                ^\n/tmp/tmpdc2q9gnv.swift:30:9: error: expected type name in\
    \ extension declaration\n        }\n        ^\n/tmp/tmpdc2q9gnv.swift:29:44: error:\
    \ expected '{' in extension\n            strongest_extension = extension\n   \
    \                                        ^\n/tmp/tmpdc2q9gnv.swift:29:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                              "
  stdout: ''
  timestamp: 1659820881
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfunc Strongest_Extension(class_name: String,\
    \ extensions: [String]) -> String {\n    var strongest_extension = \"\"\n    var\
    \ strongest_extension_strength = -1\n    for extension in extensions {\n     \
    \   let extension_strength = extension.countUpToLowercaseLetters()\n        if\
    \ extension_strength > strongest_extension_strength {\n            strongest_extension_strength\
    \ = extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp6jifw92_.swift:20:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmp6jifw92_.swift:20:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmp6jifw92_.swift:20:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmp6jifw92_.swift:21:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmp6jifw92_.swift:21:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        let extension_strength\
    \ = extension.countUpToLowercaseLetters()\n                                ^\n\
    \                                ;\n/tmp/tmp6jifw92_.swift:21:43: error: expected\
    \ type name in extension declaration\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmp6jifw92_.swift:21:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmp6jifw92_.swift:21:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmp6jifw92_.swift:24:35: error: expected\
    \ expression in assignment\n            strongest_extension = extension\n    \
    \                              ^\n/tmp/tmp6jifw92_.swift:25:9: error: expected\
    \ type name in extension declaration\n        }\n        ^\n/tmp/tmp6jifw92_.swift:24:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           ^\n/tmp/tmp6jifw92_.swift:24:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                                  ^\n"
  stdout: ''
  timestamp: 1659820881
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfunc Strongest_Extension(class_name: String,\
    \ extensions: [String]) -> String {\n    var strongest_extension = \"\"\n    var\
    \ max_strength = -1\n    for extension in extensions {\n        var strength =\
    \ count_capital_letters(extension) - count_capital_letters(class_name)\n     \
    \   if strength > max_strength {\n            max_strength = strength\n      \
    \      strongest_extension = extension\n        }\n    }\n    return class_name\
    \ + strongest_extension\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpgt5jrr4l.swift:20:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpgt5jrr4l.swift:20:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpgt5jrr4l.swift:20:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpgt5jrr4l.swift:21:46:\
    \ error: expected expression in list of expressions\n        var strength = count_capital_letters(extension)\
    \ - count_capital_letters(class_name)\n                                      \
    \       ^\n/tmp/tmpgt5jrr4l.swift:21:46: error: consecutive statements on a line\
    \ must be separated by ';'\n        var strength = count_capital_letters(extension)\
    \ - count_capital_letters(class_name)\n                                      \
    \       ^\n                                             ;\n/tmp/tmpgt5jrr4l.swift:21:55:\
    \ error: expected type name in extension declaration\n        var strength = count_capital_letters(extension)\
    \ - count_capital_letters(class_name)\n                                      \
    \                ^\n                                                       <#type#>\n\
    /tmp/tmpgt5jrr4l.swift:21:55: error: expected '{' in extension\n        var strength\
    \ = count_capital_letters(extension) - count_capital_letters(class_name)\n   \
    \                                                   ^\n/tmp/tmpgt5jrr4l.swift:21:46:\
    \ error: declaration is only valid at file scope\n        var strength = count_capital_letters(extension)\
    \ - count_capital_letters(class_name)\n                                      \
    \       ^\n/tmp/tmpgt5jrr4l.swift:24:35: error: expected expression in assignment\n\
    \            strongest_extension = extension\n                               \
    \   ^\n/tmp/tmpgt5jrr4l.swift:25:9: error: expected type name in extension declaration\n\
    \        }\n        ^\n/tmp/tmpgt5jrr4l.swift:24:44: error: expected '{' in extension\n\
    \            strongest_extension = extension\n                               \
    \            ^\n/tmp/tmpgt5jrr4l.swift:24:35: error: declaration is only valid\
    \ at file sc"
  stdout: ''
  timestamp: 1659820882
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfunc Strongest_Extension(class_name: String,\
    \ extensions: [String]) -> String {\n    var strongest_extension = \"\"\n    var\
    \ strength = -1 // default value\n    for extension in extensions {\n        let\
    \ cap = extension.count\n        let sm = class_name.count\n        let strength_fraction\
    \ = cap - sm\n        if strength_fraction > strength {\n            strongest_extension\
    \ = extension\n            strength = strength_fraction\n        }\n    }\n  \
    \  return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpe_7mhm0t.swift:20:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpe_7mhm0t.swift:20:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpe_7mhm0t.swift:20:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpe_7mhm0t.swift:21:19:\
    \ error: expected initial value after '='\n        let cap = extension.count\n\
    \                  ^\n/tmp/tmpe_7mhm0t.swift:21:18: error: consecutive statements\
    \ on a line must be separated by ';'\n        let cap = extension.count\n    \
    \             ^\n                 ;\n/tmp/tmpe_7mhm0t.swift:21:28: error: expected\
    \ type name in extension declaration\n        let cap = extension.count\n    \
    \                       ^\n/tmp/tmpe_7mhm0t.swift:21:28: error: expected '{' in\
    \ extension\n        let cap = extension.count\n                           ^\n\
    /tmp/tmpe_7mhm0t.swift:21:19: error: declaration is only valid at file scope\n\
    \        let cap = extension.count\n                  ^\n/tmp/tmpe_7mhm0t.swift:25:35:\
    \ error: expected expression in assignment\n            strongest_extension =\
    \ extension\n                                  ^\n/tmp/tmpe_7mhm0t.swift:26:22:\
    \ error: expected '{' in extension\n            strength = strength_fraction\n\
    \                     ^\n/tmp/tmpe_7mhm0t.swift:25:35: error: declaration is only\
    \ valid at file scope\n            strongest_extension = extension\n         \
    \                         ^\n/tmp/tmpe_7mhm0t.swift:26:13: error: cannot find\
    \ type 'strength' in scope\n            strength = strength_fraction\n       \
    \     ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659820882
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfunc Strongest_Extension(class_name: String,\
    \ extensions: [String]) -> String {\n    var strongest_extension = \"\"\n    var\
    \ strongest_extension_strength = -1\n    for extension in extensions {\n     \
    \   let extension_strength = extension.characters.filter({ $0.isUppercase }).count\
    \ - extension.characters.filter({ $0.isLowercase }).count\n        if extension_strength\
    \ > strongest_extension_strength {\n            strongest_extension_strength =\
    \ extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp6safxxdm.swift:20:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmp6safxxdm.swift:20:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmp6safxxdm.swift:20:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmp6safxxdm.swift:21:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.characters.filter({\
    \ $0.isUppercase }).count - extension.characters.filter({ $0.isLowercase }).count\n\
    \                                 ^\n/tmp/tmp6safxxdm.swift:21:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        let extension_strength\
    \ = extension.characters.filter({ $0.isUppercase }).count - extension.characters.filter({\
    \ $0.isLowercase }).count\n                                ^\n               \
    \                 ;\n/tmp/tmp6safxxdm.swift:21:43: error: expected type name in\
    \ extension declaration\n        let extension_strength = extension.characters.filter({\
    \ $0.isUppercase }).count - extension.characters.filter({ $0.isLowercase }).count\n\
    \                                          ^\n/tmp/tmp6safxxdm.swift:21:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.characters.filter({\
    \ $0.isUppercase }).count - extension.characters.filter({ $0.isLowercase }).count\n\
    \                                          ^\n/tmp/tmp6safxxdm.swift:21:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.characters.filter({\
    \ $0.isUppercase }).count - extension.characters.filter({ $0.isLowercase }).count\n\
    \                                 ^\n/tmp/tmp6safxxdm.swift:21:99: error: expected\
    \ type name in extension declaration\n        let extension_strength = extension.characters.filter({\
    \ $0.isUppercase }).count - extension.characters.filter({ $0.isLowercase }).count\n\
    \                                                                            \
    \                      ^\n/tmp/tmp6safxxdm.swift:21:99: error: expected"
  stdout: ''
  timestamp: 1659820882
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfunc Strongest_Extension(class_name: String,\
    \ extensions: [String]) -> String {\n    var strongest_extension = \"\"\n    var\
    \ strongest_extension_strength = -1\n    for extension in extensions {\n     \
    \   var extension_strength = extension.count\n        for letter in extension\
    \ {\n            if letter.isUpper() {\n                extension_strength -=\
    \ 1\n            }\n        }\n        if extension_strength > strongest_extension_strength\
    \ {\n            strongest_extension_strength = extension_strength\n         \
    \   strongest_extension = extension\n        }\n    }\n    return class_name +\
    \ \".\" + strongest_extension\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpdc2q9gnv.swift:20:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpdc2q9gnv.swift:20:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpdc2q9gnv.swift:20:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpdc2q9gnv.swift:21:34:\
    \ error: expected initial value after '='\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmpdc2q9gnv.swift:21:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        var extension_strength\
    \ = extension.count\n                                ^\n                     \
    \           ;\n/tmp/tmpdc2q9gnv.swift:21:43: error: expected type name in extension\
    \ declaration\n        var extension_strength = extension.count\n            \
    \                              ^\n/tmp/tmpdc2q9gnv.swift:21:43: error: expected\
    \ '{' in extension\n        var extension_strength = extension.count\n       \
    \                                   ^\n/tmp/tmpdc2q9gnv.swift:21:34: error: declaration\
    \ is only valid at file scope\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmpdc2q9gnv.swift:22:23: error: expected\
    \ Sequence expression for for-each loop\n        for letter in extension {\n \
    \                     ^\n/tmp/tmpdc2q9gnv.swift:22:23: error: expected '{' to\
    \ start the body of for-each loop\n        for letter in extension {\n       \
    \               ^\n/tmp/tmpdc2q9gnv.swift:29:35: error: expected expression in\
    \ assignment\n            strongest_extension = extension\n                  \
    \                ^\n/tmp/tmpdc2q9gnv.swift:30:9: error: expected type name in\
    \ extension declaration\n        }\n        ^\n/tmp/tmpdc2q9gnv.swift:29:44: error:\
    \ expected '{' in extension\n            strongest_extension = extension\n   \
    \                                        ^\n/tmp/tmpdc2q9gnv.swift:29:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                              "
  stdout: ''
  timestamp: 1659820881
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfunc Strongest_Extension(class_name: String,\
    \ extensions: [String]) -> String {\n    var strongest_extension = \"\"\n    var\
    \ strongest_extension_strength = -1\n    for extension in extensions {\n     \
    \   var extension_strength = extension.count\n        for char in extension {\n\
    \            if char.uppercased() != char {\n                extension_strength\
    \ -= 1\n            }\n        }\n        if extension_strength > strongest_extension_strength\
    \ {\n            strongest_extension_strength = extension_strength\n         \
    \   strongest_extension = extension\n        }\n    }\n    return class_name +\
    \ \".\" + strongest_extension\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp5m29v439.swift:20:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmp5m29v439.swift:20:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmp5m29v439.swift:20:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmp5m29v439.swift:21:34:\
    \ error: expected initial value after '='\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmp5m29v439.swift:21:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        var extension_strength\
    \ = extension.count\n                                ^\n                     \
    \           ;\n/tmp/tmp5m29v439.swift:21:43: error: expected type name in extension\
    \ declaration\n        var extension_strength = extension.count\n            \
    \                              ^\n/tmp/tmp5m29v439.swift:21:43: error: expected\
    \ '{' in extension\n        var extension_strength = extension.count\n       \
    \                                   ^\n/tmp/tmp5m29v439.swift:21:34: error: declaration\
    \ is only valid at file scope\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmp5m29v439.swift:22:21: error: expected\
    \ Sequence expression for for-each loop\n        for char in extension {\n   \
    \                 ^\n/tmp/tmp5m29v439.swift:22:21: error: expected '{' to start\
    \ the body of for-each loop\n        for char in extension {\n               \
    \     ^\n/tmp/tmp5m29v439.swift:29:35: error: expected expression in assignment\n\
    \            strongest_extension = extension\n                               \
    \   ^\n/tmp/tmp5m29v439.swift:30:9: error: expected type name in extension declaration\n\
    \        }\n        ^\n/tmp/tmp5m29v439.swift:29:44: error: expected '{' in extension\n\
    \            strongest_extension = extension\n                               \
    \            ^\n/tmp/tmp5m29v439.swift:29:35: error: declaration is only valid\
    \ at file scope\n            strongest_extension = extension\n               \
    \                   ^\n"
  stdout: ''
  timestamp: 1659820882
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfunc Strongest_Extension(class_name: String,\
    \ extensions: [String]) -> String {\n    var strongest_extension = \"\"\n    var\
    \ strength = -1\n    for extension in extensions {\n        var class_name_components\
    \ = class_name.components(separatedBy: \".\")\n        var extension_components\
    \ = extension.components(separatedBy: \".\")\n        var class_name = class_name_components[class_name_components.count-1]\n\
    \        var extension = extension_components[extension_components.count-1]\n\
    \        var class_components = class_name.components(separatedBy: \"_\")\n  \
    \      var extension_components = extension.components(separatedBy: \"_\")\n \
    \       var class_name = class_components[class_components.count-1]\n        var\
    \ extension = extension_components[extension_components.count-1]\n        var\
    \ class_components = class_name.components(separatedBy: \"-\")\n        var extension_components\
    \ = extension.components(separatedBy: \"-\")\n        var class_name = class_components[class_components.count-1]\n\
    \        var extension = extension_components[extension_components.count-1]\n\
    \        var class_components = class_name.components(separatedBy: \".\")\n  \
    \      var extension_components = extension.components(separatedBy: \".\")\n \
    \       var class_name = class_components[class_components.count-1]\n        var\
    \ extension = extension_components[extension_components.count-1]\n        var\
    \ class_components = class_name.components(separatedBy: \"_\")\n        var extension_components\
    \ = extension.components(separatedBy: \"_\")\n        var class_name = class_components[class_components.count-1]\n\
    \        var extension = extension_components[extension_components.count-1]\n\
    \        var class_components = class_name.components(separatedBy: \"-\")\n  \
    \      var extension_components = extension.components(separatedBy: \"-\")\n \
    \       var class_name = class_components[class_components.count-1]\n        var\
    \ extension = extension_components[extension_components.count-1]\n        var\
    \ class_components = class_name.components(separatedBy: \".\")\n        var extension_components\
    \ = extension.components(separatedBy: \".\")\n        var class_name = class_components[class_components.count-1]\n\
    \        var extension = extension_components[extension_components.count-1]\n\
    \        var class_components = class_name.components(separatedBy: \"_\")\n  \
    \      var extension_components = extension.components(separatedBy: \"_\")\n \
    \       var class_name = class_components[class_components.count-1]\n        var\
    \ extension = extension_components[extension_components.count-1]\n        var\
    \ class_components = class_name.components(separatedBy: \"-\")\n        var extension_components\
    \ = extension.components(separatedBy: \"-\")\n        var class_name = class_components[class_components.count-1]\n\
    \        var extension = extension_components[extension_components.count-1]\n\
    \        var class_components = class_name.components(separatedBy: \".\")\n  \
    \      var \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpb9kp985k.swift:20:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpb9kp985k.swift:20:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpb9kp985k.swift:20:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpb9kp985k.swift:22:36:\
    \ error: expected initial value after '='\n        var extension_components =\
    \ extension.components(separatedBy: \".\")\n                                 \
    \  ^\n/tmp/tmpb9kp985k.swift:22:35: error: consecutive statements on a line must\
    \ be separated by ';'\n        var extension_components = extension.components(separatedBy:\
    \ \".\")\n                                  ^\n                              \
    \    ;\n/tmp/tmpb9kp985k.swift:22:45: error: expected type name in extension declaration\n\
    \        var extension_components = extension.components(separatedBy: \".\")\n\
    \                                            ^\n/tmp/tmpb9kp985k.swift:22:45:\
    \ error: expected '{' in extension\n        var extension_components = extension.components(separatedBy:\
    \ \".\")\n                                            ^\n/tmp/tmpb9kp985k.swift:22:36:\
    \ error: declaration is only valid at file scope\n        var extension_components\
    \ = extension.components(separatedBy: \".\")\n                               \
    \    ^\n/tmp/tmpb9kp985k.swift:24:13: error: keyword 'extension' cannot be used\
    \ as an identifier here\n        var extension = extension_components[extension_components.count-1]\n\
    \            ^\n/tmp/tmpb9kp985k.swift:24:13: note: if this name is unavoidable,\
    \ use backticks to escape it\n        var extension = extension_components[extension_components.count-1]\n\
    \            ^~~~~~~~~\n            `extension`\n/tmp/tmpb9kp985k.swift:26:36:\
    \ error: expected initial value after '='\n        var extension_components =\
    \ extension.components(separatedBy: \"_\")\n                                 \
    \  ^\n/tmp/tmpb9kp985k.swift:26:35: error: consecutive statements on a line must\
    \ be separated by ';'\n        var extension_componen"
  stdout: ''
  timestamp: 1659820882
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfunc Strongest_Extension(class_name: String,\
    \ extensions: [String]) -> String {\n    var strongest_extension = \"\"\n    var\
    \ strongest_extension_strength = -1\n    for extension in extensions {\n     \
    \   let extension_strength = extension.countUpToUppercase() - extension.countUpToLowercase()\n\
    \        if extension_strength > strongest_extension_strength {\n            strongest_extension_strength\
    \ = extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpkhpb8s88.swift:20:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpkhpb8s88.swift:20:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpkhpb8s88.swift:20:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpkhpb8s88.swift:21:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUpToUppercase()\
    \ - extension.countUpToLowercase()\n                                 ^\n/tmp/tmpkhpb8s88.swift:21:33:\
    \ error: consecutive statements on a line must be separated by ';'\n        let\
    \ extension_strength = extension.countUpToUppercase() - extension.countUpToLowercase()\n\
    \                                ^\n                                ;\n/tmp/tmpkhpb8s88.swift:21:43:\
    \ error: expected type name in extension declaration\n        let extension_strength\
    \ = extension.countUpToUppercase() - extension.countUpToLowercase()\n        \
    \                                  ^\n/tmp/tmpkhpb8s88.swift:21:43: error: expected\
    \ '{' in extension\n        let extension_strength = extension.countUpToUppercase()\
    \ - extension.countUpToLowercase()\n                                         \
    \ ^\n/tmp/tmpkhpb8s88.swift:21:34: error: declaration is only valid at file scope\n\
    \        let extension_strength = extension.countUpToUppercase() - extension.countUpToLowercase()\n\
    \                                 ^\n/tmp/tmpkhpb8s88.swift:21:76: error: expected\
    \ type name in extension declaration\n        let extension_strength = extension.countUpToUppercase()\
    \ - extension.countUpToLowercase()\n                                         \
    \                                  ^\n/tmp/tmpkhpb8s88.swift:21:76: error: expected\
    \ '{' in extension\n        let extension_strength = extension.countUpToUppercase()\
    \ - extension.countUpToLowercase()\n                                         \
    \                                  ^\n/tmp/tmpkhpb8s88.swift:21:67: error: declaration\
    \ is only valid at file scope\n        let extension_strength"
  stdout: ''
  timestamp: 1659820881
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfunc Strongest_Extension(class_name: String,\
    \ extensions: [String]) -> String {\n    var strongest_extension = \"\"\n    var\
    \ strength = -1\n    for extension in extensions {\n        var extension_length\
    \ = extension.count\n        var extension_strength = extension_length - 1\n \
    \       for _ in 0..<extension_length {\n            if extension_strength > strength\
    \ {\n                strongest_extension = class_name\n                strength\
    \ = extension_strength\n            }\n            extension_strength -= 1\n \
    \       }\n    }\n    return strongest_extension\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp4uk6n6p6.swift:20:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmp4uk6n6p6.swift:20:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmp4uk6n6p6.swift:20:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmp4uk6n6p6.swift:21:32:\
    \ error: expected initial value after '='\n        var extension_length = extension.count\n\
    \                               ^\n/tmp/tmp4uk6n6p6.swift:21:31: error: consecutive\
    \ statements on a line must be separated by ';'\n        var extension_length\
    \ = extension.count\n                              ^\n                       \
    \       ;\n/tmp/tmp4uk6n6p6.swift:21:41: error: expected type name in extension\
    \ declaration\n        var extension_length = extension.count\n              \
    \                          ^\n/tmp/tmp4uk6n6p6.swift:21:41: error: expected '{'\
    \ in extension\n        var extension_length = extension.count\n             \
    \                           ^\n/tmp/tmp4uk6n6p6.swift:21:32: error: declaration\
    \ is only valid at file scope\n        var extension_length = extension.count\n\
    \                               ^\n"
  stdout: ''
  timestamp: 1659820882
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfunc Strongest_Extension(class_name: String,\
    \ extensions: [String]) -> String {\n    var strongest_extension = \"\"\n    var\
    \ strongest_extension_strength = -1\n    for extension in extensions {\n     \
    \   let class_name_components = class_name.components(separatedBy: \".\")\n  \
    \      let extension_components = extension.components(separatedBy: \".\")\n \
    \       let class_name_components_count = class_name_components.count\n      \
    \  let extension_components_count = extension_components.count\n        let class_name_components_extension_strength\
    \ = class_name_components_count - extension_components_count\n        if class_name_components_extension_strength\
    \ > strongest_extension_strength {\n            strongest_extension = extension\n\
    \            strongest_extension_strength = class_name_components_extension_strength\n\
    \        }\n    }\n    return class_name + \".\" + strongest_extension\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpmqic1ytv.swift:20:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpmqic1ytv.swift:20:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpmqic1ytv.swift:20:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpmqic1ytv.swift:22:36:\
    \ error: expected initial value after '='\n        let extension_components =\
    \ extension.components(separatedBy: \".\")\n                                 \
    \  ^\n/tmp/tmpmqic1ytv.swift:22:35: error: consecutive statements on a line must\
    \ be separated by ';'\n        let extension_components = extension.components(separatedBy:\
    \ \".\")\n                                  ^\n                              \
    \    ;\n/tmp/tmpmqic1ytv.swift:22:45: error: expected type name in extension declaration\n\
    \        let extension_components = extension.components(separatedBy: \".\")\n\
    \                                            ^\n/tmp/tmpmqic1ytv.swift:22:45:\
    \ error: expected '{' in extension\n        let extension_components = extension.components(separatedBy:\
    \ \".\")\n                                            ^\n/tmp/tmpmqic1ytv.swift:22:36:\
    \ error: declaration is only valid at file scope\n        let extension_components\
    \ = extension.components(separatedBy: \".\")\n                               \
    \    ^\n/tmp/tmpmqic1ytv.swift:27:35: error: expected expression in assignment\n\
    \            strongest_extension = extension\n                               \
    \   ^\n/tmp/tmpmqic1ytv.swift:28:42: error: expected '{' in extension\n      \
    \      strongest_extension_strength = class_name_components_extension_strength\n\
    \                                         ^\n/tmp/tmpmqic1ytv.swift:27:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                                  ^\n/tmp/tmpmqic1ytv.swift:28:13: error: cannot\
    \ find type 'strongest_extension_strength' in scope\n            strongest_extension_strength\
    \ = class_name_components_extension_strength\n            ^~~~~~~~~~~~~~"
  stdout: ''
  timestamp: 1659820882
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfunc Strongest_Extension(class_name: String,\
    \ extensions: [String]) -> String {\n    var strongest_extension = \"\"\n    var\
    \ strongest_extension_strength = -1\n    for extension in extensions {\n     \
    \   var extension_strength = extension.count\n        for letter in extension\
    \ {\n            if letter.isUpper() {\n                extension_strength -=\
    \ 1\n            }\n        }\n        if extension_strength > strongest_extension_strength\
    \ {\n            strongest_extension_strength = extension_strength\n         \
    \   strongest_extension = extension\n        }\n    }\n    return class_name +\
    \ \".\" + strongest_extension\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpdc2q9gnv.swift:20:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpdc2q9gnv.swift:20:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpdc2q9gnv.swift:20:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpdc2q9gnv.swift:21:34:\
    \ error: expected initial value after '='\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmpdc2q9gnv.swift:21:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        var extension_strength\
    \ = extension.count\n                                ^\n                     \
    \           ;\n/tmp/tmpdc2q9gnv.swift:21:43: error: expected type name in extension\
    \ declaration\n        var extension_strength = extension.count\n            \
    \                              ^\n/tmp/tmpdc2q9gnv.swift:21:43: error: expected\
    \ '{' in extension\n        var extension_strength = extension.count\n       \
    \                                   ^\n/tmp/tmpdc2q9gnv.swift:21:34: error: declaration\
    \ is only valid at file scope\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmpdc2q9gnv.swift:22:23: error: expected\
    \ Sequence expression for for-each loop\n        for letter in extension {\n \
    \                     ^\n/tmp/tmpdc2q9gnv.swift:22:23: error: expected '{' to\
    \ start the body of for-each loop\n        for letter in extension {\n       \
    \               ^\n/tmp/tmpdc2q9gnv.swift:29:35: error: expected expression in\
    \ assignment\n            strongest_extension = extension\n                  \
    \                ^\n/tmp/tmpdc2q9gnv.swift:30:9: error: expected type name in\
    \ extension declaration\n        }\n        ^\n/tmp/tmpdc2q9gnv.swift:29:44: error:\
    \ expected '{' in extension\n            strongest_extension = extension\n   \
    \                                        ^\n/tmp/tmpdc2q9gnv.swift:29:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                              "
  stdout: ''
  timestamp: 1659820881
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfunc Strongest_Extension(class_name: String,\
    \ extensions: [String]) -> String {\n    var strongest_extension = \"\"\n    var\
    \ strongest_extension_strength = -1\n    for extension in extensions {\n     \
    \   let extension_strength = extension.countUpToUppercaseLetters - extension.countUpToLowercaseLetters\n\
    \        if extension_strength > strongest_extension_strength {\n            strongest_extension_strength\
    \ = extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpxhz_h2fn.swift:20:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpxhz_h2fn.swift:20:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpxhz_h2fn.swift:20:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpxhz_h2fn.swift:21:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUpToUppercaseLetters\
    \ - extension.countUpToLowercaseLetters\n                                 ^\n\
    /tmp/tmpxhz_h2fn.swift:21:33: error: consecutive statements on a line must be\
    \ separated by ';'\n        let extension_strength = extension.countUpToUppercaseLetters\
    \ - extension.countUpToLowercaseLetters\n                                ^\n \
    \                               ;\n/tmp/tmpxhz_h2fn.swift:21:43: error: expected\
    \ type name in extension declaration\n        let extension_strength = extension.countUpToUppercaseLetters\
    \ - extension.countUpToLowercaseLetters\n                                    \
    \      ^\n/tmp/tmpxhz_h2fn.swift:21:43: error: expected '{' in extension\n   \
    \     let extension_strength = extension.countUpToUppercaseLetters - extension.countUpToLowercaseLetters\n\
    \                                          ^\n/tmp/tmpxhz_h2fn.swift:21:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.countUpToUppercaseLetters\
    \ - extension.countUpToLowercaseLetters\n                                 ^\n\
    /tmp/tmpxhz_h2fn.swift:21:81: error: expected type name in extension declaration\n\
    \        let extension_strength = extension.countUpToUppercaseLetters - extension.countUpToLowercaseLetters\n\
    \                                                                            \
    \    ^\n/tmp/tmpxhz_h2fn.swift:21:81: error: expected '{' in extension\n     \
    \   let extension_strength = extension.countUpToUppercaseLetters - extension.countUpToLowercaseLetters\n\
    \                                                                            \
    \    ^\n/tmp/tmpxhz_h2fn.swift:21:7"
  stdout: ''
  timestamp: 1659820881
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfunc Strongest_Extension(class_name: String,\
    \ extensions: [String]) -> String {\n    var strongest_extension = \"\"\n    var\
    \ max_strength = -1\n    for extension in extensions {\n        let class_name_extension\
    \ = class_name + extension\n        let strength = class_name_extension.countUppercaseLetters()\
    \ - class_name_extension.countLowercaseLetters()\n        if strength > max_strength\
    \ {\n            max_strength = strength\n            strongest_extension = class_name_extension\n\
    \        }\n    }\n    return strongest_extension\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp53ooth87.swift:20:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmp53ooth87.swift:20:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmp53ooth87.swift:20:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmp53ooth87.swift:21:49:\
    \ error: expected expression after operator\n        let class_name_extension\
    \ = class_name + extension\n                                                ^\n\
    /tmp/tmp53ooth87.swift:21:48: error: consecutive statements on a line must be\
    \ separated by ';'\n        let class_name_extension = class_name + extension\n\
    \                                               ^\n                          \
    \                     ;\n/tmp/tmp53ooth87.swift:22:9: error: expected type name\
    \ in extension declaration\n        let strength = class_name_extension.countUppercaseLetters()\
    \ - class_name_extension.countLowercaseLetters()\n        ^\n/tmp/tmp53ooth87.swift:21:58:\
    \ error: expected '{' in extension\n        let class_name_extension = class_name\
    \ + extension\n                                                         ^\n/tmp/tmp53ooth87.swift:21:49:\
    \ error: declaration is only valid at file scope\n        let class_name_extension\
    \ = class_name + extension\n                                                ^\n"
  stdout: ''
  timestamp: 1659820882
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfunc Strongest_Extension(class_name: String,\
    \ extensions: [String]) -> String {\n    var strongest_extension = \"\"\n    var\
    \ strongest_extension_strength = -1\n    for extension in extensions {\n     \
    \   var extension_strength = extension.count\n        for letter in extension\
    \ {\n            if letter.isUpper() {\n                extension_strength -=\
    \ 1\n            }\n        }\n        if extension_strength > strongest_extension_strength\
    \ {\n            strongest_extension_strength = extension_strength\n         \
    \   strongest_extension = extension\n        }\n    }\n    return class_name +\
    \ \".\" + strongest_extension\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpdc2q9gnv.swift:20:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpdc2q9gnv.swift:20:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpdc2q9gnv.swift:20:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpdc2q9gnv.swift:21:34:\
    \ error: expected initial value after '='\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmpdc2q9gnv.swift:21:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        var extension_strength\
    \ = extension.count\n                                ^\n                     \
    \           ;\n/tmp/tmpdc2q9gnv.swift:21:43: error: expected type name in extension\
    \ declaration\n        var extension_strength = extension.count\n            \
    \                              ^\n/tmp/tmpdc2q9gnv.swift:21:43: error: expected\
    \ '{' in extension\n        var extension_strength = extension.count\n       \
    \                                   ^\n/tmp/tmpdc2q9gnv.swift:21:34: error: declaration\
    \ is only valid at file scope\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmpdc2q9gnv.swift:22:23: error: expected\
    \ Sequence expression for for-each loop\n        for letter in extension {\n \
    \                     ^\n/tmp/tmpdc2q9gnv.swift:22:23: error: expected '{' to\
    \ start the body of for-each loop\n        for letter in extension {\n       \
    \               ^\n/tmp/tmpdc2q9gnv.swift:29:35: error: expected expression in\
    \ assignment\n            strongest_extension = extension\n                  \
    \                ^\n/tmp/tmpdc2q9gnv.swift:30:9: error: expected type name in\
    \ extension declaration\n        }\n        ^\n/tmp/tmpdc2q9gnv.swift:29:44: error:\
    \ expected '{' in extension\n            strongest_extension = extension\n   \
    \                                        ^\n/tmp/tmpdc2q9gnv.swift:29:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                              "
  stdout: ''
  timestamp: 1659820881
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfunc Strongest_Extension(class_name: String,\
    \ extensions: [String]) -> String {\n    var strongest_extension = \"\"\n    var\
    \ strength = -1\n    for extension in extensions {\n        let class_name_components\
    \ = class_name.components(separatedBy: \".\")\n        let extension_components\
    \ = extension.components(separatedBy: \".\")\n        let class_name_components_count\
    \ = class_name_components.count\n        let extension_components_count = extension_components.count\n\
    \        let class_name_components_count_upper = class_name_components.filter({\
    \ $0.isUppercased() }).count\n        let extension_components_count_lower = extension_components.filter({\
    \ $0.isLowercased() }).count\n        let class_name_components_count_upper_small\
    \ = class_name_components_count_upper - class_name_components_count_lower\n  \
    \      let extension_components_count_lower_small = extension_components_count_lower\
    \ - extension_components_count_upper\n        let extension_components_count_small\
    \ = extension_components_count_lower_small - extension_components_count_upper_small\n\
    \        let extension_components_count_large = extension_components_count_lower\
    \ + extension_components_count_upper_small\n        let extension_components_count_large_small\
    \ = extension_components_count_lower + extension_components_count_upper\n    \
    \    let extension_components_count_large_large = extension_components_count_lower\
    \ + extension_components_count_upper_small + extension_components_count_upper\n\
    \        let extension_components_count_large_large_small = extension_components_count_lower\
    \ + extension_components_count_upper_small + extension_components_count_upper\
    \ + extension_components_count_upper_small\n        let extension_components_count_large_large_small_large\
    \ = extension_components_count_lower + extension_components_count_upper_small\
    \ + extension_components_count_upper + extension_components_count_upper_small\
    \ + extension_components_count_upper + extension_components_count_upper_small\
    \ + extension_components_count_upper\n        let extension_components_count_large_large_small_large_small\
    \ = extension_components_count_lower + extension_components_count_upper_small\
    \ + extension_components_count_upper + extension_components_count_upper_small\
    \ + extension_components_count_upper + extension_components_count_upper_small\
    \ + extension_components_count_upper + extension_components_count_upper_small\
    \ + extension_components_count_upper + extension_components_count_upper_small\
    \ + extension_components_count_upper\n        let extension_components_count_large_large_small_large_small_large\
    \ = extension_components_count_lower + extension_components_count_upper_small\
    \ + extension_components_count_upper + extension_\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpstw870ey.swift:20:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpstw870ey.swift:20:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpstw870ey.swift:20:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpstw870ey.swift:22:36:\
    \ error: expected initial value after '='\n        let extension_components =\
    \ extension.components(separatedBy: \".\")\n                                 \
    \  ^\n/tmp/tmpstw870ey.swift:22:35: error: consecutive statements on a line must\
    \ be separated by ';'\n        let extension_components = extension.components(separatedBy:\
    \ \".\")\n                                  ^\n                              \
    \    ;\n/tmp/tmpstw870ey.swift:22:45: error: expected type name in extension declaration\n\
    \        let extension_components = extension.components(separatedBy: \".\")\n\
    \                                            ^\n/tmp/tmpstw870ey.swift:22:45:\
    \ error: expected '{' in extension\n        let extension_components = extension.components(separatedBy:\
    \ \".\")\n                                            ^\n/tmp/tmpstw870ey.swift:22:36:\
    \ error: declaration is only valid at file scope\n        let extension_components\
    \ = extension.components(separatedBy: \".\")\n                               \
    \    ^\n/tmp/tmpstw870ey.swift:60:91: error: expected '}' at end of brace statement\n\
    assert(Strongest_Extension(class_name: \"Sp\", extensions: [\"671235\", \"Bb\"\
    ]) == \"Sp.671235\")\n                                                       \
    \                                   ^\n/tmp/tmpstw870ey.swift:17:78: note: to\
    \ match this opening '{'\nfunc Strongest_Extension(class_name: String, extensions:\
    \ [String]) -> String {\n                                                    \
    \                         ^\n/tmp/tmpstw870ey.swift:40:6: error: operator functions\
    \ can only be declared at global or in type scope\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n     ^\n/tmp/tmpstw870ey.swift:21:48: error:\
    \ value of type 'St"
  stdout: ''
  timestamp: 1659820882
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfunc Strongest_Extension(class_name: String,\
    \ extensions: [String]) -> String {\n    var strongest_extension = \"\"\n    var\
    \ strongest_extension_strength = -1\n    for extension in extensions {\n     \
    \   let extension_strength = extension.countUpToUppercaseLetters - extension.countUpToLowercaseLetters\n\
    \        if extension_strength > strongest_extension_strength {\n            strongest_extension_strength\
    \ = extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpxhz_h2fn.swift:20:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpxhz_h2fn.swift:20:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpxhz_h2fn.swift:20:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpxhz_h2fn.swift:21:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUpToUppercaseLetters\
    \ - extension.countUpToLowercaseLetters\n                                 ^\n\
    /tmp/tmpxhz_h2fn.swift:21:33: error: consecutive statements on a line must be\
    \ separated by ';'\n        let extension_strength = extension.countUpToUppercaseLetters\
    \ - extension.countUpToLowercaseLetters\n                                ^\n \
    \                               ;\n/tmp/tmpxhz_h2fn.swift:21:43: error: expected\
    \ type name in extension declaration\n        let extension_strength = extension.countUpToUppercaseLetters\
    \ - extension.countUpToLowercaseLetters\n                                    \
    \      ^\n/tmp/tmpxhz_h2fn.swift:21:43: error: expected '{' in extension\n   \
    \     let extension_strength = extension.countUpToUppercaseLetters - extension.countUpToLowercaseLetters\n\
    \                                          ^\n/tmp/tmpxhz_h2fn.swift:21:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.countUpToUppercaseLetters\
    \ - extension.countUpToLowercaseLetters\n                                 ^\n\
    /tmp/tmpxhz_h2fn.swift:21:81: error: expected type name in extension declaration\n\
    \        let extension_strength = extension.countUpToUppercaseLetters - extension.countUpToLowercaseLetters\n\
    \                                                                            \
    \    ^\n/tmp/tmpxhz_h2fn.swift:21:81: error: expected '{' in extension\n     \
    \   let extension_strength = extension.countUpToUppercaseLetters - extension.countUpToLowercaseLetters\n\
    \                                                                            \
    \    ^\n/tmp/tmpxhz_h2fn.swift:21:7"
  stdout: ''
  timestamp: 1659820881
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfunc Strongest_Extension(class_name: String,\
    \ extensions: [String]) -> String {\n    var strongest_extension = \"\"\n    var\
    \ strongest_extension_strength = -1\n    for extension in extensions {\n     \
    \   let extension_strength = extension.characters.count\n        if extension_strength\
    \ > strongest_extension_strength {\n            strongest_extension_strength =\
    \ extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpg801yqsz.swift:20:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpg801yqsz.swift:20:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpg801yqsz.swift:20:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpg801yqsz.swift:21:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.characters.count\n\
    \                                 ^\n/tmp/tmpg801yqsz.swift:21:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        let extension_strength\
    \ = extension.characters.count\n                                ^\n          \
    \                      ;\n/tmp/tmpg801yqsz.swift:21:43: error: expected type name\
    \ in extension declaration\n        let extension_strength = extension.characters.count\n\
    \                                          ^\n/tmp/tmpg801yqsz.swift:21:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.characters.count\n\
    \                                          ^\n/tmp/tmpg801yqsz.swift:21:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.characters.count\n\
    \                                 ^\n/tmp/tmpg801yqsz.swift:24:35: error: expected\
    \ expression in assignment\n            strongest_extension = extension\n    \
    \                              ^\n/tmp/tmpg801yqsz.swift:25:9: error: expected\
    \ type name in extension declaration\n        }\n        ^\n/tmp/tmpg801yqsz.swift:24:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           ^\n/tmp/tmpg801yqsz.swift:24:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                                  ^\n"
  stdout: ''
  timestamp: 1659820881
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfunc Strongest_Extension(class_name: String,\
    \ extensions: [String]) -> String {\n    var strongest_extension = \"\"\n    var\
    \ max_strength = -1\n    for extension in extensions {\n        var strength =\
    \ count_capital_letters(extension) - count_capital_letters(class_name)\n     \
    \   if strength > max_strength {\n            max_strength = strength\n      \
    \      strongest_extension = extension\n        }\n    }\n    return class_name\
    \ + strongest_extension\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpgt5jrr4l.swift:20:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpgt5jrr4l.swift:20:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpgt5jrr4l.swift:20:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpgt5jrr4l.swift:21:46:\
    \ error: expected expression in list of expressions\n        var strength = count_capital_letters(extension)\
    \ - count_capital_letters(class_name)\n                                      \
    \       ^\n/tmp/tmpgt5jrr4l.swift:21:46: error: consecutive statements on a line\
    \ must be separated by ';'\n        var strength = count_capital_letters(extension)\
    \ - count_capital_letters(class_name)\n                                      \
    \       ^\n                                             ;\n/tmp/tmpgt5jrr4l.swift:21:55:\
    \ error: expected type name in extension declaration\n        var strength = count_capital_letters(extension)\
    \ - count_capital_letters(class_name)\n                                      \
    \                ^\n                                                       <#type#>\n\
    /tmp/tmpgt5jrr4l.swift:21:55: error: expected '{' in extension\n        var strength\
    \ = count_capital_letters(extension) - count_capital_letters(class_name)\n   \
    \                                                   ^\n/tmp/tmpgt5jrr4l.swift:21:46:\
    \ error: declaration is only valid at file scope\n        var strength = count_capital_letters(extension)\
    \ - count_capital_letters(class_name)\n                                      \
    \       ^\n/tmp/tmpgt5jrr4l.swift:24:35: error: expected expression in assignment\n\
    \            strongest_extension = extension\n                               \
    \   ^\n/tmp/tmpgt5jrr4l.swift:25:9: error: expected type name in extension declaration\n\
    \        }\n        ^\n/tmp/tmpgt5jrr4l.swift:24:44: error: expected '{' in extension\n\
    \            strongest_extension = extension\n                               \
    \            ^\n/tmp/tmpgt5jrr4l.swift:24:35: error: declaration is only valid\
    \ at file sc"
  stdout: ''
  timestamp: 1659820882
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfunc Strongest_Extension(class_name: String,\
    \ extensions: [String]) -> String {\n    var strongest_extension = \"\"\n    var\
    \ max_strength = -1\n    for extension in extensions {\n        var strength =\
    \ count_capital_letters(extension) - count_capital_letters(extension.lowercaseString)\n\
    \        if strength > max_strength {\n            max_strength = strength\n \
    \           strongest_extension = extension\n        }\n    }\n    return class_name\
    \ + \".\" + strongest_extension\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpuqiu69ui.swift:20:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpuqiu69ui.swift:20:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpuqiu69ui.swift:20:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpuqiu69ui.swift:21:46:\
    \ error: expected expression in list of expressions\n        var strength = count_capital_letters(extension)\
    \ - count_capital_letters(extension.lowercaseString)\n                       \
    \                      ^\n/tmp/tmpuqiu69ui.swift:21:46: error: consecutive statements\
    \ on a line must be separated by ';'\n        var strength = count_capital_letters(extension)\
    \ - count_capital_letters(extension.lowercaseString)\n                       \
    \                      ^\n                                             ;\n/tmp/tmpuqiu69ui.swift:21:55:\
    \ error: expected type name in extension declaration\n        var strength = count_capital_letters(extension)\
    \ - count_capital_letters(extension.lowercaseString)\n                       \
    \                               ^\n                                          \
    \             <#type#>\n/tmp/tmpuqiu69ui.swift:21:55: error: expected '{' in extension\n\
    \        var strength = count_capital_letters(extension) - count_capital_letters(extension.lowercaseString)\n\
    \                                                      ^\n/tmp/tmpuqiu69ui.swift:21:46:\
    \ error: declaration is only valid at file scope\n        var strength = count_capital_letters(extension)\
    \ - count_capital_letters(extension.lowercaseString)\n                       \
    \                      ^\n/tmp/tmpuqiu69ui.swift:24:35: error: expected expression\
    \ in assignment\n            strongest_extension = extension\n               \
    \                   ^\n/tmp/tmpuqiu69ui.swift:25:9: error: expected type name\
    \ in extension declaration\n        }\n        ^\n/tmp/tmpuqiu69ui.swift:24:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           "
  stdout: ''
  timestamp: 1659820881
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfunc Strongest_Extension(class_name: String,\
    \ extensions: [String]) -> String {\n    var strongest_extension = \"\"\n    var\
    \ strongest_extension_strength = -1\n    for extension in extensions {\n     \
    \   let extension_strength = extension.countUpToLowercaseLetters()\n        if\
    \ extension_strength > strongest_extension_strength {\n            strongest_extension\
    \ = extension\n            strongest_extension_strength = extension_strength\n\
    \        }\n    }\n    return class_name + \".\" + strongest_extension\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpe42yg6fg.swift:20:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpe42yg6fg.swift:20:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpe42yg6fg.swift:20:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpe42yg6fg.swift:21:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmpe42yg6fg.swift:21:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        let extension_strength\
    \ = extension.countUpToLowercaseLetters()\n                                ^\n\
    \                                ;\n/tmp/tmpe42yg6fg.swift:21:43: error: expected\
    \ type name in extension declaration\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmpe42yg6fg.swift:21:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmpe42yg6fg.swift:21:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmpe42yg6fg.swift:23:35: error: expected\
    \ expression in assignment\n            strongest_extension = extension\n    \
    \                              ^\n/tmp/tmpe42yg6fg.swift:24:42: error: expected\
    \ '{' in extension\n            strongest_extension_strength = extension_strength\n\
    \                                         ^\n/tmp/tmpe42yg6fg.swift:23:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                                  ^\n/tmp/tmpe42yg6fg.swift:24:13: error: cannot\
    \ find type 'strongest_extension_strength' in scope\n            strongest_extension_strength\
    \ = extension_strength\n            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659820882
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfunc Strongest_Extension(class_name: String,\
    \ extensions: [String]) -> String {\n    var strongest_extension = \"\"\n    var\
    \ strongest_extension_strength = -1\n    for extension in extensions {\n     \
    \   var extension_strength = extension.count\n        for letter in extension\
    \ {\n            if letter.isUpper() {\n                extension_strength -=\
    \ 1\n            }\n        }\n        if extension_strength > strongest_extension_strength\
    \ {\n            strongest_extension_strength = extension_strength\n         \
    \   strongest_extension = extension\n        }\n    }\n    return class_name +\
    \ \".\" + strongest_extension\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpdc2q9gnv.swift:20:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpdc2q9gnv.swift:20:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpdc2q9gnv.swift:20:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpdc2q9gnv.swift:21:34:\
    \ error: expected initial value after '='\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmpdc2q9gnv.swift:21:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        var extension_strength\
    \ = extension.count\n                                ^\n                     \
    \           ;\n/tmp/tmpdc2q9gnv.swift:21:43: error: expected type name in extension\
    \ declaration\n        var extension_strength = extension.count\n            \
    \                              ^\n/tmp/tmpdc2q9gnv.swift:21:43: error: expected\
    \ '{' in extension\n        var extension_strength = extension.count\n       \
    \                                   ^\n/tmp/tmpdc2q9gnv.swift:21:34: error: declaration\
    \ is only valid at file scope\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmpdc2q9gnv.swift:22:23: error: expected\
    \ Sequence expression for for-each loop\n        for letter in extension {\n \
    \                     ^\n/tmp/tmpdc2q9gnv.swift:22:23: error: expected '{' to\
    \ start the body of for-each loop\n        for letter in extension {\n       \
    \               ^\n/tmp/tmpdc2q9gnv.swift:29:35: error: expected expression in\
    \ assignment\n            strongest_extension = extension\n                  \
    \                ^\n/tmp/tmpdc2q9gnv.swift:30:9: error: expected type name in\
    \ extension declaration\n        }\n        ^\n/tmp/tmpdc2q9gnv.swift:29:44: error:\
    \ expected '{' in extension\n            strongest_extension = extension\n   \
    \                                        ^\n/tmp/tmpdc2q9gnv.swift:29:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                              "
  stdout: ''
  timestamp: 1659820881
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfunc Strongest_Extension(class_name: String,\
    \ extensions: [String]) -> String {\n    var strongest_extension = \"\"\n    var\
    \ strongest_extension_strength = -1\n    for extension in extensions {\n     \
    \   var extension_strength = extension.count\n        for char in extension {\n\
    \            if char.uppercased() != char {\n                extension_strength\
    \ -= 1\n            }\n        }\n        if extension_strength > strongest_extension_strength\
    \ {\n            strongest_extension_strength = extension_strength\n         \
    \   strongest_extension = extension\n        }\n    }\n    return class_name +\
    \ \".\" + strongest_extension\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp5m29v439.swift:20:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmp5m29v439.swift:20:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmp5m29v439.swift:20:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmp5m29v439.swift:21:34:\
    \ error: expected initial value after '='\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmp5m29v439.swift:21:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        var extension_strength\
    \ = extension.count\n                                ^\n                     \
    \           ;\n/tmp/tmp5m29v439.swift:21:43: error: expected type name in extension\
    \ declaration\n        var extension_strength = extension.count\n            \
    \                              ^\n/tmp/tmp5m29v439.swift:21:43: error: expected\
    \ '{' in extension\n        var extension_strength = extension.count\n       \
    \                                   ^\n/tmp/tmp5m29v439.swift:21:34: error: declaration\
    \ is only valid at file scope\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmp5m29v439.swift:22:21: error: expected\
    \ Sequence expression for for-each loop\n        for char in extension {\n   \
    \                 ^\n/tmp/tmp5m29v439.swift:22:21: error: expected '{' to start\
    \ the body of for-each loop\n        for char in extension {\n               \
    \     ^\n/tmp/tmp5m29v439.swift:29:35: error: expected expression in assignment\n\
    \            strongest_extension = extension\n                               \
    \   ^\n/tmp/tmp5m29v439.swift:30:9: error: expected type name in extension declaration\n\
    \        }\n        ^\n/tmp/tmp5m29v439.swift:29:44: error: expected '{' in extension\n\
    \            strongest_extension = extension\n                               \
    \            ^\n/tmp/tmp5m29v439.swift:29:35: error: declaration is only valid\
    \ at file scope\n            strongest_extension = extension\n               \
    \                   ^\n"
  stdout: ''
  timestamp: 1659820882
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfunc Strongest_Extension(class_name: String,\
    \ extensions: [String]) -> String {\n    var strongest_extension = \"\"\n    var\
    \ strongest_extension_strength = -1\n    for extension in extensions {\n     \
    \   var extension_strength = extension.count\n        for letter in extension\
    \ {\n            if letter.isUppercase {\n                extension_strength -=\
    \ 1\n            }\n            if letter.isLowercase {\n                extension_strength\
    \ += 1\n            }\n        }\n        if extension_strength > strongest_extension_strength\
    \ {\n            strongest_extension_strength = extension_strength\n         \
    \   strongest_extension = extension\n        }\n    }\n    return class_name +\
    \ \".\" + strongest_extension\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp4hxin3ab.swift:20:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmp4hxin3ab.swift:20:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmp4hxin3ab.swift:20:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmp4hxin3ab.swift:21:34:\
    \ error: expected initial value after '='\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmp4hxin3ab.swift:21:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        var extension_strength\
    \ = extension.count\n                                ^\n                     \
    \           ;\n/tmp/tmp4hxin3ab.swift:21:43: error: expected type name in extension\
    \ declaration\n        var extension_strength = extension.count\n            \
    \                              ^\n/tmp/tmp4hxin3ab.swift:21:43: error: expected\
    \ '{' in extension\n        var extension_strength = extension.count\n       \
    \                                   ^\n/tmp/tmp4hxin3ab.swift:21:34: error: declaration\
    \ is only valid at file scope\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmp4hxin3ab.swift:22:23: error: expected\
    \ Sequence expression for for-each loop\n        for letter in extension {\n \
    \                     ^\n/tmp/tmp4hxin3ab.swift:22:23: error: expected '{' to\
    \ start the body of for-each loop\n        for letter in extension {\n       \
    \               ^\n/tmp/tmp4hxin3ab.swift:32:35: error: expected expression in\
    \ assignment\n            strongest_extension = extension\n                  \
    \                ^\n/tmp/tmp4hxin3ab.swift:33:9: error: expected type name in\
    \ extension declaration\n        }\n        ^\n/tmp/tmp4hxin3ab.swift:32:44: error:\
    \ expected '{' in extension\n            strongest_extension = extension\n   \
    \                                        ^\n/tmp/tmp4hxin3ab.swift:32:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                              "
  stdout: ''
  timestamp: 1659820881
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfunc Strongest_Extension(class_name: String,\
    \ extensions: [String]) -> String {\n    var strongest_extension = \"\"\n    var\
    \ strongest_extension_strength = -1\n    for extension in extensions {\n     \
    \   let extension_strength = extension.countUpToUppercaseLetters - extension.countUpToLowercaseLetters\n\
    \        if extension_strength > strongest_extension_strength {\n            strongest_extension_strength\
    \ = extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpxhz_h2fn.swift:20:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpxhz_h2fn.swift:20:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpxhz_h2fn.swift:20:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpxhz_h2fn.swift:21:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUpToUppercaseLetters\
    \ - extension.countUpToLowercaseLetters\n                                 ^\n\
    /tmp/tmpxhz_h2fn.swift:21:33: error: consecutive statements on a line must be\
    \ separated by ';'\n        let extension_strength = extension.countUpToUppercaseLetters\
    \ - extension.countUpToLowercaseLetters\n                                ^\n \
    \                               ;\n/tmp/tmpxhz_h2fn.swift:21:43: error: expected\
    \ type name in extension declaration\n        let extension_strength = extension.countUpToUppercaseLetters\
    \ - extension.countUpToLowercaseLetters\n                                    \
    \      ^\n/tmp/tmpxhz_h2fn.swift:21:43: error: expected '{' in extension\n   \
    \     let extension_strength = extension.countUpToUppercaseLetters - extension.countUpToLowercaseLetters\n\
    \                                          ^\n/tmp/tmpxhz_h2fn.swift:21:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.countUpToUppercaseLetters\
    \ - extension.countUpToLowercaseLetters\n                                 ^\n\
    /tmp/tmpxhz_h2fn.swift:21:81: error: expected type name in extension declaration\n\
    \        let extension_strength = extension.countUpToUppercaseLetters - extension.countUpToLowercaseLetters\n\
    \                                                                            \
    \    ^\n/tmp/tmpxhz_h2fn.swift:21:81: error: expected '{' in extension\n     \
    \   let extension_strength = extension.countUpToUppercaseLetters - extension.countUpToLowercaseLetters\n\
    \                                                                            \
    \    ^\n/tmp/tmpxhz_h2fn.swift:21:7"
  stdout: ''
  timestamp: 1659820881
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfunc Strongest_Extension(class_name: String,\
    \ extensions: [String]) -> String {\n    var strongest_extension = \"\"\n    var\
    \ strongest_extension_strength = -1\n    for extension in extensions {\n     \
    \   let extension_strength = extension.countUpToLowercaseLetters()\n        if\
    \ extension_strength > strongest_extension_strength {\n            strongest_extension_strength\
    \ = extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp6jifw92_.swift:20:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmp6jifw92_.swift:20:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmp6jifw92_.swift:20:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmp6jifw92_.swift:21:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmp6jifw92_.swift:21:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        let extension_strength\
    \ = extension.countUpToLowercaseLetters()\n                                ^\n\
    \                                ;\n/tmp/tmp6jifw92_.swift:21:43: error: expected\
    \ type name in extension declaration\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmp6jifw92_.swift:21:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmp6jifw92_.swift:21:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmp6jifw92_.swift:24:35: error: expected\
    \ expression in assignment\n            strongest_extension = extension\n    \
    \                              ^\n/tmp/tmp6jifw92_.swift:25:9: error: expected\
    \ type name in extension declaration\n        }\n        ^\n/tmp/tmp6jifw92_.swift:24:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           ^\n/tmp/tmp6jifw92_.swift:24:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                                  ^\n"
  stdout: ''
  timestamp: 1659820881
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfunc Strongest_Extension(class_name: String,\
    \ extensions: [String]) -> String {\n    var strongest_extension = \"\"\n    var\
    \ strongest_extension_strength = -1\n    for extension in extensions {\n     \
    \   let extension_strength = extension.countUpToCapitalLetters - extension.countLowercaseLetters\n\
    \        if extension_strength > strongest_extension_strength {\n            strongest_extension_strength\
    \ = extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp_pj_tx6g.swift:20:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmp_pj_tx6g.swift:20:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmp_pj_tx6g.swift:20:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmp_pj_tx6g.swift:21:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUpToCapitalLetters\
    \ - extension.countLowercaseLetters\n                                 ^\n/tmp/tmp_pj_tx6g.swift:21:33:\
    \ error: consecutive statements on a line must be separated by ';'\n        let\
    \ extension_strength = extension.countUpToCapitalLetters - extension.countLowercaseLetters\n\
    \                                ^\n                                ;\n/tmp/tmp_pj_tx6g.swift:21:43:\
    \ error: expected type name in extension declaration\n        let extension_strength\
    \ = extension.countUpToCapitalLetters - extension.countLowercaseLetters\n    \
    \                                      ^\n/tmp/tmp_pj_tx6g.swift:21:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.countUpToCapitalLetters\
    \ - extension.countLowercaseLetters\n                                        \
    \  ^\n/tmp/tmp_pj_tx6g.swift:21:34: error: declaration is only valid at file scope\n\
    \        let extension_strength = extension.countUpToCapitalLetters - extension.countLowercaseLetters\n\
    \                                 ^\n/tmp/tmp_pj_tx6g.swift:21:79: error: expected\
    \ type name in extension declaration\n        let extension_strength = extension.countUpToCapitalLetters\
    \ - extension.countLowercaseLetters\n                                        \
    \                                      ^\n/tmp/tmp_pj_tx6g.swift:21:79: error:\
    \ expected '{' in extension\n        let extension_strength = extension.countUpToCapitalLetters\
    \ - extension.countLowercaseLetters\n                                        \
    \                                      ^\n/tmp/tmp_pj_tx6g.swift:21:70: error:\
    \ declaration is only valid at file sc"
  stdout: ''
  timestamp: 1659820881
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfunc Strongest_Extension(class_name: String,\
    \ extensions: [String]) -> String {\n    var strongest_extension = \"\"\n    var\
    \ strongest_extension_strength = -1\n    for extension in extensions {\n     \
    \   let extension_strength = extension.countUpToUppercase() - extension.countUpToLowercase()\n\
    \        if extension_strength > strongest_extension_strength {\n            strongest_extension_strength\
    \ = extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpkhpb8s88.swift:20:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpkhpb8s88.swift:20:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpkhpb8s88.swift:20:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpkhpb8s88.swift:21:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUpToUppercase()\
    \ - extension.countUpToLowercase()\n                                 ^\n/tmp/tmpkhpb8s88.swift:21:33:\
    \ error: consecutive statements on a line must be separated by ';'\n        let\
    \ extension_strength = extension.countUpToUppercase() - extension.countUpToLowercase()\n\
    \                                ^\n                                ;\n/tmp/tmpkhpb8s88.swift:21:43:\
    \ error: expected type name in extension declaration\n        let extension_strength\
    \ = extension.countUpToUppercase() - extension.countUpToLowercase()\n        \
    \                                  ^\n/tmp/tmpkhpb8s88.swift:21:43: error: expected\
    \ '{' in extension\n        let extension_strength = extension.countUpToUppercase()\
    \ - extension.countUpToLowercase()\n                                         \
    \ ^\n/tmp/tmpkhpb8s88.swift:21:34: error: declaration is only valid at file scope\n\
    \        let extension_strength = extension.countUpToUppercase() - extension.countUpToLowercase()\n\
    \                                 ^\n/tmp/tmpkhpb8s88.swift:21:76: error: expected\
    \ type name in extension declaration\n        let extension_strength = extension.countUpToUppercase()\
    \ - extension.countUpToLowercase()\n                                         \
    \                                  ^\n/tmp/tmpkhpb8s88.swift:21:76: error: expected\
    \ '{' in extension\n        let extension_strength = extension.countUpToUppercase()\
    \ - extension.countUpToLowercase()\n                                         \
    \                                  ^\n/tmp/tmpkhpb8s88.swift:21:67: error: declaration\
    \ is only valid at file scope\n        let extension_strength"
  stdout: ''
  timestamp: 1659820881
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfunc Strongest_Extension(class_name: String,\
    \ extensions: [String]) -> String {\n    var strongest_extension = \"\"\n    var\
    \ strongest_extension_strength = -1\n    for extension in extensions {\n     \
    \   var extension_strength = extension.count\n        for letter in extension\
    \ {\n            if letter.isUpper() {\n                extension_strength -=\
    \ 1\n            }\n        }\n        if extension_strength > strongest_extension_strength\
    \ {\n            strongest_extension_strength = extension_strength\n         \
    \   strongest_extension = extension\n        }\n    }\n    return class_name +\
    \ \".\" + strongest_extension\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpdc2q9gnv.swift:20:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpdc2q9gnv.swift:20:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpdc2q9gnv.swift:20:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpdc2q9gnv.swift:21:34:\
    \ error: expected initial value after '='\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmpdc2q9gnv.swift:21:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        var extension_strength\
    \ = extension.count\n                                ^\n                     \
    \           ;\n/tmp/tmpdc2q9gnv.swift:21:43: error: expected type name in extension\
    \ declaration\n        var extension_strength = extension.count\n            \
    \                              ^\n/tmp/tmpdc2q9gnv.swift:21:43: error: expected\
    \ '{' in extension\n        var extension_strength = extension.count\n       \
    \                                   ^\n/tmp/tmpdc2q9gnv.swift:21:34: error: declaration\
    \ is only valid at file scope\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmpdc2q9gnv.swift:22:23: error: expected\
    \ Sequence expression for for-each loop\n        for letter in extension {\n \
    \                     ^\n/tmp/tmpdc2q9gnv.swift:22:23: error: expected '{' to\
    \ start the body of for-each loop\n        for letter in extension {\n       \
    \               ^\n/tmp/tmpdc2q9gnv.swift:29:35: error: expected expression in\
    \ assignment\n            strongest_extension = extension\n                  \
    \                ^\n/tmp/tmpdc2q9gnv.swift:30:9: error: expected type name in\
    \ extension declaration\n        }\n        ^\n/tmp/tmpdc2q9gnv.swift:29:44: error:\
    \ expected '{' in extension\n            strongest_extension = extension\n   \
    \                                        ^\n/tmp/tmpdc2q9gnv.swift:29:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                              "
  stdout: ''
  timestamp: 1659820881
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfunc Strongest_Extension(class_name: String,\
    \ extensions: [String]) -> String {\n    var strongest_extension = \"\"\n    var\
    \ strength = -1\n    for extension in extensions {\n        let cap = extension.count\n\
    \        let sm = class_name.count\n        let strength = cap - sm\n        if\
    \ strength > 0 {\n            strongest_extension = class_name + \".\" + extension\n\
    \            break\n        }\n    }\n    return strongest_extension\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpvvwfojc6.swift:20:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpvvwfojc6.swift:20:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpvvwfojc6.swift:20:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpvvwfojc6.swift:21:19:\
    \ error: expected initial value after '='\n        let cap = extension.count\n\
    \                  ^\n/tmp/tmpvvwfojc6.swift:21:18: error: consecutive statements\
    \ on a line must be separated by ';'\n        let cap = extension.count\n    \
    \             ^\n                 ;\n/tmp/tmpvvwfojc6.swift:21:28: error: expected\
    \ type name in extension declaration\n        let cap = extension.count\n    \
    \                       ^\n/tmp/tmpvvwfojc6.swift:21:28: error: expected '{' in\
    \ extension\n        let cap = extension.count\n                           ^\n\
    /tmp/tmpvvwfojc6.swift:21:19: error: declaration is only valid at file scope\n\
    \        let cap = extension.count\n                  ^\n/tmp/tmpvvwfojc6.swift:25:54:\
    \ error: expected expression after operator\n            strongest_extension =\
    \ class_name + \".\" + extension\n                                           \
    \          ^\n/tmp/tmpvvwfojc6.swift:26:13: error: expected type name in extension\
    \ declaration\n            break\n            ^\n/tmp/tmpvvwfojc6.swift:25:63:\
    \ error: expected '{' in extension\n            strongest_extension = class_name\
    \ + \".\" + extension\n                                                      \
    \        ^\n/tmp/tmpvvwfojc6.swift:25:54: error: declaration is only valid at\
    \ file scope\n            strongest_extension = class_name + \".\" + extension\n\
    \                                                     ^\n"
  stdout: ''
  timestamp: 1659820882
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfunc Strongest_Extension(class_name: String,\
    \ extensions: [String]) -> String {\n    var strongest_extension = \"\"\n    var\
    \ max_strength = -1\n    for extension in extensions {\n        let class_name_components\
    \ = class_name.components(separatedBy: \".\")\n        let extension_components\
    \ = extension.components(separatedBy: \".\")\n        let class_name = class_name_components[0]\n\
    \        let extension = extension_components[0]\n        let class_components\
    \ = class_name.components(separatedBy: \"_\")\n        let extension_components\
    \ = extension.components(separatedBy: \"_\")\n        let class_name = class_components[0]\n\
    \        let extension = extension_components[0]\n        let class_components\
    \ = class_name.components(separatedBy: \"-\")\n        let extension_components\
    \ = extension.components(separatedBy: \"-\")\n        let class_name = class_components[0]\n\
    \        let extension = extension_components[0]\n        let class_components\
    \ = class_name.components(separatedBy: \".\")\n        let extension_components\
    \ = extension.components(separatedBy: \".\")\n        let class_name = class_components[0]\n\
    \        let extension = extension_components[0]\n        let class_components\
    \ = class_name.components(separatedBy: \"_\")\n        let extension_components\
    \ = extension.components(separatedBy: \"_\")\n        let class_name = class_components[0]\n\
    \        let extension = extension_components[0]\n        let class_components\
    \ = class_name.components(separatedBy: \"-\")\n        let extension_components\
    \ = extension.components(separatedBy: \"-\")\n        let class_name = class_components[0]\n\
    \        let extension = extension_components[0]\n        let class_components\
    \ = class_name.components(separatedBy: \".\")\n        let extension_components\
    \ = extension.components(separatedBy: \".\")\n        let class_name = class_components[0]\n\
    \        let extension = extension_components[0]\n        let class_components\
    \ = class_name.components(separatedBy: \"_\")\n        let extension_components\
    \ = extension.components(separatedBy: \"_\")\n        let class_name = class_components[0]\n\
    \        let extension = extension_components[0]\n        let class_components\
    \ = class_name.components(separatedBy: \"-\")\n        let extension_components\
    \ = extension.components(separatedBy: \"-\")\n        let class_name = class_components[0]\n\
    \        let extension = extension_components[0]\n        let class_components\
    \ = class_name.components(separatedBy: \".\")\n        let extension_components\
    \ = extension.components(separatedBy: \".\")\n        let class_name = class_components[0]\n\
    \        let extension = extension_components[0]\n        let class_components\
    \ = class_name.components(separatedBy: \"_\")\n        let extension_components\
    \ = extension.components(separatedBy: \"_\")\n        let class_name = class_components[0]\n\
    \        let extension = extension_components[0]\n        let class_components\
    \ = class_name.components(\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpm3kyn25r.swift:20:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpm3kyn25r.swift:20:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpm3kyn25r.swift:20:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpm3kyn25r.swift:22:36:\
    \ error: expected initial value after '='\n        let extension_components =\
    \ extension.components(separatedBy: \".\")\n                                 \
    \  ^\n/tmp/tmpm3kyn25r.swift:22:35: error: consecutive statements on a line must\
    \ be separated by ';'\n        let extension_components = extension.components(separatedBy:\
    \ \".\")\n                                  ^\n                              \
    \    ;\n/tmp/tmpm3kyn25r.swift:22:45: error: expected type name in extension declaration\n\
    \        let extension_components = extension.components(separatedBy: \".\")\n\
    \                                            ^\n/tmp/tmpm3kyn25r.swift:22:45:\
    \ error: expected '{' in extension\n        let extension_components = extension.components(separatedBy:\
    \ \".\")\n                                            ^\n/tmp/tmpm3kyn25r.swift:22:36:\
    \ error: declaration is only valid at file scope\n        let extension_components\
    \ = extension.components(separatedBy: \".\")\n                               \
    \    ^\n/tmp/tmpm3kyn25r.swift:24:13: error: keyword 'extension' cannot be used\
    \ as an identifier here\n        let extension = extension_components[0]\n   \
    \         ^\n/tmp/tmpm3kyn25r.swift:24:13: note: if this name is unavoidable,\
    \ use backticks to escape it\n        let extension = extension_components[0]\n\
    \            ^~~~~~~~~\n            `extension`\n/tmp/tmpm3kyn25r.swift:26:36:\
    \ error: expected initial value after '='\n        let extension_components =\
    \ extension.components(separatedBy: \"_\")\n                                 \
    \  ^\n/tmp/tmpm3kyn25r.swift:26:35: error: consecutive statements on a line must\
    \ be separated by ';'\n        let extension_components = extension.components(separatedBy:\
    \ \"_\")\n          "
  stdout: ''
  timestamp: 1659820882
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfunc Strongest_Extension(class_name: String,\
    \ extensions: [String]) -> String {\n    var strongest_extension = \"\"\n    var\
    \ strongest_extension_strength = -1\n    for extension in extensions {\n     \
    \   let extension_strength = extension.countUpToUppercaseLetters - extension.countUpToLowercaseLetters\n\
    \        if extension_strength > strongest_extension_strength {\n            strongest_extension_strength\
    \ = extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpxhz_h2fn.swift:20:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpxhz_h2fn.swift:20:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpxhz_h2fn.swift:20:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpxhz_h2fn.swift:21:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUpToUppercaseLetters\
    \ - extension.countUpToLowercaseLetters\n                                 ^\n\
    /tmp/tmpxhz_h2fn.swift:21:33: error: consecutive statements on a line must be\
    \ separated by ';'\n        let extension_strength = extension.countUpToUppercaseLetters\
    \ - extension.countUpToLowercaseLetters\n                                ^\n \
    \                               ;\n/tmp/tmpxhz_h2fn.swift:21:43: error: expected\
    \ type name in extension declaration\n        let extension_strength = extension.countUpToUppercaseLetters\
    \ - extension.countUpToLowercaseLetters\n                                    \
    \      ^\n/tmp/tmpxhz_h2fn.swift:21:43: error: expected '{' in extension\n   \
    \     let extension_strength = extension.countUpToUppercaseLetters - extension.countUpToLowercaseLetters\n\
    \                                          ^\n/tmp/tmpxhz_h2fn.swift:21:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.countUpToUppercaseLetters\
    \ - extension.countUpToLowercaseLetters\n                                 ^\n\
    /tmp/tmpxhz_h2fn.swift:21:81: error: expected type name in extension declaration\n\
    \        let extension_strength = extension.countUpToUppercaseLetters - extension.countUpToLowercaseLetters\n\
    \                                                                            \
    \    ^\n/tmp/tmpxhz_h2fn.swift:21:81: error: expected '{' in extension\n     \
    \   let extension_strength = extension.countUpToUppercaseLetters - extension.countUpToLowercaseLetters\n\
    \                                                                            \
    \    ^\n/tmp/tmpxhz_h2fn.swift:21:7"
  stdout: ''
  timestamp: 1659820881
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfunc Strongest_Extension(class_name: String,\
    \ extensions: [String]) -> String {\n    var strongest_extension = \"\"\n    var\
    \ strongest_extension_strength = -1\n    for extension in extensions {\n     \
    \   var extension_strength = extension.count\n        for letter in extension\
    \ {\n            if letter.isUpper() {\n                extension_strength -=\
    \ 1\n            }\n        }\n        if extension_strength > strongest_extension_strength\
    \ {\n            strongest_extension_strength = extension_strength\n         \
    \   strongest_extension = extension\n        }\n    }\n    return class_name +\
    \ \".\" + strongest_extension\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpdc2q9gnv.swift:20:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpdc2q9gnv.swift:20:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpdc2q9gnv.swift:20:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpdc2q9gnv.swift:21:34:\
    \ error: expected initial value after '='\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmpdc2q9gnv.swift:21:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        var extension_strength\
    \ = extension.count\n                                ^\n                     \
    \           ;\n/tmp/tmpdc2q9gnv.swift:21:43: error: expected type name in extension\
    \ declaration\n        var extension_strength = extension.count\n            \
    \                              ^\n/tmp/tmpdc2q9gnv.swift:21:43: error: expected\
    \ '{' in extension\n        var extension_strength = extension.count\n       \
    \                                   ^\n/tmp/tmpdc2q9gnv.swift:21:34: error: declaration\
    \ is only valid at file scope\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmpdc2q9gnv.swift:22:23: error: expected\
    \ Sequence expression for for-each loop\n        for letter in extension {\n \
    \                     ^\n/tmp/tmpdc2q9gnv.swift:22:23: error: expected '{' to\
    \ start the body of for-each loop\n        for letter in extension {\n       \
    \               ^\n/tmp/tmpdc2q9gnv.swift:29:35: error: expected expression in\
    \ assignment\n            strongest_extension = extension\n                  \
    \                ^\n/tmp/tmpdc2q9gnv.swift:30:9: error: expected type name in\
    \ extension declaration\n        }\n        ^\n/tmp/tmpdc2q9gnv.swift:29:44: error:\
    \ expected '{' in extension\n            strongest_extension = extension\n   \
    \                                        ^\n/tmp/tmpdc2q9gnv.swift:29:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                              "
  stdout: ''
  timestamp: 1659820881
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfunc Strongest_Extension(class_name: String,\
    \ extensions: [String]) -> String {\n    var strongest_extension = \"\"\n    var\
    \ max_strength = -1\n    for extension in extensions {\n        let extension_strength\
    \ = extension.characters.count\n        if extension_strength > max_strength {\n\
    \            max_strength = extension_strength\n            strongest_extension\
    \ = extension\n        }\n    }\n    return class_name + \".\" + strongest_extension\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp_yurf75k.swift:20:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmp_yurf75k.swift:20:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmp_yurf75k.swift:20:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmp_yurf75k.swift:21:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.characters.count\n\
    \                                 ^\n/tmp/tmp_yurf75k.swift:21:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        let extension_strength\
    \ = extension.characters.count\n                                ^\n          \
    \                      ;\n/tmp/tmp_yurf75k.swift:21:43: error: expected type name\
    \ in extension declaration\n        let extension_strength = extension.characters.count\n\
    \                                          ^\n/tmp/tmp_yurf75k.swift:21:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.characters.count\n\
    \                                          ^\n/tmp/tmp_yurf75k.swift:21:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.characters.count\n\
    \                                 ^\n/tmp/tmp_yurf75k.swift:24:35: error: expected\
    \ expression in assignment\n            strongest_extension = extension\n    \
    \                              ^\n/tmp/tmp_yurf75k.swift:25:9: error: expected\
    \ type name in extension declaration\n        }\n        ^\n/tmp/tmp_yurf75k.swift:24:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           ^\n/tmp/tmp_yurf75k.swift:24:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                                  ^\n"
  stdout: ''
  timestamp: 1659820881
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfunc Strongest_Extension(class_name: String,\
    \ extensions: [String]) -> String {\n    var strongest_extension = \"\"\n    var\
    \ strongest_extension_strength = -1\n    for extension in extensions {\n     \
    \   let extension_strength = extension.characters.count\n        if extension_strength\
    \ > strongest_extension_strength {\n            strongest_extension_strength =\
    \ extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpg801yqsz.swift:20:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpg801yqsz.swift:20:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpg801yqsz.swift:20:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpg801yqsz.swift:21:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.characters.count\n\
    \                                 ^\n/tmp/tmpg801yqsz.swift:21:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        let extension_strength\
    \ = extension.characters.count\n                                ^\n          \
    \                      ;\n/tmp/tmpg801yqsz.swift:21:43: error: expected type name\
    \ in extension declaration\n        let extension_strength = extension.characters.count\n\
    \                                          ^\n/tmp/tmpg801yqsz.swift:21:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.characters.count\n\
    \                                          ^\n/tmp/tmpg801yqsz.swift:21:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.characters.count\n\
    \                                 ^\n/tmp/tmpg801yqsz.swift:24:35: error: expected\
    \ expression in assignment\n            strongest_extension = extension\n    \
    \                              ^\n/tmp/tmpg801yqsz.swift:25:9: error: expected\
    \ type name in extension declaration\n        }\n        ^\n/tmp/tmpg801yqsz.swift:24:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           ^\n/tmp/tmpg801yqsz.swift:24:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                                  ^\n"
  stdout: ''
  timestamp: 1659820881
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfunc Strongest_Extension(class_name: String,\
    \ extensions: [String]) -> String {\n    var strongest_extension = \"\"\n    var\
    \ strongest_extension_strength = -1\n    for extension in extensions {\n     \
    \   var extension_strength = count_capital_letters(extension) - count_capital_letters(extension.lowercaseString)\n\
    \        if extension_strength > strongest_extension_strength {\n            strongest_extension_strength\
    \ = extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp2hy52o8j.swift:20:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmp2hy52o8j.swift:20:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmp2hy52o8j.swift:20:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmp2hy52o8j.swift:21:56:\
    \ error: expected expression in list of expressions\n        var extension_strength\
    \ = count_capital_letters(extension) - count_capital_letters(extension.lowercaseString)\n\
    \                                                       ^\n/tmp/tmp2hy52o8j.swift:21:56:\
    \ error: consecutive statements on a line must be separated by ';'\n        var\
    \ extension_strength = count_capital_letters(extension) - count_capital_letters(extension.lowercaseString)\n\
    \                                                       ^\n                  \
    \                                     ;\n/tmp/tmp2hy52o8j.swift:21:65: error:\
    \ expected type name in extension declaration\n        var extension_strength\
    \ = count_capital_letters(extension) - count_capital_letters(extension.lowercaseString)\n\
    \                                                                ^\n         \
    \                                                        <#type#>\n/tmp/tmp2hy52o8j.swift:21:65:\
    \ error: expected '{' in extension\n        var extension_strength = count_capital_letters(extension)\
    \ - count_capital_letters(extension.lowercaseString)\n                       \
    \                                         ^\n/tmp/tmp2hy52o8j.swift:21:56: error:\
    \ declaration is only valid at file scope\n        var extension_strength = count_capital_letters(extension)\
    \ - count_capital_letters(extension.lowercaseString)\n                       \
    \                                ^\n/tmp/tmp2hy52o8j.swift:24:35: error: expected\
    \ expression in assignment\n            strongest_extension = extension\n    \
    \                              ^\n/tmp/tmp2hy52o8j.swift:25:9: error: expected\
    \ type name in extension declaration\n        }\n        ^\n/tmp/tmp2hy52o8j.swift:24:44: "
  stdout: ''
  timestamp: 1659820881
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfunc Strongest_Extension(class_name: String,\
    \ extensions: [String]) -> String {\n    var strongest_extension = \"\"\n    var\
    \ strongest_extension_strength = -1\n    for extension in extensions {\n     \
    \   let extension_strength = extension.countUpToLowercaseLetters()\n        if\
    \ extension_strength > strongest_extension_strength {\n            strongest_extension\
    \ = extension\n            strongest_extension_strength = extension_strength\n\
    \        }\n    }\n    return class_name + \".\" + strongest_extension\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpe42yg6fg.swift:20:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpe42yg6fg.swift:20:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpe42yg6fg.swift:20:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpe42yg6fg.swift:21:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmpe42yg6fg.swift:21:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        let extension_strength\
    \ = extension.countUpToLowercaseLetters()\n                                ^\n\
    \                                ;\n/tmp/tmpe42yg6fg.swift:21:43: error: expected\
    \ type name in extension declaration\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmpe42yg6fg.swift:21:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmpe42yg6fg.swift:21:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmpe42yg6fg.swift:23:35: error: expected\
    \ expression in assignment\n            strongest_extension = extension\n    \
    \                              ^\n/tmp/tmpe42yg6fg.swift:24:42: error: expected\
    \ '{' in extension\n            strongest_extension_strength = extension_strength\n\
    \                                         ^\n/tmp/tmpe42yg6fg.swift:23:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                                  ^\n/tmp/tmpe42yg6fg.swift:24:13: error: cannot\
    \ find type 'strongest_extension_strength' in scope\n            strongest_extension_strength\
    \ = extension_strength\n            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659820882
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfunc Strongest_Extension(class_name: String,\
    \ extensions: [String]) -> String {\n    var strongest_extension = \"\"\n    var\
    \ strongest_extension_strength = -1\n    for extension in extensions {\n     \
    \   let extension_strength = extension.characters.count - extension.lowercased().characters.count\n\
    \        if extension_strength > strongest_extension_strength {\n            strongest_extension_strength\
    \ = extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpf6wdvm6w.swift:20:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpf6wdvm6w.swift:20:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpf6wdvm6w.swift:20:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpf6wdvm6w.swift:21:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.characters.count\
    \ - extension.lowercased().characters.count\n                                \
    \ ^\n/tmp/tmpf6wdvm6w.swift:21:33: error: consecutive statements on a line must\
    \ be separated by ';'\n        let extension_strength = extension.characters.count\
    \ - extension.lowercased().characters.count\n                                ^\n\
    \                                ;\n/tmp/tmpf6wdvm6w.swift:21:43: error: expected\
    \ type name in extension declaration\n        let extension_strength = extension.characters.count\
    \ - extension.lowercased().characters.count\n                                \
    \          ^\n/tmp/tmpf6wdvm6w.swift:21:43: error: expected '{' in extension\n\
    \        let extension_strength = extension.characters.count - extension.lowercased().characters.count\n\
    \                                          ^\n/tmp/tmpf6wdvm6w.swift:21:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.characters.count\
    \ - extension.lowercased().characters.count\n                                \
    \ ^\n/tmp/tmpf6wdvm6w.swift:21:72: error: expected type name in extension declaration\n\
    \        let extension_strength = extension.characters.count - extension.lowercased().characters.count\n\
    \                                                                       ^\n/tmp/tmpf6wdvm6w.swift:21:72:\
    \ error: expected '{' in extension\n        let extension_strength = extension.characters.count\
    \ - extension.lowercased().characters.count\n                                \
    \                                       ^\n/tmp/tmpf6wdvm6w.swift:21:63: error:\
    \ declaration is only valid at file scope\n   "
  stdout: ''
  timestamp: 1659820882
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfunc Strongest_Extension(class_name: String,\
    \ extensions: [String]) -> String {\n    var strongest_extension = \"\"\n    var\
    \ strongest_extension_strength = -1\n    for extension in extensions {\n     \
    \   var extension_strength = extension.count\n        for character in extension\
    \ {\n            if character == character.lowercased() {\n                extension_strength\
    \ -= 1\n            }\n        }\n        if extension_strength > strongest_extension_strength\
    \ {\n            strongest_extension_strength = extension_strength\n         \
    \   strongest_extension = extension\n        }\n    }\n    return class_name +\
    \ \".\" + strongest_extension\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpyqk7216q.swift:20:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpyqk7216q.swift:20:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpyqk7216q.swift:20:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpyqk7216q.swift:21:34:\
    \ error: expected initial value after '='\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmpyqk7216q.swift:21:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        var extension_strength\
    \ = extension.count\n                                ^\n                     \
    \           ;\n/tmp/tmpyqk7216q.swift:21:43: error: expected type name in extension\
    \ declaration\n        var extension_strength = extension.count\n            \
    \                              ^\n/tmp/tmpyqk7216q.swift:21:43: error: expected\
    \ '{' in extension\n        var extension_strength = extension.count\n       \
    \                                   ^\n/tmp/tmpyqk7216q.swift:21:34: error: declaration\
    \ is only valid at file scope\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmpyqk7216q.swift:22:26: error: expected\
    \ Sequence expression for for-each loop\n        for character in extension {\n\
    \                         ^\n/tmp/tmpyqk7216q.swift:22:26: error: expected '{'\
    \ to start the body of for-each loop\n        for character in extension {\n \
    \                        ^\n/tmp/tmpyqk7216q.swift:29:35: error: expected expression\
    \ in assignment\n            strongest_extension = extension\n               \
    \                   ^\n/tmp/tmpyqk7216q.swift:30:9: error: expected type name\
    \ in extension declaration\n        }\n        ^\n/tmp/tmpyqk7216q.swift:29:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           ^\n/tmp/tmpyqk7216q.swift:29:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                  "
  stdout: ''
  timestamp: 1659820881
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfunc Strongest_Extension(class_name: String,\
    \ extensions: [String]) -> String {\n    var strongest_extension = \"\"\n    var\
    \ strongest_extension_strength = -1\n    for extension in extensions {\n     \
    \   var extension_strength = count_capital_letters(extension) - count_capital_letters(extension.lowercaseString)\n\
    \        if extension_strength > strongest_extension_strength {\n            strongest_extension_strength\
    \ = extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp2hy52o8j.swift:20:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmp2hy52o8j.swift:20:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmp2hy52o8j.swift:20:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmp2hy52o8j.swift:21:56:\
    \ error: expected expression in list of expressions\n        var extension_strength\
    \ = count_capital_letters(extension) - count_capital_letters(extension.lowercaseString)\n\
    \                                                       ^\n/tmp/tmp2hy52o8j.swift:21:56:\
    \ error: consecutive statements on a line must be separated by ';'\n        var\
    \ extension_strength = count_capital_letters(extension) - count_capital_letters(extension.lowercaseString)\n\
    \                                                       ^\n                  \
    \                                     ;\n/tmp/tmp2hy52o8j.swift:21:65: error:\
    \ expected type name in extension declaration\n        var extension_strength\
    \ = count_capital_letters(extension) - count_capital_letters(extension.lowercaseString)\n\
    \                                                                ^\n         \
    \                                                        <#type#>\n/tmp/tmp2hy52o8j.swift:21:65:\
    \ error: expected '{' in extension\n        var extension_strength = count_capital_letters(extension)\
    \ - count_capital_letters(extension.lowercaseString)\n                       \
    \                                         ^\n/tmp/tmp2hy52o8j.swift:21:56: error:\
    \ declaration is only valid at file scope\n        var extension_strength = count_capital_letters(extension)\
    \ - count_capital_letters(extension.lowercaseString)\n                       \
    \                                ^\n/tmp/tmp2hy52o8j.swift:24:35: error: expected\
    \ expression in assignment\n            strongest_extension = extension\n    \
    \                              ^\n/tmp/tmp2hy52o8j.swift:25:9: error: expected\
    \ type name in extension declaration\n        }\n        ^\n/tmp/tmp2hy52o8j.swift:24:44: "
  stdout: ''
  timestamp: 1659820881
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfunc Strongest_Extension(class_name: String,\
    \ extensions: [String]) -> String {\n    var strongest_extension = \"\"\n    var\
    \ strongest_extension_strength = -1\n    for extension in extensions {\n     \
    \   let class_name_components = class_name.components(separatedBy: \".\")\n  \
    \      let extension_components = extension.components(separatedBy: \".\")\n \
    \       let class_name_components_count = class_name_components.count\n      \
    \  let extension_components_count = extension_components.count\n        let class_name_components_count_upper\
    \ = class_name_components.filter({ $0.isUppercased() }).count\n        let extension_components_count_lower\
    \ = extension_components.filter({ $0.isLowercased() }).count\n        let class_name_components_count_upper_small\
    \ = class_name_components_count_upper - class_name_components_count_lower\n  \
    \      let extension_components_count_lower_small = extension_components_count_lower\
    \ - extension_components_count_upper\n        let class_name_components_count_lower_small\
    \ = class_name_components_count_lower - class_name_components_count_upper_small\n\
    \        let extension_components_count_upper_small = extension_components_count_upper\
    \ - extension_components_count_lower_small\n        let class_name_components_count_upper_small_strength\
    \ = class_name_components_count_upper_small / class_name_components_count\n  \
    \      let extension_components_count_lower_small_strength = extension_components_count_lower_small\
    \ / extension_components_count\n        let class_name_components_count_lower_small_strength\
    \ = class_name_components_count_lower_small / class_name_components_count\n  \
    \      let extension_components_count_upper_small_strength = extension_components_count_upper_small\
    \ / extension_components_count\n        if class_name_components_count_upper_small_strength\
    \ > strongest_extension_strength {\n            strongest_extension = extension\n\
    \            strongest_extension_strength = class_name_components_count_upper_small_strength\n\
    \        }\n        if extension_components_count_lower_small_strength > strongest_extension_strength\
    \ {\n            strongest_extension = extension\n            strongest_extension_strength\
    \ = extension_components_count_lower_small_strength\n        }\n        if class_name_components_count_lower_small_strength\
    \ > strongest_extension_strength {\n            strongest_extension = extension\n\
    \            strongest_extension_strength = class_name_components_count_lower_small_strength\n\
    \        }\n        if extension_components_count_upper_small_strength > strongest_extension_strength\
    \ {\n            strongest_extension = extension\n            strongest_extension_strength\
    \ = extension_components_count_upper_small_strength\n        }\n    }\n    return\
    \ class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(Strongest_Extension(class_name: \"Watashi\", extensions: [\"tEN\"\
    , \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpebhal6lu.swift:20:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpebhal6lu.swift:20:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpebhal6lu.swift:20:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpebhal6lu.swift:22:36:\
    \ error: expected initial value after '='\n        let extension_components =\
    \ extension.components(separatedBy: \".\")\n                                 \
    \  ^\n/tmp/tmpebhal6lu.swift:22:35: error: consecutive statements on a line must\
    \ be separated by ';'\n        let extension_components = extension.components(separatedBy:\
    \ \".\")\n                                  ^\n                              \
    \    ;\n/tmp/tmpebhal6lu.swift:22:45: error: expected type name in extension declaration\n\
    \        let extension_components = extension.components(separatedBy: \".\")\n\
    \                                            ^\n/tmp/tmpebhal6lu.swift:22:45:\
    \ error: expected '{' in extension\n        let extension_components = extension.components(separatedBy:\
    \ \".\")\n                                            ^\n/tmp/tmpebhal6lu.swift:22:36:\
    \ error: declaration is only valid at file scope\n        let extension_components\
    \ = extension.components(separatedBy: \".\")\n                               \
    \    ^\n/tmp/tmpebhal6lu.swift:36:35: error: expected expression in assignment\n\
    \            strongest_extension = extension\n                               \
    \   ^\n/tmp/tmpebhal6lu.swift:37:42: error: expected '{' in extension\n      \
    \      strongest_extension_strength = class_name_components_count_upper_small_strength\n\
    \                                         ^\n/tmp/tmpebhal6lu.swift:36:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                                  ^\n/tmp/tmpebhal6lu.swift:40:35: error: expected\
    \ expression in assignment\n            strongest_extension = extension\n    \
    \                              ^\n/tmp/tmpebhal6lu.swift:41:42: error: expected"
  stdout: ''
  timestamp: 1659820882
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfunc Strongest_Extension(class_name: String,\
    \ extensions: [String]) -> String {\n    var strongest_extension = \"\"\n    var\
    \ max_strength = -1\n    for extension in extensions {\n        let extension_strength\
    \ = extension.countUppercaseLetters - extension.countLowercaseLetters\n      \
    \  if extension_strength > max_strength {\n            max_strength = extension_strength\n\
    \            strongest_extension = extension\n        }\n    }\n    return class_name\
    \ + \".\" + strongest_extension\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpm9poqlhy.swift:20:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpm9poqlhy.swift:20:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpm9poqlhy.swift:20:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpm9poqlhy.swift:21:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUppercaseLetters\
    \ - extension.countLowercaseLetters\n                                 ^\n/tmp/tmpm9poqlhy.swift:21:33:\
    \ error: consecutive statements on a line must be separated by ';'\n        let\
    \ extension_strength = extension.countUppercaseLetters - extension.countLowercaseLetters\n\
    \                                ^\n                                ;\n/tmp/tmpm9poqlhy.swift:21:43:\
    \ error: expected type name in extension declaration\n        let extension_strength\
    \ = extension.countUppercaseLetters - extension.countLowercaseLetters\n      \
    \                                    ^\n/tmp/tmpm9poqlhy.swift:21:43: error: expected\
    \ '{' in extension\n        let extension_strength = extension.countUppercaseLetters\
    \ - extension.countLowercaseLetters\n                                        \
    \  ^\n/tmp/tmpm9poqlhy.swift:21:34: error: declaration is only valid at file scope\n\
    \        let extension_strength = extension.countUppercaseLetters - extension.countLowercaseLetters\n\
    \                                 ^\n/tmp/tmpm9poqlhy.swift:21:77: error: expected\
    \ type name in extension declaration\n        let extension_strength = extension.countUppercaseLetters\
    \ - extension.countLowercaseLetters\n                                        \
    \                                    ^\n/tmp/tmpm9poqlhy.swift:21:77: error: expected\
    \ '{' in extension\n        let extension_strength = extension.countUppercaseLetters\
    \ - extension.countLowercaseLetters\n                                        \
    \                                    ^\n/tmp/tmpm9poqlhy.swift:21:68: error: declaration\
    \ is only valid at file scope\n        let ex"
  stdout: ''
  timestamp: 1659820882
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfunc Strongest_Extension(class_name: String,\
    \ extensions: [String]) -> String {\n    var strongest_extension = \"\"\n    var\
    \ strongest_extension_strength = -1\n    for extension in extensions {\n     \
    \   var extension_strength = extension.count\n        for letter in extension\
    \ {\n            if letter.isUpper() {\n                extension_strength -=\
    \ 1\n            }\n        }\n        if extension_strength > strongest_extension_strength\
    \ {\n            strongest_extension_strength = extension_strength\n         \
    \   strongest_extension = extension\n        }\n    }\n    return class_name +\
    \ \".\" + strongest_extension\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpdc2q9gnv.swift:20:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpdc2q9gnv.swift:20:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpdc2q9gnv.swift:20:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpdc2q9gnv.swift:21:34:\
    \ error: expected initial value after '='\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmpdc2q9gnv.swift:21:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        var extension_strength\
    \ = extension.count\n                                ^\n                     \
    \           ;\n/tmp/tmpdc2q9gnv.swift:21:43: error: expected type name in extension\
    \ declaration\n        var extension_strength = extension.count\n            \
    \                              ^\n/tmp/tmpdc2q9gnv.swift:21:43: error: expected\
    \ '{' in extension\n        var extension_strength = extension.count\n       \
    \                                   ^\n/tmp/tmpdc2q9gnv.swift:21:34: error: declaration\
    \ is only valid at file scope\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmpdc2q9gnv.swift:22:23: error: expected\
    \ Sequence expression for for-each loop\n        for letter in extension {\n \
    \                     ^\n/tmp/tmpdc2q9gnv.swift:22:23: error: expected '{' to\
    \ start the body of for-each loop\n        for letter in extension {\n       \
    \               ^\n/tmp/tmpdc2q9gnv.swift:29:35: error: expected expression in\
    \ assignment\n            strongest_extension = extension\n                  \
    \                ^\n/tmp/tmpdc2q9gnv.swift:30:9: error: expected type name in\
    \ extension declaration\n        }\n        ^\n/tmp/tmpdc2q9gnv.swift:29:44: error:\
    \ expected '{' in extension\n            strongest_extension = extension\n   \
    \                                        ^\n/tmp/tmpdc2q9gnv.swift:29:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                              "
  stdout: ''
  timestamp: 1659820881
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfunc Strongest_Extension(class_name: String,\
    \ extensions: [String]) -> String {\n    var strongest_extension = \"\"\n    var\
    \ strongest_extension_strength = -1\n    for extension in extensions {\n     \
    \   let extension_strength = extension.countUpToUppercaseLetters - extension.countUpToLowercaseLetters\n\
    \        if extension_strength > strongest_extension_strength {\n            strongest_extension_strength\
    \ = extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpxhz_h2fn.swift:20:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpxhz_h2fn.swift:20:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpxhz_h2fn.swift:20:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpxhz_h2fn.swift:21:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUpToUppercaseLetters\
    \ - extension.countUpToLowercaseLetters\n                                 ^\n\
    /tmp/tmpxhz_h2fn.swift:21:33: error: consecutive statements on a line must be\
    \ separated by ';'\n        let extension_strength = extension.countUpToUppercaseLetters\
    \ - extension.countUpToLowercaseLetters\n                                ^\n \
    \                               ;\n/tmp/tmpxhz_h2fn.swift:21:43: error: expected\
    \ type name in extension declaration\n        let extension_strength = extension.countUpToUppercaseLetters\
    \ - extension.countUpToLowercaseLetters\n                                    \
    \      ^\n/tmp/tmpxhz_h2fn.swift:21:43: error: expected '{' in extension\n   \
    \     let extension_strength = extension.countUpToUppercaseLetters - extension.countUpToLowercaseLetters\n\
    \                                          ^\n/tmp/tmpxhz_h2fn.swift:21:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.countUpToUppercaseLetters\
    \ - extension.countUpToLowercaseLetters\n                                 ^\n\
    /tmp/tmpxhz_h2fn.swift:21:81: error: expected type name in extension declaration\n\
    \        let extension_strength = extension.countUpToUppercaseLetters - extension.countUpToLowercaseLetters\n\
    \                                                                            \
    \    ^\n/tmp/tmpxhz_h2fn.swift:21:81: error: expected '{' in extension\n     \
    \   let extension_strength = extension.countUpToUppercaseLetters - extension.countUpToLowercaseLetters\n\
    \                                                                            \
    \    ^\n/tmp/tmpxhz_h2fn.swift:21:7"
  stdout: ''
  timestamp: 1659820881
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfunc Strongest_Extension(class_name: String,\
    \ extensions: [String]) -> String {\n    var strongest_extension = \"\"\n    var\
    \ strongest_extension_strength = -1\n    var extension_counter = 0\n    for extension\
    \ in extensions {\n        extension_counter += 1\n        let extension_counter_string\
    \ = String(extension_counter)\n        let extension_counter_string_capitalized\
    \ = extension_counter_string.capitalized\n        let extension_counter_string_smaller\
    \ = extension_counter_string_capitalized.lowercased()\n        let extension_counter_string_smallerCapitalized\
    \ = extension_counter_string_smaller.capitalized\n        let extension_counter_string_smallerCapitalizedToUppercase\
    \ = extension_counter_string_smallerCapitalized.uppercased()\n        let extension_counter_string_smallerCapitalizedToLowercase\
    \ = extension_counter_string_smallerCapitalized.lowercased()\n        let extension_counter_string_smallerCapitalizedToLowercaseToUppercase\
    \ = extension_counter_string_smallerCapitalizedToLowercase.uppercased()\n    \
    \    let extension_counter_string_smallerCapitalizedToLowercaseToUppercaseToUppercase\
    \ = extension_counter_string_smallerCapitalizedToLowercaseToUppercase.uppercased()\n\
    \        let extension_counter_string_smallerCapitalizedToLowercaseToUppercaseToUppercaseToUppercase\
    \ = extension_counter_string_smallerCapitalizedToLowercaseToUppercaseToUppercase.uppercased()\n\
    \        let extension_counter_string_smallerCapitalizedToLowercaseToUppercaseToUppercaseToUppercaseToUppercase\
    \ = extension_counter_string_smallerCapitalizedToLowercaseToUppercaseToUppercaseToUppercase.uppercased()\n\
    \        let extension_counter_string_smallerCapitalizedToLowercaseToUppercaseToUppercaseToUppercaseToUppercaseToUppercase\
    \ = extension_counter_string_smallerCapitalizedToLowercaseToUppercaseToUppercaseToUppercaseToUppercaseToUppercase.uppercased()\n\
    \        let extension_counter_string_smallerCapitalizedToLowercaseToUppercaseToUppercaseToUppercaseToUppercaseToUppercaseToUppercase\
    \ = extension_counter_string_smallerCapitalizedToLowercaseToUppercaseToUppercaseToUppercaseToUppercaseToUppercaseToUppercaseToUppercase.uppercased()\n\
    \        let extension_counter_string_smallerCapitalizedToLowercaseToUppercaseToUppercaseToUppercaseToUppercaseToUppercaseToUppercaseToUppercase\
    \ = extension_counter_string_smallerCapitalizedToLowercaseToUppercase\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp09b9hjva.swift:21:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmp09b9hjva.swift:21:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmp09b9hjva.swift:21:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmp09b9hjva.swift:59:91:\
    \ error: expected '}' at end of brace statement\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")\n              \
    \                                                                            ^\n\
    /tmp/tmp09b9hjva.swift:17:78: note: to match this opening '{'\nfunc Strongest_Extension(class_name:\
    \ String, extensions: [String]) -> String {\n                                \
    \                                             ^\n/tmp/tmp09b9hjva.swift:39:6:\
    \ error: operator functions can only be declared at global or in type scope\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n/tmp/tmp09b9hjva.swift:24:77:\
    \ error: value of type 'String' has no member 'capitalized'\n        let extension_counter_string_capitalized\
    \ = extension_counter_string.capitalized\n                                   \
    \                ~~~~~~~~~~~~~~~~~~~~~~~~ ^~~~~~~~~~~\n/tmp/tmp09b9hjva.swift:33:125:\
    \ error: use of local variable 'extension_counter_string_smallerCapitalizedToLowercaseToUppercaseToUppercaseToUppercaseToUppercaseToUppercase'\
    \ before its declaration\n        let extension_counter_string_smallerCapitalizedToLowercaseToUppercaseToUppercaseToUppercaseToUppercaseToUppercase\
    \ = extension_counter_string_smallerCapitalizedToLowercaseToUppercaseToUppercaseToUppercaseToUppercaseToUppercase.uppercased()\n\
    \                                                                            \
    \                                                ^\n/tmp/tmp09b9hjva.swift:33:13:\
    \ note: 'extension_counter_string_smallerCapitalizedToLowercaseToUppercaseToUppercaseToUppercaseToUppercaseToUppercase'\
    \ declared here\n        let extension_counter_string_smallerCapitalize"
  stdout: ''
  timestamp: 1659820882
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfunc Strongest_Extension(class_name: String,\
    \ extensions: [String]) -> String {\n    var strongest_extension = \"\"\n    var\
    \ strongest_extension_strength = -1\n    for extension in extensions {\n     \
    \   let extension_strength = extension.characters.count\n        if extension_strength\
    \ > strongest_extension_strength {\n            strongest_extension_strength =\
    \ extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpg801yqsz.swift:20:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpg801yqsz.swift:20:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpg801yqsz.swift:20:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpg801yqsz.swift:21:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.characters.count\n\
    \                                 ^\n/tmp/tmpg801yqsz.swift:21:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        let extension_strength\
    \ = extension.characters.count\n                                ^\n          \
    \                      ;\n/tmp/tmpg801yqsz.swift:21:43: error: expected type name\
    \ in extension declaration\n        let extension_strength = extension.characters.count\n\
    \                                          ^\n/tmp/tmpg801yqsz.swift:21:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.characters.count\n\
    \                                          ^\n/tmp/tmpg801yqsz.swift:21:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.characters.count\n\
    \                                 ^\n/tmp/tmpg801yqsz.swift:24:35: error: expected\
    \ expression in assignment\n            strongest_extension = extension\n    \
    \                              ^\n/tmp/tmpg801yqsz.swift:25:9: error: expected\
    \ type name in extension declaration\n        }\n        ^\n/tmp/tmpg801yqsz.swift:24:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           ^\n/tmp/tmpg801yqsz.swift:24:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                                  ^\n"
  stdout: ''
  timestamp: 1659820881
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfunc Strongest_Extension(class_name: String,\
    \ extensions: [String]) -> String {\n    var strongest_extension = \"\"\n    var\
    \ strongest_extension_strength = -1\n    for extension in extensions {\n     \
    \   let extension_strength = extension.countUpToLowercaseLetters()\n        if\
    \ extension_strength > strongest_extension_strength {\n            strongest_extension_strength\
    \ = extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp6jifw92_.swift:20:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmp6jifw92_.swift:20:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmp6jifw92_.swift:20:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmp6jifw92_.swift:21:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmp6jifw92_.swift:21:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        let extension_strength\
    \ = extension.countUpToLowercaseLetters()\n                                ^\n\
    \                                ;\n/tmp/tmp6jifw92_.swift:21:43: error: expected\
    \ type name in extension declaration\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmp6jifw92_.swift:21:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmp6jifw92_.swift:21:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmp6jifw92_.swift:24:35: error: expected\
    \ expression in assignment\n            strongest_extension = extension\n    \
    \                              ^\n/tmp/tmp6jifw92_.swift:25:9: error: expected\
    \ type name in extension declaration\n        }\n        ^\n/tmp/tmp6jifw92_.swift:24:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           ^\n/tmp/tmp6jifw92_.swift:24:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                                  ^\n"
  stdout: ''
  timestamp: 1659820881
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfunc Strongest_Extension(class_name: String,\
    \ extensions: [String]) -> String {\n    var strongest_extension = \"\"\n    var\
    \ max_strength = -1\n    for extension in extensions {\n        var strength =\
    \ count_capital_letters(extension) - count_capital_letters(extension.lowercaseString)\n\
    \        if strength > max_strength {\n            max_strength = strength\n \
    \           strongest_extension = extension\n        }\n    }\n    return class_name\
    \ + \".\" + strongest_extension\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpuqiu69ui.swift:20:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpuqiu69ui.swift:20:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpuqiu69ui.swift:20:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpuqiu69ui.swift:21:46:\
    \ error: expected expression in list of expressions\n        var strength = count_capital_letters(extension)\
    \ - count_capital_letters(extension.lowercaseString)\n                       \
    \                      ^\n/tmp/tmpuqiu69ui.swift:21:46: error: consecutive statements\
    \ on a line must be separated by ';'\n        var strength = count_capital_letters(extension)\
    \ - count_capital_letters(extension.lowercaseString)\n                       \
    \                      ^\n                                             ;\n/tmp/tmpuqiu69ui.swift:21:55:\
    \ error: expected type name in extension declaration\n        var strength = count_capital_letters(extension)\
    \ - count_capital_letters(extension.lowercaseString)\n                       \
    \                               ^\n                                          \
    \             <#type#>\n/tmp/tmpuqiu69ui.swift:21:55: error: expected '{' in extension\n\
    \        var strength = count_capital_letters(extension) - count_capital_letters(extension.lowercaseString)\n\
    \                                                      ^\n/tmp/tmpuqiu69ui.swift:21:46:\
    \ error: declaration is only valid at file scope\n        var strength = count_capital_letters(extension)\
    \ - count_capital_letters(extension.lowercaseString)\n                       \
    \                      ^\n/tmp/tmpuqiu69ui.swift:24:35: error: expected expression\
    \ in assignment\n            strongest_extension = extension\n               \
    \                   ^\n/tmp/tmpuqiu69ui.swift:25:9: error: expected type name\
    \ in extension declaration\n        }\n        ^\n/tmp/tmpuqiu69ui.swift:24:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           "
  stdout: ''
  timestamp: 1659820881
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfunc Strongest_Extension(class_name: String,\
    \ extensions: [String]) -> String {\n    var strongest_extension = \"\"\n    var\
    \ max_strength = -1\n    for extension in extensions {\n        let strength =\
    \ class_name.characters.filter({ $0.isUppercase }).count - class_name.characters.filter({\
    \ $0.isLowercase }).count\n        if strength > max_strength {\n            max_strength\
    \ = strength\n            strongest_extension = extension\n        }\n    }\n\
    \    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpu0_fjv_y.swift:20:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpu0_fjv_y.swift:20:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpu0_fjv_y.swift:20:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpu0_fjv_y.swift:24:35:\
    \ error: expected expression in assignment\n            strongest_extension =\
    \ extension\n                                  ^\n/tmp/tmpu0_fjv_y.swift:25:9:\
    \ error: expected type name in extension declaration\n        }\n        ^\n/tmp/tmpu0_fjv_y.swift:24:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           ^\n/tmp/tmpu0_fjv_y.swift:24:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                                  ^\n/tmp/tmpu0_fjv_y.swift:21:35: error: 'characters'\
    \ is unavailable: Please use String directly\n        let strength = class_name.characters.filter({\
    \ $0.isUppercase }).count - class_name.characters.filter({ $0.isLowercase }).count\n\
    \                                  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpu0_fjv_y.swift:21:92: error: 'characters' is unavailable:\
    \ Please use String directly\n        let strength = class_name.characters.filter({\
    \ $0.isUppercase }).count - class_name.characters.filter({ $0.isLowercase }).count\n\
    \                                                                            \
    \               ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n"
  stdout: ''
  timestamp: 1659820882
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfunc Strongest_Extension(class_name: String,\
    \ extensions: [String]) -> String {\n    var strongest_extension = \"\"\n    var\
    \ max_strength = -1\n    for extension in extensions {\n        var extension_strength\
    \ = extension.count\n        for char in extension {\n            if char.uppercased()\
    \ != char {\n                extension_strength -= 1\n            }\n        }\n\
    \        if extension_strength > max_strength {\n            max_strength = extension_strength\n\
    \            strongest_extension = class_name\n        }\n    }\n    return strongest_extension\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp8643d2ow.swift:20:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmp8643d2ow.swift:20:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmp8643d2ow.swift:20:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmp8643d2ow.swift:21:34:\
    \ error: expected initial value after '='\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmp8643d2ow.swift:21:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        var extension_strength\
    \ = extension.count\n                                ^\n                     \
    \           ;\n/tmp/tmp8643d2ow.swift:21:43: error: expected type name in extension\
    \ declaration\n        var extension_strength = extension.count\n            \
    \                              ^\n/tmp/tmp8643d2ow.swift:21:43: error: expected\
    \ '{' in extension\n        var extension_strength = extension.count\n       \
    \                                   ^\n/tmp/tmp8643d2ow.swift:21:34: error: declaration\
    \ is only valid at file scope\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmp8643d2ow.swift:22:21: error: expected\
    \ Sequence expression for for-each loop\n        for char in extension {\n   \
    \                 ^\n/tmp/tmp8643d2ow.swift:22:21: error: expected '{' to start\
    \ the body of for-each loop\n        for char in extension {\n               \
    \     ^\n"
  stdout: ''
  timestamp: 1659820882
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfunc Strongest_Extension(class_name: String,\
    \ extensions: [String]) -> String {\n    var strongest_extension = \"\"\n    var\
    \ strongest_extension_strength = -1\n    for extension in extensions {\n     \
    \   var extension_strength = extension.count\n        for letter in extension\
    \ {\n            if letter.isUpper() {\n                extension_strength -=\
    \ 1\n            }\n        }\n        if extension_strength > strongest_extension_strength\
    \ {\n            strongest_extension_strength = extension_strength\n         \
    \   strongest_extension = extension\n        }\n    }\n    return class_name +\
    \ \".\" + strongest_extension\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpdc2q9gnv.swift:20:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpdc2q9gnv.swift:20:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpdc2q9gnv.swift:20:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpdc2q9gnv.swift:21:34:\
    \ error: expected initial value after '='\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmpdc2q9gnv.swift:21:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        var extension_strength\
    \ = extension.count\n                                ^\n                     \
    \           ;\n/tmp/tmpdc2q9gnv.swift:21:43: error: expected type name in extension\
    \ declaration\n        var extension_strength = extension.count\n            \
    \                              ^\n/tmp/tmpdc2q9gnv.swift:21:43: error: expected\
    \ '{' in extension\n        var extension_strength = extension.count\n       \
    \                                   ^\n/tmp/tmpdc2q9gnv.swift:21:34: error: declaration\
    \ is only valid at file scope\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmpdc2q9gnv.swift:22:23: error: expected\
    \ Sequence expression for for-each loop\n        for letter in extension {\n \
    \                     ^\n/tmp/tmpdc2q9gnv.swift:22:23: error: expected '{' to\
    \ start the body of for-each loop\n        for letter in extension {\n       \
    \               ^\n/tmp/tmpdc2q9gnv.swift:29:35: error: expected expression in\
    \ assignment\n            strongest_extension = extension\n                  \
    \                ^\n/tmp/tmpdc2q9gnv.swift:30:9: error: expected type name in\
    \ extension declaration\n        }\n        ^\n/tmp/tmpdc2q9gnv.swift:29:44: error:\
    \ expected '{' in extension\n            strongest_extension = extension\n   \
    \                                        ^\n/tmp/tmpdc2q9gnv.swift:29:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                              "
  stdout: ''
  timestamp: 1659820881
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfunc Strongest_Extension(class_name: String,\
    \ extensions: [String]) -> String {\n    var strongest_extension = \"\"\n    var\
    \ strongest_extension_strength = -1\n    for extension in extensions {\n     \
    \   let class_name_components = class_name.components(separatedBy: \".\")\n  \
    \      let extension_components = extension.components(separatedBy: \".\")\n \
    \       let class_name_components_count = class_name_components.count\n      \
    \  let extension_components_count = extension_components.count\n        let class_name_components_count_cap\
    \ = class_name_components.count - class_name_components_count + 1\n        let\
    \ extension_components_count_cap = extension_components.count - extension_components_count\
    \ + 1\n        let class_name_components_count_sm = class_name_components_count\
    \ - class_name_components_count_cap\n        let extension_components_count_sm\
    \ = extension_components_count - extension_components_count_cap\n        let class_name_components_count_cap_sm\
    \ = (class_name_components_count_cap - class_name_components_count_sm) / 2\n \
    \       let extension_components_count_cap_sm = (extension_components_count_cap\
    \ - extension_components_count_sm) / 2\n        let class_name_components_count_cap_sm_cap\
    \ = class_name_components_count_cap - class_name_components_count_cap_sm + 1\n\
    \        let extension_components_count_cap_sm_cap = extension_components_count_cap\
    \ - extension_components_count_cap_sm + 1\n        let class_name_components_count_cap_sm_sm\
    \ = class_name_components_count_cap_sm - class_name_components_count_cap_sm_cap\n\
    \        let extension_components_count_cap_sm_sm = extension_components_count_cap_sm\
    \ - extension_components_count_cap_sm_cap\n        let class_name_components_count_cap_sm_cap_sm\
    \ = class_name_components_count_cap_sm_cap - class_name_components_count_cap_sm_sm\
    \ + 1\n        let extension_components_count_cap_sm_cap_sm = extension_components_count_cap_sm_cap\
    \ - extension_components_count_cap_sm_sm + 1\n        let class_name_components_count_cap_sm_sm_cap\
    \ = class_name_components_count_cap_sm_sm - class_name_components_count_cap_sm_cap_sm\
    \ + 1\n        let extension_components_count_cap_sm_sm_cap = extension_components_count_cap_sm_sm\
    \ - extension_components_count_cap_sm_cap_sm + 1\n        let class_name_components_count_cap_sm_cap_sm_sm\
    \ = class_name_components_count_cap_sm_cap_sm - class_name_components_count_cap_sm_sm_cap\
    \ + 1\n        let extension_components_count_cap_sm_cap_sm_sm = extension_components_count_cap_s\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp_179uk5a.swift:20:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmp_179uk5a.swift:20:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmp_179uk5a.swift:20:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmp_179uk5a.swift:22:36:\
    \ error: expected initial value after '='\n        let extension_components =\
    \ extension.components(separatedBy: \".\")\n                                 \
    \  ^\n/tmp/tmp_179uk5a.swift:22:35: error: consecutive statements on a line must\
    \ be separated by ';'\n        let extension_components = extension.components(separatedBy:\
    \ \".\")\n                                  ^\n                              \
    \    ;\n/tmp/tmp_179uk5a.swift:22:45: error: expected type name in extension declaration\n\
    \        let extension_components = extension.components(separatedBy: \".\")\n\
    \                                            ^\n/tmp/tmp_179uk5a.swift:22:45:\
    \ error: expected '{' in extension\n        let extension_components = extension.components(separatedBy:\
    \ \".\")\n                                            ^\n/tmp/tmp_179uk5a.swift:22:36:\
    \ error: declaration is only valid at file scope\n        let extension_components\
    \ = extension.components(separatedBy: \".\")\n                               \
    \    ^\n/tmp/tmp_179uk5a.swift:64:91: error: expected '}' at end of brace statement\n\
    assert(Strongest_Extension(class_name: \"Sp\", extensions: [\"671235\", \"Bb\"\
    ]) == \"Sp.671235\")\n                                                       \
    \                                   ^\n/tmp/tmp_179uk5a.swift:17:78: note: to\
    \ match this opening '{'\nfunc Strongest_Extension(class_name: String, extensions:\
    \ [String]) -> String {\n                                                    \
    \                         ^\n/tmp/tmp_179uk5a.swift:44:6: error: operator functions\
    \ can only be declared at global or in type scope\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n     ^\n/tmp/tmp_179uk5a.swift:21:48: error:\
    \ value of type 'St"
  stdout: ''
  timestamp: 1659820882
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfunc Strongest_Extension(class_name: String,\
    \ extensions: [String]) -> String {\n    var strongest_extension = \"\"\n    var\
    \ strength = -1\n    for extension in extensions {\n        var extension_length\
    \ = extension.count\n        var extension_strength = extension_length - 1\n \
    \       for index in 0..<extension_length {\n            if extension[index] ==\
    \ extension[index].lowercased() {\n                extension_strength -= 1\n \
    \           }\n        }\n        if extension_strength > strength {\n       \
    \     strongest_extension = class_name\n            strength = extension_strength\n\
    \        }\n    }\n    return strongest_extension\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpm31jgtc8.swift:20:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpm31jgtc8.swift:20:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpm31jgtc8.swift:20:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpm31jgtc8.swift:21:32:\
    \ error: expected initial value after '='\n        var extension_length = extension.count\n\
    \                               ^\n/tmp/tmpm31jgtc8.swift:21:31: error: consecutive\
    \ statements on a line must be separated by ';'\n        var extension_length\
    \ = extension.count\n                              ^\n                       \
    \       ;\n/tmp/tmpm31jgtc8.swift:21:41: error: expected type name in extension\
    \ declaration\n        var extension_length = extension.count\n              \
    \                          ^\n/tmp/tmpm31jgtc8.swift:21:41: error: expected '{'\
    \ in extension\n        var extension_length = extension.count\n             \
    \                           ^\n/tmp/tmpm31jgtc8.swift:21:32: error: declaration\
    \ is only valid at file scope\n        var extension_length = extension.count\n\
    \                               ^\n/tmp/tmpm31jgtc8.swift:24:16: error: expected\
    \ expression, var, or let in 'if' condition\n            if extension[index] ==\
    \ extension[index].lowercased() {\n               ^\n/tmp/tmpm31jgtc8.swift:24:33:\
    \ error: expected '{' in extension\n            if extension[index] == extension[index].lowercased()\
    \ {\n                                ^\n/tmp/tmpm31jgtc8.swift:24:16: error: declaration\
    \ is only valid at file scope\n            if extension[index] == extension[index].lowercased()\
    \ {\n               ^\n/tmp/tmpm31jgtc8.swift:24:52: error: expected '{' in extension\n\
    \            if extension[index] == extension[index].lowercased() {\n        \
    \                                           ^\n/tmp/tmpm31jgtc8.swift:24:36: error:\
    \ declaration is only valid at file scope\n            if extension[index] ==\
    \ extension[index].lowercased() {\n                                   ^\n"
  stdout: ''
  timestamp: 1659820882
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfunc Strongest_Extension(class_name: String,\
    \ extensions: [String]) -> String {\n    var strongest_extension = \"\"\n    var\
    \ strongest_extension_strength = -1\n    for extension in extensions {\n     \
    \   let class_name_components = class_name.components(separatedBy: \".\")\n  \
    \      let extension_components = extension.components(separatedBy: \".\")\n \
    \       let class_name_components_count = class_name_components.count\n      \
    \  let extension_components_count = extension_components.count\n        let class_name_components_count_upper\
    \ = class_name_components.filter({ $0.isUppercased() }).count\n        let extension_components_count_lower\
    \ = extension_components.filter({ $0.isLowercased() }).count\n        let class_name_components_count_upper_small\
    \ = class_name_components_count_upper - class_name_components_count_lower\n  \
    \      let extension_components_count_lower_small = extension_components_count_lower\
    \ - extension_components_count_upper_small\n        let extension_strength = class_name_components_count_upper_small\
    \ * extension_components_count_lower_small\n        if extension_strength > strongest_extension_strength\
    \ {\n            strongest_extension_strength = extension_strength\n         \
    \   strongest_extension = extension\n        }\n    }\n    return class_name +\
    \ \".\" + strongest_extension\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpe0whwrh4.swift:20:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpe0whwrh4.swift:20:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpe0whwrh4.swift:20:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpe0whwrh4.swift:22:36:\
    \ error: expected initial value after '='\n        let extension_components =\
    \ extension.components(separatedBy: \".\")\n                                 \
    \  ^\n/tmp/tmpe0whwrh4.swift:22:35: error: consecutive statements on a line must\
    \ be separated by ';'\n        let extension_components = extension.components(separatedBy:\
    \ \".\")\n                                  ^\n                              \
    \    ;\n/tmp/tmpe0whwrh4.swift:22:45: error: expected type name in extension declaration\n\
    \        let extension_components = extension.components(separatedBy: \".\")\n\
    \                                            ^\n/tmp/tmpe0whwrh4.swift:22:45:\
    \ error: expected '{' in extension\n        let extension_components = extension.components(separatedBy:\
    \ \".\")\n                                            ^\n/tmp/tmpe0whwrh4.swift:22:36:\
    \ error: declaration is only valid at file scope\n        let extension_components\
    \ = extension.components(separatedBy: \".\")\n                               \
    \    ^\n/tmp/tmpe0whwrh4.swift:32:35: error: expected expression in assignment\n\
    \            strongest_extension = extension\n                               \
    \   ^\n/tmp/tmpe0whwrh4.swift:33:9: error: expected type name in extension declaration\n\
    \        }\n        ^\n/tmp/tmpe0whwrh4.swift:32:44: error: expected '{' in extension\n\
    \            strongest_extension = extension\n                               \
    \            ^\n/tmp/tmpe0whwrh4.swift:32:35: error: declaration is only valid\
    \ at file scope\n            strongest_extension = extension\n               \
    \                   ^\n/tmp/tmpe0whwrh4.swift:21:48: error: value of type 'String'\
    \ has no member 'components'\n        let class_name_components = class_name.componen"
  stdout: ''
  timestamp: 1659820882
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfunc Strongest_Extension(class_name: String,\
    \ extensions: [String]) -> String {\n    var strongest_extension = \"\"\n    var\
    \ strongest_extension_strength = -1\n    for extension in extensions {\n     \
    \   var extension_strength = extension.count\n        for letter in extension\
    \ {\n            if letter.isUpper() {\n                extension_strength -=\
    \ 1\n            }\n        }\n        if extension_strength > strongest_extension_strength\
    \ {\n            strongest_extension_strength = extension_strength\n         \
    \   strongest_extension = extension\n        }\n    }\n    return class_name +\
    \ \".\" + strongest_extension\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpdc2q9gnv.swift:20:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpdc2q9gnv.swift:20:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpdc2q9gnv.swift:20:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpdc2q9gnv.swift:21:34:\
    \ error: expected initial value after '='\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmpdc2q9gnv.swift:21:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        var extension_strength\
    \ = extension.count\n                                ^\n                     \
    \           ;\n/tmp/tmpdc2q9gnv.swift:21:43: error: expected type name in extension\
    \ declaration\n        var extension_strength = extension.count\n            \
    \                              ^\n/tmp/tmpdc2q9gnv.swift:21:43: error: expected\
    \ '{' in extension\n        var extension_strength = extension.count\n       \
    \                                   ^\n/tmp/tmpdc2q9gnv.swift:21:34: error: declaration\
    \ is only valid at file scope\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmpdc2q9gnv.swift:22:23: error: expected\
    \ Sequence expression for for-each loop\n        for letter in extension {\n \
    \                     ^\n/tmp/tmpdc2q9gnv.swift:22:23: error: expected '{' to\
    \ start the body of for-each loop\n        for letter in extension {\n       \
    \               ^\n/tmp/tmpdc2q9gnv.swift:29:35: error: expected expression in\
    \ assignment\n            strongest_extension = extension\n                  \
    \                ^\n/tmp/tmpdc2q9gnv.swift:30:9: error: expected type name in\
    \ extension declaration\n        }\n        ^\n/tmp/tmpdc2q9gnv.swift:29:44: error:\
    \ expected '{' in extension\n            strongest_extension = extension\n   \
    \                                        ^\n/tmp/tmpdc2q9gnv.swift:29:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                              "
  stdout: ''
  timestamp: 1659820881
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfunc Strongest_Extension(class_name: String,\
    \ extensions: [String]) -> String {\n    var strongest_extension = \"\"\n    var\
    \ strongest_extension_strength = -1\n    for extension in extensions {\n     \
    \   let extension_strength = extension.countUpToLowercaseLetters()\n        if\
    \ extension_strength > strongest_extension_strength {\n            strongest_extension_strength\
    \ = extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp6jifw92_.swift:20:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmp6jifw92_.swift:20:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmp6jifw92_.swift:20:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmp6jifw92_.swift:21:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmp6jifw92_.swift:21:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        let extension_strength\
    \ = extension.countUpToLowercaseLetters()\n                                ^\n\
    \                                ;\n/tmp/tmp6jifw92_.swift:21:43: error: expected\
    \ type name in extension declaration\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmp6jifw92_.swift:21:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmp6jifw92_.swift:21:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmp6jifw92_.swift:24:35: error: expected\
    \ expression in assignment\n            strongest_extension = extension\n    \
    \                              ^\n/tmp/tmp6jifw92_.swift:25:9: error: expected\
    \ type name in extension declaration\n        }\n        ^\n/tmp/tmp6jifw92_.swift:24:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           ^\n/tmp/tmp6jifw92_.swift:24:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                                  ^\n"
  stdout: ''
  timestamp: 1659820881
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfunc Strongest_Extension(class_name: String,\
    \ extensions: [String]) -> String {\n    var strongest_extension = \"\"\n    var\
    \ max_strength = -1\n    for extension in extensions {\n        var strength =\
    \ count_capital_letters(extension) - count_capital_letters(class_name)\n     \
    \   if strength > max_strength {\n            max_strength = strength\n      \
    \      strongest_extension = extension\n        }\n    }\n    return class_name\
    \ + \".\" + strongest_extension\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpg72ztk2y.swift:20:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpg72ztk2y.swift:20:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpg72ztk2y.swift:20:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpg72ztk2y.swift:21:46:\
    \ error: expected expression in list of expressions\n        var strength = count_capital_letters(extension)\
    \ - count_capital_letters(class_name)\n                                      \
    \       ^\n/tmp/tmpg72ztk2y.swift:21:46: error: consecutive statements on a line\
    \ must be separated by ';'\n        var strength = count_capital_letters(extension)\
    \ - count_capital_letters(class_name)\n                                      \
    \       ^\n                                             ;\n/tmp/tmpg72ztk2y.swift:21:55:\
    \ error: expected type name in extension declaration\n        var strength = count_capital_letters(extension)\
    \ - count_capital_letters(class_name)\n                                      \
    \                ^\n                                                       <#type#>\n\
    /tmp/tmpg72ztk2y.swift:21:55: error: expected '{' in extension\n        var strength\
    \ = count_capital_letters(extension) - count_capital_letters(class_name)\n   \
    \                                                   ^\n/tmp/tmpg72ztk2y.swift:21:46:\
    \ error: declaration is only valid at file scope\n        var strength = count_capital_letters(extension)\
    \ - count_capital_letters(class_name)\n                                      \
    \       ^\n/tmp/tmpg72ztk2y.swift:24:35: error: expected expression in assignment\n\
    \            strongest_extension = extension\n                               \
    \   ^\n/tmp/tmpg72ztk2y.swift:25:9: error: expected type name in extension declaration\n\
    \        }\n        ^\n/tmp/tmpg72ztk2y.swift:24:44: error: expected '{' in extension\n\
    \            strongest_extension = extension\n                               \
    \            ^\n/tmp/tmpg72ztk2y.swift:24:35: error: declaration is only valid\
    \ at file sc"
  stdout: ''
  timestamp: 1659820882
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfunc Strongest_Extension(class_name: String,\
    \ extensions: [String]) -> String {\n    var strongest_extension = \"\"\n    var\
    \ strongest_extension_strength = -1\n    for extension in extensions {\n     \
    \   let extension_strength = extension.characters.count\n        if extension_strength\
    \ > strongest_extension_strength {\n            strongest_extension = class_name\n\
    \            strongest_extension_strength = extension_strength\n        }\n  \
    \  }\n    return strongest_extension\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(Strongest_Extension(class_name: \"Watashi\", extensions: [\"tEN\", \"niNE\"\
    , \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpitdvtw8u.swift:20:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpitdvtw8u.swift:20:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpitdvtw8u.swift:20:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpitdvtw8u.swift:21:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.characters.count\n\
    \                                 ^\n/tmp/tmpitdvtw8u.swift:21:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        let extension_strength\
    \ = extension.characters.count\n                                ^\n          \
    \                      ;\n/tmp/tmpitdvtw8u.swift:21:43: error: expected type name\
    \ in extension declaration\n        let extension_strength = extension.characters.count\n\
    \                                          ^\n/tmp/tmpitdvtw8u.swift:21:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.characters.count\n\
    \                                          ^\n/tmp/tmpitdvtw8u.swift:21:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.characters.count\n\
    \                                 ^\n"
  stdout: ''
  timestamp: 1659820882
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfunc Strongest_Extension(class_name: String,\
    \ extensions: [String]) -> String {\n    var strongest_extension = \"\"\n    var\
    \ max_strength = -1\n    for extension in extensions {\n        var strength =\
    \ count_capital_letters(extension) - count_capital_letters(class_name)\n     \
    \   if strength > max_strength {\n            max_strength = strength\n      \
    \      strongest_extension = extension\n        }\n    }\n    return class_name\
    \ + \".\" + strongest_extension\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpg72ztk2y.swift:20:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpg72ztk2y.swift:20:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpg72ztk2y.swift:20:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpg72ztk2y.swift:21:46:\
    \ error: expected expression in list of expressions\n        var strength = count_capital_letters(extension)\
    \ - count_capital_letters(class_name)\n                                      \
    \       ^\n/tmp/tmpg72ztk2y.swift:21:46: error: consecutive statements on a line\
    \ must be separated by ';'\n        var strength = count_capital_letters(extension)\
    \ - count_capital_letters(class_name)\n                                      \
    \       ^\n                                             ;\n/tmp/tmpg72ztk2y.swift:21:55:\
    \ error: expected type name in extension declaration\n        var strength = count_capital_letters(extension)\
    \ - count_capital_letters(class_name)\n                                      \
    \                ^\n                                                       <#type#>\n\
    /tmp/tmpg72ztk2y.swift:21:55: error: expected '{' in extension\n        var strength\
    \ = count_capital_letters(extension) - count_capital_letters(class_name)\n   \
    \                                                   ^\n/tmp/tmpg72ztk2y.swift:21:46:\
    \ error: declaration is only valid at file scope\n        var strength = count_capital_letters(extension)\
    \ - count_capital_letters(class_name)\n                                      \
    \       ^\n/tmp/tmpg72ztk2y.swift:24:35: error: expected expression in assignment\n\
    \            strongest_extension = extension\n                               \
    \   ^\n/tmp/tmpg72ztk2y.swift:25:9: error: expected type name in extension declaration\n\
    \        }\n        ^\n/tmp/tmpg72ztk2y.swift:24:44: error: expected '{' in extension\n\
    \            strongest_extension = extension\n                               \
    \            ^\n/tmp/tmpg72ztk2y.swift:24:35: error: declaration is only valid\
    \ at file sc"
  stdout: ''
  timestamp: 1659820882
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfunc Strongest_Extension(class_name: String,\
    \ extensions: [String]) -> String {\n    var strongest_extension = \"\"\n    var\
    \ strongest_extension_strength = -1\n    for extension in extensions {\n     \
    \   let extension_strength = extension.countUpToLowercaseLetters()\n        if\
    \ extension_strength > strongest_extension_strength {\n            strongest_extension_strength\
    \ = extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp6jifw92_.swift:20:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmp6jifw92_.swift:20:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmp6jifw92_.swift:20:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmp6jifw92_.swift:21:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmp6jifw92_.swift:21:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        let extension_strength\
    \ = extension.countUpToLowercaseLetters()\n                                ^\n\
    \                                ;\n/tmp/tmp6jifw92_.swift:21:43: error: expected\
    \ type name in extension declaration\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmp6jifw92_.swift:21:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmp6jifw92_.swift:21:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmp6jifw92_.swift:24:35: error: expected\
    \ expression in assignment\n            strongest_extension = extension\n    \
    \                              ^\n/tmp/tmp6jifw92_.swift:25:9: error: expected\
    \ type name in extension declaration\n        }\n        ^\n/tmp/tmp6jifw92_.swift:24:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           ^\n/tmp/tmp6jifw92_.swift:24:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                                  ^\n"
  stdout: ''
  timestamp: 1659820881
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfunc Strongest_Extension(class_name: String,\
    \ extensions: [String]) -> String {\n    var strongest_extension = \"\"\n    var\
    \ strongest_extension_strength = -1\n    for extension in extensions {\n     \
    \   let extension_strength = extension.countUpToLowercaseLetters()\n        if\
    \ extension_strength > strongest_extension_strength {\n            strongest_extension_strength\
    \ = extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp6jifw92_.swift:20:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmp6jifw92_.swift:20:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmp6jifw92_.swift:20:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmp6jifw92_.swift:21:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmp6jifw92_.swift:21:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        let extension_strength\
    \ = extension.countUpToLowercaseLetters()\n                                ^\n\
    \                                ;\n/tmp/tmp6jifw92_.swift:21:43: error: expected\
    \ type name in extension declaration\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmp6jifw92_.swift:21:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmp6jifw92_.swift:21:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmp6jifw92_.swift:24:35: error: expected\
    \ expression in assignment\n            strongest_extension = extension\n    \
    \                              ^\n/tmp/tmp6jifw92_.swift:25:9: error: expected\
    \ type name in extension declaration\n        }\n        ^\n/tmp/tmp6jifw92_.swift:24:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           ^\n/tmp/tmp6jifw92_.swift:24:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                                  ^\n"
  stdout: ''
  timestamp: 1659820881
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfunc Strongest_Extension(class_name: String,\
    \ extensions: [String]) -> String {\n    var strongest_extension = \"\"\n    var\
    \ strongest_extension_strength = -1\n    for extension in extensions {\n     \
    \   let extension_strength = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n\
    \        if extension_strength > strongest_extension_strength {\n            strongest_extension_strength\
    \ = extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpmx22zuzy.swift:20:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpmx22zuzy.swift:20:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpmx22zuzy.swift:20:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpmx22zuzy.swift:21:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUppercaseLetters()\
    \ - extension.countLowercaseLetters()\n                                 ^\n/tmp/tmpmx22zuzy.swift:21:33:\
    \ error: consecutive statements on a line must be separated by ';'\n        let\
    \ extension_strength = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n\
    \                                ^\n                                ;\n/tmp/tmpmx22zuzy.swift:21:43:\
    \ error: expected type name in extension declaration\n        let extension_strength\
    \ = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n  \
    \                                        ^\n/tmp/tmpmx22zuzy.swift:21:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.countUppercaseLetters()\
    \ - extension.countLowercaseLetters()\n                                      \
    \    ^\n/tmp/tmpmx22zuzy.swift:21:34: error: declaration is only valid at file\
    \ scope\n        let extension_strength = extension.countUppercaseLetters() -\
    \ extension.countLowercaseLetters()\n                                 ^\n/tmp/tmpmx22zuzy.swift:21:79:\
    \ error: expected type name in extension declaration\n        let extension_strength\
    \ = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n  \
    \                                                                            ^\n\
    /tmp/tmpmx22zuzy.swift:21:79: error: expected '{' in extension\n        let extension_strength\
    \ = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n  \
    \                                                                            ^\n\
    /tmp/tmpmx22zuzy.swift:21:70: error: declaration is only va"
  stdout: ''
  timestamp: 1659820882
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfunc Strongest_Extension(class_name: String,\
    \ extensions: [String]) -> String {\n    var strongest_extension = \"\"\n    var\
    \ strongest_extension_strength = -1\n    for extension in extensions {\n     \
    \   var extension_strength = extension.count\n        for letter in extension\
    \ {\n            if letter.isUpper() {\n                extension_strength -=\
    \ 1\n            }\n        }\n        if extension_strength > strongest_extension_strength\
    \ {\n            strongest_extension_strength = extension_strength\n         \
    \   strongest_extension = extension\n        }\n    }\n    return class_name +\
    \ \".\" + strongest_extension\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpdc2q9gnv.swift:20:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpdc2q9gnv.swift:20:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpdc2q9gnv.swift:20:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpdc2q9gnv.swift:21:34:\
    \ error: expected initial value after '='\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmpdc2q9gnv.swift:21:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        var extension_strength\
    \ = extension.count\n                                ^\n                     \
    \           ;\n/tmp/tmpdc2q9gnv.swift:21:43: error: expected type name in extension\
    \ declaration\n        var extension_strength = extension.count\n            \
    \                              ^\n/tmp/tmpdc2q9gnv.swift:21:43: error: expected\
    \ '{' in extension\n        var extension_strength = extension.count\n       \
    \                                   ^\n/tmp/tmpdc2q9gnv.swift:21:34: error: declaration\
    \ is only valid at file scope\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmpdc2q9gnv.swift:22:23: error: expected\
    \ Sequence expression for for-each loop\n        for letter in extension {\n \
    \                     ^\n/tmp/tmpdc2q9gnv.swift:22:23: error: expected '{' to\
    \ start the body of for-each loop\n        for letter in extension {\n       \
    \               ^\n/tmp/tmpdc2q9gnv.swift:29:35: error: expected expression in\
    \ assignment\n            strongest_extension = extension\n                  \
    \                ^\n/tmp/tmpdc2q9gnv.swift:30:9: error: expected type name in\
    \ extension declaration\n        }\n        ^\n/tmp/tmpdc2q9gnv.swift:29:44: error:\
    \ expected '{' in extension\n            strongest_extension = extension\n   \
    \                                        ^\n/tmp/tmpdc2q9gnv.swift:29:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                              "
  stdout: ''
  timestamp: 1659820881
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfunc Strongest_Extension(class_name: String,\
    \ extensions: [String]) -> String {\n    var strongest_extension = \"\"\n    var\
    \ strongest_extension_strength = -1\n    for extension in extensions {\n     \
    \   let extension_strength = extension.characters.count - extension.lowercased().characters.count\n\
    \        if extension_strength > strongest_extension_strength {\n            strongest_extension\
    \ = class_name\n            strongest_extension_strength = extension_strength\n\
    \        }\n    }\n    return strongest_extension\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpqvzr7_j8.swift:20:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpqvzr7_j8.swift:20:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpqvzr7_j8.swift:20:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpqvzr7_j8.swift:21:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.characters.count\
    \ - extension.lowercased().characters.count\n                                \
    \ ^\n/tmp/tmpqvzr7_j8.swift:21:33: error: consecutive statements on a line must\
    \ be separated by ';'\n        let extension_strength = extension.characters.count\
    \ - extension.lowercased().characters.count\n                                ^\n\
    \                                ;\n/tmp/tmpqvzr7_j8.swift:21:43: error: expected\
    \ type name in extension declaration\n        let extension_strength = extension.characters.count\
    \ - extension.lowercased().characters.count\n                                \
    \          ^\n/tmp/tmpqvzr7_j8.swift:21:43: error: expected '{' in extension\n\
    \        let extension_strength = extension.characters.count - extension.lowercased().characters.count\n\
    \                                          ^\n/tmp/tmpqvzr7_j8.swift:21:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.characters.count\
    \ - extension.lowercased().characters.count\n                                \
    \ ^\n/tmp/tmpqvzr7_j8.swift:21:72: error: expected type name in extension declaration\n\
    \        let extension_strength = extension.characters.count - extension.lowercased().characters.count\n\
    \                                                                       ^\n/tmp/tmpqvzr7_j8.swift:21:72:\
    \ error: expected '{' in extension\n        let extension_strength = extension.characters.count\
    \ - extension.lowercased().characters.count\n                                \
    \                                       ^\n/tmp/tmpqvzr7_j8.swift:21:63: error:\
    \ declaration is only valid at file scope\n   "
  stdout: ''
  timestamp: 1659820882
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfunc Strongest_Extension(class_name: String,\
    \ extensions: [String]) -> String {\n    var strongest_extension = \"\"\n    var\
    \ max_strength = -1\n    for extension in extensions {\n        let strength =\
    \ extension.countUpToUppercaseLetters() - extension.countUpToLowercaseLetters()\n\
    \        if strength > max_strength {\n            max_strength = strength\n \
    \           strongest_extension = extension\n        }\n    }\n    return class_name\
    \ + \".\" + strongest_extension\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpah_kz0u2.swift:20:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpah_kz0u2.swift:20:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpah_kz0u2.swift:20:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpah_kz0u2.swift:21:24:\
    \ error: expected initial value after '='\n        let strength = extension.countUpToUppercaseLetters()\
    \ - extension.countUpToLowercaseLetters()\n                       ^\n/tmp/tmpah_kz0u2.swift:21:23:\
    \ error: consecutive statements on a line must be separated by ';'\n        let\
    \ strength = extension.countUpToUppercaseLetters() - extension.countUpToLowercaseLetters()\n\
    \                      ^\n                      ;\n/tmp/tmpah_kz0u2.swift:21:33:\
    \ error: expected type name in extension declaration\n        let strength = extension.countUpToUppercaseLetters()\
    \ - extension.countUpToLowercaseLetters()\n                                ^\n\
    /tmp/tmpah_kz0u2.swift:21:33: error: expected '{' in extension\n        let strength\
    \ = extension.countUpToUppercaseLetters() - extension.countUpToLowercaseLetters()\n\
    \                                ^\n/tmp/tmpah_kz0u2.swift:21:24: error: declaration\
    \ is only valid at file scope\n        let strength = extension.countUpToUppercaseLetters()\
    \ - extension.countUpToLowercaseLetters()\n                       ^\n/tmp/tmpah_kz0u2.swift:21:73:\
    \ error: expected type name in extension declaration\n        let strength = extension.countUpToUppercaseLetters()\
    \ - extension.countUpToLowercaseLetters()\n                                  \
    \                                      ^\n/tmp/tmpah_kz0u2.swift:21:73: error:\
    \ expected '{' in extension\n        let strength = extension.countUpToUppercaseLetters()\
    \ - extension.countUpToLowercaseLetters()\n                                  \
    \                                      ^\n/tmp/tmpah_kz0u2.swift:21:64: error:\
    \ declaration is only valid at file scope\n        let strength = extension.countUpToUppercaseLetters()\
    \ - exten"
  stdout: ''
  timestamp: 1659820882
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfunc Strongest_Extension(class_name: String,\
    \ extensions: [String]) -> String {\n    var strongest_extension = \"\"\n    var\
    \ strongest_extension_strength = -1\n    for extension in extensions {\n     \
    \   let extension_strength = extension.characters.filter({ $0.isUppercase }).count\
    \ - extension.characters.filter({ $0.isLowercase }).count\n        if extension_strength\
    \ > strongest_extension_strength {\n            strongest_extension_strength =\
    \ extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp6safxxdm.swift:20:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmp6safxxdm.swift:20:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmp6safxxdm.swift:20:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmp6safxxdm.swift:21:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.characters.filter({\
    \ $0.isUppercase }).count - extension.characters.filter({ $0.isLowercase }).count\n\
    \                                 ^\n/tmp/tmp6safxxdm.swift:21:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        let extension_strength\
    \ = extension.characters.filter({ $0.isUppercase }).count - extension.characters.filter({\
    \ $0.isLowercase }).count\n                                ^\n               \
    \                 ;\n/tmp/tmp6safxxdm.swift:21:43: error: expected type name in\
    \ extension declaration\n        let extension_strength = extension.characters.filter({\
    \ $0.isUppercase }).count - extension.characters.filter({ $0.isLowercase }).count\n\
    \                                          ^\n/tmp/tmp6safxxdm.swift:21:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.characters.filter({\
    \ $0.isUppercase }).count - extension.characters.filter({ $0.isLowercase }).count\n\
    \                                          ^\n/tmp/tmp6safxxdm.swift:21:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.characters.filter({\
    \ $0.isUppercase }).count - extension.characters.filter({ $0.isLowercase }).count\n\
    \                                 ^\n/tmp/tmp6safxxdm.swift:21:99: error: expected\
    \ type name in extension declaration\n        let extension_strength = extension.characters.filter({\
    \ $0.isUppercase }).count - extension.characters.filter({ $0.isLowercase }).count\n\
    \                                                                            \
    \                      ^\n/tmp/tmp6safxxdm.swift:21:99: error: expected"
  stdout: ''
  timestamp: 1659820882
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfunc Strongest_Extension(class_name: String,\
    \ extensions: [String]) -> String {\n    var strongest_extension = \"\"\n    var\
    \ strongest_extension_strength = -1\n    for extension in extensions {\n     \
    \   let extension_strength = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n\
    \        if extension_strength > strongest_extension_strength {\n            strongest_extension_strength\
    \ = extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpmx22zuzy.swift:20:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpmx22zuzy.swift:20:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpmx22zuzy.swift:20:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpmx22zuzy.swift:21:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUppercaseLetters()\
    \ - extension.countLowercaseLetters()\n                                 ^\n/tmp/tmpmx22zuzy.swift:21:33:\
    \ error: consecutive statements on a line must be separated by ';'\n        let\
    \ extension_strength = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n\
    \                                ^\n                                ;\n/tmp/tmpmx22zuzy.swift:21:43:\
    \ error: expected type name in extension declaration\n        let extension_strength\
    \ = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n  \
    \                                        ^\n/tmp/tmpmx22zuzy.swift:21:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.countUppercaseLetters()\
    \ - extension.countLowercaseLetters()\n                                      \
    \    ^\n/tmp/tmpmx22zuzy.swift:21:34: error: declaration is only valid at file\
    \ scope\n        let extension_strength = extension.countUppercaseLetters() -\
    \ extension.countLowercaseLetters()\n                                 ^\n/tmp/tmpmx22zuzy.swift:21:79:\
    \ error: expected type name in extension declaration\n        let extension_strength\
    \ = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n  \
    \                                                                            ^\n\
    /tmp/tmpmx22zuzy.swift:21:79: error: expected '{' in extension\n        let extension_strength\
    \ = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n  \
    \                                                                            ^\n\
    /tmp/tmpmx22zuzy.swift:21:70: error: declaration is only va"
  stdout: ''
  timestamp: 1659820882
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfunc Strongest_Extension(class_name: String,\
    \ extensions: [String]) -> String {\n    var strongest_extension = \"\"\n    var\
    \ strength = -1\n    for extension in extensions {\n        let class_name_components\
    \ = class_name.components(separatedBy: \".\")\n        let extension_components\
    \ = extension.components(separatedBy: \".\")\n        let class_name_components_count\
    \ = class_name_components.count\n        let extension_components_count = extension_components.count\n\
    \        if class_name_components_count == extension_components_count {\n    \
    \        if class_name_components_count == 1 {\n                if class_name_components[0]\
    \ == extension_components[0] {\n                    strength = class_name_components[0]\n\
    \                }\n            }\n            else {\n                if class_name_components[0]\
    \ == extension_components[0] && class_name_components[1] == extension_components[1]\
    \ {\n                    strength = class_name_components[0]\n               \
    \ }\n            }\n        }\n    }\n    if strength == -1 {\n        return\
    \ class_name\n    }\n    else {\n        return class_name + \".\" + extensions[extensions.index(of:\
    \ extensions[extensions.index(of: extensions[extensions.index(of: extensions)!])!])!]\n\
    \    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpxn7bw9dl.swift:20:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpxn7bw9dl.swift:20:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpxn7bw9dl.swift:20:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpxn7bw9dl.swift:22:36:\
    \ error: expected initial value after '='\n        let extension_components =\
    \ extension.components(separatedBy: \".\")\n                                 \
    \  ^\n/tmp/tmpxn7bw9dl.swift:22:35: error: consecutive statements on a line must\
    \ be separated by ';'\n        let extension_components = extension.components(separatedBy:\
    \ \".\")\n                                  ^\n                              \
    \    ;\n/tmp/tmpxn7bw9dl.swift:22:45: error: expected type name in extension declaration\n\
    \        let extension_components = extension.components(separatedBy: \".\")\n\
    \                                            ^\n/tmp/tmpxn7bw9dl.swift:22:45:\
    \ error: expected '{' in extension\n        let extension_components = extension.components(separatedBy:\
    \ \".\")\n                                            ^\n/tmp/tmpxn7bw9dl.swift:22:36:\
    \ error: declaration is only valid at file scope\n        let extension_components\
    \ = extension.components(separatedBy: \".\")\n                               \
    \    ^\n/tmp/tmpxn7bw9dl.swift:42:131: error: cannot convert value of type '[String]'\
    \ to expected argument type 'String'\n        return class_name + \".\" + extensions[extensions.index(of:\
    \ extensions[extensions.index(of: extensions[extensions.index(of: extensions)!])!])!]\n\
    \                                                                            \
    \                                                      ^\n/tmp/tmpxn7bw9dl.swift:21:48:\
    \ error: value of type 'String' has no member 'components'\n        let class_name_components\
    \ = class_name.components(separatedBy: \".\")\n                              \
    \      ~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659820882
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfunc Strongest_Extension(class_name: String,\
    \ extensions: [String]) -> String {\n    var strongest_extension = \"\"\n    var\
    \ strongest_extension_strength = -1\n    for extension in extensions {\n     \
    \   let extension_strength = extension.countUpToUppercaseLetters - extension.countUpToLowercaseLetters\n\
    \        if extension_strength > strongest_extension_strength {\n            strongest_extension_strength\
    \ = extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpxhz_h2fn.swift:20:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpxhz_h2fn.swift:20:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpxhz_h2fn.swift:20:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpxhz_h2fn.swift:21:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUpToUppercaseLetters\
    \ - extension.countUpToLowercaseLetters\n                                 ^\n\
    /tmp/tmpxhz_h2fn.swift:21:33: error: consecutive statements on a line must be\
    \ separated by ';'\n        let extension_strength = extension.countUpToUppercaseLetters\
    \ - extension.countUpToLowercaseLetters\n                                ^\n \
    \                               ;\n/tmp/tmpxhz_h2fn.swift:21:43: error: expected\
    \ type name in extension declaration\n        let extension_strength = extension.countUpToUppercaseLetters\
    \ - extension.countUpToLowercaseLetters\n                                    \
    \      ^\n/tmp/tmpxhz_h2fn.swift:21:43: error: expected '{' in extension\n   \
    \     let extension_strength = extension.countUpToUppercaseLetters - extension.countUpToLowercaseLetters\n\
    \                                          ^\n/tmp/tmpxhz_h2fn.swift:21:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.countUpToUppercaseLetters\
    \ - extension.countUpToLowercaseLetters\n                                 ^\n\
    /tmp/tmpxhz_h2fn.swift:21:81: error: expected type name in extension declaration\n\
    \        let extension_strength = extension.countUpToUppercaseLetters - extension.countUpToLowercaseLetters\n\
    \                                                                            \
    \    ^\n/tmp/tmpxhz_h2fn.swift:21:81: error: expected '{' in extension\n     \
    \   let extension_strength = extension.countUpToUppercaseLetters - extension.countUpToLowercaseLetters\n\
    \                                                                            \
    \    ^\n/tmp/tmpxhz_h2fn.swift:21:7"
  stdout: ''
  timestamp: 1659820881
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfunc Strongest_Extension(class_name: String,\
    \ extensions: [String]) -> String {\n    var strongest_extension = \"\"\n    var\
    \ strongest_extension_strength = -1\n    var class_name_lowercase = class_name.lowercased()\n\
    \    var class_name_uppercase = class_name.uppercased()\n    for extension in\
    \ extensions {\n        var extension_lowercase = extension.lowercased()\n   \
    \     var extension_uppercase = extension.uppercased()\n        var extension_strength\
    \ = class_name_lowercase.distance(class_name_uppercase)\n        var extension_strength_2\
    \ = class_name_uppercase.distance(class_name_lowercase)\n        if extension_strength\
    \ > strongest_extension_strength {\n            strongest_extension = extension\n\
    \            strongest_extension_strength = extension_strength\n        }\n  \
    \      if extension_strength_2 > strongest_extension_strength {\n            strongest_extension\
    \ = extension\n            strongest_extension_strength = extension_strength_2\n\
    \        }\n    }\n    return strongest_extension\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp3dsjph4t.swift:22:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmp3dsjph4t.swift:22:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmp3dsjph4t.swift:22:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmp3dsjph4t.swift:23:35:\
    \ error: expected initial value after '='\n        var extension_lowercase = extension.lowercased()\n\
    \                                  ^\n/tmp/tmp3dsjph4t.swift:23:34: error: consecutive\
    \ statements on a line must be separated by ';'\n        var extension_lowercase\
    \ = extension.lowercased()\n                                 ^\n             \
    \                    ;\n/tmp/tmp3dsjph4t.swift:23:44: error: expected type name\
    \ in extension declaration\n        var extension_lowercase = extension.lowercased()\n\
    \                                           ^\n/tmp/tmp3dsjph4t.swift:23:44: error:\
    \ expected '{' in extension\n        var extension_lowercase = extension.lowercased()\n\
    \                                           ^\n/tmp/tmp3dsjph4t.swift:23:35: error:\
    \ declaration is only valid at file scope\n        var extension_lowercase = extension.lowercased()\n\
    \                                  ^\n/tmp/tmp3dsjph4t.swift:24:35: error: expected\
    \ initial value after '='\n        var extension_uppercase = extension.uppercased()\n\
    \                                  ^\n/tmp/tmp3dsjph4t.swift:24:34: error: consecutive\
    \ statements on a line must be separated by ';'\n        var extension_uppercase\
    \ = extension.uppercased()\n                                 ^\n             \
    \                    ;\n/tmp/tmp3dsjph4t.swift:24:44: error: expected type name\
    \ in extension declaration\n        var extension_uppercase = extension.uppercased()\n\
    \                                           ^\n/tmp/tmp3dsjph4t.swift:24:44: error:\
    \ expected '{' in extension\n        var extension_uppercase = extension.uppercased()\n\
    \                                           ^\n/tmp/tmp3dsjph4t.swift:24:35: error:\
    \ declaration is only val"
  stdout: ''
  timestamp: 1659820882
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfunc Strongest_Extension(class_name: String,\
    \ extensions: [String]) -> String {\n    var strongest_extension = \"\"\n    var\
    \ max_strength = -1\n    for extension in extensions {\n        let extension_strength\
    \ = extension.characters.count\n        if extension_strength > max_strength {\n\
    \            max_strength = extension_strength\n            strongest_extension\
    \ = extension\n        }\n    }\n    return class_name + \".\" + strongest_extension\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp_yurf75k.swift:20:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmp_yurf75k.swift:20:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmp_yurf75k.swift:20:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmp_yurf75k.swift:21:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.characters.count\n\
    \                                 ^\n/tmp/tmp_yurf75k.swift:21:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        let extension_strength\
    \ = extension.characters.count\n                                ^\n          \
    \                      ;\n/tmp/tmp_yurf75k.swift:21:43: error: expected type name\
    \ in extension declaration\n        let extension_strength = extension.characters.count\n\
    \                                          ^\n/tmp/tmp_yurf75k.swift:21:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.characters.count\n\
    \                                          ^\n/tmp/tmp_yurf75k.swift:21:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.characters.count\n\
    \                                 ^\n/tmp/tmp_yurf75k.swift:24:35: error: expected\
    \ expression in assignment\n            strongest_extension = extension\n    \
    \                              ^\n/tmp/tmp_yurf75k.swift:25:9: error: expected\
    \ type name in extension declaration\n        }\n        ^\n/tmp/tmp_yurf75k.swift:24:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           ^\n/tmp/tmp_yurf75k.swift:24:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                                  ^\n"
  stdout: ''
  timestamp: 1659820881
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfunc Strongest_Extension(class_name: String,\
    \ extensions: [String]) -> String {\n    var strongest_extension = \"\"\n    var\
    \ strongest_extension_strength = -1\n    for extension in extensions {\n     \
    \   var extension_strength = extension.count\n        for c in extension {\n \
    \           if c >= 'A' && c <= 'Z' {\n                extension_strength -= 1\
    \ \n            }\n            if c >= 'a' && c <= 'z' {\n                extension_strength\
    \ -= 1 \n            }\n        }\n        if extension_strength > strongest_extension_strength\
    \ {\n            strongest_extension = extension\n            strongest_extension_strength\
    \ = extension_strength\n        }\n    }\n    return class_name + \".\" + strongest_extension\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpjpbl6d3n.swift:20:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpjpbl6d3n.swift:20:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpjpbl6d3n.swift:20:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpjpbl6d3n.swift:21:34:\
    \ error: expected initial value after '='\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmpjpbl6d3n.swift:21:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        var extension_strength\
    \ = extension.count\n                                ^\n                     \
    \           ;\n/tmp/tmpjpbl6d3n.swift:21:43: error: expected type name in extension\
    \ declaration\n        var extension_strength = extension.count\n            \
    \                              ^\n/tmp/tmpjpbl6d3n.swift:21:43: error: expected\
    \ '{' in extension\n        var extension_strength = extension.count\n       \
    \                                   ^\n/tmp/tmpjpbl6d3n.swift:21:34: error: declaration\
    \ is only valid at file scope\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmpjpbl6d3n.swift:22:18: error: expected\
    \ Sequence expression for for-each loop\n        for c in extension {\n      \
    \           ^\n/tmp/tmpjpbl6d3n.swift:22:18: error: expected '{' to start the\
    \ body of for-each loop\n        for c in extension {\n                 ^\n/tmp/tmpjpbl6d3n.swift:23:21:\
    \ error: single-quoted string literal found, use '\"'\n            if c >= 'A'\
    \ && c <= 'Z' {\n                    ^~~\n                    \"A\"\n/tmp/tmpjpbl6d3n.swift:23:33:\
    \ error: single-quoted string literal found, use '\"'\n            if c >= 'A'\
    \ && c <= 'Z' {\n                                ^~~\n                       \
    \         \"Z\"\n/tmp/tmpjpbl6d3n.swift:26:21: error: single-quoted string literal\
    \ found, use '\"'\n            if c >= 'a' && c <= 'z' {\n                   \
    \ ^~~\n                    \"a\"\n/tmp/tmpjpbl6d3n.swift:26:33: error: single-quote"
  stdout: ''
  timestamp: 1659820882
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfunc Strongest_Extension(class_name: String,\
    \ extensions: [String]) -> String {\n    var strongest_extension = \"\"\n    var\
    \ strongest_extension_strength = -1\n    for extension in extensions {\n     \
    \   let extension_strength = extension.characters.count\n        if extension_strength\
    \ > strongest_extension_strength {\n            strongest_extension_strength =\
    \ extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpg801yqsz.swift:20:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpg801yqsz.swift:20:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpg801yqsz.swift:20:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpg801yqsz.swift:21:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.characters.count\n\
    \                                 ^\n/tmp/tmpg801yqsz.swift:21:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        let extension_strength\
    \ = extension.characters.count\n                                ^\n          \
    \                      ;\n/tmp/tmpg801yqsz.swift:21:43: error: expected type name\
    \ in extension declaration\n        let extension_strength = extension.characters.count\n\
    \                                          ^\n/tmp/tmpg801yqsz.swift:21:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.characters.count\n\
    \                                          ^\n/tmp/tmpg801yqsz.swift:21:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.characters.count\n\
    \                                 ^\n/tmp/tmpg801yqsz.swift:24:35: error: expected\
    \ expression in assignment\n            strongest_extension = extension\n    \
    \                              ^\n/tmp/tmpg801yqsz.swift:25:9: error: expected\
    \ type name in extension declaration\n        }\n        ^\n/tmp/tmpg801yqsz.swift:24:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           ^\n/tmp/tmpg801yqsz.swift:24:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                                  ^\n"
  stdout: ''
  timestamp: 1659820881
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfunc Strongest_Extension(class_name: String,\
    \ extensions: [String]) -> String {\n    var strongest_extension = \"\"\n    var\
    \ strongest_extension_strength = -1\n    for extension in extensions {\n     \
    \   var extension_strength = extension.count\n        for letter in extension\
    \ {\n            if letter.isUpper() {\n                extension_strength -=\
    \ 1\n            }\n        }\n        if extension_strength > strongest_extension_strength\
    \ {\n            strongest_extension_strength = extension_strength\n         \
    \   strongest_extension = extension\n        }\n    }\n    return class_name +\
    \ \".\" + strongest_extension\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpdc2q9gnv.swift:20:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpdc2q9gnv.swift:20:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpdc2q9gnv.swift:20:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpdc2q9gnv.swift:21:34:\
    \ error: expected initial value after '='\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmpdc2q9gnv.swift:21:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        var extension_strength\
    \ = extension.count\n                                ^\n                     \
    \           ;\n/tmp/tmpdc2q9gnv.swift:21:43: error: expected type name in extension\
    \ declaration\n        var extension_strength = extension.count\n            \
    \                              ^\n/tmp/tmpdc2q9gnv.swift:21:43: error: expected\
    \ '{' in extension\n        var extension_strength = extension.count\n       \
    \                                   ^\n/tmp/tmpdc2q9gnv.swift:21:34: error: declaration\
    \ is only valid at file scope\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmpdc2q9gnv.swift:22:23: error: expected\
    \ Sequence expression for for-each loop\n        for letter in extension {\n \
    \                     ^\n/tmp/tmpdc2q9gnv.swift:22:23: error: expected '{' to\
    \ start the body of for-each loop\n        for letter in extension {\n       \
    \               ^\n/tmp/tmpdc2q9gnv.swift:29:35: error: expected expression in\
    \ assignment\n            strongest_extension = extension\n                  \
    \                ^\n/tmp/tmpdc2q9gnv.swift:30:9: error: expected type name in\
    \ extension declaration\n        }\n        ^\n/tmp/tmpdc2q9gnv.swift:29:44: error:\
    \ expected '{' in extension\n            strongest_extension = extension\n   \
    \                                        ^\n/tmp/tmpdc2q9gnv.swift:29:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                              "
  stdout: ''
  timestamp: 1659820881
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfunc Strongest_Extension(class_name: String,\
    \ extensions: [String]) -> String {\n    var strongest_extension = \"\"\n    var\
    \ strength = -1\n    for extension in extensions {\n        let class_components\
    \ = class_name.components(separatedBy: \".\")\n        let extension_components\
    \ = extension.components(separatedBy: \".\")\n        if class_components.count\
    \ < extension_components.count {\n            strongest_extension = extension\n\
    \            strength = class_components.count - extension_components.count\n\
    \        } else if class_components.count == extension_components.count {\n  \
    \          if class_components[0] == extension_components[0] {\n             \
    \   strongest_extension = extension\n                strength = class_components.count\
    \ - extension_components.count\n            }\n        }\n    }\n    return class_name\
    \ + \".\" + strongest_extension\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp_ow19i17.swift:20:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmp_ow19i17.swift:20:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmp_ow19i17.swift:20:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmp_ow19i17.swift:22:36:\
    \ error: expected initial value after '='\n        let extension_components =\
    \ extension.components(separatedBy: \".\")\n                                 \
    \  ^\n/tmp/tmp_ow19i17.swift:22:35: error: consecutive statements on a line must\
    \ be separated by ';'\n        let extension_components = extension.components(separatedBy:\
    \ \".\")\n                                  ^\n                              \
    \    ;\n/tmp/tmp_ow19i17.swift:22:45: error: expected type name in extension declaration\n\
    \        let extension_components = extension.components(separatedBy: \".\")\n\
    \                                            ^\n/tmp/tmp_ow19i17.swift:22:45:\
    \ error: expected '{' in extension\n        let extension_components = extension.components(separatedBy:\
    \ \".\")\n                                            ^\n/tmp/tmp_ow19i17.swift:22:36:\
    \ error: declaration is only valid at file scope\n        let extension_components\
    \ = extension.components(separatedBy: \".\")\n                               \
    \    ^\n/tmp/tmp_ow19i17.swift:24:35: error: expected expression in assignment\n\
    \            strongest_extension = extension\n                               \
    \   ^\n/tmp/tmp_ow19i17.swift:25:22: error: expected '{' in extension\n      \
    \      strength = class_components.count - extension_components.count\n      \
    \               ^\n/tmp/tmp_ow19i17.swift:24:35: error: declaration is only valid\
    \ at file scope\n            strongest_extension = extension\n               \
    \                   ^\n/tmp/tmp_ow19i17.swift:28:39: error: expected expression\
    \ in assignment\n                strongest_extension = extension\n           \
    \                           ^\n/tmp/tmp_ow19i17.swift:29:26: error: expected '{'\
    \ in extension\n           "
  stdout: ''
  timestamp: 1659820882
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfunc Strongest_Extension(class_name: String,\
    \ extensions: [String]) -> String {\n    var strongest_extension = \"\"\n    var\
    \ strongest_extension_strength = -1\n    for extension in extensions {\n     \
    \   let class_name_components = class_name.components(separatedBy: \".\")\n  \
    \      let extension_components = extension.components(separatedBy: \".\")\n \
    \       let class_name_components_count = class_name_components.count\n      \
    \  let extension_components_count = extension_components.count\n        let class_name_components_extension_strength\
    \ = class_name_components_count - extension_components_count\n        if class_name_components_extension_strength\
    \ > strongest_extension_strength {\n            strongest_extension = extension\n\
    \            strongest_extension_strength = class_name_components_extension_strength\n\
    \        }\n    }\n    return class_name + \".\" + strongest_extension\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpmqic1ytv.swift:20:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpmqic1ytv.swift:20:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpmqic1ytv.swift:20:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpmqic1ytv.swift:22:36:\
    \ error: expected initial value after '='\n        let extension_components =\
    \ extension.components(separatedBy: \".\")\n                                 \
    \  ^\n/tmp/tmpmqic1ytv.swift:22:35: error: consecutive statements on a line must\
    \ be separated by ';'\n        let extension_components = extension.components(separatedBy:\
    \ \".\")\n                                  ^\n                              \
    \    ;\n/tmp/tmpmqic1ytv.swift:22:45: error: expected type name in extension declaration\n\
    \        let extension_components = extension.components(separatedBy: \".\")\n\
    \                                            ^\n/tmp/tmpmqic1ytv.swift:22:45:\
    \ error: expected '{' in extension\n        let extension_components = extension.components(separatedBy:\
    \ \".\")\n                                            ^\n/tmp/tmpmqic1ytv.swift:22:36:\
    \ error: declaration is only valid at file scope\n        let extension_components\
    \ = extension.components(separatedBy: \".\")\n                               \
    \    ^\n/tmp/tmpmqic1ytv.swift:27:35: error: expected expression in assignment\n\
    \            strongest_extension = extension\n                               \
    \   ^\n/tmp/tmpmqic1ytv.swift:28:42: error: expected '{' in extension\n      \
    \      strongest_extension_strength = class_name_components_extension_strength\n\
    \                                         ^\n/tmp/tmpmqic1ytv.swift:27:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                                  ^\n/tmp/tmpmqic1ytv.swift:28:13: error: cannot\
    \ find type 'strongest_extension_strength' in scope\n            strongest_extension_strength\
    \ = class_name_components_extension_strength\n            ^~~~~~~~~~~~~~"
  stdout: ''
  timestamp: 1659820882
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfunc Strongest_Extension(class_name: String,\
    \ extensions: [String]) -> String {\n    var strongest_extension = \"\"\n    var\
    \ strongest_extension_strength = -1\n    for extension in extensions {\n     \
    \   let extension_strength = extension.countUpToUppercase() - extension.countUpToLowercase()\n\
    \        if extension_strength > strongest_extension_strength {\n            strongest_extension_strength\
    \ = extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpkhpb8s88.swift:20:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpkhpb8s88.swift:20:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpkhpb8s88.swift:20:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpkhpb8s88.swift:21:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUpToUppercase()\
    \ - extension.countUpToLowercase()\n                                 ^\n/tmp/tmpkhpb8s88.swift:21:33:\
    \ error: consecutive statements on a line must be separated by ';'\n        let\
    \ extension_strength = extension.countUpToUppercase() - extension.countUpToLowercase()\n\
    \                                ^\n                                ;\n/tmp/tmpkhpb8s88.swift:21:43:\
    \ error: expected type name in extension declaration\n        let extension_strength\
    \ = extension.countUpToUppercase() - extension.countUpToLowercase()\n        \
    \                                  ^\n/tmp/tmpkhpb8s88.swift:21:43: error: expected\
    \ '{' in extension\n        let extension_strength = extension.countUpToUppercase()\
    \ - extension.countUpToLowercase()\n                                         \
    \ ^\n/tmp/tmpkhpb8s88.swift:21:34: error: declaration is only valid at file scope\n\
    \        let extension_strength = extension.countUpToUppercase() - extension.countUpToLowercase()\n\
    \                                 ^\n/tmp/tmpkhpb8s88.swift:21:76: error: expected\
    \ type name in extension declaration\n        let extension_strength = extension.countUpToUppercase()\
    \ - extension.countUpToLowercase()\n                                         \
    \                                  ^\n/tmp/tmpkhpb8s88.swift:21:76: error: expected\
    \ '{' in extension\n        let extension_strength = extension.countUpToUppercase()\
    \ - extension.countUpToLowercase()\n                                         \
    \                                  ^\n/tmp/tmpkhpb8s88.swift:21:67: error: declaration\
    \ is only valid at file scope\n        let extension_strength"
  stdout: ''
  timestamp: 1659820881
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfunc Strongest_Extension(class_name: String,\
    \ extensions: [String]) -> String {\n    var strongest_extension = \"\"\n    var\
    \ strongest_extension_strength = -1\n    for extension in extensions {\n     \
    \   let extension_strength = extension.countUpToLowercaseLetters()\n        if\
    \ extension_strength > strongest_extension_strength {\n            strongest_extension_strength\
    \ = extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp6jifw92_.swift:20:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmp6jifw92_.swift:20:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmp6jifw92_.swift:20:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmp6jifw92_.swift:21:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmp6jifw92_.swift:21:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        let extension_strength\
    \ = extension.countUpToLowercaseLetters()\n                                ^\n\
    \                                ;\n/tmp/tmp6jifw92_.swift:21:43: error: expected\
    \ type name in extension declaration\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmp6jifw92_.swift:21:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmp6jifw92_.swift:21:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmp6jifw92_.swift:24:35: error: expected\
    \ expression in assignment\n            strongest_extension = extension\n    \
    \                              ^\n/tmp/tmp6jifw92_.swift:25:9: error: expected\
    \ type name in extension declaration\n        }\n        ^\n/tmp/tmp6jifw92_.swift:24:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           ^\n/tmp/tmp6jifw92_.swift:24:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                                  ^\n"
  stdout: ''
  timestamp: 1659820881
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfunc Strongest_Extension(class_name: String,\
    \ extensions: [String]) -> String {\n    var strongest_extension = \"\"\n    var\
    \ max_strength = -1\n    for extension in extensions {\n        let extension_strength\
    \ = extension.countElements() - extension.lowercased().countElements()\n     \
    \   if extension_strength > max_strength {\n            max_strength = extension_strength\n\
    \            strongest_extension = extension\n        }\n    }\n    return class_name\
    \ + \".\" + strongest_extension\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp7ewlcdv2.swift:20:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmp7ewlcdv2.swift:20:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmp7ewlcdv2.swift:20:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmp7ewlcdv2.swift:21:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countElements()\
    \ - extension.lowercased().countElements()\n                                 ^\n\
    /tmp/tmp7ewlcdv2.swift:21:33: error: consecutive statements on a line must be\
    \ separated by ';'\n        let extension_strength = extension.countElements()\
    \ - extension.lowercased().countElements()\n                                ^\n\
    \                                ;\n/tmp/tmp7ewlcdv2.swift:21:43: error: expected\
    \ type name in extension declaration\n        let extension_strength = extension.countElements()\
    \ - extension.lowercased().countElements()\n                                 \
    \         ^\n/tmp/tmp7ewlcdv2.swift:21:43: error: expected '{' in extension\n\
    \        let extension_strength = extension.countElements() - extension.lowercased().countElements()\n\
    \                                          ^\n/tmp/tmp7ewlcdv2.swift:21:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.countElements()\
    \ - extension.lowercased().countElements()\n                                 ^\n\
    /tmp/tmp7ewlcdv2.swift:21:71: error: expected type name in extension declaration\n\
    \        let extension_strength = extension.countElements() - extension.lowercased().countElements()\n\
    \                                                                      ^\n/tmp/tmp7ewlcdv2.swift:21:71:\
    \ error: expected '{' in extension\n        let extension_strength = extension.countElements()\
    \ - extension.lowercased().countElements()\n                                 \
    \                                     ^\n/tmp/tmp7ewlcdv2.swift:21:62: error:\
    \ declaration is only valid at file scope\n        let extensi"
  stdout: ''
  timestamp: 1659820882
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfunc Strongest_Extension(class_name: String,\
    \ extensions: [String]) -> String {\n    var strongest_extension = \"\"\n    var\
    \ max_strength = -1\n    for extension in extensions {\n        var strength =\
    \ count_capital_letters(extension) - count_capital_letters(extension.lowercaseString)\n\
    \        if strength > max_strength {\n            max_strength = strength\n \
    \           strongest_extension = extension\n        }\n    }\n    return class_name\
    \ + \".\" + strongest_extension\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpuqiu69ui.swift:20:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpuqiu69ui.swift:20:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpuqiu69ui.swift:20:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpuqiu69ui.swift:21:46:\
    \ error: expected expression in list of expressions\n        var strength = count_capital_letters(extension)\
    \ - count_capital_letters(extension.lowercaseString)\n                       \
    \                      ^\n/tmp/tmpuqiu69ui.swift:21:46: error: consecutive statements\
    \ on a line must be separated by ';'\n        var strength = count_capital_letters(extension)\
    \ - count_capital_letters(extension.lowercaseString)\n                       \
    \                      ^\n                                             ;\n/tmp/tmpuqiu69ui.swift:21:55:\
    \ error: expected type name in extension declaration\n        var strength = count_capital_letters(extension)\
    \ - count_capital_letters(extension.lowercaseString)\n                       \
    \                               ^\n                                          \
    \             <#type#>\n/tmp/tmpuqiu69ui.swift:21:55: error: expected '{' in extension\n\
    \        var strength = count_capital_letters(extension) - count_capital_letters(extension.lowercaseString)\n\
    \                                                      ^\n/tmp/tmpuqiu69ui.swift:21:46:\
    \ error: declaration is only valid at file scope\n        var strength = count_capital_letters(extension)\
    \ - count_capital_letters(extension.lowercaseString)\n                       \
    \                      ^\n/tmp/tmpuqiu69ui.swift:24:35: error: expected expression\
    \ in assignment\n            strongest_extension = extension\n               \
    \                   ^\n/tmp/tmpuqiu69ui.swift:25:9: error: expected type name\
    \ in extension declaration\n        }\n        ^\n/tmp/tmpuqiu69ui.swift:24:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           "
  stdout: ''
  timestamp: 1659820881
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfunc Strongest_Extension(class_name: String,\
    \ extensions: [String]) -> String {\n    var strongest_extension = \"\"\n    var\
    \ strongest_extension_strength = -1\n    for extension in extensions {\n     \
    \   let extension_strength = extension.countUpToLowercaseLetters()\n        if\
    \ extension_strength > strongest_extension_strength {\n            strongest_extension_strength\
    \ = extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp6jifw92_.swift:20:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmp6jifw92_.swift:20:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmp6jifw92_.swift:20:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmp6jifw92_.swift:21:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmp6jifw92_.swift:21:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        let extension_strength\
    \ = extension.countUpToLowercaseLetters()\n                                ^\n\
    \                                ;\n/tmp/tmp6jifw92_.swift:21:43: error: expected\
    \ type name in extension declaration\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmp6jifw92_.swift:21:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmp6jifw92_.swift:21:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmp6jifw92_.swift:24:35: error: expected\
    \ expression in assignment\n            strongest_extension = extension\n    \
    \                              ^\n/tmp/tmp6jifw92_.swift:25:9: error: expected\
    \ type name in extension declaration\n        }\n        ^\n/tmp/tmp6jifw92_.swift:24:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           ^\n/tmp/tmp6jifw92_.swift:24:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                                  ^\n"
  stdout: ''
  timestamp: 1659820881
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfunc Strongest_Extension(class_name: String,\
    \ extensions: [String]) -> String {\n    var strongest_extension = \"\"\n    var\
    \ strongest_extension_strength = -1\n    for extension in extensions {\n     \
    \   var extension_strength = extension.count\n        for letter in extension\
    \ {\n            if letter.isUpper() {\n                extension_strength -=\
    \ 1\n            }\n        }\n        if extension_strength > strongest_extension_strength\
    \ {\n            strongest_extension_strength = extension_strength\n         \
    \   strongest_extension = extension\n        }\n    }\n    return class_name +\
    \ \".\" + strongest_extension\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpdc2q9gnv.swift:20:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpdc2q9gnv.swift:20:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpdc2q9gnv.swift:20:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpdc2q9gnv.swift:21:34:\
    \ error: expected initial value after '='\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmpdc2q9gnv.swift:21:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        var extension_strength\
    \ = extension.count\n                                ^\n                     \
    \           ;\n/tmp/tmpdc2q9gnv.swift:21:43: error: expected type name in extension\
    \ declaration\n        var extension_strength = extension.count\n            \
    \                              ^\n/tmp/tmpdc2q9gnv.swift:21:43: error: expected\
    \ '{' in extension\n        var extension_strength = extension.count\n       \
    \                                   ^\n/tmp/tmpdc2q9gnv.swift:21:34: error: declaration\
    \ is only valid at file scope\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmpdc2q9gnv.swift:22:23: error: expected\
    \ Sequence expression for for-each loop\n        for letter in extension {\n \
    \                     ^\n/tmp/tmpdc2q9gnv.swift:22:23: error: expected '{' to\
    \ start the body of for-each loop\n        for letter in extension {\n       \
    \               ^\n/tmp/tmpdc2q9gnv.swift:29:35: error: expected expression in\
    \ assignment\n            strongest_extension = extension\n                  \
    \                ^\n/tmp/tmpdc2q9gnv.swift:30:9: error: expected type name in\
    \ extension declaration\n        }\n        ^\n/tmp/tmpdc2q9gnv.swift:29:44: error:\
    \ expected '{' in extension\n            strongest_extension = extension\n   \
    \                                        ^\n/tmp/tmpdc2q9gnv.swift:29:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                              "
  stdout: ''
  timestamp: 1659820881
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfunc Strongest_Extension(class_name: String,\
    \ extensions: [String]) -> String {\n    var strongest_extension = \"\"\n    var\
    \ strongest_extension_strength = -1\n    for extension in extensions {\n     \
    \   let extension_strength = extension.countUpToLowercaseLetters()\n        if\
    \ extension_strength > strongest_extension_strength {\n            strongest_extension_strength\
    \ = extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp6jifw92_.swift:20:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmp6jifw92_.swift:20:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmp6jifw92_.swift:20:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmp6jifw92_.swift:21:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmp6jifw92_.swift:21:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        let extension_strength\
    \ = extension.countUpToLowercaseLetters()\n                                ^\n\
    \                                ;\n/tmp/tmp6jifw92_.swift:21:43: error: expected\
    \ type name in extension declaration\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmp6jifw92_.swift:21:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmp6jifw92_.swift:21:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmp6jifw92_.swift:24:35: error: expected\
    \ expression in assignment\n            strongest_extension = extension\n    \
    \                              ^\n/tmp/tmp6jifw92_.swift:25:9: error: expected\
    \ type name in extension declaration\n        }\n        ^\n/tmp/tmp6jifw92_.swift:24:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           ^\n/tmp/tmp6jifw92_.swift:24:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                                  ^\n"
  stdout: ''
  timestamp: 1659820881
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfunc Strongest_Extension(class_name: String,\
    \ extensions: [String]) -> String {\n    var strongest_extension = \"\"\n    var\
    \ strongest_extension_strength = -1\n    for extension in extensions {\n     \
    \   let extension_strength = extension.countUpToLowercaseLetters()\n        if\
    \ extension_strength > strongest_extension_strength {\n            strongest_extension_strength\
    \ = extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp6jifw92_.swift:20:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmp6jifw92_.swift:20:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmp6jifw92_.swift:20:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmp6jifw92_.swift:21:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmp6jifw92_.swift:21:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        let extension_strength\
    \ = extension.countUpToLowercaseLetters()\n                                ^\n\
    \                                ;\n/tmp/tmp6jifw92_.swift:21:43: error: expected\
    \ type name in extension declaration\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmp6jifw92_.swift:21:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmp6jifw92_.swift:21:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmp6jifw92_.swift:24:35: error: expected\
    \ expression in assignment\n            strongest_extension = extension\n    \
    \                              ^\n/tmp/tmp6jifw92_.swift:25:9: error: expected\
    \ type name in extension declaration\n        }\n        ^\n/tmp/tmp6jifw92_.swift:24:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           ^\n/tmp/tmp6jifw92_.swift:24:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                                  ^\n"
  stdout: ''
  timestamp: 1659820881
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfunc Strongest_Extension(class_name: String,\
    \ extensions: [String]) -> String {\n    var strongest_extension = \"\"\n    var\
    \ strongest_extension_strength = -1\n    for extension in extensions {\n     \
    \   let extension_strength = extension.countUpToLowercaseLetters()\n        if\
    \ extension_strength > strongest_extension_strength {\n            strongest_extension_strength\
    \ = extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp6jifw92_.swift:20:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmp6jifw92_.swift:20:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmp6jifw92_.swift:20:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmp6jifw92_.swift:21:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmp6jifw92_.swift:21:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        let extension_strength\
    \ = extension.countUpToLowercaseLetters()\n                                ^\n\
    \                                ;\n/tmp/tmp6jifw92_.swift:21:43: error: expected\
    \ type name in extension declaration\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmp6jifw92_.swift:21:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmp6jifw92_.swift:21:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmp6jifw92_.swift:24:35: error: expected\
    \ expression in assignment\n            strongest_extension = extension\n    \
    \                              ^\n/tmp/tmp6jifw92_.swift:25:9: error: expected\
    \ type name in extension declaration\n        }\n        ^\n/tmp/tmp6jifw92_.swift:24:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           ^\n/tmp/tmp6jifw92_.swift:24:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                                  ^\n"
  stdout: ''
  timestamp: 1659820881
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfunc Strongest_Extension(class_name: String,\
    \ extensions: [String]) -> String {\n    var strongest_extension = \"\"\n    var\
    \ strongest_extension_strength = -1\n    for extension in extensions {\n     \
    \   var extension_strength = extension.count\n        for letter in extension\
    \ {\n            if letter.isUppercase {\n                extension_strength -=\
    \ 1\n            }\n        }\n        if extension_strength > strongest_extension_strength\
    \ {\n            strongest_extension_strength = extension_strength\n         \
    \   strongest_extension = extension\n        }\n    }\n    return class_name +\
    \ \".\" + strongest_extension\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmphp4tno7j.swift:20:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmphp4tno7j.swift:20:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmphp4tno7j.swift:20:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmphp4tno7j.swift:21:34:\
    \ error: expected initial value after '='\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmphp4tno7j.swift:21:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        var extension_strength\
    \ = extension.count\n                                ^\n                     \
    \           ;\n/tmp/tmphp4tno7j.swift:21:43: error: expected type name in extension\
    \ declaration\n        var extension_strength = extension.count\n            \
    \                              ^\n/tmp/tmphp4tno7j.swift:21:43: error: expected\
    \ '{' in extension\n        var extension_strength = extension.count\n       \
    \                                   ^\n/tmp/tmphp4tno7j.swift:21:34: error: declaration\
    \ is only valid at file scope\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmphp4tno7j.swift:22:23: error: expected\
    \ Sequence expression for for-each loop\n        for letter in extension {\n \
    \                     ^\n/tmp/tmphp4tno7j.swift:22:23: error: expected '{' to\
    \ start the body of for-each loop\n        for letter in extension {\n       \
    \               ^\n/tmp/tmphp4tno7j.swift:29:35: error: expected expression in\
    \ assignment\n            strongest_extension = extension\n                  \
    \                ^\n/tmp/tmphp4tno7j.swift:30:9: error: expected type name in\
    \ extension declaration\n        }\n        ^\n/tmp/tmphp4tno7j.swift:29:44: error:\
    \ expected '{' in extension\n            strongest_extension = extension\n   \
    \                                        ^\n/tmp/tmphp4tno7j.swift:29:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                              "
  stdout: ''
  timestamp: 1659820882
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfunc Strongest_Extension(class_name: String,\
    \ extensions: [String]) -> String {\n    var strongest_extension = \"\"\n    var\
    \ strength = -1 // default value\n    for extension in extensions {\n        let\
    \ cap = extension.count\n        let sm = class_name.count\n        let strength\
    \ = cap - sm\n        if strength > strongest_extension.count {\n            strongest_extension\
    \ = extension\n        }\n    }\n    return class_name + \".\" + strongest_extension\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp5vx8nnxv.swift:20:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmp5vx8nnxv.swift:20:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmp5vx8nnxv.swift:20:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmp5vx8nnxv.swift:21:19:\
    \ error: expected initial value after '='\n        let cap = extension.count\n\
    \                  ^\n/tmp/tmp5vx8nnxv.swift:21:18: error: consecutive statements\
    \ on a line must be separated by ';'\n        let cap = extension.count\n    \
    \             ^\n                 ;\n/tmp/tmp5vx8nnxv.swift:21:28: error: expected\
    \ type name in extension declaration\n        let cap = extension.count\n    \
    \                       ^\n/tmp/tmp5vx8nnxv.swift:21:28: error: expected '{' in\
    \ extension\n        let cap = extension.count\n                           ^\n\
    /tmp/tmp5vx8nnxv.swift:21:19: error: declaration is only valid at file scope\n\
    \        let cap = extension.count\n                  ^\n/tmp/tmp5vx8nnxv.swift:25:35:\
    \ error: expected expression in assignment\n            strongest_extension =\
    \ extension\n                                  ^\n/tmp/tmp5vx8nnxv.swift:26:9:\
    \ error: expected type name in extension declaration\n        }\n        ^\n/tmp/tmp5vx8nnxv.swift:25:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           ^\n/tmp/tmp5vx8nnxv.swift:25:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                                  ^\n"
  stdout: ''
  timestamp: 1659820882
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfunc Strongest_Extension(class_name: String,\
    \ extensions: [String]) -> String {\n    var strongest_extension = \"\"\n    var\
    \ strongest_extension_strength = -1\n    for extension in extensions {\n     \
    \   let extension_strength = extension.countUpToLowercaseLetters()\n        if\
    \ extension_strength > strongest_extension_strength {\n            strongest_extension_strength\
    \ = extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp6jifw92_.swift:20:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmp6jifw92_.swift:20:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmp6jifw92_.swift:20:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmp6jifw92_.swift:21:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmp6jifw92_.swift:21:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        let extension_strength\
    \ = extension.countUpToLowercaseLetters()\n                                ^\n\
    \                                ;\n/tmp/tmp6jifw92_.swift:21:43: error: expected\
    \ type name in extension declaration\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmp6jifw92_.swift:21:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmp6jifw92_.swift:21:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmp6jifw92_.swift:24:35: error: expected\
    \ expression in assignment\n            strongest_extension = extension\n    \
    \                              ^\n/tmp/tmp6jifw92_.swift:25:9: error: expected\
    \ type name in extension declaration\n        }\n        ^\n/tmp/tmp6jifw92_.swift:24:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           ^\n/tmp/tmp6jifw92_.swift:24:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                                  ^\n"
  stdout: ''
  timestamp: 1659820881
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfunc Strongest_Extension(class_name: String,\
    \ extensions: [String]) -> String {\n    var strongest_extension = \"\"\n    var\
    \ strongest_extension_strength = -1\n    for extension in extensions {\n     \
    \   var extension_strength = extension.count\n        for letter in extension\
    \ {\n            if letter.isUppercase {\n                extension_strength -=\
    \ 1\n            }\n            if letter.isLowercase {\n                extension_strength\
    \ += 1\n            }\n        }\n        if extension_strength > strongest_extension_strength\
    \ {\n            strongest_extension = class_name\n            strongest_extension_strength\
    \ = extension_strength\n        }\n    }\n    return strongest_extension\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp3x68q8f6.swift:20:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmp3x68q8f6.swift:20:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmp3x68q8f6.swift:20:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmp3x68q8f6.swift:21:34:\
    \ error: expected initial value after '='\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmp3x68q8f6.swift:21:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        var extension_strength\
    \ = extension.count\n                                ^\n                     \
    \           ;\n/tmp/tmp3x68q8f6.swift:21:43: error: expected type name in extension\
    \ declaration\n        var extension_strength = extension.count\n            \
    \                              ^\n/tmp/tmp3x68q8f6.swift:21:43: error: expected\
    \ '{' in extension\n        var extension_strength = extension.count\n       \
    \                                   ^\n/tmp/tmp3x68q8f6.swift:21:34: error: declaration\
    \ is only valid at file scope\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmp3x68q8f6.swift:22:23: error: expected\
    \ Sequence expression for for-each loop\n        for letter in extension {\n \
    \                     ^\n/tmp/tmp3x68q8f6.swift:22:23: error: expected '{' to\
    \ start the body of for-each loop\n        for letter in extension {\n       \
    \               ^\n"
  stdout: ''
  timestamp: 1659820882
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfunc Strongest_Extension(class_name: String,\
    \ extensions: [String]) -> String {\n    var strongest_extension = \"\"\n    var\
    \ strongest_extension_strength = -1\n    for extension in extensions {\n     \
    \   let extension_strength = extension.characters.count - extension.lowercased().characters.count\n\
    \        if extension_strength > strongest_extension_strength {\n            strongest_extension_strength\
    \ = extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpf6wdvm6w.swift:20:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpf6wdvm6w.swift:20:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpf6wdvm6w.swift:20:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpf6wdvm6w.swift:21:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.characters.count\
    \ - extension.lowercased().characters.count\n                                \
    \ ^\n/tmp/tmpf6wdvm6w.swift:21:33: error: consecutive statements on a line must\
    \ be separated by ';'\n        let extension_strength = extension.characters.count\
    \ - extension.lowercased().characters.count\n                                ^\n\
    \                                ;\n/tmp/tmpf6wdvm6w.swift:21:43: error: expected\
    \ type name in extension declaration\n        let extension_strength = extension.characters.count\
    \ - extension.lowercased().characters.count\n                                \
    \          ^\n/tmp/tmpf6wdvm6w.swift:21:43: error: expected '{' in extension\n\
    \        let extension_strength = extension.characters.count - extension.lowercased().characters.count\n\
    \                                          ^\n/tmp/tmpf6wdvm6w.swift:21:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.characters.count\
    \ - extension.lowercased().characters.count\n                                \
    \ ^\n/tmp/tmpf6wdvm6w.swift:21:72: error: expected type name in extension declaration\n\
    \        let extension_strength = extension.characters.count - extension.lowercased().characters.count\n\
    \                                                                       ^\n/tmp/tmpf6wdvm6w.swift:21:72:\
    \ error: expected '{' in extension\n        let extension_strength = extension.characters.count\
    \ - extension.lowercased().characters.count\n                                \
    \                                       ^\n/tmp/tmpf6wdvm6w.swift:21:63: error:\
    \ declaration is only valid at file scope\n   "
  stdout: ''
  timestamp: 1659820882
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfunc Strongest_Extension(class_name: String,\
    \ extensions: [String]) -> String {\n    var strongest_extension = \"\"\n    var\
    \ max_strength = -1\n    for extension in extensions {\n        var extension_strength\
    \ = extension.count\n        for letter in extension {\n            if letter.isUpper()\
    \ {\n                extension_strength -= letter.isUpper()\n            }\n \
    \       }\n        if extension_strength > max_strength {\n            max_strength\
    \ = extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpn9du8lu4.swift:20:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpn9du8lu4.swift:20:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpn9du8lu4.swift:20:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpn9du8lu4.swift:21:34:\
    \ error: expected initial value after '='\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmpn9du8lu4.swift:21:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        var extension_strength\
    \ = extension.count\n                                ^\n                     \
    \           ;\n/tmp/tmpn9du8lu4.swift:21:43: error: expected type name in extension\
    \ declaration\n        var extension_strength = extension.count\n            \
    \                              ^\n/tmp/tmpn9du8lu4.swift:21:43: error: expected\
    \ '{' in extension\n        var extension_strength = extension.count\n       \
    \                                   ^\n/tmp/tmpn9du8lu4.swift:21:34: error: declaration\
    \ is only valid at file scope\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmpn9du8lu4.swift:22:23: error: expected\
    \ Sequence expression for for-each loop\n        for letter in extension {\n \
    \                     ^\n/tmp/tmpn9du8lu4.swift:22:23: error: expected '{' to\
    \ start the body of for-each loop\n        for letter in extension {\n       \
    \               ^\n/tmp/tmpn9du8lu4.swift:29:35: error: expected expression in\
    \ assignment\n            strongest_extension = extension\n                  \
    \                ^\n/tmp/tmpn9du8lu4.swift:30:9: error: expected type name in\
    \ extension declaration\n        }\n        ^\n/tmp/tmpn9du8lu4.swift:29:44: error:\
    \ expected '{' in extension\n            strongest_extension = extension\n   \
    \                                        ^\n/tmp/tmpn9du8lu4.swift:29:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                              "
  stdout: ''
  timestamp: 1659820882
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfunc Strongest_Extension(class_name: String,\
    \ extensions: [String]) -> String {\n    var strongest_extension = \"\"\n    var\
    \ strongest_extension_strength = -1\n    for extension in extensions {\n     \
    \   let extension_strength = extension.countUpToLowercaseLetters()\n        if\
    \ extension_strength > strongest_extension_strength {\n            strongest_extension_strength\
    \ = extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp6jifw92_.swift:20:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmp6jifw92_.swift:20:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmp6jifw92_.swift:20:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmp6jifw92_.swift:21:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmp6jifw92_.swift:21:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        let extension_strength\
    \ = extension.countUpToLowercaseLetters()\n                                ^\n\
    \                                ;\n/tmp/tmp6jifw92_.swift:21:43: error: expected\
    \ type name in extension declaration\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmp6jifw92_.swift:21:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmp6jifw92_.swift:21:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmp6jifw92_.swift:24:35: error: expected\
    \ expression in assignment\n            strongest_extension = extension\n    \
    \                              ^\n/tmp/tmp6jifw92_.swift:25:9: error: expected\
    \ type name in extension declaration\n        }\n        ^\n/tmp/tmp6jifw92_.swift:24:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           ^\n/tmp/tmp6jifw92_.swift:24:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                                  ^\n"
  stdout: ''
  timestamp: 1659820881
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfunc Strongest_Extension(class_name: String,\
    \ extensions: [String]) -> String {\n    var strongest_extension = \"\"\n    var\
    \ strongest_extension_strength = -1\n    for extension in extensions {\n     \
    \   let extension_strength = extension.countUpToUppercaseLetters() - extension.countUpToLowercaseLetters()\n\
    \        if extension_strength > strongest_extension_strength {\n            strongest_extension_strength\
    \ = extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpva48le5c.swift:20:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpva48le5c.swift:20:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpva48le5c.swift:20:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpva48le5c.swift:21:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUpToUppercaseLetters()\
    \ - extension.countUpToLowercaseLetters()\n                                 ^\n\
    /tmp/tmpva48le5c.swift:21:33: error: consecutive statements on a line must be\
    \ separated by ';'\n        let extension_strength = extension.countUpToUppercaseLetters()\
    \ - extension.countUpToLowercaseLetters()\n                                ^\n\
    \                                ;\n/tmp/tmpva48le5c.swift:21:43: error: expected\
    \ type name in extension declaration\n        let extension_strength = extension.countUpToUppercaseLetters()\
    \ - extension.countUpToLowercaseLetters()\n                                  \
    \        ^\n/tmp/tmpva48le5c.swift:21:43: error: expected '{' in extension\n \
    \       let extension_strength = extension.countUpToUppercaseLetters() - extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmpva48le5c.swift:21:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.countUpToUppercaseLetters()\
    \ - extension.countUpToLowercaseLetters()\n                                 ^\n\
    /tmp/tmpva48le5c.swift:21:83: error: expected type name in extension declaration\n\
    \        let extension_strength = extension.countUpToUppercaseLetters() - extension.countUpToLowercaseLetters()\n\
    \                                                                            \
    \      ^\n/tmp/tmpva48le5c.swift:21:83: error: expected '{' in extension\n   \
    \     let extension_strength = extension.countUpToUppercaseLetters() - extension.countUpToLowercaseLetters()\n\
    \                                                                            \
    \   "
  stdout: ''
  timestamp: 1659820882
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfunc Strongest_Extension(class_name: String,\
    \ extensions: [String]) -> String {\n    var strongest_extension = \"\"\n    var\
    \ max_strength = -1\n    for extension in extensions {\n        let class_name_extension\
    \ = class_name + extension\n        let class_name_extension_lowercase = class_name_extension.lowercased()\n\
    \        let class_name_extension_lowercase_index = class_name_extension.lowercased().characters.index(of:\
    \ class_name_extension_lowercase)\n        let class_name_extension_lowercase_index\
    \ = class_name_extension_lowercase_index! + class_name_extension.lowercased().characters.count\
    \ - class_name_extension_lowercase_index!\n        let class_name_extension_lowercase_index\
    \ = class_name_extension_lowercase_index! / 2\n        let class_name_extension_lowercase_index\
    \ = class_name_extension_lowercase_index! + class_name_extension.lowercased().characters.count\
    \ - class_name_extension_lowercase_index!\n        let class_name_extension_lowercase_index\
    \ = class_name_extension_lowercase_index! / 2\n        let class_name_extension_lowercase_index\
    \ = class_name_extension_lowercase_index! + class_name_extension.lowercased().characters.count\
    \ - class_name_extension_lowercase_index!\n        let class_name_extension_lowercase_index\
    \ = class_name_extension_lowercase_index! / 2\n        let class_name_extension_lowercase_index\
    \ = class_name_extension_lowercase_index! + class_name_extension.lowercased().characters.count\
    \ - class_name_extension_lowercase_index!\n        let class_name_extension_lowercase_index\
    \ = class_name_extension_lowercase_index! / 2\n        let class_name_extension_lowercase_index\
    \ = class_name_extension_lowercase_index! + class_name_extension.lowercased().characters.count\
    \ - class_name_extension_lowercase_index!\n        let class_name_extension_lowercase_index\
    \ = class_name_extension_lowercase_index! / 2\n        let class_name_extension_lowercase_index\
    \ = class_name_extension_lowercase_index! + class_name_extension.lowercased().characters.count\
    \ - class_name_extension_lowercase_index!\n        let class_name_extension_lowercase_index\
    \ = class_name_extension_lowercase_index! / 2\n        let class_name_extension_lowercase_index\
    \ = class_name_extension_lowercase_index! + class_name_extension.lowercased().characters.count\
    \ - class_name_extension_lowercase_index!\n        let class_name_extension_lowercase_index\
    \ = class_name_extension_lowercase_index! / 2\n        let class_name_extension_lowercase_index\
    \ = class_name_extension_lowercase_index! + class_name_extension.lowercased().characters.count\
    \ - class_name_extension_lowercase_index!\n        let class_name_extension_lowercase_index\
    \ = class_name_extension_lowercase_index! / 2\n        let class_name_extension_lowercase_index\
    \ = class_name_extension_lowercase_index! + class_name_extension.lowercased().characters.count\
    \ - class_name_extension_lowercase_index!\n        let class_name_extension_lowercase_index\
    \ = class_name_extension_lowercase_index\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(Strongest_Extension(class_name: \"Watashi\", extensions: [\"tEN\", \"niNE\"\
    , \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp54h88hj5.swift:20:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmp54h88hj5.swift:20:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmp54h88hj5.swift:20:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmp54h88hj5.swift:21:49:\
    \ error: expected expression after operator\n        let class_name_extension\
    \ = class_name + extension\n                                                ^\n\
    /tmp/tmp54h88hj5.swift:21:48: error: consecutive statements on a line must be\
    \ separated by ';'\n        let class_name_extension = class_name + extension\n\
    \                                               ^\n                          \
    \                     ;\n/tmp/tmp54h88hj5.swift:22:9: error: expected type name\
    \ in extension declaration\n        let class_name_extension_lowercase = class_name_extension.lowercased()\n\
    \        ^\n/tmp/tmp54h88hj5.swift:21:58: error: expected '{' in extension\n \
    \       let class_name_extension = class_name + extension\n                  \
    \                                       ^\n/tmp/tmp54h88hj5.swift:21:49: error:\
    \ declaration is only valid at file scope\n        let class_name_extension =\
    \ class_name + extension\n                                                ^\n\
    /tmp/tmp54h88hj5.swift:65:91: error: expected '}' at end of brace statement\n\
    assert(Strongest_Extension(class_name: \"Sp\", extensions: [\"671235\", \"Bb\"\
    ]) == \"Sp.671235\")\n                                                       \
    \                                   ^\n/tmp/tmp54h88hj5.swift:17:78: note: to\
    \ match this opening '{'\nfunc Strongest_Extension(class_name: String, extensions:\
    \ [String]) -> String {\n                                                    \
    \                         ^\n/tmp/tmp54h88hj5.swift:45:6: error: operator functions\
    \ can only be declared at global or in type scope\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1659820883
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfunc Strongest_Extension(class_name: String,\
    \ extensions: [String]) -> String {\n    var strongest_extension = \"\"\n    var\
    \ max_strength = -1\n    for extension in extensions {\n        let extension_strength\
    \ = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n  \
    \      if extension_strength > max_strength {\n            max_strength = extension_strength\n\
    \            strongest_extension = extension\n        }\n    }\n    return class_name\
    \ + \".\" + strongest_extension\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpgp9i3pnc.swift:20:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpgp9i3pnc.swift:20:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpgp9i3pnc.swift:20:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpgp9i3pnc.swift:21:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUppercaseLetters()\
    \ - extension.countLowercaseLetters()\n                                 ^\n/tmp/tmpgp9i3pnc.swift:21:33:\
    \ error: consecutive statements on a line must be separated by ';'\n        let\
    \ extension_strength = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n\
    \                                ^\n                                ;\n/tmp/tmpgp9i3pnc.swift:21:43:\
    \ error: expected type name in extension declaration\n        let extension_strength\
    \ = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n  \
    \                                        ^\n/tmp/tmpgp9i3pnc.swift:21:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.countUppercaseLetters()\
    \ - extension.countLowercaseLetters()\n                                      \
    \    ^\n/tmp/tmpgp9i3pnc.swift:21:34: error: declaration is only valid at file\
    \ scope\n        let extension_strength = extension.countUppercaseLetters() -\
    \ extension.countLowercaseLetters()\n                                 ^\n/tmp/tmpgp9i3pnc.swift:21:79:\
    \ error: expected type name in extension declaration\n        let extension_strength\
    \ = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n  \
    \                                                                            ^\n\
    /tmp/tmpgp9i3pnc.swift:21:79: error: expected '{' in extension\n        let extension_strength\
    \ = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n  \
    \                                                                            ^\n\
    /tmp/tmpgp9i3pnc.swift:21:70: error: declaration is only va"
  stdout: ''
  timestamp: 1659820881
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfunc Strongest_Extension(class_name: String,\
    \ extensions: [String]) -> String {\n    var strongest_extension = \"\"\n    var\
    \ strongest_extension_strength = -1\n    for extension in extensions {\n     \
    \   let extension_strength = extension.countUpToLowercaseLetters()\n        if\
    \ extension_strength > strongest_extension_strength {\n            strongest_extension_strength\
    \ = extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp6jifw92_.swift:20:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmp6jifw92_.swift:20:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmp6jifw92_.swift:20:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmp6jifw92_.swift:21:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmp6jifw92_.swift:21:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        let extension_strength\
    \ = extension.countUpToLowercaseLetters()\n                                ^\n\
    \                                ;\n/tmp/tmp6jifw92_.swift:21:43: error: expected\
    \ type name in extension declaration\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmp6jifw92_.swift:21:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmp6jifw92_.swift:21:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmp6jifw92_.swift:24:35: error: expected\
    \ expression in assignment\n            strongest_extension = extension\n    \
    \                              ^\n/tmp/tmp6jifw92_.swift:25:9: error: expected\
    \ type name in extension declaration\n        }\n        ^\n/tmp/tmp6jifw92_.swift:24:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           ^\n/tmp/tmp6jifw92_.swift:24:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                                  ^\n"
  stdout: ''
  timestamp: 1659820881
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfunc Strongest_Extension(class_name: String,\
    \ extensions: [String]) -> String {\n    var strongest_extension = \"\"\n    var\
    \ max_strength = -1\n    for extension in extensions {\n        let class_name_components\
    \ = class_name.components(separatedBy: \".\")\n        let extension_components\
    \ = extension.components(separatedBy: \".\")\n        let class_name = class_name_components[class_name_components.count\
    \ - 1]\n        let extension = extension_components[extension_components.count\
    \ - 1]\n        let strength = class_name.distance(to: extension)\n        if\
    \ strength > max_strength {\n            max_strength = strength\n           \
    \ strongest_extension = extension\n        }\n    }\n    return class_name + \"\
    .\" + strongest_extension\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpqpro7xu1.swift:20:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpqpro7xu1.swift:20:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpqpro7xu1.swift:20:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpqpro7xu1.swift:22:36:\
    \ error: expected initial value after '='\n        let extension_components =\
    \ extension.components(separatedBy: \".\")\n                                 \
    \  ^\n/tmp/tmpqpro7xu1.swift:22:35: error: consecutive statements on a line must\
    \ be separated by ';'\n        let extension_components = extension.components(separatedBy:\
    \ \".\")\n                                  ^\n                              \
    \    ;\n/tmp/tmpqpro7xu1.swift:22:45: error: expected type name in extension declaration\n\
    \        let extension_components = extension.components(separatedBy: \".\")\n\
    \                                            ^\n/tmp/tmpqpro7xu1.swift:22:45:\
    \ error: expected '{' in extension\n        let extension_components = extension.components(separatedBy:\
    \ \".\")\n                                            ^\n/tmp/tmpqpro7xu1.swift:22:36:\
    \ error: declaration is only valid at file scope\n        let extension_components\
    \ = extension.components(separatedBy: \".\")\n                               \
    \    ^\n/tmp/tmpqpro7xu1.swift:24:13: error: keyword 'extension' cannot be used\
    \ as an identifier here\n        let extension = extension_components[extension_components.count\
    \ - 1]\n            ^\n/tmp/tmpqpro7xu1.swift:24:13: note: if this name is unavoidable,\
    \ use backticks to escape it\n        let extension = extension_components[extension_components.count\
    \ - 1]\n            ^~~~~~~~~\n            `extension`\n/tmp/tmpqpro7xu1.swift:25:48:\
    \ error: expected expression in list of expressions\n        let strength = class_name.distance(to:\
    \ extension)\n                                               ^\n/tmp/tmpqpro7xu1.swift:25:47:\
    \ error: consecutive statements on a line must be separated by ';'\n        let\
    \ strength"
  stdout: ''
  timestamp: 1659820882
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfunc Strongest_Extension(class_name: String,\
    \ extensions: [String]) -> String {\n    var strongest_extension = \"\"\n    var\
    \ strongest_extension_strength = -1\n    for extension in extensions {\n     \
    \   var extension_strength = extension.count\n        for c in extension {\n \
    \           if c.isUppercase {\n                extension_strength -= 1\n    \
    \        }\n            if c.isLowercase {\n                extension_strength\
    \ += 1\n            }\n        }\n        if extension_strength > strongest_extension_strength\
    \ {\n            strongest_extension = extension\n            strongest_extension_strength\
    \ = extension_strength\n        }\n    }\n    return class_name + \".\" + strongest_extension\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpb7qk5n1d.swift:20:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpb7qk5n1d.swift:20:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpb7qk5n1d.swift:20:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpb7qk5n1d.swift:21:34:\
    \ error: expected initial value after '='\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmpb7qk5n1d.swift:21:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        var extension_strength\
    \ = extension.count\n                                ^\n                     \
    \           ;\n/tmp/tmpb7qk5n1d.swift:21:43: error: expected type name in extension\
    \ declaration\n        var extension_strength = extension.count\n            \
    \                              ^\n/tmp/tmpb7qk5n1d.swift:21:43: error: expected\
    \ '{' in extension\n        var extension_strength = extension.count\n       \
    \                                   ^\n/tmp/tmpb7qk5n1d.swift:21:34: error: declaration\
    \ is only valid at file scope\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmpb7qk5n1d.swift:22:18: error: expected\
    \ Sequence expression for for-each loop\n        for c in extension {\n      \
    \           ^\n/tmp/tmpb7qk5n1d.swift:22:18: error: expected '{' to start the\
    \ body of for-each loop\n        for c in extension {\n                 ^\n/tmp/tmpb7qk5n1d.swift:31:35:\
    \ error: expected expression in assignment\n            strongest_extension =\
    \ extension\n                                  ^\n/tmp/tmpb7qk5n1d.swift:32:42:\
    \ error: expected '{' in extension\n            strongest_extension_strength =\
    \ extension_strength\n                                         ^\n/tmp/tmpb7qk5n1d.swift:31:35:\
    \ error: declaration is only valid at file scope\n            strongest_extension\
    \ = extension\n                                  ^\n/tmp/tmpb7qk5n1d.swift:32:13:\
    \ error: cannot find type 'strongest_extension_strength' in scope\n    "
  stdout: ''
  timestamp: 1659820882
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfunc Strongest_Extension(class_name: String,\
    \ extensions: [String]) -> String {\n    var strongest_extension = \"\"\n    var\
    \ strongest_extension_strength = -1\n    for extension in extensions {\n     \
    \   let extension_strength = extension.countUpToUppercaseLetters - extension.countUpToLowercaseLetters\n\
    \        if extension_strength > strongest_extension_strength {\n            strongest_extension\
    \ = extension\n            strongest_extension_strength = extension_strength\n\
    \        }\n    }\n    return class_name + \".\" + strongest_extension\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmphsa33ar_.swift:20:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmphsa33ar_.swift:20:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmphsa33ar_.swift:20:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmphsa33ar_.swift:21:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUpToUppercaseLetters\
    \ - extension.countUpToLowercaseLetters\n                                 ^\n\
    /tmp/tmphsa33ar_.swift:21:33: error: consecutive statements on a line must be\
    \ separated by ';'\n        let extension_strength = extension.countUpToUppercaseLetters\
    \ - extension.countUpToLowercaseLetters\n                                ^\n \
    \                               ;\n/tmp/tmphsa33ar_.swift:21:43: error: expected\
    \ type name in extension declaration\n        let extension_strength = extension.countUpToUppercaseLetters\
    \ - extension.countUpToLowercaseLetters\n                                    \
    \      ^\n/tmp/tmphsa33ar_.swift:21:43: error: expected '{' in extension\n   \
    \     let extension_strength = extension.countUpToUppercaseLetters - extension.countUpToLowercaseLetters\n\
    \                                          ^\n/tmp/tmphsa33ar_.swift:21:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.countUpToUppercaseLetters\
    \ - extension.countUpToLowercaseLetters\n                                 ^\n\
    /tmp/tmphsa33ar_.swift:21:81: error: expected type name in extension declaration\n\
    \        let extension_strength = extension.countUpToUppercaseLetters - extension.countUpToLowercaseLetters\n\
    \                                                                            \
    \    ^\n/tmp/tmphsa33ar_.swift:21:81: error: expected '{' in extension\n     \
    \   let extension_strength = extension.countUpToUppercaseLetters - extension.countUpToLowercaseLetters\n\
    \                                                                            \
    \    ^\n/tmp/tmphsa33ar_.swift:21:7"
  stdout: ''
  timestamp: 1659820882
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfunc Strongest_Extension(class_name: String,\
    \ extensions: [String]) -> String {\n    var strongest_extension = \"\"\n    var\
    \ strongest_extension_strength = -1\n    for extension in extensions {\n     \
    \   let extension_strength = extension.characters.count\n        if extension_strength\
    \ > strongest_extension_strength {\n            strongest_extension_strength =\
    \ extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpg801yqsz.swift:20:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpg801yqsz.swift:20:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpg801yqsz.swift:20:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpg801yqsz.swift:21:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.characters.count\n\
    \                                 ^\n/tmp/tmpg801yqsz.swift:21:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        let extension_strength\
    \ = extension.characters.count\n                                ^\n          \
    \                      ;\n/tmp/tmpg801yqsz.swift:21:43: error: expected type name\
    \ in extension declaration\n        let extension_strength = extension.characters.count\n\
    \                                          ^\n/tmp/tmpg801yqsz.swift:21:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.characters.count\n\
    \                                          ^\n/tmp/tmpg801yqsz.swift:21:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.characters.count\n\
    \                                 ^\n/tmp/tmpg801yqsz.swift:24:35: error: expected\
    \ expression in assignment\n            strongest_extension = extension\n    \
    \                              ^\n/tmp/tmpg801yqsz.swift:25:9: error: expected\
    \ type name in extension declaration\n        }\n        ^\n/tmp/tmpg801yqsz.swift:24:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           ^\n/tmp/tmpg801yqsz.swift:24:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                                  ^\n"
  stdout: ''
  timestamp: 1659820881
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfunc Strongest_Extension(class_name: String,\
    \ extensions: [String]) -> String {\n    var strongest_extension = \"\"\n    var\
    \ strongest_extension_strength = -1\n    for extension in extensions {\n     \
    \   let class_name_components = class_name.components(separatedBy: \".\")\n  \
    \      let extension_components = extension.components(separatedBy: \".\")\n \
    \       let class_name_components_count = class_name_components.count\n      \
    \  let extension_components_count = extension_components.count\n        let class_name_components_count_upper\
    \ = class_name_components.filter({ $0.isUppercased() }).count\n        let extension_components_count_lower\
    \ = extension_components.filter({ $0.isLowercased() }).count\n        let class_name_components_count_upper_small\
    \ = class_name_components_count_upper - class_name_components_count_lower\n  \
    \      let extension_components_count_lower_small = extension_components_count_lower\
    \ - extension_components_count_upper\n        let extension_strength = class_name_components_count_upper_small\
    \ * extension_components_count_lower_small\n        if extension_strength > strongest_extension_strength\
    \ {\n            strongest_extension = extension\n            strongest_extension_strength\
    \ = extension_strength\n        }\n    }\n    return class_name + \".\" + strongest_extension\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpnluapf03.swift:20:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpnluapf03.swift:20:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpnluapf03.swift:20:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpnluapf03.swift:22:36:\
    \ error: expected initial value after '='\n        let extension_components =\
    \ extension.components(separatedBy: \".\")\n                                 \
    \  ^\n/tmp/tmpnluapf03.swift:22:35: error: consecutive statements on a line must\
    \ be separated by ';'\n        let extension_components = extension.components(separatedBy:\
    \ \".\")\n                                  ^\n                              \
    \    ;\n/tmp/tmpnluapf03.swift:22:45: error: expected type name in extension declaration\n\
    \        let extension_components = extension.components(separatedBy: \".\")\n\
    \                                            ^\n/tmp/tmpnluapf03.swift:22:45:\
    \ error: expected '{' in extension\n        let extension_components = extension.components(separatedBy:\
    \ \".\")\n                                            ^\n/tmp/tmpnluapf03.swift:22:36:\
    \ error: declaration is only valid at file scope\n        let extension_components\
    \ = extension.components(separatedBy: \".\")\n                               \
    \    ^\n/tmp/tmpnluapf03.swift:31:35: error: expected expression in assignment\n\
    \            strongest_extension = extension\n                               \
    \   ^\n/tmp/tmpnluapf03.swift:32:42: error: expected '{' in extension\n      \
    \      strongest_extension_strength = extension_strength\n                   \
    \                      ^\n/tmp/tmpnluapf03.swift:31:35: error: declaration is\
    \ only valid at file scope\n            strongest_extension = extension\n    \
    \                              ^\n/tmp/tmpnluapf03.swift:32:13: error: cannot\
    \ find type 'strongest_extension_strength' in scope\n            strongest_extension_strength\
    \ = extension_strength\n            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpnluapf03.swift:21:48:"
  stdout: ''
  timestamp: 1659820882
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfunc Strongest_Extension(class_name: String,\
    \ extensions: [String]) -> String {\n    var strongest_extension: String = \"\"\
    \n    var strongest_extension_strength: Int = 0\n    for extension in extensions\
    \ {\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \        if extension_strength > strongest_extension_strength {\n            strongest_extension_strength\
    \ = extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmprt3untt6.swift:20:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmprt3untt6.swift:20:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmprt3untt6.swift:20:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmprt3untt6.swift:21:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmprt3untt6.swift:21:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        let extension_strength\
    \ = extension.countUpToLowercaseLetters()\n                                ^\n\
    \                                ;\n/tmp/tmprt3untt6.swift:21:43: error: expected\
    \ type name in extension declaration\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmprt3untt6.swift:21:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmprt3untt6.swift:21:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmprt3untt6.swift:24:35: error: expected\
    \ expression in assignment\n            strongest_extension = extension\n    \
    \                              ^\n/tmp/tmprt3untt6.swift:25:9: error: expected\
    \ type name in extension declaration\n        }\n        ^\n/tmp/tmprt3untt6.swift:24:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           ^\n/tmp/tmprt3untt6.swift:24:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                                  ^\n"
  stdout: ''
  timestamp: 1659820882
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfunc Strongest_Extension(class_name: String,\
    \ extensions: [String]) -> String {\n    var strongest_extension = \"\"\n    var\
    \ max_strength = -1\n    for extension in extensions {\n        let extension_strength\
    \ = extension.countUpToUppercaseLetters - extension.countUpToLowercaseLetters\n\
    \        if extension_strength > max_strength {\n            max_strength = extension_strength\n\
    \            strongest_extension = extension\n        }\n    }\n    return class_name\
    \ + \".\" + strongest_extension\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpjgoko36m.swift:20:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpjgoko36m.swift:20:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpjgoko36m.swift:20:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpjgoko36m.swift:21:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUpToUppercaseLetters\
    \ - extension.countUpToLowercaseLetters\n                                 ^\n\
    /tmp/tmpjgoko36m.swift:21:33: error: consecutive statements on a line must be\
    \ separated by ';'\n        let extension_strength = extension.countUpToUppercaseLetters\
    \ - extension.countUpToLowercaseLetters\n                                ^\n \
    \                               ;\n/tmp/tmpjgoko36m.swift:21:43: error: expected\
    \ type name in extension declaration\n        let extension_strength = extension.countUpToUppercaseLetters\
    \ - extension.countUpToLowercaseLetters\n                                    \
    \      ^\n/tmp/tmpjgoko36m.swift:21:43: error: expected '{' in extension\n   \
    \     let extension_strength = extension.countUpToUppercaseLetters - extension.countUpToLowercaseLetters\n\
    \                                          ^\n/tmp/tmpjgoko36m.swift:21:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.countUpToUppercaseLetters\
    \ - extension.countUpToLowercaseLetters\n                                 ^\n\
    /tmp/tmpjgoko36m.swift:21:81: error: expected type name in extension declaration\n\
    \        let extension_strength = extension.countUpToUppercaseLetters - extension.countUpToLowercaseLetters\n\
    \                                                                            \
    \    ^\n/tmp/tmpjgoko36m.swift:21:81: error: expected '{' in extension\n     \
    \   let extension_strength = extension.countUpToUppercaseLetters - extension.countUpToLowercaseLetters\n\
    \                                                                            \
    \    ^\n/tmp/tmpjgoko36m.swift:21:7"
  stdout: ''
  timestamp: 1659820882
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfunc Strongest_Extension(class_name: String,\
    \ extensions: [String]) -> String {\n    var strongest_extension = \"\"\n    var\
    \ strongest_extension_strength = -1\n    for extension in extensions {\n     \
    \   let class_name_components = class_name.components(separatedBy: \".\")\n  \
    \      let extension_components = extension.components(separatedBy: \".\")\n \
    \       let class_name_components_count = class_name_components.count\n      \
    \  let extension_components_count = extension_components.count\n        let class_name_components_count_cap\
    \ = class_name_components.count - class_name_components_count\n        let extension_components_count_cap\
    \ = extension_components.count - extension_components_count\n        let class_name_components_count_sm\
    \ = class_name_components_count - class_name_components_count_cap\n        let\
    \ extension_components_count_sm = extension_components_count - extension_components_count_cap\n\
    \        let class_name_components_count_cap_sm = (class_name_components_count_cap\
    \ * class_name_components_count_sm) / class_name_components_count\n        let\
    \ extension_components_count_cap_sm = (extension_components_count_cap * extension_components_count_sm)\
    \ / extension_components_count\n        let class_name_components_count_cap_sm_max\
    \ = class_name_components_count_cap_sm > extension_components_count_cap_sm ? class_name_components_count_cap_sm\
    \ : extension_components_count_cap_sm\n        let extension_components_count_cap_sm_max\
    \ = extension_components_count_cap_sm > class_name_components_count_cap_sm ? extension_components_count_cap_sm\
    \ : class_name_components_count_cap_sm\n        let class_name_components_count_cap_sm_min\
    \ = class_name_components_count_cap_sm < extension_components_count_cap_sm ? class_name_components_count_cap_sm\
    \ : extension_components_count_cap_sm\n        let extension_components_count_cap_sm_min\
    \ = extension_components_count_cap_sm < class_name_components_count_cap_sm ? extension_components_count_cap_sm\
    \ : class_name_components_count_cap_sm\n        let class_name_components_count_cap_sm_max\
    \ = class_name_components_count_cap_sm > extension_components_count_cap_sm ? class_name_components_count_cap_sm\
    \ : extension_components_count_cap_sm\n        let extension_components_count_cap_sm_max\
    \ = extension_components_count_cap_sm > class_name_components_count_cap_sm ? extension_components_count_cap_sm\
    \ : class_name_components_count_cap_sm\n        let class_name_components_count_cap_sm_min\
    \ = class_name_components_count_cap_sm < extension_components_count_cap_sm ? class_name_components_count_\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp4vlktmlj.swift:20:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmp4vlktmlj.swift:20:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmp4vlktmlj.swift:20:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmp4vlktmlj.swift:22:36:\
    \ error: expected initial value after '='\n        let extension_components =\
    \ extension.components(separatedBy: \".\")\n                                 \
    \  ^\n/tmp/tmp4vlktmlj.swift:22:35: error: consecutive statements on a line must\
    \ be separated by ';'\n        let extension_components = extension.components(separatedBy:\
    \ \".\")\n                                  ^\n                              \
    \    ;\n/tmp/tmp4vlktmlj.swift:22:45: error: expected type name in extension declaration\n\
    \        let extension_components = extension.components(separatedBy: \".\")\n\
    \                                            ^\n/tmp/tmp4vlktmlj.swift:22:45:\
    \ error: expected '{' in extension\n        let extension_components = extension.components(separatedBy:\
    \ \".\")\n                                            ^\n/tmp/tmp4vlktmlj.swift:22:36:\
    \ error: declaration is only valid at file scope\n        let extension_components\
    \ = extension.components(separatedBy: \".\")\n                               \
    \    ^\n/tmp/tmp4vlktmlj.swift:37:125: error: expected ':' after '? ...' in ternary\
    \ expression\n        let class_name_components_count_cap_sm_min = class_name_components_count_cap_sm\
    \ < extension_components_count_cap_sm ? class_name_components_count_\n       \
    \                                                                            \
    \                                         ^\n/tmp/tmp4vlktmlj.swift:61:91: error:\
    \ expected '}' at end of brace statement\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")\n              \
    \                                                                            ^\n\
    /tmp/tmp4vlktmlj.swift:17:78: note: to match this opening '{'\nfunc Stronges"
  stdout: ''
  timestamp: 1659820882
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfunc Strongest_Extension(class_name: String,\
    \ extensions: [String]) -> String {\n    var strongest_extension = \"\"\n    var\
    \ max_strength = -1\n    for extension in extensions {\n        let extension_strength\
    \ = extension.countUpToUppercaseLetters - extension.countUpToLowercaseLetters\n\
    \        if extension_strength > max_strength {\n            max_strength = extension_strength\n\
    \            strongest_extension = extension\n        }\n    }\n    return class_name\
    \ + \".\" + strongest_extension\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpjgoko36m.swift:20:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpjgoko36m.swift:20:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpjgoko36m.swift:20:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpjgoko36m.swift:21:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUpToUppercaseLetters\
    \ - extension.countUpToLowercaseLetters\n                                 ^\n\
    /tmp/tmpjgoko36m.swift:21:33: error: consecutive statements on a line must be\
    \ separated by ';'\n        let extension_strength = extension.countUpToUppercaseLetters\
    \ - extension.countUpToLowercaseLetters\n                                ^\n \
    \                               ;\n/tmp/tmpjgoko36m.swift:21:43: error: expected\
    \ type name in extension declaration\n        let extension_strength = extension.countUpToUppercaseLetters\
    \ - extension.countUpToLowercaseLetters\n                                    \
    \      ^\n/tmp/tmpjgoko36m.swift:21:43: error: expected '{' in extension\n   \
    \     let extension_strength = extension.countUpToUppercaseLetters - extension.countUpToLowercaseLetters\n\
    \                                          ^\n/tmp/tmpjgoko36m.swift:21:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.countUpToUppercaseLetters\
    \ - extension.countUpToLowercaseLetters\n                                 ^\n\
    /tmp/tmpjgoko36m.swift:21:81: error: expected type name in extension declaration\n\
    \        let extension_strength = extension.countUpToUppercaseLetters - extension.countUpToLowercaseLetters\n\
    \                                                                            \
    \    ^\n/tmp/tmpjgoko36m.swift:21:81: error: expected '{' in extension\n     \
    \   let extension_strength = extension.countUpToUppercaseLetters - extension.countUpToLowercaseLetters\n\
    \                                                                            \
    \    ^\n/tmp/tmpjgoko36m.swift:21:7"
  stdout: ''
  timestamp: 1659820882
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfunc Strongest_Extension(class_name: String,\
    \ extensions: [String]) -> String {\n    var strongest_extension = \"\"\n    var\
    \ strongest_extension_strength = -1\n    for extension in extensions {\n     \
    \   let extension_strength = extension.countUpToUppercaseLetters - extension.countUpToLowercaseLetters\n\
    \        if extension_strength > strongest_extension_strength {\n            strongest_extension\
    \ = extension\n            strongest_extension_strength = extension_strength\n\
    \        }\n    }\n    return class_name + \".\" + strongest_extension\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmphsa33ar_.swift:20:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmphsa33ar_.swift:20:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmphsa33ar_.swift:20:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmphsa33ar_.swift:21:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUpToUppercaseLetters\
    \ - extension.countUpToLowercaseLetters\n                                 ^\n\
    /tmp/tmphsa33ar_.swift:21:33: error: consecutive statements on a line must be\
    \ separated by ';'\n        let extension_strength = extension.countUpToUppercaseLetters\
    \ - extension.countUpToLowercaseLetters\n                                ^\n \
    \                               ;\n/tmp/tmphsa33ar_.swift:21:43: error: expected\
    \ type name in extension declaration\n        let extension_strength = extension.countUpToUppercaseLetters\
    \ - extension.countUpToLowercaseLetters\n                                    \
    \      ^\n/tmp/tmphsa33ar_.swift:21:43: error: expected '{' in extension\n   \
    \     let extension_strength = extension.countUpToUppercaseLetters - extension.countUpToLowercaseLetters\n\
    \                                          ^\n/tmp/tmphsa33ar_.swift:21:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.countUpToUppercaseLetters\
    \ - extension.countUpToLowercaseLetters\n                                 ^\n\
    /tmp/tmphsa33ar_.swift:21:81: error: expected type name in extension declaration\n\
    \        let extension_strength = extension.countUpToUppercaseLetters - extension.countUpToLowercaseLetters\n\
    \                                                                            \
    \    ^\n/tmp/tmphsa33ar_.swift:21:81: error: expected '{' in extension\n     \
    \   let extension_strength = extension.countUpToUppercaseLetters - extension.countUpToLowercaseLetters\n\
    \                                                                            \
    \    ^\n/tmp/tmphsa33ar_.swift:21:7"
  stdout: ''
  timestamp: 1659820882
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfunc Strongest_Extension(class_name: String,\
    \ extensions: [String]) -> String {\n    var strongest_extension = \"\"\n    var\
    \ strongest_extension_strength = -1\n    for extension in extensions {\n     \
    \   var extension_strength = extension.count\n        for character in extension\
    \ {\n            if character == character.lowercased() {\n                extension_strength\
    \ -= 1\n            }\n        }\n        if extension_strength > strongest_extension_strength\
    \ {\n            strongest_extension_strength = extension_strength\n         \
    \   strongest_extension = extension\n        }\n    }\n    return class_name +\
    \ \".\" + strongest_extension\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpyqk7216q.swift:20:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpyqk7216q.swift:20:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpyqk7216q.swift:20:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpyqk7216q.swift:21:34:\
    \ error: expected initial value after '='\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmpyqk7216q.swift:21:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        var extension_strength\
    \ = extension.count\n                                ^\n                     \
    \           ;\n/tmp/tmpyqk7216q.swift:21:43: error: expected type name in extension\
    \ declaration\n        var extension_strength = extension.count\n            \
    \                              ^\n/tmp/tmpyqk7216q.swift:21:43: error: expected\
    \ '{' in extension\n        var extension_strength = extension.count\n       \
    \                                   ^\n/tmp/tmpyqk7216q.swift:21:34: error: declaration\
    \ is only valid at file scope\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmpyqk7216q.swift:22:26: error: expected\
    \ Sequence expression for for-each loop\n        for character in extension {\n\
    \                         ^\n/tmp/tmpyqk7216q.swift:22:26: error: expected '{'\
    \ to start the body of for-each loop\n        for character in extension {\n \
    \                        ^\n/tmp/tmpyqk7216q.swift:29:35: error: expected expression\
    \ in assignment\n            strongest_extension = extension\n               \
    \                   ^\n/tmp/tmpyqk7216q.swift:30:9: error: expected type name\
    \ in extension declaration\n        }\n        ^\n/tmp/tmpyqk7216q.swift:29:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           ^\n/tmp/tmpyqk7216q.swift:29:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                  "
  stdout: ''
  timestamp: 1659820881
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfunc Strongest_Extension(class_name: String,\
    \ extensions: [String]) -> String {\n    var strongest_extension = \"\"\n    var\
    \ strongest_extension_strength = -1\n    for extension in extensions {\n     \
    \   var extension_strength = extension.count\n        for letter in extension\
    \ {\n            if letter.isUpper() {\n                extension_strength -=\
    \ 1\n            }\n        }\n        if extension_strength > strongest_extension_strength\
    \ {\n            strongest_extension = class_name\n            strongest_extension_strength\
    \ = extension_strength\n        }\n    }\n    return strongest_extension\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpc77nuunh.swift:20:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpc77nuunh.swift:20:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpc77nuunh.swift:20:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpc77nuunh.swift:21:34:\
    \ error: expected initial value after '='\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmpc77nuunh.swift:21:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        var extension_strength\
    \ = extension.count\n                                ^\n                     \
    \           ;\n/tmp/tmpc77nuunh.swift:21:43: error: expected type name in extension\
    \ declaration\n        var extension_strength = extension.count\n            \
    \                              ^\n/tmp/tmpc77nuunh.swift:21:43: error: expected\
    \ '{' in extension\n        var extension_strength = extension.count\n       \
    \                                   ^\n/tmp/tmpc77nuunh.swift:21:34: error: declaration\
    \ is only valid at file scope\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmpc77nuunh.swift:22:23: error: expected\
    \ Sequence expression for for-each loop\n        for letter in extension {\n \
    \                     ^\n/tmp/tmpc77nuunh.swift:22:23: error: expected '{' to\
    \ start the body of for-each loop\n        for letter in extension {\n       \
    \               ^\n"
  stdout: ''
  timestamp: 1659820882
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfunc Strongest_Extension(class_name: String,\
    \ extensions: [String]) -> String {\n    var strongest_extension = \"\"\n    var\
    \ strength = -1 // default strength to -1\n    for extension in extensions {\n\
    \        let cap = extension.count\n        let sm = class_name.count\n      \
    \  let strength = cap - sm\n        if strength > strongest_extension.count {\n\
    \            strongest_extension = extension\n        }\n    }\n    return class_name\
    \ + \".\" + strongest_extension\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp_wfjrqyw.swift:20:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmp_wfjrqyw.swift:20:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmp_wfjrqyw.swift:20:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmp_wfjrqyw.swift:21:19:\
    \ error: expected initial value after '='\n        let cap = extension.count\n\
    \                  ^\n/tmp/tmp_wfjrqyw.swift:21:18: error: consecutive statements\
    \ on a line must be separated by ';'\n        let cap = extension.count\n    \
    \             ^\n                 ;\n/tmp/tmp_wfjrqyw.swift:21:28: error: expected\
    \ type name in extension declaration\n        let cap = extension.count\n    \
    \                       ^\n/tmp/tmp_wfjrqyw.swift:21:28: error: expected '{' in\
    \ extension\n        let cap = extension.count\n                           ^\n\
    /tmp/tmp_wfjrqyw.swift:21:19: error: declaration is only valid at file scope\n\
    \        let cap = extension.count\n                  ^\n/tmp/tmp_wfjrqyw.swift:25:35:\
    \ error: expected expression in assignment\n            strongest_extension =\
    \ extension\n                                  ^\n/tmp/tmp_wfjrqyw.swift:26:9:\
    \ error: expected type name in extension declaration\n        }\n        ^\n/tmp/tmp_wfjrqyw.swift:25:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           ^\n/tmp/tmp_wfjrqyw.swift:25:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                                  ^\n"
  stdout: ''
  timestamp: 1659820882
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfunc Strongest_Extension(class_name: String,\
    \ extensions: [String]) -> String {\n    var strongest_extension = \"\"\n    var\
    \ strongest_extension_strength = -1\n    for extension in extensions {\n     \
    \   let extension_strength = extension.countUpToUppercaseLetters - extension.countUpToLowercaseLetters\n\
    \        if extension_strength > strongest_extension_strength {\n            strongest_extension_strength\
    \ = extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpxhz_h2fn.swift:20:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpxhz_h2fn.swift:20:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpxhz_h2fn.swift:20:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpxhz_h2fn.swift:21:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUpToUppercaseLetters\
    \ - extension.countUpToLowercaseLetters\n                                 ^\n\
    /tmp/tmpxhz_h2fn.swift:21:33: error: consecutive statements on a line must be\
    \ separated by ';'\n        let extension_strength = extension.countUpToUppercaseLetters\
    \ - extension.countUpToLowercaseLetters\n                                ^\n \
    \                               ;\n/tmp/tmpxhz_h2fn.swift:21:43: error: expected\
    \ type name in extension declaration\n        let extension_strength = extension.countUpToUppercaseLetters\
    \ - extension.countUpToLowercaseLetters\n                                    \
    \      ^\n/tmp/tmpxhz_h2fn.swift:21:43: error: expected '{' in extension\n   \
    \     let extension_strength = extension.countUpToUppercaseLetters - extension.countUpToLowercaseLetters\n\
    \                                          ^\n/tmp/tmpxhz_h2fn.swift:21:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.countUpToUppercaseLetters\
    \ - extension.countUpToLowercaseLetters\n                                 ^\n\
    /tmp/tmpxhz_h2fn.swift:21:81: error: expected type name in extension declaration\n\
    \        let extension_strength = extension.countUpToUppercaseLetters - extension.countUpToLowercaseLetters\n\
    \                                                                            \
    \    ^\n/tmp/tmpxhz_h2fn.swift:21:81: error: expected '{' in extension\n     \
    \   let extension_strength = extension.countUpToUppercaseLetters - extension.countUpToLowercaseLetters\n\
    \                                                                            \
    \    ^\n/tmp/tmpxhz_h2fn.swift:21:7"
  stdout: ''
  timestamp: 1659820881
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfunc Strongest_Extension(class_name: String,\
    \ extensions: [String]) -> String {\n    var strongest_extension = \"\"\n    var\
    \ strongest_extension_strength = -1\n    for extension in extensions {\n     \
    \   let extension_strength = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n\
    \        if extension_strength > strongest_extension_strength {\n            strongest_extension_strength\
    \ = extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpmx22zuzy.swift:20:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpmx22zuzy.swift:20:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpmx22zuzy.swift:20:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpmx22zuzy.swift:21:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUppercaseLetters()\
    \ - extension.countLowercaseLetters()\n                                 ^\n/tmp/tmpmx22zuzy.swift:21:33:\
    \ error: consecutive statements on a line must be separated by ';'\n        let\
    \ extension_strength = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n\
    \                                ^\n                                ;\n/tmp/tmpmx22zuzy.swift:21:43:\
    \ error: expected type name in extension declaration\n        let extension_strength\
    \ = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n  \
    \                                        ^\n/tmp/tmpmx22zuzy.swift:21:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.countUppercaseLetters()\
    \ - extension.countLowercaseLetters()\n                                      \
    \    ^\n/tmp/tmpmx22zuzy.swift:21:34: error: declaration is only valid at file\
    \ scope\n        let extension_strength = extension.countUppercaseLetters() -\
    \ extension.countLowercaseLetters()\n                                 ^\n/tmp/tmpmx22zuzy.swift:21:79:\
    \ error: expected type name in extension declaration\n        let extension_strength\
    \ = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n  \
    \                                                                            ^\n\
    /tmp/tmpmx22zuzy.swift:21:79: error: expected '{' in extension\n        let extension_strength\
    \ = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n  \
    \                                                                            ^\n\
    /tmp/tmpmx22zuzy.swift:21:70: error: declaration is only va"
  stdout: ''
  timestamp: 1659820882
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfunc Strongest_Extension(class_name: String,\
    \ extensions: [String]) -> String {\n    var strongest_extension = \"\"\n    var\
    \ strongest_extension_strength = -1\n    for extension in extensions {\n     \
    \   let extension_strength = extension.countUpToLowercaseLetters()\n        if\
    \ extension_strength > strongest_extension_strength {\n            strongest_extension_strength\
    \ = extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp6jifw92_.swift:20:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmp6jifw92_.swift:20:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmp6jifw92_.swift:20:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmp6jifw92_.swift:21:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmp6jifw92_.swift:21:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        let extension_strength\
    \ = extension.countUpToLowercaseLetters()\n                                ^\n\
    \                                ;\n/tmp/tmp6jifw92_.swift:21:43: error: expected\
    \ type name in extension declaration\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmp6jifw92_.swift:21:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmp6jifw92_.swift:21:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmp6jifw92_.swift:24:35: error: expected\
    \ expression in assignment\n            strongest_extension = extension\n    \
    \                              ^\n/tmp/tmp6jifw92_.swift:25:9: error: expected\
    \ type name in extension declaration\n        }\n        ^\n/tmp/tmp6jifw92_.swift:24:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           ^\n/tmp/tmp6jifw92_.swift:24:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                                  ^\n"
  stdout: ''
  timestamp: 1659820881
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfunc Strongest_Extension(class_name: String,\
    \ extensions: [String]) -> String {\n    var strongest_extension = \"\"\n    var\
    \ max_strength = -1\n    for extension in extensions {\n        let extension_strength\
    \ = extension.countUpToUppercaseLetters() - extension.countUpToLowercaseLetters()\n\
    \        if extension_strength > max_strength {\n            max_strength = extension_strength\n\
    \            strongest_extension = extension\n        }\n    }\n    return class_name\
    \ + \".\" + strongest_extension\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpagjjf8k9.swift:20:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpagjjf8k9.swift:20:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpagjjf8k9.swift:20:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpagjjf8k9.swift:21:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUpToUppercaseLetters()\
    \ - extension.countUpToLowercaseLetters()\n                                 ^\n\
    /tmp/tmpagjjf8k9.swift:21:33: error: consecutive statements on a line must be\
    \ separated by ';'\n        let extension_strength = extension.countUpToUppercaseLetters()\
    \ - extension.countUpToLowercaseLetters()\n                                ^\n\
    \                                ;\n/tmp/tmpagjjf8k9.swift:21:43: error: expected\
    \ type name in extension declaration\n        let extension_strength = extension.countUpToUppercaseLetters()\
    \ - extension.countUpToLowercaseLetters()\n                                  \
    \        ^\n/tmp/tmpagjjf8k9.swift:21:43: error: expected '{' in extension\n \
    \       let extension_strength = extension.countUpToUppercaseLetters() - extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmpagjjf8k9.swift:21:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.countUpToUppercaseLetters()\
    \ - extension.countUpToLowercaseLetters()\n                                 ^\n\
    /tmp/tmpagjjf8k9.swift:21:83: error: expected type name in extension declaration\n\
    \        let extension_strength = extension.countUpToUppercaseLetters() - extension.countUpToLowercaseLetters()\n\
    \                                                                            \
    \      ^\n/tmp/tmpagjjf8k9.swift:21:83: error: expected '{' in extension\n   \
    \     let extension_strength = extension.countUpToUppercaseLetters() - extension.countUpToLowercaseLetters()\n\
    \                                                                            \
    \   "
  stdout: ''
  timestamp: 1659820882
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfunc Strongest_Extension(class_name: String,\
    \ extensions: [String]) -> String {\n    var strongest_extension = \"\"\n    var\
    \ strongest_extension_strength = -1\n    for extension in extensions {\n     \
    \   let extension_strength = extension.characters.count\n        if extension_strength\
    \ > strongest_extension_strength {\n            strongest_extension_strength =\
    \ extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpg801yqsz.swift:20:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpg801yqsz.swift:20:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpg801yqsz.swift:20:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpg801yqsz.swift:21:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.characters.count\n\
    \                                 ^\n/tmp/tmpg801yqsz.swift:21:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        let extension_strength\
    \ = extension.characters.count\n                                ^\n          \
    \                      ;\n/tmp/tmpg801yqsz.swift:21:43: error: expected type name\
    \ in extension declaration\n        let extension_strength = extension.characters.count\n\
    \                                          ^\n/tmp/tmpg801yqsz.swift:21:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.characters.count\n\
    \                                          ^\n/tmp/tmpg801yqsz.swift:21:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.characters.count\n\
    \                                 ^\n/tmp/tmpg801yqsz.swift:24:35: error: expected\
    \ expression in assignment\n            strongest_extension = extension\n    \
    \                              ^\n/tmp/tmpg801yqsz.swift:25:9: error: expected\
    \ type name in extension declaration\n        }\n        ^\n/tmp/tmpg801yqsz.swift:24:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           ^\n/tmp/tmpg801yqsz.swift:24:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                                  ^\n"
  stdout: ''
  timestamp: 1659820881
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfunc Strongest_Extension(class_name: String,\
    \ extensions: [String]) -> String {\n    var strongest_extension = \"\"\n    var\
    \ strongest_extension_strength = -1\n    for extension in extensions {\n     \
    \   var extension_strength = extension.count\n        for character in extension\
    \ {\n            if character == character.lowercased() {\n                extension_strength\
    \ -= 1\n            }\n        }\n        if extension_strength > strongest_extension_strength\
    \ {\n            strongest_extension_strength = extension_strength\n         \
    \   strongest_extension = extension\n        }\n    }\n    return class_name +\
    \ \".\" + strongest_extension\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpyqk7216q.swift:20:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpyqk7216q.swift:20:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpyqk7216q.swift:20:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpyqk7216q.swift:21:34:\
    \ error: expected initial value after '='\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmpyqk7216q.swift:21:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        var extension_strength\
    \ = extension.count\n                                ^\n                     \
    \           ;\n/tmp/tmpyqk7216q.swift:21:43: error: expected type name in extension\
    \ declaration\n        var extension_strength = extension.count\n            \
    \                              ^\n/tmp/tmpyqk7216q.swift:21:43: error: expected\
    \ '{' in extension\n        var extension_strength = extension.count\n       \
    \                                   ^\n/tmp/tmpyqk7216q.swift:21:34: error: declaration\
    \ is only valid at file scope\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmpyqk7216q.swift:22:26: error: expected\
    \ Sequence expression for for-each loop\n        for character in extension {\n\
    \                         ^\n/tmp/tmpyqk7216q.swift:22:26: error: expected '{'\
    \ to start the body of for-each loop\n        for character in extension {\n \
    \                        ^\n/tmp/tmpyqk7216q.swift:29:35: error: expected expression\
    \ in assignment\n            strongest_extension = extension\n               \
    \                   ^\n/tmp/tmpyqk7216q.swift:30:9: error: expected type name\
    \ in extension declaration\n        }\n        ^\n/tmp/tmpyqk7216q.swift:29:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           ^\n/tmp/tmpyqk7216q.swift:29:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                  "
  stdout: ''
  timestamp: 1659820881
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfunc Strongest_Extension(class_name: String,\
    \ extensions: [String]) -> String {\n    var strongest_extension = \"\"\n    var\
    \ strength = -1\n    for extension in extensions {\n        let class_name_components\
    \ = class_name.components(separatedBy: \".\")\n        let extension_components\
    \ = extension.components(separatedBy: \".\")\n        let class_name_length =\
    \ class_name_components.count\n        let extension_length = extension_components.count\n\
    \        let class_name_components_count = class_name_components.count\n     \
    \   let extension_components_count = extension_components.count\n        let class_name_components_count_cap\
    \ = class_name_components_count.map { $0.capitalized }\n        let extension_components_count_cap\
    \ = extension_components_count.map { $0.capitalized }\n        let class_name_components_count_sm\
    \ = class_name_components_count.map { $0.lowercased() }\n        let extension_components_count_sm\
    \ = extension_components_count.map { $0.lowercased() }\n        let class_name_components_count_cap_min\
    \ = class_name_components_count_cap.min()\n        let extension_components_count_cap_min\
    \ = extension_components_count_cap.min()\n        let class_name_components_count_sm_min\
    \ = class_name_components_count_sm.min()\n        let extension_components_count_sm_min\
    \ = extension_components_count_sm.min()\n        let class_name_components_count_cap_max\
    \ = class_name_components_count_cap.max()\n        let extension_components_count_cap_max\
    \ = extension_components_count_cap.max()\n        let class_name_components_count_sm_max\
    \ = class_name_components_count_sm.max()\n        let extension_components_count_sm_max\
    \ = extension_components_count_sm.max()\n        let class_name_components_count_cap_sum\
    \ = class_name_components_count_cap.sum()\n        let extension_components_count_cap_sum\
    \ = extension_components_count_cap.sum()\n        let class_name_components_count_sm_sum\
    \ = class_name_components_count_sm.sum()\n        let extension_components_count_sm_sum\
    \ = extension_components_count_sm.sum()\n        let class_name_components_count_cap_product\
    \ = class_name_components_count_cap.product()\n        let extension_components_count_cap_product\
    \ = extension_components_count_cap.product()\n        let class_name_components_count_sm_product\
    \ = class_name_components_count_sm.product()\n        let extension_components_count_sm_product\
    \ = extension_components_count_sm.product()\n        let class_name_components_count_cap_product_min\
    \ = class_name_components_count_cap_product.min()\n        let extension_components_count_cap_product_min\
    \ = extension_components_count_cap_product.min()\n        let class_name_components_count_sm_product_min\
    \ = class_name_components_count_sm_product.min()\n        let extension_\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmplevcghh8.swift:20:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmplevcghh8.swift:20:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmplevcghh8.swift:20:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmplevcghh8.swift:22:36:\
    \ error: expected initial value after '='\n        let extension_components =\
    \ extension.components(separatedBy: \".\")\n                                 \
    \  ^\n/tmp/tmplevcghh8.swift:22:35: error: consecutive statements on a line must\
    \ be separated by ';'\n        let extension_components = extension.components(separatedBy:\
    \ \".\")\n                                  ^\n                              \
    \    ;\n/tmp/tmplevcghh8.swift:22:45: error: expected type name in extension declaration\n\
    \        let extension_components = extension.components(separatedBy: \".\")\n\
    \                                            ^\n/tmp/tmplevcghh8.swift:22:45:\
    \ error: expected '{' in extension\n        let extension_components = extension.components(separatedBy:\
    \ \".\")\n                                            ^\n/tmp/tmplevcghh8.swift:22:36:\
    \ error: declaration is only valid at file scope\n        let extension_components\
    \ = extension.components(separatedBy: \".\")\n                               \
    \    ^\n/tmp/tmplevcghh8.swift:74:91: error: expected '}' at end of brace statement\n\
    assert(Strongest_Extension(class_name: \"Sp\", extensions: [\"671235\", \"Bb\"\
    ]) == \"Sp.671235\")\n                                                       \
    \                                   ^\n/tmp/tmplevcghh8.swift:17:78: note: to\
    \ match this opening '{'\nfunc Strongest_Extension(class_name: String, extensions:\
    \ [String]) -> String {\n                                                    \
    \                         ^\n/tmp/tmplevcghh8.swift:54:6: error: operator functions\
    \ can only be declared at global or in type scope\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n     ^\n/tmp/tmplevcghh8.swift:21:48: error:\
    \ value of type 'St"
  stdout: ''
  timestamp: 1659820882
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfunc Strongest_Extension(class_name: String,\
    \ extensions: [String]) -> String {\n    var strongest_extension = \"\"\n    var\
    \ strongest_extension_strength = -1\n    for extension in extensions {\n     \
    \   var extension_strength = extension.count\n        for c in extension {\n \
    \           if c >= 'A' && c <= 'Z' {\n                extension_strength = extension_strength\
    \ * 26 + c - 'A'\n            }\n        }\n        if extension_strength > strongest_extension_strength\
    \ {\n            strongest_extension_strength = extension_strength\n         \
    \   strongest_extension = extension\n        }\n    }\n    return class_name +\
    \ \".\" + strongest_extension\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpmwpwt25f.swift:20:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpmwpwt25f.swift:20:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpmwpwt25f.swift:20:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpmwpwt25f.swift:21:34:\
    \ error: expected initial value after '='\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmpmwpwt25f.swift:21:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        var extension_strength\
    \ = extension.count\n                                ^\n                     \
    \           ;\n/tmp/tmpmwpwt25f.swift:21:43: error: expected type name in extension\
    \ declaration\n        var extension_strength = extension.count\n            \
    \                              ^\n/tmp/tmpmwpwt25f.swift:21:43: error: expected\
    \ '{' in extension\n        var extension_strength = extension.count\n       \
    \                                   ^\n/tmp/tmpmwpwt25f.swift:21:34: error: declaration\
    \ is only valid at file scope\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmpmwpwt25f.swift:22:18: error: expected\
    \ Sequence expression for for-each loop\n        for c in extension {\n      \
    \           ^\n/tmp/tmpmwpwt25f.swift:22:18: error: expected '{' to start the\
    \ body of for-each loop\n        for c in extension {\n                 ^\n/tmp/tmpmwpwt25f.swift:23:21:\
    \ error: single-quoted string literal found, use '\"'\n            if c >= 'A'\
    \ && c <= 'Z' {\n                    ^~~\n                    \"A\"\n/tmp/tmpmwpwt25f.swift:23:33:\
    \ error: single-quoted string literal found, use '\"'\n            if c >= 'A'\
    \ && c <= 'Z' {\n                                ^~~\n                       \
    \         \"Z\"\n/tmp/tmpmwpwt25f.swift:24:68: error: single-quoted string literal\
    \ found, use '\"'\n                extension_strength = extension_strength * 26\
    \ + c - 'A'\n                                                                "
  stdout: ''
  timestamp: 1659820882
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfunc Strongest_Extension(class_name: String,\
    \ extensions: [String]) -> String {\n    var strongest_extension = \"\"\n    var\
    \ strongest_extension_strength = -1\n    for extension in extensions {\n     \
    \   let extension_strength = extension.countUpToLowercaseLetters()\n        if\
    \ extension_strength > strongest_extension_strength {\n            strongest_extension_strength\
    \ = extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp6jifw92_.swift:20:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmp6jifw92_.swift:20:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmp6jifw92_.swift:20:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmp6jifw92_.swift:21:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmp6jifw92_.swift:21:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        let extension_strength\
    \ = extension.countUpToLowercaseLetters()\n                                ^\n\
    \                                ;\n/tmp/tmp6jifw92_.swift:21:43: error: expected\
    \ type name in extension declaration\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmp6jifw92_.swift:21:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmp6jifw92_.swift:21:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmp6jifw92_.swift:24:35: error: expected\
    \ expression in assignment\n            strongest_extension = extension\n    \
    \                              ^\n/tmp/tmp6jifw92_.swift:25:9: error: expected\
    \ type name in extension declaration\n        }\n        ^\n/tmp/tmp6jifw92_.swift:24:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           ^\n/tmp/tmp6jifw92_.swift:24:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                                  ^\n"
  stdout: ''
  timestamp: 1659820881
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfunc Strongest_Extension(class_name: String,\
    \ extensions: [String]) -> String {\n    var strongest_extension = \"\"\n    var\
    \ strongest_extension_strength = -1\n    for extension in extensions {\n     \
    \   var extension_strength = extension.count\n        for letter in extension\
    \ {\n            if letter.isUpper() {\n                extension_strength -=\
    \ 1\n            }\n        }\n        if extension_strength > strongest_extension_strength\
    \ {\n            strongest_extension_strength = extension_strength\n         \
    \   strongest_extension = extension\n        }\n    }\n    return class_name +\
    \ \".\" + strongest_extension\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpdc2q9gnv.swift:20:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpdc2q9gnv.swift:20:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpdc2q9gnv.swift:20:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpdc2q9gnv.swift:21:34:\
    \ error: expected initial value after '='\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmpdc2q9gnv.swift:21:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        var extension_strength\
    \ = extension.count\n                                ^\n                     \
    \           ;\n/tmp/tmpdc2q9gnv.swift:21:43: error: expected type name in extension\
    \ declaration\n        var extension_strength = extension.count\n            \
    \                              ^\n/tmp/tmpdc2q9gnv.swift:21:43: error: expected\
    \ '{' in extension\n        var extension_strength = extension.count\n       \
    \                                   ^\n/tmp/tmpdc2q9gnv.swift:21:34: error: declaration\
    \ is only valid at file scope\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmpdc2q9gnv.swift:22:23: error: expected\
    \ Sequence expression for for-each loop\n        for letter in extension {\n \
    \                     ^\n/tmp/tmpdc2q9gnv.swift:22:23: error: expected '{' to\
    \ start the body of for-each loop\n        for letter in extension {\n       \
    \               ^\n/tmp/tmpdc2q9gnv.swift:29:35: error: expected expression in\
    \ assignment\n            strongest_extension = extension\n                  \
    \                ^\n/tmp/tmpdc2q9gnv.swift:30:9: error: expected type name in\
    \ extension declaration\n        }\n        ^\n/tmp/tmpdc2q9gnv.swift:29:44: error:\
    \ expected '{' in extension\n            strongest_extension = extension\n   \
    \                                        ^\n/tmp/tmpdc2q9gnv.swift:29:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                              "
  stdout: ''
  timestamp: 1659820881
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfunc Strongest_Extension(class_name: String,\
    \ extensions: [String]) -> String {\n    var strongest_extension = \"\"\n    var\
    \ strongest_extension_strength = -1\n    for extension in extensions {\n     \
    \   let extension_strength = extension.characters.count\n        if extension_strength\
    \ > strongest_extension_strength {\n            strongest_extension_strength =\
    \ extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpg801yqsz.swift:20:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpg801yqsz.swift:20:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpg801yqsz.swift:20:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpg801yqsz.swift:21:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.characters.count\n\
    \                                 ^\n/tmp/tmpg801yqsz.swift:21:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        let extension_strength\
    \ = extension.characters.count\n                                ^\n          \
    \                      ;\n/tmp/tmpg801yqsz.swift:21:43: error: expected type name\
    \ in extension declaration\n        let extension_strength = extension.characters.count\n\
    \                                          ^\n/tmp/tmpg801yqsz.swift:21:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.characters.count\n\
    \                                          ^\n/tmp/tmpg801yqsz.swift:21:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.characters.count\n\
    \                                 ^\n/tmp/tmpg801yqsz.swift:24:35: error: expected\
    \ expression in assignment\n            strongest_extension = extension\n    \
    \                              ^\n/tmp/tmpg801yqsz.swift:25:9: error: expected\
    \ type name in extension declaration\n        }\n        ^\n/tmp/tmpg801yqsz.swift:24:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           ^\n/tmp/tmpg801yqsz.swift:24:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                                  ^\n"
  stdout: ''
  timestamp: 1659820881
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfunc Strongest_Extension(class_name: String,\
    \ extensions: [String]) -> String {\n    var strongest_extension = \"\"\n    var\
    \ strongest_extension_strength = -1\n    for extension in extensions {\n     \
    \   let extension_strength = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n\
    \        if extension_strength > strongest_extension_strength {\n            strongest_extension_strength\
    \ = extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpmx22zuzy.swift:20:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpmx22zuzy.swift:20:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpmx22zuzy.swift:20:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpmx22zuzy.swift:21:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUppercaseLetters()\
    \ - extension.countLowercaseLetters()\n                                 ^\n/tmp/tmpmx22zuzy.swift:21:33:\
    \ error: consecutive statements on a line must be separated by ';'\n        let\
    \ extension_strength = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n\
    \                                ^\n                                ;\n/tmp/tmpmx22zuzy.swift:21:43:\
    \ error: expected type name in extension declaration\n        let extension_strength\
    \ = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n  \
    \                                        ^\n/tmp/tmpmx22zuzy.swift:21:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.countUppercaseLetters()\
    \ - extension.countLowercaseLetters()\n                                      \
    \    ^\n/tmp/tmpmx22zuzy.swift:21:34: error: declaration is only valid at file\
    \ scope\n        let extension_strength = extension.countUppercaseLetters() -\
    \ extension.countLowercaseLetters()\n                                 ^\n/tmp/tmpmx22zuzy.swift:21:79:\
    \ error: expected type name in extension declaration\n        let extension_strength\
    \ = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n  \
    \                                                                            ^\n\
    /tmp/tmpmx22zuzy.swift:21:79: error: expected '{' in extension\n        let extension_strength\
    \ = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n  \
    \                                                                            ^\n\
    /tmp/tmpmx22zuzy.swift:21:70: error: declaration is only va"
  stdout: ''
  timestamp: 1659820882
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfunc Strongest_Extension(class_name: String,\
    \ extensions: [String]) -> String {\n    var strongest_extension = \"\"\n    var\
    \ strongest_extension_strength = -1\n    for extension in extensions {\n     \
    \   var extension_strength = count_capital_letters(extension) - count_capital_letters(extension.lowercaseString)\n\
    \        if extension_strength > strongest_extension_strength {\n            strongest_extension_strength\
    \ = extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp2hy52o8j.swift:20:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmp2hy52o8j.swift:20:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmp2hy52o8j.swift:20:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmp2hy52o8j.swift:21:56:\
    \ error: expected expression in list of expressions\n        var extension_strength\
    \ = count_capital_letters(extension) - count_capital_letters(extension.lowercaseString)\n\
    \                                                       ^\n/tmp/tmp2hy52o8j.swift:21:56:\
    \ error: consecutive statements on a line must be separated by ';'\n        var\
    \ extension_strength = count_capital_letters(extension) - count_capital_letters(extension.lowercaseString)\n\
    \                                                       ^\n                  \
    \                                     ;\n/tmp/tmp2hy52o8j.swift:21:65: error:\
    \ expected type name in extension declaration\n        var extension_strength\
    \ = count_capital_letters(extension) - count_capital_letters(extension.lowercaseString)\n\
    \                                                                ^\n         \
    \                                                        <#type#>\n/tmp/tmp2hy52o8j.swift:21:65:\
    \ error: expected '{' in extension\n        var extension_strength = count_capital_letters(extension)\
    \ - count_capital_letters(extension.lowercaseString)\n                       \
    \                                         ^\n/tmp/tmp2hy52o8j.swift:21:56: error:\
    \ declaration is only valid at file scope\n        var extension_strength = count_capital_letters(extension)\
    \ - count_capital_letters(extension.lowercaseString)\n                       \
    \                                ^\n/tmp/tmp2hy52o8j.swift:24:35: error: expected\
    \ expression in assignment\n            strongest_extension = extension\n    \
    \                              ^\n/tmp/tmp2hy52o8j.swift:25:9: error: expected\
    \ type name in extension declaration\n        }\n        ^\n/tmp/tmp2hy52o8j.swift:24:44: "
  stdout: ''
  timestamp: 1659820881
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfunc Strongest_Extension(class_name: String,\
    \ extensions: [String]) -> String {\n    var strongest_extension = \"\"\n    var\
    \ strongest_extension_strength = -1\n    for extension in extensions {\n     \
    \   let extension_strength = extension.countUpToLowercaseLetters()\n        if\
    \ extension_strength > strongest_extension_strength {\n            strongest_extension_strength\
    \ = extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp6jifw92_.swift:20:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmp6jifw92_.swift:20:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmp6jifw92_.swift:20:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmp6jifw92_.swift:21:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmp6jifw92_.swift:21:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        let extension_strength\
    \ = extension.countUpToLowercaseLetters()\n                                ^\n\
    \                                ;\n/tmp/tmp6jifw92_.swift:21:43: error: expected\
    \ type name in extension declaration\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmp6jifw92_.swift:21:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmp6jifw92_.swift:21:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmp6jifw92_.swift:24:35: error: expected\
    \ expression in assignment\n            strongest_extension = extension\n    \
    \                              ^\n/tmp/tmp6jifw92_.swift:25:9: error: expected\
    \ type name in extension declaration\n        }\n        ^\n/tmp/tmp6jifw92_.swift:24:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           ^\n/tmp/tmp6jifw92_.swift:24:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                                  ^\n"
  stdout: ''
  timestamp: 1659820881
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfunc Strongest_Extension(class_name: String,\
    \ extensions: [String]) -> String {\n    var strongest_extension = \"\"\n    var\
    \ strongest_extension_strength = -1\n    for extension in extensions {\n     \
    \   var extension_strength = extension.count\n        for letter in extension\
    \ {\n            if letter.isUpper() {\n                extension_strength -=\
    \ 1\n            }\n        }\n        if extension_strength > strongest_extension_strength\
    \ {\n            strongest_extension_strength = extension_strength\n         \
    \   strongest_extension = extension\n        }\n    }\n    return class_name +\
    \ \".\" + strongest_extension\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpdc2q9gnv.swift:20:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpdc2q9gnv.swift:20:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpdc2q9gnv.swift:20:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpdc2q9gnv.swift:21:34:\
    \ error: expected initial value after '='\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmpdc2q9gnv.swift:21:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        var extension_strength\
    \ = extension.count\n                                ^\n                     \
    \           ;\n/tmp/tmpdc2q9gnv.swift:21:43: error: expected type name in extension\
    \ declaration\n        var extension_strength = extension.count\n            \
    \                              ^\n/tmp/tmpdc2q9gnv.swift:21:43: error: expected\
    \ '{' in extension\n        var extension_strength = extension.count\n       \
    \                                   ^\n/tmp/tmpdc2q9gnv.swift:21:34: error: declaration\
    \ is only valid at file scope\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmpdc2q9gnv.swift:22:23: error: expected\
    \ Sequence expression for for-each loop\n        for letter in extension {\n \
    \                     ^\n/tmp/tmpdc2q9gnv.swift:22:23: error: expected '{' to\
    \ start the body of for-each loop\n        for letter in extension {\n       \
    \               ^\n/tmp/tmpdc2q9gnv.swift:29:35: error: expected expression in\
    \ assignment\n            strongest_extension = extension\n                  \
    \                ^\n/tmp/tmpdc2q9gnv.swift:30:9: error: expected type name in\
    \ extension declaration\n        }\n        ^\n/tmp/tmpdc2q9gnv.swift:29:44: error:\
    \ expected '{' in extension\n            strongest_extension = extension\n   \
    \                                        ^\n/tmp/tmpdc2q9gnv.swift:29:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                              "
  stdout: ''
  timestamp: 1659820881
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfunc Strongest_Extension(class_name: String,\
    \ extensions: [String]) -> String {\n    var strongest_extension = \"\"\n    var\
    \ strongest_extension_strength = -1\n    for extension in extensions {\n     \
    \   var extension_strength = extension.count\n        for letter in extension\
    \ {\n            if letter.isUpper() {\n                extension_strength -=\
    \ 1\n            }\n        }\n        if extension_strength > strongest_extension_strength\
    \ {\n            strongest_extension_strength = extension_strength\n         \
    \   strongest_extension = extension\n        }\n    }\n    return class_name +\
    \ \".\" + strongest_extension\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpdc2q9gnv.swift:20:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpdc2q9gnv.swift:20:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpdc2q9gnv.swift:20:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpdc2q9gnv.swift:21:34:\
    \ error: expected initial value after '='\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmpdc2q9gnv.swift:21:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        var extension_strength\
    \ = extension.count\n                                ^\n                     \
    \           ;\n/tmp/tmpdc2q9gnv.swift:21:43: error: expected type name in extension\
    \ declaration\n        var extension_strength = extension.count\n            \
    \                              ^\n/tmp/tmpdc2q9gnv.swift:21:43: error: expected\
    \ '{' in extension\n        var extension_strength = extension.count\n       \
    \                                   ^\n/tmp/tmpdc2q9gnv.swift:21:34: error: declaration\
    \ is only valid at file scope\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmpdc2q9gnv.swift:22:23: error: expected\
    \ Sequence expression for for-each loop\n        for letter in extension {\n \
    \                     ^\n/tmp/tmpdc2q9gnv.swift:22:23: error: expected '{' to\
    \ start the body of for-each loop\n        for letter in extension {\n       \
    \               ^\n/tmp/tmpdc2q9gnv.swift:29:35: error: expected expression in\
    \ assignment\n            strongest_extension = extension\n                  \
    \                ^\n/tmp/tmpdc2q9gnv.swift:30:9: error: expected type name in\
    \ extension declaration\n        }\n        ^\n/tmp/tmpdc2q9gnv.swift:29:44: error:\
    \ expected '{' in extension\n            strongest_extension = extension\n   \
    \                                        ^\n/tmp/tmpdc2q9gnv.swift:29:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                              "
  stdout: ''
  timestamp: 1659820881
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfunc Strongest_Extension(class_name: String,\
    \ extensions: [String]) -> String {\n    var strongest_extension = \"\"\n    var\
    \ strongest_extension_strength = -1\n    for extension in extensions {\n     \
    \   let extension_strength = extension.countUpToLowercaseLetters()\n        if\
    \ extension_strength > strongest_extension_strength {\n            strongest_extension_strength\
    \ = extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp6jifw92_.swift:20:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmp6jifw92_.swift:20:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmp6jifw92_.swift:20:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmp6jifw92_.swift:21:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmp6jifw92_.swift:21:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        let extension_strength\
    \ = extension.countUpToLowercaseLetters()\n                                ^\n\
    \                                ;\n/tmp/tmp6jifw92_.swift:21:43: error: expected\
    \ type name in extension declaration\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmp6jifw92_.swift:21:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmp6jifw92_.swift:21:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmp6jifw92_.swift:24:35: error: expected\
    \ expression in assignment\n            strongest_extension = extension\n    \
    \                              ^\n/tmp/tmp6jifw92_.swift:25:9: error: expected\
    \ type name in extension declaration\n        }\n        ^\n/tmp/tmp6jifw92_.swift:24:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           ^\n/tmp/tmp6jifw92_.swift:24:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                                  ^\n"
  stdout: ''
  timestamp: 1659820881
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfunc Strongest_Extension(class_name: String,\
    \ extensions: [String]) -> String {\n    var strongest_extension: String = \"\"\
    \n    var strongest_extension_strength: Int = -1\n    for extension in extensions\
    \ {\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \        if extension_strength > strongest_extension_strength {\n            strongest_extension\
    \ = class_name\n            strongest_extension_strength = extension_strength\n\
    \        }\n    }\n    return strongest_extension\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpjqoo4jng.swift:20:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpjqoo4jng.swift:20:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpjqoo4jng.swift:20:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpjqoo4jng.swift:21:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmpjqoo4jng.swift:21:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        let extension_strength\
    \ = extension.countUpToLowercaseLetters()\n                                ^\n\
    \                                ;\n/tmp/tmpjqoo4jng.swift:21:43: error: expected\
    \ type name in extension declaration\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmpjqoo4jng.swift:21:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmpjqoo4jng.swift:21:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n"
  stdout: ''
  timestamp: 1659820882
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfunc Strongest_Extension(class_name: String,\
    \ extensions: [String]) -> String {\n    var strongest_extension = \"\"\n    var\
    \ strongest_extension_strength = -1\n    for extension in extensions {\n     \
    \   let extension_strength = extension.countUpToLowercaseLetters()\n        if\
    \ extension_strength > strongest_extension_strength {\n            strongest_extension_strength\
    \ = extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp6jifw92_.swift:20:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmp6jifw92_.swift:20:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmp6jifw92_.swift:20:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmp6jifw92_.swift:21:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmp6jifw92_.swift:21:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        let extension_strength\
    \ = extension.countUpToLowercaseLetters()\n                                ^\n\
    \                                ;\n/tmp/tmp6jifw92_.swift:21:43: error: expected\
    \ type name in extension declaration\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmp6jifw92_.swift:21:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmp6jifw92_.swift:21:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmp6jifw92_.swift:24:35: error: expected\
    \ expression in assignment\n            strongest_extension = extension\n    \
    \                              ^\n/tmp/tmp6jifw92_.swift:25:9: error: expected\
    \ type name in extension declaration\n        }\n        ^\n/tmp/tmp6jifw92_.swift:24:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           ^\n/tmp/tmp6jifw92_.swift:24:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                                  ^\n"
  stdout: ''
  timestamp: 1659820881
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfunc Strongest_Extension(class_name: String,\
    \ extensions: [String]) -> String {\n    var strongest_extension = \"\"\n    var\
    \ strongest_extension_strength = -1\n    for extension in extensions {\n     \
    \   var extension_strength = extension.count\n        for c in extension {\n \
    \           if c.isUppercase {\n                extension_strength -= 1\n    \
    \        }\n            if c.isLowercase {\n                extension_strength\
    \ += 1\n            }\n        }\n        if extension_strength > strongest_extension_strength\
    \ {\n            strongest_extension_strength = extension_strength\n         \
    \   strongest_extension = extension\n        }\n    }\n    return class_name +\
    \ \".\" + strongest_extension\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp49pjzhs9.swift:20:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmp49pjzhs9.swift:20:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmp49pjzhs9.swift:20:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmp49pjzhs9.swift:21:34:\
    \ error: expected initial value after '='\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmp49pjzhs9.swift:21:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        var extension_strength\
    \ = extension.count\n                                ^\n                     \
    \           ;\n/tmp/tmp49pjzhs9.swift:21:43: error: expected type name in extension\
    \ declaration\n        var extension_strength = extension.count\n            \
    \                              ^\n/tmp/tmp49pjzhs9.swift:21:43: error: expected\
    \ '{' in extension\n        var extension_strength = extension.count\n       \
    \                                   ^\n/tmp/tmp49pjzhs9.swift:21:34: error: declaration\
    \ is only valid at file scope\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmp49pjzhs9.swift:22:18: error: expected\
    \ Sequence expression for for-each loop\n        for c in extension {\n      \
    \           ^\n/tmp/tmp49pjzhs9.swift:22:18: error: expected '{' to start the\
    \ body of for-each loop\n        for c in extension {\n                 ^\n/tmp/tmp49pjzhs9.swift:32:35:\
    \ error: expected expression in assignment\n            strongest_extension =\
    \ extension\n                                  ^\n/tmp/tmp49pjzhs9.swift:33:9:\
    \ error: expected type name in extension declaration\n        }\n        ^\n/tmp/tmp49pjzhs9.swift:32:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           ^\n/tmp/tmp49pjzhs9.swift:32:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                                  ^\n"
  stdout: ''
  timestamp: 1659820882
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfunc Strongest_Extension(class_name: String,\
    \ extensions: [String]) -> String {\n    var strongest_extension = \"\"\n    var\
    \ strongest_extension_strength = -1\n    for extension in extensions {\n     \
    \   var extension_strength = extension.count\n        for char in extension {\n\
    \            if char.uppercased() != char {\n                extension_strength\
    \ -= 1\n            }\n        }\n        if extension_strength > strongest_extension_strength\
    \ {\n            strongest_extension_strength = extension_strength\n         \
    \   strongest_extension = extension\n        }\n    }\n    return class_name +\
    \ \".\" + strongest_extension\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp5m29v439.swift:20:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmp5m29v439.swift:20:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmp5m29v439.swift:20:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmp5m29v439.swift:21:34:\
    \ error: expected initial value after '='\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmp5m29v439.swift:21:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        var extension_strength\
    \ = extension.count\n                                ^\n                     \
    \           ;\n/tmp/tmp5m29v439.swift:21:43: error: expected type name in extension\
    \ declaration\n        var extension_strength = extension.count\n            \
    \                              ^\n/tmp/tmp5m29v439.swift:21:43: error: expected\
    \ '{' in extension\n        var extension_strength = extension.count\n       \
    \                                   ^\n/tmp/tmp5m29v439.swift:21:34: error: declaration\
    \ is only valid at file scope\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmp5m29v439.swift:22:21: error: expected\
    \ Sequence expression for for-each loop\n        for char in extension {\n   \
    \                 ^\n/tmp/tmp5m29v439.swift:22:21: error: expected '{' to start\
    \ the body of for-each loop\n        for char in extension {\n               \
    \     ^\n/tmp/tmp5m29v439.swift:29:35: error: expected expression in assignment\n\
    \            strongest_extension = extension\n                               \
    \   ^\n/tmp/tmp5m29v439.swift:30:9: error: expected type name in extension declaration\n\
    \        }\n        ^\n/tmp/tmp5m29v439.swift:29:44: error: expected '{' in extension\n\
    \            strongest_extension = extension\n                               \
    \            ^\n/tmp/tmp5m29v439.swift:29:35: error: declaration is only valid\
    \ at file scope\n            strongest_extension = extension\n               \
    \                   ^\n"
  stdout: ''
  timestamp: 1659820882
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfunc Strongest_Extension(class_name: String,\
    \ extensions: [String]) -> String {\n    var strongest_extension = \"\"\n    var\
    \ strongest_extension_strength = -1\n    for extension in extensions {\n     \
    \   let extension_strength = extension.countUpToUppercaseLetters - extension.countUpToLowercaseLetters\n\
    \        if extension_strength > strongest_extension_strength {\n            strongest_extension\
    \ = extension\n            strongest_extension_strength = extension_strength\n\
    \        }\n    }\n    return class_name + \".\" + strongest_extension\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmphsa33ar_.swift:20:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmphsa33ar_.swift:20:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmphsa33ar_.swift:20:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmphsa33ar_.swift:21:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUpToUppercaseLetters\
    \ - extension.countUpToLowercaseLetters\n                                 ^\n\
    /tmp/tmphsa33ar_.swift:21:33: error: consecutive statements on a line must be\
    \ separated by ';'\n        let extension_strength = extension.countUpToUppercaseLetters\
    \ - extension.countUpToLowercaseLetters\n                                ^\n \
    \                               ;\n/tmp/tmphsa33ar_.swift:21:43: error: expected\
    \ type name in extension declaration\n        let extension_strength = extension.countUpToUppercaseLetters\
    \ - extension.countUpToLowercaseLetters\n                                    \
    \      ^\n/tmp/tmphsa33ar_.swift:21:43: error: expected '{' in extension\n   \
    \     let extension_strength = extension.countUpToUppercaseLetters - extension.countUpToLowercaseLetters\n\
    \                                          ^\n/tmp/tmphsa33ar_.swift:21:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.countUpToUppercaseLetters\
    \ - extension.countUpToLowercaseLetters\n                                 ^\n\
    /tmp/tmphsa33ar_.swift:21:81: error: expected type name in extension declaration\n\
    \        let extension_strength = extension.countUpToUppercaseLetters - extension.countUpToLowercaseLetters\n\
    \                                                                            \
    \    ^\n/tmp/tmphsa33ar_.swift:21:81: error: expected '{' in extension\n     \
    \   let extension_strength = extension.countUpToUppercaseLetters - extension.countUpToLowercaseLetters\n\
    \                                                                            \
    \    ^\n/tmp/tmphsa33ar_.swift:21:7"
  stdout: ''
  timestamp: 1659820882
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfunc Strongest_Extension(class_name: String,\
    \ extensions: [String]) -> String {\n    var strongest_extension = \"\"\n    var\
    \ strongest_extension_strength = -1\n    for extension in extensions {\n     \
    \   var extension_strength = extension.count\n        for character in extension\
    \ {\n            if character == character.lowercased() {\n                extension_strength\
    \ -= 1\n            }\n        }\n        if extension_strength > strongest_extension_strength\
    \ {\n            strongest_extension_strength = extension_strength\n         \
    \   strongest_extension = extension\n        }\n    }\n    return class_name +\
    \ \".\" + strongest_extension\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpyqk7216q.swift:20:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpyqk7216q.swift:20:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpyqk7216q.swift:20:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpyqk7216q.swift:21:34:\
    \ error: expected initial value after '='\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmpyqk7216q.swift:21:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        var extension_strength\
    \ = extension.count\n                                ^\n                     \
    \           ;\n/tmp/tmpyqk7216q.swift:21:43: error: expected type name in extension\
    \ declaration\n        var extension_strength = extension.count\n            \
    \                              ^\n/tmp/tmpyqk7216q.swift:21:43: error: expected\
    \ '{' in extension\n        var extension_strength = extension.count\n       \
    \                                   ^\n/tmp/tmpyqk7216q.swift:21:34: error: declaration\
    \ is only valid at file scope\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmpyqk7216q.swift:22:26: error: expected\
    \ Sequence expression for for-each loop\n        for character in extension {\n\
    \                         ^\n/tmp/tmpyqk7216q.swift:22:26: error: expected '{'\
    \ to start the body of for-each loop\n        for character in extension {\n \
    \                        ^\n/tmp/tmpyqk7216q.swift:29:35: error: expected expression\
    \ in assignment\n            strongest_extension = extension\n               \
    \                   ^\n/tmp/tmpyqk7216q.swift:30:9: error: expected type name\
    \ in extension declaration\n        }\n        ^\n/tmp/tmpyqk7216q.swift:29:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           ^\n/tmp/tmpyqk7216q.swift:29:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                  "
  stdout: ''
  timestamp: 1659820881
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfunc Strongest_Extension(class_name: String,\
    \ extensions: [String]) -> String {\n    var strongest_extension = \"\"\n    var\
    \ strongest_extension_strength = -1\n    for extension in extensions {\n     \
    \   var extension_strength = extension.count\n        for letter in extension\
    \ {\n            if letter.isUpper() {\n                extension_strength -=\
    \ 1\n            }\n        }\n        if extension_strength > strongest_extension_strength\
    \ {\n            strongest_extension_strength = extension_strength\n         \
    \   strongest_extension = extension\n        }\n    }\n    return class_name +\
    \ \".\" + strongest_extension\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpdc2q9gnv.swift:20:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpdc2q9gnv.swift:20:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpdc2q9gnv.swift:20:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpdc2q9gnv.swift:21:34:\
    \ error: expected initial value after '='\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmpdc2q9gnv.swift:21:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        var extension_strength\
    \ = extension.count\n                                ^\n                     \
    \           ;\n/tmp/tmpdc2q9gnv.swift:21:43: error: expected type name in extension\
    \ declaration\n        var extension_strength = extension.count\n            \
    \                              ^\n/tmp/tmpdc2q9gnv.swift:21:43: error: expected\
    \ '{' in extension\n        var extension_strength = extension.count\n       \
    \                                   ^\n/tmp/tmpdc2q9gnv.swift:21:34: error: declaration\
    \ is only valid at file scope\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmpdc2q9gnv.swift:22:23: error: expected\
    \ Sequence expression for for-each loop\n        for letter in extension {\n \
    \                     ^\n/tmp/tmpdc2q9gnv.swift:22:23: error: expected '{' to\
    \ start the body of for-each loop\n        for letter in extension {\n       \
    \               ^\n/tmp/tmpdc2q9gnv.swift:29:35: error: expected expression in\
    \ assignment\n            strongest_extension = extension\n                  \
    \                ^\n/tmp/tmpdc2q9gnv.swift:30:9: error: expected type name in\
    \ extension declaration\n        }\n        ^\n/tmp/tmpdc2q9gnv.swift:29:44: error:\
    \ expected '{' in extension\n            strongest_extension = extension\n   \
    \                                        ^\n/tmp/tmpdc2q9gnv.swift:29:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                              "
  stdout: ''
  timestamp: 1659820881
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfunc Strongest_Extension(class_name: String,\
    \ extensions: [String]) -> String {\n    var strongest_extension = \"\"\n    var\
    \ strongest_extension_strength = -1\n    for extension in extensions {\n     \
    \   let extension_strength = extension.characters.count\n        if extension_strength\
    \ > strongest_extension_strength {\n            strongest_extension_strength =\
    \ extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpg801yqsz.swift:20:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpg801yqsz.swift:20:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpg801yqsz.swift:20:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpg801yqsz.swift:21:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.characters.count\n\
    \                                 ^\n/tmp/tmpg801yqsz.swift:21:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        let extension_strength\
    \ = extension.characters.count\n                                ^\n          \
    \                      ;\n/tmp/tmpg801yqsz.swift:21:43: error: expected type name\
    \ in extension declaration\n        let extension_strength = extension.characters.count\n\
    \                                          ^\n/tmp/tmpg801yqsz.swift:21:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.characters.count\n\
    \                                          ^\n/tmp/tmpg801yqsz.swift:21:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.characters.count\n\
    \                                 ^\n/tmp/tmpg801yqsz.swift:24:35: error: expected\
    \ expression in assignment\n            strongest_extension = extension\n    \
    \                              ^\n/tmp/tmpg801yqsz.swift:25:9: error: expected\
    \ type name in extension declaration\n        }\n        ^\n/tmp/tmpg801yqsz.swift:24:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           ^\n/tmp/tmpg801yqsz.swift:24:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                                  ^\n"
  stdout: ''
  timestamp: 1659820881
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfunc Strongest_Extension(class_name: String,\
    \ extensions: [String]) -> String {\n    var strongest_extension = \"\"\n    var\
    \ strongest_extension_strength = -1\n    for extension in extensions {\n     \
    \   var extension_strength = extension.count\n        for character in extension\
    \ {\n            if character == character.lowercased() {\n                extension_strength\
    \ -= 1\n            }\n        }\n        if extension_strength > strongest_extension_strength\
    \ {\n            strongest_extension_strength = extension_strength\n         \
    \   strongest_extension = extension\n        }\n    }\n    return class_name +\
    \ \".\" + strongest_extension\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpyqk7216q.swift:20:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpyqk7216q.swift:20:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpyqk7216q.swift:20:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpyqk7216q.swift:21:34:\
    \ error: expected initial value after '='\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmpyqk7216q.swift:21:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        var extension_strength\
    \ = extension.count\n                                ^\n                     \
    \           ;\n/tmp/tmpyqk7216q.swift:21:43: error: expected type name in extension\
    \ declaration\n        var extension_strength = extension.count\n            \
    \                              ^\n/tmp/tmpyqk7216q.swift:21:43: error: expected\
    \ '{' in extension\n        var extension_strength = extension.count\n       \
    \                                   ^\n/tmp/tmpyqk7216q.swift:21:34: error: declaration\
    \ is only valid at file scope\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmpyqk7216q.swift:22:26: error: expected\
    \ Sequence expression for for-each loop\n        for character in extension {\n\
    \                         ^\n/tmp/tmpyqk7216q.swift:22:26: error: expected '{'\
    \ to start the body of for-each loop\n        for character in extension {\n \
    \                        ^\n/tmp/tmpyqk7216q.swift:29:35: error: expected expression\
    \ in assignment\n            strongest_extension = extension\n               \
    \                   ^\n/tmp/tmpyqk7216q.swift:30:9: error: expected type name\
    \ in extension declaration\n        }\n        ^\n/tmp/tmpyqk7216q.swift:29:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           ^\n/tmp/tmpyqk7216q.swift:29:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                  "
  stdout: ''
  timestamp: 1659820881
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfunc Strongest_Extension(class_name: String,\
    \ extensions: [String]) -> String {\n    var strongest_extension = \"\"\n    var\
    \ max_strength = -1\n    for extension in extensions {\n        let extension_strength\
    \ = extension.countUpToUppercase() - extension.countUpToLowercase()\n        if\
    \ extension_strength > max_strength {\n            max_strength = extension_strength\n\
    \            strongest_extension = extension\n        }\n    }\n    return class_name\
    \ + \".\" + strongest_extension\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp62wxw7i6.swift:20:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmp62wxw7i6.swift:20:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmp62wxw7i6.swift:20:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmp62wxw7i6.swift:21:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUpToUppercase()\
    \ - extension.countUpToLowercase()\n                                 ^\n/tmp/tmp62wxw7i6.swift:21:33:\
    \ error: consecutive statements on a line must be separated by ';'\n        let\
    \ extension_strength = extension.countUpToUppercase() - extension.countUpToLowercase()\n\
    \                                ^\n                                ;\n/tmp/tmp62wxw7i6.swift:21:43:\
    \ error: expected type name in extension declaration\n        let extension_strength\
    \ = extension.countUpToUppercase() - extension.countUpToLowercase()\n        \
    \                                  ^\n/tmp/tmp62wxw7i6.swift:21:43: error: expected\
    \ '{' in extension\n        let extension_strength = extension.countUpToUppercase()\
    \ - extension.countUpToLowercase()\n                                         \
    \ ^\n/tmp/tmp62wxw7i6.swift:21:34: error: declaration is only valid at file scope\n\
    \        let extension_strength = extension.countUpToUppercase() - extension.countUpToLowercase()\n\
    \                                 ^\n/tmp/tmp62wxw7i6.swift:21:76: error: expected\
    \ type name in extension declaration\n        let extension_strength = extension.countUpToUppercase()\
    \ - extension.countUpToLowercase()\n                                         \
    \                                  ^\n/tmp/tmp62wxw7i6.swift:21:76: error: expected\
    \ '{' in extension\n        let extension_strength = extension.countUpToUppercase()\
    \ - extension.countUpToLowercase()\n                                         \
    \                                  ^\n/tmp/tmp62wxw7i6.swift:21:67: error: declaration\
    \ is only valid at file scope\n        let extension_strength"
  stdout: ''
  timestamp: 1659820882
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfunc Strongest_Extension(class_name: String,\
    \ extensions: [String]) -> String {\n    var strongest_extension = \"\"\n    var\
    \ strongest_extension_strength = -1\n    for extension in extensions {\n     \
    \   let extension_strength = extension.countUpToLowercaseLetters()\n        if\
    \ extension_strength > strongest_extension_strength {\n            strongest_extension_strength\
    \ = extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp6jifw92_.swift:20:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmp6jifw92_.swift:20:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmp6jifw92_.swift:20:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmp6jifw92_.swift:21:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmp6jifw92_.swift:21:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        let extension_strength\
    \ = extension.countUpToLowercaseLetters()\n                                ^\n\
    \                                ;\n/tmp/tmp6jifw92_.swift:21:43: error: expected\
    \ type name in extension declaration\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmp6jifw92_.swift:21:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmp6jifw92_.swift:21:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmp6jifw92_.swift:24:35: error: expected\
    \ expression in assignment\n            strongest_extension = extension\n    \
    \                              ^\n/tmp/tmp6jifw92_.swift:25:9: error: expected\
    \ type name in extension declaration\n        }\n        ^\n/tmp/tmp6jifw92_.swift:24:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           ^\n/tmp/tmp6jifw92_.swift:24:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                                  ^\n"
  stdout: ''
  timestamp: 1659820881
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfunc Strongest_Extension(class_name: String,\
    \ extensions: [String]) -> String {\n    var strongest_extension = \"\"\n    var\
    \ strongest_extension_strength = -1\n    for extension in extensions {\n     \
    \   var extension_strength = extension.count\n        for char in extension {\n\
    \            if char.uppercased() != char {\n                extension_strength\
    \ -= 1\n            }\n        }\n        if extension_strength > strongest_extension_strength\
    \ {\n            strongest_extension_strength = extension_strength\n         \
    \   strongest_extension = extension\n        }\n    }\n    return class_name +\
    \ \".\" + strongest_extension\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp5m29v439.swift:20:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmp5m29v439.swift:20:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmp5m29v439.swift:20:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmp5m29v439.swift:21:34:\
    \ error: expected initial value after '='\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmp5m29v439.swift:21:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        var extension_strength\
    \ = extension.count\n                                ^\n                     \
    \           ;\n/tmp/tmp5m29v439.swift:21:43: error: expected type name in extension\
    \ declaration\n        var extension_strength = extension.count\n            \
    \                              ^\n/tmp/tmp5m29v439.swift:21:43: error: expected\
    \ '{' in extension\n        var extension_strength = extension.count\n       \
    \                                   ^\n/tmp/tmp5m29v439.swift:21:34: error: declaration\
    \ is only valid at file scope\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmp5m29v439.swift:22:21: error: expected\
    \ Sequence expression for for-each loop\n        for char in extension {\n   \
    \                 ^\n/tmp/tmp5m29v439.swift:22:21: error: expected '{' to start\
    \ the body of for-each loop\n        for char in extension {\n               \
    \     ^\n/tmp/tmp5m29v439.swift:29:35: error: expected expression in assignment\n\
    \            strongest_extension = extension\n                               \
    \   ^\n/tmp/tmp5m29v439.swift:30:9: error: expected type name in extension declaration\n\
    \        }\n        ^\n/tmp/tmp5m29v439.swift:29:44: error: expected '{' in extension\n\
    \            strongest_extension = extension\n                               \
    \            ^\n/tmp/tmp5m29v439.swift:29:35: error: declaration is only valid\
    \ at file scope\n            strongest_extension = extension\n               \
    \                   ^\n"
  stdout: ''
  timestamp: 1659820882
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfunc Strongest_Extension(class_name: String,\
    \ extensions: [String]) -> String {\n    var strongest_extension = \"\"\n    var\
    \ strongest_extension_strength = -1\n    for extension in extensions {\n     \
    \   let class_name_components = class_name.components(separatedBy: \".\")\n  \
    \      let extension_components = extension.components(separatedBy: \".\")\n \
    \       let class_name_components_count = class_name_components.count\n      \
    \  let extension_components_count = extension_components.count\n        let class_name_components_count_cap\
    \ = class_name_components.count - class_name_components_count + 1\n        let\
    \ extension_components_count_cap = extension_components.count - extension_components_count\
    \ + 1\n        let class_name_components_count_sm = class_name_components_count\
    \ - class_name_components_count_cap\n        let extension_components_count_sm\
    \ = extension_components_count - extension_components_count_cap\n        let class_name_components_count_cap_sm\
    \ = (class_name_components_count_cap - class_name_components_count_sm) / 2\n \
    \       let extension_components_count_cap_sm = (extension_components_count_cap\
    \ - extension_components_count_sm) / 2\n        let class_name_components_count_cap_sm_strength\
    \ = class_name_components_count_cap_sm + class_name_components_count_cap - class_name_components_count_sm\n\
    \        let extension_components_count_cap_sm_strength = extension_components_count_cap_sm\
    \ + extension_components_count_cap - extension_components_count_sm\n        if\
    \ class_name_components_count_cap_sm_strength > strongest_extension_strength {\n\
    \            strongest_extension = extension\n            strongest_extension_strength\
    \ = class_name_components_count_cap_sm_strength\n        }\n    }\n    return\
    \ class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(Strongest_Extension(class_name: \"Watashi\", extensions: [\"tEN\"\
    , \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp0prrr0yt.swift:20:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmp0prrr0yt.swift:20:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmp0prrr0yt.swift:20:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmp0prrr0yt.swift:22:36:\
    \ error: expected initial value after '='\n        let extension_components =\
    \ extension.components(separatedBy: \".\")\n                                 \
    \  ^\n/tmp/tmp0prrr0yt.swift:22:35: error: consecutive statements on a line must\
    \ be separated by ';'\n        let extension_components = extension.components(separatedBy:\
    \ \".\")\n                                  ^\n                              \
    \    ;\n/tmp/tmp0prrr0yt.swift:22:45: error: expected type name in extension declaration\n\
    \        let extension_components = extension.components(separatedBy: \".\")\n\
    \                                            ^\n/tmp/tmp0prrr0yt.swift:22:45:\
    \ error: expected '{' in extension\n        let extension_components = extension.components(separatedBy:\
    \ \".\")\n                                            ^\n/tmp/tmp0prrr0yt.swift:22:36:\
    \ error: declaration is only valid at file scope\n        let extension_components\
    \ = extension.components(separatedBy: \".\")\n                               \
    \    ^\n/tmp/tmp0prrr0yt.swift:34:35: error: expected expression in assignment\n\
    \            strongest_extension = extension\n                               \
    \   ^\n/tmp/tmp0prrr0yt.swift:35:42: error: expected '{' in extension\n      \
    \      strongest_extension_strength = class_name_components_count_cap_sm_strength\n\
    \                                         ^\n/tmp/tmp0prrr0yt.swift:34:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                                  ^\n/tmp/tmp0prrr0yt.swift:35:13: error: cannot\
    \ find type 'strongest_extension_strength' in scope\n            strongest_extension_strength\
    \ = class_name_components_count_cap_sm_strength\n            ^~~~~~~~"
  stdout: ''
  timestamp: 1659820882
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfunc Strongest_Extension(class_name: String,\
    \ extensions: [String]) -> String {\n    var strongest_extension = \"\"\n    var\
    \ strongest_extension_strength = -1\n    for extension in extensions {\n     \
    \   let extension_strength = extension.countUpToUppercase() - extension.countUpToLowercase()\n\
    \        if extension_strength > strongest_extension_strength {\n            strongest_extension_strength\
    \ = extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpkhpb8s88.swift:20:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpkhpb8s88.swift:20:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpkhpb8s88.swift:20:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpkhpb8s88.swift:21:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUpToUppercase()\
    \ - extension.countUpToLowercase()\n                                 ^\n/tmp/tmpkhpb8s88.swift:21:33:\
    \ error: consecutive statements on a line must be separated by ';'\n        let\
    \ extension_strength = extension.countUpToUppercase() - extension.countUpToLowercase()\n\
    \                                ^\n                                ;\n/tmp/tmpkhpb8s88.swift:21:43:\
    \ error: expected type name in extension declaration\n        let extension_strength\
    \ = extension.countUpToUppercase() - extension.countUpToLowercase()\n        \
    \                                  ^\n/tmp/tmpkhpb8s88.swift:21:43: error: expected\
    \ '{' in extension\n        let extension_strength = extension.countUpToUppercase()\
    \ - extension.countUpToLowercase()\n                                         \
    \ ^\n/tmp/tmpkhpb8s88.swift:21:34: error: declaration is only valid at file scope\n\
    \        let extension_strength = extension.countUpToUppercase() - extension.countUpToLowercase()\n\
    \                                 ^\n/tmp/tmpkhpb8s88.swift:21:76: error: expected\
    \ type name in extension declaration\n        let extension_strength = extension.countUpToUppercase()\
    \ - extension.countUpToLowercase()\n                                         \
    \                                  ^\n/tmp/tmpkhpb8s88.swift:21:76: error: expected\
    \ '{' in extension\n        let extension_strength = extension.countUpToUppercase()\
    \ - extension.countUpToLowercase()\n                                         \
    \                                  ^\n/tmp/tmpkhpb8s88.swift:21:67: error: declaration\
    \ is only valid at file scope\n        let extension_strength"
  stdout: ''
  timestamp: 1659820881
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfunc Strongest_Extension(class_name: String,\
    \ extensions: [String]) -> String {\n    var strongest_extension = \"\"\n    var\
    \ strongest_extension_strength = -1\n    for extension in extensions {\n     \
    \   let extension_strength = extension.countUpToLowercaseLetters()\n        if\
    \ extension_strength > strongest_extension_strength {\n            strongest_extension\
    \ = extension\n            strongest_extension_strength = extension_strength\n\
    \        }\n    }\n    return class_name + \".\" + strongest_extension\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpe42yg6fg.swift:20:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpe42yg6fg.swift:20:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpe42yg6fg.swift:20:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpe42yg6fg.swift:21:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmpe42yg6fg.swift:21:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        let extension_strength\
    \ = extension.countUpToLowercaseLetters()\n                                ^\n\
    \                                ;\n/tmp/tmpe42yg6fg.swift:21:43: error: expected\
    \ type name in extension declaration\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmpe42yg6fg.swift:21:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmpe42yg6fg.swift:21:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmpe42yg6fg.swift:23:35: error: expected\
    \ expression in assignment\n            strongest_extension = extension\n    \
    \                              ^\n/tmp/tmpe42yg6fg.swift:24:42: error: expected\
    \ '{' in extension\n            strongest_extension_strength = extension_strength\n\
    \                                         ^\n/tmp/tmpe42yg6fg.swift:23:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                                  ^\n/tmp/tmpe42yg6fg.swift:24:13: error: cannot\
    \ find type 'strongest_extension_strength' in scope\n            strongest_extension_strength\
    \ = extension_strength\n            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659820882
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfunc Strongest_Extension(class_name: String,\
    \ extensions: [String]) -> String {\n    var strongest_extension = \"\"\n    var\
    \ strongest_extension_strength = -1\n    for extension in extensions {\n     \
    \   let class_name_components = class_name.components(separatedBy: \".\")\n  \
    \      let extension_components = extension.components(separatedBy: \".\")\n \
    \       let class_name_components_count = class_name_components.count\n      \
    \  let extension_components_count = extension_components.count\n        let class_name_components_count_upper\
    \ = class_name_components.filter{$0.isUpper}.count\n        let extension_components_count_lower\
    \ = extension_components.filter{$0.isLower}.count\n        let class_name_components_count_upper_small\
    \ = class_name_components_count_upper - class_name_components_count_lower\n  \
    \      let extension_components_count_lower_small = extension_components_count_lower\
    \ - extension_components_count_upper\n        let extension_components_count_lower_small_strength\
    \ = extension_components_count_lower_small / class_name_components_count_upper_small\n\
    \        let extension_components_count_upper_small_strength = extension_components_count_upper_small\
    \ / class_name_components_count_upper\n        let extension_components_count_lower_small_strength\
    \ = extension_components_count_lower_small_strength * class_name_components_count_upper_small_strength\n\
    \        let extension_components_count_upper_small_strength = extension_components_count_upper_small_strength\
    \ * class_name_components_count_lower_small_strength\n        if extension_components_count_lower_small_strength\
    \ > strongest_extension_strength {\n            strongest_extension = extension\n\
    \            strongest_extension_strength = extension_components_count_lower_small_strength\n\
    \        }\n    }\n    return class_name + \".\" + strongest_extension\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp_7rzeycd.swift:20:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmp_7rzeycd.swift:20:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmp_7rzeycd.swift:20:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmp_7rzeycd.swift:22:36:\
    \ error: expected initial value after '='\n        let extension_components =\
    \ extension.components(separatedBy: \".\")\n                                 \
    \  ^\n/tmp/tmp_7rzeycd.swift:22:35: error: consecutive statements on a line must\
    \ be separated by ';'\n        let extension_components = extension.components(separatedBy:\
    \ \".\")\n                                  ^\n                              \
    \    ;\n/tmp/tmp_7rzeycd.swift:22:45: error: expected type name in extension declaration\n\
    \        let extension_components = extension.components(separatedBy: \".\")\n\
    \                                            ^\n/tmp/tmp_7rzeycd.swift:22:45:\
    \ error: expected '{' in extension\n        let extension_components = extension.components(separatedBy:\
    \ \".\")\n                                            ^\n/tmp/tmp_7rzeycd.swift:22:36:\
    \ error: declaration is only valid at file scope\n        let extension_components\
    \ = extension.components(separatedBy: \".\")\n                               \
    \    ^\n/tmp/tmp_7rzeycd.swift:34:35: error: expected expression in assignment\n\
    \            strongest_extension = extension\n                               \
    \   ^\n/tmp/tmp_7rzeycd.swift:35:42: error: expected '{' in extension\n      \
    \      strongest_extension_strength = extension_components_count_lower_small_strength\n\
    \                                         ^\n/tmp/tmp_7rzeycd.swift:34:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                                  ^\n/tmp/tmp_7rzeycd.swift:35:13: error: cannot\
    \ find type 'strongest_extension_strength' in scope\n            strongest_extension_strength\
    \ = extension_components_count_lower_small_strength\n            "
  stdout: ''
  timestamp: 1659820882
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfunc Strongest_Extension(class_name: String,\
    \ extensions: [String]) -> String {\n    var strongest_extension = \"\"\n    var\
    \ strongest_extension_strength = -1\n    for extension in extensions {\n     \
    \   var extension_strength = extension.count\n        for letter in extension\
    \ {\n            if letter.isUpper() {\n                extension_strength -=\
    \ 1\n            }\n        }\n        if extension_strength > strongest_extension_strength\
    \ {\n            strongest_extension_strength = extension_strength\n         \
    \   strongest_extension = extension\n        }\n    }\n    return class_name +\
    \ \".\" + strongest_extension\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpdc2q9gnv.swift:20:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpdc2q9gnv.swift:20:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpdc2q9gnv.swift:20:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpdc2q9gnv.swift:21:34:\
    \ error: expected initial value after '='\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmpdc2q9gnv.swift:21:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        var extension_strength\
    \ = extension.count\n                                ^\n                     \
    \           ;\n/tmp/tmpdc2q9gnv.swift:21:43: error: expected type name in extension\
    \ declaration\n        var extension_strength = extension.count\n            \
    \                              ^\n/tmp/tmpdc2q9gnv.swift:21:43: error: expected\
    \ '{' in extension\n        var extension_strength = extension.count\n       \
    \                                   ^\n/tmp/tmpdc2q9gnv.swift:21:34: error: declaration\
    \ is only valid at file scope\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmpdc2q9gnv.swift:22:23: error: expected\
    \ Sequence expression for for-each loop\n        for letter in extension {\n \
    \                     ^\n/tmp/tmpdc2q9gnv.swift:22:23: error: expected '{' to\
    \ start the body of for-each loop\n        for letter in extension {\n       \
    \               ^\n/tmp/tmpdc2q9gnv.swift:29:35: error: expected expression in\
    \ assignment\n            strongest_extension = extension\n                  \
    \                ^\n/tmp/tmpdc2q9gnv.swift:30:9: error: expected type name in\
    \ extension declaration\n        }\n        ^\n/tmp/tmpdc2q9gnv.swift:29:44: error:\
    \ expected '{' in extension\n            strongest_extension = extension\n   \
    \                                        ^\n/tmp/tmpdc2q9gnv.swift:29:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                              "
  stdout: ''
  timestamp: 1659820881
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfunc Strongest_Extension(class_name: String,\
    \ extensions: [String]) -> String {\n    var strongest_extension = \"\"\n    var\
    \ strongest_extension_strength = -1\n    for extension in extensions {\n     \
    \   let extension_strength = extension.countUpToUppercaseLetters - extension.countUpToLowercaseLetters\n\
    \        if extension_strength > strongest_extension_strength {\n            strongest_extension_strength\
    \ = extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpxhz_h2fn.swift:20:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpxhz_h2fn.swift:20:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpxhz_h2fn.swift:20:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpxhz_h2fn.swift:21:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUpToUppercaseLetters\
    \ - extension.countUpToLowercaseLetters\n                                 ^\n\
    /tmp/tmpxhz_h2fn.swift:21:33: error: consecutive statements on a line must be\
    \ separated by ';'\n        let extension_strength = extension.countUpToUppercaseLetters\
    \ - extension.countUpToLowercaseLetters\n                                ^\n \
    \                               ;\n/tmp/tmpxhz_h2fn.swift:21:43: error: expected\
    \ type name in extension declaration\n        let extension_strength = extension.countUpToUppercaseLetters\
    \ - extension.countUpToLowercaseLetters\n                                    \
    \      ^\n/tmp/tmpxhz_h2fn.swift:21:43: error: expected '{' in extension\n   \
    \     let extension_strength = extension.countUpToUppercaseLetters - extension.countUpToLowercaseLetters\n\
    \                                          ^\n/tmp/tmpxhz_h2fn.swift:21:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.countUpToUppercaseLetters\
    \ - extension.countUpToLowercaseLetters\n                                 ^\n\
    /tmp/tmpxhz_h2fn.swift:21:81: error: expected type name in extension declaration\n\
    \        let extension_strength = extension.countUpToUppercaseLetters - extension.countUpToLowercaseLetters\n\
    \                                                                            \
    \    ^\n/tmp/tmpxhz_h2fn.swift:21:81: error: expected '{' in extension\n     \
    \   let extension_strength = extension.countUpToUppercaseLetters - extension.countUpToLowercaseLetters\n\
    \                                                                            \
    \    ^\n/tmp/tmpxhz_h2fn.swift:21:7"
  stdout: ''
  timestamp: 1659820881
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfunc Strongest_Extension(class_name: String,\
    \ extensions: [String]) -> String {\n    var strongest_extension = \"\"\n    var\
    \ strongest_extension_strength = -1\n    for extension in extensions {\n     \
    \   let extension_strength = extension.countUpToUppercaseLetters - extension.countUpToLowercaseLetters\n\
    \        if extension_strength > strongest_extension_strength {\n            strongest_extension_strength\
    \ = extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpxhz_h2fn.swift:20:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpxhz_h2fn.swift:20:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpxhz_h2fn.swift:20:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpxhz_h2fn.swift:21:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUpToUppercaseLetters\
    \ - extension.countUpToLowercaseLetters\n                                 ^\n\
    /tmp/tmpxhz_h2fn.swift:21:33: error: consecutive statements on a line must be\
    \ separated by ';'\n        let extension_strength = extension.countUpToUppercaseLetters\
    \ - extension.countUpToLowercaseLetters\n                                ^\n \
    \                               ;\n/tmp/tmpxhz_h2fn.swift:21:43: error: expected\
    \ type name in extension declaration\n        let extension_strength = extension.countUpToUppercaseLetters\
    \ - extension.countUpToLowercaseLetters\n                                    \
    \      ^\n/tmp/tmpxhz_h2fn.swift:21:43: error: expected '{' in extension\n   \
    \     let extension_strength = extension.countUpToUppercaseLetters - extension.countUpToLowercaseLetters\n\
    \                                          ^\n/tmp/tmpxhz_h2fn.swift:21:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.countUpToUppercaseLetters\
    \ - extension.countUpToLowercaseLetters\n                                 ^\n\
    /tmp/tmpxhz_h2fn.swift:21:81: error: expected type name in extension declaration\n\
    \        let extension_strength = extension.countUpToUppercaseLetters - extension.countUpToLowercaseLetters\n\
    \                                                                            \
    \    ^\n/tmp/tmpxhz_h2fn.swift:21:81: error: expected '{' in extension\n     \
    \   let extension_strength = extension.countUpToUppercaseLetters - extension.countUpToLowercaseLetters\n\
    \                                                                            \
    \    ^\n/tmp/tmpxhz_h2fn.swift:21:7"
  stdout: ''
  timestamp: 1659820881
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfunc Strongest_Extension(class_name: String,\
    \ extensions: [String]) -> String {\n    var strongest_extension = \"\"\n    var\
    \ strongest_extension_strength = -1\n    for extension in extensions {\n     \
    \   let extension_strength = extension.characters.count\n        if extension_strength\
    \ > strongest_extension_strength {\n            strongest_extension_strength =\
    \ extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpg801yqsz.swift:20:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpg801yqsz.swift:20:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpg801yqsz.swift:20:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpg801yqsz.swift:21:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.characters.count\n\
    \                                 ^\n/tmp/tmpg801yqsz.swift:21:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        let extension_strength\
    \ = extension.characters.count\n                                ^\n          \
    \                      ;\n/tmp/tmpg801yqsz.swift:21:43: error: expected type name\
    \ in extension declaration\n        let extension_strength = extension.characters.count\n\
    \                                          ^\n/tmp/tmpg801yqsz.swift:21:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.characters.count\n\
    \                                          ^\n/tmp/tmpg801yqsz.swift:21:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.characters.count\n\
    \                                 ^\n/tmp/tmpg801yqsz.swift:24:35: error: expected\
    \ expression in assignment\n            strongest_extension = extension\n    \
    \                              ^\n/tmp/tmpg801yqsz.swift:25:9: error: expected\
    \ type name in extension declaration\n        }\n        ^\n/tmp/tmpg801yqsz.swift:24:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           ^\n/tmp/tmpg801yqsz.swift:24:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                                  ^\n"
  stdout: ''
  timestamp: 1659820881
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfunc Strongest_Extension(class_name: String,\
    \ extensions: [String]) -> String {\n    var strongest_extension = \"\"\n    var\
    \ strongest_extension_strength = -1\n    for extension in extensions {\n     \
    \   let extension_strength = extension.countUpToUppercase() - extension.countUpToLowercase()\n\
    \        if extension_strength > strongest_extension_strength {\n            strongest_extension_strength\
    \ = extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpkhpb8s88.swift:20:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpkhpb8s88.swift:20:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpkhpb8s88.swift:20:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpkhpb8s88.swift:21:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUpToUppercase()\
    \ - extension.countUpToLowercase()\n                                 ^\n/tmp/tmpkhpb8s88.swift:21:33:\
    \ error: consecutive statements on a line must be separated by ';'\n        let\
    \ extension_strength = extension.countUpToUppercase() - extension.countUpToLowercase()\n\
    \                                ^\n                                ;\n/tmp/tmpkhpb8s88.swift:21:43:\
    \ error: expected type name in extension declaration\n        let extension_strength\
    \ = extension.countUpToUppercase() - extension.countUpToLowercase()\n        \
    \                                  ^\n/tmp/tmpkhpb8s88.swift:21:43: error: expected\
    \ '{' in extension\n        let extension_strength = extension.countUpToUppercase()\
    \ - extension.countUpToLowercase()\n                                         \
    \ ^\n/tmp/tmpkhpb8s88.swift:21:34: error: declaration is only valid at file scope\n\
    \        let extension_strength = extension.countUpToUppercase() - extension.countUpToLowercase()\n\
    \                                 ^\n/tmp/tmpkhpb8s88.swift:21:76: error: expected\
    \ type name in extension declaration\n        let extension_strength = extension.countUpToUppercase()\
    \ - extension.countUpToLowercase()\n                                         \
    \                                  ^\n/tmp/tmpkhpb8s88.swift:21:76: error: expected\
    \ '{' in extension\n        let extension_strength = extension.countUpToUppercase()\
    \ - extension.countUpToLowercase()\n                                         \
    \                                  ^\n/tmp/tmpkhpb8s88.swift:21:67: error: declaration\
    \ is only valid at file scope\n        let extension_strength"
  stdout: ''
  timestamp: 1659820881
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfunc Strongest_Extension(class_name: String,\
    \ extensions: [String]) -> String {\n    var strongest_extension = \"\"\n    var\
    \ strongest_extension_strength = -1\n    for extension in extensions {\n     \
    \   let extension_strength = extension.countUpToCapitalLetters() - extension.countLowercaseLetters()\n\
    \        if extension_strength > strongest_extension_strength {\n            strongest_extension_strength\
    \ = extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmps2lee1kq.swift:20:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmps2lee1kq.swift:20:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmps2lee1kq.swift:20:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmps2lee1kq.swift:21:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUpToCapitalLetters()\
    \ - extension.countLowercaseLetters()\n                                 ^\n/tmp/tmps2lee1kq.swift:21:33:\
    \ error: consecutive statements on a line must be separated by ';'\n        let\
    \ extension_strength = extension.countUpToCapitalLetters() - extension.countLowercaseLetters()\n\
    \                                ^\n                                ;\n/tmp/tmps2lee1kq.swift:21:43:\
    \ error: expected type name in extension declaration\n        let extension_strength\
    \ = extension.countUpToCapitalLetters() - extension.countLowercaseLetters()\n\
    \                                          ^\n/tmp/tmps2lee1kq.swift:21:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.countUpToCapitalLetters()\
    \ - extension.countLowercaseLetters()\n                                      \
    \    ^\n/tmp/tmps2lee1kq.swift:21:34: error: declaration is only valid at file\
    \ scope\n        let extension_strength = extension.countUpToCapitalLetters()\
    \ - extension.countLowercaseLetters()\n                                 ^\n/tmp/tmps2lee1kq.swift:21:81:\
    \ error: expected type name in extension declaration\n        let extension_strength\
    \ = extension.countUpToCapitalLetters() - extension.countLowercaseLetters()\n\
    \                                                                            \
    \    ^\n/tmp/tmps2lee1kq.swift:21:81: error: expected '{' in extension\n     \
    \   let extension_strength = extension.countUpToCapitalLetters() - extension.countLowercaseLetters()\n\
    \                                                                            \
    \    ^\n/tmp/tmps2lee1kq.swift:21:72: error: decl"
  stdout: ''
  timestamp: 1659820882
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfunc Strongest_Extension(class_name: String,\
    \ extensions: [String]) -> String {\n    var strongest_extension = \"\"\n    var\
    \ strongest_extension_strength = -1\n    for extension in extensions {\n     \
    \   let extension_strength = extension.countUpToLowercaseLetters()\n        if\
    \ extension_strength > strongest_extension_strength {\n            strongest_extension_strength\
    \ = extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp6jifw92_.swift:20:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmp6jifw92_.swift:20:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmp6jifw92_.swift:20:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmp6jifw92_.swift:21:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmp6jifw92_.swift:21:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        let extension_strength\
    \ = extension.countUpToLowercaseLetters()\n                                ^\n\
    \                                ;\n/tmp/tmp6jifw92_.swift:21:43: error: expected\
    \ type name in extension declaration\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmp6jifw92_.swift:21:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmp6jifw92_.swift:21:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmp6jifw92_.swift:24:35: error: expected\
    \ expression in assignment\n            strongest_extension = extension\n    \
    \                              ^\n/tmp/tmp6jifw92_.swift:25:9: error: expected\
    \ type name in extension declaration\n        }\n        ^\n/tmp/tmp6jifw92_.swift:24:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           ^\n/tmp/tmp6jifw92_.swift:24:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                                  ^\n"
  stdout: ''
  timestamp: 1659820881
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfunc Strongest_Extension(class_name: String,\
    \ extensions: [String]) -> String {\n    var strongest_extension = \"\"\n    var\
    \ strongest_extension_strength = -1\n    for extension in extensions {\n     \
    \   let extension_strength = extension.characters.reduce(0) { (sum, character)\
    \ -> Int in\n            if character == character.lowercaseString {\n       \
    \         return sum + 1\n            }\n            return sum\n        }\n \
    \       if extension_strength > strongest_extension_strength {\n            strongest_extension_strength\
    \ = extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpzmp5ugkl.swift:20:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpzmp5ugkl.swift:20:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpzmp5ugkl.swift:20:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpzmp5ugkl.swift:21:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.characters.reduce(0)\
    \ { (sum, character) -> Int in\n                                 ^\n/tmp/tmpzmp5ugkl.swift:21:33:\
    \ error: consecutive statements on a line must be separated by ';'\n        let\
    \ extension_strength = extension.characters.reduce(0) { (sum, character) -> Int\
    \ in\n                                ^\n                                ;\n/tmp/tmpzmp5ugkl.swift:21:43:\
    \ error: expected type name in extension declaration\n        let extension_strength\
    \ = extension.characters.reduce(0) { (sum, character) -> Int in\n            \
    \                              ^\n/tmp/tmpzmp5ugkl.swift:21:43: error: expected\
    \ '{' in extension\n        let extension_strength = extension.characters.reduce(0)\
    \ { (sum, character) -> Int in\n                                          ^\n\
    /tmp/tmpzmp5ugkl.swift:21:34: error: declaration is only valid at file scope\n\
    \        let extension_strength = extension.characters.reduce(0) { (sum, character)\
    \ -> Int in\n                                 ^\n/tmp/tmpzmp5ugkl.swift:29:35:\
    \ error: expected expression in assignment\n            strongest_extension =\
    \ extension\n                                  ^\n/tmp/tmpzmp5ugkl.swift:30:9:\
    \ error: expected type name in extension declaration\n        }\n        ^\n/tmp/tmpzmp5ugkl.swift:29:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           ^\n/tmp/tmpzmp5ugkl.swift:29:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                                  ^\n"
  stdout: ''
  timestamp: 1659820882
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfunc Strongest_Extension(class_name: String,\
    \ extensions: [String]) -> String {\n    var strongest_extension = \"\"\n    var\
    \ strongest_extension_strength = -1\n    for extension in extensions {\n     \
    \   let class_name_components = class_name.components(separatedBy: \".\")\n  \
    \      let extension_components = extension.components(separatedBy: \".\")\n \
    \       let class_name_components_count = class_name_components.count\n      \
    \  let extension_components_count = extension_components.count\n        let class_name_components_extension_strength\
    \ = class_name_components_count - extension_components_count\n        if class_name_components_extension_strength\
    \ > strongest_extension_strength {\n            strongest_extension = extension\n\
    \            strongest_extension_strength = class_name_components_extension_strength\n\
    \        }\n    }\n    return class_name + \".\" + strongest_extension\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpmqic1ytv.swift:20:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpmqic1ytv.swift:20:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpmqic1ytv.swift:20:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpmqic1ytv.swift:22:36:\
    \ error: expected initial value after '='\n        let extension_components =\
    \ extension.components(separatedBy: \".\")\n                                 \
    \  ^\n/tmp/tmpmqic1ytv.swift:22:35: error: consecutive statements on a line must\
    \ be separated by ';'\n        let extension_components = extension.components(separatedBy:\
    \ \".\")\n                                  ^\n                              \
    \    ;\n/tmp/tmpmqic1ytv.swift:22:45: error: expected type name in extension declaration\n\
    \        let extension_components = extension.components(separatedBy: \".\")\n\
    \                                            ^\n/tmp/tmpmqic1ytv.swift:22:45:\
    \ error: expected '{' in extension\n        let extension_components = extension.components(separatedBy:\
    \ \".\")\n                                            ^\n/tmp/tmpmqic1ytv.swift:22:36:\
    \ error: declaration is only valid at file scope\n        let extension_components\
    \ = extension.components(separatedBy: \".\")\n                               \
    \    ^\n/tmp/tmpmqic1ytv.swift:27:35: error: expected expression in assignment\n\
    \            strongest_extension = extension\n                               \
    \   ^\n/tmp/tmpmqic1ytv.swift:28:42: error: expected '{' in extension\n      \
    \      strongest_extension_strength = class_name_components_extension_strength\n\
    \                                         ^\n/tmp/tmpmqic1ytv.swift:27:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                                  ^\n/tmp/tmpmqic1ytv.swift:28:13: error: cannot\
    \ find type 'strongest_extension_strength' in scope\n            strongest_extension_strength\
    \ = class_name_components_extension_strength\n            ^~~~~~~~~~~~~~"
  stdout: ''
  timestamp: 1659820882
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfunc Strongest_Extension(class_name: String,\
    \ extensions: [String]) -> String {\n    var strongest_extension = \"\"\n    var\
    \ strongest_extension_strength = -1\n    for extension in extensions {\n     \
    \   var extension_strength = extension.count\n        for letter in extension\
    \ {\n            if letter.isUppercase {\n                extension_strength -=\
    \ 1\n            }\n        }\n        if extension_strength > strongest_extension_strength\
    \ {\n            strongest_extension_strength = extension_strength\n         \
    \   strongest_extension = extension\n        }\n    }\n    return class_name +\
    \ \".\" + strongest_extension\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmphp4tno7j.swift:20:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmphp4tno7j.swift:20:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmphp4tno7j.swift:20:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmphp4tno7j.swift:21:34:\
    \ error: expected initial value after '='\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmphp4tno7j.swift:21:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        var extension_strength\
    \ = extension.count\n                                ^\n                     \
    \           ;\n/tmp/tmphp4tno7j.swift:21:43: error: expected type name in extension\
    \ declaration\n        var extension_strength = extension.count\n            \
    \                              ^\n/tmp/tmphp4tno7j.swift:21:43: error: expected\
    \ '{' in extension\n        var extension_strength = extension.count\n       \
    \                                   ^\n/tmp/tmphp4tno7j.swift:21:34: error: declaration\
    \ is only valid at file scope\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmphp4tno7j.swift:22:23: error: expected\
    \ Sequence expression for for-each loop\n        for letter in extension {\n \
    \                     ^\n/tmp/tmphp4tno7j.swift:22:23: error: expected '{' to\
    \ start the body of for-each loop\n        for letter in extension {\n       \
    \               ^\n/tmp/tmphp4tno7j.swift:29:35: error: expected expression in\
    \ assignment\n            strongest_extension = extension\n                  \
    \                ^\n/tmp/tmphp4tno7j.swift:30:9: error: expected type name in\
    \ extension declaration\n        }\n        ^\n/tmp/tmphp4tno7j.swift:29:44: error:\
    \ expected '{' in extension\n            strongest_extension = extension\n   \
    \                                        ^\n/tmp/tmphp4tno7j.swift:29:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                              "
  stdout: ''
  timestamp: 1659820882
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfunc Strongest_Extension(class_name: String,\
    \ extensions: [String]) -> String {\n    var strongest_extension = \"\"\n    var\
    \ strongest_extension_strength = -1\n    for extension in extensions {\n     \
    \   var extension_strength = extension.count\n        for letter in extension\
    \ {\n            if letter.isUpper() {\n                extension_strength -=\
    \ 1\n            }\n        }\n        if extension_strength > strongest_extension_strength\
    \ {\n            strongest_extension_strength = extension_strength\n         \
    \   strongest_extension = extension\n        }\n    }\n    return class_name +\
    \ \".\" + strongest_extension\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpdc2q9gnv.swift:20:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpdc2q9gnv.swift:20:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpdc2q9gnv.swift:20:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpdc2q9gnv.swift:21:34:\
    \ error: expected initial value after '='\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmpdc2q9gnv.swift:21:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        var extension_strength\
    \ = extension.count\n                                ^\n                     \
    \           ;\n/tmp/tmpdc2q9gnv.swift:21:43: error: expected type name in extension\
    \ declaration\n        var extension_strength = extension.count\n            \
    \                              ^\n/tmp/tmpdc2q9gnv.swift:21:43: error: expected\
    \ '{' in extension\n        var extension_strength = extension.count\n       \
    \                                   ^\n/tmp/tmpdc2q9gnv.swift:21:34: error: declaration\
    \ is only valid at file scope\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmpdc2q9gnv.swift:22:23: error: expected\
    \ Sequence expression for for-each loop\n        for letter in extension {\n \
    \                     ^\n/tmp/tmpdc2q9gnv.swift:22:23: error: expected '{' to\
    \ start the body of for-each loop\n        for letter in extension {\n       \
    \               ^\n/tmp/tmpdc2q9gnv.swift:29:35: error: expected expression in\
    \ assignment\n            strongest_extension = extension\n                  \
    \                ^\n/tmp/tmpdc2q9gnv.swift:30:9: error: expected type name in\
    \ extension declaration\n        }\n        ^\n/tmp/tmpdc2q9gnv.swift:29:44: error:\
    \ expected '{' in extension\n            strongest_extension = extension\n   \
    \                                        ^\n/tmp/tmpdc2q9gnv.swift:29:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                              "
  stdout: ''
  timestamp: 1659820881
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfunc Strongest_Extension(class_name: String,\
    \ extensions: [String]) -> String {\n    var strongest_extension = \"\"\n    var\
    \ strongest_extension_strength = -1\n    for extension in extensions {\n     \
    \   let extension_strength = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n\
    \        if extension_strength > strongest_extension_strength {\n            strongest_extension_strength\
    \ = extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpmx22zuzy.swift:20:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpmx22zuzy.swift:20:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpmx22zuzy.swift:20:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpmx22zuzy.swift:21:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUppercaseLetters()\
    \ - extension.countLowercaseLetters()\n                                 ^\n/tmp/tmpmx22zuzy.swift:21:33:\
    \ error: consecutive statements on a line must be separated by ';'\n        let\
    \ extension_strength = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n\
    \                                ^\n                                ;\n/tmp/tmpmx22zuzy.swift:21:43:\
    \ error: expected type name in extension declaration\n        let extension_strength\
    \ = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n  \
    \                                        ^\n/tmp/tmpmx22zuzy.swift:21:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.countUppercaseLetters()\
    \ - extension.countLowercaseLetters()\n                                      \
    \    ^\n/tmp/tmpmx22zuzy.swift:21:34: error: declaration is only valid at file\
    \ scope\n        let extension_strength = extension.countUppercaseLetters() -\
    \ extension.countLowercaseLetters()\n                                 ^\n/tmp/tmpmx22zuzy.swift:21:79:\
    \ error: expected type name in extension declaration\n        let extension_strength\
    \ = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n  \
    \                                                                            ^\n\
    /tmp/tmpmx22zuzy.swift:21:79: error: expected '{' in extension\n        let extension_strength\
    \ = extension.countUppercaseLetters() - extension.countLowercaseLetters()\n  \
    \                                                                            ^\n\
    /tmp/tmpmx22zuzy.swift:21:70: error: declaration is only va"
  stdout: ''
  timestamp: 1659820882
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfunc Strongest_Extension(class_name: String,\
    \ extensions: [String]) -> String {\n    var strongest_extension = \"\"\n    var\
    \ strongest_extension_strength = -1\n    for extension in extensions {\n     \
    \   let extension_strength = extension.countUpToLowercaseLetters()\n        if\
    \ extension_strength > strongest_extension_strength {\n            strongest_extension_strength\
    \ = extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp6jifw92_.swift:20:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmp6jifw92_.swift:20:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmp6jifw92_.swift:20:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmp6jifw92_.swift:21:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmp6jifw92_.swift:21:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        let extension_strength\
    \ = extension.countUpToLowercaseLetters()\n                                ^\n\
    \                                ;\n/tmp/tmp6jifw92_.swift:21:43: error: expected\
    \ type name in extension declaration\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmp6jifw92_.swift:21:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmp6jifw92_.swift:21:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmp6jifw92_.swift:24:35: error: expected\
    \ expression in assignment\n            strongest_extension = extension\n    \
    \                              ^\n/tmp/tmp6jifw92_.swift:25:9: error: expected\
    \ type name in extension declaration\n        }\n        ^\n/tmp/tmp6jifw92_.swift:24:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           ^\n/tmp/tmp6jifw92_.swift:24:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                                  ^\n"
  stdout: ''
  timestamp: 1659820881
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfunc Strongest_Extension(class_name: String,\
    \ extensions: [String]) -> String {\n    var strongest_extension = \"\"\n    var\
    \ strongest_extension_strength = -1\n    for extension in extensions {\n     \
    \   var extension_strength = extension.count\n        for character in extension\
    \ {\n            if character == character.lowercased() {\n                extension_strength\
    \ -= 1\n            }\n        }\n        if extension_strength > strongest_extension_strength\
    \ {\n            strongest_extension_strength = extension_strength\n         \
    \   strongest_extension = extension\n        }\n    }\n    return class_name +\
    \ \".\" + strongest_extension\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpyqk7216q.swift:20:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpyqk7216q.swift:20:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpyqk7216q.swift:20:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpyqk7216q.swift:21:34:\
    \ error: expected initial value after '='\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmpyqk7216q.swift:21:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        var extension_strength\
    \ = extension.count\n                                ^\n                     \
    \           ;\n/tmp/tmpyqk7216q.swift:21:43: error: expected type name in extension\
    \ declaration\n        var extension_strength = extension.count\n            \
    \                              ^\n/tmp/tmpyqk7216q.swift:21:43: error: expected\
    \ '{' in extension\n        var extension_strength = extension.count\n       \
    \                                   ^\n/tmp/tmpyqk7216q.swift:21:34: error: declaration\
    \ is only valid at file scope\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmpyqk7216q.swift:22:26: error: expected\
    \ Sequence expression for for-each loop\n        for character in extension {\n\
    \                         ^\n/tmp/tmpyqk7216q.swift:22:26: error: expected '{'\
    \ to start the body of for-each loop\n        for character in extension {\n \
    \                        ^\n/tmp/tmpyqk7216q.swift:29:35: error: expected expression\
    \ in assignment\n            strongest_extension = extension\n               \
    \                   ^\n/tmp/tmpyqk7216q.swift:30:9: error: expected type name\
    \ in extension declaration\n        }\n        ^\n/tmp/tmpyqk7216q.swift:29:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           ^\n/tmp/tmpyqk7216q.swift:29:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                  "
  stdout: ''
  timestamp: 1659820881
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfunc Strongest_Extension(class_name: String,\
    \ extensions: [String]) -> String {\n    var strongest_extension = \"\"\n    var\
    \ strongest_extension_strength = -1\n    for extension in extensions {\n     \
    \   let class_name_components = class_name.components(separatedBy: \".\")\n  \
    \      let extension_components = extension.components(separatedBy: \".\")\n \
    \       let class_name_components_count = class_name_components.count\n      \
    \  let extension_components_count = extension_components.count\n        let class_name_components_count_cap\
    \ = class_name_components.count - class_name_components.filter({ $0.isUppercased()\
    \ }).count\n        let extension_components_count_cap = extension_components.count\
    \ - extension_components.filter({ $0.isUppercased() }).count\n        let class_name_components_count_sm\
    \ = class_name_components.count - class_name_components.filter({ $0.isLowercased()\
    \ }).count\n        let extension_components_count_sm = extension_components.count\
    \ - extension_components.filter({ $0.isLowercased() }).count\n        let class_name_components_count_cap_and_sm\
    \ = class_name_components_count_cap - class_name_components_count_sm\n       \
    \ let extension_components_count_cap_and_sm = extension_components_count_cap -\
    \ extension_components_count_sm\n        let class_name_components_count_cap_and_sm_and_extension_components_count_cap_and_sm\
    \ = class_name_components_count_cap_and_sm + extension_components_count_cap_and_sm\n\
    \        let extension_components_count_cap_and_sm_and_class_name_components_count_cap_and_sm\
    \ = extension_components_count_cap_and_sm + class_name_components_count_cap_and_sm\n\
    \        if class_name_components_count_cap_and_sm_and_extension_components_count_cap_and_sm\
    \ > strongest_extension_strength {\n            strongest_extension = extension\n\
    \            strongest_extension_strength = class_name_components_count_cap_and_sm_and_extension_components_count_cap_and_sm\n\
    \        }\n    }\n    return class_name + \".\" + strongest_extension\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpx5ux7_zi.swift:20:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpx5ux7_zi.swift:20:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpx5ux7_zi.swift:20:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpx5ux7_zi.swift:22:36:\
    \ error: expected initial value after '='\n        let extension_components =\
    \ extension.components(separatedBy: \".\")\n                                 \
    \  ^\n/tmp/tmpx5ux7_zi.swift:22:35: error: consecutive statements on a line must\
    \ be separated by ';'\n        let extension_components = extension.components(separatedBy:\
    \ \".\")\n                                  ^\n                              \
    \    ;\n/tmp/tmpx5ux7_zi.swift:22:45: error: expected type name in extension declaration\n\
    \        let extension_components = extension.components(separatedBy: \".\")\n\
    \                                            ^\n/tmp/tmpx5ux7_zi.swift:22:45:\
    \ error: expected '{' in extension\n        let extension_components = extension.components(separatedBy:\
    \ \".\")\n                                            ^\n/tmp/tmpx5ux7_zi.swift:22:36:\
    \ error: declaration is only valid at file scope\n        let extension_components\
    \ = extension.components(separatedBy: \".\")\n                               \
    \    ^\n/tmp/tmpx5ux7_zi.swift:34:35: error: expected expression in assignment\n\
    \            strongest_extension = extension\n                               \
    \   ^\n/tmp/tmpx5ux7_zi.swift:35:42: error: expected '{' in extension\n      \
    \      strongest_extension_strength = class_name_components_count_cap_and_sm_and_extension_components_count_cap_and_sm\n\
    \                                         ^\n/tmp/tmpx5ux7_zi.swift:34:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                                  ^\n/tmp/tmpx5ux7_zi.swift:35:13: error: cannot\
    \ find type 'strongest_extension_strength' in scope\n            strongest_extension_strength\
    \ = class_name_components_count"
  stdout: ''
  timestamp: 1659820882
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfunc Strongest_Extension(class_name: String,\
    \ extensions: [String]) -> String {\n    var strongest_extension = \"\"\n    var\
    \ strongest_extension_strength = -1\n    for extension in extensions {\n     \
    \   var extension_strength = extension.count\n        for c in extension {\n \
    \           if c >= 'A' && c <= 'Z' {\n                extension_strength -= 1\n\
    \            }\n            if c >= 'a' && c <= 'z' {\n                extension_strength\
    \ -= 1\n            }\n        }\n        if extension_strength > strongest_extension_strength\
    \ {\n            strongest_extension_strength = extension_strength\n         \
    \   strongest_extension = extension\n        }\n    }\n    return class_name +\
    \ \".\" + strongest_extension\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpne606nr2.swift:20:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpne606nr2.swift:20:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpne606nr2.swift:20:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpne606nr2.swift:21:34:\
    \ error: expected initial value after '='\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmpne606nr2.swift:21:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        var extension_strength\
    \ = extension.count\n                                ^\n                     \
    \           ;\n/tmp/tmpne606nr2.swift:21:43: error: expected type name in extension\
    \ declaration\n        var extension_strength = extension.count\n            \
    \                              ^\n/tmp/tmpne606nr2.swift:21:43: error: expected\
    \ '{' in extension\n        var extension_strength = extension.count\n       \
    \                                   ^\n/tmp/tmpne606nr2.swift:21:34: error: declaration\
    \ is only valid at file scope\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmpne606nr2.swift:22:18: error: expected\
    \ Sequence expression for for-each loop\n        for c in extension {\n      \
    \           ^\n/tmp/tmpne606nr2.swift:22:18: error: expected '{' to start the\
    \ body of for-each loop\n        for c in extension {\n                 ^\n/tmp/tmpne606nr2.swift:23:21:\
    \ error: single-quoted string literal found, use '\"'\n            if c >= 'A'\
    \ && c <= 'Z' {\n                    ^~~\n                    \"A\"\n/tmp/tmpne606nr2.swift:23:33:\
    \ error: single-quoted string literal found, use '\"'\n            if c >= 'A'\
    \ && c <= 'Z' {\n                                ^~~\n                       \
    \         \"Z\"\n/tmp/tmpne606nr2.swift:26:21: error: single-quoted string literal\
    \ found, use '\"'\n            if c >= 'a' && c <= 'z' {\n                   \
    \ ^~~\n                    \"a\"\n/tmp/tmpne606nr2.swift:26:33: error: single-quote"
  stdout: ''
  timestamp: 1659820882
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfunc Strongest_Extension(class_name: String,\
    \ extensions: [String]) -> String {\n    var strongest_extension = \"\"\n    var\
    \ max_strength = -1\n    for extension in extensions {\n        var strength =\
    \ count_capital_letters(extension) - count_capital_letters(class_name)\n     \
    \   if strength > max_strength {\n            max_strength = strength\n      \
    \      strongest_extension = extension\n        }\n    }\n    return class_name\
    \ + \".\" + strongest_extension\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpg72ztk2y.swift:20:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpg72ztk2y.swift:20:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpg72ztk2y.swift:20:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpg72ztk2y.swift:21:46:\
    \ error: expected expression in list of expressions\n        var strength = count_capital_letters(extension)\
    \ - count_capital_letters(class_name)\n                                      \
    \       ^\n/tmp/tmpg72ztk2y.swift:21:46: error: consecutive statements on a line\
    \ must be separated by ';'\n        var strength = count_capital_letters(extension)\
    \ - count_capital_letters(class_name)\n                                      \
    \       ^\n                                             ;\n/tmp/tmpg72ztk2y.swift:21:55:\
    \ error: expected type name in extension declaration\n        var strength = count_capital_letters(extension)\
    \ - count_capital_letters(class_name)\n                                      \
    \                ^\n                                                       <#type#>\n\
    /tmp/tmpg72ztk2y.swift:21:55: error: expected '{' in extension\n        var strength\
    \ = count_capital_letters(extension) - count_capital_letters(class_name)\n   \
    \                                                   ^\n/tmp/tmpg72ztk2y.swift:21:46:\
    \ error: declaration is only valid at file scope\n        var strength = count_capital_letters(extension)\
    \ - count_capital_letters(class_name)\n                                      \
    \       ^\n/tmp/tmpg72ztk2y.swift:24:35: error: expected expression in assignment\n\
    \            strongest_extension = extension\n                               \
    \   ^\n/tmp/tmpg72ztk2y.swift:25:9: error: expected type name in extension declaration\n\
    \        }\n        ^\n/tmp/tmpg72ztk2y.swift:24:44: error: expected '{' in extension\n\
    \            strongest_extension = extension\n                               \
    \            ^\n/tmp/tmpg72ztk2y.swift:24:35: error: declaration is only valid\
    \ at file sc"
  stdout: ''
  timestamp: 1659820882
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfunc Strongest_Extension(class_name: String,\
    \ extensions: [String]) -> String {\n    var strongest_extension = \"\"\n    var\
    \ strongest_extension_strength = -1\n    for extension in extensions {\n     \
    \   let extension_strength = extension.characters.count\n        if extension_strength\
    \ > strongest_extension_strength {\n            strongest_extension_strength =\
    \ extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpg801yqsz.swift:20:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpg801yqsz.swift:20:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpg801yqsz.swift:20:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpg801yqsz.swift:21:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.characters.count\n\
    \                                 ^\n/tmp/tmpg801yqsz.swift:21:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        let extension_strength\
    \ = extension.characters.count\n                                ^\n          \
    \                      ;\n/tmp/tmpg801yqsz.swift:21:43: error: expected type name\
    \ in extension declaration\n        let extension_strength = extension.characters.count\n\
    \                                          ^\n/tmp/tmpg801yqsz.swift:21:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.characters.count\n\
    \                                          ^\n/tmp/tmpg801yqsz.swift:21:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.characters.count\n\
    \                                 ^\n/tmp/tmpg801yqsz.swift:24:35: error: expected\
    \ expression in assignment\n            strongest_extension = extension\n    \
    \                              ^\n/tmp/tmpg801yqsz.swift:25:9: error: expected\
    \ type name in extension declaration\n        }\n        ^\n/tmp/tmpg801yqsz.swift:24:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           ^\n/tmp/tmpg801yqsz.swift:24:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                                  ^\n"
  stdout: ''
  timestamp: 1659820881
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfunc Strongest_Extension(class_name: String,\
    \ extensions: [String]) -> String {\n    var strongest_extension = \"\"\n    var\
    \ strongest_extension_strength = -1\n    for extension in extensions {\n     \
    \   let extension_strength = extension.countUpToLowercaseLetters()\n        if\
    \ extension_strength > strongest_extension_strength {\n            strongest_extension_strength\
    \ = extension_strength\n            strongest_extension = extension\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(Strongest_Extension(class_name: \"Watashi\", extensions:\
    \ [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmp6jifw92_.swift:20:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmp6jifw92_.swift:20:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmp6jifw92_.swift:20:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmp6jifw92_.swift:21:34:\
    \ error: expected initial value after '='\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmp6jifw92_.swift:21:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        let extension_strength\
    \ = extension.countUpToLowercaseLetters()\n                                ^\n\
    \                                ;\n/tmp/tmp6jifw92_.swift:21:43: error: expected\
    \ type name in extension declaration\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmp6jifw92_.swift:21:43: error:\
    \ expected '{' in extension\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                          ^\n/tmp/tmp6jifw92_.swift:21:34: error:\
    \ declaration is only valid at file scope\n        let extension_strength = extension.countUpToLowercaseLetters()\n\
    \                                 ^\n/tmp/tmp6jifw92_.swift:24:35: error: expected\
    \ expression in assignment\n            strongest_extension = extension\n    \
    \                              ^\n/tmp/tmp6jifw92_.swift:25:9: error: expected\
    \ type name in extension declaration\n        }\n        ^\n/tmp/tmp6jifw92_.swift:24:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           ^\n/tmp/tmp6jifw92_.swift:24:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                                  ^\n"
  stdout: ''
  timestamp: 1659820881
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfunc Strongest_Extension(class_name: String,\
    \ extensions: [String]) -> String {\n    var strongest_extension = \"\"\n    var\
    \ strongest_extension_strength = -1\n    for extension in extensions {\n     \
    \   let class_name_components = class_name.components(separatedBy: \".\")\n  \
    \      let extension_components = extension.components(separatedBy: \".\")\n \
    \       let class_name = class_name_components[0]\n        let extension = extension_components[0]\n\
    \        let class_name_components_count = class_name_components.count\n     \
    \   let extension_components_count = extension_components.count\n        let class_name_components_count_upper\
    \ = class_name_components_count - class_name_components_count.map { $0.isUppercase\
    \ }.count\n        let extension_components_count_upper = extension_components_count\
    \ - extension_components_count.map { $0.isUppercase }.count\n        let class_name_components_count_lower\
    \ = class_name_components_count - class_name_components_count.map { $0.isLowercase\
    \ }.count\n        let extension_components_count_lower = extension_components_count\
    \ - extension_components_count.map { $0.isLowercase }.count\n        let class_name_components_count_all\
    \ = class_name_components_count + class_name_components_count_upper + class_name_components_count_lower\n\
    \        let extension_components_count_all = extension_components_count + extension_components_count_upper\
    \ + extension_components_count_lower\n        let class_name_components_count_all_upper\
    \ = class_name_components_count_all - class_name_components_count_all.map { $0.isUppercase\
    \ }.count\n        let extension_components_count_all_upper = extension_components_count_all\
    \ - extension_components_count_all.map { $0.isUppercase }.count\n        let class_name_components_count_all_lower\
    \ = class_name_components_count_all - class_name_components_count_all.map { $0.isLowercase\
    \ }.count\n        let extension_components_count_all_lower = extension_components_count_all\
    \ - extension_components_count_all.map { $0.isLowercase }.count\n        let class_name_components_count_all_all\
    \ = class_name_components_count_all + class_name_components_count_all_upper +\
    \ class_name_components_count_all_lower\n        let extension_components_count_all_all\
    \ = extension_components_count_all + extension_components_count_all_upper + extension_components_count_all_lower\n\
    \        let class_name_components_count_all_all_upper = class_name_components_count_all_all\
    \ - class_name_components_count_all_all.map { $0.isUppercase }.count\n       \
    \ let extension_components_count_all_all_upper = extension_components_count_all_all\
    \ - extension_components_count_all_all.map { \n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(Strongest_Extension(class_name: \"Watashi\", extensions: [\"tEN\"\
    , \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\")\nassert(Strongest_Extension(class_name:\
    \ \"Boku123\", extensions: [\"nani\", \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"\
    ]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name: \"__YESIMHERE\"\
    , extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\", \"123NoooneB321\"\
    ]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name: \"K\", extensions:\
    \ [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\nassert(Strongest_Extension(class_name:\
    \ \"__HAHA\", extensions: [\"Tab\", \"123\", \"781345\", \"-_-\"]) == \"__HAHA.123\"\
    )\nassert(Strongest_Extension(class_name: \"YameRore\", extensions: [\"HhAas\"\
    , \"okIWILL123\", \"WorkOut\", \"Fails\", \"-_-\"]) == \"YameRore.okIWILL123\"\
    )\nassert(Strongest_Extension(class_name: \"finNNalLLly\", extensions: [\"Die\"\
    , \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\")\nassert(Strongest_Extension(class_name:\
    \ \"_\", extensions: [\"Bb\", \"91245\"]) == \"_.Bb\")\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmph7dqtkle.swift:20:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmph7dqtkle.swift:20:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmph7dqtkle.swift:20:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmph7dqtkle.swift:22:36:\
    \ error: expected initial value after '='\n        let extension_components =\
    \ extension.components(separatedBy: \".\")\n                                 \
    \  ^\n/tmp/tmph7dqtkle.swift:22:35: error: consecutive statements on a line must\
    \ be separated by ';'\n        let extension_components = extension.components(separatedBy:\
    \ \".\")\n                                  ^\n                              \
    \    ;\n/tmp/tmph7dqtkle.swift:22:45: error: expected type name in extension declaration\n\
    \        let extension_components = extension.components(separatedBy: \".\")\n\
    \                                            ^\n/tmp/tmph7dqtkle.swift:22:45:\
    \ error: expected '{' in extension\n        let extension_components = extension.components(separatedBy:\
    \ \".\")\n                                            ^\n/tmp/tmph7dqtkle.swift:22:36:\
    \ error: declaration is only valid at file scope\n        let extension_components\
    \ = extension.components(separatedBy: \".\")\n                               \
    \    ^\n/tmp/tmph7dqtkle.swift:24:13: error: keyword 'extension' cannot be used\
    \ as an identifier here\n        let extension = extension_components[0]\n   \
    \         ^\n/tmp/tmph7dqtkle.swift:24:13: note: if this name is unavoidable,\
    \ use backticks to escape it\n        let extension = extension_components[0]\n\
    \            ^~~~~~~~~\n            `extension`\n/tmp/tmph7dqtkle.swift:64:91:\
    \ error: expected '}' at end of brace statement\nassert(Strongest_Extension(class_name:\
    \ \"Sp\", extensions: [\"671235\", \"Bb\"]) == \"Sp.671235\")\n              \
    \                                                                            ^\n\
    /tmp/tmph7dqtkle.swift:20:33: note: to match this opening '{'\n    for extension\
    \ in extensions {\n     "
  stdout: ''
  timestamp: 1659820882
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfunc Strongest_Extension(class_name: String,\
    \ extensions: [String]) -> String {\n    var strongest_extension = \"\"\n    var\
    \ max_strength = -1\n    for extension in extensions {\n        var strength =\
    \ count_capital_letters(extension) - count_capital_letters(extension.lowercaseString)\n\
    \        if strength > max_strength {\n            max_strength = strength\n \
    \           strongest_extension = extension\n        }\n    }\n    return class_name\
    \ + \".\" + strongest_extension\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpuqiu69ui.swift:20:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpuqiu69ui.swift:20:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpuqiu69ui.swift:20:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpuqiu69ui.swift:21:46:\
    \ error: expected expression in list of expressions\n        var strength = count_capital_letters(extension)\
    \ - count_capital_letters(extension.lowercaseString)\n                       \
    \                      ^\n/tmp/tmpuqiu69ui.swift:21:46: error: consecutive statements\
    \ on a line must be separated by ';'\n        var strength = count_capital_letters(extension)\
    \ - count_capital_letters(extension.lowercaseString)\n                       \
    \                      ^\n                                             ;\n/tmp/tmpuqiu69ui.swift:21:55:\
    \ error: expected type name in extension declaration\n        var strength = count_capital_letters(extension)\
    \ - count_capital_letters(extension.lowercaseString)\n                       \
    \                               ^\n                                          \
    \             <#type#>\n/tmp/tmpuqiu69ui.swift:21:55: error: expected '{' in extension\n\
    \        var strength = count_capital_letters(extension) - count_capital_letters(extension.lowercaseString)\n\
    \                                                      ^\n/tmp/tmpuqiu69ui.swift:21:46:\
    \ error: declaration is only valid at file scope\n        var strength = count_capital_letters(extension)\
    \ - count_capital_letters(extension.lowercaseString)\n                       \
    \                      ^\n/tmp/tmpuqiu69ui.swift:24:35: error: expected expression\
    \ in assignment\n            strongest_extension = extension\n               \
    \                   ^\n/tmp/tmpuqiu69ui.swift:25:9: error: expected type name\
    \ in extension declaration\n        }\n        ^\n/tmp/tmpuqiu69ui.swift:24:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           "
  stdout: ''
  timestamp: 1659820881
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfunc Strongest_Extension(class_name: String,\
    \ extensions: [String]) -> String {\n    var strongest_extension = \"\"\n    var\
    \ max_strength = -1\n    for extension in extensions {\n        let cap = extension.count\n\
    \        let sm = class_name.count\n        let strength = cap - sm\n        if\
    \ strength > max_strength {\n            max_strength = strength\n           \
    \ strongest_extension = extension\n        }\n    }\n    return class_name + \"\
    .\" + strongest_extension\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmptr8htnm7.swift:20:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmptr8htnm7.swift:20:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmptr8htnm7.swift:20:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmptr8htnm7.swift:21:19:\
    \ error: expected initial value after '='\n        let cap = extension.count\n\
    \                  ^\n/tmp/tmptr8htnm7.swift:21:18: error: consecutive statements\
    \ on a line must be separated by ';'\n        let cap = extension.count\n    \
    \             ^\n                 ;\n/tmp/tmptr8htnm7.swift:21:28: error: expected\
    \ type name in extension declaration\n        let cap = extension.count\n    \
    \                       ^\n/tmp/tmptr8htnm7.swift:21:28: error: expected '{' in\
    \ extension\n        let cap = extension.count\n                           ^\n\
    /tmp/tmptr8htnm7.swift:21:19: error: declaration is only valid at file scope\n\
    \        let cap = extension.count\n                  ^\n/tmp/tmptr8htnm7.swift:26:35:\
    \ error: expected expression in assignment\n            strongest_extension =\
    \ extension\n                                  ^\n/tmp/tmptr8htnm7.swift:27:9:\
    \ error: expected type name in extension declaration\n        }\n        ^\n/tmp/tmptr8htnm7.swift:26:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           ^\n/tmp/tmptr8htnm7.swift:26:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                                  ^\n"
  stdout: ''
  timestamp: 1659820882
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfunc Strongest_Extension(class_name: String,\
    \ extensions: [String]) -> String {\n    var strongest_extension = \"\"\n    var\
    \ strongest_extension_strength = -1\n    for extension in extensions {\n     \
    \   var extension_strength = extension.count\n        for character in extension\
    \ {\n            if character == character.lowercased() {\n                extension_strength\
    \ -= 1\n            }\n        }\n        if extension_strength > strongest_extension_strength\
    \ {\n            strongest_extension_strength = extension_strength\n         \
    \   strongest_extension = extension\n        }\n    }\n    return class_name +\
    \ \".\" + strongest_extension\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpyqk7216q.swift:20:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpyqk7216q.swift:20:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpyqk7216q.swift:20:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpyqk7216q.swift:21:34:\
    \ error: expected initial value after '='\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmpyqk7216q.swift:21:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        var extension_strength\
    \ = extension.count\n                                ^\n                     \
    \           ;\n/tmp/tmpyqk7216q.swift:21:43: error: expected type name in extension\
    \ declaration\n        var extension_strength = extension.count\n            \
    \                              ^\n/tmp/tmpyqk7216q.swift:21:43: error: expected\
    \ '{' in extension\n        var extension_strength = extension.count\n       \
    \                                   ^\n/tmp/tmpyqk7216q.swift:21:34: error: declaration\
    \ is only valid at file scope\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmpyqk7216q.swift:22:26: error: expected\
    \ Sequence expression for for-each loop\n        for character in extension {\n\
    \                         ^\n/tmp/tmpyqk7216q.swift:22:26: error: expected '{'\
    \ to start the body of for-each loop\n        for character in extension {\n \
    \                        ^\n/tmp/tmpyqk7216q.swift:29:35: error: expected expression\
    \ in assignment\n            strongest_extension = extension\n               \
    \                   ^\n/tmp/tmpyqk7216q.swift:30:9: error: expected type name\
    \ in extension declaration\n        }\n        ^\n/tmp/tmpyqk7216q.swift:29:44:\
    \ error: expected '{' in extension\n            strongest_extension = extension\n\
    \                                           ^\n/tmp/tmpyqk7216q.swift:29:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                  "
  stdout: ''
  timestamp: 1659820881
- exit_code: 1
  program: "\n/// You will be given the name of a class (a string) and a list of extensions.\n\
    /// The extensions are to be used to load additional classes to the class. The\n\
    /// strength of the extension is as follows: Let CAP be the number of the uppercase\n\
    /// letters in the extension's name, and let SM be the number of lowercase letters\
    \ \n/// in the extension's name, the strength is given by the fraction CAP - SM.\
    \ \n/// You should find the strongest extension and return a string in this \n\
    /// format: ClassName.StrongestExtensionName.\n/// If there are two or more extensions\
    \ with the same strength, you should\n/// choose the one that comes first in the\
    \ list.\n/// For example, if you are given \"Slices\" as the class and a list\
    \ of the\n/// extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n\
    /// return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension\
    \ \n/// (its strength is -1).\n/// Example:\n/// for Strongest_Extension('my_class',\
    \ ['AA', 'Be', 'CC']) == 'my_class.AA'\nfunc Strongest_Extension(class_name: String,\
    \ extensions: [String]) -> String {\n    var strongest_extension = \"\"\n    var\
    \ strongest_extension_strength = -1\n    for extension in extensions {\n     \
    \   var extension_strength = extension.count\n        for letter in extension\
    \ {\n            if letter.isUpper() {\n                extension_strength -=\
    \ 1\n            }\n        }\n        if extension_strength > strongest_extension_strength\
    \ {\n            strongest_extension_strength = extension_strength\n         \
    \   strongest_extension = extension\n        }\n    }\n    return class_name +\
    \ \".\" + strongest_extension\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(Strongest_Extension(class_name:\
    \ \"Watashi\", extensions: [\"tEN\", \"niNE\", \"eIGHt8OKe\"]) == \"Watashi.eIGHt8OKe\"\
    )\nassert(Strongest_Extension(class_name: \"Boku123\", extensions: [\"nani\",\
    \ \"NazeDa\", \"YEs.WeCaNe\", \"32145tggg\"]) == \"Boku123.YEs.WeCaNe\")\nassert(Strongest_Extension(class_name:\
    \ \"__YESIMHERE\", extensions: [\"t\", \"eMptY\", \"nothing\", \"zeR00\", \"NuLl__\"\
    , \"123NoooneB321\"]) == \"__YESIMHERE.NuLl__\")\nassert(Strongest_Extension(class_name:\
    \ \"K\", extensions: [\"Ta\", \"TAR\", \"t234An\", \"cosSo\"]) == \"K.TAR\")\n\
    assert(Strongest_Extension(class_name: \"__HAHA\", extensions: [\"Tab\", \"123\"\
    , \"781345\", \"-_-\"]) == \"__HAHA.123\")\nassert(Strongest_Extension(class_name:\
    \ \"YameRore\", extensions: [\"HhAas\", \"okIWILL123\", \"WorkOut\", \"Fails\"\
    , \"-_-\"]) == \"YameRore.okIWILL123\")\nassert(Strongest_Extension(class_name:\
    \ \"finNNalLLly\", extensions: [\"Die\", \"NowW\", \"Wow\", \"WoW\"]) == \"finNNalLLly.WoW\"\
    )\nassert(Strongest_Extension(class_name: \"_\", extensions: [\"Bb\", \"91245\"\
    ]) == \"_.Bb\")\nassert(Strongest_Extension(class_name: \"Sp\", extensions: [\"\
    671235\", \"Bb\"]) == \"Sp.671235\")"
  status: SyntaxError
  stderr: "/tmp/tmpdc2q9gnv.swift:20:9: error: expected pattern\n    for extension\
    \ in extensions {\n        ^\n/tmp/tmpdc2q9gnv.swift:20:9: error: expected Sequence\
    \ expression for for-each loop\n    for extension in extensions {\n        ^\n\
    /tmp/tmpdc2q9gnv.swift:20:9: error: expected '{' to start the body of for-each\
    \ loop\n    for extension in extensions {\n        ^\n/tmp/tmpdc2q9gnv.swift:21:34:\
    \ error: expected initial value after '='\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmpdc2q9gnv.swift:21:33: error: consecutive\
    \ statements on a line must be separated by ';'\n        var extension_strength\
    \ = extension.count\n                                ^\n                     \
    \           ;\n/tmp/tmpdc2q9gnv.swift:21:43: error: expected type name in extension\
    \ declaration\n        var extension_strength = extension.count\n            \
    \                              ^\n/tmp/tmpdc2q9gnv.swift:21:43: error: expected\
    \ '{' in extension\n        var extension_strength = extension.count\n       \
    \                                   ^\n/tmp/tmpdc2q9gnv.swift:21:34: error: declaration\
    \ is only valid at file scope\n        var extension_strength = extension.count\n\
    \                                 ^\n/tmp/tmpdc2q9gnv.swift:22:23: error: expected\
    \ Sequence expression for for-each loop\n        for letter in extension {\n \
    \                     ^\n/tmp/tmpdc2q9gnv.swift:22:23: error: expected '{' to\
    \ start the body of for-each loop\n        for letter in extension {\n       \
    \               ^\n/tmp/tmpdc2q9gnv.swift:29:35: error: expected expression in\
    \ assignment\n            strongest_extension = extension\n                  \
    \                ^\n/tmp/tmpdc2q9gnv.swift:30:9: error: expected type name in\
    \ extension declaration\n        }\n        ^\n/tmp/tmpdc2q9gnv.swift:29:44: error:\
    \ expected '{' in extension\n            strongest_extension = extension\n   \
    \                                        ^\n/tmp/tmpdc2q9gnv.swift:29:35: error:\
    \ declaration is only valid at file scope\n            strongest_extension = extension\n\
    \                              "
  stdout: ''
  timestamp: 1659820881
