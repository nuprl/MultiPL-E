language: swift
name: HumanEval_132_is_nested
results:
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    func is_nested(string: String) -> Bool {\n    var stack = [String]()\n    var\
    \ openBrackets = 0\n    var closeBrackets = 0\n    for symbol in string {\n  \
    \      switch symbol {\n        case \"[\": openBrackets += 1\n        case \"\
    [\": closeBrackets += 1\n        case \"(\": openBrackets += 1\n        case \"\
    )\": closeBrackets += 1\n        default: break\n        }\n        stack.append(symbol)\n\
    \    }\n    if openBrackets == closeBrackets {\n        return true\n    }\n \
    \   return false\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(is_nested(string:\
    \ \"[[]]\") == true)\nassert(is_nested(string: \"[]]]]]]][[[[[]\") == false)\n\
    assert(is_nested(string: \"[][]\") == false)\nassert(is_nested(string: \"[]\"\
    ) == false)\nassert(is_nested(string: \"[[[[]]]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]]]]]\") == false)\nassert(is_nested(string: \"[][][[]]\") == true)\n\
    assert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string: \"[]]\"\
    ) == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmpkhs_h3ew.swift:18:14: warning: literal value is already handled\
    \ by previous pattern; consider removing it\n        case \"[\": closeBrackets\
    \ += 1\n             ^~~\n/tmp/tmpkhs_h3ew.swift:17:14: note: first occurrence\
    \ of identical literal pattern is here\n        case \"[\": openBrackets += 1\n\
    \             ^~~\n/tmp/tmpkhs_h3ew.swift:23:22: error: cannot convert value of\
    \ type 'Character' to expected argument type 'String'\n        stack.append(symbol)\n\
    \                     ^\n"
  stdout: ''
  timestamp: 1660013960
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    func is_nested(string: String) -> Bool {\n    let stack = Stack()\n    for char\
    \ in string {\n        if char == '[' {\n            stack.push(char)\n      \
    \  } else if char == ']' {\n            if stack.count > 0 {\n               \
    \ if stack.peek() == '[' {\n                    stack.pop()\n                }\
    \ else {\n                    return false\n                }\n            } else\
    \ {\n                return false\n            }\n        }\n    }\n    return\
    \ stack.count == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(is_nested(string:\
    \ \"[[]]\") == true)\nassert(is_nested(string: \"[]]]]]]][[[[[]\") == false)\n\
    assert(is_nested(string: \"[][]\") == false)\nassert(is_nested(string: \"[]\"\
    ) == false)\nassert(is_nested(string: \"[[[[]]]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]]]]]\") == false)\nassert(is_nested(string: \"[][][[]]\") == true)\n\
    assert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string: \"[]]\"\
    ) == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmpv6kb9la6.swift:14:20: error: single-quoted string literal found,\
    \ use '\"'\n        if char == '[' {\n                   ^~~\n               \
    \    \"[\"\n/tmp/tmpv6kb9la6.swift:16:27: error: single-quoted string literal\
    \ found, use '\"'\n        } else if char == ']' {\n                         \
    \ ^~~\n                          \"]\"\n/tmp/tmpv6kb9la6.swift:18:36: error: single-quoted\
    \ string literal found, use '\"'\n                if stack.peek() == '[' {\n \
    \                                  ^~~\n                                   \"\
    [\"\n/tmp/tmpv6kb9la6.swift:12:17: error: cannot find 'Stack' in scope\n    let\
    \ stack = Stack()\n                ^~~~~\n"
  stdout: ''
  timestamp: 1660013960
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    func is_nested(string: String) -> Bool {\n    var stack = [String]()\n    var\
    \ openingBrackets = 0\n    for char in string {\n        if char == '[' {\n  \
    \          openingBrackets += 1\n        } else if char == ']' {\n           \
    \ openingBrackets -= 1\n        } else if char == '[' && openingBrackets == 0\
    \ {\n            stack.append(char)\n        } else if char == ']' && openingBrackets\
    \ > 0 {\n            if stack[stack.count - 1] == '[' {\n                stack.removeLast()\n\
    \            } else {\n                return false\n            }\n        }\n\
    \    }\n    return openingBrackets == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string: \"[]]]]]]][[[[[]\"\
    ) == false)\nassert(is_nested(string: \"[][]\") == false)\nassert(is_nested(string:\
    \ \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]]]]]\") == false)\nassert(is_nested(string: \"[][][[]]\") == true)\n\
    assert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string: \"[]]\"\
    ) == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmpa5_glpb7.swift:15:20: error: single-quoted string literal found,\
    \ use '\"'\n        if char == '[' {\n                   ^~~\n               \
    \    \"[\"\n/tmp/tmpa5_glpb7.swift:17:27: error: single-quoted string literal\
    \ found, use '\"'\n        } else if char == ']' {\n                         \
    \ ^~~\n                          \"]\"\n/tmp/tmpa5_glpb7.swift:19:27: error: single-quoted\
    \ string literal found, use '\"'\n        } else if char == '[' && openingBrackets\
    \ == 0 {\n                          ^~~\n                          \"[\"\n/tmp/tmpa5_glpb7.swift:21:27:\
    \ error: single-quoted string literal found, use '\"'\n        } else if char\
    \ == ']' && openingBrackets > 0 {\n                          ^~~\n           \
    \               \"]\"\n/tmp/tmpa5_glpb7.swift:22:42: error: single-quoted string\
    \ literal found, use '\"'\n            if stack[stack.count - 1] == '[' {\n  \
    \                                       ^~~\n                                \
    \         \"[\"\n/tmp/tmpa5_glpb7.swift:20:26: error: cannot convert value of\
    \ type 'Character' to expected argument type 'String'\n            stack.append(char)\n\
    \                         ^\n"
  stdout: ''
  timestamp: 1660013960
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    func is_nested(string: String) -> Bool {\n    guard let openBracket = string.rangeOfString(\"\
    [\", options: .LiteralSearch, range: nil, locale: nil) else {\n        return\
    \ false\n    }\n    guard let closeBracket = string.rangeOfString(\"]\", options:\
    \ .LiteralSearch, range: nil, locale: nil) else {\n        return false\n    }\n\
    \    guard openBracket.location != closeBracket.location else {\n        return\
    \ false\n    }\n    guard openBracket.location != string.endIndex else {\n   \
    \     return false\n    }\n    guard closeBracket.location != string.startIndex\
    \ else {\n        return false\n    }\n    guard openBracket.location != string.startIndex\
    \ else {\n        return false\n    }\n    guard closeBracket.location != string.endIndex\
    \ else {\n        return false\n    }\n    guard openBracket.location != string.endIndex\
    \ else {\n        return false\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]][[[[[]\") == false)\nassert(is_nested(string: \"[][]\") == false)\n\
    assert(is_nested(string: \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\"\
    ) == true)\nassert(is_nested(string: \"[]]]]]]]]]]\") == false)\nassert(is_nested(string:\
    \ \"[][][[]]\") == true)\nassert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string:\
    \ \"[]]\") == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmps9zohie2.swift:12:36: error: value of type 'String' has no member\
    \ 'rangeOfString'\n    guard let openBracket = string.rangeOfString(\"[\", options:\
    \ .LiteralSearch, range: nil, locale: nil) else {\n                          \
    \  ~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmps9zohie2.swift:12:65: error: cannot infer contextual\
    \ base in reference to member 'LiteralSearch'\n    guard let openBracket = string.rangeOfString(\"\
    [\", options: .LiteralSearch, range: nil, locale: nil) else {\n              \
    \                                                 ~^~~~~~~~~~~~~\n/tmp/tmps9zohie2.swift:12:87:\
    \ error: 'nil' requires a contextual type\n    guard let openBracket = string.rangeOfString(\"\
    [\", options: .LiteralSearch, range: nil, locale: nil) else {\n              \
    \                                                                        ^\n/tmp/tmps9zohie2.swift:12:100:\
    \ error: 'nil' requires a contextual type\n    guard let openBracket = string.rangeOfString(\"\
    [\", options: .LiteralSearch, range: nil, locale: nil) else {\n              \
    \                                                                            \
    \         ^\n/tmp/tmps9zohie2.swift:15:37: error: value of type 'String' has no\
    \ member 'rangeOfString'\n    guard let closeBracket = string.rangeOfString(\"\
    ]\", options: .LiteralSearch, range: nil, locale: nil) else {\n              \
    \               ~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmps9zohie2.swift:15:66: error: cannot\
    \ infer contextual base in reference to member 'LiteralSearch'\n    guard let\
    \ closeBracket = string.rangeOfString(\"]\", options: .LiteralSearch, range: nil,\
    \ locale: nil) else {\n                                                      \
    \          ~^~~~~~~~~~~~~\n/tmp/tmps9zohie2.swift:15:88: error: 'nil' requires\
    \ a contextual type\n    guard let closeBracket = string.rangeOfString(\"]\",\
    \ options: .LiteralSearch, range: nil, locale: nil) else {\n                 \
    \                                                                      ^\n/tmp/tmps9zohie2.swift:15:101:\
    \ error: 'nil' requires a contextual type\n    guard let closeBracket = string.rangeOfString(\"\
    ]\", options"
  stdout: ''
  timestamp: 1660013960
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    func is_nested(string: String) -> Bool {\n    let stack = Stack()\n    for char\
    \ in string {\n        if char == '[' {\n            stack.push(char)\n      \
    \  } else if char == ']' {\n            if stack.top() == '[' {\n            \
    \    stack.pop()\n            } else {\n                return false\n       \
    \     }\n        } else {\n            return false\n        }\n    }\n    return\
    \ stack.empty()\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(is_nested(string:\
    \ \"[[]]\") == true)\nassert(is_nested(string: \"[]]]]]]][[[[[]\") == false)\n\
    assert(is_nested(string: \"[][]\") == false)\nassert(is_nested(string: \"[]\"\
    ) == false)\nassert(is_nested(string: \"[[[[]]]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]]]]]\") == false)\nassert(is_nested(string: \"[][][[]]\") == true)\n\
    assert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string: \"[]]\"\
    ) == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmpghzat_c6.swift:14:20: error: single-quoted string literal found,\
    \ use '\"'\n        if char == '[' {\n                   ^~~\n               \
    \    \"[\"\n/tmp/tmpghzat_c6.swift:16:27: error: single-quoted string literal\
    \ found, use '\"'\n        } else if char == ']' {\n                         \
    \ ^~~\n                          \"]\"\n/tmp/tmpghzat_c6.swift:17:31: error: single-quoted\
    \ string literal found, use '\"'\n            if stack.top() == '[' {\n      \
    \                        ^~~\n                              \"[\"\n/tmp/tmpghzat_c6.swift:12:17:\
    \ error: cannot find 'Stack' in scope\n    let stack = Stack()\n             \
    \   ^~~~~\n"
  stdout: ''
  timestamp: 1660013960
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    func is_nested(string: String) -> Bool {\n    \n    let stack = Stack()\n    \n\
    \    for character in string {\n        \n        if character == '[' {\n    \
    \        stack.push(character)\n        }\n        \n        if character == ']'\
    \ {\n            \n            if stack.count > 0 {\n                \n      \
    \          if stack.peek() == '[' {\n                    stack.pop()\n       \
    \         } else {\n                    return false\n                }\n    \
    \        }\n        }\n    }\n    \n    return stack.count == 0\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]][[[[[]\") == false)\nassert(is_nested(string: \"[][]\") == false)\n\
    assert(is_nested(string: \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\"\
    ) == true)\nassert(is_nested(string: \"[]]]]]]]]]]\") == false)\nassert(is_nested(string:\
    \ \"[][][[]]\") == true)\nassert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string:\
    \ \"[]]\") == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmpr76dm6wc.swift:17:25: error: single-quoted string literal found,\
    \ use '\"'\n        if character == '[' {\n                        ^~~\n     \
    \                   \"[\"\n/tmp/tmpr76dm6wc.swift:21:25: error: single-quoted\
    \ string literal found, use '\"'\n        if character == ']' {\n            \
    \            ^~~\n                        \"]\"\n/tmp/tmpr76dm6wc.swift:25:36:\
    \ error: single-quoted string literal found, use '\"'\n                if stack.peek()\
    \ == '[' {\n                                   ^~~\n                         \
    \          \"[\"\n/tmp/tmpr76dm6wc.swift:13:17: error: cannot find 'Stack' in\
    \ scope\n    let stack = Stack()\n                ^~~~~\n"
  stdout: ''
  timestamp: 1660013960
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    func is_nested(string: String) -> Bool {\n    \n    let brackets = string.replacingOccurrences(of:\
    \ \"[\", with: \"\").replacingOccurrences(of: \"]\", with: \"\")\n    \n    if\
    \ brackets.count < 2 {\n        return false\n    }\n    \n    let openingBrackets\
    \ = brackets.replacingOccurrences(of: \"[\", with: \"\").replacingOccurrences(of:\
    \ \"]\", with: \"\")\n    \n    if openingBrackets.count < 2 {\n        return\
    \ false\n    }\n    \n    let closingBrackets = brackets.replacingOccurrences(of:\
    \ \"[\", with: \"\").replacingOccurrences(of: \"]\", with: \"\")\n    \n    if\
    \ closingBrackets.count < 2 {\n        return false\n    }\n    \n    let openingBracketsCount\
    \ = openingBrackets.count\n    let closingBracketsCount = closingBrackets.count\n\
    \    \n    if openingBracketsCount != closingBracketsCount {\n        return false\n\
    \    }\n    \n    let openingBracketsArray = openingBrackets.characters\n    let\
    \ closingBracketsArray = closingBrackets.characters\n    \n    let openingBracketsArrayCount\
    \ = openingBracketsArray.count\n    let closingBracketsArrayCount = closingBracketsArray.count\n\
    \    \n    if openingBracketsArrayCount != closingBracketsArrayCount {\n     \
    \   return false\n    }\n    \n    let openingBracketsArrayIndex = 0\n    let\
    \ closingBracketsArrayIndex = 0\n    \n    while openingBracketsArrayIndex < openingBracketsArrayCount\
    \ && closingBracketsArrayIndex < closingBracketsArrayCount {\n        \n     \
    \   let openingBracket = openingBracketsArray[openingBracketsArrayIndex]\n   \
    \     let closingBracket = closingBracketsArray[closingBracketsArrayIndex]\n \
    \       \n        if openingBracket != closingBracket {\n            return false\n\
    \        }\n        \n        openingBracketsArrayIndex += 1\n        closingBracketsArrayIndex\
    \ += 1\n    }\n    \n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string: \"[]]]]]]][[[[[]\"\
    ) == false)\nassert(is_nested(string: \"[][]\") == false)\nassert(is_nested(string:\
    \ \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]]]]]\") == false)\nassert(is_nested(string: \"[][][[]]\") == true)\n\
    assert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string: \"[]]\"\
    ) == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmpn2l3wf6k.swift:13:27: error: value of type 'String' has no member\
    \ 'replacingOccurrences'\n    let brackets = string.replacingOccurrences(of: \"\
    [\", with: \"\").replacingOccurrences(of: \"]\", with: \"\")\n               \
    \    ~~~~~~ ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmpn2l3wf6k.swift:60:35: error: left side\
    \ of mutating operator isn't mutable: 'openingBracketsArrayIndex' is a 'let' constant\n\
    \        openingBracketsArrayIndex += 1\n        ~~~~~~~~~~~~~~~~~~~~~~~~~ ^\n\
    /tmp/tmpn2l3wf6k.swift:48:5: note: change 'let' to 'var' to make it mutable\n\
    \    let openingBracketsArrayIndex = 0\n    ^~~\n    var\n/tmp/tmpn2l3wf6k.swift:61:35:\
    \ error: left side of mutating operator isn't mutable: 'closingBracketsArrayIndex'\
    \ is a 'let' constant\n        closingBracketsArrayIndex += 1\n        ~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^\n/tmp/tmpn2l3wf6k.swift:49:5: note: change 'let' to 'var' to make it mutable\n\
    \    let closingBracketsArrayIndex = 0\n    ^~~\n    var\n"
  stdout: ''
  timestamp: 1660013960
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    func is_nested(string: String) -> Bool {\n    var stack = [String]()\n    var\
    \ open = 0\n    var close = 0\n    for i := 0; i < len(string); i++ {\n      \
    \  if string[i] == '[' {\n            open++\n            stack.append(string[i])\n\
    \        } else if string[i] == ']' {\n            close++\n            if open\
    \ > close {\n                return false\n            }\n            open--\n\
    \        }\n    }\n    return open > close\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string: \"\
    []]]]]]][[[[[]\") == false)\nassert(is_nested(string: \"[][]\") == false)\nassert(is_nested(string:\
    \ \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]]]]]\") == false)\nassert(is_nested(string: \"[][][[]]\") == true)\n\
    assert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string: \"[]]\"\
    ) == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmplpv4yima.swift:15:12: error: expected type\n    for i := 0; i <\
    \ len(string); i++ {\n           ^\n            <#type#>\n/tmp/tmplpv4yima.swift:15:12:\
    \ error: expected 'in' after for-each pattern\n    for i := 0; i < len(string);\
    \ i++ {\n           ^\n/tmp/tmplpv4yima.swift:15:12: error: expected Sequence\
    \ expression for for-each loop\n    for i := 0; i < len(string); i++ {\n     \
    \      ^\n/tmp/tmplpv4yima.swift:16:25: error: single-quoted string literal found,\
    \ use '\"'\n        if string[i] == '[' {\n                        ^~~\n     \
    \                   \"[\"\n/tmp/tmplpv4yima.swift:19:32: error: single-quoted\
    \ string literal found, use '\"'\n        } else if string[i] == ']' {\n     \
    \                          ^~~\n                               \"]\"\n"
  stdout: ''
  timestamp: 1660013960
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    func is_nested(string: String) -> Bool {\n    let brackets = string.unicodeScalars\n\
    \        .filter { $0 != brackets.first }\n        .map { $0 }\n        .filter\
    \ { $0 != brackets.last }\n        .map { $0 }\n        .filter { $0 != brackets.first\
    \ }\n        .map { $0 }\n        .filter { $0 != brackets.last }\n        .map\
    \ { $0 }\n        .filter { $0 != brackets.first }\n        .map { $0 }\n    \
    \    .filter { $0 != brackets.last }\n        .map { $0 }\n        .filter { $0\
    \ != brackets.first }\n        .map { $0 }\n        .filter { $0 != brackets.last\
    \ }\n        .map { $0 }\n        .filter { $0 != brackets.first }\n        .map\
    \ { $0 }\n        .filter { $0 != brackets.last }\n        .map { $0 }\n     \
    \   .filter { $0 != brackets.first }\n        .map { $0 }\n        .filter { $0\
    \ != brackets.last }\n        .map { $0 }\n        .filter { $0 != brackets.first\
    \ }\n        .map { $0 }\n        .filter { $0 != brackets.last }\n        .map\
    \ { $0 }\n        .filter { $0 != brackets.first }\n        .map { $0 }\n    \
    \    .filter { $0 != brackets.last }\n        .map { $0 }\n        .filter { $0\
    \ != brackets.first }\n        .map { $0 }\n        .filter { $0 != brackets.last\
    \ }\n        .map { $0 }\n        .filter { $0 != brackets.first }\n        .map\
    \ { $0 }\n        .filter { $0 != brackets.last }\n        .map { $0 }\n     \
    \   .filter { $0 != brackets.first }\n        .map { $0 }\n        .filter { $0\
    \ != brackets.last }\n        .map { $0 }\n        .filter { $0 != brackets.first\
    \ }\n        .map { $0 }\n        .filter { $0 != brackets.last }\n        .map\
    \ { $0 }\n        .filter { $0 != brackets.first }\n        .map { $0 }\n    \
    \    .filter { $0 != brackets.last }\n        .map { $0 }\n        .filter { $0\
    \ != brackets.first }\n        .map { $0 }\n        .filter { $0 != brackets.last\
    \ }\n        .map { $0 }\n\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(is_nested(string:\
    \ \"[[]]\") == true)\nassert(is_nested(string: \"[]]]]]]][[[[[]\") == false)\n\
    assert(is_nested(string: \"[][]\") == false)\nassert(is_nested(string: \"[]\"\
    ) == false)\nassert(is_nested(string: \"[[[[]]]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]]]]]\") == false)\nassert(is_nested(string: \"[][][[]]\") == true)\n\
    assert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string: \"[]]\"\
    ) == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmpgsfi8o6p.swift:68:10: error: failed to produce diagnostic for expression;\
    \ please submit a bug report (https://swift.org/contributing/#reporting-bugs)\
    \ and include the project\n        .map { $0 }\n         ^\n"
  stdout: ''
  timestamp: 1660013960
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    func is_nested(string: String) -> Bool {\n    guard let open = string.range(of:\
    \ \"[\"),\n        let close = string.range(of: \"]\"),\n        open != nil &&\
    \ close != nil else {\n        return false\n    }\n    \n    let openCount =\
    \ string.distance(from: open.upperBound, to: open.lowerBound)\n    let closeCount\
    \ = string.distance(from: close.upperBound, to: close.lowerBound)\n    \n    return\
    \ openCount == closeCount\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(is_nested(string:\
    \ \"[[]]\") == true)\nassert(is_nested(string: \"[]]]]]]][[[[[]\") == false)\n\
    assert(is_nested(string: \"[][]\") == false)\nassert(is_nested(string: \"[]\"\
    ) == false)\nassert(is_nested(string: \"[[[[]]]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]]]]]\") == false)\nassert(is_nested(string: \"[][][[]]\") == true)\n\
    assert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string: \"[]]\"\
    ) == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmpsitlbs7w.swift:12:29: error: value of type 'String' has no member\
    \ 'range'\n    guard let open = string.range(of: \"[\"),\n                   \
    \  ~~~~~~ ^~~~~\n/tmp/tmpsitlbs7w.swift:13:28: error: value of type 'String' has\
    \ no member 'range'\n        let close = string.range(of: \"]\"),\n          \
    \          ~~~~~~ ^~~~~\n"
  stdout: ''
  timestamp: 1660013960
- exit_code: -4
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    func is_nested(string: String) -> Bool {\n    \n    // Your code here\n    \n\
    \    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(is_nested(string:\
    \ \"[[]]\") == true)\nassert(is_nested(string: \"[]]]]]]][[[[[]\") == false)\n\
    assert(is_nested(string: \"[][]\") == false)\nassert(is_nested(string: \"[]\"\
    ) == false)\nassert(is_nested(string: \"[[[[]]]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]]]]]\") == false)\nassert(is_nested(string: \"[][][[]]\") == true)\n\
    assert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string: \"[]]\"\
    ) == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: Exception
  stderr: 'tmp4fbozzey/tmp4fbozzey.swift:32: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af698c96c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af69898db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af69898d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af69898c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp4fbozzey                        0x000056101a6522fb <unavailable> + 4859

    5    libc.so.6                          0x00002af698e82460 __libc_start_main +
    245

    6    tmp4fbozzey                        0x000056101a651ee9 <unavailable> + 3817

    '
  stdout: ''
  timestamp: 1660013961
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    func is_nested(string: String) -> Bool {\n    let openingBrackets = string.unicodeScalars.filter({\
    \ $0.isOpen })\n    let closingBrackets = string.unicodeScalars.filter({ $0.isClosing\
    \ })\n    \n    if openingBrackets.count != closingBrackets.count {\n        return\
    \ false\n    }\n    \n    let openingBracketsCount = openingBrackets.count\n \
    \   let closingBracketsCount = closingBrackets.count\n    \n    if openingBracketsCount\
    \ == 0 {\n        return true\n    }\n    \n    if openingBracketsCount == 1 {\n\
    \        return closingBrackets.first!.isNested == openingBrackets.first!.isNested\n\
    \    }\n    \n    let openingBracketsIndex = openingBrackets.first!.index\n  \
    \  let closingBracketsIndex = closingBrackets.first!.index\n    \n    let openingBracketsString\
    \ = string.substring(from: openingBracketsIndex)\n    let closingBracketsString\
    \ = string.substring(from: closingBracketsIndex)\n    \n    let openingBracketsStringCount\
    \ = openingBracketsString.unicodeScalars.filter({ $0.isOpen }).count\n    let\
    \ closingBracketsStringCount = closingBracketsString.unicodeScalars.filter({ $0.isClosing\
    \ }).count\n    \n    if openingBracketsStringCount != closingBracketsStringCount\
    \ {\n        return false\n    }\n    \n    let openingBracketsStringIndex = openingBracketsString.unicodeScalars.filter({\
    \ $0.isOpen }).first!.index\n    let closingBracketsStringIndex = closingBracketsString.unicodeScalars.filter({\
    \ $0.isClosing }).first!.index\n    \n    let openingBracketsStringCount = openingBracketsString.unicodeScalars.filter({\
    \ $0.isOpen }).count\n    let closingBracketsStringCount = closingBracketsString.unicodeScalars.filter({\
    \ $0.isClosing }).count\n    \n    if openingBracketsStringCount != closingBracketsStringCount\
    \ {\n        return false\n    }\n    \n    let openingBracketsStringIndex = openingBracketsString.unicodeScalars.filter({\
    \ $0.isOpen }).first!.index\n    let closingBracketsStringIndex = closingBracketsString.unicodeScalars.filter({\
    \ $0.isClosing }).first!.index\n    \n    let openingBracketsStringCount = openingBracketsString.unicodeScalars.filter({\
    \ $0.isOpen }).count\n    let closingBracket\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string: \"\
    []]]]]]][[[[[]\") == false)\nassert(is_nested(string: \"[][]\") == false)\nassert(is_nested(string:\
    \ \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]]]]]\") == false)\nassert(is_nested(string: \"[][][[]]\") == true)\n\
    assert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string: \"[]]\"\
    ) == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmpq8knux6g.swift:12:61: error: value of type 'Unicode.Scalar' has\
    \ no member 'isOpen'\n    let openingBrackets = string.unicodeScalars.filter({\
    \ $0.isOpen })\n                                                         ~~ ^~~~~~\n\
    /tmp/tmpq8knux6g.swift:13:61: error: value of type 'Unicode.Scalar' has no member\
    \ 'isClosing'\n    let closingBrackets = string.unicodeScalars.filter({ $0.isClosing\
    \ })\n                                                         ~~ ^~~~~~~~~\n\
    /tmp/tmpq8knux6g.swift:33:40: error: value of type 'String' has no member 'substring'\n\
    \    let openingBracketsString = string.substring(from: openingBracketsIndex)\n\
    \                                ~~~~~~ ^~~~~~~~~\n/tmp/tmpq8knux6g.swift:34:40:\
    \ error: value of type 'String' has no member 'substring'\n    let closingBracketsString\
    \ = string.substring(from: closingBracketsIndex)\n                           \
    \     ~~~~~~ ^~~~~~~~~\n/tmp/tmpq8knux6g.swift:57:9: error: type annotation missing\
    \ in pattern\n    let closingBracket\n        ^\n"
  stdout: ''
  timestamp: 1660013960
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    func is_nested(string: String) -> Bool {\n    guard let start = string.index(of:\
    \ \"[\"), let end = string.index(of: \"]\") else {\n        return false\n   \
    \ }\n    \n    var stack = [String]()\n    stack.append(string[start..<end])\n\
    \    \n    for _ in 0..<string.count {\n        guard let start = string.index(of:\
    \ \"[\"), let end = string.index(of: \"]\") else {\n            return false\n\
    \        }\n        \n        if start < end {\n            stack.append(string[start..<end])\n\
    \        }\n    }\n    \n    return stack.count > 1\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]][[[[[]\") == false)\nassert(is_nested(string: \"[][]\") == false)\n\
    assert(is_nested(string: \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\"\
    ) == true)\nassert(is_nested(string: \"[]]]]]]]]]]\") == false)\nassert(is_nested(string:\
    \ \"[][][[]]\") == true)\nassert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string:\
    \ \"[]]\") == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmp_y08vw8b.swift:12:30: warning: 'index(of:)' is deprecated: renamed\
    \ to 'firstIndex(of:)'\n    guard let start = string.index(of: \"[\"), let end\
    \ = string.index(of: \"]\") else {\n                             ^\n/tmp/tmp_y08vw8b.swift:12:30:\
    \ note: use 'firstIndex(of:)' instead\n    guard let start = string.index(of:\
    \ \"[\"), let end = string.index(of: \"]\") else {\n                         \
    \    ^~~~~\n                             firstIndex\n/tmp/tmp_y08vw8b.swift:12:63:\
    \ warning: 'index(of:)' is deprecated: renamed to 'firstIndex(of:)'\n    guard\
    \ let start = string.index(of: \"[\"), let end = string.index(of: \"]\") else\
    \ {\n                                                              ^\n/tmp/tmp_y08vw8b.swift:12:63:\
    \ note: use 'firstIndex(of:)' instead\n    guard let start = string.index(of:\
    \ \"[\"), let end = string.index(of: \"]\") else {\n                         \
    \                                     ^~~~~\n                                \
    \                              firstIndex\n/tmp/tmp_y08vw8b.swift:17:24: error:\
    \ subscript 'subscript(_:)' requires the types 'String.Index' and 'Int' be equivalent\n\
    \    stack.append(string[start..<end])\n                       ^\nSwift.String:5:12:\
    \ note: where 'R.Bound' = 'String.Index'\n    public subscript<R>(bounds: R) ->\
    \ String where R : RangeExpression, R.Bound == Int { get }\n           ^\n/tmp/tmp_y08vw8b.swift:20:34:\
    \ warning: 'index(of:)' is deprecated: renamed to 'firstIndex(of:)'\n        guard\
    \ let start = string.index(of: \"[\"), let end = string.index(of: \"]\") else\
    \ {\n                                 ^\n/tmp/tmp_y08vw8b.swift:20:34: note: use\
    \ 'firstIndex(of:)' instead\n        guard let start = string.index(of: \"[\"\
    ), let end = string.index(of: \"]\") else {\n                                \
    \ ^~~~~\n                                 firstIndex\n/tmp/tmp_y08vw8b.swift:20:67:\
    \ warning: 'index(of:)' is deprecated: renamed to 'firstIndex(of:)'\n        guard\
    \ let start = string.index(of: \"[\"), let end = string.index(of: \"]\") else\
    \ {\n                                                                  ^\n/tmp/tmp_y08vw8b.sw"
  stdout: ''
  timestamp: 1660013960
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    func is_nested(string: String) -> Bool {\n    var stack = [String]()\n    var\
    \ opening = false\n    for char in string {\n        if char == '[' {\n      \
    \      stack.append(char)\n            opening = true\n        } else if char\
    \ == ']' {\n            if opening {\n                opening = false\n      \
    \      } else {\n                return false\n            }\n        } else {\n\
    \            if opening {\n                stack.removeLast()\n            }\n\
    \        }\n    }\n    return stack.count == 0\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string: \"\
    []]]]]]][[[[[]\") == false)\nassert(is_nested(string: \"[][]\") == false)\nassert(is_nested(string:\
    \ \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]]]]]\") == false)\nassert(is_nested(string: \"[][][[]]\") == true)\n\
    assert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string: \"[]]\"\
    ) == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmp48hwmrf9.swift:15:20: error: single-quoted string literal found,\
    \ use '\"'\n        if char == '[' {\n                   ^~~\n               \
    \    \"[\"\n/tmp/tmp48hwmrf9.swift:18:27: error: single-quoted string literal\
    \ found, use '\"'\n        } else if char == ']' {\n                         \
    \ ^~~\n                          \"]\"\n/tmp/tmp48hwmrf9.swift:16:26: error: cannot\
    \ convert value of type 'Character' to expected argument type 'String'\n     \
    \       stack.append(char)\n                         ^\n"
  stdout: ''
  timestamp: 1660013960
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    func is_nested(string: String) -> Bool {\n    let stack = Stack()\n    for character\
    \ in string {\n        if character == '[' {\n            stack.push(character)\n\
    \        } else if character == ']' {\n            if stack.top() == '[' {\n \
    \               stack.pop()\n            } else {\n                return false\n\
    \            }\n        } else {\n            return false\n        }\n    }\n\
    \    return stack.empty()\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(is_nested(string:\
    \ \"[[]]\") == true)\nassert(is_nested(string: \"[]]]]]]][[[[[]\") == false)\n\
    assert(is_nested(string: \"[][]\") == false)\nassert(is_nested(string: \"[]\"\
    ) == false)\nassert(is_nested(string: \"[[[[]]]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]]]]]\") == false)\nassert(is_nested(string: \"[][][[]]\") == true)\n\
    assert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string: \"[]]\"\
    ) == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmp7uzdn270.swift:14:25: error: single-quoted string literal found,\
    \ use '\"'\n        if character == '[' {\n                        ^~~\n     \
    \                   \"[\"\n/tmp/tmp7uzdn270.swift:16:32: error: single-quoted\
    \ string literal found, use '\"'\n        } else if character == ']' {\n     \
    \                          ^~~\n                               \"]\"\n/tmp/tmp7uzdn270.swift:17:31:\
    \ error: single-quoted string literal found, use '\"'\n            if stack.top()\
    \ == '[' {\n                              ^~~\n                              \"\
    [\"\n/tmp/tmp7uzdn270.swift:12:17: error: cannot find 'Stack' in scope\n    let\
    \ stack = Stack()\n                ^~~~~\n"
  stdout: ''
  timestamp: 1660013960
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    func is_nested(string: String) -> Bool {\n    \n    // Initialize a stack to store\
    \ brackets\n    var stack = [String]()\n    \n    // Initialize a counter to keep\
    \ track of how many brackets are in the string\n    var count = 0\n    \n    //\
    \ Iterate through the string and add each character to the stack\n    for char\
    \ in string {\n        \n        // If the character is a bracket, add it to the\
    \ stack\n        if char == \"[\" || char == \"]\" {\n            stack.append(char)\n\
    \            count += 1\n            \n        // If the character is a closing\
    \ bracket, pop the stack\n        } else if char == \"]\" {\n            \n  \
    \          // If the stack is empty, return False\n            if stack.count\
    \ == 0 {\n                return false\n            }\n            \n        \
    \    // Pop the last element from the stack\n            stack.removeLast()\n\
    \            \n            // If the stack is empty, return False\n          \
    \  if stack.count == 0 {\n                return false\n            }\n      \
    \      \n            // Increment the counter\n            count += 1\n      \
    \  }\n    }\n    \n    // If the stack is empty, return False\n    if stack.count\
    \ == 0 {\n        return false\n    }\n    \n    // If the stack is not empty,\
    \ return True\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(is_nested(string:\
    \ \"[[]]\") == true)\nassert(is_nested(string: \"[]]]]]]][[[[[]\") == false)\n\
    assert(is_nested(string: \"[][]\") == false)\nassert(is_nested(string: \"[]\"\
    ) == false)\nassert(is_nested(string: \"[[[[]]]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]]]]]\") == false)\nassert(is_nested(string: \"[][][[]]\") == true)\n\
    assert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string: \"[]]\"\
    ) == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmp0w8zj7yk.swift:24:26: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n            stack.append(char)\n       \
    \                  ^\n"
  stdout: ''
  timestamp: 1660013960
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    func is_nested(string: String) -> Bool {\n\tlet openBracketsCount = string.count(\"\
    [\")\n\tlet closeBracketsCount = string.count(\"]\")\n\t\n\tif openBracketsCount\
    \ != closeBracketsCount {\n\t\treturn false\n\t}\n\t\n\tlet openBracketsIndex\
    \ = 0\n\tlet closeBracketsIndex = 0\n\t\n\twhile openBracketsIndex < openBracketsCount\
    \ {\n\t\tlet openBracket = string[openBracketsIndex]\n\t\t\n\t\tif openBracket\
    \ == \"[\" {\n\t\t\topenBracketsIndex += 1\n\t\t} else if openBracket == \"]\"\
    \ {\n\t\t\tcloseBracketsIndex += 1\n\t\t} else {\n\t\t\treturn false\n\t\t}\n\t\
    }\n\t\n\treturn true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(is_nested(string:\
    \ \"[[]]\") == true)\nassert(is_nested(string: \"[]]]]]]][[[[[]\") == false)\n\
    assert(is_nested(string: \"[][]\") == false)\nassert(is_nested(string: \"[]\"\
    ) == false)\nassert(is_nested(string: \"[[[[]]]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]]]]]\") == false)\nassert(is_nested(string: \"[][][[]]\") == true)\n\
    assert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string: \"[]]\"\
    ) == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmptb82jn2n.swift:12:33: error: cannot call value of non-function\
    \ type 'Int'\n        let openBracketsCount = string.count(\"[\")\n          \
    \                             ^\n/tmp/tmptb82jn2n.swift:13:34: error: cannot call\
    \ value of non-function type 'Int'\n        let closeBracketsCount = string.count(\"\
    ]\")\n                                        ^\n/tmp/tmptb82jn2n.swift:23:21:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n                let openBracket = string[openBracketsIndex]\n\
    \                                  ^~~~~~~~~~~~~~~~~~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmptb82jn2n.swift:26:22:\
    \ error: left side of mutating operator isn't mutable: 'openBracketsIndex' is\
    \ a 'let' constant\n                        openBracketsIndex += 1\n         \
    \               ~~~~~~~~~~~~~~~~~ ^\n/tmp/tmptb82jn2n.swift:19:2: note: change\
    \ 'let' to 'var' to make it mutable\n        let openBracketsIndex = 0\n     \
    \   ^~~\n        var\n/tmp/tmptb82jn2n.swift:28:23: error: left side of mutating\
    \ operator isn't mutable: 'closeBracketsIndex' is a 'let' constant\n         \
    \               closeBracketsIndex += 1\n                        ~~~~~~~~~~~~~~~~~~\
    \ ^\n/tmp/tmptb82jn2n.swift:20:2: note: change 'let' to 'var' to make it mutable\n\
    \        let closeBracketsIndex = 0\n        ^~~\n        var\n"
  stdout: ''
  timestamp: 1660013960
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    func is_nested(string: String) -> Bool {\n    let stack = Stack()\n    for char\
    \ in string {\n        if char == '[' {\n            stack.push(char)\n      \
    \  } else if char == ']' {\n            if stack.top() == '[' {\n            \
    \    stack.pop()\n            } else {\n                return false\n       \
    \     }\n        } else {\n            return false\n        }\n    }\n    return\
    \ stack.empty()\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(is_nested(string:\
    \ \"[[]]\") == true)\nassert(is_nested(string: \"[]]]]]]][[[[[]\") == false)\n\
    assert(is_nested(string: \"[][]\") == false)\nassert(is_nested(string: \"[]\"\
    ) == false)\nassert(is_nested(string: \"[[[[]]]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]]]]]\") == false)\nassert(is_nested(string: \"[][][[]]\") == true)\n\
    assert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string: \"[]]\"\
    ) == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmpghzat_c6.swift:14:20: error: single-quoted string literal found,\
    \ use '\"'\n        if char == '[' {\n                   ^~~\n               \
    \    \"[\"\n/tmp/tmpghzat_c6.swift:16:27: error: single-quoted string literal\
    \ found, use '\"'\n        } else if char == ']' {\n                         \
    \ ^~~\n                          \"]\"\n/tmp/tmpghzat_c6.swift:17:31: error: single-quoted\
    \ string literal found, use '\"'\n            if stack.top() == '[' {\n      \
    \                        ^~~\n                              \"[\"\n/tmp/tmpghzat_c6.swift:12:17:\
    \ error: cannot find 'Stack' in scope\n    let stack = Stack()\n             \
    \   ^~~~~\n"
  stdout: ''
  timestamp: 1660013960
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    func is_nested(string: String) -> Bool {\n\tlet stack = Stack()\n\tlet openBrackets\
    \ = Set<Character>()\n\tlet closeBrackets = Set<Character>()\n\tlet openBracketsCount\
    \ = 1\n\tlet closeBracketsCount = 1\n\t\n\tfor char in string.characters {\n\t\
    \tif char == '[' {\n\t\t\topenBrackets.insert(char)\n\t\t\topenBracketsCount +=\
    \ 1\n\t\t} else if char == ']' {\n\t\t\tcloseBrackets.insert(char)\n\t\t\tcloseBracketsCount\
    \ += 1\n\t\t} else if char == '{' {\n\t\t\topenBracketsCount += 1\n\t\t} else\
    \ if char == '}' {\n\t\t\tcloseBracketsCount += 1\n\t\t}\n\t\t\n\t\tif openBracketsCount\
    \ == closeBracketsCount {\n\t\t\tstack.push(char)\n\t\t}\n\t}\n\t\n\treturn stack.count\
    \ == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(is_nested(string: \"[[]]\"\
    ) == true)\nassert(is_nested(string: \"[]]]]]]][[[[[]\") == false)\nassert(is_nested(string:\
    \ \"[][]\") == false)\nassert(is_nested(string: \"[]\") == false)\nassert(is_nested(string:\
    \ \"[[[[]]]]\") == true)\nassert(is_nested(string: \"[]]]]]]]]]]\") == false)\n\
    assert(is_nested(string: \"[][][[]]\") == true)\nassert(is_nested(string: \"[[]\"\
    ) == false)\nassert(is_nested(string: \"[]]\") == false)\nassert(is_nested(string:\
    \ \"[[]][[\") == true)\nassert(is_nested(string: \"[[][]]\") == true)\nassert(is_nested(string:\
    \ \"\") == false)\nassert(is_nested(string: \"[[[[[[[[\") == false)\nassert(is_nested(string:\
    \ \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmpeenrvi6g.swift:19:14: error: single-quoted string literal found,\
    \ use '\"'\n                if char == '[' {\n                           ^~~\n\
    \                           \"[\"\n/tmp/tmpeenrvi6g.swift:22:21: error: single-quoted\
    \ string literal found, use '\"'\n                } else if char == ']' {\n  \
    \                                ^~~\n                                  \"]\"\n\
    /tmp/tmpeenrvi6g.swift:25:21: error: single-quoted string literal found, use '\"\
    '\n                } else if char == '{' {\n                                 \
    \ ^~~\n                                  \"{\"\n/tmp/tmpeenrvi6g.swift:27:21:\
    \ error: single-quoted string literal found, use '\"'\n                } else\
    \ if char == '}' {\n                                  ^~~\n                  \
    \                \"}\"\n/tmp/tmpeenrvi6g.swift:12:14: error: cannot find 'Stack'\
    \ in scope\n        let stack = Stack()\n                    ^~~~~\n/tmp/tmpeenrvi6g.swift:18:21:\
    \ error: 'characters' is unavailable: Please use String directly\n        for\
    \ char in string.characters {\n                           ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmpeenrvi6g.swift:20:17: error: cannot use\
    \ mutating member on immutable value: 'openBrackets' is a 'let' constant\n   \
    \                     openBrackets.insert(char)\n                        ~~~~~~~~~~~~\
    \ ^\n/tmp/tmpeenrvi6g.swift:13:2: note: change 'let' to 'var' to make it mutable\n\
    \        let openBrackets = Set<Character>()\n        ^~~\n        var\n/tmp/tmpeenrvi6g.swift:21:22:\
    \ error: left side of mutating operator isn't mutable: 'openBracketsCount' is\
    \ a 'let' constant\n                        openBracketsCount += 1\n         \
    \               ~~~~~~~~~~~~~~~~~ ^\n/tmp/tmpeenrvi6g.swift:15:2: note: change\
    \ 'let' to 'var' to make it mutable\n        let openBracketsCount = 1\n     \
    \   ^~~\n        var\n/tmp/tmpeenrvi6g.swift:23:18: error: cannot use mutating\
    \ member on immutable value: 'closeBrackets' is a 'let' constant\n           \
    \             closeBrackets.inse"
  stdout: ''
  timestamp: 1660013960
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    func is_nested(string: String) -> Bool {\n    guard let range = string.rangeOfString(\"\
    [\", options: .LiteralSearch, range: nil, locale: nil) else {\n        return\
    \ false\n    }\n    guard let start = range.lowerBound else {\n        return\
    \ false\n    }\n    guard let end = string.rangeOfString(\"]\", options: .LiteralSearch,\
    \ range: nil, locale: nil)?.upperBound else {\n        return false\n    }\n \
    \   return start < end\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(is_nested(string:\
    \ \"[[]]\") == true)\nassert(is_nested(string: \"[]]]]]]][[[[[]\") == false)\n\
    assert(is_nested(string: \"[][]\") == false)\nassert(is_nested(string: \"[]\"\
    ) == false)\nassert(is_nested(string: \"[[[[]]]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]]]]]\") == false)\nassert(is_nested(string: \"[][][[]]\") == true)\n\
    assert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string: \"[]]\"\
    ) == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmpvikdncz8.swift:12:30: error: value of type 'String' has no member\
    \ 'rangeOfString'\n    guard let range = string.rangeOfString(\"[\", options:\
    \ .LiteralSearch, range: nil, locale: nil) else {\n                      ~~~~~~\
    \ ^~~~~~~~~~~~~\n/tmp/tmpvikdncz8.swift:12:59: error: cannot infer contextual\
    \ base in reference to member 'LiteralSearch'\n    guard let range = string.rangeOfString(\"\
    [\", options: .LiteralSearch, range: nil, locale: nil) else {\n              \
    \                                           ~^~~~~~~~~~~~~\n/tmp/tmpvikdncz8.swift:12:81:\
    \ error: 'nil' requires a contextual type\n    guard let range = string.rangeOfString(\"\
    [\", options: .LiteralSearch, range: nil, locale: nil) else {\n              \
    \                                                                  ^\n/tmp/tmpvikdncz8.swift:12:94:\
    \ error: 'nil' requires a contextual type\n    guard let range = string.rangeOfString(\"\
    [\", options: .LiteralSearch, range: nil, locale: nil) else {\n              \
    \                                                                            \
    \   ^\n/tmp/tmpvikdncz8.swift:18:28: error: value of type 'String' has no member\
    \ 'rangeOfString'\n    guard let end = string.rangeOfString(\"]\", options: .LiteralSearch,\
    \ range: nil, locale: nil)?.upperBound else {\n                    ~~~~~~ ^~~~~~~~~~~~~\n\
    /tmp/tmpvikdncz8.swift:18:57: error: cannot infer contextual base in reference\
    \ to member 'LiteralSearch'\n    guard let end = string.rangeOfString(\"]\", options:\
    \ .LiteralSearch, range: nil, locale: nil)?.upperBound else {\n              \
    \                                         ~^~~~~~~~~~~~~\n/tmp/tmpvikdncz8.swift:18:79:\
    \ error: 'nil' requires a contextual type\n    guard let end = string.rangeOfString(\"\
    ]\", options: .LiteralSearch, range: nil, locale: nil)?.upperBound else {\n  \
    \                                                                            ^\n\
    /tmp/tmpvikdncz8.swift:18:92: error: 'nil' requires a contextual type\n    guard\
    \ let end = string.rangeOfString(\"]\", options: .LiteralSearch, range: nil, locale:\
    \ nil)?.upperBound else {\n               "
  stdout: ''
  timestamp: 1660013960
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    func is_nested(string: String) -> Bool {\n    guard let start = string.index(of:\
    \ \"[\"),\n        let end = string.index(of: \"]\"),\n        start != end,\n\
    \        let start = string.index(of: \"[\", range: start..<end),\n        let\
    \ end = string.index(of: \"]\", range: start..<end),\n        start != end,\n\
    \        let start = string.index(of: \"[\", range: start..<end),\n        let\
    \ end = string.index(of: \"]\", range: start..<end),\n        start != end,\n\
    \        let start = string.index(of: \"[\", range: start..<end),\n        let\
    \ end = string.index(of: \"]\", range: start..<end),\n        start != end,\n\
    \        let start = string.index(of: \"[\", range: start..<end),\n        let\
    \ end = string.index(of: \"]\", range: start..<end),\n        start != end,\n\
    \        let start = string.index(of: \"[\", range: start..<end),\n        let\
    \ end = string.index(of: \"]\", range: start..<end),\n        start != end,\n\
    \        let start = string.index(of: \"[\", range: start..<end),\n        let\
    \ end = string.index(of: \"]\", range: start..<end),\n        start != end,\n\
    \        let start = string.index(of: \"[\", range: start..<end),\n        let\
    \ end = string.index(of: \"]\", range: start..<end),\n        start != end,\n\
    \        let start = string.index(of: \"[\", range: start..<end),\n        let\
    \ end = string.index(of: \"]\", range: start..<end),\n        start != end,\n\
    \        let start = string.index(of: \"[\", range: start..<end),\n        let\
    \ end = string.index(of: \"]\", range: start..<end),\n        start != end,\n\
    \        let start = string.index(of: \"[\", range: start..<end),\n        let\
    \ end = string.index(of: \"]\", range: start..<end),\n        start != end,\n\
    \        let start = string.index(of: \"[\", range: start..<end),\n        let\
    \ end = string.index(of: \"]\", range: start..<end),\n        start != end,\n\
    \        let start = string.index(of: \"[\", range: start..<end),\n        let\
    \ end = string.index(of: \"]\", range: start..<end),\n        start != end,\n\
    \        let start = string.index(of: \"[\", range: start..<end),\n        let\
    \ end = string.index(of: \"]\", range: start..<\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string: \"\
    []]]]]]][[[[[]\") == false)\nassert(is_nested(string: \"[][]\") == false)\nassert(is_nested(string:\
    \ \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]]]]]\") == false)\nassert(is_nested(string: \"[][][[]]\") == true)\n\
    assert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string: \"[]]\"\
    ) == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmp_h3vp2qo.swift:53:1: error: expected ')' in expression list\n}\n\
    ^\n/tmp/tmp_h3vp2qo.swift:52:31: note: to match this opening '('\n        let\
    \ end = string.index(of: \"]\", range: start..<\n                            \
    \  ^\n/tmp/tmp_h3vp2qo.swift:52:56: error: expected 'else' after 'guard' condition\n\
    \        let end = string.index(of: \"]\", range: start..<\n                 \
    \                                      ^\n/tmp/tmp_h3vp2qo.swift:12:30: warning:\
    \ 'index(of:)' is deprecated: renamed to 'firstIndex(of:)'\n    guard let start\
    \ = string.index(of: \"[\"),\n                             ^\n/tmp/tmp_h3vp2qo.swift:12:30:\
    \ note: use 'firstIndex(of:)' instead\n    guard let start = string.index(of:\
    \ \"[\"),\n                             ^~~~~\n                             firstIndex\n\
    /tmp/tmp_h3vp2qo.swift:13:26: warning: 'index(of:)' is deprecated: renamed to\
    \ 'firstIndex(of:)'\n        let end = string.index(of: \"]\"),\n            \
    \             ^\n/tmp/tmp_h3vp2qo.swift:13:26: note: use 'firstIndex(of:)' instead\n\
    \        let end = string.index(of: \"]\"),\n                         ^~~~~\n\
    \                         firstIndex\n/tmp/tmp_h3vp2qo.swift:15:55: error: extra\
    \ argument 'range' in call\n        let start = string.index(of: \"[\", range:\
    \ start..<end),\n                                ~~~~~~~~~~~~~~~~~~~~~~^~~~~~~\n\
    /tmp/tmp_h3vp2qo.swift:16:53: error: extra argument 'range' in call\n        let\
    \ end = string.index(of: \"]\", range: start..<end),\n                       \
    \       ~~~~~~~~~~~~~~~~~~~~~~^~~~~~~\n/tmp/tmp_h3vp2qo.swift:18:55: error: extra\
    \ argument 'range' in call\n        let start = string.index(of: \"[\", range:\
    \ start..<end),\n                                ~~~~~~~~~~~~~~~~~~~~~~^~~~~~~\n\
    /tmp/tmp_h3vp2qo.swift:19:53: error: extra argument 'range' in call\n        let\
    \ end = string.index(of: \"]\", range: start..<end),\n                       \
    \       ~~~~~~~~~~~~~~~~~~~~~~^~~~~~~\n/tmp/tmp_h3vp2qo.swift:21:55: error: extra\
    \ argument 'range' in call\n        let start = string.index(of: \"[\", range:\
    \ start..<end),\n                                ~~~~~~~~~~~~~"
  stdout: ''
  timestamp: 1660013960
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    func is_nested(string: String) -> Bool {\n    guard let openBracket = string.rangeOfString(\"\
    [\", options: .BackwardsSearch) else { return false }\n    guard let closeBracket\
    \ = string.rangeOfString(\"]\", options: .BackwardsSearch) else { return false\
    \ }\n    return openBracket.location != closeBracket.location\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]][[[[[]\") == false)\nassert(is_nested(string: \"[][]\") == false)\n\
    assert(is_nested(string: \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\"\
    ) == true)\nassert(is_nested(string: \"[]]]]]]]]]]\") == false)\nassert(is_nested(string:\
    \ \"[][][[]]\") == true)\nassert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string:\
    \ \"[]]\") == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmpvakun5rx.swift:12:36: error: value of type 'String' has no member\
    \ 'rangeOfString'\n    guard let openBracket = string.rangeOfString(\"[\", options:\
    \ .BackwardsSearch) else { return false }\n                            ~~~~~~\
    \ ^~~~~~~~~~~~~\n/tmp/tmpvakun5rx.swift:12:65: error: cannot infer contextual\
    \ base in reference to member 'BackwardsSearch'\n    guard let openBracket = string.rangeOfString(\"\
    [\", options: .BackwardsSearch) else { return false }\n                      \
    \                                         ~^~~~~~~~~~~~~~~\n/tmp/tmpvakun5rx.swift:13:37:\
    \ error: value of type 'String' has no member 'rangeOfString'\n    guard let closeBracket\
    \ = string.rangeOfString(\"]\", options: .BackwardsSearch) else { return false\
    \ }\n                             ~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmpvakun5rx.swift:13:66:\
    \ error: cannot infer contextual base in reference to member 'BackwardsSearch'\n\
    \    guard let closeBracket = string.rangeOfString(\"]\", options: .BackwardsSearch)\
    \ else { return false }\n                                                    \
    \            ~^~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013960
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    func is_nested(string: String) -> Bool {\n    \n    var stack = [String]()\n \
    \   var open = 0\n    var close = 0\n    \n    for _ in string.unicodeScalars\
    \ {\n        if let c = string.unicodeScalars.next() {\n            switch c {\n\
    \            case .OpenSquareBracket:\n                open++\n            case\
    \ .CloseSquareBracket:\n                close++\n            case .OpenParenthesis:\n\
    \                stack.append(c)\n            case .CloseParenthesis:\n      \
    \          open--\n                if open < 0 {\n                    return false\n\
    \                }\n                close--\n            }\n        }\n    }\n\
    \    \n    return open >= 0 && close >= 0\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string: \"\
    []]]]]]][[[[[]\") == false)\nassert(is_nested(string: \"[][]\") == false)\nassert(is_nested(string:\
    \ \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]]]]]\") == false)\nassert(is_nested(string: \"[][][[]]\") == true)\n\
    assert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string: \"[]]\"\
    ) == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmp2j19xd_9.swift:18:42: error: value of type 'String.UnicodeScalarView'\
    \ has no member 'next'\n        if let c = string.unicodeScalars.next() {\n  \
    \                 ~~~~~~~~~~~~~~~~~~~~~ ^~~~\n/tmp/tmp2j19xd_9.swift:21:21: error:\
    \ cannot find operator '++' in scope; did you mean '+= 1'?\n                open++\n\
    \                    ^~\n/tmp/tmp2j19xd_9.swift:23:22: error: cannot find operator\
    \ '++' in scope; did you mean '+= 1'?\n                close++\n             \
    \        ^~\n/tmp/tmp2j19xd_9.swift:27:21: error: cannot find operator '--' in\
    \ scope; did you mean '-= 1'?\n                open--\n                    ^~\n\
    /tmp/tmp2j19xd_9.swift:31:22: error: cannot find operator '--' in scope; did you\
    \ mean '-= 1'?\n                close--\n                     ^~\n"
  stdout: ''
  timestamp: 1660013960
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    func is_nested(string: String) -> Bool {\n\tlet stack = Array<String>()\n\tlet\
    \ openingBrackets = Array<String>()\n\tlet closingBrackets = Array<String>()\n\
    \tlet openingBracketIndex = -1\n\tlet closingBracketIndex = -1\n\t\n\tlet openingBracketCount\
    \ = 1\n\tlet closingBracketCount = 1\n\t\n\tlet openingBracket = string[openingBracketIndex]\n\
    \tlet closingBracket = string[closingBracketIndex]\n\t\n\twhile openingBracket\
    \ != \"\" {\n\t\t\n\t\tif openingBracket == \"[\" {\n\t\t\topeningBracketCount\
    \ += 1\n\t\t\topeningBracketIndex = string.index(openingBracket, offsetBy: 1)\n\
    \t\t\topeningBracket = string[openingBracketIndex]\n\t\t}\n\t\t\n\t\tif openingBracket\
    \ == \"]\" {\n\t\t\topeningBracketCount -= 1\n\t\t\topeningBracketIndex = string.index(openingBracket,\
    \ offsetBy: 1)\n\t\t\topeningBracket = string[openingBracketIndex]\n\t\t}\n\t\t\
    \n\t\tif openingBracketCount < 0 {\n\t\t\topeningBracketIndex = string.index(openingBracket,\
    \ offsetBy: 1)\n\t\t\topeningBracket = string[openingBracketIndex]\n\t\t\topeningBracketCount\
    \ = 1\n\t\t}\n\t\t\n\t\tif closingBracket == \"[\" {\n\t\t\tclosingBracketCount\
    \ += 1\n\t\t\tclosingBracketIndex = string.index(closingBracket, offsetBy: 1)\n\
    \t\t\tclosingBracket = string[closingBracketIndex]\n\t\t}\n\t\t\n\t\tif closingBracket\
    \ == \"]\" {\n\t\t\tclosingBracketCount -= 1\n\t\t\tclosingBracketIndex = string.index(closingBracket,\
    \ offsetBy: 1)\n\t\t\tclosingBracket = string[closingBracketIndex]\n\t\t}\n\t\t\
    \n\t\tif closingBracketCount < 0 {\n\t\t\tclosingBracketIndex = string.index(closingBracket,\
    \ offsetBy: 1)\n\t\t\tclosingBracket = string[closingBracketIndex]\n\t\t\tclosingBracketCount\
    \ = 1\n\t\t}\n\t\t\n\t\tif openingBracketCount > 0 && closingBracketCount == 0\
    \ {\n\t\t\tstack.append(openingBracket)\n\t\t}\n\t\t\n\t\tif closingBracketCount\
    \ > 0 && openingBracketCount == 0 {\n\t\t\tstack.append(closingBracket)\n\t\t\
    }\n\t\t\n\t\tif openingBracketCount > 0 && closingBracketCount > 0 {\n\t\t\topeningBracketIndex\
    \ = string.index(openingBracket, offsetBy: 1)\n\t\t\tclosingBracketIndex = string.index(closing\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]][[[[[]\") == false)\nassert(is_nested(string: \"[][]\") == false)\n\
    assert(is_nested(string: \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\"\
    ) == true)\nassert(is_nested(string: \"[]]]]]]]]]]\") == false)\nassert(is_nested(string:\
    \ \"[][][[]]\") == true)\nassert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string:\
    \ \"[]]\") == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmpwnykcl1q.swift:73:1: error: expected ')' in expression list\n}\n\
    ^\n/tmp/tmpwnykcl1q.swift:72:38: note: to match this opening '('\n           \
    \             closingBracketIndex = string.index(closing\n                   \
    \                                       ^\n/tmp/tmpwnykcl1q.swift:101:47: error:\
    \ expected '}' at end of brace statement\nassert(is_nested(string: \"]]]]]]]]\"\
    ) == false)\n                                              ^\n/tmp/tmpwnykcl1q.swift:24:29:\
    \ note: to match this opening '{'\n        while openingBracket != \"\" {\n  \
    \                                 ^\n/tmp/tmpwnykcl1q.swift:101:47: error: expected\
    \ '}' at end of brace statement\nassert(is_nested(string: \"]]]]]]]]\") == false)\n\
    \                                              ^\n/tmp/tmpwnykcl1q.swift:11:40:\
    \ note: to match this opening '{'\nfunc is_nested(string: String) -> Bool {\n\
    \                                       ^\n/tmp/tmpwnykcl1q.swift:21:23: error:\
    \ 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index\
    \ instead.\n        let openingBracket = string[openingBracketIndex]\n       \
    \                      ^~~~~~~~~~~~~~~~~~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpwnykcl1q.swift:22:23: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        let closingBracket = string[closingBracketIndex]\n                  \
    \           ^~~~~~~~~~~~~~~~~~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpwnykcl1q.swift:24:26: error: cannot\
    \ convert value of type 'String' to expected argument type 'Character'\n     \
    \   while openingBracket != \"\" {\n                                ^\n/tmp/tmpwnykcl1q.swift:27:24:\
    \ error: left side of mutating operator isn't mutable: 'openingBracketCount' is\
    \ a 'let' constant\n                        openingBracketCount += 1\n       \
    \      "
  stdout: ''
  timestamp: 1660013960
- exit_code: -4
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    func is_nested(string: String) -> Bool {\n    guard let start = string.index(of:\
    \ \"[\"),\n        let end = string.index(of: \"]\"),\n        start != end,\n\
    \        start < string.endIndex,\n        end < string.endIndex,\n        start\
    \ < end else { return false }\n    let startIndex = string.index(before: start)\n\
    \    let endIndex = string.index(before: end)\n    let subsequence = string[startIndex..<endIndex]\n\
    \    return subsequence.contains(\"[\")\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string: \"[]]]]]]][[[[[]\"\
    ) == false)\nassert(is_nested(string: \"[][]\") == false)\nassert(is_nested(string:\
    \ \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]]]]]\") == false)\nassert(is_nested(string: \"[][][[]]\") == true)\n\
    assert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string: \"[]]\"\
    ) == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: Exception
  stderr: 'Swift/StringCharacterView.swift:93: Fatal error: String index is out of
    bounds

    Current stack trace:

    0    libswiftCore.so                    0x00002ae9baccec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae9ba9c5561 <unavailable> + 1434977

    2    libswiftCore.so                    0x00002ae9ba9c5286 <unavailable> + 1434246

    3    libswiftCore.so                    0x00002ae9ba9c513c <unavailable> + 1433916

    4    libswiftCore.so                    0x00002ae9ba9c4bb0 _assertionFailure(_:_:file:line:flags:)
    + 251

    5    libswiftCore.so                    0x00002ae9baaf86c9 <unavailable> + 2692809

    6    tmp8s_5b5fk                        0x000056141bf232be <unavailable> + 8894

    7    tmp8s_5b5fk                        0x000056141bf22686 <unavailable> + 5766

    8    libc.so.6                          0x00002ae9baeba460 __libc_start_main +
    245

    9    tmp8s_5b5fk                        0x000056141bf22389 <unavailable> + 5001

    '
  stdout: ''
  timestamp: 1660013961
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    func is_nested(string: String) -> Bool {\n\tlet brackets = string.replacingOccurrences(of:\
    \ \"[\", with: \"\").replacingOccurrences(of: \"]\", with: \"\")\n\tlet openBrackets\
    \ = brackets.replacingOccurrences(of: \"(\", with: \"\").replacingOccurrences(of:\
    \ \")\", with: \"\")\n\tlet closeBrackets = brackets.replacingOccurrences(of:\
    \ \"{\", with: \"\").replacingOccurrences(of: \"}\", with: \"\")\n\tlet openBracketsCount\
    \ = openBrackets.characters.count\n\tlet closeBracketsCount = closeBrackets.characters.count\n\
    \tlet openBracketsCount = openBracketsCount + closeBracketsCount - 1\n\tlet closeBracketsCount\
    \ = openBracketsCount + closeBracketsCount - 1\n\treturn openBracketsCount % 2\
    \ == 0 && closeBracketsCount % 2 == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string: \"[]]]]]]][[[[[]\"\
    ) == false)\nassert(is_nested(string: \"[][]\") == false)\nassert(is_nested(string:\
    \ \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]]]]]\") == false)\nassert(is_nested(string: \"[][][[]]\") == true)\n\
    assert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string: \"[]]\"\
    ) == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmpxl7j89ux.swift:12:24: error: value of type 'String' has no member\
    \ 'replacingOccurrences'\n        let brackets = string.replacingOccurrences(of:\
    \ \"[\", with: \"\").replacingOccurrences(of: \"]\", with: \"\")\n           \
    \            ~~~~~~ ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmpxl7j89ux.swift:17:44: error:\
    \ cannot convert value of type 'String' to expected argument type 'Int'\n    \
    \    let openBracketsCount = openBracketsCount + closeBracketsCount - 1\n    \
    \                                              ^\n/tmp/tmpxl7j89ux.swift:18:45:\
    \ error: cannot convert value of type 'String' to expected argument type 'Int'\n\
    \        let closeBracketsCount = openBracketsCount + closeBracketsCount - 1\n\
    \                                                   ^\n"
  stdout: ''
  timestamp: 1660013961
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    func is_nested(string: String) -> Bool {\n    guard let open = string.range(of:\
    \ \"[\"),\n        let close = string.range(of: \"]\"),\n        let open2 = string.range(of:\
    \ \"[\", options: .backwards),\n        let close2 = string.range(of: \"]\", options:\
    \ .backwards) else { return false }\n    return open != nil && close != nil &&\
    \ open2 != nil && close2 != nil && open2.lowerBound < close2.lowerBound\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]][[[[[]\") == false)\nassert(is_nested(string: \"[][]\") == false)\n\
    assert(is_nested(string: \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\"\
    ) == true)\nassert(is_nested(string: \"[]]]]]]]]]]\") == false)\nassert(is_nested(string:\
    \ \"[][][[]]\") == true)\nassert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string:\
    \ \"[]]\") == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmpa_v9424c.swift:12:29: error: value of type 'String' has no member\
    \ 'range'\n    guard let open = string.range(of: \"[\"),\n                   \
    \  ~~~~~~ ^~~~~\n/tmp/tmpa_v9424c.swift:13:28: error: value of type 'String' has\
    \ no member 'range'\n        let close = string.range(of: \"]\"),\n          \
    \          ~~~~~~ ^~~~~\n/tmp/tmpa_v9424c.swift:14:28: error: value of type 'String'\
    \ has no member 'range'\n        let open2 = string.range(of: \"[\", options:\
    \ .backwards),\n                    ~~~~~~ ^~~~~\n/tmp/tmpa_v9424c.swift:14:53:\
    \ error: cannot infer contextual base in reference to member 'backwards'\n   \
    \     let open2 = string.range(of: \"[\", options: .backwards),\n            \
    \                                       ~^~~~~~~~~\n/tmp/tmpa_v9424c.swift:15:29:\
    \ error: value of type 'String' has no member 'range'\n        let close2 = string.range(of:\
    \ \"]\", options: .backwards) else { return false }\n                     ~~~~~~\
    \ ^~~~~\n/tmp/tmpa_v9424c.swift:15:54: error: cannot infer contextual base in\
    \ reference to member 'backwards'\n        let close2 = string.range(of: \"]\"\
    , options: .backwards) else { return false }\n                               \
    \                     ~^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013962
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    func is_nested(string: String) -> Bool {\n    guard let start = string.index(of:\
    \ \"[\"),\n        let end = string.index(of: \"]\"),\n        let start = string.index(of:\
    \ \"[\", range: start..<end),\n        let end = string.index(of: \"]\", range:\
    \ start..<end),\n        let start = string.index(of: \"[\", range: start..<end),\n\
    \        let end = string.index(of: \"]\", range: start..<end),\n        let start\
    \ = string.index(of: \"[\", range: start..<end),\n        let end = string.index(of:\
    \ \"]\", range: start..<end),\n        let start = string.index(of: \"[\", range:\
    \ start..<end),\n        let end = string.index(of: \"]\", range: start..<end),\n\
    \        let start = string.index(of: \"[\", range: start..<end),\n        let\
    \ end = string.index(of: \"]\", range: start..<end),\n        let start = string.index(of:\
    \ \"[\", range: start..<end),\n        let end = string.index(of: \"]\", range:\
    \ start..<end),\n        let start = string.index(of: \"[\", range: start..<end),\n\
    \        let end = string.index(of: \"]\", range: start..<end),\n        let start\
    \ = string.index(of: \"[\", range: start..<end),\n        let end = string.index(of:\
    \ \"]\", range: start..<end),\n        let start = string.index(of: \"[\", range:\
    \ start..<end),\n        let end = string.index(of: \"]\", range: start..<end),\n\
    \        let start = string.index(of: \"[\", range: start..<end),\n        let\
    \ end = string.index(of: \"]\", range: start..<end),\n        let start = string.index(of:\
    \ \"[\", range: start..<end),\n        let end = string.index(of: \"]\", range:\
    \ start..<end),\n        let start = string.index(of: \"[\", range: start..<end),\n\
    \        let end = string.index(of: \"]\", range: start..<end),\n        let start\
    \ = string.index(of: \"[\", range: start..<end),\n        let end = string.index(of:\
    \ \"]\", range: start..<end),\n        let start = string.index(of: \"[\", range:\
    \ start..<end),\n        let end = string.index(of: \"]\", range: start..<end),\n\
    \        let start = string.index(of: \"[\", range: start..<end),\n        let\
    \ end = string.index(of: \"]\", range: start..<end),\n        let start = string.index(of:\
    \ \"[\", range: start.\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(is_nested(string:\
    \ \"[[]]\") == true)\nassert(is_nested(string: \"[]]]]]]][[[[[]\") == false)\n\
    assert(is_nested(string: \"[][]\") == false)\nassert(is_nested(string: \"[]\"\
    ) == false)\nassert(is_nested(string: \"[[[[]]]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]]]]]\") == false)\nassert(is_nested(string: \"[][][[]]\") == true)\n\
    assert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string: \"[]]\"\
    ) == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmpwmsls8_p.swift:44:55: error: expected member name following '.'\n\
    \        let start = string.index(of: \"[\", range: start.\n                 \
    \                                     ^\n/tmp/tmpwmsls8_p.swift:45:1: error: expected\
    \ ')' in expression list\n}\n^\n/tmp/tmpwmsls8_p.swift:44:33: note: to match this\
    \ opening '('\n        let start = string.index(of: \"[\", range: start.\n   \
    \                             ^\n/tmp/tmpwmsls8_p.swift:44:56: error: expected\
    \ 'else' after 'guard' condition\n        let start = string.index(of: \"[\",\
    \ range: start.\n                                                       ^\n/tmp/tmpwmsls8_p.swift:12:30:\
    \ warning: 'index(of:)' is deprecated: renamed to 'firstIndex(of:)'\n    guard\
    \ let start = string.index(of: \"[\"),\n                             ^\n/tmp/tmpwmsls8_p.swift:12:30:\
    \ note: use 'firstIndex(of:)' instead\n    guard let start = string.index(of:\
    \ \"[\"),\n                             ^~~~~\n                             firstIndex\n\
    /tmp/tmpwmsls8_p.swift:13:26: warning: 'index(of:)' is deprecated: renamed to\
    \ 'firstIndex(of:)'\n        let end = string.index(of: \"]\"),\n            \
    \             ^\n/tmp/tmpwmsls8_p.swift:13:26: note: use 'firstIndex(of:)' instead\n\
    \        let end = string.index(of: \"]\"),\n                         ^~~~~\n\
    \                         firstIndex\n/tmp/tmpwmsls8_p.swift:14:55: error: extra\
    \ argument 'range' in call\n        let start = string.index(of: \"[\", range:\
    \ start..<end),\n                                ~~~~~~~~~~~~~~~~~~~~~~^~~~~~~\n\
    /tmp/tmpwmsls8_p.swift:15:53: error: extra argument 'range' in call\n        let\
    \ end = string.index(of: \"]\", range: start..<end),\n                       \
    \       ~~~~~~~~~~~~~~~~~~~~~~^~~~~~~\n/tmp/tmpwmsls8_p.swift:16:55: error: extra\
    \ argument 'range' in call\n        let start = string.index(of: \"[\", range:\
    \ start..<end),\n                                ~~~~~~~~~~~~~~~~~~~~~~^~~~~~~\n\
    /tmp/tmpwmsls8_p.swift:17:53: error: extra argument 'range' in call\n        let\
    \ end = string.index(of: \"]\", range: start..<end),\n                       \
    \       ~~~~~~~~~~~~~~~~~~~~"
  stdout: ''
  timestamp: 1660013961
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    func is_nested(string: String) -> Bool {\n    guard let index = string.index(of:\
    \ \"[\"),\n        let end = string.index(of: \"]\", from: index) else {\n   \
    \     return false\n    }\n    guard let start = string.index(of: \"[\", from:\
    \ index),\n        let end = string.index(of: \"]\", from: end) else {\n     \
    \   return false\n    }\n    return string.distance(from: index, to: end) == 1\
    \ &&\n        string.distance(from: start, to: end) == 1 &&\n        string.distance(from:\
    \ start, to: index) == 1 &&\n        string.distance(from: end, to: index) ==\
    \ 1\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(is_nested(string: \"[[]]\") ==\
    \ true)\nassert(is_nested(string: \"[]]]]]]][[[[[]\") == false)\nassert(is_nested(string:\
    \ \"[][]\") == false)\nassert(is_nested(string: \"[]\") == false)\nassert(is_nested(string:\
    \ \"[[[[]]]]\") == true)\nassert(is_nested(string: \"[]]]]]]]]]]\") == false)\n\
    assert(is_nested(string: \"[][][[]]\") == true)\nassert(is_nested(string: \"[[]\"\
    ) == false)\nassert(is_nested(string: \"[]]\") == false)\nassert(is_nested(string:\
    \ \"[[]][[\") == true)\nassert(is_nested(string: \"[[][]]\") == true)\nassert(is_nested(string:\
    \ \"\") == false)\nassert(is_nested(string: \"[[[[[[[[\") == false)\nassert(is_nested(string:\
    \ \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmp3wr1gi7w.swift:12:30: warning: 'index(of:)' is deprecated: renamed\
    \ to 'firstIndex(of:)'\n    guard let index = string.index(of: \"[\"),\n     \
    \                        ^\n/tmp/tmp3wr1gi7w.swift:12:30: note: use 'firstIndex(of:)'\
    \ instead\n    guard let index = string.index(of: \"[\"),\n                  \
    \           ^~~~~\n                             firstIndex\n/tmp/tmp3wr1gi7w.swift:13:47:\
    \ error: extra argument 'from' in call\n        let end = string.index(of: \"\
    ]\", from: index) else {\n                              ~~~~~~~~~~~~~~~~^~~~~~\n\
    /tmp/tmp3wr1gi7w.swift:16:51: error: extra argument 'from' in call\n    guard\
    \ let start = string.index(of: \"[\", from: index),\n                        \
    \          ~~~~~~~~~~~~~~~~^~~~~~\n/tmp/tmp3wr1gi7w.swift:17:47: error: extra\
    \ argument 'from' in call\n        let end = string.index(of: \"]\", from: end)\
    \ else {\n                              ~~~~~~~~~~~~~~~~^~~~\n"
  stdout: ''
  timestamp: 1660013961
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    func is_nested(string: String) -> Bool {\n    let brackets = string.unicodeScalars.filter({\
    \ $0.isBr })\n    guard brackets.count > 0 else { return false }\n    let openBrackets\
    \ = brackets.filter({ $0.isBr })\n    guard openBrackets.count > 0 else { return\
    \ false }\n    let closeBrackets = brackets.filter({ !$0.isBr })\n    guard closeBrackets.count\
    \ > 0 else { return false }\n    let openBracketsCount = openBrackets.count\n\
    \    let closeBracketsCount = closeBrackets.count\n    let openBracketsNesting\
    \ = (openBracketsCount - closeBracketsCount) > 0\n    let closeBracketsNesting\
    \ = (openBracketsCount - closeBracketsCount) < 0\n    return openBracketsNesting\
    \ && closeBracketsNesting\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(is_nested(string:\
    \ \"[[]]\") == true)\nassert(is_nested(string: \"[]]]]]]][[[[[]\") == false)\n\
    assert(is_nested(string: \"[][]\") == false)\nassert(is_nested(string: \"[]\"\
    ) == false)\nassert(is_nested(string: \"[[[[]]]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]]]]]\") == false)\nassert(is_nested(string: \"[][][[]]\") == true)\n\
    assert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string: \"[]]\"\
    ) == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmpk6_g7u2x.swift:12:54: error: value of type 'Unicode.Scalar' has\
    \ no member 'isBr'\n    let brackets = string.unicodeScalars.filter({ $0.isBr\
    \ })\n                                                  ~~ ^~~~\n/tmp/tmpk6_g7u2x.swift:20:50:\
    \ error: cannot convert value of type 'Duration' to expected argument type 'Int'\n\
    \    let openBracketsNesting = (openBracketsCount - closeBracketsCount) > 0\n\
    \                                                 ^\n/tmp/tmpk6_g7u2x.swift:21:73:\
    \ error: binary operator '<' cannot be applied to operands of type 'Duration'\
    \ and 'Int'\n    let closeBracketsNesting = (openBracketsCount - closeBracketsCount)\
    \ < 0\n                               ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^ ~\n/tmp/tmpk6_g7u2x.swift:21:73: note: overloads for '<' exist with these\
    \ partially matching parameter lists: (Duration, Duration), (Int, Int)\n    let\
    \ closeBracketsNesting = (openBracketsCount - closeBracketsCount) < 0\n      \
    \                                                                  ^\n"
  stdout: ''
  timestamp: 1660013961
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    func is_nested(string: String) -> Bool {\n    guard let openBracket = string.rangeOfString(\"\
    [\", options: .LiteralSearch, range: nil, locale: nil) else {\n        return\
    \ false\n    }\n    guard let closeBracket = string.rangeOfString(\"]\", options:\
    \ .LiteralSearch, range: nil, locale: nil) else {\n        return false\n    }\n\
    \    guard openBracket.location != closeBracket.location else {\n        return\
    \ false\n    }\n    guard openBracket.location != string.endIndex else {\n   \
    \     return false\n    }\n    guard closeBracket.location != string.startIndex\
    \ else {\n        return false\n    }\n    guard openBracket.location < closeBracket.location\
    \ else {\n        return false\n    }\n    guard openBracket.location <= closeBracket.location\
    \ else {\n        return false\n    }\n    guard openBracket.location + 1 < closeBracket.location\
    \ else {\n        return false\n    }\n    guard openBracket.location + 1 == closeBracket.location\
    \ + 1 else {\n        return false\n    }\n    guard openBracket.location + 2\
    \ < closeBracket.location else {\n        return false\n    }\n    guard openBracket.location\
    \ + 2 == closeBracket.location + 2 else {\n        return false\n    }\n    guard\
    \ openBracket.location + 3 < closeBracket.location else {\n        return false\n\
    \    }\n    guard openBracket.location + 3 == closeBracket.location + 3 else {\n\
    \        return false\n    }\n    guard openBracket.location + 4 < closeBracket.location\
    \ else {\n        return false\n    }\n    guard openBracket.location + 4 == closeBracket.location\
    \ + 4 else {\n        return false\n    }\n    guard openBracket.location + 5\
    \ < closeBracket.location else {\n        return false\n    }\n    guard openBracket.location\
    \ + 5 == closeBracket.location + 5 else {\n        return false\n    }\n    guard\
    \ openBracket.location + 6 < closeBracket.location else {\n        return false\n\
    \    }\n    guard openBracket.location + 6 == closeBracket.location + 6 else {\n\
    \        return false\n    }\n    guard openBracket.location + 7 < closeBracket.location\
    \ else {\n        return false\n    }\n    guard openBracket.location + 7 == closeBracket.location\
    \ + 7 else {\n        return false\n    }\n    guard openBracket.location + 8\
    \ < closeBra\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(is_nested(string:\
    \ \"[[]]\") == true)\nassert(is_nested(string: \"[]]]]]]][[[[[]\") == false)\n\
    assert(is_nested(string: \"[][]\") == false)\nassert(is_nested(string: \"[]\"\
    ) == false)\nassert(is_nested(string: \"[[[[]]]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]]]]]\") == false)\nassert(is_nested(string: \"[][][[]]\") == true)\n\
    assert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string: \"[]]\"\
    ) == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmpc1a0neyz.swift:75:46: error: expected 'else' after 'guard' condition\n\
    \    guard openBracket.location + 8 < closeBra\n                             \
    \                ^\n/tmp/tmpc1a0neyz.swift:12:36: error: value of type 'String'\
    \ has no member 'rangeOfString'\n    guard let openBracket = string.rangeOfString(\"\
    [\", options: .LiteralSearch, range: nil, locale: nil) else {\n              \
    \              ~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmpc1a0neyz.swift:12:65: error: cannot\
    \ infer contextual base in reference to member 'LiteralSearch'\n    guard let\
    \ openBracket = string.rangeOfString(\"[\", options: .LiteralSearch, range: nil,\
    \ locale: nil) else {\n                                                      \
    \         ~^~~~~~~~~~~~~\n/tmp/tmpc1a0neyz.swift:12:87: error: 'nil' requires\
    \ a contextual type\n    guard let openBracket = string.rangeOfString(\"[\", options:\
    \ .LiteralSearch, range: nil, locale: nil) else {\n                          \
    \                                                            ^\n/tmp/tmpc1a0neyz.swift:12:100:\
    \ error: 'nil' requires a contextual type\n    guard let openBracket = string.rangeOfString(\"\
    [\", options: .LiteralSearch, range: nil, locale: nil) else {\n              \
    \                                                                            \
    \         ^\n/tmp/tmpc1a0neyz.swift:15:37: error: value of type 'String' has no\
    \ member 'rangeOfString'\n    guard let closeBracket = string.rangeOfString(\"\
    ]\", options: .LiteralSearch, range: nil, locale: nil) else {\n              \
    \               ~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmpc1a0neyz.swift:15:66: error: cannot\
    \ infer contextual base in reference to member 'LiteralSearch'\n    guard let\
    \ closeBracket = string.rangeOfString(\"]\", options: .LiteralSearch, range: nil,\
    \ locale: nil) else {\n                                                      \
    \          ~^~~~~~~~~~~~~\n/tmp/tmpc1a0neyz.swift:15:88: error: 'nil' requires\
    \ a contextual type\n    guard let closeBracket = string.rangeOfString(\"]\",\
    \ options: .LiteralSearch, range: nil, locale: nil) else {\n                 \
    \                                   "
  stdout: ''
  timestamp: 1660013966
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    func is_nested(string: String) -> Bool {\n    guard let start = string.index(of:\
    \ \"[\"),\n        let end = string.index(of: \"]\"),\n        start < end else\
    \ {\n            return false\n    }\n    \n    var stack = [String]()\n    stack.append(string[start..<end])\n\
    \    \n    while let top = stack.removeLast() {\n        if let next = stack.removeLast()\
    \ {\n            if next == \"[\" {\n                stack.append(next)\n    \
    \        } else if next == \"]\" {\n                if stack.isEmpty {\n     \
    \               return false\n                }\n                stack.append(next)\n\
    \            } else {\n                return false\n            }\n        }\
    \ else {\n            return false\n        }\n    }\n    \n    return stack.isEmpty\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]][[[[[]\") == false)\nassert(is_nested(string: \"[][]\") == false)\n\
    assert(is_nested(string: \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\"\
    ) == true)\nassert(is_nested(string: \"[]]]]]]]]]]\") == false)\nassert(is_nested(string:\
    \ \"[][][[]]\") == true)\nassert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string:\
    \ \"[]]\") == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmpp47e1hdb.swift:12:30: warning: 'index(of:)' is deprecated: renamed\
    \ to 'firstIndex(of:)'\n    guard let start = string.index(of: \"[\"),\n     \
    \                        ^\n/tmp/tmpp47e1hdb.swift:12:30: note: use 'firstIndex(of:)'\
    \ instead\n    guard let start = string.index(of: \"[\"),\n                  \
    \           ^~~~~\n                             firstIndex\n/tmp/tmpp47e1hdb.swift:13:26:\
    \ warning: 'index(of:)' is deprecated: renamed to 'firstIndex(of:)'\n        let\
    \ end = string.index(of: \"]\"),\n                         ^\n/tmp/tmpp47e1hdb.swift:13:26:\
    \ note: use 'firstIndex(of:)' instead\n        let end = string.index(of: \"]\"\
    ),\n                         ^~~~~\n                         firstIndex\n/tmp/tmpp47e1hdb.swift:19:24:\
    \ error: subscript 'subscript(_:)' requires the types 'String.Index' and 'Int'\
    \ be equivalent\n    stack.append(string[start..<end])\n                     \
    \  ^\nSwift.String:5:12: note: where 'R.Bound' = 'String.Index'\n    public subscript<R>(bounds:\
    \ R) -> String where R : RangeExpression, R.Bound == Int { get }\n           ^\n\
    /tmp/tmpp47e1hdb.swift:22:12: error: initializer for conditional binding must\
    \ have Optional type, not 'String'\n        if let next = stack.removeLast() {\n\
    \           ^          ~~~~~~~~~~~~~~~~~~\n/tmp/tmpp47e1hdb.swift:21:11: error:\
    \ initializer for conditional binding must have Optional type, not 'String'\n\
    \    while let top = stack.removeLast() {\n          ^         ~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013961
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    func is_nested(string: String) -> Bool {\n\tlet openingBrackets = string.rangeOfString(\"\
    [\")\n\tlet closingBrackets = string.rangeOfString(\"]\")\n\t\n\tif openingBrackets\
    \ == nil || closingBrackets == nil {\n\t\treturn false\n\t}\n\t\n\tlet openingBracketsCount\
    \ = openingBrackets?.endIndex - openingBrackets?.startIndex\n\tlet closingBracketsCount\
    \ = closingBrackets?.endIndex - closingBrackets?.startIndex\n\t\n\tif openingBracketsCount\
    \ != closingBracketsCount {\n\t\treturn false\n\t}\n\t\n\tlet openingBracketsString\
    \ = string.substringWithRange(openingBrackets!)\n\tlet closingBracketsString =\
    \ string.substringWithRange(closingBrackets!)\n\t\n\treturn openingBracketsString.rangeOfString(\"\
    [\", options: .BackwardsSearch) != nil\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string: \"[]]]]]]][[[[[]\"\
    ) == false)\nassert(is_nested(string: \"[][]\") == false)\nassert(is_nested(string:\
    \ \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]]]]]\") == false)\nassert(is_nested(string: \"[][][[]]\") == true)\n\
    assert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string: \"[]]\"\
    ) == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmplr37q4al.swift:12:31: error: value of type 'String' has no member\
    \ 'rangeOfString'\n        let openingBrackets = string.rangeOfString(\"[\")\n\
    \                              ~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmplr37q4al.swift:13:31:\
    \ error: value of type 'String' has no member 'rangeOfString'\n        let closingBrackets\
    \ = string.rangeOfString(\"]\")\n                              ~~~~~~ ^~~~~~~~~~~~~\n\
    /tmp/tmplr37q4al.swift:19:55: error: binary operator '-' cannot be applied to\
    \ two 'Duration?' operands\n        let openingBracketsCount = openingBrackets?.endIndex\
    \ - openingBrackets?.startIndex\n                                   ~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^ ~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmplr37q4al.swift:19:55: note: overloads\
    \ for '-' exist with these partially matching parameter lists: (ContinuousClock.Instant,\
    \ ContinuousClock.Instant), (ContinuousClock.Instant, Duration), (Double, Double),\
    \ (Duration, Duration), (Float, Float), (Float16, Float16), (Float80, Float80),\
    \ (Int, Int), (Int16, Int16), (Int32, Int32), (Int64, Int64), (Int8, Int8), (SuspendingClock.Instant,\
    \ Duration), (SuspendingClock.Instant, SuspendingClock.Instant), (UInt, UInt),\
    \ (UInt16, UInt16), (UInt32, UInt32), (UInt64, UInt64), (UInt8, UInt8)\n     \
    \   let openingBracketsCount = openingBrackets?.endIndex - openingBrackets?.startIndex\n\
    \                                                             ^\n/tmp/tmplr37q4al.swift:20:55:\
    \ error: binary operator '-' cannot be applied to two 'Duration?' operands\n \
    \       let closingBracketsCount = closingBrackets?.endIndex - closingBrackets?.startIndex\n\
    \                                   ~~~~~~~~~~~~~~~~~~~~~~~~~ ^ ~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmplr37q4al.swift:20:55: note: overloads for '-' exist with these partially\
    \ matching parameter lists: (ContinuousClock.Instant, ContinuousClock.Instant),\
    \ (ContinuousClock.Instant, Duration), (Double, Double), (Duration, Duration),\
    \ (Float, Float), (Float16, Float16), (Float80, Float80), (Int, Int), (Int16,\
    \ Int16), (Int32, Int32), (Int64, Int64), (Int8, Int8), (SuspendingClock.Instant, "
  stdout: ''
  timestamp: 1660013961
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    func is_nested(string: String) -> Bool {\n    var stack = [String]()\n    var\
    \ openBrackets = 0\n    var openBracketsCount = 0\n    var openBracketsCountMax\
    \ = 1000\n    var openBracketsCountMax2 = 1000\n    var openBracketsCountMax3\
    \ = 1000\n    var openBracketsCountMax4 = 1000\n    var openBracketsCountMax5\
    \ = 1000\n    var openBracketsCountMax6 = 1000\n    var openBracketsCountMax7\
    \ = 1000\n    var openBracketsCountMax8 = 1000\n    var openBracketsCountMax9\
    \ = 1000\n    var openBracketsCountMax10 = 1000\n    var openBracketsCountMax11\
    \ = 1000\n    var openBracketsCountMax12 = 1000\n    var openBracketsCountMax13\
    \ = 1000\n    var openBracketsCountMax14 = 1000\n    var openBracketsCountMax15\
    \ = 1000\n    var openBracketsCountMax16 = 1000\n    var openBracketsCountMax17\
    \ = 1000\n    var openBracketsCountMax18 = 1000\n    var openBracketsCountMax19\
    \ = 1000\n    var openBracketsCountMax20 = 1000\n    var openBracketsCountMax21\
    \ = 1000\n    var openBracketsCountMax22 = 1000\n    var openBracketsCountMax23\
    \ = 1000\n    var openBracketsCountMax24 = 1000\n    var openBracketsCountMax25\
    \ = 1000\n    var openBracketsCountMax26 = 1000\n    var openBracketsCountMax27\
    \ = 1000\n    var openBracketsCountMax28 = 1000\n    var openBracketsCountMax29\
    \ = 1000\n    var openBracketsCountMax30 = 1000\n    var openBracketsCountMax31\
    \ = 1000\n    var openBracketsCountMax32 = 1000\n    var openBracketsCountMax33\
    \ = 1000\n    var openBracketsCountMax34 = 1000\n    var openBracketsCountMax35\
    \ = 1000\n    var openBracketsCountMax36 = 1000\n    var openBracketsCountMax37\
    \ = 1000\n    var openBracketsCountMax38 = 1000\n    var openBracketsCountMax39\
    \ = 1000\n    var openBracketsCountMax40 = 1000\n    var openBracketsCountMax41\
    \ = 1000\n    var openBracketsCountMax42 = 1000\n    var openBracketsCountMax43\
    \ = 1000\n    var openBracketsCountMax44 = 1000\n    var openBracketsCountMax45\
    \ = 1000\n    var openBracketsCountMax4\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string: \"[]]]]]]][[[[[]\"\
    ) == false)\nassert(is_nested(string: \"[][]\") == false)\nassert(is_nested(string:\
    \ \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]]]]]\") == false)\nassert(is_nested(string: \"[][][[]]\") == true)\n\
    assert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string: \"[]]\"\
    ) == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmp7oz1ukv7.swift:60:9: error: type annotation missing in pattern\n\
    \    var openBracketsCountMax4\n        ^\n"
  stdout: ''
  timestamp: 1660013961
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    func is_nested(string: String) -> Bool {\n    let stack = Stack()\n    for char\
    \ in string {\n        if char == '[' {\n            stack.push(char)\n      \
    \  } else if char == ']' {\n            if stack.top() == '[' {\n            \
    \    stack.pop()\n            } else {\n                return false\n       \
    \     }\n        } else {\n            return false\n        }\n    }\n    return\
    \ stack.empty()\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(is_nested(string:\
    \ \"[[]]\") == true)\nassert(is_nested(string: \"[]]]]]]][[[[[]\") == false)\n\
    assert(is_nested(string: \"[][]\") == false)\nassert(is_nested(string: \"[]\"\
    ) == false)\nassert(is_nested(string: \"[[[[]]]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]]]]]\") == false)\nassert(is_nested(string: \"[][][[]]\") == true)\n\
    assert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string: \"[]]\"\
    ) == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmpghzat_c6.swift:14:20: error: single-quoted string literal found,\
    \ use '\"'\n        if char == '[' {\n                   ^~~\n               \
    \    \"[\"\n/tmp/tmpghzat_c6.swift:16:27: error: single-quoted string literal\
    \ found, use '\"'\n        } else if char == ']' {\n                         \
    \ ^~~\n                          \"]\"\n/tmp/tmpghzat_c6.swift:17:31: error: single-quoted\
    \ string literal found, use '\"'\n            if stack.top() == '[' {\n      \
    \                        ^~~\n                              \"[\"\n/tmp/tmpghzat_c6.swift:12:17:\
    \ error: cannot find 'Stack' in scope\n    let stack = Stack()\n             \
    \   ^~~~~\n"
  stdout: ''
  timestamp: 1660013960
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    func is_nested(string: String) -> Bool {\n    var stack = [String]()\n    var\
    \ openBrackets = 0\n    for char in string {\n        if char == '[' {\n     \
    \       stack.append(char)\n            openBrackets += 1\n        } else if char\
    \ == ']' {\n            if openBrackets > 0 {\n                openBrackets -=\
    \ 1\n            } else {\n                return false\n            }\n     \
    \   } else {\n            if openBrackets > 0 {\n                return false\n\
    \            }\n        }\n    }\n    return openBrackets == 0\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]][[[[[]\") == false)\nassert(is_nested(string: \"[][]\") == false)\n\
    assert(is_nested(string: \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\"\
    ) == true)\nassert(is_nested(string: \"[]]]]]]]]]]\") == false)\nassert(is_nested(string:\
    \ \"[][][[]]\") == true)\nassert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string:\
    \ \"[]]\") == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmpaf5oaj_b.swift:15:20: error: single-quoted string literal found,\
    \ use '\"'\n        if char == '[' {\n                   ^~~\n               \
    \    \"[\"\n/tmp/tmpaf5oaj_b.swift:18:27: error: single-quoted string literal\
    \ found, use '\"'\n        } else if char == ']' {\n                         \
    \ ^~~\n                          \"]\"\n/tmp/tmpaf5oaj_b.swift:16:26: error: cannot\
    \ convert value of type 'Character' to expected argument type 'String'\n     \
    \       stack.append(char)\n                         ^\n"
  stdout: ''
  timestamp: 1660013961
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    func is_nested(string: String) -> Bool {\n    guard let open = string.rangeOfString(\"\
    [\", options: .LiteralSearch, range: nil, locale: nil),\n        let close = string.rangeOfString(\"\
    ]\", options: .LiteralSearch, range: nil, locale: nil) else {\n            return\
    \ false\n    }\n    let start = open.location\n    let end = close.location\n\
    \    let range = start..<end\n    let nested = string.rangeOfString(\"[\", options:\
    \ .LiteralSearch, range: range, locale: nil)\n    return nested != nil\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]][[[[[]\") == false)\nassert(is_nested(string: \"[][]\") == false)\n\
    assert(is_nested(string: \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\"\
    ) == true)\nassert(is_nested(string: \"[]]]]]]]]]]\") == false)\nassert(is_nested(string:\
    \ \"[][][[]]\") == true)\nassert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string:\
    \ \"[]]\") == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmp_hk94ile.swift:12:29: error: value of type 'String' has no member\
    \ 'rangeOfString'\n    guard let open = string.rangeOfString(\"[\", options: .LiteralSearch,\
    \ range: nil, locale: nil),\n                     ~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp_hk94ile.swift:12:58:\
    \ error: cannot infer contextual base in reference to member 'LiteralSearch'\n\
    \    guard let open = string.rangeOfString(\"[\", options: .LiteralSearch, range:\
    \ nil, locale: nil),\n                                                       \
    \ ~^~~~~~~~~~~~~\n/tmp/tmp_hk94ile.swift:12:80: error: 'nil' requires a contextual\
    \ type\n    guard let open = string.rangeOfString(\"[\", options: .LiteralSearch,\
    \ range: nil, locale: nil),\n                                                \
    \                               ^\n/tmp/tmp_hk94ile.swift:12:93: error: 'nil'\
    \ requires a contextual type\n    guard let open = string.rangeOfString(\"[\"\
    , options: .LiteralSearch, range: nil, locale: nil),\n                       \
    \                                                                     ^\n/tmp/tmp_hk94ile.swift:13:28:\
    \ error: value of type 'String' has no member 'rangeOfString'\n        let close\
    \ = string.rangeOfString(\"]\", options: .LiteralSearch, range: nil, locale: nil)\
    \ else {\n                    ~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp_hk94ile.swift:13:57:\
    \ error: cannot infer contextual base in reference to member 'LiteralSearch'\n\
    \        let close = string.rangeOfString(\"]\", options: .LiteralSearch, range:\
    \ nil, locale: nil) else {\n                                                 \
    \      ~^~~~~~~~~~~~~\n/tmp/tmp_hk94ile.swift:13:79: error: 'nil' requires a contextual\
    \ type\n        let close = string.rangeOfString(\"]\", options: .LiteralSearch,\
    \ range: nil, locale: nil) else {\n                                          \
    \                                    ^\n/tmp/tmp_hk94ile.swift:13:92: error: 'nil'\
    \ requires a contextual type\n        let close = string.rangeOfString(\"]\",\
    \ options: .LiteralSearch, range: nil, locale: nil) else {\n                 \
    \                                                                          ^\n\
    /t"
  stdout: ''
  timestamp: 1660013961
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    func is_nested(string: String) -> Bool {\n    var stack = [String]()\n    var\
    \ openingBrackets = 0\n    var closingBrackets = 0\n    for char in string {\n\
    \        if char == '[' {\n            openingBrackets += 1\n            stack.append(char)\n\
    \        } else if char == ']' {\n            closingBrackets += 1\n         \
    \   if closingBrackets > openingBrackets {\n                stack.removeLast()\n\
    \            }\n        } else if char == '[' {\n            openingBrackets +=\
    \ 1\n        } else if char == ']' {\n            closingBrackets += 1\n     \
    \   }\n    }\n    return openingBrackets == closingBrackets\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]][[[[[]\") == false)\nassert(is_nested(string: \"[][]\") == false)\n\
    assert(is_nested(string: \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\"\
    ) == true)\nassert(is_nested(string: \"[]]]]]]]]]]\") == false)\nassert(is_nested(string:\
    \ \"[][][[]]\") == true)\nassert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string:\
    \ \"[]]\") == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmp6vk1rzim.swift:16:20: error: single-quoted string literal found,\
    \ use '\"'\n        if char == '[' {\n                   ^~~\n               \
    \    \"[\"\n/tmp/tmp6vk1rzim.swift:19:27: error: single-quoted string literal\
    \ found, use '\"'\n        } else if char == ']' {\n                         \
    \ ^~~\n                          \"]\"\n/tmp/tmp6vk1rzim.swift:24:27: error: single-quoted\
    \ string literal found, use '\"'\n        } else if char == '[' {\n          \
    \                ^~~\n                          \"[\"\n/tmp/tmp6vk1rzim.swift:26:27:\
    \ error: single-quoted string literal found, use '\"'\n        } else if char\
    \ == ']' {\n                          ^~~\n                          \"]\"\n/tmp/tmp6vk1rzim.swift:18:26:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            stack.append(char)\n                         ^\n"
  stdout: ''
  timestamp: 1660013961
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    func is_nested(string: String) -> Bool {\n    let brackets = string.unicodeScalars\n\
    \        .filter({$0.isASCII})\n        .filter({$0.isNotASCII})\n        .filter({$0.isIn(\"\
    []\")})\n        .filter({$0.isNotIn(\"[]\")})\n        .filter({$0.isIn(\"()\"\
    )})\n        .filter({$0.isNotIn(\"()\")})\n        .filter({$0.isIn(\"{}\")})\n\
    \        .filter({$0.isNotIn(\"{}\")})\n        .filter({$0.isIn(\"<>\")})\n \
    \       .filter({$0.isNotIn(\"<>\")})\n        .filter({$0.isIn(\"()<>\")})\n\
    \        .filter({$0.isNotIn(\"()<>\")})\n        .filter({$0.isIn(\"{}<>\")})\n\
    \        .filter({$0.isNotIn(\"{}<>\")})\n        .filter({$0.isIn(\"[]<>\")})\n\
    \        .filter({$0.isNotIn(\"[]<>\")})\n        .filter({$0.isIn(\"()[]<>\"\
    )})\n        .filter({$0.isNotIn(\"()[]<>\")})\n        .filter({$0.isIn(\"{}[]<>\"\
    )})\n        .filter({$0.isNotIn(\"{}[]<>\")})\n        .filter({$0.isIn(\"<>[]\"\
    )})\n        .filter({$0.isNotIn(\"<>[]\")})\n        .filter({$0.isIn(\"()<>[]\"\
    )})\n        .filter({$0.isNotIn(\"()<>[]\")})\n        .filter({$0.isIn(\"{}<>[]\"\
    )})\n        .filter({$0.isNotIn(\"{}<>[]\")})\n        .filter({$0.isIn(\"[][]<>\"\
    )})\n        .filter({$0.isNotIn(\"[][]<>\")})\n        .filter({$0.isIn(\"()[][]<>\"\
    )})\n        .filter({$0.isNotIn(\"()[][]<>\")})\n        .filter({$0.isIn(\"\
    {}[][]<>\")})\n        .filter({$0.isNotIn(\"{}[][]<>\")})\n        .filter({$0.isIn(\"\
    <>{}\")})\n        .filter({$0.isNotIn(\"<>{}\")})\n        .filter({$0.isIn(\"\
    ()<>{}\")})\n        .filter({$0.isNotIn(\"()<>{}\")})\n        .filter({$0.isIn(\"\
    {}<>{}\")})\n\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(is_nested(string:\
    \ \"[[]]\") == true)\nassert(is_nested(string: \"[]]]]]]][[[[[]\") == false)\n\
    assert(is_nested(string: \"[][]\") == false)\nassert(is_nested(string: \"[]\"\
    ) == false)\nassert(is_nested(string: \"[[[[]]]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]]]]]\") == false)\nassert(is_nested(string: \"[][][[]]\") == true)\n\
    assert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string: \"[]]\"\
    ) == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmp3shynccq.swift:12:20: error: the compiler is unable to type-check\
    \ this expression in reasonable time; try breaking up the expression into distinct\
    \ sub-expressions\n    let brackets = string.unicodeScalars\n                \
    \   ^~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013993
- exit_code: -4
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    func is_nested(string: String) -> Bool {\n    \n    // Your code here\n    \n\
    \    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(is_nested(string:\
    \ \"[[]]\") == true)\nassert(is_nested(string: \"[]]]]]]][[[[[]\") == false)\n\
    assert(is_nested(string: \"[][]\") == false)\nassert(is_nested(string: \"[]\"\
    ) == false)\nassert(is_nested(string: \"[[[[]]]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]]]]]\") == false)\nassert(is_nested(string: \"[][][[]]\") == true)\n\
    assert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string: \"[]]\"\
    ) == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: Exception
  stderr: 'tmp4fbozzey/tmp4fbozzey.swift:32: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af698c96c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af69898db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af69898d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af69898c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp4fbozzey                        0x000056101a6522fb <unavailable> + 4859

    5    libc.so.6                          0x00002af698e82460 __libc_start_main +
    245

    6    tmp4fbozzey                        0x000056101a651ee9 <unavailable> + 3817

    '
  stdout: ''
  timestamp: 1660013961
- exit_code: -4
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    func is_nested(string: String) -> Bool {\n    \n    // Your code here\n    \n\
    \    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(is_nested(string:\
    \ \"[[]]\") == true)\nassert(is_nested(string: \"[]]]]]]][[[[[]\") == false)\n\
    assert(is_nested(string: \"[][]\") == false)\nassert(is_nested(string: \"[]\"\
    ) == false)\nassert(is_nested(string: \"[[[[]]]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]]]]]\") == false)\nassert(is_nested(string: \"[][][[]]\") == true)\n\
    assert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string: \"[]]\"\
    ) == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: Exception
  stderr: 'tmp4fbozzey/tmp4fbozzey.swift:32: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af698c96c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af69898db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af69898d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af69898c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp4fbozzey                        0x000056101a6522fb <unavailable> + 4859

    5    libc.so.6                          0x00002af698e82460 __libc_start_main +
    245

    6    tmp4fbozzey                        0x000056101a651ee9 <unavailable> + 3817

    '
  stdout: ''
  timestamp: 1660013961
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    func is_nested(string: String) -> Bool {\n    guard let start = string.index(of:\
    \ \"[\"),\n        let end = string.index(of: \"]\", in: start) else {\n     \
    \       return false\n    }\n    guard let nested = string.substring(from: start\
    \ + 1, to: end) else {\n        return false\n    }\n    guard let nested2 = string.substring(from:\
    \ start + 1, to: nested) else {\n        return false\n    }\n    return is_nested(nested2)\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]][[[[[]\") == false)\nassert(is_nested(string: \"[][]\") == false)\n\
    assert(is_nested(string: \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\"\
    ) == true)\nassert(is_nested(string: \"[]]]]]]]]]]\") == false)\nassert(is_nested(string:\
    \ \"[][][[]]\") == true)\nassert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string:\
    \ \"[]]\") == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmpbra3_ibv.swift:12:30: warning: 'index(of:)' is deprecated: renamed\
    \ to 'firstIndex(of:)'\n    guard let start = string.index(of: \"[\"),\n     \
    \                        ^\n/tmp/tmpbra3_ibv.swift:12:30: note: use 'firstIndex(of:)'\
    \ instead\n    guard let start = string.index(of: \"[\"),\n                  \
    \           ^~~~~\n                             firstIndex\n/tmp/tmpbra3_ibv.swift:13:45:\
    \ error: extra argument 'in' in call\n        let end = string.index(of: \"]\"\
    , in: start) else {\n                              ~~~~~~~~~~~~~~^~~~~~\n/tmp/tmpbra3_ibv.swift:16:47:\
    \ error: cannot convert value of type 'String.Index' to expected argument type\
    \ 'Int'\n    guard let nested = string.substring(from: start + 1, to: end) else\
    \ {\n                                              ^\n/tmp/tmpbra3_ibv.swift:16:31:\
    \ error: value of type 'String' has no member 'substring'\n    guard let nested\
    \ = string.substring(from: start + 1, to: end) else {\n                      \
    \ ~~~~~~ ^~~~~~~~~\n/tmp/tmpbra3_ibv.swift:19:48: error: cannot convert value\
    \ of type 'String.Index' to expected argument type 'Int'\n    guard let nested2\
    \ = string.substring(from: start + 1, to: nested) else {\n                   \
    \                            ^\n/tmp/tmpbra3_ibv.swift:19:32: error: value of\
    \ type 'String' has no member 'substring'\n    guard let nested2 = string.substring(from:\
    \ start + 1, to: nested) else {\n                        ~~~~~~ ^~~~~~~~~\n/tmp/tmpbra3_ibv.swift:22:22:\
    \ error: missing argument label 'string:' in call\n    return is_nested(nested2)\n\
    \                     ^\n                     string: \n"
  stdout: ''
  timestamp: 1660013961
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    func is_nested(string: String) -> Bool {\n    var stack = [String]()\n    var\
    \ opening = false\n    for char in string {\n        if char == '[' {\n      \
    \      opening = true\n        } else if char == ']' {\n            opening =\
    \ false\n        } else if opening {\n            stack.append(char)\n       \
    \ }\n    }\n    return stack.count == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string: \"[]]]]]]][[[[[]\"\
    ) == false)\nassert(is_nested(string: \"[][]\") == false)\nassert(is_nested(string:\
    \ \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]]]]]\") == false)\nassert(is_nested(string: \"[][][[]]\") == true)\n\
    assert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string: \"[]]\"\
    ) == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmpmhzn1r_5.swift:15:20: error: single-quoted string literal found,\
    \ use '\"'\n        if char == '[' {\n                   ^~~\n               \
    \    \"[\"\n/tmp/tmpmhzn1r_5.swift:17:27: error: single-quoted string literal\
    \ found, use '\"'\n        } else if char == ']' {\n                         \
    \ ^~~\n                          \"]\"\n/tmp/tmpmhzn1r_5.swift:20:26: error: cannot\
    \ convert value of type 'Character' to expected argument type 'String'\n     \
    \       stack.append(char)\n                         ^\n"
  stdout: ''
  timestamp: 1660013961
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    func is_nested(string: String) -> Bool {\n    var stack = [String]()\n    var\
    \ openingBrackets = 0\n    for index in 0..<string.characters.count {\n      \
    \  let character = string.characters[index]\n        if character == '[' {\n \
    \           stack.append(character)\n            openingBrackets += 1\n      \
    \  } else if character == ']' {\n            openingBrackets -= 1\n          \
    \  if openingBrackets == 0 {\n                stack.removeLast()\n           \
    \ }\n        }\n    }\n    return openingBrackets == 0\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]][[[[[]\") == false)\nassert(is_nested(string: \"[][]\") == false)\n\
    assert(is_nested(string: \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\"\
    ) == true)\nassert(is_nested(string: \"[]]]]]]]]]]\") == false)\nassert(is_nested(string:\
    \ \"[][][[]]\") == true)\nassert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string:\
    \ \"[]]\") == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmph62hm1y7.swift:16:25: error: single-quoted string literal found,\
    \ use '\"'\n        if character == '[' {\n                        ^~~\n     \
    \                   \"[\"\n/tmp/tmph62hm1y7.swift:19:32: error: single-quoted\
    \ string literal found, use '\"'\n        } else if character == ']' {\n     \
    \                          ^~~\n                               \"]\"\n/tmp/tmph62hm1y7.swift:14:29:\
    \ error: 'characters' is unavailable: Please use String directly\n    for index\
    \ in 0..<string.characters.count {\n                            ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmph62hm1y7.swift:15:25: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        let character = string.characters[index]\n                        ^~~~~~~~~~~~~~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmph62hm1y7.swift:15:32:\
    \ error: 'characters' is unavailable: Please use String directly\n        let\
    \ character = string.characters[index]\n                               ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmph62hm1y7.swift:17:26:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            stack.append(character)\n                         ^\n"
  stdout: ''
  timestamp: 1660013961
- exit_code: -4
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    func is_nested(string: String) -> Bool {\n    \n    // Your code here\n    \n\
    \    return false\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(is_nested(string:\
    \ \"[[]]\") == true)\nassert(is_nested(string: \"[]]]]]]][[[[[]\") == false)\n\
    assert(is_nested(string: \"[][]\") == false)\nassert(is_nested(string: \"[]\"\
    ) == false)\nassert(is_nested(string: \"[[[[]]]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]]]]]\") == false)\nassert(is_nested(string: \"[][][[]]\") == true)\n\
    assert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string: \"[]]\"\
    ) == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: Exception
  stderr: 'tmpghpah9e9/tmpghpah9e9.swift:31: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab009692c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab009389b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab009389988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab0093887b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpghpah9e9                        0x000055d6f6afa25b <unavailable> + 4699

    5    libc.so.6                          0x00002ab00987e460 __libc_start_main +
    245

    6    tmpghpah9e9                        0x000055d6f6af9ee9 <unavailable> + 3817

    '
  stdout: ''
  timestamp: 1660013961
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    func is_nested(string: String) -> Bool {\n    var stack = [String]()\n    var\
    \ openBrackets = 0\n    var closeBrackets = 0\n    for character in string {\n\
    \        if character == '[' {\n            openBrackets += 1\n            stack.append(character)\n\
    \        } else if character == ']' {\n            closeBrackets += 1\n      \
    \      if openBrackets == closeBrackets {\n                stack.removeLast()\n\
    \            }\n        } else if openBrackets > closeBrackets {\n           \
    \ return false\n        }\n    }\n    return openBrackets == closeBrackets\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]][[[[[]\") == false)\nassert(is_nested(string: \"[][]\") == false)\n\
    assert(is_nested(string: \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\"\
    ) == true)\nassert(is_nested(string: \"[]]]]]]]]]]\") == false)\nassert(is_nested(string:\
    \ \"[][][[]]\") == true)\nassert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string:\
    \ \"[]]\") == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmp8ood62k0.swift:16:25: error: single-quoted string literal found,\
    \ use '\"'\n        if character == '[' {\n                        ^~~\n     \
    \                   \"[\"\n/tmp/tmp8ood62k0.swift:19:32: error: single-quoted\
    \ string literal found, use '\"'\n        } else if character == ']' {\n     \
    \                          ^~~\n                               \"]\"\n/tmp/tmp8ood62k0.swift:18:26:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            stack.append(character)\n                         ^\n"
  stdout: ''
  timestamp: 1660013961
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    func is_nested(string: String) -> Bool {\n    guard let open = string.rangeOfString(\"\
    [\", options: .LiteralSearch, range: nil, locale: nil),\n        let close = string.rangeOfString(\"\
    ]\", options: .LiteralSearch, range: nil, locale: nil) else {\n            return\
    \ false\n    }\n    return open.location == close && close.location == open.location\
    \ + 1\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(is_nested(string: \"[[]]\"\
    ) == true)\nassert(is_nested(string: \"[]]]]]]][[[[[]\") == false)\nassert(is_nested(string:\
    \ \"[][]\") == false)\nassert(is_nested(string: \"[]\") == false)\nassert(is_nested(string:\
    \ \"[[[[]]]]\") == true)\nassert(is_nested(string: \"[]]]]]]]]]]\") == false)\n\
    assert(is_nested(string: \"[][][[]]\") == true)\nassert(is_nested(string: \"[[]\"\
    ) == false)\nassert(is_nested(string: \"[]]\") == false)\nassert(is_nested(string:\
    \ \"[[]][[\") == true)\nassert(is_nested(string: \"[[][]]\") == true)\nassert(is_nested(string:\
    \ \"\") == false)\nassert(is_nested(string: \"[[[[[[[[\") == false)\nassert(is_nested(string:\
    \ \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmpkfllo09u.swift:12:29: error: value of type 'String' has no member\
    \ 'rangeOfString'\n    guard let open = string.rangeOfString(\"[\", options: .LiteralSearch,\
    \ range: nil, locale: nil),\n                     ~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmpkfllo09u.swift:12:58:\
    \ error: cannot infer contextual base in reference to member 'LiteralSearch'\n\
    \    guard let open = string.rangeOfString(\"[\", options: .LiteralSearch, range:\
    \ nil, locale: nil),\n                                                       \
    \ ~^~~~~~~~~~~~~\n/tmp/tmpkfllo09u.swift:12:80: error: 'nil' requires a contextual\
    \ type\n    guard let open = string.rangeOfString(\"[\", options: .LiteralSearch,\
    \ range: nil, locale: nil),\n                                                \
    \                               ^\n/tmp/tmpkfllo09u.swift:12:93: error: 'nil'\
    \ requires a contextual type\n    guard let open = string.rangeOfString(\"[\"\
    , options: .LiteralSearch, range: nil, locale: nil),\n                       \
    \                                                                     ^\n/tmp/tmpkfllo09u.swift:13:28:\
    \ error: value of type 'String' has no member 'rangeOfString'\n        let close\
    \ = string.rangeOfString(\"]\", options: .LiteralSearch, range: nil, locale: nil)\
    \ else {\n                    ~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmpkfllo09u.swift:13:57:\
    \ error: cannot infer contextual base in reference to member 'LiteralSearch'\n\
    \        let close = string.rangeOfString(\"]\", options: .LiteralSearch, range:\
    \ nil, locale: nil) else {\n                                                 \
    \      ~^~~~~~~~~~~~~\n/tmp/tmpkfllo09u.swift:13:79: error: 'nil' requires a contextual\
    \ type\n        let close = string.rangeOfString(\"]\", options: .LiteralSearch,\
    \ range: nil, locale: nil) else {\n                                          \
    \                                    ^\n/tmp/tmpkfllo09u.swift:13:92: error: 'nil'\
    \ requires a contextual type\n        let close = string.rangeOfString(\"]\",\
    \ options: .LiteralSearch, range: nil, locale: nil) else {\n                 \
    \                                                                          ^\n"
  stdout: ''
  timestamp: 1660013961
- exit_code: -4
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    func is_nested(string: String) -> Bool {\n    \n    // Your code here\n    \n\
    \    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(is_nested(string:\
    \ \"[[]]\") == true)\nassert(is_nested(string: \"[]]]]]]][[[[[]\") == false)\n\
    assert(is_nested(string: \"[][]\") == false)\nassert(is_nested(string: \"[]\"\
    ) == false)\nassert(is_nested(string: \"[[[[]]]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]]]]]\") == false)\nassert(is_nested(string: \"[][][[]]\") == true)\n\
    assert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string: \"[]]\"\
    ) == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: Exception
  stderr: 'tmp4fbozzey/tmp4fbozzey.swift:32: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af698c96c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af69898db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af69898d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af69898c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp4fbozzey                        0x000056101a6522fb <unavailable> + 4859

    5    libc.so.6                          0x00002af698e82460 __libc_start_main +
    245

    6    tmp4fbozzey                        0x000056101a651ee9 <unavailable> + 3817

    '
  stdout: ''
  timestamp: 1660013961
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    func is_nested(string: String) -> Bool {\n    guard let index = string.index(of:\
    \ \"[\"),\n        let end = string.index(of: \"]\", from: index) else {\n   \
    \     return false\n    }\n    let start = index + 1\n    let end = string.index(of:\
    \ \"]\", from: end)\n    let subsequence = string.substring(from: start, to: end)\n\
    \    return subsequence.contains(\"[\")\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string: \"[]]]]]]][[[[[]\"\
    ) == false)\nassert(is_nested(string: \"[][]\") == false)\nassert(is_nested(string:\
    \ \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]]]]]\") == false)\nassert(is_nested(string: \"[][][[]]\") == true)\n\
    assert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string: \"[]]\"\
    ) == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmp4l7nopy6.swift:12:30: warning: 'index(of:)' is deprecated: renamed\
    \ to 'firstIndex(of:)'\n    guard let index = string.index(of: \"[\"),\n     \
    \                        ^\n/tmp/tmp4l7nopy6.swift:12:30: note: use 'firstIndex(of:)'\
    \ instead\n    guard let index = string.index(of: \"[\"),\n                  \
    \           ^~~~~\n                             firstIndex\n/tmp/tmp4l7nopy6.swift:13:47:\
    \ error: extra argument 'from' in call\n        let end = string.index(of: \"\
    ]\", from: index) else {\n                              ~~~~~~~~~~~~~~~~^~~~~~\n\
    /tmp/tmp4l7nopy6.swift:16:17: error: cannot convert value of type 'String.Index'\
    \ to expected argument type 'Int'\n    let start = index + 1\n               \
    \ ^\n/tmp/tmp4l7nopy6.swift:17:43: error: extra argument 'from' in call\n    let\
    \ end = string.index(of: \"]\", from: end)\n                          ~~~~~~~~~~~~~~~~^~~~\n\
    /tmp/tmp4l7nopy6.swift:18:30: error: value of type 'String' has no member 'substring'\n\
    \    let subsequence = string.substring(from: start, to: end)\n              \
    \        ~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013961
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    func is_nested(string: String) -> Bool {\n\tlet openingBrackets = string.unicodeScalars.filter({\
    \ $0.isOpen })\n\tlet closingBrackets = string.unicodeScalars.filter({ $0.isClosing\
    \ })\n\t\n\tguard openingBrackets.count > 0 && closingBrackets.count > 0 else\
    \ {\n\t\treturn false\n\t}\n\t\n\tlet openingBracketsCount = openingBrackets.count\n\
    \tlet closingBracketsCount = closingBrackets.count\n\t\n\tguard openingBracketsCount\
    \ == closingBracketsCount else {\n\t\treturn false\n\t}\n\t\n\tlet openingBracketsIndex\
    \ = openingBrackets.firstIndex(where: { $0.isOpen })\n\tlet closingBracketsIndex\
    \ = closingBrackets.firstIndex(where: { $0.isClosing })\n\t\n\tguard openingBracketsIndex\
    \ != closingBracketsIndex else {\n\t\treturn false\n\t}\n\t\n\tlet openingBracketsString\
    \ = openingBrackets[openingBracketsIndex].value\n\tlet closingBracketsString =\
    \ closingBrackets[closingBracketsIndex].value\n\t\n\tlet openingBracketsStringRange\
    \ = string.unicodeScalars.filter({ $0.isOpen }).first(where: { $0.value == openingBracketsString\
    \ })\n\tlet closingBracketsStringRange = string.unicodeScalars.filter({ $0.isClosing\
    \ }).first(where: { $0.value == closingBracketsString })\n\t\n\tguard openingBracketsStringRange\
    \ != nil && closingBracketsStringRange != nil else {\n\t\treturn false\n\t}\n\t\
    \n\tlet openingBracketsStringRangeIndex = openingBracketsStringRange.index\n\t\
    let closingBracketsStringRangeIndex = closingBracketsStringRange.index\n\t\n\t\
    guard openingBracketsStringRangeIndex != closingBracketsStringRangeIndex else\
    \ {\n\t\treturn false\n\t}\n\t\n\treturn true\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string: \"\
    []]]]]]][[[[[]\") == false)\nassert(is_nested(string: \"[][]\") == false)\nassert(is_nested(string:\
    \ \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]]]]]\") == false)\nassert(is_nested(string: \"[][][[]]\") == true)\n\
    assert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string: \"[]]\"\
    ) == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmpl0kjn6ps.swift:12:58: error: value of type 'Unicode.Scalar' has\
    \ no member 'isOpen'\n        let openingBrackets = string.unicodeScalars.filter({\
    \ $0.isOpen })\n                                                             ~~\
    \ ^~~~~~\n/tmp/tmpl0kjn6ps.swift:13:58: error: value of type 'Unicode.Scalar'\
    \ has no member 'isClosing'\n        let closingBrackets = string.unicodeScalars.filter({\
    \ $0.isClosing })\n                                                          \
    \   ~~ ^~~~~~~~~\n/tmp/tmpl0kjn6ps.swift:36:69: error: value of type 'Unicode.Scalar'\
    \ has no member 'isOpen'\n        let openingBracketsStringRange = string.unicodeScalars.filter({\
    \ $0.isOpen }).first(where: { $0.value == openingBracketsString })\n         \
    \                                                               ~~ ^~~~~~\n/tmp/tmpl0kjn6ps.swift:37:69:\
    \ error: value of type 'Unicode.Scalar' has no member 'isClosing'\n        let\
    \ closingBracketsStringRange = string.unicodeScalars.filter({ $0.isClosing }).first(where:\
    \ { $0.value == closingBracketsString })\n                                   \
    \                                     ~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013961
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    func is_nested(string: String) -> Bool {\n    var stack = [String]()\n    var\
    \ openingBrackets = 0\n    for char in string {\n        if char == '[' {\n  \
    \          stack.append(char)\n            openingBrackets += 1\n        } else\
    \ if char == ']' {\n            openingBrackets -= 1\n            if openingBrackets\
    \ == 0 {\n                stack.removeLast()\n            }\n        } else if\
    \ char == '[' && openingBrackets > 0 {\n            stack.removeLast()\n     \
    \   }\n    }\n    return stack.count > 0\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string: \"[]]]]]]][[[[[]\"\
    ) == false)\nassert(is_nested(string: \"[][]\") == false)\nassert(is_nested(string:\
    \ \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]]]]]\") == false)\nassert(is_nested(string: \"[][][[]]\") == true)\n\
    assert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string: \"[]]\"\
    ) == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmpirtd1zj2.swift:15:20: error: single-quoted string literal found,\
    \ use '\"'\n        if char == '[' {\n                   ^~~\n               \
    \    \"[\"\n/tmp/tmpirtd1zj2.swift:18:27: error: single-quoted string literal\
    \ found, use '\"'\n        } else if char == ']' {\n                         \
    \ ^~~\n                          \"]\"\n/tmp/tmpirtd1zj2.swift:23:27: error: single-quoted\
    \ string literal found, use '\"'\n        } else if char == '[' && openingBrackets\
    \ > 0 {\n                          ^~~\n                          \"[\"\n/tmp/tmpirtd1zj2.swift:16:26:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            stack.append(char)\n                         ^\n"
  stdout: ''
  timestamp: 1660013961
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    func is_nested(string: String) -> Bool {\n    var index = 0\n    var openCount\
    \ = 0\n    var closeCount = 0\n    var openBracketCount = 0\n    var closeBracketCount\
    \ = 0\n    var openBracketNestingCount = 0\n    var closeBracketNestingCount =\
    \ 0\n    var openBracketNesting = 0\n    var closeBracketNesting = 0\n    var\
    \ openBracketNestingCount = 0\n    var closeBracketNestingCount = 0\n    var openBracketNestingCount\
    \ = 0\n    var closeBracketNestingCount = 0\n    var openBracketNestingCount =\
    \ 0\n    var closeBracketNestingCount = 0\n    var openBracketNestingCount = 0\n\
    \    var closeBracketNestingCount = 0\n    var openBracketNestingCount = 0\n \
    \   var closeBracketNestingCount = 0\n    var openBracketNestingCount = 0\n  \
    \  var closeBracketNestingCount = 0\n    var openBracketNestingCount = 0\n   \
    \ var closeBracketNestingCount = 0\n    var openBracketNestingCount = 0\n    var\
    \ closeBracketNestingCount = 0\n    var openBracketNestingCount = 0\n    var closeBracketNestingCount\
    \ = 0\n    var openBracketNestingCount = 0\n    var closeBracketNestingCount =\
    \ 0\n    var openBracketNestingCount = 0\n    var closeBracketNestingCount = 0\n\
    \    var openBracketNestingCount = 0\n    var closeBracketNestingCount = 0\n \
    \   var openBracketNestingCount = 0\n    var closeBracketNestingCount = 0\n  \
    \  var openBracketNestingCount = 0\n    var closeBracketNestingCount = 0\n   \
    \ var openBracketNestingCount = 0\n    var closeBracketNestingCount = 0\n    var\
    \ openBracketNestingCount = 0\n    var closeBracketNestingCount = 0\n    var openBracketNestingCount\
    \ = 0\n    var closeBracketNestingCount = 0\n    var openBracketNestingCount =\
    \ 0\n    var closeBracketNestingCount = 0\n    var openBracketNestingCount = 0\n\
    \    var closeBracketNestingCount = 0\n    var openBracketNestingCount = 0\n \
    \   var closeBracketNestingCount = 0\n    var openBracketNestingCount = 0\n  \
    \  var closeBracketNestingCount = 0\n    var openBracketNestingCount = 0\n   \
    \ var closeBracketNestingCount = 0\n    var openBracketNest\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]][[[[[]\") == false)\nassert(is_nested(string: \"[][]\") == false)\n\
    assert(is_nested(string: \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\"\
    ) == true)\nassert(is_nested(string: \"[]]]]]]]]]]\") == false)\nassert(is_nested(string:\
    \ \"[][][[]]\") == true)\nassert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string:\
    \ \"[]]\") == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmpthqjgzdu.swift:21:9: error: invalid redeclaration of 'openBracketNestingCount'\n\
    \    var openBracketNestingCount = 0\n        ^\n/tmp/tmpthqjgzdu.swift:17:9:\
    \ note: 'openBracketNestingCount' previously declared here\n    var openBracketNestingCount\
    \ = 0\n        ^\n/tmp/tmpthqjgzdu.swift:22:9: error: invalid redeclaration of\
    \ 'closeBracketNestingCount'\n    var closeBracketNestingCount = 0\n        ^\n\
    /tmp/tmpthqjgzdu.swift:18:9: note: 'closeBracketNestingCount' previously declared\
    \ here\n    var closeBracketNestingCount = 0\n        ^\n/tmp/tmpthqjgzdu.swift:23:9:\
    \ error: invalid redeclaration of 'openBracketNestingCount'\n    var openBracketNestingCount\
    \ = 0\n        ^\n/tmp/tmpthqjgzdu.swift:17:9: note: 'openBracketNestingCount'\
    \ previously declared here\n    var openBracketNestingCount = 0\n        ^\n/tmp/tmpthqjgzdu.swift:24:9:\
    \ error: invalid redeclaration of 'closeBracketNestingCount'\n    var closeBracketNestingCount\
    \ = 0\n        ^\n/tmp/tmpthqjgzdu.swift:18:9: note: 'closeBracketNestingCount'\
    \ previously declared here\n    var closeBracketNestingCount = 0\n        ^\n\
    /tmp/tmpthqjgzdu.swift:25:9: error: invalid redeclaration of 'openBracketNestingCount'\n\
    \    var openBracketNestingCount = 0\n        ^\n/tmp/tmpthqjgzdu.swift:17:9:\
    \ note: 'openBracketNestingCount' previously declared here\n    var openBracketNestingCount\
    \ = 0\n        ^\n/tmp/tmpthqjgzdu.swift:26:9: error: invalid redeclaration of\
    \ 'closeBracketNestingCount'\n    var closeBracketNestingCount = 0\n        ^\n\
    /tmp/tmpthqjgzdu.swift:18:9: note: 'closeBracketNestingCount' previously declared\
    \ here\n    var closeBracketNestingCount = 0\n        ^\n/tmp/tmpthqjgzdu.swift:27:9:\
    \ error: invalid redeclaration of 'openBracketNestingCount'\n    var openBracketNestingCount\
    \ = 0\n        ^\n/tmp/tmpthqjgzdu.swift:17:9: note: 'openBracketNestingCount'\
    \ previously declared here\n    var openBracketNestingCount = 0\n        ^\n/tmp/tmpthqjgzdu.swift:28:9:\
    \ error: invalid redeclaration of 'closeBracketNestingCount'\n    var closeBracketNestingCount\
    \ = 0\n        ^\n/tmp/tmpthqjgzdu.swift:18:9: note: 'closeBrack"
  stdout: ''
  timestamp: 1660013961
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    func is_nested(string: String) -> Bool {\n    guard let start = string.index(of:\
    \ \"[\"),\n        let end = string.index(of: \"]\"),\n        start < end else\
    \ {\n            return false\n    }\n    let nested = string.substring(from:\
    \ start + 1, to: end - 1)\n    return nested.characters.count > 0\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]][[[[[]\") == false)\nassert(is_nested(string: \"[][]\") == false)\n\
    assert(is_nested(string: \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\"\
    ) == true)\nassert(is_nested(string: \"[]]]]]]]]]]\") == false)\nassert(is_nested(string:\
    \ \"[][][[]]\") == true)\nassert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string:\
    \ \"[]]\") == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmpei5d__r7.swift:12:30: warning: 'index(of:)' is deprecated: renamed\
    \ to 'firstIndex(of:)'\n    guard let start = string.index(of: \"[\"),\n     \
    \                        ^\n/tmp/tmpei5d__r7.swift:12:30: note: use 'firstIndex(of:)'\
    \ instead\n    guard let start = string.index(of: \"[\"),\n                  \
    \           ^~~~~\n                             firstIndex\n/tmp/tmpei5d__r7.swift:13:26:\
    \ warning: 'index(of:)' is deprecated: renamed to 'firstIndex(of:)'\n        let\
    \ end = string.index(of: \"]\"),\n                         ^\n/tmp/tmpei5d__r7.swift:13:26:\
    \ note: use 'firstIndex(of:)' instead\n        let end = string.index(of: \"]\"\
    ),\n                         ^~~~~\n                         firstIndex\n/tmp/tmpei5d__r7.swift:17:47:\
    \ error: binary operator '+' cannot be applied to operands of type 'String.Index'\
    \ and 'Int'\n    let nested = string.substring(from: start + 1, to: end - 1)\n\
    \                                        ~~~~~ ^ ~\n/tmp/tmpei5d__r7.swift:17:25:\
    \ error: value of type 'String' has no member 'substring'\n    let nested = string.substring(from:\
    \ start + 1, to: end - 1)\n                 ~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013961
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    func is_nested(string: String) -> Bool {\n    \n    // Initialize a stack of brackets\n\
    \    var stack = [Bracket]()\n    \n    // Iterate over the string and add brackets\
    \ to the stack\n    for char in string {\n        switch char {\n        case\
    \ '[':\n            stack.append(Bracket.Open)\n        case '[':\n          \
    \  stack.append(Bracket.Close)\n        case ']':\n            stack.append(Bracket.Close)\n\
    \        case ']':\n            stack.append(Bracket.Open)\n        default:\n\
    \            // If stack is empty, return false\n            if stack.count ==\
    \ 0 {\n                return false\n            }\n            // If stack is\
    \ not empty, return true if the stack is balanced\n            if stack.count\
    \ == 1 {\n                return true\n            }\n            // Otherwise,\
    \ return false if the stack is not balanced\n            return false\n      \
    \  }\n    }\n    \n    // If stack is empty, return false\n    if stack.count\
    \ == 0 {\n        return false\n    }\n    \n    // If stack is not empty, return\
    \ true if the stack is balanced\n    if stack.count == 1 {\n        return true\n\
    \    }\n    \n    // Otherwise, return false if the stack is not balanced\n  \
    \  return false\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(is_nested(string:\
    \ \"[[]]\") == true)\nassert(is_nested(string: \"[]]]]]]][[[[[]\") == false)\n\
    assert(is_nested(string: \"[][]\") == false)\nassert(is_nested(string: \"[]\"\
    ) == false)\nassert(is_nested(string: \"[[[[]]]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]]]]]\") == false)\nassert(is_nested(string: \"[][][[]]\") == true)\n\
    assert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string: \"[]]\"\
    ) == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmpw8t6120n.swift:19:14: error: single-quoted string literal found,\
    \ use '\"'\n        case '[':\n             ^~~\n             \"[\"\n/tmp/tmpw8t6120n.swift:21:14:\
    \ error: single-quoted string literal found, use '\"'\n        case '[':\n   \
    \          ^~~\n             \"[\"\n/tmp/tmpw8t6120n.swift:23:14: error: single-quoted\
    \ string literal found, use '\"'\n        case ']':\n             ^~~\n      \
    \       \"]\"\n/tmp/tmpw8t6120n.swift:25:14: error: single-quoted string literal\
    \ found, use '\"'\n        case ']':\n             ^~~\n             \"]\"\n/tmp/tmpw8t6120n.swift:14:18:\
    \ error: cannot find 'Bracket' in scope\n    var stack = [Bracket]()\n       \
    \          ^~~~~~~\n/tmp/tmpw8t6120n.swift:14:17: error: cannot call value of\
    \ non-function type '[Any]'\n    var stack = [Bracket]()\n                ^  \
    \      ~~\n                         \n/tmp/tmpw8t6120n.swift:20:26: error: cannot\
    \ find 'Bracket' in scope\n            stack.append(Bracket.Open)\n          \
    \               ^~~~~~~\n/tmp/tmpw8t6120n.swift:22:26: error: cannot find 'Bracket'\
    \ in scope\n            stack.append(Bracket.Close)\n                        \
    \ ^~~~~~~\n/tmp/tmpw8t6120n.swift:24:26: error: cannot find 'Bracket' in scope\n\
    \            stack.append(Bracket.Close)\n                         ^~~~~~~\n/tmp/tmpw8t6120n.swift:26:26:\
    \ error: cannot find 'Bracket' in scope\n            stack.append(Bracket.Open)\n\
    \                         ^~~~~~~\n/tmp/tmpw8t6120n.swift:21:14: warning: literal\
    \ value is already handled by previous pattern; consider removing it\n       \
    \ case '[':\n             ^~~\n/tmp/tmpw8t6120n.swift:19:14: note: first occurrence\
    \ of identical literal pattern is here\n        case '[':\n             ^~~\n\
    /tmp/tmpw8t6120n.swift:25:14: warning: literal value is already handled by previous\
    \ pattern; consider removing it\n        case ']':\n             ^~~\n/tmp/tmpw8t6120n.swift:23:14:\
    \ note: first occurrence of identical literal pattern is here\n        case ']':\n\
    \             ^~~\n"
  stdout: ''
  timestamp: 1660013961
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    func is_nested(string: String) -> Bool {\n    let stack = Stack()\n    for character\
    \ in string {\n        if character == '[' {\n            stack.push(character)\n\
    \        } else if character == ']' {\n            if stack.top() == '[' {\n \
    \               stack.pop()\n            } else {\n                return false\n\
    \            }\n        }\n    }\n    return stack.top() == nil\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]][[[[[]\") == false)\nassert(is_nested(string: \"[][]\") == false)\n\
    assert(is_nested(string: \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\"\
    ) == true)\nassert(is_nested(string: \"[]]]]]]]]]]\") == false)\nassert(is_nested(string:\
    \ \"[][][[]]\") == true)\nassert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string:\
    \ \"[]]\") == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmpr7991uf1.swift:14:25: error: single-quoted string literal found,\
    \ use '\"'\n        if character == '[' {\n                        ^~~\n     \
    \                   \"[\"\n/tmp/tmpr7991uf1.swift:16:32: error: single-quoted\
    \ string literal found, use '\"'\n        } else if character == ']' {\n     \
    \                          ^~~\n                               \"]\"\n/tmp/tmpr7991uf1.swift:17:31:\
    \ error: single-quoted string literal found, use '\"'\n            if stack.top()\
    \ == '[' {\n                              ^~~\n                              \"\
    [\"\n/tmp/tmpr7991uf1.swift:12:17: error: cannot find 'Stack' in scope\n    let\
    \ stack = Stack()\n                ^~~~~\n"
  stdout: ''
  timestamp: 1660013961
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    func is_nested(string: String) -> Bool {\n    guard let openBracket = string.rangeOfString(\"\
    [\", options: .BackwardsSearch) else { return false }\n    guard let closeBracket\
    \ = string.rangeOfString(\"]\", options: .BackwardsSearch) else { return false\
    \ }\n    guard openBracket.location < closeBracket.location else { return false\
    \ }\n    guard openBracket.location > 0 else { return false }\n    guard closeBracket.location\
    \ < string.count else { return false }\n    \n    let openBracketIndex = string.startIndex.advancedBy(openBracket.location)\n\
    \    let closeBracketIndex = string.startIndex.advancedBy(closeBracket.location)\n\
    \    \n    let openBracketString = string.substringWithRange(openBracketIndex)\n\
    \    let closeBracketString = string.substringWithRange(closeBracketIndex)\n \
    \   \n    if openBracketString == closeBracketString {\n        return true\n\
    \    }\n    \n    return false\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(is_nested(string:\
    \ \"[[]]\") == true)\nassert(is_nested(string: \"[]]]]]]][[[[[]\") == false)\n\
    assert(is_nested(string: \"[][]\") == false)\nassert(is_nested(string: \"[]\"\
    ) == false)\nassert(is_nested(string: \"[[[[]]]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]]]]]\") == false)\nassert(is_nested(string: \"[][][[]]\") == true)\n\
    assert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string: \"[]]\"\
    ) == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmpa7yubgr9.swift:12:36: error: value of type 'String' has no member\
    \ 'rangeOfString'\n    guard let openBracket = string.rangeOfString(\"[\", options:\
    \ .BackwardsSearch) else { return false }\n                            ~~~~~~\
    \ ^~~~~~~~~~~~~\n/tmp/tmpa7yubgr9.swift:12:65: error: cannot infer contextual\
    \ base in reference to member 'BackwardsSearch'\n    guard let openBracket = string.rangeOfString(\"\
    [\", options: .BackwardsSearch) else { return false }\n                      \
    \                                         ~^~~~~~~~~~~~~~~\n/tmp/tmpa7yubgr9.swift:13:37:\
    \ error: value of type 'String' has no member 'rangeOfString'\n    guard let closeBracket\
    \ = string.rangeOfString(\"]\", options: .BackwardsSearch) else { return false\
    \ }\n                             ~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmpa7yubgr9.swift:13:66:\
    \ error: cannot infer contextual base in reference to member 'BackwardsSearch'\n\
    \    guard let closeBracket = string.rangeOfString(\"]\", options: .BackwardsSearch)\
    \ else { return false }\n                                                    \
    \            ~^~~~~~~~~~~~~~~\n/tmp/tmpa7yubgr9.swift:18:46: error: value of type\
    \ 'String.Index' has no member 'advancedBy'\n    let openBracketIndex = string.startIndex.advancedBy(openBracket.location)\n\
    \                           ~~~~~~~~~~~~~~~~~ ^~~~~~~~~~\n/tmp/tmpa7yubgr9.swift:19:47:\
    \ error: value of type 'String.Index' has no member 'advancedBy'\n    let closeBracketIndex\
    \ = string.startIndex.advancedBy(closeBracket.location)\n                    \
    \        ~~~~~~~~~~~~~~~~~ ^~~~~~~~~~\n/tmp/tmpa7yubgr9.swift:21:36: error: value\
    \ of type 'String' has no member 'substringWithRange'\n    let openBracketString\
    \ = string.substringWithRange(openBracketIndex)\n                            ~~~~~~\
    \ ^~~~~~~~~~~~~~~~~~\n/tmp/tmpa7yubgr9.swift:22:37: error: value of type 'String'\
    \ has no member 'substringWithRange'\n    let closeBracketString = string.substringWithRange(closeBracketIndex)\n\
    \                             ~~~~~~ ^~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013961
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    func is_nested(string: String) -> Bool {\n    \n    let stack = Stack()\n    \n\
    \    for char in string {\n        \n        if char == '[' {\n            stack.push(char)\n\
    \        }\n        \n        if char == ']' {\n            \n            if stack.count\
    \ > 0 {\n                \n                if stack.pop() == '[' {\n         \
    \           \n                    return true\n                }\n           \
    \ }\n        }\n    }\n    \n    return false\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string: \"\
    []]]]]]][[[[[]\") == false)\nassert(is_nested(string: \"[][]\") == false)\nassert(is_nested(string:\
    \ \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]]]]]\") == false)\nassert(is_nested(string: \"[][][[]]\") == true)\n\
    assert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string: \"[]]\"\
    ) == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmp5u5defad.swift:17:20: error: single-quoted string literal found,\
    \ use '\"'\n        if char == '[' {\n                   ^~~\n               \
    \    \"[\"\n/tmp/tmp5u5defad.swift:21:20: error: single-quoted string literal\
    \ found, use '\"'\n        if char == ']' {\n                   ^~~\n        \
    \           \"]\"\n/tmp/tmp5u5defad.swift:25:35: error: single-quoted string literal\
    \ found, use '\"'\n                if stack.pop() == '[' {\n                 \
    \                 ^~~\n                                  \"[\"\n/tmp/tmp5u5defad.swift:13:17:\
    \ error: cannot find 'Stack' in scope\n    let stack = Stack()\n             \
    \   ^~~~~\n"
  stdout: ''
  timestamp: 1660013961
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    func is_nested(string: String) -> Bool {\n    guard let openBracket = string.rangeOfString(\"\
    [\", options: .LiteralSearch, range: nil, locale: nil),\n        let closeBracket\
    \ = string.rangeOfString(\"]\", options: .LiteralSearch, range: nil, locale: nil)\
    \ else {\n            return false\n    }\n    return openBracket.location !=\
    \ closeBracket.location\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(is_nested(string:\
    \ \"[[]]\") == true)\nassert(is_nested(string: \"[]]]]]]][[[[[]\") == false)\n\
    assert(is_nested(string: \"[][]\") == false)\nassert(is_nested(string: \"[]\"\
    ) == false)\nassert(is_nested(string: \"[[[[]]]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]]]]]\") == false)\nassert(is_nested(string: \"[][][[]]\") == true)\n\
    assert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string: \"[]]\"\
    ) == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmptc0olnf9.swift:12:36: error: value of type 'String' has no member\
    \ 'rangeOfString'\n    guard let openBracket = string.rangeOfString(\"[\", options:\
    \ .LiteralSearch, range: nil, locale: nil),\n                            ~~~~~~\
    \ ^~~~~~~~~~~~~\n/tmp/tmptc0olnf9.swift:12:65: error: cannot infer contextual\
    \ base in reference to member 'LiteralSearch'\n    guard let openBracket = string.rangeOfString(\"\
    [\", options: .LiteralSearch, range: nil, locale: nil),\n                    \
    \                                           ~^~~~~~~~~~~~~\n/tmp/tmptc0olnf9.swift:12:87:\
    \ error: 'nil' requires a contextual type\n    guard let openBracket = string.rangeOfString(\"\
    [\", options: .LiteralSearch, range: nil, locale: nil),\n                    \
    \                                                                  ^\n/tmp/tmptc0olnf9.swift:12:100:\
    \ error: 'nil' requires a contextual type\n    guard let openBracket = string.rangeOfString(\"\
    [\", options: .LiteralSearch, range: nil, locale: nil),\n                    \
    \                                                                            \
    \   ^\n/tmp/tmptc0olnf9.swift:13:35: error: value of type 'String' has no member\
    \ 'rangeOfString'\n        let closeBracket = string.rangeOfString(\"]\", options:\
    \ .LiteralSearch, range: nil, locale: nil) else {\n                          \
    \ ~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmptc0olnf9.swift:13:64: error: cannot infer contextual\
    \ base in reference to member 'LiteralSearch'\n        let closeBracket = string.rangeOfString(\"\
    ]\", options: .LiteralSearch, range: nil, locale: nil) else {\n              \
    \                                                ~^~~~~~~~~~~~~\n/tmp/tmptc0olnf9.swift:13:86:\
    \ error: 'nil' requires a contextual type\n        let closeBracket = string.rangeOfString(\"\
    ]\", options: .LiteralSearch, range: nil, locale: nil) else {\n              \
    \                                                                       ^\n/tmp/tmptc0olnf9.swift:13:99:\
    \ error: 'nil' requires a contextual type\n        let closeBracket = string.rangeOfString(\"\
    ]\", options: .LiteralSearch, range: nil, locale: n"
  stdout: ''
  timestamp: 1660013961
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    func is_nested(string: String) -> Bool {\n    guard let openingBracket = string.rangeOfString(\"\
    [\", options: .LiteralSearch, range: nil, locale: nil) else {\n        return\
    \ false\n    }\n    guard let closingBracket = string.rangeOfString(\"]\", options:\
    \ .LiteralSearch, range: nil, locale: nil) else {\n        return false\n    }\n\
    \    guard let openingBracketIndex = string.index(of: openingBracket, options:\
    \ .LiteralSearch, range: nil, locale: nil) else {\n        return false\n    }\n\
    \    guard let closingBracketIndex = string.index(of: closingBracket, options:\
    \ .LiteralSearch, range: nil, locale: nil) else {\n        return false\n    }\n\
    \    guard let openingBracketIndex = string.index(of: openingBracket, options:\
    \ .LiteralSearch, range: nil, locale: nil) else {\n        return false\n    }\n\
    \    guard let closingBracketIndex = string.index(of: closingBracket, options:\
    \ .LiteralSearch, range: nil, locale: nil) else {\n        return false\n    }\n\
    \    guard let openingBracketIndex = string.index(of: openingBracket, options:\
    \ .LiteralSearch, range: nil, locale: nil) else {\n        return false\n    }\n\
    \    guard let closingBracketIndex = string.index(of: closingBracket, options:\
    \ .LiteralSearch, range: nil, locale: nil) else {\n        return false\n    }\n\
    \    guard let openingBracketIndex = string.index(of: openingBracket, options:\
    \ .LiteralSearch, range: nil, locale: nil) else {\n        return false\n    }\n\
    \    guard let closingBracketIndex = string.index(of: closingBracket, options:\
    \ .LiteralSearch, range: nil, locale: nil) else {\n        return false\n    }\n\
    \    guard let openingBracketIndex = string.index(of: openingBracket, options:\
    \ .LiteralSearch, range: nil, locale: nil) else {\n        return false\n    }\n\
    \    guard let closingBracketIndex = string.index(of: closingBracket, options:\
    \ .LiteralSearch, range: nil, locale: nil) else {\n        return false\n    }\n\
    \    guard let openingBracketIndex = string.index(of: openingBracket, options:\
    \ .LiteralSearch, range: nil, locale: nil) else {\n        return false\n    }\n\
    \    guard let closingBracketIndex = string.index(of: closingBracket, options:\
    \ .LiteralSearch, range: nil, locale: nil) else {\n        return false\n    }\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]][[[[[]\") == false)\nassert(is_nested(string: \"[][]\") == false)\n\
    assert(is_nested(string: \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\"\
    ) == true)\nassert(is_nested(string: \"[]]]]]]]]]]\") == false)\nassert(is_nested(string:\
    \ \"[][][[]]\") == true)\nassert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string:\
    \ \"[]]\") == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmpg0uwng8t.swift:12:39: error: value of type 'String' has no member\
    \ 'rangeOfString'\n    guard let openingBracket = string.rangeOfString(\"[\",\
    \ options: .LiteralSearch, range: nil, locale: nil) else {\n                 \
    \              ~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmpg0uwng8t.swift:12:68: error: cannot\
    \ infer contextual base in reference to member 'LiteralSearch'\n    guard let\
    \ openingBracket = string.rangeOfString(\"[\", options: .LiteralSearch, range:\
    \ nil, locale: nil) else {\n                                                 \
    \                 ~^~~~~~~~~~~~~\n/tmp/tmpg0uwng8t.swift:12:90: error: 'nil' requires\
    \ a contextual type\n    guard let openingBracket = string.rangeOfString(\"[\"\
    , options: .LiteralSearch, range: nil, locale: nil) else {\n                 \
    \                                                                        ^\n/tmp/tmpg0uwng8t.swift:12:103:\
    \ error: 'nil' requires a contextual type\n    guard let openingBracket = string.rangeOfString(\"\
    [\", options: .LiteralSearch, range: nil, locale: nil) else {\n              \
    \                                                                            \
    \            ^\n/tmp/tmpg0uwng8t.swift:15:39: error: value of type 'String' has\
    \ no member 'rangeOfString'\n    guard let closingBracket = string.rangeOfString(\"\
    ]\", options: .LiteralSearch, range: nil, locale: nil) else {\n              \
    \                 ~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmpg0uwng8t.swift:15:68: error: cannot\
    \ infer contextual base in reference to member 'LiteralSearch'\n    guard let\
    \ closingBracket = string.rangeOfString(\"]\", options: .LiteralSearch, range:\
    \ nil, locale: nil) else {\n                                                 \
    \                 ~^~~~~~~~~~~~~\n/tmp/tmpg0uwng8t.swift:15:90: error: 'nil' requires\
    \ a contextual type\n    guard let closingBracket = string.rangeOfString(\"]\"\
    , options: .LiteralSearch, range: nil, locale: nil) else {\n                 \
    \                                                                        ^\n/tmp/tmpg0uwng8t.swift:15:103:\
    \ error: 'nil' requires a contextual type\n    guard let closingBrack"
  stdout: ''
  timestamp: 1660013961
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    func is_nested(string: String) -> Bool {\n    \n    let stack = Stack()\n    \n\
    \    for char in string {\n        \n        if char == '[' {\n            stack.push(char)\n\
    \        } else if char == ']' {\n            if stack.count > 0 {\n         \
    \       stack.pop()\n            } else {\n                return false\n    \
    \        }\n        }\n    }\n    \n    return stack.count == 0\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]][[[[[]\") == false)\nassert(is_nested(string: \"[][]\") == false)\n\
    assert(is_nested(string: \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\"\
    ) == true)\nassert(is_nested(string: \"[]]]]]]]]]]\") == false)\nassert(is_nested(string:\
    \ \"[][][[]]\") == true)\nassert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string:\
    \ \"[]]\") == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmpk2ihsqup.swift:17:20: error: single-quoted string literal found,\
    \ use '\"'\n        if char == '[' {\n                   ^~~\n               \
    \    \"[\"\n/tmp/tmpk2ihsqup.swift:19:27: error: single-quoted string literal\
    \ found, use '\"'\n        } else if char == ']' {\n                         \
    \ ^~~\n                          \"]\"\n/tmp/tmpk2ihsqup.swift:13:17: error: cannot\
    \ find 'Stack' in scope\n    let stack = Stack()\n                ^~~~~\n"
  stdout: ''
  timestamp: 1660013961
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    func is_nested(string: String) -> Bool {\n    var openingBrackets = 0 // number\
    \ of opening brackets\n    var closingBrackets = 0 // number of closing brackets\n\
    \    var openingBracketsStack = [String]() // stack of opening brackets\n    var\
    \ closingBracketsStack = [String]() // stack of closing brackets\n    var openingBracketsStackCount\
    \ = 1 // number of opening brackets in the stack\n    var closingBracketsStackCount\
    \ = 1 // number of closing brackets in the stack\n    var openingBracketsStackLastIndex\
    \ = -1 // index of the last opening bracket in the stack\n    var closingBracketsStackLastIndex\
    \ = -1 // index of the last closing bracket in the stack\n    var openingBracketsStackLastBracket\
    \ = nil // last bracket in the stack\n    var closingBracketsStackLastBracket\
    \ = nil // last bracket in the stack\n    var openingBracketsStackLastBracketIndex\
    \ = -1 // index of the last opening bracket in the stack\n    var closingBracketsStackLastBracketIndex\
    \ = -1 // index of the last closing bracket in the stack\n    var openingBracketsStackLastBracketIndex\
    \ = -1 // index of the last opening bracket in the stack\n    var closingBracketsStackLastBracketIndex\
    \ = -1 // index of the last closing bracket in the stack\n    var openingBracketsStackLastBracketIndex\
    \ = -1 // index of the last opening bracket in the stack\n    var closingBracketsStackLastBracketIndex\
    \ = -1 // index of the last closing bracket in the stack\n    var openingBracketsStackLastBracketIndex\
    \ = -1 // index of the last opening bracket in the stack\n    var closingBracketsStackLastBracketIndex\
    \ = -1 // index of the last closing bracket in the stack\n    var openingBracketsStackLastBracketIndex\
    \ = -1 // index of the last opening bracket in the stack\n    var closingBracketsStackLastBracketIndex\
    \ = -1 // index of the last closing bracket in the stack\n    var openingBracketsStackLastBracketIndex\
    \ = -1 // index of the last opening bracket in the stack\n    var closingBracketsStackLastBracketIndex\
    \ = -1 // index of the last closing bracket in the stack\n    var openingBracketsStackLastBracketIndex\
    \ = -1 // index of the last opening bracket in the stack\n    var closingBracketsStackLastBracketIndex\
    \ = -1 // index of the last closing bracket in the stack\n    var openingBracketsStackLastBracketIndex\
    \ = -1 // index of the last opening bracket in the stack\n    var closingBracketsStackLastBracketIndex\
    \ = -1 // index of the last closing bracket in the stack\n    var openingBracketsStackLastBracketIndex\
    \ = -1 // index of the last opening bracket in the \n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]][[[[[]\") == false)\nassert(is_nested(string: \"[][]\") == false)\n\
    assert(is_nested(string: \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\"\
    ) == true)\nassert(is_nested(string: \"[]]]]]]]]]]\") == false)\nassert(is_nested(string:\
    \ \"[][][[]]\") == true)\nassert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string:\
    \ \"[]]\") == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmpngbfvtgn.swift:20:43: error: 'nil' requires a contextual type\n\
    \    var openingBracketsStackLastBracket = nil // last bracket in the stack\n\
    \                                          ^\n/tmp/tmpngbfvtgn.swift:21:43: error:\
    \ 'nil' requires a contextual type\n    var closingBracketsStackLastBracket =\
    \ nil // last bracket in the stack\n                                         \
    \ ^\n/tmp/tmpngbfvtgn.swift:24:9: error: invalid redeclaration of 'openingBracketsStackLastBracketIndex'\n\
    \    var openingBracketsStackLastBracketIndex = -1 // index of the last opening\
    \ bracket in the stack\n        ^\n/tmp/tmpngbfvtgn.swift:22:9: note: 'openingBracketsStackLastBracketIndex'\
    \ previously declared here\n    var openingBracketsStackLastBracketIndex = -1\
    \ // index of the last opening bracket in the stack\n        ^\n/tmp/tmpngbfvtgn.swift:25:9:\
    \ error: invalid redeclaration of 'closingBracketsStackLastBracketIndex'\n   \
    \ var closingBracketsStackLastBracketIndex = -1 // index of the last closing bracket\
    \ in the stack\n        ^\n/tmp/tmpngbfvtgn.swift:23:9: note: 'closingBracketsStackLastBracketIndex'\
    \ previously declared here\n    var closingBracketsStackLastBracketIndex = -1\
    \ // index of the last closing bracket in the stack\n        ^\n/tmp/tmpngbfvtgn.swift:26:9:\
    \ error: invalid redeclaration of 'openingBracketsStackLastBracketIndex'\n   \
    \ var openingBracketsStackLastBracketIndex = -1 // index of the last opening bracket\
    \ in the stack\n        ^\n/tmp/tmpngbfvtgn.swift:22:9: note: 'openingBracketsStackLastBracketIndex'\
    \ previously declared here\n    var openingBracketsStackLastBracketIndex = -1\
    \ // index of the last opening bracket in the stack\n        ^\n/tmp/tmpngbfvtgn.swift:27:9:\
    \ error: invalid redeclaration of 'closingBracketsStackLastBracketIndex'\n   \
    \ var closingBracketsStackLastBracketIndex = -1 // index of the last closing bracket\
    \ in the stack\n        ^\n/tmp/tmpngbfvtgn.swift:23:9: note: 'closingBracketsStackLastBracketIndex'\
    \ previously declared here\n    var closingBracketsStackLastBracketIndex = -1\
    \ // index of the last closing bracket in the stack\n    "
  stdout: ''
  timestamp: 1660013961
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    func is_nested(string: String) -> Bool {\n    guard let openBracket = string.rangeOfString(\"\
    [\", options: .BackwardsSearch) else { return false }\n    guard let closeBracket\
    \ = string.rangeOfString(\"]\", options: .BackwardsSearch) else { return false\
    \ }\n    guard openBracket.location == closeBracket.location else { return false\
    \ }\n    guard openBracket.location > 0 else { return false }\n    guard closeBracket.location\
    \ < string.count else { return false }\n    \n    let openBracketIndex = string.index(openBracket.location,\
    \ offsetBy: 1)\n    let closeBracketIndex = string.index(closeBracket.location,\
    \ offsetBy: 1)\n    \n    guard openBracketIndex < closeBracketIndex else { return\
    \ false }\n    \n    let openBracketString = string[openBracketIndex..<closeBracketIndex]\n\
    \    \n    guard openBracketString.rangeOfString(\"[\", options: .BackwardsSearch)\
    \ == nil else { return false }\n    guard openBracketString.rangeOfString(\"]\"\
    , options: .BackwardsSearch) == nil else { return false }\n    \n    return true\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]][[[[[]\") == false)\nassert(is_nested(string: \"[][]\") == false)\n\
    assert(is_nested(string: \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\"\
    ) == true)\nassert(is_nested(string: \"[]]]]]]]]]]\") == false)\nassert(is_nested(string:\
    \ \"[][][[]]\") == true)\nassert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string:\
    \ \"[]]\") == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmp0j_5v_5o.swift:12:36: error: value of type 'String' has no member\
    \ 'rangeOfString'\n    guard let openBracket = string.rangeOfString(\"[\", options:\
    \ .BackwardsSearch) else { return false }\n                            ~~~~~~\
    \ ^~~~~~~~~~~~~\n/tmp/tmp0j_5v_5o.swift:12:65: error: cannot infer contextual\
    \ base in reference to member 'BackwardsSearch'\n    guard let openBracket = string.rangeOfString(\"\
    [\", options: .BackwardsSearch) else { return false }\n                      \
    \                                         ~^~~~~~~~~~~~~~~\n/tmp/tmp0j_5v_5o.swift:13:37:\
    \ error: value of type 'String' has no member 'rangeOfString'\n    guard let closeBracket\
    \ = string.rangeOfString(\"]\", options: .BackwardsSearch) else { return false\
    \ }\n                             ~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp0j_5v_5o.swift:13:66:\
    \ error: cannot infer contextual base in reference to member 'BackwardsSearch'\n\
    \    guard let closeBracket = string.rangeOfString(\"]\", options: .BackwardsSearch)\
    \ else { return false }\n                                                    \
    \            ~^~~~~~~~~~~~~~~\n/tmp/tmp0j_5v_5o.swift:25:58: error: cannot infer\
    \ contextual base in reference to member 'BackwardsSearch'\n    guard openBracketString.rangeOfString(\"\
    [\", options: .BackwardsSearch) == nil else { return false }\n               \
    \                                         ~^~~~~~~~~~~~~~~\n/tmp/tmp0j_5v_5o.swift:26:58:\
    \ error: cannot infer contextual base in reference to member 'BackwardsSearch'\n\
    \    guard openBracketString.rangeOfString(\"]\", options: .BackwardsSearch) ==\
    \ nil else { return false }\n                                                \
    \        ~^~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013961
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    func is_nested(string: String) -> Bool {\n    var stack = [String]()\n    var\
    \ open = 0\n    var close = 0\n    for i := 0; i < len(string); i++ {\n      \
    \  if string[i] == '[' {\n            open++\n            stack.append(string[i])\n\
    \        } else if string[i] == ']' {\n            close++\n            if open\
    \ > close {\n                return false\n            }\n            open--\n\
    \        }\n    }\n    return open > close\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string: \"\
    []]]]]]][[[[[]\") == false)\nassert(is_nested(string: \"[][]\") == false)\nassert(is_nested(string:\
    \ \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]]]]]\") == false)\nassert(is_nested(string: \"[][][[]]\") == true)\n\
    assert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string: \"[]]\"\
    ) == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmplpv4yima.swift:15:12: error: expected type\n    for i := 0; i <\
    \ len(string); i++ {\n           ^\n            <#type#>\n/tmp/tmplpv4yima.swift:15:12:\
    \ error: expected 'in' after for-each pattern\n    for i := 0; i < len(string);\
    \ i++ {\n           ^\n/tmp/tmplpv4yima.swift:15:12: error: expected Sequence\
    \ expression for for-each loop\n    for i := 0; i < len(string); i++ {\n     \
    \      ^\n/tmp/tmplpv4yima.swift:16:25: error: single-quoted string literal found,\
    \ use '\"'\n        if string[i] == '[' {\n                        ^~~\n     \
    \                   \"[\"\n/tmp/tmplpv4yima.swift:19:32: error: single-quoted\
    \ string literal found, use '\"'\n        } else if string[i] == ']' {\n     \
    \                          ^~~\n                               \"]\"\n"
  stdout: ''
  timestamp: 1660013960
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    func is_nested(string: String) -> Bool {\n    let openBrackets = string.count(\"\
    [\")\n    let closeBrackets = string.count(\"]\")\n    let openBracketsNesting\
    \ = openBrackets > closeBrackets\n    let closeBracketsNesting = closeBrackets\
    \ > openBrackets\n    return openBracketsNesting && closeBracketsNesting\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]][[[[[]\") == false)\nassert(is_nested(string: \"[][]\") == false)\n\
    assert(is_nested(string: \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\"\
    ) == true)\nassert(is_nested(string: \"[]]]]]]]]]]\") == false)\nassert(is_nested(string:\
    \ \"[][][[]]\") == true)\nassert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string:\
    \ \"[]]\") == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmp6c22nr4i.swift:12:31: error: cannot call value of non-function\
    \ type 'Int'\n    let openBrackets = string.count(\"[\")\n                   \
    \           ^\n/tmp/tmp6c22nr4i.swift:13:32: error: cannot call value of non-function\
    \ type 'Int'\n    let closeBrackets = string.count(\"]\")\n                  \
    \             ^\n"
  stdout: ''
  timestamp: 1660013961
- exit_code: -4
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    func is_nested(string: String) -> Bool {\n    \n    // Your code here\n    \n\
    \    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(is_nested(string:\
    \ \"[[]]\") == true)\nassert(is_nested(string: \"[]]]]]]][[[[[]\") == false)\n\
    assert(is_nested(string: \"[][]\") == false)\nassert(is_nested(string: \"[]\"\
    ) == false)\nassert(is_nested(string: \"[[[[]]]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]]]]]\") == false)\nassert(is_nested(string: \"[][][[]]\") == true)\n\
    assert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string: \"[]]\"\
    ) == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: Exception
  stderr: 'tmp4fbozzey/tmp4fbozzey.swift:32: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af698c96c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af69898db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af69898d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af69898c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp4fbozzey                        0x000056101a6522fb <unavailable> + 4859

    5    libc.so.6                          0x00002af698e82460 __libc_start_main +
    245

    6    tmp4fbozzey                        0x000056101a651ee9 <unavailable> + 3817

    '
  stdout: ''
  timestamp: 1660013961
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    func is_nested(string: String) -> Bool {\n    guard let start = string.index(of:\
    \ \"[\"),\n        let end = string.index(of: \"]\", in: start) else {\n     \
    \       return false\n    }\n    let subsequence = string[start..<end]\n    return\
    \ subsequence.contains(\"[\")\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(is_nested(string:\
    \ \"[[]]\") == true)\nassert(is_nested(string: \"[]]]]]]][[[[[]\") == false)\n\
    assert(is_nested(string: \"[][]\") == false)\nassert(is_nested(string: \"[]\"\
    ) == false)\nassert(is_nested(string: \"[[[[]]]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]]]]]\") == false)\nassert(is_nested(string: \"[][][[]]\") == true)\n\
    assert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string: \"[]]\"\
    ) == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmpd2mxj6ma.swift:12:30: warning: 'index(of:)' is deprecated: renamed\
    \ to 'firstIndex(of:)'\n    guard let start = string.index(of: \"[\"),\n     \
    \                        ^\n/tmp/tmpd2mxj6ma.swift:12:30: note: use 'firstIndex(of:)'\
    \ instead\n    guard let start = string.index(of: \"[\"),\n                  \
    \           ^~~~~\n                             firstIndex\n/tmp/tmpd2mxj6ma.swift:13:45:\
    \ error: extra argument 'in' in call\n        let end = string.index(of: \"]\"\
    , in: start) else {\n                              ~~~~~~~~~~~~~~^~~~~~\n"
  stdout: ''
  timestamp: 1660013961
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    func is_nested(string: String) -> Bool {\n    guard let index = string.index(of:\
    \ \"[\"),\n        let end = string.index(of: \"]\", in: index),\n        let\
    \ start = string.index(of: \"[\", in: end),\n        let end = string.index(of:\
    \ \"]\", in: start) else {\n            return false\n    }\n    return start\
    \ < end\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(is_nested(string: \"[[]]\"\
    ) == true)\nassert(is_nested(string: \"[]]]]]]][[[[[]\") == false)\nassert(is_nested(string:\
    \ \"[][]\") == false)\nassert(is_nested(string: \"[]\") == false)\nassert(is_nested(string:\
    \ \"[[[[]]]]\") == true)\nassert(is_nested(string: \"[]]]]]]]]]]\") == false)\n\
    assert(is_nested(string: \"[][][[]]\") == true)\nassert(is_nested(string: \"[[]\"\
    ) == false)\nassert(is_nested(string: \"[]]\") == false)\nassert(is_nested(string:\
    \ \"[[]][[\") == true)\nassert(is_nested(string: \"[[][]]\") == true)\nassert(is_nested(string:\
    \ \"\") == false)\nassert(is_nested(string: \"[[[[[[[[\") == false)\nassert(is_nested(string:\
    \ \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmpnvotb2cg.swift:12:30: warning: 'index(of:)' is deprecated: renamed\
    \ to 'firstIndex(of:)'\n    guard let index = string.index(of: \"[\"),\n     \
    \                        ^\n/tmp/tmpnvotb2cg.swift:12:30: note: use 'firstIndex(of:)'\
    \ instead\n    guard let index = string.index(of: \"[\"),\n                  \
    \           ^~~~~\n                             firstIndex\n/tmp/tmpnvotb2cg.swift:13:45:\
    \ error: extra argument 'in' in call\n        let end = string.index(of: \"]\"\
    , in: index),\n                              ~~~~~~~~~~~~~~^~~~~~\n/tmp/tmpnvotb2cg.swift:14:47:\
    \ error: extra argument 'in' in call\n        let start = string.index(of: \"\
    [\", in: end),\n                                ~~~~~~~~~~~~~~^~~~\n/tmp/tmpnvotb2cg.swift:15:45:\
    \ error: extra argument 'in' in call\n        let end = string.index(of: \"]\"\
    , in: start) else {\n                              ~~~~~~~~~~~~~~^~~~~~\n"
  stdout: ''
  timestamp: 1660013961
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    func is_nested(string: String) -> Bool {\n    var stack = [String]()\n    var\
    \ openBrackets = 0\n    for c in string {\n        if c == '[' {\n           \
    \ stack.append(c)\n            openBrackets += 1\n        } else if c == '[' {\n\
    \            openBrackets -= 1\n            if openBrackets == 0 {\n         \
    \       stack.removeLast()\n            }\n        } else if c == ']' {\n    \
    \        if openBrackets == 0 {\n                return false\n            }\n\
    \            openBrackets -= 1\n        }\n    }\n    return openBrackets == 0\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]][[[[[]\") == false)\nassert(is_nested(string: \"[][]\") == false)\n\
    assert(is_nested(string: \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\"\
    ) == true)\nassert(is_nested(string: \"[]]]]]]]]]]\") == false)\nassert(is_nested(string:\
    \ \"[][][[]]\") == true)\nassert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string:\
    \ \"[]]\") == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmpeeeffci1.swift:15:17: error: single-quoted string literal found,\
    \ use '\"'\n        if c == '[' {\n                ^~~\n                \"[\"\n\
    /tmp/tmpeeeffci1.swift:18:24: error: single-quoted string literal found, use '\"\
    '\n        } else if c == '[' {\n                       ^~~\n                \
    \       \"[\"\n/tmp/tmpeeeffci1.swift:23:24: error: single-quoted string literal\
    \ found, use '\"'\n        } else if c == ']' {\n                       ^~~\n\
    \                       \"]\"\n/tmp/tmpeeeffci1.swift:16:26: error: cannot convert\
    \ value of type 'Character' to expected argument type 'String'\n            stack.append(c)\n\
    \                         ^\n"
  stdout: ''
  timestamp: 1660013961
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    func is_nested(string: String) -> Bool {\n    let brackets = string.unicodeScalars\n\
    \        .filter { $0 != brackets.first }\n        .map { $0 }\n        .filter\
    \ { $0 != brackets.last }\n        .map { $0 }\n        .filter { $0 != brackets.first\
    \ }\n        .map { $0 }\n        .filter { $0 != brackets.last }\n        .map\
    \ { $0 }\n        .filter { $0 != brackets.first }\n        .map { $0 }\n    \
    \    .filter { $0 != brackets.last }\n        .map { $0 }\n        .filter { $0\
    \ != brackets.first }\n        .map { $0 }\n        .filter { $0 != brackets.last\
    \ }\n        .map { $0 }\n        .filter { $0 != brackets.first }\n        .map\
    \ { $0 }\n        .filter { $0 != brackets.last }\n        .map { $0 }\n     \
    \   .filter { $0 != brackets.first }\n        .map { $0 }\n        .filter { $0\
    \ != brackets.last }\n        .map { $0 }\n        .filter { $0 != brackets.first\
    \ }\n        .map { $0 }\n        .filter { $0 != brackets.last }\n        .map\
    \ { $0 }\n        .filter { $0 != brackets.first }\n        .map { $0 }\n    \
    \    .filter { $0 != brackets.last }\n        .map { $0 }\n        .filter { $0\
    \ != brackets.first }\n        .map { $0 }\n        .filter { $0 != brackets.last\
    \ }\n        .map { $0 }\n        .filter { $0 != brackets.first }\n        .map\
    \ { $0 }\n        .filter { $0 != brackets.last }\n        .map { $0 }\n     \
    \   .filter { $0 != brackets.first }\n        .map { $0 }\n        .filter { $0\
    \ != brackets.last }\n        .map { $0 }\n        .filter { $0 != brackets.first\
    \ }\n        .map { $0 }\n        .filter { $0 != brackets.last }\n        .map\
    \ { $0 }\n        .filter { $0 != brackets.first }\n        .map { $0 }\n    \
    \    .filter { $0 != brackets.last }\n        .map { $0 }\n        .filter { $0\
    \ != brackets.first }\n        .map { $0 }\n        .filter { $0 != brackets.last\
    \ }\n        .map { $0 }\n\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(is_nested(string:\
    \ \"[[]]\") == true)\nassert(is_nested(string: \"[]]]]]]][[[[[]\") == false)\n\
    assert(is_nested(string: \"[][]\") == false)\nassert(is_nested(string: \"[]\"\
    ) == false)\nassert(is_nested(string: \"[[[[]]]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]]]]]\") == false)\nassert(is_nested(string: \"[][][[]]\") == true)\n\
    assert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string: \"[]]\"\
    ) == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmpgsfi8o6p.swift:68:10: error: failed to produce diagnostic for expression;\
    \ please submit a bug report (https://swift.org/contributing/#reporting-bugs)\
    \ and include the project\n        .map { $0 }\n         ^\n"
  stdout: ''
  timestamp: 1660013960
- exit_code: -4
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    func is_nested(string: String) -> Bool {\n    \n    // Your code here\n    \n\
    \    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(is_nested(string:\
    \ \"[[]]\") == true)\nassert(is_nested(string: \"[]]]]]]][[[[[]\") == false)\n\
    assert(is_nested(string: \"[][]\") == false)\nassert(is_nested(string: \"[]\"\
    ) == false)\nassert(is_nested(string: \"[[[[]]]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]]]]]\") == false)\nassert(is_nested(string: \"[][][[]]\") == true)\n\
    assert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string: \"[]]\"\
    ) == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: Exception
  stderr: 'tmp4fbozzey/tmp4fbozzey.swift:32: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af698c96c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af69898db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af69898d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af69898c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp4fbozzey                        0x000056101a6522fb <unavailable> + 4859

    5    libc.so.6                          0x00002af698e82460 __libc_start_main +
    245

    6    tmp4fbozzey                        0x000056101a651ee9 <unavailable> + 3817

    '
  stdout: ''
  timestamp: 1660013961
- exit_code: -4
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    func is_nested(string: String) -> Bool {\n    \n    // Your code here\n    \n\
    \    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(is_nested(string:\
    \ \"[[]]\") == true)\nassert(is_nested(string: \"[]]]]]]][[[[[]\") == false)\n\
    assert(is_nested(string: \"[][]\") == false)\nassert(is_nested(string: \"[]\"\
    ) == false)\nassert(is_nested(string: \"[[[[]]]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]]]]]\") == false)\nassert(is_nested(string: \"[][][[]]\") == true)\n\
    assert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string: \"[]]\"\
    ) == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: Exception
  stderr: 'tmp4fbozzey/tmp4fbozzey.swift:32: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af698c96c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af69898db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af69898d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af69898c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp4fbozzey                        0x000056101a6522fb <unavailable> + 4859

    5    libc.so.6                          0x00002af698e82460 __libc_start_main +
    245

    6    tmp4fbozzey                        0x000056101a651ee9 <unavailable> + 3817

    '
  stdout: ''
  timestamp: 1660013961
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    func is_nested(string: String) -> Bool {\n    var stack = [String]()\n    for\
    \ c in string {\n        if c == '[' {\n            stack.append(c)\n        }\
    \ else if c == ']' {\n            if stack.count > 0 {\n                stack.removeLast()\n\
    \            } else {\n                return false\n            }\n        }\n\
    \    }\n    return stack.count == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string: \"[]]]]]]][[[[[]\"\
    ) == false)\nassert(is_nested(string: \"[][]\") == false)\nassert(is_nested(string:\
    \ \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]]]]]\") == false)\nassert(is_nested(string: \"[][][[]]\") == true)\n\
    assert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string: \"[]]\"\
    ) == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmpzazkqnwh.swift:14:17: error: single-quoted string literal found,\
    \ use '\"'\n        if c == '[' {\n                ^~~\n                \"[\"\n\
    /tmp/tmpzazkqnwh.swift:16:24: error: single-quoted string literal found, use '\"\
    '\n        } else if c == ']' {\n                       ^~~\n                \
    \       \"]\"\n/tmp/tmpzazkqnwh.swift:15:26: error: cannot convert value of type\
    \ 'Character' to expected argument type 'String'\n            stack.append(c)\n\
    \                         ^\n"
  stdout: ''
  timestamp: 1660013961
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    func is_nested(string: String) -> Bool {\n    guard let openBracket = string.rangeOfString(\"\
    [\", options: .LiteralSearch, range: nil, locale: nil) else {\n        return\
    \ false\n    }\n    guard let closeBracket = string.rangeOfString(\"]\", options:\
    \ .LiteralSearch, range: nil, locale: nil) else {\n        return false\n    }\n\
    \    guard openBracket.location != closeBracket.location else {\n        return\
    \ false\n    }\n    guard openBracket.location > closeBracket.location else {\n\
    \        return false\n    }\n    guard openBracket.location < string.endIndex\
    \ else {\n        return false\n    }\n    guard closeBracket.location > string.endIndex\
    \ else {\n        return false\n    }\n    guard closeBracket.location < openBracket.location\
    \ else {\n        return false\n    }\n    guard let openBracketIndex = string.index(openBracket,\
    \ offsetBy: 1) {\n        return false\n    }\n    guard let closeBracketIndex\
    \ = string.index(closeBracket, offsetBy: 1) {\n        return false\n    }\n \
    \   guard openBracketIndex < closeBracketIndex else {\n        return false\n\
    \    }\n    guard let openBracket = string.substring(to: openBracketIndex),\n\
    \        let closeBracket = string.substring(to: closeBracketIndex),\n       \
    \ let openBracketRange = string.range(of: openBracket, options: .LiteralSearch,\
    \ range: nil, locale: nil),\n        let closeBracketRange = string.range(of:\
    \ closeBracket, options: .LiteralSearch, range: nil, locale: nil)\n    else {\n\
    \        return false\n    }\n    return openBracketRange.lowerBound < closeBracketRange.lowerBound\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]][[[[[]\") == false)\nassert(is_nested(string: \"[][]\") == false)\n\
    assert(is_nested(string: \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\"\
    ) == true)\nassert(is_nested(string: \"[]]]]]]]]]]\") == false)\nassert(is_nested(string:\
    \ \"[][][[]]\") == true)\nassert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string:\
    \ \"[]]\") == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmp556_mp9s.swift:33:73: error: expected 'else' after 'guard' condition\n\
    \    guard let openBracketIndex = string.index(openBracket, offsetBy: 1) {\n \
    \                                                                       ^\n  \
    \                                                                      else \n\
    /tmp/tmp556_mp9s.swift:36:75: error: expected 'else' after 'guard' condition\n\
    \    guard let closeBracketIndex = string.index(closeBracket, offsetBy: 1) {\n\
    \                                                                          ^\n\
    \                                                                          else\
    \ \n/tmp/tmp556_mp9s.swift:12:36: error: value of type 'String' has no member\
    \ 'rangeOfString'\n    guard let openBracket = string.rangeOfString(\"[\", options:\
    \ .LiteralSearch, range: nil, locale: nil) else {\n                          \
    \  ~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp556_mp9s.swift:12:65: error: cannot infer contextual\
    \ base in reference to member 'LiteralSearch'\n    guard let openBracket = string.rangeOfString(\"\
    [\", options: .LiteralSearch, range: nil, locale: nil) else {\n              \
    \                                                 ~^~~~~~~~~~~~~\n/tmp/tmp556_mp9s.swift:12:87:\
    \ error: 'nil' requires a contextual type\n    guard let openBracket = string.rangeOfString(\"\
    [\", options: .LiteralSearch, range: nil, locale: nil) else {\n              \
    \                                                                        ^\n/tmp/tmp556_mp9s.swift:12:100:\
    \ error: 'nil' requires a contextual type\n    guard let openBracket = string.rangeOfString(\"\
    [\", options: .LiteralSearch, range: nil, locale: nil) else {\n              \
    \                                                                            \
    \         ^\n/tmp/tmp556_mp9s.swift:15:37: error: value of type 'String' has no\
    \ member 'rangeOfString'\n    guard let closeBracket = string.rangeOfString(\"\
    ]\", options: .LiteralSearch, range: nil, locale: nil) else {\n              \
    \               ~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp556_mp9s.swift:15:66: error: cannot\
    \ infer contextual base in reference to member"
  stdout: ''
  timestamp: 1660013961
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    func is_nested(string: String) -> Bool {\n    let stack = Stack()\n    for char\
    \ in string {\n        if char == '[' {\n            stack.push(char)\n      \
    \  } else if char == ']' {\n            if stack.top() == '[' {\n            \
    \    stack.pop()\n            } else {\n                return false\n       \
    \     }\n        }\n    }\n    return stack.top() == nil\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]][[[[[]\") == false)\nassert(is_nested(string: \"[][]\") == false)\n\
    assert(is_nested(string: \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\"\
    ) == true)\nassert(is_nested(string: \"[]]]]]]]]]]\") == false)\nassert(is_nested(string:\
    \ \"[][][[]]\") == true)\nassert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string:\
    \ \"[]]\") == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmpzyiji9c1.swift:14:20: error: single-quoted string literal found,\
    \ use '\"'\n        if char == '[' {\n                   ^~~\n               \
    \    \"[\"\n/tmp/tmpzyiji9c1.swift:16:27: error: single-quoted string literal\
    \ found, use '\"'\n        } else if char == ']' {\n                         \
    \ ^~~\n                          \"]\"\n/tmp/tmpzyiji9c1.swift:17:31: error: single-quoted\
    \ string literal found, use '\"'\n            if stack.top() == '[' {\n      \
    \                        ^~~\n                              \"[\"\n/tmp/tmpzyiji9c1.swift:12:17:\
    \ error: cannot find 'Stack' in scope\n    let stack = Stack()\n             \
    \   ^~~~~\n"
  stdout: ''
  timestamp: 1660013961
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    func is_nested(string: String) -> Bool {\n    guard let start = string.index(of:\
    \ \"[\"),\n        let end = string.index(of: \"]\"),\n        let start = string.index(of:\
    \ \"[\", range: start..<end),\n        let end = string.index(of: \"]\", range:\
    \ start..<end),\n        let start = string.index(of: \"[\", range: start..<end),\n\
    \        let end = string.index(of: \"]\", range: start..<end),\n        let start\
    \ = string.index(of: \"[\", range: start..<end),\n        let end = string.index(of:\
    \ \"]\", range: start..<end),\n        let start = string.index(of: \"[\", range:\
    \ start..<end),\n        let end = string.index(of: \"]\", range: start..<end),\n\
    \        let start = string.index(of: \"[\", range: start..<end),\n        let\
    \ end = string.index(of: \"]\", range: start..<end),\n        let start = string.index(of:\
    \ \"[\", range: start..<end),\n        let end = string.index(of: \"]\", range:\
    \ start..<end),\n        let start = string.index(of: \"[\", range: start..<end),\n\
    \        let end = string.index(of: \"]\", range: start..<end),\n        let start\
    \ = string.index(of: \"[\", range: start..<end),\n        let end = string.index(of:\
    \ \"]\", range: start..<end),\n        let start = string.index(of: \"[\", range:\
    \ start..<end),\n        let end = string.index(of: \"]\", range: start..<end),\n\
    \        let start = string.index(of: \"[\", range: start..<end),\n        let\
    \ end = string.index(of: \"]\", range: start..<end),\n        let start = string.index(of:\
    \ \"[\", range: start..<end),\n        let end = string.index(of: \"]\", range:\
    \ start..<end),\n        let start = string.index(of: \"[\", range: start..<end),\n\
    \        let end = string.index(of: \"]\", range: start..<end),\n        let start\
    \ = string.index(of: \"[\", range: start..<end),\n        let end = string.index(of:\
    \ \"]\", range: start..<end),\n        let start = string.index(of: \"[\", range:\
    \ start..<end),\n        let end = string.index(of: \"]\", range: start..<end),\n\
    \        let start = string.index(of: \"[\", range: start..<end),\n        let\
    \ end = string.index(of: \"]\", range: start..<end),\n        let start = string.index(of:\
    \ \"[\", range: start.\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(is_nested(string:\
    \ \"[[]]\") == true)\nassert(is_nested(string: \"[]]]]]]][[[[[]\") == false)\n\
    assert(is_nested(string: \"[][]\") == false)\nassert(is_nested(string: \"[]\"\
    ) == false)\nassert(is_nested(string: \"[[[[]]]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]]]]]\") == false)\nassert(is_nested(string: \"[][][[]]\") == true)\n\
    assert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string: \"[]]\"\
    ) == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmpwmsls8_p.swift:44:55: error: expected member name following '.'\n\
    \        let start = string.index(of: \"[\", range: start.\n                 \
    \                                     ^\n/tmp/tmpwmsls8_p.swift:45:1: error: expected\
    \ ')' in expression list\n}\n^\n/tmp/tmpwmsls8_p.swift:44:33: note: to match this\
    \ opening '('\n        let start = string.index(of: \"[\", range: start.\n   \
    \                             ^\n/tmp/tmpwmsls8_p.swift:44:56: error: expected\
    \ 'else' after 'guard' condition\n        let start = string.index(of: \"[\",\
    \ range: start.\n                                                       ^\n/tmp/tmpwmsls8_p.swift:12:30:\
    \ warning: 'index(of:)' is deprecated: renamed to 'firstIndex(of:)'\n    guard\
    \ let start = string.index(of: \"[\"),\n                             ^\n/tmp/tmpwmsls8_p.swift:12:30:\
    \ note: use 'firstIndex(of:)' instead\n    guard let start = string.index(of:\
    \ \"[\"),\n                             ^~~~~\n                             firstIndex\n\
    /tmp/tmpwmsls8_p.swift:13:26: warning: 'index(of:)' is deprecated: renamed to\
    \ 'firstIndex(of:)'\n        let end = string.index(of: \"]\"),\n            \
    \             ^\n/tmp/tmpwmsls8_p.swift:13:26: note: use 'firstIndex(of:)' instead\n\
    \        let end = string.index(of: \"]\"),\n                         ^~~~~\n\
    \                         firstIndex\n/tmp/tmpwmsls8_p.swift:14:55: error: extra\
    \ argument 'range' in call\n        let start = string.index(of: \"[\", range:\
    \ start..<end),\n                                ~~~~~~~~~~~~~~~~~~~~~~^~~~~~~\n\
    /tmp/tmpwmsls8_p.swift:15:53: error: extra argument 'range' in call\n        let\
    \ end = string.index(of: \"]\", range: start..<end),\n                       \
    \       ~~~~~~~~~~~~~~~~~~~~~~^~~~~~~\n/tmp/tmpwmsls8_p.swift:16:55: error: extra\
    \ argument 'range' in call\n        let start = string.index(of: \"[\", range:\
    \ start..<end),\n                                ~~~~~~~~~~~~~~~~~~~~~~^~~~~~~\n\
    /tmp/tmpwmsls8_p.swift:17:53: error: extra argument 'range' in call\n        let\
    \ end = string.index(of: \"]\", range: start..<end),\n                       \
    \       ~~~~~~~~~~~~~~~~~~~~"
  stdout: ''
  timestamp: 1660013961
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    func is_nested(string: String) -> Bool {\n    var stack = [String]()\n    var\
    \ open = 0\n    var close = 0\n    for i := 0; i < len(string); i++ {\n      \
    \  if string[i] == '[' {\n            open++\n            stack.append(string[i])\n\
    \        } else if string[i] == ']' {\n            close++\n            if open\
    \ > close {\n                return false\n            }\n            open--\n\
    \            stack.pop()\n        }\n    }\n    return open > close\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]][[[[[]\") == false)\nassert(is_nested(string: \"[][]\") == false)\n\
    assert(is_nested(string: \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\"\
    ) == true)\nassert(is_nested(string: \"[]]]]]]]]]]\") == false)\nassert(is_nested(string:\
    \ \"[][][[]]\") == true)\nassert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string:\
    \ \"[]]\") == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmpx4qdhnax.swift:15:12: error: expected type\n    for i := 0; i <\
    \ len(string); i++ {\n           ^\n            <#type#>\n/tmp/tmpx4qdhnax.swift:15:12:\
    \ error: expected 'in' after for-each pattern\n    for i := 0; i < len(string);\
    \ i++ {\n           ^\n/tmp/tmpx4qdhnax.swift:15:12: error: expected Sequence\
    \ expression for for-each loop\n    for i := 0; i < len(string); i++ {\n     \
    \      ^\n/tmp/tmpx4qdhnax.swift:16:25: error: single-quoted string literal found,\
    \ use '\"'\n        if string[i] == '[' {\n                        ^~~\n     \
    \                   \"[\"\n/tmp/tmpx4qdhnax.swift:19:32: error: single-quoted\
    \ string literal found, use '\"'\n        } else if string[i] == ']' {\n     \
    \                          ^~~\n                               \"]\"\n"
  stdout: ''
  timestamp: 1660013961
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    func is_nested(string: String) -> Bool {\n    let brackets = string.unicodeScalars.filter({\
    \ $0.value > 0 })\n    \n    if brackets.count < 1 {\n        return false\n \
    \   }\n    \n    let openingBrackets = brackets.filter({ $0.value == 1 })\n  \
    \  \n    if openingBrackets.count < 1 {\n        return false\n    }\n    \n \
    \   let closingBrackets = brackets.filter({ $0.value == -1 })\n    \n    if closingBrackets.count\
    \ < 1 {\n        return false\n    }\n    \n    let nestedBrackets = openingBrackets.reduce(into:\
    \ [String](), { $0.append($0.last!) })\n    \n    return closingBrackets.reduce(into:\
    \ [String](), { $0.append($0.last!) }).contains(nestedBrackets)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]][[[[[]\") == false)\nassert(is_nested(string: \"[][]\") == false)\n\
    assert(is_nested(string: \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\"\
    ) == true)\nassert(is_nested(string: \"[]]]]]]]]]]\") == false)\nassert(is_nested(string:\
    \ \"[][][[]]\") == true)\nassert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string:\
    \ \"[]]\") == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmprm0rkqqx.swift:30:67: error: contextual closure type '(inout [String],\
    \ Unicode.Scalar) throws -> ()' expects 2 arguments, but 1 was used in closure\
    \ body\n    let nestedBrackets = openingBrackets.reduce(into: [String](), { $0.append($0.last!)\
    \ })\n                                                                  ^\n/tmp/tmprm0rkqqx.swift:32:53:\
    \ error: contextual closure type '(inout [String], Unicode.Scalar) throws -> ()'\
    \ expects 2 arguments, but 1 was used in closure body\n    return closingBrackets.reduce(into:\
    \ [String](), { $0.append($0.last!) }).contains(nestedBrackets)\n            \
    \                                        ^\n"
  stdout: ''
  timestamp: 1660013961
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    func is_nested(string: String) -> Bool {\n    guard let index = string.index(of:\
    \ \"[\"),\n        let end = string.index(of: \"]\", range: start..<string.endIndex),\n\
    \        string.distance(from: start, to: end) == 1 else {\n        return false\n\
    \    }\n    return is_nested(string[start..<end])\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]][[[[[]\") == false)\nassert(is_nested(string: \"[][]\") == false)\n\
    assert(is_nested(string: \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\"\
    ) == true)\nassert(is_nested(string: \"[]]]]]]]]]]\") == false)\nassert(is_nested(string:\
    \ \"[][][[]]\") == true)\nassert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string:\
    \ \"[]]\") == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmpddpmondj.swift:12:30: warning: 'index(of:)' is deprecated: renamed\
    \ to 'firstIndex(of:)'\n    guard let index = string.index(of: \"[\"),\n     \
    \                        ^\n/tmp/tmpddpmondj.swift:12:30: note: use 'firstIndex(of:)'\
    \ instead\n    guard let index = string.index(of: \"[\"),\n                  \
    \           ^~~~~\n                             firstIndex\n/tmp/tmpddpmondj.swift:13:48:\
    \ error: cannot find 'start' in scope\n        let end = string.index(of: \"]\"\
    , range: start..<string.endIndex),\n                                         \
    \      ^~~~~\n/tmp/tmpddpmondj.swift:13:53: error: extra argument 'range' in call\n\
    \        let end = string.index(of: \"]\", range: start..<string.endIndex),\n\
    \                              ~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~\n/tmp/tmpddpmondj.swift:14:31:\
    \ error: cannot find 'start' in scope\n        string.distance(from: start, to:\
    \ end) == 1 else {\n                              ^~~~~\n/tmp/tmpddpmondj.swift:17:29:\
    \ error: cannot find 'start' in scope\n    return is_nested(string[start..<end])\n\
    \                            ^~~~~\n/tmp/tmpddpmondj.swift:17:22: error: missing\
    \ argument label 'string:' in call\n    return is_nested(string[start..<end])\n\
    \                     ^\n                     string: \n"
  stdout: ''
  timestamp: 1660013961
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    func is_nested(string: String) -> Bool {\n    let stack = Stack()\n    for char\
    \ in string {\n        if char == '[' {\n            stack.push(char)\n      \
    \  } else if char == ']' {\n            if stack.isEmpty {\n                return\
    \ false\n            }\n            let top = stack.top()\n            if top\
    \ == '[' {\n                stack.pop()\n            } else {\n              \
    \  return false\n            }\n        }\n    }\n    return stack.isEmpty\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]][[[[[]\") == false)\nassert(is_nested(string: \"[][]\") == false)\n\
    assert(is_nested(string: \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\"\
    ) == true)\nassert(is_nested(string: \"[]]]]]]]]]]\") == false)\nassert(is_nested(string:\
    \ \"[][][[]]\") == true)\nassert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string:\
    \ \"[]]\") == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmpud7rf5ch.swift:14:20: error: single-quoted string literal found,\
    \ use '\"'\n        if char == '[' {\n                   ^~~\n               \
    \    \"[\"\n/tmp/tmpud7rf5ch.swift:16:27: error: single-quoted string literal\
    \ found, use '\"'\n        } else if char == ']' {\n                         \
    \ ^~~\n                          \"]\"\n/tmp/tmpud7rf5ch.swift:21:23: error: single-quoted\
    \ string literal found, use '\"'\n            if top == '[' {\n              \
    \        ^~~\n                      \"[\"\n/tmp/tmpud7rf5ch.swift:12:17: error:\
    \ cannot find 'Stack' in scope\n    let stack = Stack()\n                ^~~~~\n"
  stdout: ''
  timestamp: 1660013961
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    func is_nested(string: String) -> Bool {\n    guard let start = string.index(of:\
    \ \"[\"), let end = string.index(of: \"]\") else {\n        return false\n   \
    \ }\n    let range = start..<end\n    let openBrackets = string.components(separatedBy:\
    \ \"]\").filter({ $0.contains(\"[\") })\n    let closeBrackets = string.components(separatedBy:\
    \ \"]\").filter({ $0.contains(\"[\") }).reversed()\n    let openBracketsCount\
    \ = openBrackets.count\n    let closeBracketsCount = closeBrackets.count\n   \
    \ let openBracketsNesting = (openBracketsCount - closeBracketsCount) > 0\n   \
    \ let closeBracketsNesting = (closeBracketsCount - openBracketsCount) > 0\n  \
    \  return openBracketsNesting && closeBracketsNesting\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]][[[[[]\") == false)\nassert(is_nested(string: \"[][]\") == false)\n\
    assert(is_nested(string: \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\"\
    ) == true)\nassert(is_nested(string: \"[]]]]]]]]]]\") == false)\nassert(is_nested(string:\
    \ \"[][][[]]\") == true)\nassert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string:\
    \ \"[]]\") == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmpdp3gwyv0.swift:12:30: warning: 'index(of:)' is deprecated: renamed\
    \ to 'firstIndex(of:)'\n    guard let start = string.index(of: \"[\"), let end\
    \ = string.index(of: \"]\") else {\n                             ^\n/tmp/tmpdp3gwyv0.swift:12:30:\
    \ note: use 'firstIndex(of:)' instead\n    guard let start = string.index(of:\
    \ \"[\"), let end = string.index(of: \"]\") else {\n                         \
    \    ^~~~~\n                             firstIndex\n/tmp/tmpdp3gwyv0.swift:12:63:\
    \ warning: 'index(of:)' is deprecated: renamed to 'firstIndex(of:)'\n    guard\
    \ let start = string.index(of: \"[\"), let end = string.index(of: \"]\") else\
    \ {\n                                                              ^\n/tmp/tmpdp3gwyv0.swift:12:63:\
    \ note: use 'firstIndex(of:)' instead\n    guard let start = string.index(of:\
    \ \"[\"), let end = string.index(of: \"]\") else {\n                         \
    \                                     ^~~~~\n                                \
    \                              firstIndex\n/tmp/tmpdp3gwyv0.swift:16:31: error:\
    \ value of type 'String' has no member 'components'\n    let openBrackets = string.components(separatedBy:\
    \ \"]\").filter({ $0.contains(\"[\") })\n                       ~~~~~~ ^~~~~~~~~~\n\
    /tmp/tmpdp3gwyv0.swift:17:32: error: value of type 'String' has no member 'components'\n\
    \    let closeBrackets = string.components(separatedBy: \"]\").filter({ $0.contains(\"\
    [\") }).reversed()\n                        ~~~~~~ ^~~~~~~~~~\n/tmp/tmpdp3gwyv0.swift:20:50:\
    \ error: cannot convert value of type 'Duration' to expected argument type 'Int'\n\
    \    let openBracketsNesting = (openBracketsCount - closeBracketsCount) > 0\n\
    \                                                 ^\n/tmp/tmpdp3gwyv0.swift:21:52:\
    \ error: cannot convert value of type 'Duration' to expected argument type 'Int'\n\
    \    let closeBracketsNesting = (closeBracketsCount - openBracketsCount) > 0\n\
    \                                                   ^\n"
  stdout: ''
  timestamp: 1660013961
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    func is_nested(string: String) -> Bool {\n    guard let openBracket = string.rangeOfString(\"\
    [\", options: .LiteralSearch, range: nil, locale: nil) else {\n        return\
    \ false\n    }\n    guard let closeBracket = string.rangeOfString(\"]\", options:\
    \ .LiteralSearch, range: nil, locale: nil) else {\n        return false\n    }\n\
    \    guard openBracket.location != closeBracket.location else {\n        return\
    \ false\n    }\n    guard openBracket.location != string.endIndex else {\n   \
    \     return false\n    }\n    guard closeBracket.location != string.startIndex\
    \ else {\n        return false\n    }\n    let openBracketIndex = string.startIndex\n\
    \    let closeBracketIndex = openBracketIndex + closeBracket.location - openBracket.location\n\
    \    guard openBracketIndex <= closeBracketIndex else {\n        return false\n\
    \    }\n    let openBracketCount = string.distance(from: openBracketIndex, to:\
    \ closeBracketIndex)\n    let closeBracketCount = string.distance(from: openBracketIndex,\
    \ to: closeBracketIndex + 1)\n    return openBracketCount == closeBracketCount\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]][[[[[]\") == false)\nassert(is_nested(string: \"[][]\") == false)\n\
    assert(is_nested(string: \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\"\
    ) == true)\nassert(is_nested(string: \"[]]]]]]]]]]\") == false)\nassert(is_nested(string:\
    \ \"[][][[]]\") == true)\nassert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string:\
    \ \"[]]\") == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmphxsr8sp4.swift:12:36: error: value of type 'String' has no member\
    \ 'rangeOfString'\n    guard let openBracket = string.rangeOfString(\"[\", options:\
    \ .LiteralSearch, range: nil, locale: nil) else {\n                          \
    \  ~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmphxsr8sp4.swift:12:65: error: cannot infer contextual\
    \ base in reference to member 'LiteralSearch'\n    guard let openBracket = string.rangeOfString(\"\
    [\", options: .LiteralSearch, range: nil, locale: nil) else {\n              \
    \                                                 ~^~~~~~~~~~~~~\n/tmp/tmphxsr8sp4.swift:12:87:\
    \ error: 'nil' requires a contextual type\n    guard let openBracket = string.rangeOfString(\"\
    [\", options: .LiteralSearch, range: nil, locale: nil) else {\n              \
    \                                                                        ^\n/tmp/tmphxsr8sp4.swift:12:100:\
    \ error: 'nil' requires a contextual type\n    guard let openBracket = string.rangeOfString(\"\
    [\", options: .LiteralSearch, range: nil, locale: nil) else {\n              \
    \                                                                            \
    \         ^\n/tmp/tmphxsr8sp4.swift:15:37: error: value of type 'String' has no\
    \ member 'rangeOfString'\n    guard let closeBracket = string.rangeOfString(\"\
    ]\", options: .LiteralSearch, range: nil, locale: nil) else {\n              \
    \               ~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmphxsr8sp4.swift:15:66: error: cannot\
    \ infer contextual base in reference to member 'LiteralSearch'\n    guard let\
    \ closeBracket = string.rangeOfString(\"]\", options: .LiteralSearch, range: nil,\
    \ locale: nil) else {\n                                                      \
    \          ~^~~~~~~~~~~~~\n/tmp/tmphxsr8sp4.swift:15:88: error: 'nil' requires\
    \ a contextual type\n    guard let closeBracket = string.rangeOfString(\"]\",\
    \ options: .LiteralSearch, range: nil, locale: nil) else {\n                 \
    \                                                                      ^\n/tmp/tmphxsr8sp4.swift:15:101:\
    \ error: 'nil' requires a contextual type\n    guard let closeBracket = string.rangeOfString(\"\
    ]\", options"
  stdout: ''
  timestamp: 1660013961
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    func is_nested(string: String) -> Bool {\n    var openingBracketCount = 0\n  \
    \  var closingBracketCount = 0\n    var openingBracket = String()\n    var closingBracket\
    \ = String()\n    for i := 0; i < len(string); i++ {\n        if string[i] ==\
    \ '[' {\n            openingBracketCount++\n            openingBracket = openingBracket.stringByAppendingString(string[i])\n\
    \        } else if string[i] == ']' {\n            closingBracketCount++\n   \
    \         closingBracket = closingBracket.stringByAppendingString(string[i])\n\
    \        } else if openingBracketCount > 0 && closingBracketCount > 0 {\n    \
    \        if openingBracketCount < closingBracketCount {\n                if openingBracket.rangeOfString(closingBracket)\
    \ != nil {\n                    return true\n                }\n            }\
    \ else {\n                if openingBracket.rangeOfString(closingBracket) == nil\
    \ {\n                    return true\n                }\n            }\n     \
    \       openingBracketCount = 0\n            closingBracketCount = 0\n       \
    \     openingBracket = String()\n            closingBracket = String()\n     \
    \   }\n    }\n    return false\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(is_nested(string:\
    \ \"[[]]\") == true)\nassert(is_nested(string: \"[]]]]]]][[[[[]\") == false)\n\
    assert(is_nested(string: \"[][]\") == false)\nassert(is_nested(string: \"[]\"\
    ) == false)\nassert(is_nested(string: \"[[[[]]]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]]]]]\") == false)\nassert(is_nested(string: \"[][][[]]\") == true)\n\
    assert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string: \"[]]\"\
    ) == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmpyfqjig9q.swift:16:12: error: expected type\n    for i := 0; i <\
    \ len(string); i++ {\n           ^\n            <#type#>\n/tmp/tmpyfqjig9q.swift:16:12:\
    \ error: expected 'in' after for-each pattern\n    for i := 0; i < len(string);\
    \ i++ {\n           ^\n/tmp/tmpyfqjig9q.swift:16:12: error: expected Sequence\
    \ expression for for-each loop\n    for i := 0; i < len(string); i++ {\n     \
    \      ^\n/tmp/tmpyfqjig9q.swift:17:25: error: single-quoted string literal found,\
    \ use '\"'\n        if string[i] == '[' {\n                        ^~~\n     \
    \                   \"[\"\n/tmp/tmpyfqjig9q.swift:20:32: error: single-quoted\
    \ string literal found, use '\"'\n        } else if string[i] == ']' {\n     \
    \                          ^~~\n                               \"]\"\n"
  stdout: ''
  timestamp: 1660013961
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    func is_nested(string: String) -> Bool {\n    let stack = Stack<String>()\n  \
    \  for character in string {\n        if character == '[' {\n            stack.push(character)\n\
    \        } else if character == ']' {\n            if stack.count > 0 {\n    \
    \            stack.pop()\n            } else {\n                return false\n\
    \            }\n        }\n    }\n    return stack.count == 0\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]][[[[[]\") == false)\nassert(is_nested(string: \"[][]\") == false)\n\
    assert(is_nested(string: \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\"\
    ) == true)\nassert(is_nested(string: \"[]]]]]]]]]]\") == false)\nassert(is_nested(string:\
    \ \"[][][[]]\") == true)\nassert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string:\
    \ \"[]]\") == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmpzbivf8jl.swift:14:25: error: single-quoted string literal found,\
    \ use '\"'\n        if character == '[' {\n                        ^~~\n     \
    \                   \"[\"\n/tmp/tmpzbivf8jl.swift:16:32: error: single-quoted\
    \ string literal found, use '\"'\n        } else if character == ']' {\n     \
    \                          ^~~\n                               \"]\"\n/tmp/tmpzbivf8jl.swift:12:17:\
    \ error: cannot find 'Stack' in scope\n    let stack = Stack<String>()\n     \
    \           ^~~~~\n"
  stdout: ''
  timestamp: 1660013961
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    func is_nested(string: String) -> Bool {\n    guard let openingBracket = string.rangeOfString(\"\
    [\", options: .LiteralSearch, range: nil, locale: nil) else {\n        return\
    \ false\n    }\n    guard let closingBracket = string.rangeOfString(\"]\", options:\
    \ .LiteralSearch, range: nil, locale: nil) else {\n        return false\n    }\n\
    \    guard openingBracket.location != closingBracket.location else {\n       \
    \ return false\n    }\n    guard openingBracket.location > 0 else {\n        return\
    \ false\n    }\n    guard closingBracket.location < string.count else {\n    \
    \    return false\n    }\n    guard let openingBracketIndex = string.index(string.startIndex,\
    \ offsetBy: openingBracket.location),\n        let closingBracketIndex = string.index(string.startIndex,\
    \ offsetBy: closingBracket.location),\n        openingBracketIndex < closingBracketIndex\
    \ + 1 else {\n        return false\n    }\n    let openingBracket = string[openingBracketIndex].unicodeScalars.first!\n\
    \    let closingBracket = string[closingBracketIndex].unicodeScalars.first!\n\
    \    guard openingBracket == closingBracket else {\n        return false\n   \
    \ }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(is_nested(string:\
    \ \"[[]]\") == true)\nassert(is_nested(string: \"[]]]]]]][[[[[]\") == false)\n\
    assert(is_nested(string: \"[][]\") == false)\nassert(is_nested(string: \"[]\"\
    ) == false)\nassert(is_nested(string: \"[[[[]]]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]]]]]\") == false)\nassert(is_nested(string: \"[][][[]]\") == true)\n\
    assert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string: \"[]]\"\
    ) == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmp3e8djdco.swift:12:39: error: value of type 'String' has no member\
    \ 'rangeOfString'\n    guard let openingBracket = string.rangeOfString(\"[\",\
    \ options: .LiteralSearch, range: nil, locale: nil) else {\n                 \
    \              ~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp3e8djdco.swift:12:68: error: cannot\
    \ infer contextual base in reference to member 'LiteralSearch'\n    guard let\
    \ openingBracket = string.rangeOfString(\"[\", options: .LiteralSearch, range:\
    \ nil, locale: nil) else {\n                                                 \
    \                 ~^~~~~~~~~~~~~\n/tmp/tmp3e8djdco.swift:12:90: error: 'nil' requires\
    \ a contextual type\n    guard let openingBracket = string.rangeOfString(\"[\"\
    , options: .LiteralSearch, range: nil, locale: nil) else {\n                 \
    \                                                                        ^\n/tmp/tmp3e8djdco.swift:12:103:\
    \ error: 'nil' requires a contextual type\n    guard let openingBracket = string.rangeOfString(\"\
    [\", options: .LiteralSearch, range: nil, locale: nil) else {\n              \
    \                                                                            \
    \            ^\n/tmp/tmp3e8djdco.swift:15:39: error: value of type 'String' has\
    \ no member 'rangeOfString'\n    guard let closingBracket = string.rangeOfString(\"\
    ]\", options: .LiteralSearch, range: nil, locale: nil) else {\n              \
    \                 ~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp3e8djdco.swift:15:68: error: cannot\
    \ infer contextual base in reference to member 'LiteralSearch'\n    guard let\
    \ closingBracket = string.rangeOfString(\"]\", options: .LiteralSearch, range:\
    \ nil, locale: nil) else {\n                                                 \
    \                 ~^~~~~~~~~~~~~\n/tmp/tmp3e8djdco.swift:15:90: error: 'nil' requires\
    \ a contextual type\n    guard let closingBracket = string.rangeOfString(\"]\"\
    , options: .LiteralSearch, range: nil, locale: nil) else {\n                 \
    \                                                                        ^\n/tmp/tmp3e8djdco.swift:15:103:\
    \ error: 'nil' requires a contextual type\n    guard let closingBrack"
  stdout: ''
  timestamp: 1660013961
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    func is_nested(string: String) -> Bool {\n    guard let start = string.index(of:\
    \ \"[\"),\n        let end = string.index(of: \"]\"),\n        start < end else\
    \ {\n            return false\n    }\n    \n    let stack = Array<Character>()\n\
    \    stack.append(contentsOf: string.unicodeScalars)\n    \n    var openingBrackets\
    \ = 0\n    var closingBrackets = 0\n    \n    for scalar in stack {\n        if\
    \ scalar == Character(\"[\") {\n            openingBrackets += 1\n        }\n\
    \        if scalar == Character(\"]\") {\n            closingBrackets += 1\n \
    \       }\n    }\n    \n    return openingBrackets == closingBrackets\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]][[[[[]\") == false)\nassert(is_nested(string: \"[][]\") == false)\n\
    assert(is_nested(string: \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\"\
    ) == true)\nassert(is_nested(string: \"[]]]]]]]]]]\") == false)\nassert(is_nested(string:\
    \ \"[][][[]]\") == true)\nassert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string:\
    \ \"[]]\") == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmp9jumw5di.swift:12:30: warning: 'index(of:)' is deprecated: renamed\
    \ to 'firstIndex(of:)'\n    guard let start = string.index(of: \"[\"),\n     \
    \                        ^\n/tmp/tmp9jumw5di.swift:12:30: note: use 'firstIndex(of:)'\
    \ instead\n    guard let start = string.index(of: \"[\"),\n                  \
    \           ^~~~~\n                             firstIndex\n/tmp/tmp9jumw5di.swift:13:26:\
    \ warning: 'index(of:)' is deprecated: renamed to 'firstIndex(of:)'\n        let\
    \ end = string.index(of: \"]\"),\n                         ^\n/tmp/tmp9jumw5di.swift:13:26:\
    \ note: use 'firstIndex(of:)' instead\n        let end = string.index(of: \"]\"\
    ),\n                         ^~~~~\n                         firstIndex\n/tmp/tmp9jumw5di.swift:19:11:\
    \ error: no exact matches in call to instance method 'append'\n    stack.append(contentsOf:\
    \ string.unicodeScalars)\n          ^\n/tmp/tmp9jumw5di.swift:19:11: note: found\
    \ candidate with type '(__owned String.UnicodeScalarView) -> ()'\n    stack.append(contentsOf:\
    \ string.unicodeScalars)\n          ^\n"
  stdout: ''
  timestamp: 1660013961
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    func is_nested(string: String) -> Bool {\n    if string == \"\" {\n        return\
    \ false\n    }\n    var open = 0\n    var close = 0\n    var openCount = 0\n \
    \   var closeCount = 0\n    for i := 0; i < len(string); i++ {\n        if string[i]\
    \ == '[' {\n            openCount++\n        }\n        if string[i] == ']' {\n\
    \            closeCount++\n        }\n        if string[i] == '[' && openCount\
    \ > closeCount {\n            open++\n        }\n        if string[i] == ']' &&\
    \ openCount > closeCount {\n            close++\n        }\n    }\n    return\
    \ open > close\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(is_nested(string:\
    \ \"[[]]\") == true)\nassert(is_nested(string: \"[]]]]]]][[[[[]\") == false)\n\
    assert(is_nested(string: \"[][]\") == false)\nassert(is_nested(string: \"[]\"\
    ) == false)\nassert(is_nested(string: \"[[[[]]]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]]]]]\") == false)\nassert(is_nested(string: \"[][][[]]\") == true)\n\
    assert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string: \"[]]\"\
    ) == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmpsnsnt87l.swift:19:12: error: expected type\n    for i := 0; i <\
    \ len(string); i++ {\n           ^\n            <#type#>\n/tmp/tmpsnsnt87l.swift:19:12:\
    \ error: expected 'in' after for-each pattern\n    for i := 0; i < len(string);\
    \ i++ {\n           ^\n/tmp/tmpsnsnt87l.swift:19:12: error: expected Sequence\
    \ expression for for-each loop\n    for i := 0; i < len(string); i++ {\n     \
    \      ^\n/tmp/tmpsnsnt87l.swift:20:25: error: single-quoted string literal found,\
    \ use '\"'\n        if string[i] == '[' {\n                        ^~~\n     \
    \                   \"[\"\n/tmp/tmpsnsnt87l.swift:23:25: error: single-quoted\
    \ string literal found, use '\"'\n        if string[i] == ']' {\n            \
    \            ^~~\n                        \"]\"\n/tmp/tmpsnsnt87l.swift:26:25:\
    \ error: single-quoted string literal found, use '\"'\n        if string[i] ==\
    \ '[' && openCount > closeCount {\n                        ^~~\n             \
    \           \"[\"\n/tmp/tmpsnsnt87l.swift:29:25: error: single-quoted string literal\
    \ found, use '\"'\n        if string[i] == ']' && openCount > closeCount {\n \
    \                       ^~~\n                        \"]\"\n"
  stdout: ''
  timestamp: 1660013961
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    func is_nested(string: String) -> Bool {\n    var stack = [String]()\n    var\
    \ openBrackets = 0\n    for char in string {\n        if char == '[' {\n     \
    \       stack.append(char)\n            openBrackets += 1\n        } else if char\
    \ == ']' {\n            if openBrackets > 0 {\n                openBrackets -=\
    \ 1\n            } else {\n                return false\n            }\n     \
    \   }\n    }\n    return openBrackets == 0\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string: \"\
    []]]]]]][[[[[]\") == false)\nassert(is_nested(string: \"[][]\") == false)\nassert(is_nested(string:\
    \ \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]]]]]\") == false)\nassert(is_nested(string: \"[][][[]]\") == true)\n\
    assert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string: \"[]]\"\
    ) == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmpji2jjmjt.swift:15:20: error: single-quoted string literal found,\
    \ use '\"'\n        if char == '[' {\n                   ^~~\n               \
    \    \"[\"\n/tmp/tmpji2jjmjt.swift:18:27: error: single-quoted string literal\
    \ found, use '\"'\n        } else if char == ']' {\n                         \
    \ ^~~\n                          \"]\"\n/tmp/tmpji2jjmjt.swift:16:26: error: cannot\
    \ convert value of type 'Character' to expected argument type 'String'\n     \
    \       stack.append(char)\n                         ^\n"
  stdout: ''
  timestamp: 1660013961
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    func is_nested(string: String) -> Bool {\n    guard let openingBracket = string.rangeOfString(\"\
    [\", options: .LiteralSearch, range: nil, locale: nil) else {\n        return\
    \ false\n    }\n    guard let closingBracket = string.rangeOfString(\"]\", options:\
    \ .LiteralSearch, range: nil, locale: nil) else {\n        return false\n    }\n\
    \    guard let openingBracketIndex = string.rangeOfString(\"[\", options: .LiteralSearch,\
    \ range: nil, locale: nil)?.lowerBound else {\n        return false\n    }\n \
    \   guard let closingBracketIndex = string.rangeOfString(\"]\", options: .LiteralSearch,\
    \ range: nil, locale: nil)?.upperBound else {\n        return false\n    }\n \
    \   guard openingBracketIndex <= closingBracketIndex else {\n        return false\n\
    \    }\n    guard openingBracketIndex == openingBracket.lowerBound else {\n  \
    \      return false\n    }\n    guard closingBracketIndex == closingBracket.upperBound\
    \ else {\n        return false\n    }\n    guard openingBracketIndex == openingBracket.upperBound\
    \ else {\n        return false\n    }\n    guard closingBracketIndex == closingBracket.lowerBound\
    \ else {\n        return false\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]][[[[[]\") == false)\nassert(is_nested(string: \"[][]\") == false)\n\
    assert(is_nested(string: \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\"\
    ) == true)\nassert(is_nested(string: \"[]]]]]]]]]]\") == false)\nassert(is_nested(string:\
    \ \"[][][[]]\") == true)\nassert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string:\
    \ \"[]]\") == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmpqo35ad1a.swift:12:39: error: value of type 'String' has no member\
    \ 'rangeOfString'\n    guard let openingBracket = string.rangeOfString(\"[\",\
    \ options: .LiteralSearch, range: nil, locale: nil) else {\n                 \
    \              ~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmpqo35ad1a.swift:12:68: error: cannot\
    \ infer contextual base in reference to member 'LiteralSearch'\n    guard let\
    \ openingBracket = string.rangeOfString(\"[\", options: .LiteralSearch, range:\
    \ nil, locale: nil) else {\n                                                 \
    \                 ~^~~~~~~~~~~~~\n/tmp/tmpqo35ad1a.swift:12:90: error: 'nil' requires\
    \ a contextual type\n    guard let openingBracket = string.rangeOfString(\"[\"\
    , options: .LiteralSearch, range: nil, locale: nil) else {\n                 \
    \                                                                        ^\n/tmp/tmpqo35ad1a.swift:12:103:\
    \ error: 'nil' requires a contextual type\n    guard let openingBracket = string.rangeOfString(\"\
    [\", options: .LiteralSearch, range: nil, locale: nil) else {\n              \
    \                                                                            \
    \            ^\n/tmp/tmpqo35ad1a.swift:15:39: error: value of type 'String' has\
    \ no member 'rangeOfString'\n    guard let closingBracket = string.rangeOfString(\"\
    ]\", options: .LiteralSearch, range: nil, locale: nil) else {\n              \
    \                 ~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmpqo35ad1a.swift:15:68: error: cannot\
    \ infer contextual base in reference to member 'LiteralSearch'\n    guard let\
    \ closingBracket = string.rangeOfString(\"]\", options: .LiteralSearch, range:\
    \ nil, locale: nil) else {\n                                                 \
    \                 ~^~~~~~~~~~~~~\n/tmp/tmpqo35ad1a.swift:15:90: error: 'nil' requires\
    \ a contextual type\n    guard let closingBracket = string.rangeOfString(\"]\"\
    , options: .LiteralSearch, range: nil, locale: nil) else {\n                 \
    \                                                                        ^\n/tmp/tmpqo35ad1a.swift:15:103:\
    \ error: 'nil' requires a contextual type\n    guard let closingBrack"
  stdout: ''
  timestamp: 1660013961
- exit_code: -4
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    func is_nested(string: String) -> Bool {\n    \n    // Your code here\n    \n\
    \    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(is_nested(string:\
    \ \"[[]]\") == true)\nassert(is_nested(string: \"[]]]]]]][[[[[]\") == false)\n\
    assert(is_nested(string: \"[][]\") == false)\nassert(is_nested(string: \"[]\"\
    ) == false)\nassert(is_nested(string: \"[[[[]]]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]]]]]\") == false)\nassert(is_nested(string: \"[][][[]]\") == true)\n\
    assert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string: \"[]]\"\
    ) == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: Exception
  stderr: 'tmp4fbozzey/tmp4fbozzey.swift:32: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af698c96c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af69898db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af69898d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af69898c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp4fbozzey                        0x000056101a6522fb <unavailable> + 4859

    5    libc.so.6                          0x00002af698e82460 __libc_start_main +
    245

    6    tmp4fbozzey                        0x000056101a651ee9 <unavailable> + 3817

    '
  stdout: ''
  timestamp: 1660013961
- exit_code: -4
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    func is_nested(string: String) -> Bool {\n    guard let openingBracket = string.firstIndex(of:\
    \ \"[\"),\n        let closingBracket = string.lastIndex(of: \"]\") else {\n \
    \           return false\n    }\n    \n    let openingBracketIndex = string.index(openingBracket,\
    \ offsetBy: 1)\n    let closingBracketIndex = string.index(closingBracket, offsetBy:\
    \ -1)\n    \n    return openingBracketIndex != closingBracketIndex\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]][[[[[]\") == false)\nassert(is_nested(string: \"[][]\") == false)\n\
    assert(is_nested(string: \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\"\
    ) == true)\nassert(is_nested(string: \"[]]]]]]]]]]\") == false)\nassert(is_nested(string:\
    \ \"[][][[]]\") == true)\nassert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string:\
    \ \"[]]\") == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: Exception
  stderr: 'tmp1_hwo6_i/tmp1_hwo6_i.swift:37: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b31e5e18c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b31e5b0fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b31e5b0f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b31e5b0e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp1_hwo6_i                        0x000056400983d5cb <unavailable> + 5579

    5    libc.so.6                          0x00002b31e6004460 __libc_start_main +
    245

    6    tmp1_hwo6_i                        0x000056400983d1b9 <unavailable> + 4537

    '
  stdout: ''
  timestamp: 1660013961
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    func is_nested(string: String) -> Bool {\n\tlet stack = Stack<String>()\n\tlet\
    \ openBrackets = Set<String>()\n\tlet closeBrackets = Set<String>()\n\tlet openBracketsCount\
    \ = 1\n\tlet closeBracketsCount = 1\n\t\n\tlet openBracketsString = \"[\"\n\t\
    let closeBracketsString = \"[\"\n\t\n\tlet openBracketsCount = string.characters.filter({\
    \ openBracketsString.contains($0) }).count\n\tlet closeBracketsCount = string.characters.filter({\
    \ closeBracketsString.contains($0) }).count\n\t\n\tlet openBracketsStringCount\
    \ = string.characters.filter({ openBracketsString.contains($0) }).count\n\tlet\
    \ closeBracketsStringCount = string.characters.filter({ closeBracketsString.contains($0)\
    \ }).count\n\t\n\tlet openBracketsStringCount2 = string.characters.filter({ openBracketsString.contains($0)\
    \ }).count\n\tlet closeBracketsStringCount2 = string.characters.filter({ closeBracketsString.contains($0)\
    \ }).count\n\t\n\tlet openBracketsStringCount3 = string.characters.filter({ openBracketsString.contains($0)\
    \ }).count\n\tlet closeBracketsStringCount3 = string.characters.filter({ closeBracketsString.contains($0)\
    \ }).count\n\t\n\tlet openBracketsStringCount4 = string.characters.filter({ openBracketsString.contains($0)\
    \ }).count\n\tlet closeBracketsStringCount4 = string.characters.filter({ closeBracketsString.contains($0)\
    \ }).count\n\t\n\tlet openBracketsStringCount5 = string.characters.filter({ openBracketsString.contains($0)\
    \ }).count\n\tlet closeBracketsStringCount5 = string.characters.filter({ closeBracketsString.contains($0)\
    \ }).count\n\t\n\tlet openBracketsStringCount6 = string.characters.filter({ openBracketsString.contains($0)\
    \ }).count\n\tlet closeBracketsStringCount6 = string.characters.filter({ closeBracketsString.contains($0)\
    \ }).count\n\t\n\tlet openBracketsStringCount7 = string.characters.filter({ openBracketsString.contains($0)\
    \ }).count\n\tlet closeBracketsStringCount7 = string.characters.filter({ closeBracketsString.contains($0)\
    \ }).count\n\t\n\tlet openBracketsStringCount8 = string.characters.filter({ openBracketsString.contains($0)\
    \ }).count\n\tlet closeBracketsStringCount8 = string.characters.filter({ closeBracketsString.\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]][[[[[]\") == false)\nassert(is_nested(string: \"[][]\") == false)\n\
    assert(is_nested(string: \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\"\
    ) == true)\nassert(is_nested(string: \"[]]]]]]]]]]\") == false)\nassert(is_nested(string:\
    \ \"[][][[]]\") == true)\nassert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string:\
    \ \"[]]\") == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmptavy_e27.swift:46:80: error: expected member name following '.'\n\
    \        let closeBracketsStringCount8 = string.characters.filter({ closeBracketsString.\n\
    \                                                                            \
    \          ^\n/tmp/tmptavy_e27.swift:50:1: error: expected ')' in expression list\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n^\n/tmp/tmptavy_e27.swift:46:58:\
    \ note: to match this opening '('\n        let closeBracketsStringCount8 = string.characters.filter({\
    \ closeBracketsString.\n                                                     \
    \           ^\n/tmp/tmptavy_e27.swift:75:47: error: expected '}' at end of brace\
    \ statement\nassert(is_nested(string: \"]]]]]]]]\") == false)\n              \
    \                                ^\n/tmp/tmptavy_e27.swift:11:40: note: to match\
    \ this opening '{'\nfunc is_nested(string: String) -> Bool {\n               \
    \                        ^\n/tmp/tmptavy_e27.swift:12:14: error: cannot find 'Stack'\
    \ in scope\n        let stack = Stack<String>()\n                    ^~~~~\n/tmp/tmptavy_e27.swift:21:33:\
    \ error: 'characters' is unavailable: Please use String directly\n        let\
    \ openBracketsCount = string.characters.filter({ openBracketsString.contains($0)\
    \ }).count\n                                       ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmptavy_e27.swift:21:6: error: invalid redeclaration\
    \ of 'openBracketsCount'\n        let openBracketsCount = string.characters.filter({\
    \ openBracketsString.contains($0) }).count\n            ^\n/tmp/tmptavy_e27.swift:15:6:\
    \ note: 'openBracketsCount' previously declared here\n        let openBracketsCount\
    \ = 1\n            ^\n/tmp/tmptavy_e27.swift:22:34: error: 'characters' is unavailable:\
    \ Please use String directly\n        let closeBracketsCount = string.characters.filter({\
    \ closeBracketsString.contains($0) }).count\n                                \
    \        ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    pub"
  stdout: ''
  timestamp: 1660013961
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    func is_nested(string: String) -> Bool {\n    \n    let stack = Stack()\n    \n\
    \    for char in string {\n        \n        if char == '[' {\n            stack.push(char)\n\
    \        } else if char == ']' {\n            if stack.count > 0 {\n         \
    \       stack.pop()\n            } else {\n                return false\n    \
    \        }\n        }\n    }\n    \n    return stack.count == 0\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]][[[[[]\") == false)\nassert(is_nested(string: \"[][]\") == false)\n\
    assert(is_nested(string: \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\"\
    ) == true)\nassert(is_nested(string: \"[]]]]]]]]]]\") == false)\nassert(is_nested(string:\
    \ \"[][][[]]\") == true)\nassert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string:\
    \ \"[]]\") == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmpk2ihsqup.swift:17:20: error: single-quoted string literal found,\
    \ use '\"'\n        if char == '[' {\n                   ^~~\n               \
    \    \"[\"\n/tmp/tmpk2ihsqup.swift:19:27: error: single-quoted string literal\
    \ found, use '\"'\n        } else if char == ']' {\n                         \
    \ ^~~\n                          \"]\"\n/tmp/tmpk2ihsqup.swift:13:17: error: cannot\
    \ find 'Stack' in scope\n    let stack = Stack()\n                ^~~~~\n"
  stdout: ''
  timestamp: 1660013961
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    func is_nested(string: String) -> Bool {\n    let stack = Stack()\n    for char\
    \ in string {\n        if char == '[' {\n            stack.push(char)\n      \
    \  } else if char == ']' {\n            if stack.count > 0 {\n               \
    \ stack.pop()\n            } else {\n                return false\n          \
    \  }\n        }\n    }\n    return stack.count == 0\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]][[[[[]\") == false)\nassert(is_nested(string: \"[][]\") == false)\n\
    assert(is_nested(string: \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\"\
    ) == true)\nassert(is_nested(string: \"[]]]]]]]]]]\") == false)\nassert(is_nested(string:\
    \ \"[][][[]]\") == true)\nassert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string:\
    \ \"[]]\") == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmpy26dcyps.swift:14:20: error: single-quoted string literal found,\
    \ use '\"'\n        if char == '[' {\n                   ^~~\n               \
    \    \"[\"\n/tmp/tmpy26dcyps.swift:16:27: error: single-quoted string literal\
    \ found, use '\"'\n        } else if char == ']' {\n                         \
    \ ^~~\n                          \"]\"\n/tmp/tmpy26dcyps.swift:12:17: error: cannot\
    \ find 'Stack' in scope\n    let stack = Stack()\n                ^~~~~\n"
  stdout: ''
  timestamp: 1660013961
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    func is_nested(string: String) -> Bool {\n    \n    let brackets = string.unicodeScalars\n\
    \    \n    var openingBracketCount = 0\n    var closingBracketCount = 0\n    \n\
    \    for bracket in brackets {\n        \n        switch bracket {\n         \
    \   \n        case .LeftBracket:\n            openingBracketCount += 1\n     \
    \       \n        case .RightBracket:\n            closingBracketCount += 1\n\
    \            \n        default:\n            \n            if openingBracketCount\
    \ > closingBracketCount {\n                return false\n            }\n     \
    \   }\n    }\n    \n    return openingBracketCount == closingBracketCount\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]][[[[[]\") == false)\nassert(is_nested(string: \"[][]\") == false)\n\
    assert(is_nested(string: \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\"\
    ) == true)\nassert(is_nested(string: \"[]]]]]]]]]]\") == false)\nassert(is_nested(string:\
    \ \"[][][[]]\") == true)\nassert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string:\
    \ \"[]]\") == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmpyq7rphbz.swift:22:15: error: type 'Unicode.Scalar' has no member\
    \ 'LeftBracket'\n        case .LeftBracket:\n             ~^~~~~~~~~~~\n/tmp/tmpyq7rphbz.swift:25:15:\
    \ error: type 'Unicode.Scalar' has no member 'RightBracket'\n        case .RightBracket:\n\
    \             ~^~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013961
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    func is_nested(string: String) -> Bool {\n    guard let pattern = try? NSRegularExpression(pattern:\
    \ \"\\\\[\\\\[\\\\]\\\\]\\\\]\", options: .CaseInsensitive) else {\n        return\
    \ false\n    }\n    \n    let range = NSMakeRange(0, string.characters.count)\n\
    \    \n    return pattern.firstMatchInString(string, options: .CaseInsensitive,\
    \ range: range) != nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(is_nested(string:\
    \ \"[[]]\") == true)\nassert(is_nested(string: \"[]]]]]]][[[[[]\") == false)\n\
    assert(is_nested(string: \"[][]\") == false)\nassert(is_nested(string: \"[]\"\
    ) == false)\nassert(is_nested(string: \"[[[[]]]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]]]]]\") == false)\nassert(is_nested(string: \"[][][[]]\") == true)\n\
    assert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string: \"[]]\"\
    ) == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmpha6oq84j.swift:12:30: error: cannot find 'NSRegularExpression'\
    \ in scope\n    guard let pattern = try? NSRegularExpression(pattern: \"\\\\[\\\
    \\[\\\\]\\\\]\\\\]\", options: .CaseInsensitive) else {\n                    \
    \         ^~~~~~~~~~~~~~~~~~~\n/tmp/tmpha6oq84j.swift:12:88: error: cannot infer\
    \ contextual base in reference to member 'CaseInsensitive'\n    guard let pattern\
    \ = try? NSRegularExpression(pattern: \"\\\\[\\\\[\\\\]\\\\]\\\\]\", options:\
    \ .CaseInsensitive) else {\n                                                 \
    \                                     ~^~~~~~~~~~~~~~~\n/tmp/tmpha6oq84j.swift:16:17:\
    \ error: cannot find 'NSMakeRange' in scope\n    let range = NSMakeRange(0, string.characters.count)\n\
    \                ^~~~~~~~~~~\n/tmp/tmpha6oq84j.swift:18:57: error: cannot infer\
    \ contextual base in reference to member 'CaseInsensitive'\n    return pattern.firstMatchInString(string,\
    \ options: .CaseInsensitive, range: range) != nil\n                          \
    \                             ~^~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013961
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    func is_nested(string: String) -> Bool {\n    guard let open = string.range(of:\
    \ \"[\"),\n        let close = string.range(of: \"]\"),\n        let open2 = string.range(of:\
    \ \"[\", options: .backwards),\n        let close2 = string.range(of: \"]\", options:\
    \ .backwards) else { return false }\n    return open != nil && close != nil &&\
    \ open2 != nil && close2 != nil && open2.lowerBound < close2.lowerBound\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]][[[[[]\") == false)\nassert(is_nested(string: \"[][]\") == false)\n\
    assert(is_nested(string: \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\"\
    ) == true)\nassert(is_nested(string: \"[]]]]]]]]]]\") == false)\nassert(is_nested(string:\
    \ \"[][][[]]\") == true)\nassert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string:\
    \ \"[]]\") == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmpa_v9424c.swift:12:29: error: value of type 'String' has no member\
    \ 'range'\n    guard let open = string.range(of: \"[\"),\n                   \
    \  ~~~~~~ ^~~~~\n/tmp/tmpa_v9424c.swift:13:28: error: value of type 'String' has\
    \ no member 'range'\n        let close = string.range(of: \"]\"),\n          \
    \          ~~~~~~ ^~~~~\n/tmp/tmpa_v9424c.swift:14:28: error: value of type 'String'\
    \ has no member 'range'\n        let open2 = string.range(of: \"[\", options:\
    \ .backwards),\n                    ~~~~~~ ^~~~~\n/tmp/tmpa_v9424c.swift:14:53:\
    \ error: cannot infer contextual base in reference to member 'backwards'\n   \
    \     let open2 = string.range(of: \"[\", options: .backwards),\n            \
    \                                       ~^~~~~~~~~\n/tmp/tmpa_v9424c.swift:15:29:\
    \ error: value of type 'String' has no member 'range'\n        let close2 = string.range(of:\
    \ \"]\", options: .backwards) else { return false }\n                     ~~~~~~\
    \ ^~~~~\n/tmp/tmpa_v9424c.swift:15:54: error: cannot infer contextual base in\
    \ reference to member 'backwards'\n        let close2 = string.range(of: \"]\"\
    , options: .backwards) else { return false }\n                               \
    \                     ~^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013962
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    func is_nested(string: String) -> Bool {\n    var stack = [String]()\n    for\
    \ char in string {\n        if char == '[' {\n            stack.append(char)\n\
    \        } else if char == ']' {\n            if stack.count > 0 {\n         \
    \       stack.removeLast()\n            } else {\n                return false\n\
    \            }\n        }\n    }\n    return stack.count == 0\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]][[[[[]\") == false)\nassert(is_nested(string: \"[][]\") == false)\n\
    assert(is_nested(string: \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\"\
    ) == true)\nassert(is_nested(string: \"[]]]]]]]]]]\") == false)\nassert(is_nested(string:\
    \ \"[][][[]]\") == true)\nassert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string:\
    \ \"[]]\") == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmpr8kv7_i8.swift:14:20: error: single-quoted string literal found,\
    \ use '\"'\n        if char == '[' {\n                   ^~~\n               \
    \    \"[\"\n/tmp/tmpr8kv7_i8.swift:16:27: error: single-quoted string literal\
    \ found, use '\"'\n        } else if char == ']' {\n                         \
    \ ^~~\n                          \"]\"\n/tmp/tmpr8kv7_i8.swift:15:26: error: cannot\
    \ convert value of type 'Character' to expected argument type 'String'\n     \
    \       stack.append(char)\n                         ^\n"
  stdout: ''
  timestamp: 1660013961
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    func is_nested(string: String) -> Bool {\n    guard let openingBracketIndex =\
    \ string.index(of: \"[\"),\n        let closingBracketIndex = string.index(of:\
    \ \"]\"),\n        openingBracketIndex != closingBracketIndex else {\n       \
    \     return false\n    }\n    let openingBracket = string[openingBracketIndex..<openingBracketIndex.advanced(by:\
    \ 1)]\n    let closingBracket = string[closingBracketIndex..<closingBracketIndex.advanced(by:\
    \ 1)]\n    return openingBracket.count > 0 && closingBracket.count > 0 && openingBracket\
    \ == closingBracket\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(is_nested(string:\
    \ \"[[]]\") == true)\nassert(is_nested(string: \"[]]]]]]][[[[[]\") == false)\n\
    assert(is_nested(string: \"[][]\") == false)\nassert(is_nested(string: \"[]\"\
    ) == false)\nassert(is_nested(string: \"[[[[]]]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]]]]]\") == false)\nassert(is_nested(string: \"[][][[]]\") == true)\n\
    assert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string: \"[]]\"\
    ) == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmppiudztcr.swift:12:44: warning: 'index(of:)' is deprecated: renamed\
    \ to 'firstIndex(of:)'\n    guard let openingBracketIndex = string.index(of: \"\
    [\"),\n                                           ^\n/tmp/tmppiudztcr.swift:12:44:\
    \ note: use 'firstIndex(of:)' instead\n    guard let openingBracketIndex = string.index(of:\
    \ \"[\"),\n                                           ^~~~~\n                \
    \                           firstIndex\n/tmp/tmppiudztcr.swift:13:42: warning:\
    \ 'index(of:)' is deprecated: renamed to 'firstIndex(of:)'\n        let closingBracketIndex\
    \ = string.index(of: \"]\"),\n                                         ^\n/tmp/tmppiudztcr.swift:13:42:\
    \ note: use 'firstIndex(of:)' instead\n        let closingBracketIndex = string.index(of:\
    \ \"]\"),\n                                         ^~~~~\n                  \
    \                       firstIndex\n/tmp/tmppiudztcr.swift:17:75: error: value\
    \ of type 'String.Index' has no member 'advanced'\n    let openingBracket = string[openingBracketIndex..<openingBracketIndex.advanced(by:\
    \ 1)]\n                                                      ~~~~~~~~~~~~~~~~~~~\
    \ ^~~~~~~~\n/tmp/tmppiudztcr.swift:18:75: error: value of type 'String.Index'\
    \ has no member 'advanced'\n    let closingBracket = string[closingBracketIndex..<closingBracketIndex.advanced(by:\
    \ 1)]\n                                                      ~~~~~~~~~~~~~~~~~~~\
    \ ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660013961
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    func is_nested(string: String) -> Bool {\n    guard let openBracketIndex = string.firstIndex(of:\
    \ \"[\"),\n        let closeBracketIndex = string.lastIndex(of: \"]\"),\n    \
    \    openBracketIndex != closeBracketIndex,\n        let openBracket = string[openBracketIndex],\n\
    \        let closeBracket = string[closeBracketIndex],\n        let openBracketCount\
    \ = string.distance(from: openBracketIndex, to: closeBracketIndex),\n        openBracketCount\
    \ > 0 else {\n        return false\n    }\n    \n    let openBracketsCount = openBracket.count\n\
    \    let closeBracketsCount = closeBracket.count\n    \n    if openBracketsCount\
    \ == closeBracketsCount {\n        return true\n    }\n    \n    let openBracketsCount\
    \ = openBracket.count\n    let closeBracketsCount = closeBracket.count\n    \n\
    \    if openBracketsCount > closeBracketsCount {\n        return false\n    }\n\
    \    \n    let openBracketsCount = openBracket.count\n    let closeBracketsCount\
    \ = closeBracket.count\n    \n    if openBracketsCount < closeBracketsCount {\n\
    \        return true\n    }\n    \n    let openBracketsCount = openBracket.count\n\
    \    let closeBracketsCount = closeBracket.count\n    \n    if openBracketsCount\
    \ > closeBracketsCount {\n        return false\n    }\n    \n    let openBracketsCount\
    \ = openBracket.count\n    let closeBracketsCount = closeBracket.count\n    \n\
    \    if openBracketsCount < closeBracketsCount {\n        return true\n    }\n\
    \    \n    let openBracketsCount = openBracket.count\n    let closeBracketsCount\
    \ = closeBracket.count\n    \n    if openBracketsCount > closeBracketsCount {\n\
    \        return false\n    }\n    \n    let openBracketsCount = openBracket.count\n\
    \    let closeBracketsCount = closeBracket.count\n    \n    if openBracketsCount\
    \ < closeBracketsCount {\n        return true\n    }\n    \n    let openBracketsCount\
    \ = openBracket.count\n    let closeBracketsCount = closeBracket.count\n    \n\
    \    if openBracketsCount > closeBracketsCount {\n        return false\n    }\n\
    \    \n    let openBracketsCount = openBracket.count\n    let closeBracketsCount\
    \ = closeBracket.count\n    \n    if openBracketsCount \n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]][[[[[]\") == false)\nassert(is_nested(string: \"[][]\") == false)\n\
    assert(is_nested(string: \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\"\
    ) == true)\nassert(is_nested(string: \"[]]]]]]]]]]\") == false)\nassert(is_nested(string:\
    \ \"[][][[]]\") == true)\nassert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string:\
    \ \"[]]\") == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmprmojsi43.swift:81:25: error: expected '{' after 'if' condition\n\
    \    if openBracketsCount \n                        ^\n/tmp/tmprmojsi43.swift:15:9:\
    \ error: initializer for conditional binding must have Optional type, not 'Character'\n\
    \        let openBracket = string[openBracketIndex],\n        ^              \
    \   ~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmprmojsi43.swift:16:9: error: initializer\
    \ for conditional binding must have Optional type, not 'Character'\n        let\
    \ closeBracket = string[closeBracketIndex],\n        ^                  ~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmprmojsi43.swift:17:9: error: initializer for conditional binding must have\
    \ Optional type, not 'Int'\n        let openBracketCount = string.distance(from:\
    \ openBracketIndex, to: closeBracketIndex),\n        ^                      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmprmojsi43.swift:22:41: error: value of type 'Character' has no member 'count'\n\
    \    let openBracketsCount = openBracket.count\n                            ~~~~~~~~~~~\
    \ ^~~~~\n/tmp/tmprmojsi43.swift:23:43: error: value of type 'Character' has no\
    \ member 'count'\n    let closeBracketsCount = closeBracket.count\n          \
    \                   ~~~~~~~~~~~~ ^~~~~\n/tmp/tmprmojsi43.swift:29:41: error: value\
    \ of type 'Character' has no member 'count'\n    let openBracketsCount = openBracket.count\n\
    \                            ~~~~~~~~~~~ ^~~~~\n/tmp/tmprmojsi43.swift:30:43:\
    \ error: value of type 'Character' has no member 'count'\n    let closeBracketsCount\
    \ = closeBracket.count\n                             ~~~~~~~~~~~~ ^~~~~\n/tmp/tmprmojsi43.swift:36:41:\
    \ error: value of type 'Character' has no member 'count'\n    let openBracketsCount\
    \ = openBracket.count\n                            ~~~~~~~~~~~ ^~~~~\n/tmp/tmprmojsi43.swift:37:43:\
    \ error: value of type 'Character' has no member 'count'\n    let closeBracketsCount\
    \ = closeBracket.count\n                             ~~~~~~~~~~~~ ^~~~~\n/tmp/tmprmojsi43.swift:43:41:\
    \ error: value of type 'Character' has no member 'count'\n    let openBracketsCount\
    \ = openBr"
  stdout: ''
  timestamp: 1660013961
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    func is_nested(string: String) -> Bool {\n    \n    let stack = Stack()\n    \n\
    \    for character in string {\n        \n        if character == '[' {\n    \
    \        stack.push(character)\n        }\n        \n        if character == ']'\
    \ {\n            \n            if stack.count > 0 {\n                \n      \
    \          if stack.peek() == '[' {\n                    stack.pop()\n       \
    \         } else {\n                    return false\n                }\n    \
    \        } else {\n                return false\n            }\n        }\n  \
    \  }\n    \n    return stack.count == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string: \"[]]]]]]][[[[[]\"\
    ) == false)\nassert(is_nested(string: \"[][]\") == false)\nassert(is_nested(string:\
    \ \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]]]]]\") == false)\nassert(is_nested(string: \"[][][[]]\") == true)\n\
    assert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string: \"[]]\"\
    ) == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmpi93t9av7.swift:17:25: error: single-quoted string literal found,\
    \ use '\"'\n        if character == '[' {\n                        ^~~\n     \
    \                   \"[\"\n/tmp/tmpi93t9av7.swift:21:25: error: single-quoted\
    \ string literal found, use '\"'\n        if character == ']' {\n            \
    \            ^~~\n                        \"]\"\n/tmp/tmpi93t9av7.swift:25:36:\
    \ error: single-quoted string literal found, use '\"'\n                if stack.peek()\
    \ == '[' {\n                                   ^~~\n                         \
    \          \"[\"\n/tmp/tmpi93t9av7.swift:13:17: error: cannot find 'Stack' in\
    \ scope\n    let stack = Stack()\n                ^~~~~\n"
  stdout: ''
  timestamp: 1660013961
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    func is_nested(string: String) -> Bool {\n    let brackets = string.unicodeScalars\n\
    \        .filter { $0 != brackets.first }\n        .map { $0.value }\n       \
    \ .reduce(into: []) { $0.append($1); $0.append($1); $0.append($1) }\n    \n  \
    \  return brackets.count >= 2\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(is_nested(string:\
    \ \"[[]]\") == true)\nassert(is_nested(string: \"[]]]]]]][[[[[]\") == false)\n\
    assert(is_nested(string: \"[][]\") == false)\nassert(is_nested(string: \"[]\"\
    ) == false)\nassert(is_nested(string: \"[[[[]]]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]]]]]\") == false)\nassert(is_nested(string: \"[][][[]]\") == true)\n\
    assert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string: \"[]]\"\
    ) == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmp_hbmey74.swift:15:10: error: failed to produce diagnostic for expression;\
    \ please submit a bug report (https://swift.org/contributing/#reporting-bugs)\
    \ and include the project\n        .reduce(into: []) { $0.append($1); $0.append($1);\
    \ $0.append($1) }\n         ^\n"
  stdout: ''
  timestamp: 1660013961
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    func is_nested(string: String) -> Bool {\n    if string == \"\" {\n        return\
    \ false\n    }\n    var openBrackets = 0\n    var closeBrackets = 0\n    var openBracketsStack\
    \ = [String]()\n    var closeBracketsStack = [String]()\n    for char in string\
    \ {\n        if char == \"[\" {\n            openBracketsStack.append(char)\n\
    \            openBrackets++\n        } else if char == \"]\" {\n            closeBracketsStack.append(char)\n\
    \            closeBrackets++\n        } else if char == \"]\" && openBrackets\
    \ > 0 && closeBrackets == 0 {\n            openBracketsStack.removeLast()\n  \
    \          openBrackets--\n        } else if char == \"[\" && openBrackets ==\
    \ 0 && closeBrackets > 0 {\n            closeBracketsStack.removeLast()\n    \
    \        closeBrackets--\n        }\n    }\n    return openBrackets == 0 && closeBrackets\
    \ == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(is_nested(string: \"[[]]\"\
    ) == true)\nassert(is_nested(string: \"[]]]]]]][[[[[]\") == false)\nassert(is_nested(string:\
    \ \"[][]\") == false)\nassert(is_nested(string: \"[]\") == false)\nassert(is_nested(string:\
    \ \"[[[[]]]]\") == true)\nassert(is_nested(string: \"[]]]]]]]]]]\") == false)\n\
    assert(is_nested(string: \"[][][[]]\") == true)\nassert(is_nested(string: \"[[]\"\
    ) == false)\nassert(is_nested(string: \"[]]\") == false)\nassert(is_nested(string:\
    \ \"[[]][[\") == true)\nassert(is_nested(string: \"[[][]]\") == true)\nassert(is_nested(string:\
    \ \"\") == false)\nassert(is_nested(string: \"[[[[[[[[\") == false)\nassert(is_nested(string:\
    \ \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmp3wf142y3.swift:21:38: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n            openBracketsStack.append(char)\n\
    \                                     ^\n/tmp/tmp3wf142y3.swift:22:25: error:\
    \ cannot find operator '++' in scope; did you mean '+= 1'?\n            openBrackets++\n\
    \                        ^~\n/tmp/tmp3wf142y3.swift:24:39: error: cannot convert\
    \ value of type 'Character' to expected argument type 'String'\n            closeBracketsStack.append(char)\n\
    \                                      ^\n/tmp/tmp3wf142y3.swift:25:26: error:\
    \ cannot find operator '++' in scope; did you mean '+= 1'?\n            closeBrackets++\n\
    \                         ^~\n/tmp/tmp3wf142y3.swift:28:25: error: cannot find\
    \ operator '--' in scope; did you mean '-= 1'?\n            openBrackets--\n \
    \                       ^~\n/tmp/tmp3wf142y3.swift:31:26: error: cannot find operator\
    \ '--' in scope; did you mean '-= 1'?\n            closeBrackets--\n         \
    \                ^~\n"
  stdout: ''
  timestamp: 1660013961
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    func is_nested(string: String) -> Bool {\n    let stack = Stack()\n    for char\
    \ in string {\n        if char == '[' {\n            stack.push(char)\n      \
    \  } else if char == ']' {\n            if stack.top() == '[' {\n            \
    \    stack.pop()\n            } else {\n                return false\n       \
    \     }\n        } else {\n            return false\n        }\n    }\n    return\
    \ stack.empty()\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(is_nested(string:\
    \ \"[[]]\") == true)\nassert(is_nested(string: \"[]]]]]]][[[[[]\") == false)\n\
    assert(is_nested(string: \"[][]\") == false)\nassert(is_nested(string: \"[]\"\
    ) == false)\nassert(is_nested(string: \"[[[[]]]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]]]]]\") == false)\nassert(is_nested(string: \"[][][[]]\") == true)\n\
    assert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string: \"[]]\"\
    ) == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmpghzat_c6.swift:14:20: error: single-quoted string literal found,\
    \ use '\"'\n        if char == '[' {\n                   ^~~\n               \
    \    \"[\"\n/tmp/tmpghzat_c6.swift:16:27: error: single-quoted string literal\
    \ found, use '\"'\n        } else if char == ']' {\n                         \
    \ ^~~\n                          \"]\"\n/tmp/tmpghzat_c6.swift:17:31: error: single-quoted\
    \ string literal found, use '\"'\n            if stack.top() == '[' {\n      \
    \                        ^~~\n                              \"[\"\n/tmp/tmpghzat_c6.swift:12:17:\
    \ error: cannot find 'Stack' in scope\n    let stack = Stack()\n             \
    \   ^~~~~\n"
  stdout: ''
  timestamp: 1660013960
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    func is_nested(string: String) -> Bool {\n    guard let start = string.index(of:\
    \ \"[\"),\n        let end = string.index(of: \"]\"),\n        start != end,\n\
    \        start < string.endIndex,\n        end < string.endIndex,\n        start\
    \ < end else {\n        return false\n    }\n    \n    let stack = Stack()\n \
    \   stack.push(start)\n    \n    var open = 0\n    var close = 0\n    \n    while\
    \ open < string.count {\n        if let index = string.index(of: \"[\", range:\
    \ start..<end) {\n            stack.push(index)\n            open += 1\n     \
    \   }\n        \n        if let index = string.index(of: \"]\", range: start..<end)\
    \ {\n            close += 1\n            \n            if stack.count > 0 {\n\
    \                let top = stack.pop()\n                if top == index {\n  \
    \                  return true\n                }\n            }\n        }\n\
    \    }\n    \n    return false\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(is_nested(string:\
    \ \"[[]]\") == true)\nassert(is_nested(string: \"[]]]]]]][[[[[]\") == false)\n\
    assert(is_nested(string: \"[][]\") == false)\nassert(is_nested(string: \"[]\"\
    ) == false)\nassert(is_nested(string: \"[[[[]]]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]]]]]\") == false)\nassert(is_nested(string: \"[][][[]]\") == true)\n\
    assert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string: \"[]]\"\
    ) == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmpex0szvhe.swift:12:30: warning: 'index(of:)' is deprecated: renamed\
    \ to 'firstIndex(of:)'\n    guard let start = string.index(of: \"[\"),\n     \
    \                        ^\n/tmp/tmpex0szvhe.swift:12:30: note: use 'firstIndex(of:)'\
    \ instead\n    guard let start = string.index(of: \"[\"),\n                  \
    \           ^~~~~\n                             firstIndex\n/tmp/tmpex0szvhe.swift:13:26:\
    \ warning: 'index(of:)' is deprecated: renamed to 'firstIndex(of:)'\n        let\
    \ end = string.index(of: \"]\"),\n                         ^\n/tmp/tmpex0szvhe.swift:13:26:\
    \ note: use 'firstIndex(of:)' instead\n        let end = string.index(of: \"]\"\
    ),\n                         ^~~~~\n                         firstIndex\n/tmp/tmpex0szvhe.swift:21:17:\
    \ error: cannot find 'Stack' in scope\n    let stack = Stack()\n             \
    \   ^~~~~\n/tmp/tmpex0szvhe.swift:28:58: error: extra argument 'range' in call\n\
    \        if let index = string.index(of: \"[\", range: start..<end) {\n      \
    \                             ~~~~~~~~~~~~~~~~~~~~~~^~~~~~~\n/tmp/tmpex0szvhe.swift:33:58:\
    \ error: extra argument 'range' in call\n        if let index = string.index(of:\
    \ \"]\", range: start..<end) {\n                                   ~~~~~~~~~~~~~~~~~~~~~~^~~~~~~\n"
  stdout: ''
  timestamp: 1660013961
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    func is_nested(string: String) -> Bool {\n    guard let start = string.index(of:\
    \ \"[\"), let end = string.index(of: \"]\"), let start = string.index(of: \"[\"\
    , offset: start), let end = string.index(of: \"]\", offset: end) else {\n    \
    \    return false\n    }\n    return start < end\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]][[[[[]\") == false)\nassert(is_nested(string: \"[][]\") == false)\n\
    assert(is_nested(string: \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\"\
    ) == true)\nassert(is_nested(string: \"[]]]]]]]]]]\") == false)\nassert(is_nested(string:\
    \ \"[][][[]]\") == true)\nassert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string:\
    \ \"[]]\") == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmpa1kifbnz.swift:12:30: warning: 'index(of:)' is deprecated: renamed\
    \ to 'firstIndex(of:)'\n    guard let start = string.index(of: \"[\"), let end\
    \ = string.index(of: \"]\"), let start = string.index(of: \"[\", offset: start),\
    \ let end = string.index(of: \"]\", offset: end) else {\n                    \
    \         ^\n/tmp/tmpa1kifbnz.swift:12:30: note: use 'firstIndex(of:)' instead\n\
    \    guard let start = string.index(of: \"[\"), let end = string.index(of: \"\
    ]\"), let start = string.index(of: \"[\", offset: start), let end = string.index(of:\
    \ \"]\", offset: end) else {\n                             ^~~~~\n           \
    \                  firstIndex\n/tmp/tmpa1kifbnz.swift:12:63: warning: 'index(of:)'\
    \ is deprecated: renamed to 'firstIndex(of:)'\n    guard let start = string.index(of:\
    \ \"[\"), let end = string.index(of: \"]\"), let start = string.index(of: \"[\"\
    , offset: start), let end = string.index(of: \"]\", offset: end) else {\n    \
    \                                                          ^\n/tmp/tmpa1kifbnz.swift:12:63:\
    \ note: use 'firstIndex(of:)' instead\n    guard let start = string.index(of:\
    \ \"[\"), let end = string.index(of: \"]\"), let start = string.index(of: \"[\"\
    , offset: start), let end = string.index(of: \"]\", offset: end) else {\n    \
    \                                                          ^~~~~\n           \
    \                                                   firstIndex\n/tmp/tmpa1kifbnz.swift:12:121:\
    \ error: extra argument 'offset' in call\n    guard let start = string.index(of:\
    \ \"[\"), let end = string.index(of: \"]\"), let start = string.index(of: \"[\"\
    , offset: start), let end = string.index(of: \"]\", offset: end) else {\n    \
    \                                                                            \
    \                      ~~~~~~~~~~~~~~~~~~^~~~~~\n/tmp/tmpa1kifbnz.swift:12:169:\
    \ error: extra argument 'offset' in call\n    guard let start = string.index(of:\
    \ \"[\"), let end = string.index(of: \"]\"), let start = string.index(of: \"[\"\
    , offset: start), let end = string.index(of: \"]\", offset: end) else {\n    \
    \                                                              "
  stdout: ''
  timestamp: 1660013961
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    func is_nested(string: String) -> Bool {\n    guard let openBracket = string.index(of:\
    \ \"[\"),\n        let closeBracket = string.index(of: \"]\"),\n        openBracket\
    \ != closeBracket else { return false }\n    \n    let openBracketIndex = string.index(of:\
    \ \"[\", offsetBy: openBracket)\n    let closeBracketIndex = string.index(of:\
    \ \"]\", offsetBy: closeBracket)\n    \n    return openBracketIndex != nil &&\
    \ closeBracketIndex != nil && openBracketIndex! < closeBracketIndex!\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]][[[[[]\") == false)\nassert(is_nested(string: \"[][]\") == false)\n\
    assert(is_nested(string: \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\"\
    ) == true)\nassert(is_nested(string: \"[]]]]]]]]]]\") == false)\nassert(is_nested(string:\
    \ \"[][][[]]\") == true)\nassert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string:\
    \ \"[]]\") == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmp2cyjkxy6.swift:12:36: warning: 'index(of:)' is deprecated: renamed\
    \ to 'firstIndex(of:)'\n    guard let openBracket = string.index(of: \"[\"),\n\
    \                                   ^\n/tmp/tmp2cyjkxy6.swift:12:36: note: use\
    \ 'firstIndex(of:)' instead\n    guard let openBracket = string.index(of: \"[\"\
    ),\n                                   ^~~~~\n                               \
    \    firstIndex\n/tmp/tmp2cyjkxy6.swift:13:35: warning: 'index(of:)' is deprecated:\
    \ renamed to 'firstIndex(of:)'\n        let closeBracket = string.index(of: \"\
    ]\"),\n                                  ^\n/tmp/tmp2cyjkxy6.swift:13:35: note:\
    \ use 'firstIndex(of:)' instead\n        let closeBracket = string.index(of: \"\
    ]\"),\n                                  ^~~~~\n                             \
    \     firstIndex\n/tmp/tmp2cyjkxy6.swift:16:60: error: extra argument 'offsetBy'\
    \ in call\n    let openBracketIndex = string.index(of: \"[\", offsetBy: openBracket)\n\
    \                                       ~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~\n/tmp/tmp2cyjkxy6.swift:17:61:\
    \ error: extra argument 'offsetBy' in call\n    let closeBracketIndex = string.index(of:\
    \ \"]\", offsetBy: closeBracket)\n                                        ~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013961
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    func is_nested(string: String) -> Bool {\n    let stack = Stack()\n    for char\
    \ in string {\n        if char == '[' {\n            stack.push(char)\n      \
    \  } else if char == ']' {\n            if stack.top() == '[' {\n            \
    \    stack.pop()\n            } else {\n                return false\n       \
    \     }\n        }\n    }\n    return stack.empty()\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]][[[[[]\") == false)\nassert(is_nested(string: \"[][]\") == false)\n\
    assert(is_nested(string: \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\"\
    ) == true)\nassert(is_nested(string: \"[]]]]]]]]]]\") == false)\nassert(is_nested(string:\
    \ \"[][][[]]\") == true)\nassert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string:\
    \ \"[]]\") == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmpspcecqyj.swift:14:20: error: single-quoted string literal found,\
    \ use '\"'\n        if char == '[' {\n                   ^~~\n               \
    \    \"[\"\n/tmp/tmpspcecqyj.swift:16:27: error: single-quoted string literal\
    \ found, use '\"'\n        } else if char == ']' {\n                         \
    \ ^~~\n                          \"]\"\n/tmp/tmpspcecqyj.swift:17:31: error: single-quoted\
    \ string literal found, use '\"'\n            if stack.top() == '[' {\n      \
    \                        ^~~\n                              \"[\"\n/tmp/tmpspcecqyj.swift:12:17:\
    \ error: cannot find 'Stack' in scope\n    let stack = Stack()\n             \
    \   ^~~~~\n"
  stdout: ''
  timestamp: 1660013961
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    func is_nested(string: String) -> Bool {\n\tlet stack = Stack()\n\tlet openBrackets\
    \ = Stack()\n\tlet closeBrackets = Stack()\n\tlet openBracketsCount = Stack()\n\
    \tlet closeBracketsCount = Stack()\n\tlet openBracketsCount2 = Stack()\n\tlet\
    \ closeBracketsCount2 = Stack()\n\tlet openBracketsCount3 = Stack()\n\tlet closeBracketsCount3\
    \ = Stack()\n\tlet openBracketsCount4 = Stack()\n\tlet closeBracketsCount4 = Stack()\n\
    \tlet openBracketsCount5 = Stack()\n\tlet closeBracketsCount5 = Stack()\n\tlet\
    \ openBracketsCount6 = Stack()\n\tlet closeBracketsCount6 = Stack()\n\tlet openBracketsCount7\
    \ = Stack()\n\tlet closeBracketsCount7 = Stack()\n\tlet openBracketsCount8 = Stack()\n\
    \tlet closeBracketsCount8 = Stack()\n\tlet openBracketsCount9 = Stack()\n\tlet\
    \ closeBracketsCount9 = Stack()\n\tlet openBracketsCount10 = Stack()\n\tlet closeBracketsCount10\
    \ = Stack()\n\tlet openBracketsCount11 = Stack()\n\tlet closeBracketsCount11 =\
    \ Stack()\n\tlet openBracketsCount12 = Stack()\n\tlet closeBracketsCount12 = Stack()\n\
    \tlet openBracketsCount13 = Stack()\n\tlet closeBracketsCount13 = Stack()\n\t\
    let openBracketsCount14 = Stack()\n\tlet closeBracketsCount14 = Stack()\n\tlet\
    \ openBracketsCount15 = Stack()\n\tlet closeBracketsCount15 = Stack()\n\tlet openBracketsCount16\
    \ = Stack()\n\tlet closeBracketsCount16 = Stack()\n\tlet openBracketsCount17 =\
    \ Stack()\n\tlet closeBracketsCount17 = Stack()\n\tlet openBracketsCount18 = Stack()\n\
    \tlet closeBracketsCount18 = Stack()\n\tlet openBracketsCount19 = Stack()\n\t\
    let closeBracketsCount19 = Stack()\n\tlet openBracketsCount20 = Stack()\n\tlet\
    \ closeBracketsCount20 = Stack()\n\tlet openBracketsCount21 = Stack()\n\tlet closeBracketsCount21\
    \ = Stack()\n\tlet openBracketsCount22 = \n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string: \"\
    []]]]]]][[[[[]\") == false)\nassert(is_nested(string: \"[][]\") == false)\nassert(is_nested(string:\
    \ \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]]]]]\") == false)\nassert(is_nested(string: \"[][][[]]\") == true)\n\
    assert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string: \"[]]\"\
    ) == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmpup7zjaeh.swift:57:27: error: expected initial value after '='\n\
    \        let openBracketsCount22 = \n                                 ^\n/tmp/tmpup7zjaeh.swift:12:14:\
    \ error: cannot find 'Stack' in scope\n        let stack = Stack()\n         \
    \           ^~~~~\n/tmp/tmpup7zjaeh.swift:13:21: error: cannot find 'Stack' in\
    \ scope\n        let openBrackets = Stack()\n                           ^~~~~\n\
    /tmp/tmpup7zjaeh.swift:14:22: error: cannot find 'Stack' in scope\n        let\
    \ closeBrackets = Stack()\n                            ^~~~~\n/tmp/tmpup7zjaeh.swift:15:26:\
    \ error: cannot find 'Stack' in scope\n        let openBracketsCount = Stack()\n\
    \                                ^~~~~\n/tmp/tmpup7zjaeh.swift:16:27: error: cannot\
    \ find 'Stack' in scope\n        let closeBracketsCount = Stack()\n          \
    \                       ^~~~~\n/tmp/tmpup7zjaeh.swift:17:27: error: cannot find\
    \ 'Stack' in scope\n        let openBracketsCount2 = Stack()\n               \
    \                  ^~~~~\n/tmp/tmpup7zjaeh.swift:18:28: error: cannot find 'Stack'\
    \ in scope\n        let closeBracketsCount2 = Stack()\n                      \
    \            ^~~~~\n/tmp/tmpup7zjaeh.swift:19:27: error: cannot find 'Stack' in\
    \ scope\n        let openBracketsCount3 = Stack()\n                          \
    \       ^~~~~\n/tmp/tmpup7zjaeh.swift:20:28: error: cannot find 'Stack' in scope\n\
    \        let closeBracketsCount3 = Stack()\n                                 \
    \ ^~~~~\n/tmp/tmpup7zjaeh.swift:21:27: error: cannot find 'Stack' in scope\n \
    \       let openBracketsCount4 = Stack()\n                                 ^~~~~\n\
    /tmp/tmpup7zjaeh.swift:22:28: error: cannot find 'Stack' in scope\n        let\
    \ closeBracketsCount4 = Stack()\n                                  ^~~~~\n/tmp/tmpup7zjaeh.swift:23:27:\
    \ error: cannot find 'Stack' in scope\n        let openBracketsCount5 = Stack()\n\
    \                                 ^~~~~\n/tmp/tmpup7zjaeh.swift:24:28: error:\
    \ cannot find 'Stack' in scope\n        let closeBracketsCount5 = Stack()\n  \
    \                                ^~~~~\n/tmp/tmpup7zjaeh.swift:25:27: error: cannot\
    \ find 'St"
  stdout: ''
  timestamp: 1660013961
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    func is_nested(string: String) -> Bool {\n    let brackets = string.unicodeScalars\n\
    \        .filter { $0 != '[' }\n        .filter { $0 != ']' }\n        .filter\
    \ { $0 != '{' }\n        .filter { $0 != '}' }\n        .filter { $0 != '(' }\n\
    \        .filter { $0 != ')' }\n    return brackets.count > 0\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]][[[[[]\") == false)\nassert(is_nested(string: \"[][]\") == false)\n\
    assert(is_nested(string: \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\"\
    ) == true)\nassert(is_nested(string: \"[]]]]]]]]]]\") == false)\nassert(is_nested(string:\
    \ \"[][][[]]\") == true)\nassert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string:\
    \ \"[]]\") == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmp55edippv.swift:13:25: error: single-quoted string literal found,\
    \ use '\"'\n        .filter { $0 != '[' }\n                        ^~~\n     \
    \                   \"[\"\n/tmp/tmp55edippv.swift:14:25: error: single-quoted\
    \ string literal found, use '\"'\n        .filter { $0 != ']' }\n            \
    \            ^~~\n                        \"]\"\n/tmp/tmp55edippv.swift:15:25:\
    \ error: single-quoted string literal found, use '\"'\n        .filter { $0 !=\
    \ '{' }\n                        ^~~\n                        \"{\"\n/tmp/tmp55edippv.swift:16:25:\
    \ error: single-quoted string literal found, use '\"'\n        .filter { $0 !=\
    \ '}' }\n                        ^~~\n                        \"}\"\n/tmp/tmp55edippv.swift:17:25:\
    \ error: single-quoted string literal found, use '\"'\n        .filter { $0 !=\
    \ '(' }\n                        ^~~\n                        \"(\"\n/tmp/tmp55edippv.swift:18:25:\
    \ error: single-quoted string literal found, use '\"'\n        .filter { $0 !=\
    \ ')' }\n                        ^~~\n                        \")\"\n/tmp/tmp55edippv.swift:12:27:\
    \ error: ambiguous use of 'filter'\n    let brackets = string.unicodeScalars\n\
    \                          ^\nSwift.RangeReplaceableCollection:3:40: note: found\
    \ this candidate\n    @inlinable public __consuming func filter(_ isIncluded:\
    \ (Self.Element) throws -> Bool) rethrows -> Self\n                          \
    \             ^\nSwift.Sequence:3:40: note: found this candidate\n    @inlinable\
    \ public __consuming func filter(_ isIncluded: (Self.Element) throws -> Bool)\
    \ rethrows -> [Self.Element]\n                                       ^\n"
  stdout: ''
  timestamp: 1660013962
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    func is_nested(string: String) -> Bool {\n    if string == \"\" {\n        return\
    \ false\n    }\n    var openBrackets = 0\n    var closeBrackets = 0\n    var openBracketsStack\
    \ = [String]()\n    var closeBracketsStack = [String]()\n    for char in string\
    \ {\n        if char == \"[\" {\n            openBracketsStack.append(char)\n\
    \            openBrackets++\n        } else if char == \"]\" {\n            closeBracketsStack.append(char)\n\
    \            closeBrackets++\n        } else if char == \"]\" && openBrackets\
    \ > 0 && closeBrackets == 0 {\n            closeBracketsStack.removeLast()\n \
    \           closeBrackets--\n            if openBrackets == 0 {\n            \
    \    openBracketsStack.removeLast()\n                openBrackets--\n        \
    \    }\n        }\n    }\n    return openBrackets == 0 && closeBrackets == 0\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]][[[[[]\") == false)\nassert(is_nested(string: \"[][]\") == false)\n\
    assert(is_nested(string: \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\"\
    ) == true)\nassert(is_nested(string: \"[]]]]]]]]]]\") == false)\nassert(is_nested(string:\
    \ \"[][][[]]\") == true)\nassert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string:\
    \ \"[]]\") == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmp3__vqrki.swift:21:38: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n            openBracketsStack.append(char)\n\
    \                                     ^\n/tmp/tmp3__vqrki.swift:22:25: error:\
    \ cannot find operator '++' in scope; did you mean '+= 1'?\n            openBrackets++\n\
    \                        ^~\n/tmp/tmp3__vqrki.swift:24:39: error: cannot convert\
    \ value of type 'Character' to expected argument type 'String'\n            closeBracketsStack.append(char)\n\
    \                                      ^\n/tmp/tmp3__vqrki.swift:25:26: error:\
    \ cannot find operator '++' in scope; did you mean '+= 1'?\n            closeBrackets++\n\
    \                         ^~\n/tmp/tmp3__vqrki.swift:28:26: error: cannot find\
    \ operator '--' in scope; did you mean '-= 1'?\n            closeBrackets--\n\
    \                         ^~\n/tmp/tmp3__vqrki.swift:31:29: error: cannot find\
    \ operator '--' in scope; did you mean '-= 1'?\n                openBrackets--\n\
    \                            ^~\n"
  stdout: ''
  timestamp: 1660013961
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    func is_nested(string: String) -> Bool {\n    var openBracketCount = 0\n    var\
    \ closeBracketCount = 0\n    var openBracketCountStack = [Int]()\n    var closeBracketCountStack\
    \ = [Int]()\n    for char in string {\n        switch char {\n        case '[':\n\
    \            openBracketCountStack.append(openBracketCount)\n            openBracketCount++\n\
    \        case ']':\n            closeBracketCountStack.append(closeBracketCount)\n\
    \            closeBracketCount++\n        default:\n            if openBracketCount\
    \ > closeBracketCount {\n                return false\n            }\n       \
    \     if openBracketCount == closeBracketCount {\n                openBracketCountStack.removeLast()\n\
    \                closeBracketCountStack.removeLast()\n            }\n        }\n\
    \    }\n    if openBracketCount != closeBracketCount {\n        return false\n\
    \    }\n    for openBracketCount in openBracketCountStack {\n        if openBracketCount\
    \ != closeBracketCount {\n            return false\n        }\n    }\n    return\
    \ true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(is_nested(string: \"[[]]\"\
    ) == true)\nassert(is_nested(string: \"[]]]]]]][[[[[]\") == false)\nassert(is_nested(string:\
    \ \"[][]\") == false)\nassert(is_nested(string: \"[]\") == false)\nassert(is_nested(string:\
    \ \"[[[[]]]]\") == true)\nassert(is_nested(string: \"[]]]]]]]]]]\") == false)\n\
    assert(is_nested(string: \"[][][[]]\") == true)\nassert(is_nested(string: \"[[]\"\
    ) == false)\nassert(is_nested(string: \"[]]\") == false)\nassert(is_nested(string:\
    \ \"[[]][[\") == true)\nassert(is_nested(string: \"[[][]]\") == true)\nassert(is_nested(string:\
    \ \"\") == false)\nassert(is_nested(string: \"[[[[[[[[\") == false)\nassert(is_nested(string:\
    \ \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmph7oab7sq.swift:18:14: error: single-quoted string literal found,\
    \ use '\"'\n        case '[':\n             ^~~\n             \"[\"\n/tmp/tmph7oab7sq.swift:21:14:\
    \ error: single-quoted string literal found, use '\"'\n        case ']':\n   \
    \          ^~~\n             \"]\"\n/tmp/tmph7oab7sq.swift:20:29: error: cannot\
    \ find operator '++' in scope; did you mean '+= 1'?\n            openBracketCount++\n\
    \                            ^~\n/tmp/tmph7oab7sq.swift:23:30: error: cannot find\
    \ operator '++' in scope; did you mean '+= 1'?\n            closeBracketCount++\n\
    \                             ^~\n"
  stdout: ''
  timestamp: 1660013961
- exit_code: -4
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    func is_nested(string: String) -> Bool {\n    \n    // Your code here\n    \n\
    \    return false\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(is_nested(string:\
    \ \"[[]]\") == true)\nassert(is_nested(string: \"[]]]]]]][[[[[]\") == false)\n\
    assert(is_nested(string: \"[][]\") == false)\nassert(is_nested(string: \"[]\"\
    ) == false)\nassert(is_nested(string: \"[[[[]]]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]]]]]\") == false)\nassert(is_nested(string: \"[][][[]]\") == true)\n\
    assert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string: \"[]]\"\
    ) == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: Exception
  stderr: 'tmpghpah9e9/tmpghpah9e9.swift:31: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab009692c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab009389b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab009389988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab0093887b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpghpah9e9                        0x000055d6f6afa25b <unavailable> + 4699

    5    libc.so.6                          0x00002ab00987e460 __libc_start_main +
    245

    6    tmpghpah9e9                        0x000055d6f6af9ee9 <unavailable> + 3817

    '
  stdout: ''
  timestamp: 1660013961
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    func is_nested(string: String) -> Bool {\n    var stack = [String]()\n    var\
    \ opening = false\n    for c in string {\n        if c == '[' {\n            stack.append(c)\n\
    \            opening = true\n        } else if c == ']' {\n            if opening{\n\
    \                opening = false\n            } else {\n                return\
    \ false\n            }\n        } else {\n            if opening{\n          \
    \      stack.removeLast()\n            }\n        }\n    }\n    return stack.count\
    \ == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(is_nested(string: \"[[]]\"\
    ) == true)\nassert(is_nested(string: \"[]]]]]]][[[[[]\") == false)\nassert(is_nested(string:\
    \ \"[][]\") == false)\nassert(is_nested(string: \"[]\") == false)\nassert(is_nested(string:\
    \ \"[[[[]]]]\") == true)\nassert(is_nested(string: \"[]]]]]]]]]]\") == false)\n\
    assert(is_nested(string: \"[][][[]]\") == true)\nassert(is_nested(string: \"[[]\"\
    ) == false)\nassert(is_nested(string: \"[]]\") == false)\nassert(is_nested(string:\
    \ \"[[]][[\") == true)\nassert(is_nested(string: \"[[][]]\") == true)\nassert(is_nested(string:\
    \ \"\") == false)\nassert(is_nested(string: \"[[[[[[[[\") == false)\nassert(is_nested(string:\
    \ \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmpjj52dwcx.swift:15:17: error: single-quoted string literal found,\
    \ use '\"'\n        if c == '[' {\n                ^~~\n                \"[\"\n\
    /tmp/tmpjj52dwcx.swift:18:24: error: single-quoted string literal found, use '\"\
    '\n        } else if c == ']' {\n                       ^~~\n                \
    \       \"]\"\n/tmp/tmpjj52dwcx.swift:16:26: error: cannot convert value of type\
    \ 'Character' to expected argument type 'String'\n            stack.append(c)\n\
    \                         ^\n"
  stdout: ''
  timestamp: 1660013961
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    func is_nested(string: String) -> Bool {\n    guard let openBracketIndex = string.index(of:\
    \ \"[\"),\n        let closeBracketIndex = string.index(of: \"]\"),\n        openBracketIndex\
    \ != closeBracketIndex else {\n            return false\n    }\n    \n    let\
    \ openBracketCount = 1\n    let closeBracketCount = 1\n    \n    var openBracketIndex:\
    \ String.Index?\n    var closeBracketIndex: String.Index?\n    \n    for index\
    \ in string.indices {\n        if let openBracketIndex = string.index(of: \"[\"\
    , range: index..<string.endIndex),\n            let closeBracketIndex = string.index(of:\
    \ \"]\", range: openBracketIndex..<string.endIndex),\n            openBracketIndex\
    \ != closeBracketIndex {\n                openBracketCount += 1\n            \
    \    closeBracketCount += 1\n        }\n    }\n    \n    return openBracketCount\
    \ == closeBracketCount\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(is_nested(string:\
    \ \"[[]]\") == true)\nassert(is_nested(string: \"[]]]]]]][[[[[]\") == false)\n\
    assert(is_nested(string: \"[][]\") == false)\nassert(is_nested(string: \"[]\"\
    ) == false)\nassert(is_nested(string: \"[[[[]]]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]]]]]\") == false)\nassert(is_nested(string: \"[][][[]]\") == true)\n\
    assert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string: \"[]]\"\
    ) == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmp16kch9l8.swift:12:41: warning: 'index(of:)' is deprecated: renamed\
    \ to 'firstIndex(of:)'\n    guard let openBracketIndex = string.index(of: \"[\"\
    ),\n                                        ^\n/tmp/tmp16kch9l8.swift:12:41: note:\
    \ use 'firstIndex(of:)' instead\n    guard let openBracketIndex = string.index(of:\
    \ \"[\"),\n                                        ^~~~~\n                   \
    \                     firstIndex\n/tmp/tmp16kch9l8.swift:13:40: warning: 'index(of:)'\
    \ is deprecated: renamed to 'firstIndex(of:)'\n        let closeBracketIndex =\
    \ string.index(of: \"]\"),\n                                       ^\n/tmp/tmp16kch9l8.swift:13:40:\
    \ note: use 'firstIndex(of:)' instead\n        let closeBracketIndex = string.index(of:\
    \ \"]\"),\n                                       ^~~~~\n                    \
    \                   firstIndex\n/tmp/tmp16kch9l8.swift:21:9: error: invalid redeclaration\
    \ of 'openBracketIndex'\n    var openBracketIndex: String.Index?\n        ^\n\
    /tmp/tmp16kch9l8.swift:12:15: note: 'openBracketIndex' previously declared here\n\
    \    guard let openBracketIndex = string.index(of: \"[\"),\n              ^\n\
    /tmp/tmp16kch9l8.swift:22:9: error: invalid redeclaration of 'closeBracketIndex'\n\
    \    var closeBracketIndex: String.Index?\n        ^\n/tmp/tmp16kch9l8.swift:13:13:\
    \ note: 'closeBracketIndex' previously declared here\n        let closeBracketIndex\
    \ = string.index(of: \"]\"),\n            ^\n/tmp/tmp16kch9l8.swift:25:69: error:\
    \ extra argument 'range' in call\n        if let openBracketIndex = string.index(of:\
    \ \"[\", range: index..<string.endIndex),\n                                  \
    \            ~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~\n/tmp/tmp16kch9l8.swift:26:82:\
    \ error: extra argument 'range' in call\n            let closeBracketIndex = string.index(of:\
    \ \"]\", range: openBracketIndex..<string.endIndex),\n                       \
    \                         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmp16kch9l8.swift:28:34: error: left side of mutating operator isn't mutable:\
    \ 'openBracketCount' is a 'let' constant\n                openBrack"
  stdout: ''
  timestamp: 1660013961
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    func is_nested(string: String) -> Bool {\n\tlet brackets = string.unicodeScalars\n\
    \tlet openingBrackets = brackets.filter({ $0.isOpen })\n\tlet closingBrackets\
    \ = brackets.filter({ $0.isClosing })\n\t\n\treturn openingBrackets.count > 0\
    \ && closingBrackets.count > 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(is_nested(string:\
    \ \"[[]]\") == true)\nassert(is_nested(string: \"[]]]]]]][[[[[]\") == false)\n\
    assert(is_nested(string: \"[][]\") == false)\nassert(is_nested(string: \"[]\"\
    ) == false)\nassert(is_nested(string: \"[[[[]]]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]]]]]\") == false)\nassert(is_nested(string: \"[][][[]]\") == true)\n\
    assert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string: \"[]]\"\
    ) == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmp7kaqbemq.swift:13:45: error: value of type 'Unicode.Scalar' has\
    \ no member 'isOpen'\n        let openingBrackets = brackets.filter({ $0.isOpen\
    \ })\n                                                ~~ ^~~~~~\n/tmp/tmp7kaqbemq.swift:14:45:\
    \ error: value of type 'Unicode.Scalar' has no member 'isClosing'\n        let\
    \ closingBrackets = brackets.filter({ $0.isClosing })\n                      \
    \                          ~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013961
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    func is_nested(string: String) -> Bool {\n    guard let open = string.range(of:\
    \ \"[\"),\n        let close = string.range(of: \"]\"),\n        let open2 = string.range(of:\
    \ \"[\", options: .backwards),\n        let close2 = string.range(of: \"]\", options:\
    \ .backwards) else {\n            return false\n    }\n    return open < close\
    \ && open2 < close2\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(is_nested(string:\
    \ \"[[]]\") == true)\nassert(is_nested(string: \"[]]]]]]][[[[[]\") == false)\n\
    assert(is_nested(string: \"[][]\") == false)\nassert(is_nested(string: \"[]\"\
    ) == false)\nassert(is_nested(string: \"[[[[]]]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]]]]]\") == false)\nassert(is_nested(string: \"[][][[]]\") == true)\n\
    assert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string: \"[]]\"\
    ) == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmp6cdlgw2v.swift:12:29: error: value of type 'String' has no member\
    \ 'range'\n    guard let open = string.range(of: \"[\"),\n                   \
    \  ~~~~~~ ^~~~~\n/tmp/tmp6cdlgw2v.swift:13:28: error: value of type 'String' has\
    \ no member 'range'\n        let close = string.range(of: \"]\"),\n          \
    \          ~~~~~~ ^~~~~\n/tmp/tmp6cdlgw2v.swift:14:28: error: value of type 'String'\
    \ has no member 'range'\n        let open2 = string.range(of: \"[\", options:\
    \ .backwards),\n                    ~~~~~~ ^~~~~\n/tmp/tmp6cdlgw2v.swift:14:53:\
    \ error: cannot infer contextual base in reference to member 'backwards'\n   \
    \     let open2 = string.range(of: \"[\", options: .backwards),\n            \
    \                                       ~^~~~~~~~~\n/tmp/tmp6cdlgw2v.swift:15:29:\
    \ error: value of type 'String' has no member 'range'\n        let close2 = string.range(of:\
    \ \"]\", options: .backwards) else {\n                     ~~~~~~ ^~~~~\n/tmp/tmp6cdlgw2v.swift:15:54:\
    \ error: cannot infer contextual base in reference to member 'backwards'\n   \
    \     let close2 = string.range(of: \"]\", options: .backwards) else {\n     \
    \                                               ~^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013961
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    func is_nested(string: String) -> Bool {\n    guard let openingBracketIndex =\
    \ string.index(of: \"[\"),\n        let closingBracketIndex = string.index(of:\
    \ \"]\"),\n        openingBracketIndex != closingBracketIndex else {\n       \
    \     return false\n    }\n    let openingBracket = string[openingBracketIndex..<closingBracketIndex]\n\
    \    let closingBracket = string[closingBracketIndex..<string.endIndex]\n    let\
    \ openingBracketCount = openingBracket.count\n    let closingBracketCount = closingBracket.count\n\
    \    if openingBracketCount > closingBracketCount {\n        return false\n  \
    \  }\n    let openingBracketIndex = string.index(of: \"[\", offsetBy: 1)\n   \
    \ let closingBracketIndex = string.index(of: \"]\", offsetBy: 1)\n    let openingBracket\
    \ = string[openingBracketIndex..<closingBracketIndex]\n    let closingBracket\
    \ = string[closingBracketIndex..<string.endIndex]\n    let openingBracketCount\
    \ = openingBracket.count\n    let closingBracketCount = closingBracket.count\n\
    \    if openingBracketCount > closingBracketCount {\n        return false\n  \
    \  }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(is_nested(string:\
    \ \"[[]]\") == true)\nassert(is_nested(string: \"[]]]]]]][[[[[]\") == false)\n\
    assert(is_nested(string: \"[][]\") == false)\nassert(is_nested(string: \"[]\"\
    ) == false)\nassert(is_nested(string: \"[[[[]]]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]]]]]\") == false)\nassert(is_nested(string: \"[][][[]]\") == true)\n\
    assert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string: \"[]]\"\
    ) == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmpbgkfsbkq.swift:12:44: warning: 'index(of:)' is deprecated: renamed\
    \ to 'firstIndex(of:)'\n    guard let openingBracketIndex = string.index(of: \"\
    [\"),\n                                           ^\n/tmp/tmpbgkfsbkq.swift:12:44:\
    \ note: use 'firstIndex(of:)' instead\n    guard let openingBracketIndex = string.index(of:\
    \ \"[\"),\n                                           ^~~~~\n                \
    \                           firstIndex\n/tmp/tmpbgkfsbkq.swift:13:42: warning:\
    \ 'index(of:)' is deprecated: renamed to 'firstIndex(of:)'\n        let closingBracketIndex\
    \ = string.index(of: \"]\"),\n                                         ^\n/tmp/tmpbgkfsbkq.swift:13:42:\
    \ note: use 'firstIndex(of:)' instead\n        let closingBracketIndex = string.index(of:\
    \ \"]\"),\n                                         ^~~~~\n                  \
    \                       firstIndex\n/tmp/tmpbgkfsbkq.swift:24:38: error: no exact\
    \ matches in call to instance method 'index'\n    let openingBracketIndex = string.index(of:\
    \ \"[\", offsetBy: 1)\n                                     ^\n/tmp/tmpbgkfsbkq.swift:24:38:\
    \ note: candidate has partially matching parameter list (String.Index, offsetBy:\
    \ Int)\n    let openingBracketIndex = string.index(of: \"[\", offsetBy: 1)\n \
    \                                    ^\n/tmp/tmpbgkfsbkq.swift:24:38: note: candidate\
    \ has partially matching parameter list (String.Index, offsetBy: Int)\n    let\
    \ openingBracketIndex = string.index(of: \"[\", offsetBy: 1)\n               \
    \                      ^\n/tmp/tmpbgkfsbkq.swift:24:38: note: candidate has partially\
    \ matching parameter list (String.Index, offsetBy: Int)\n    let openingBracketIndex\
    \ = string.index(of: \"[\", offsetBy: 1)\n                                   \
    \  ^\n/tmp/tmpbgkfsbkq.swift:25:38: error: no exact matches in call to instance\
    \ method 'index'\n    let closingBracketIndex = string.index(of: \"]\", offsetBy:\
    \ 1)\n                                     ^\n/tmp/tmpbgkfsbkq.swift:25:38: note:\
    \ candidate has partially matching parameter list (String.Index, offsetBy: Int)\n\
    \    let closingBracketIndex = string.index(of: \""
  stdout: ''
  timestamp: 1660013961
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    func is_nested(string: String) -> Bool {\n    let brackets = string.unicodeScalars\n\
    \        .filter({$0 >= 0x5B && $0 <= 0x5D})\n        .filter({$0 >= 0x7B && $0\
    \ <= 0x7D})\n        .filter({$0 >= 0x5B && $0 <= 0x5D})\n        .filter({$0\
    \ >= 0x7B && $0 <= 0x7D})\n        .filter({$0 >= 0x5B && $0 <= 0x5D})\n     \
    \   .filter({$0 >= 0x7B && $0 <= 0x7D})\n        .filter({$0 >= 0x5B && $0 <=\
    \ 0x5D})\n        .filter({$0 >= 0x7B && $0 <= 0x7D})\n        .filter({$0 >=\
    \ 0x5B && $0 <= 0x5D})\n        .filter({$0 >= 0x7B && $0 <= 0x7D})\n        .filter({$0\
    \ >= 0x5B && $0 <= 0x5D})\n        .filter({$0 >= 0x7B && $0 <= 0x7D})\n     \
    \   .filter({$0 >= 0x5B && $0 <= 0x5D})\n        .filter({$0 >= 0x7B && $0 <=\
    \ 0x7D})\n        .filter({$0 >= 0x5B && $0 <= 0x5D})\n        .filter({$0 >=\
    \ 0x7B && $0 <= 0x7D})\n        .filter({$0 >= 0x5B && $0 <= 0x5D})\n        .filter({$0\
    \ >= 0x7B && $0 <= 0x7D})\n        .filter({$0 >= 0x5B && $0 <= 0x5D})\n     \
    \   .filter({$0 >= 0x7B && $0 <= 0x7D})\n        .filter({$0 >= 0x5B && $0 <=\
    \ 0x5D})\n        .filter({$0 >= 0x7B && $0 <= 0x7D})\n        .filter({$0 >=\
    \ 0x5B && $0 <= 0x5D})\n        .filter({$0 >= 0x7B && $0 <= 0x7D})\n        .filter({$0\
    \ >= 0x5B && $0 <= 0x5D})\n        .filter({$0 >= 0x7B && $0 <= 0x7D})\n     \
    \   .filter({$0 >= 0x5B && $0 <= 0x5D})\n        .filter({$0 >= 0x7B && $0 <=\
    \ 0x7D})\n        .filter({$0 >= 0x5B && $0 <= 0x5D})\n        .filter({$0 >=\
    \ 0x7B && $0 <= 0x7D})\n        .filter({$0 >= 0x5B && $0 <= 0x5D})\n        .filter({$0\
    \ >= 0x7B && $0 <= 0x7D})\n        .filter({$0 >= 0x5B && $0 <= 0x5D})\n     \
    \   .filter({$0 >= 0x7B && \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(is_nested(string:\
    \ \"[[]]\") == true)\nassert(is_nested(string: \"[]]]]]]][[[[[]\") == false)\n\
    assert(is_nested(string: \"[][]\") == false)\nassert(is_nested(string: \"[]\"\
    ) == false)\nassert(is_nested(string: \"[[[[]]]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]]]]]\") == false)\nassert(is_nested(string: \"[][][[]]\") == true)\n\
    assert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string: \"[]]\"\
    ) == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmpajfkqq4b.swift:47:1: error: expected expression after operator\n\
    }\n^\n/tmp/tmpajfkqq4b.swift:50:1: error: expected ')' in expression list\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n^\n/tmp/tmpajfkqq4b.swift:46:16:\
    \ note: to match this opening '('\n        .filter({$0 >= 0x7B && \n         \
    \      ^\n/tmp/tmpajfkqq4b.swift:75:47: error: expected '}' at end of brace statement\n\
    assert(is_nested(string: \"]]]]]]]]\") == false)\n                           \
    \                   ^\n/tmp/tmpajfkqq4b.swift:11:40: note: to match this opening\
    \ '{'\nfunc is_nested(string: String) -> Bool {\n                            \
    \           ^\n/tmp/tmpajfkqq4b.swift:50:6: error: operator functions can only\
    \ be declared at global or in type scope\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660013961
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    func is_nested(string: String) -> Bool {\n    \n    let stack = Stack()\n    \n\
    \    for char in string {\n        \n        if char == '[' {\n            stack.push(char)\n\
    \        }\n        \n        if char == ']' {\n            \n            if stack.count\
    \ > 0 {\n                \n                if stack.peek() == '[' {\n        \
    \            stack.pop()\n                } else {\n                    return\
    \ false\n                }\n            } else {\n                return false\n\
    \            }\n        }\n    }\n    \n    return stack.count == 0\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]][[[[[]\") == false)\nassert(is_nested(string: \"[][]\") == false)\n\
    assert(is_nested(string: \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\"\
    ) == true)\nassert(is_nested(string: \"[]]]]]]]]]]\") == false)\nassert(is_nested(string:\
    \ \"[][][[]]\") == true)\nassert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string:\
    \ \"[]]\") == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmpe1s72ygp.swift:17:20: error: single-quoted string literal found,\
    \ use '\"'\n        if char == '[' {\n                   ^~~\n               \
    \    \"[\"\n/tmp/tmpe1s72ygp.swift:21:20: error: single-quoted string literal\
    \ found, use '\"'\n        if char == ']' {\n                   ^~~\n        \
    \           \"]\"\n/tmp/tmpe1s72ygp.swift:25:36: error: single-quoted string literal\
    \ found, use '\"'\n                if stack.peek() == '[' {\n                \
    \                   ^~~\n                                   \"[\"\n/tmp/tmpe1s72ygp.swift:13:17:\
    \ error: cannot find 'Stack' in scope\n    let stack = Stack()\n             \
    \   ^~~~~\n"
  stdout: ''
  timestamp: 1660013961
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    func is_nested(string: String) -> Bool {\n    let stack = Stack()\n    for char\
    \ in string {\n        if char == '[' {\n            stack.push(char)\n      \
    \  } else if char == ']' {\n            if stack.count > 0 {\n               \
    \ stack.pop()\n            } else {\n                return false\n          \
    \  }\n        }\n    }\n    return stack.count == 0\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]][[[[[]\") == false)\nassert(is_nested(string: \"[][]\") == false)\n\
    assert(is_nested(string: \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\"\
    ) == true)\nassert(is_nested(string: \"[]]]]]]]]]]\") == false)\nassert(is_nested(string:\
    \ \"[][][[]]\") == true)\nassert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string:\
    \ \"[]]\") == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmpy26dcyps.swift:14:20: error: single-quoted string literal found,\
    \ use '\"'\n        if char == '[' {\n                   ^~~\n               \
    \    \"[\"\n/tmp/tmpy26dcyps.swift:16:27: error: single-quoted string literal\
    \ found, use '\"'\n        } else if char == ']' {\n                         \
    \ ^~~\n                          \"]\"\n/tmp/tmpy26dcyps.swift:12:17: error: cannot\
    \ find 'Stack' in scope\n    let stack = Stack()\n                ^~~~~\n"
  stdout: ''
  timestamp: 1660013961
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    func is_nested(string: String) -> Bool {\n    let stack = Stack<String>()\n  \
    \  stack.push(string)\n    \n    while stack.count > 0 {\n        let top = stack.pop()\n\
    \        \n        if top == \"[\" || top == \"{\" || top == \"(\" || top == \"\
    <\" {\n            return true\n        }\n        \n        if top == \"]\" ||\
    \ top == \"]}\" || top == \"]>\" || top == \">\" {\n            return false\n\
    \        }\n        \n        if top == \"}\" || top == \"}>\" || top == \">}\"\
    \ {\n            return false\n        }\n        \n        if top == \"]>\" ||\
    \ top == \">>\" {\n            return false\n        }\n        \n        if top\
    \ == \"[\" || top == \"{\" || top == \"(\" || top == \"<\" {\n            return\
    \ false\n        }\n        \n        if top == \"]\" || top == \"]}\" || top\
    \ == \"]>\" || top == \">\" {\n            return false\n        }\n        \n\
    \        if top == \"}\" || top == \"}>\" || top == \">}\" {\n            return\
    \ false\n        }\n        \n        if top == \"]>\" || top == \">>\" {\n  \
    \          return false\n        }\n        \n        if top == \"<\" || top ==\
    \ \"<}\" || top == \"<<\" {\n            return false\n        }\n        \n \
    \       if top == \">\" || top == \">>\" {\n            return false\n       \
    \ }\n        \n        if top == \"{\" || top == \"}\" || top == \"}\" || top\
    \ == \"}\" {\n            return false\n        }\n        \n        if top ==\
    \ \"(\" || top == \"(}\" || top == \"(>\" || top == \"(>}\" {\n            return\
    \ false\n        }\n        \n        if top == \"<\" || top == \"<}\" || top\
    \ == \"<<\" {\n            return false\n        }\n        \n        if top ==\
    \ \">\" || top == \">>\" {\n            return false\n        }\n        \n  \
    \      if top == \"[\" || top == \"[}\" || top == \"[>\" || top == \"[>}\" {\n\
    \            return false\n        }\n        \n        if top == \"{\" || top\
    \ == \"}\" || top == \"}\" || top == \"}\" {\n            return false\n     \
    \   }\n        \n        if top == \"(\" || top == \"(}\" || top == \"(>\" ||\
    \ top == \"(>}\" {\n            return false\n        }\n        \n        if\
    \ top == \"<\" || top == \"<}\" || top == \"<<\" {\n            return false\n\
    \        }\n        \n        if top == \">\" || top == \">>\" {\n           \
    \ return false\n        }\n        \n        if top == \"[\" || top == \"[}\"\
    \ || top == \"[>\" || top == \"[>}\" {\n            return false\n        }\n\
    \        \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(is_nested(string: \"\
    [[]]\") == true)\nassert(is_nested(string: \"[]]]]]]][[[[[]\") == false)\nassert(is_nested(string:\
    \ \"[][]\") == false)\nassert(is_nested(string: \"[]\") == false)\nassert(is_nested(string:\
    \ \"[[[[]]]]\") == true)\nassert(is_nested(string: \"[]]]]]]]]]]\") == false)\n\
    assert(is_nested(string: \"[][][[]]\") == true)\nassert(is_nested(string: \"[[]\"\
    ) == false)\nassert(is_nested(string: \"[]]\") == false)\nassert(is_nested(string:\
    \ \"[[]][[\") == true)\nassert(is_nested(string: \"[[][]]\") == true)\nassert(is_nested(string:\
    \ \"\") == false)\nassert(is_nested(string: \"[[[[[[[[\") == false)\nassert(is_nested(string:\
    \ \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmp9sd95bcd.swift:126:47: error: expected '}' at end of brace statement\n\
    assert(is_nested(string: \"]]]]]]]]\") == false)\n                           \
    \                   ^\n/tmp/tmp9sd95bcd.swift:11:40: note: to match this opening\
    \ '{'\nfunc is_nested(string: String) -> Bool {\n                            \
    \           ^\n/tmp/tmp9sd95bcd.swift:12:17: error: cannot find 'Stack' in scope\n\
    \    let stack = Stack<String>()\n                ^~~~~\n/tmp/tmp9sd95bcd.swift:101:6:\
    \ error: operator functions can only be declared at global or in type scope\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660013961
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    func is_nested(string: String) -> Bool {\n    guard let start = string.index(of:\
    \ \"[\"),\n        let end = string.index(of: \"]\"),\n        start != end,\n\
    \        start != string.endIndex,\n        end != string.startIndex,\n      \
    \  start < end else { return false }\n    \n    var open = 0\n    var close =\
    \ 0\n    var nesting = 0\n    \n    for index in string.indices {\n        guard\
    \ let c = string[index],\n            open == close else { continue }\n      \
    \  \n        switch c {\n        case \"[\": open += 1\n        case \"]\": close\
    \ += 1\n        default: nesting += 1\n        }\n    }\n    \n    return nesting\
    \ == 1\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(is_nested(string: \"[[]]\"\
    ) == true)\nassert(is_nested(string: \"[]]]]]]][[[[[]\") == false)\nassert(is_nested(string:\
    \ \"[][]\") == false)\nassert(is_nested(string: \"[]\") == false)\nassert(is_nested(string:\
    \ \"[[[[]]]]\") == true)\nassert(is_nested(string: \"[]]]]]]]]]]\") == false)\n\
    assert(is_nested(string: \"[][][[]]\") == true)\nassert(is_nested(string: \"[[]\"\
    ) == false)\nassert(is_nested(string: \"[]]\") == false)\nassert(is_nested(string:\
    \ \"[[]][[\") == true)\nassert(is_nested(string: \"[[][]]\") == true)\nassert(is_nested(string:\
    \ \"\") == false)\nassert(is_nested(string: \"[[[[[[[[\") == false)\nassert(is_nested(string:\
    \ \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmp0t_nz2gf.swift:12:30: warning: 'index(of:)' is deprecated: renamed\
    \ to 'firstIndex(of:)'\n    guard let start = string.index(of: \"[\"),\n     \
    \                        ^\n/tmp/tmp0t_nz2gf.swift:12:30: note: use 'firstIndex(of:)'\
    \ instead\n    guard let start = string.index(of: \"[\"),\n                  \
    \           ^~~~~\n                             firstIndex\n/tmp/tmp0t_nz2gf.swift:13:26:\
    \ warning: 'index(of:)' is deprecated: renamed to 'firstIndex(of:)'\n        let\
    \ end = string.index(of: \"]\"),\n                         ^\n/tmp/tmp0t_nz2gf.swift:13:26:\
    \ note: use 'firstIndex(of:)' instead\n        let end = string.index(of: \"]\"\
    ),\n                         ^~~~~\n                         firstIndex\n/tmp/tmp0t_nz2gf.swift:24:15:\
    \ error: initializer for conditional binding must have Optional type, not 'Character'\n\
    \        guard let c = string[index],\n              ^       ~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013961
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    func is_nested(string: String) -> Bool {\n    guard let index = string.index(of:\
    \ \"[\"),\n        let end = string.index(of: \"]\", from: index) else {\n   \
    \         return false\n    }\n    \n    let start = index + 1\n    let end =\
    \ string.index(of: \"]\", from: index)\n    \n    return start < end\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]][[[[[]\") == false)\nassert(is_nested(string: \"[][]\") == false)\n\
    assert(is_nested(string: \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\"\
    ) == true)\nassert(is_nested(string: \"[]]]]]]]]]]\") == false)\nassert(is_nested(string:\
    \ \"[][][[]]\") == true)\nassert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string:\
    \ \"[]]\") == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmprqr78q8v.swift:12:30: warning: 'index(of:)' is deprecated: renamed\
    \ to 'firstIndex(of:)'\n    guard let index = string.index(of: \"[\"),\n     \
    \                        ^\n/tmp/tmprqr78q8v.swift:12:30: note: use 'firstIndex(of:)'\
    \ instead\n    guard let index = string.index(of: \"[\"),\n                  \
    \           ^~~~~\n                             firstIndex\n/tmp/tmprqr78q8v.swift:13:47:\
    \ error: extra argument 'from' in call\n        let end = string.index(of: \"\
    ]\", from: index) else {\n                              ~~~~~~~~~~~~~~~~^~~~~~\n\
    /tmp/tmprqr78q8v.swift:17:17: error: cannot convert value of type 'String.Index'\
    \ to expected argument type 'Int'\n    let start = index + 1\n               \
    \ ^\n/tmp/tmprqr78q8v.swift:18:43: error: extra argument 'from' in call\n    let\
    \ end = string.index(of: \"]\", from: index)\n                          ~~~~~~~~~~~~~~~~^~~~~~\n"
  stdout: ''
  timestamp: 1660013961
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    func is_nested(string: String) -> Bool {\n    guard let open = string.rangeOfString(\"\
    [\", options: .LiteralSearch, range: nil, locale: nil),\n        let close = string.rangeOfString(\"\
    ]\", options: .LiteralSearch, range: nil, locale: nil) else {\n            return\
    \ false\n    }\n    return open < close\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string: \"[]]]]]]][[[[[]\"\
    ) == false)\nassert(is_nested(string: \"[][]\") == false)\nassert(is_nested(string:\
    \ \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]]]]]\") == false)\nassert(is_nested(string: \"[][][[]]\") == true)\n\
    assert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string: \"[]]\"\
    ) == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmp03k83ee4.swift:12:29: error: value of type 'String' has no member\
    \ 'rangeOfString'\n    guard let open = string.rangeOfString(\"[\", options: .LiteralSearch,\
    \ range: nil, locale: nil),\n                     ~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp03k83ee4.swift:12:58:\
    \ error: cannot infer contextual base in reference to member 'LiteralSearch'\n\
    \    guard let open = string.rangeOfString(\"[\", options: .LiteralSearch, range:\
    \ nil, locale: nil),\n                                                       \
    \ ~^~~~~~~~~~~~~\n/tmp/tmp03k83ee4.swift:12:80: error: 'nil' requires a contextual\
    \ type\n    guard let open = string.rangeOfString(\"[\", options: .LiteralSearch,\
    \ range: nil, locale: nil),\n                                                \
    \                               ^\n/tmp/tmp03k83ee4.swift:12:93: error: 'nil'\
    \ requires a contextual type\n    guard let open = string.rangeOfString(\"[\"\
    , options: .LiteralSearch, range: nil, locale: nil),\n                       \
    \                                                                     ^\n/tmp/tmp03k83ee4.swift:13:28:\
    \ error: value of type 'String' has no member 'rangeOfString'\n        let close\
    \ = string.rangeOfString(\"]\", options: .LiteralSearch, range: nil, locale: nil)\
    \ else {\n                    ~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp03k83ee4.swift:13:57:\
    \ error: cannot infer contextual base in reference to member 'LiteralSearch'\n\
    \        let close = string.rangeOfString(\"]\", options: .LiteralSearch, range:\
    \ nil, locale: nil) else {\n                                                 \
    \      ~^~~~~~~~~~~~~\n/tmp/tmp03k83ee4.swift:13:79: error: 'nil' requires a contextual\
    \ type\n        let close = string.rangeOfString(\"]\", options: .LiteralSearch,\
    \ range: nil, locale: nil) else {\n                                          \
    \                                    ^\n/tmp/tmp03k83ee4.swift:13:92: error: 'nil'\
    \ requires a contextual type\n        let close = string.rangeOfString(\"]\",\
    \ options: .LiteralSearch, range: nil, locale: nil) else {\n                 \
    \                                                                          ^\n"
  stdout: ''
  timestamp: 1660013961
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    func is_nested(string: String) -> Bool {\n\tlet stack = Stack()\n\tlet openingBrackets\
    \ = string.unicodeScalars.filter({ $0.isOpen })\n\tlet closingBrackets = string.unicodeScalars.filter({\
    \ $0.isClosing })\n\t\n\topeningBrackets.forEach { stack.push(it) }\n\tclosingBrackets.forEach\
    \ { stack.push(it) }\n\t\n\treturn stack.count == 0\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]][[[[[]\") == false)\nassert(is_nested(string: \"[][]\") == false)\n\
    assert(is_nested(string: \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\"\
    ) == true)\nassert(is_nested(string: \"[]]]]]]]]]]\") == false)\nassert(is_nested(string:\
    \ \"[][][[]]\") == true)\nassert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string:\
    \ \"[]]\") == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmp6yaipoot.swift:12:14: error: cannot find 'Stack' in scope\n   \
    \     let stack = Stack()\n                    ^~~~~\n/tmp/tmp6yaipoot.swift:13:58:\
    \ error: value of type 'Unicode.Scalar' has no member 'isOpen'\n        let openingBrackets\
    \ = string.unicodeScalars.filter({ $0.isOpen })\n                            \
    \                                 ~~ ^~~~~~\n/tmp/tmp6yaipoot.swift:14:58: error:\
    \ value of type 'Unicode.Scalar' has no member 'isClosing'\n        let closingBrackets\
    \ = string.unicodeScalars.filter({ $0.isClosing })\n                         \
    \                                    ~~ ^~~~~~~~~\n/tmp/tmp6yaipoot.swift:16:39:\
    \ error: cannot find 'it' in scope\n        openingBrackets.forEach { stack.push(it)\
    \ }\n                                             ^~\n/tmp/tmp6yaipoot.swift:17:39:\
    \ error: cannot find 'it' in scope\n        closingBrackets.forEach { stack.push(it)\
    \ }\n                                             ^~\n"
  stdout: ''
  timestamp: 1660013961
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    func is_nested(string: String) -> Bool {\n    guard let openBracket = string.rangeOfString(\"\
    [\", options: .BackwardsSearch) else {\n        return false\n    }\n    guard\
    \ let closeBracket = string.rangeOfString(\"]\", options: .BackwardsSearch) else\
    \ {\n        return false\n    }\n    guard openBracket.location < closeBracket.location\
    \ else {\n        return false\n    }\n    guard openBracket.location != string.startIndex\
    \ else {\n        return false\n    }\n    guard closeBracket.location != string.endIndex\
    \ else {\n        return false\n    }\n    guard openBracket.location < closeBracket.location\
    \ else {\n        return false\n    }\n    guard openBracket.location != string.startIndex\
    \ else {\n        return false\n    }\n    guard closeBracket.location != string.endIndex\
    \ else {\n        return false\n    }\n    guard openBracket.location < closeBracket.location\
    \ else {\n        return false\n    }\n    guard openBracket.location != string.startIndex\
    \ else {\n        return false\n    }\n    guard closeBracket.location != string.endIndex\
    \ else {\n        return false\n    }\n    guard openBracket.location < closeBracket.location\
    \ else {\n        return false\n    }\n    guard openBracket.location != string.startIndex\
    \ else {\n        return false\n    }\n    guard closeBracket.location != string.endIndex\
    \ else {\n        return false\n    }\n    guard openBracket.location < closeBracket.location\
    \ else {\n        return false\n    }\n    guard openBracket.location != string.startIndex\
    \ else {\n        return false\n    }\n    guard closeBracket.location != string.endIndex\
    \ else {\n        return false\n    }\n    guard openBracket.location < closeBracket.location\
    \ else {\n        return false\n    }\n    guard openBracket.location != string.startIndex\
    \ else {\n        return false\n    }\n    guard closeBracket.location != string.endIndex\
    \ else {\n        return false\n    }\n    guard openBracket.location < closeBracket.location\
    \ else {\n        return false\n    }\n    guard openBracket.location != string.startIndex\
    \ else {\n        return false\n    }\n    guard closeBracket.location != string.endIndex\
    \ else {\n        return false\n    }\n    guard openBracket.location < closeBracket.location\
    \ else {\n        return false\n    }\n    guard openBracket.location != string.startIndex\
    \ else {\n        return false\n    }\n    guard \n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]][[[[[]\") == false)\nassert(is_nested(string: \"[][]\") == false)\n\
    assert(is_nested(string: \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\"\
    ) == true)\nassert(is_nested(string: \"[]]]]]]]]]]\") == false)\nassert(is_nested(string:\
    \ \"[][][[]]\") == true)\nassert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string:\
    \ \"[]]\") == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmpe63zo833.swift:87:10: error: expected expression, var, let or case\
    \ in 'guard' condition\n    guard \n         ^\n/tmp/tmpe63zo833.swift:12:36:\
    \ error: value of type 'String' has no member 'rangeOfString'\n    guard let openBracket\
    \ = string.rangeOfString(\"[\", options: .BackwardsSearch) else {\n          \
    \                  ~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmpe63zo833.swift:12:65: error:\
    \ cannot infer contextual base in reference to member 'BackwardsSearch'\n    guard\
    \ let openBracket = string.rangeOfString(\"[\", options: .BackwardsSearch) else\
    \ {\n                                                               ~^~~~~~~~~~~~~~~\n\
    /tmp/tmpe63zo833.swift:15:37: error: value of type 'String' has no member 'rangeOfString'\n\
    \    guard let closeBracket = string.rangeOfString(\"]\", options: .BackwardsSearch)\
    \ else {\n                             ~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmpe63zo833.swift:15:66:\
    \ error: cannot infer contextual base in reference to member 'BackwardsSearch'\n\
    \    guard let closeBracket = string.rangeOfString(\"]\", options: .BackwardsSearch)\
    \ else {\n                                                                ~^~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013962
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    func is_nested(string: String) -> Bool {\n    let openingBrackets = string.unicodeScalars.filter({\
    \ $0.isOpen })\n    let closingBrackets = string.unicodeScalars.filter({ $0.isClosing\
    \ })\n    \n    return openingBrackets.count >= closingBrackets.count\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]][[[[[]\") == false)\nassert(is_nested(string: \"[][]\") == false)\n\
    assert(is_nested(string: \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\"\
    ) == true)\nassert(is_nested(string: \"[]]]]]]]]]]\") == false)\nassert(is_nested(string:\
    \ \"[][][[]]\") == true)\nassert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string:\
    \ \"[]]\") == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmpnxavod1x.swift:12:61: error: value of type 'Unicode.Scalar' has\
    \ no member 'isOpen'\n    let openingBrackets = string.unicodeScalars.filter({\
    \ $0.isOpen })\n                                                         ~~ ^~~~~~\n\
    /tmp/tmpnxavod1x.swift:13:61: error: value of type 'Unicode.Scalar' has no member\
    \ 'isClosing'\n    let closingBrackets = string.unicodeScalars.filter({ $0.isClosing\
    \ })\n                                                         ~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013961
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    func is_nested(string: String) -> Bool {\n    let stack = Stack()\n    for char\
    \ in string {\n        if char == '[' {\n            stack.push(char)\n      \
    \  } else if char == ']' {\n            if stack.count > 0 {\n               \
    \ stack.pop()\n            } else {\n                return false\n          \
    \  }\n        }\n    }\n    return stack.count == 0\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]][[[[[]\") == false)\nassert(is_nested(string: \"[][]\") == false)\n\
    assert(is_nested(string: \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\"\
    ) == true)\nassert(is_nested(string: \"[]]]]]]]]]]\") == false)\nassert(is_nested(string:\
    \ \"[][][[]]\") == true)\nassert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string:\
    \ \"[]]\") == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmpy26dcyps.swift:14:20: error: single-quoted string literal found,\
    \ use '\"'\n        if char == '[' {\n                   ^~~\n               \
    \    \"[\"\n/tmp/tmpy26dcyps.swift:16:27: error: single-quoted string literal\
    \ found, use '\"'\n        } else if char == ']' {\n                         \
    \ ^~~\n                          \"]\"\n/tmp/tmpy26dcyps.swift:12:17: error: cannot\
    \ find 'Stack' in scope\n    let stack = Stack()\n                ^~~~~\n"
  stdout: ''
  timestamp: 1660013961
- exit_code: -4
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    func is_nested(string: String) -> Bool {\n    guard let openBracketIndex = string.firstIndex(of:\
    \ \"[\"),\n        let closeBracketIndex = string.lastIndex(of: \"]\"),\n    \
    \    openBracketIndex != closeBracketIndex else {\n            return false\n\
    \    }\n    let openBracket = string[openBracketIndex..<closeBracketIndex]\n \
    \   let closeBracket = string[closeBracketIndex..<string.endIndex]\n    return\
    \ openBracket.count > 0 && closeBracket.count > 0 && openBracket == closeBracket\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]][[[[[]\") == false)\nassert(is_nested(string: \"[][]\") == false)\n\
    assert(is_nested(string: \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\"\
    ) == true)\nassert(is_nested(string: \"[]]]]]]]]]]\") == false)\nassert(is_nested(string:\
    \ \"[][][[]]\") == true)\nassert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string:\
    \ \"[]]\") == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: Exception
  stderr: 'tmp_11w8pg5/tmp_11w8pg5.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b514c40bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b514c102b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b514c102988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b514c1017b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp_11w8pg5                        0x0000555dbba6d76b <unavailable> + 5995

    5    libc.so.6                          0x00002b514c5f7460 __libc_start_main +
    245

    6    tmp_11w8pg5                        0x0000555dbba6d3f9 <unavailable> + 5113

    '
  stdout: ''
  timestamp: 1660013962
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    func is_nested(string: String) -> Bool {\n\tlet stack = Stack<String>()\n\tlet\
    \ openingBrackets = Set<String>()\n\tlet closingBrackets = Set<String>()\n\tlet\
    \ openingBracketsCount = stack.count\n\tlet closingBracketsCount = stack.count\n\
    \t\n\tlet openingBracketsString = stack.last!\n\tlet closingBracketsString = stack.last!\n\
    \t\n\tlet openingBracketsStringCount = openingBracketsString.count\n\tlet closingBracketsStringCount\
    \ = closingBracketsString.count\n\t\n\tlet openingBracketsStringLastIndex = openingBracketsString.last!.characters.count\n\
    \tlet closingBracketsStringLastIndex = closingBracketsString.last!.characters.count\n\
    \t\n\tlet openingBracketsStringLastIndexCount = openingBracketsStringLastIndex\n\
    \tlet closingBracketsStringLastIndexCount = closingBracketsStringLastIndex\n\t\
    \n\tlet openingBracketsStringLastIndexLastIndex = openingBracketsStringLastIndex\n\
    \tlet closingBracketsStringLastIndexLastIndex = closingBracketsStringLastIndex\n\
    \t\n\tlet openingBracketsStringLastIndexLastIndexCount = openingBracketsStringLastIndexLastIndex\n\
    \tlet closingBracketsStringLastIndexLastIndexCount = closingBracketsStringLastIndexLastIndex\n\
    \t\n\tlet openingBracketsStringLastIndexLastIndexLastIndexCount = openingBracketsStringLastIndexLastIndexLastIndex\n\
    \tlet closingBracketsStringLastIndexLastIndexLastIndexCount = closingBracketsStringLastIndexLastIndexLastIndex\n\
    \t\n\tlet openingBracketsStringLastIndexLastIndexLastIndexLastIndexCount = openingBracketsStringLastIndexLastIndexLastIndexLastIndex\n\
    \tlet closingBracketsStringLastIndexLastIndexLastIndexLastIndexCount = closingBracketsStringLastIndexLastIndexLastIndexLastIndex\n\
    \t\n\tlet openingBracketsStringLastIndexLastIndexLastIndexLastIndexLastIndexCount\
    \ = openingBracketsStringLastIndexLastIndexLastIndexLastIndexLastIndex\n\tlet\
    \ closingBracketsStringLastIndexLastIndexLastIndexLastIndexCount = closingBracketsStringLastIndexLastIndexLastIndexLastIndex\n\
    \t\n\tlet openingBracketsStringLastIndexLastIndexLastIndexLastIndexLastIndexCount\
    \ = openingBracketsStringLastIndexLastIndexLastIndexLastIndex\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]][[[[[]\") == false)\nassert(is_nested(string: \"[][]\") == false)\n\
    assert(is_nested(string: \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\"\
    ) == true)\nassert(is_nested(string: \"[]]]]]]]]]]\") == false)\nassert(is_nested(string:\
    \ \"[][][[]]\") == true)\nassert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string:\
    \ \"[]]\") == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmpqrvdu1_t.swift:12:14: error: cannot find 'Stack' in scope\n   \
    \     let stack = Stack<String>()\n                    ^~~~~\n/tmp/tmpqrvdu1_t.swift:36:62:\
    \ error: cannot find 'openingBracketsStringLastIndexLastIndexLastIndex' in scope\n\
    \        let openingBracketsStringLastIndexLastIndexLastIndexCount = openingBracketsStringLastIndexLastIndexLastIndex\n\
    \                                                                    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpqrvdu1_t.swift:37:62: error: cannot find 'closingBracketsStringLastIndexLastIndexLastIndex'\
    \ in scope\n        let closingBracketsStringLastIndexLastIndexLastIndexCount\
    \ = closingBracketsStringLastIndexLastIndexLastIndex\n                       \
    \                                             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpqrvdu1_t.swift:39:71: error: cannot find 'openingBracketsStringLastIndexLastIndexLastIndexLastIndex'\
    \ in scope\n        let openingBracketsStringLastIndexLastIndexLastIndexLastIndexCount\
    \ = openingBracketsStringLastIndexLastIndexLastIndexLastIndex\n              \
    \                                                               ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpqrvdu1_t.swift:40:71: error: cannot find 'closingBracketsStringLastIndexLastIndexLastIndexLastIndex'\
    \ in scope\n        let closingBracketsStringLastIndexLastIndexLastIndexLastIndexCount\
    \ = closingBracketsStringLastIndexLastIndexLastIndexLastIndex\n              \
    \                                                               ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpqrvdu1_t.swift:42:80: error: cannot find 'openingBracketsStringLastIndexLastIndexLastIndexLastIndexLastIndex'\
    \ in scope\n        let openingBracketsStringLastIndexLastIndexLastIndexLastIndexLastIndexCount\
    \ = openingBracketsStringLastIndexLastIndexLastIndexLastIndexLastIndex\n     \
    \                                                                            \
    \     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpqrvdu1_t.swift:43"
  stdout: ''
  timestamp: 1660013961
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    func is_nested(string: String) -> Bool {\n    guard let openingBracket = string.rangeOfString(\"\
    [\"),\n        let closingBracket = string.rangeOfString(\"]\") else {\n     \
    \       return false\n    }\n    let openingBracketIndex = string.index(openingBracket,\
    \ offsetBy: 1)\n    let closingBracketIndex = string.index(closingBracket, offsetBy:\
    \ 1)\n    let openingBracketLength = openingBracketIndex.distanceTo(openingBracket)\n\
    \    let closingBracketLength = closingBracketIndex.distanceTo(closingBracket)\n\
    \    let openingBracketsCount = openingBracketLength / 2\n    let closingBracketsCount\
    \ = closingBracketLength / 2\n    let openingBracketsCountInMiddle = openingBracketsCount\
    \ - closingBracketsCount\n    let closingBracketsCountInMiddle = closingBracketsCount\
    \ - openingBracketsCount\n    if openingBracketsCountInMiddle == closingBracketsCountInMiddle\
    \ {\n        return true\n    }\n    return false\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]][[[[[]\") == false)\nassert(is_nested(string: \"[][]\") == false)\n\
    assert(is_nested(string: \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\"\
    ) == true)\nassert(is_nested(string: \"[]]]]]]]]]]\") == false)\nassert(is_nested(string:\
    \ \"[][][[]]\") == true)\nassert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string:\
    \ \"[]]\") == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmpt8_ywbex.swift:12:39: error: value of type 'String' has no member\
    \ 'rangeOfString'\n    guard let openingBracket = string.rangeOfString(\"[\"),\n\
    \                               ~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmpt8_ywbex.swift:13:37:\
    \ error: value of type 'String' has no member 'rangeOfString'\n        let closingBracket\
    \ = string.rangeOfString(\"]\") else {\n                             ~~~~~~ ^~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013961
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    func is_nested(string: String) -> Bool {\n    guard let start = string.index(of:\
    \ \"[\"),\n        let end = string.index(of: \"]\"),\n        start < end else\
    \ { return false }\n    let nested = string.substring(from: start + 1, to: end\
    \ - 1)\n    return nested.characters.count >= 2\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string: \"\
    []]]]]]][[[[[]\") == false)\nassert(is_nested(string: \"[][]\") == false)\nassert(is_nested(string:\
    \ \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]]]]]\") == false)\nassert(is_nested(string: \"[][][[]]\") == true)\n\
    assert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string: \"[]]\"\
    ) == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmpq7rfbgrz.swift:12:30: warning: 'index(of:)' is deprecated: renamed\
    \ to 'firstIndex(of:)'\n    guard let start = string.index(of: \"[\"),\n     \
    \                        ^\n/tmp/tmpq7rfbgrz.swift:12:30: note: use 'firstIndex(of:)'\
    \ instead\n    guard let start = string.index(of: \"[\"),\n                  \
    \           ^~~~~\n                             firstIndex\n/tmp/tmpq7rfbgrz.swift:13:26:\
    \ warning: 'index(of:)' is deprecated: renamed to 'firstIndex(of:)'\n        let\
    \ end = string.index(of: \"]\"),\n                         ^\n/tmp/tmpq7rfbgrz.swift:13:26:\
    \ note: use 'firstIndex(of:)' instead\n        let end = string.index(of: \"]\"\
    ),\n                         ^~~~~\n                         firstIndex\n/tmp/tmpq7rfbgrz.swift:15:47:\
    \ error: binary operator '+' cannot be applied to operands of type 'String.Index'\
    \ and 'Int'\n    let nested = string.substring(from: start + 1, to: end - 1)\n\
    \                                        ~~~~~ ^ ~\n/tmp/tmpq7rfbgrz.swift:15:25:\
    \ error: value of type 'String' has no member 'substring'\n    let nested = string.substring(from:\
    \ start + 1, to: end - 1)\n                 ~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013962
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    func is_nested(string: String) -> Bool {\n    let brackets = string.unicodeScalars\n\
    \        .filter { $0 >= 0x5B && $0 <= 0x5D }\n        .filter { $0 != 0x5D }\n\
    \        .filter { $0 != 0x5C }\n        .filter { $0 != 0x5B }\n        .map\
    \ { String($0) }\n        .reduce(\"\") { $0 + String($1) + String($2) }\n   \
    \ return brackets.rangeOfString(\"[[\", options: .BackwardsSearch) != nil\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]][[[[[]\") == false)\nassert(is_nested(string: \"[][]\") == false)\n\
    assert(is_nested(string: \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\"\
    ) == true)\nassert(is_nested(string: \"[]]]]]]]]]]\") == false)\nassert(is_nested(string:\
    \ \"[][][[]]\") == true)\nassert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string:\
    \ \"[]]\") == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmp97r_ubk8.swift:12:20: error: the compiler is unable to type-check\
    \ this expression in reasonable time; try breaking up the expression into distinct\
    \ sub-expressions\n    let brackets = string.unicodeScalars\n                \
    \   ^~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp97r_ubk8.swift:19:51: error: cannot infer contextual\
    \ base in reference to member 'BackwardsSearch'\n    return brackets.rangeOfString(\"\
    [[\", options: .BackwardsSearch) != nil\n                                    \
    \             ~^~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014025
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    func is_nested(string: String) -> Bool {\n    let brackets = string.unicodeScalars\n\
    \        .filter { $0 != '[' }\n        .filter { $0 != ']' }\n        .filter\
    \ { $0 != '{' }\n        .filter { $0 != '}' }\n        .filter { $0 != '(' }\n\
    \        .filter { $0 != ')' }\n    return brackets.count > 0\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]][[[[[]\") == false)\nassert(is_nested(string: \"[][]\") == false)\n\
    assert(is_nested(string: \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\"\
    ) == true)\nassert(is_nested(string: \"[]]]]]]]]]]\") == false)\nassert(is_nested(string:\
    \ \"[][][[]]\") == true)\nassert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string:\
    \ \"[]]\") == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmp55edippv.swift:13:25: error: single-quoted string literal found,\
    \ use '\"'\n        .filter { $0 != '[' }\n                        ^~~\n     \
    \                   \"[\"\n/tmp/tmp55edippv.swift:14:25: error: single-quoted\
    \ string literal found, use '\"'\n        .filter { $0 != ']' }\n            \
    \            ^~~\n                        \"]\"\n/tmp/tmp55edippv.swift:15:25:\
    \ error: single-quoted string literal found, use '\"'\n        .filter { $0 !=\
    \ '{' }\n                        ^~~\n                        \"{\"\n/tmp/tmp55edippv.swift:16:25:\
    \ error: single-quoted string literal found, use '\"'\n        .filter { $0 !=\
    \ '}' }\n                        ^~~\n                        \"}\"\n/tmp/tmp55edippv.swift:17:25:\
    \ error: single-quoted string literal found, use '\"'\n        .filter { $0 !=\
    \ '(' }\n                        ^~~\n                        \"(\"\n/tmp/tmp55edippv.swift:18:25:\
    \ error: single-quoted string literal found, use '\"'\n        .filter { $0 !=\
    \ ')' }\n                        ^~~\n                        \")\"\n/tmp/tmp55edippv.swift:12:27:\
    \ error: ambiguous use of 'filter'\n    let brackets = string.unicodeScalars\n\
    \                          ^\nSwift.RangeReplaceableCollection:3:40: note: found\
    \ this candidate\n    @inlinable public __consuming func filter(_ isIncluded:\
    \ (Self.Element) throws -> Bool) rethrows -> Self\n                          \
    \             ^\nSwift.Sequence:3:40: note: found this candidate\n    @inlinable\
    \ public __consuming func filter(_ isIncluded: (Self.Element) throws -> Bool)\
    \ rethrows -> [Self.Element]\n                                       ^\n"
  stdout: ''
  timestamp: 1660013962
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    func is_nested(string: String) -> Bool {\n\tlet openBrackets = string.rangeOfString(\"\
    [\")\n\tlet closeBrackets = string.rangeOfString(\"]\")\n\t\n\tif openBrackets\
    \ == nil || closeBrackets == nil {\n\t\treturn false\n\t}\n\t\n\tlet openBracketsCount\
    \ = openBrackets!.location - openBrackets!.startIndex\n\tlet closeBracketsCount\
    \ = closeBrackets!.location - closeBrackets!.startIndex\n\t\n\tif openBracketsCount\
    \ < closeBracketsCount {\n\t\treturn false\n\t}\n\t\n\tlet openBracketsString\
    \ = string.substringWithRange(openBrackets!)\n\tlet closeBracketsString = string.substringWithRange(closeBrackets!)\n\
    \t\n\treturn openBracketsString.rangeOfString(closeBracketsString) != nil\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]][[[[[]\") == false)\nassert(is_nested(string: \"[][]\") == false)\n\
    assert(is_nested(string: \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\"\
    ) == true)\nassert(is_nested(string: \"[]]]]]]]]]]\") == false)\nassert(is_nested(string:\
    \ \"[][][[]]\") == true)\nassert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string:\
    \ \"[]]\") == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmp1z1ywid4.swift:12:28: error: value of type 'String' has no member\
    \ 'rangeOfString'\n        let openBrackets = string.rangeOfString(\"[\")\n  \
    \                         ~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp1z1ywid4.swift:13:29:\
    \ error: value of type 'String' has no member 'rangeOfString'\n        let closeBrackets\
    \ = string.rangeOfString(\"]\")\n                            ~~~~~~ ^~~~~~~~~~~~~\n\
    /tmp/tmp1z1ywid4.swift:26:34: error: value of type 'String' has no member 'substringWithRange'\n\
    \        let openBracketsString = string.substringWithRange(openBrackets!)\n \
    \                                ~~~~~~ ^~~~~~~~~~~~~~~~~~\n/tmp/tmp1z1ywid4.swift:27:35:\
    \ error: value of type 'String' has no member 'substringWithRange'\n        let\
    \ closeBracketsString = string.substringWithRange(closeBrackets!)\n          \
    \                        ~~~~~~ ^~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013962
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    func is_nested(string: String) -> Bool {\n    if string == \"\" {\n        return\
    \ false\n    }\n    var stack = [String]()\n    var openBrackets = 0\n    var\
    \ closeBrackets = 0\n    for char in string {\n        if char == '[' {\n    \
    \        openBrackets += 1\n            stack.append(char)\n        } else if\
    \ char == ']' {\n            closeBrackets += 1\n            if openBrackets >\
    \ closeBrackets {\n                return false\n            }\n            openBrackets\
    \ -= 1\n            stack.removeLast()\n        } else if char == ']' && openBrackets\
    \ == closeBrackets {\n            return true\n        }\n    }\n    return false\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]][[[[[]\") == false)\nassert(is_nested(string: \"[][]\") == false)\n\
    assert(is_nested(string: \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\"\
    ) == true)\nassert(is_nested(string: \"[]]]]]]]]]]\") == false)\nassert(is_nested(string:\
    \ \"[][][[]]\") == true)\nassert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string:\
    \ \"[]]\") == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmp_awrons9.swift:19:20: error: single-quoted string literal found,\
    \ use '\"'\n        if char == '[' {\n                   ^~~\n               \
    \    \"[\"\n/tmp/tmp_awrons9.swift:22:27: error: single-quoted string literal\
    \ found, use '\"'\n        } else if char == ']' {\n                         \
    \ ^~~\n                          \"]\"\n/tmp/tmp_awrons9.swift:29:27: error: single-quoted\
    \ string literal found, use '\"'\n        } else if char == ']' && openBrackets\
    \ == closeBrackets {\n                          ^~~\n                        \
    \  \"]\"\n/tmp/tmp_awrons9.swift:21:26: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n            stack.append(char)\n       \
    \                  ^\n"
  stdout: ''
  timestamp: 1660013962
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    func is_nested(string: String) -> Bool {\n\tlet openBrackets = string.count(\"\
    [\")\n\tlet closeBrackets = string.count(\"]\")\n\t\n\tif openBrackets == closeBrackets\
    \ {\n\t\treturn true\n\t}\n\t\n\treturn false\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string: \"\
    []]]]]]][[[[[]\") == false)\nassert(is_nested(string: \"[][]\") == false)\nassert(is_nested(string:\
    \ \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]]]]]\") == false)\nassert(is_nested(string: \"[][][[]]\") == true)\n\
    assert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string: \"[]]\"\
    ) == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmpewz5nvja.swift:12:28: error: cannot call value of non-function\
    \ type 'Int'\n        let openBrackets = string.count(\"[\")\n               \
    \                   ^\n/tmp/tmpewz5nvja.swift:13:29: error: cannot call value\
    \ of non-function type 'Int'\n        let closeBrackets = string.count(\"]\")\n\
    \                                   ^\n"
  stdout: ''
  timestamp: 1660013962
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    func is_nested(string: String) -> Bool {\n    let stack = Stack()\n    for char\
    \ in string {\n        if char == '[' {\n            stack.push(char)\n      \
    \  } else if char == ']' {\n            if stack.isEmpty {\n                return\
    \ false\n            }\n            let top = stack.top()\n            if top\
    \ != '[' {\n                return false\n            }\n            stack.pop()\n\
    \        } else {\n            return false\n        }\n    }\n    return stack.isEmpty\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]][[[[[]\") == false)\nassert(is_nested(string: \"[][]\") == false)\n\
    assert(is_nested(string: \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\"\
    ) == true)\nassert(is_nested(string: \"[]]]]]]]]]]\") == false)\nassert(is_nested(string:\
    \ \"[][][[]]\") == true)\nassert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string:\
    \ \"[]]\") == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmp2_7hgwmu.swift:14:20: error: single-quoted string literal found,\
    \ use '\"'\n        if char == '[' {\n                   ^~~\n               \
    \    \"[\"\n/tmp/tmp2_7hgwmu.swift:16:27: error: single-quoted string literal\
    \ found, use '\"'\n        } else if char == ']' {\n                         \
    \ ^~~\n                          \"]\"\n/tmp/tmp2_7hgwmu.swift:21:23: error: single-quoted\
    \ string literal found, use '\"'\n            if top != '[' {\n              \
    \        ^~~\n                      \"[\"\n/tmp/tmp2_7hgwmu.swift:12:17: error:\
    \ cannot find 'Stack' in scope\n    let stack = Stack()\n                ^~~~~\n"
  stdout: ''
  timestamp: 1660013962
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    func is_nested(string: String) -> Bool {\n    guard let start = string.index(of:\
    \ \"[\"),\n        let end = string.index(of: \"]\"),\n        start != end,\n\
    \        let start = string.index(of: \"[\", range: start..<end),\n        let\
    \ end = string.index(of: \"]\", range: start..<end),\n        start != end,\n\
    \        let start = string.index(of: \"[\", range: start..<end),\n        let\
    \ end = string.index(of: \"]\", range: start..<end),\n        start != end,\n\
    \        let start = string.index(of: \"[\", range: start..<end),\n        let\
    \ end = string.index(of: \"]\", range: start..<end),\n        start != end,\n\
    \        let start = string.index(of: \"[\", range: start..<end),\n        let\
    \ end = string.index(of: \"]\", range: start..<end),\n        start != end,\n\
    \        let start = string.index(of: \"[\", range: start..<end),\n        let\
    \ end = string.index(of: \"]\", range: start..<end),\n        start != end,\n\
    \        let start = string.index(of: \"[\", range: start..<end),\n        let\
    \ end = string.index(of: \"]\", range: start..<end),\n        start != end,\n\
    \        let start = string.index(of: \"[\", range: start..<end),\n        let\
    \ end = string.index(of: \"]\", range: start..<end),\n        start != end,\n\
    \        let start = string.index(of: \"[\", range: start..<end),\n        let\
    \ end = string.index(of: \"]\", range: start..<end),\n        start != end,\n\
    \        let start = string.index(of: \"[\", range: start..<end),\n        let\
    \ end = string.index(of: \"]\", range: start..<end),\n        start != end,\n\
    \        let start = string.index(of: \"[\", range: start..<end),\n        let\
    \ end = string.index(of: \"]\", range: start..<end),\n        start != end,\n\
    \        let start = string.index(of: \"[\", range: start..<end),\n        let\
    \ end = string.index(of: \"]\", range: start..<end),\n        start != end,\n\
    \        let start = string.index(of: \"[\", range: start..<end),\n        let\
    \ end = string.index(of: \"]\", range: start..<end),\n        start != end,\n\
    \        let start = string.index(of: \"[\", range: start..<end),\n        let\
    \ end = string.index(of: \"]\", range: start..<\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string: \"\
    []]]]]]][[[[[]\") == false)\nassert(is_nested(string: \"[][]\") == false)\nassert(is_nested(string:\
    \ \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]]]]]\") == false)\nassert(is_nested(string: \"[][][[]]\") == true)\n\
    assert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string: \"[]]\"\
    ) == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmp_h3vp2qo.swift:53:1: error: expected ')' in expression list\n}\n\
    ^\n/tmp/tmp_h3vp2qo.swift:52:31: note: to match this opening '('\n        let\
    \ end = string.index(of: \"]\", range: start..<\n                            \
    \  ^\n/tmp/tmp_h3vp2qo.swift:52:56: error: expected 'else' after 'guard' condition\n\
    \        let end = string.index(of: \"]\", range: start..<\n                 \
    \                                      ^\n/tmp/tmp_h3vp2qo.swift:12:30: warning:\
    \ 'index(of:)' is deprecated: renamed to 'firstIndex(of:)'\n    guard let start\
    \ = string.index(of: \"[\"),\n                             ^\n/tmp/tmp_h3vp2qo.swift:12:30:\
    \ note: use 'firstIndex(of:)' instead\n    guard let start = string.index(of:\
    \ \"[\"),\n                             ^~~~~\n                             firstIndex\n\
    /tmp/tmp_h3vp2qo.swift:13:26: warning: 'index(of:)' is deprecated: renamed to\
    \ 'firstIndex(of:)'\n        let end = string.index(of: \"]\"),\n            \
    \             ^\n/tmp/tmp_h3vp2qo.swift:13:26: note: use 'firstIndex(of:)' instead\n\
    \        let end = string.index(of: \"]\"),\n                         ^~~~~\n\
    \                         firstIndex\n/tmp/tmp_h3vp2qo.swift:15:55: error: extra\
    \ argument 'range' in call\n        let start = string.index(of: \"[\", range:\
    \ start..<end),\n                                ~~~~~~~~~~~~~~~~~~~~~~^~~~~~~\n\
    /tmp/tmp_h3vp2qo.swift:16:53: error: extra argument 'range' in call\n        let\
    \ end = string.index(of: \"]\", range: start..<end),\n                       \
    \       ~~~~~~~~~~~~~~~~~~~~~~^~~~~~~\n/tmp/tmp_h3vp2qo.swift:18:55: error: extra\
    \ argument 'range' in call\n        let start = string.index(of: \"[\", range:\
    \ start..<end),\n                                ~~~~~~~~~~~~~~~~~~~~~~^~~~~~~\n\
    /tmp/tmp_h3vp2qo.swift:19:53: error: extra argument 'range' in call\n        let\
    \ end = string.index(of: \"]\", range: start..<end),\n                       \
    \       ~~~~~~~~~~~~~~~~~~~~~~^~~~~~~\n/tmp/tmp_h3vp2qo.swift:21:55: error: extra\
    \ argument 'range' in call\n        let start = string.index(of: \"[\", range:\
    \ start..<end),\n                                ~~~~~~~~~~~~~"
  stdout: ''
  timestamp: 1660013960
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    func is_nested(string: String) -> Bool {\n    guard let start = string.index(of:\
    \ \"[\"),\n        let end = string.index(of: \"]\"),\n        start < end else\
    \ {\n            return false\n    }\n    let start = string.index(before: start)\n\
    \    let end = string.index(before: end)\n    let nested = string[start..<end]\n\
    \    return nested.contains(\"[\")\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string: \"[]]]]]]][[[[[]\"\
    ) == false)\nassert(is_nested(string: \"[][]\") == false)\nassert(is_nested(string:\
    \ \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]]]]]\") == false)\nassert(is_nested(string: \"[][][[]]\") == true)\n\
    assert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string: \"[]]\"\
    ) == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmppq7k1k__.swift:12:30: warning: 'index(of:)' is deprecated: renamed\
    \ to 'firstIndex(of:)'\n    guard let start = string.index(of: \"[\"),\n     \
    \                        ^\n/tmp/tmppq7k1k__.swift:12:30: note: use 'firstIndex(of:)'\
    \ instead\n    guard let start = string.index(of: \"[\"),\n                  \
    \           ^~~~~\n                             firstIndex\n/tmp/tmppq7k1k__.swift:13:26:\
    \ warning: 'index(of:)' is deprecated: renamed to 'firstIndex(of:)'\n        let\
    \ end = string.index(of: \"]\"),\n                         ^\n/tmp/tmppq7k1k__.swift:13:26:\
    \ note: use 'firstIndex(of:)' instead\n        let end = string.index(of: \"]\"\
    ),\n                         ^~~~~\n                         firstIndex\n/tmp/tmppq7k1k__.swift:17:9:\
    \ error: invalid redeclaration of 'start'\n    let start = string.index(before:\
    \ start)\n        ^\n/tmp/tmppq7k1k__.swift:12:15: note: 'start' previously declared\
    \ here\n    guard let start = string.index(of: \"[\"),\n              ^\n/tmp/tmppq7k1k__.swift:18:9:\
    \ error: invalid redeclaration of 'end'\n    let end = string.index(before: end)\n\
    \        ^\n/tmp/tmppq7k1k__.swift:13:13: note: 'end' previously declared here\n\
    \        let end = string.index(of: \"]\"),\n            ^\n"
  stdout: ''
  timestamp: 1660013962
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    func is_nested(string: String) -> Bool {\n    guard let start = string.index(of:\
    \ \"[\"),\n        let end = string.index(of: \"]\"),\n        let start = string.index(of:\
    \ \"[\", range: start...end),\n        let end = string.index(of: \"]\", range:\
    \ start...end),\n        let start = string.index(of: \"[\", range: start..<end),\n\
    \        let end = string.index(of: \"]\", range: start..<end),\n        let start\
    \ = string.index(of: \"[\", range: start..<end),\n        let end = string.index(of:\
    \ \"]\", range: start..<end),\n        let start = string.index(of: \"[\", range:\
    \ start..<end),\n        let end = string.index(of: \"]\", range: start..<end),\n\
    \        let start = string.index(of: \"[\", range: start..<end),\n        let\
    \ end = string.index(of: \"]\", range: start..<end),\n        let start = string.index(of:\
    \ \"[\", range: start..<end),\n        let end = string.index(of: \"]\", range:\
    \ start..<end),\n        let start = string.index(of: \"[\", range: start..<end),\n\
    \        let end = string.index(of: \"]\", range: start..<end),\n        let start\
    \ = string.index(of: \"[\", range: start..<end),\n        let end = string.index(of:\
    \ \"]\", range: start..<end),\n        let start = string.index(of: \"[\", range:\
    \ start..<end),\n        let end = string.index(of: \"]\", range: start..<end),\n\
    \        let start = string.index(of: \"[\", range: start..<end),\n        let\
    \ end = string.index(of: \"]\", range: start..<end),\n        let start = string.index(of:\
    \ \"[\", range: start..<end),\n        let end = string.index(of: \"]\", range:\
    \ start..<end),\n        let start = string.index(of: \"[\", range: start..<end),\n\
    \        let end = string.index(of: \"]\", range: start..<end),\n        let start\
    \ = string.index(of: \"[\", range: start..<end),\n        let end = string.index(of:\
    \ \"]\", range: start..<end),\n        let start = string.index(of: \"[\", range:\
    \ start..<end),\n        let end = string.index(of: \"]\", range: start..<end),\n\
    \        let start = string.index(of: \"[\", range: start..<end),\n        let\
    \ end = string.index(of: \"]\", range: start..<end),\n        let start = string.index(of:\
    \ \"[\", range: start..<\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(is_nested(string:\
    \ \"[[]]\") == true)\nassert(is_nested(string: \"[]]]]]]][[[[[]\") == false)\n\
    assert(is_nested(string: \"[][]\") == false)\nassert(is_nested(string: \"[]\"\
    ) == false)\nassert(is_nested(string: \"[[[[]]]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]]]]]\") == false)\nassert(is_nested(string: \"[][][[]]\") == true)\n\
    assert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string: \"[]]\"\
    ) == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmpu32n90fm.swift:45:1: error: expected ')' in expression list\n}\n\
    ^\n/tmp/tmpu32n90fm.swift:44:33: note: to match this opening '('\n        let\
    \ start = string.index(of: \"[\", range: start..<\n                          \
    \      ^\n/tmp/tmpu32n90fm.swift:44:58: error: expected 'else' after 'guard' condition\n\
    \        let start = string.index(of: \"[\", range: start..<\n               \
    \                                          ^\n/tmp/tmpu32n90fm.swift:12:30: warning:\
    \ 'index(of:)' is deprecated: renamed to 'firstIndex(of:)'\n    guard let start\
    \ = string.index(of: \"[\"),\n                             ^\n/tmp/tmpu32n90fm.swift:12:30:\
    \ note: use 'firstIndex(of:)' instead\n    guard let start = string.index(of:\
    \ \"[\"),\n                             ^~~~~\n                             firstIndex\n\
    /tmp/tmpu32n90fm.swift:13:26: warning: 'index(of:)' is deprecated: renamed to\
    \ 'firstIndex(of:)'\n        let end = string.index(of: \"]\"),\n            \
    \             ^\n/tmp/tmpu32n90fm.swift:13:26: note: use 'firstIndex(of:)' instead\n\
    \        let end = string.index(of: \"]\"),\n                         ^~~~~\n\
    \                         firstIndex\n/tmp/tmpu32n90fm.swift:14:55: error: extra\
    \ argument 'range' in call\n        let start = string.index(of: \"[\", range:\
    \ start...end),\n                                ~~~~~~~~~~~~~~~~~~~~~~^~~~~~~\n\
    /tmp/tmpu32n90fm.swift:15:53: error: extra argument 'range' in call\n        let\
    \ end = string.index(of: \"]\", range: start...end),\n                       \
    \       ~~~~~~~~~~~~~~~~~~~~~~^~~~~~~\n/tmp/tmpu32n90fm.swift:16:55: error: extra\
    \ argument 'range' in call\n        let start = string.index(of: \"[\", range:\
    \ start..<end),\n                                ~~~~~~~~~~~~~~~~~~~~~~^~~~~~~\n\
    /tmp/tmpu32n90fm.swift:17:53: error: extra argument 'range' in call\n        let\
    \ end = string.index(of: \"]\", range: start..<end),\n                       \
    \       ~~~~~~~~~~~~~~~~~~~~~~^~~~~~~\n/tmp/tmpu32n90fm.swift:18:55: error: extra\
    \ argument 'range' in call\n        let start = string.index(of: \"[\", range:\
    \ start..<end),\n                                ~~~~~"
  stdout: ''
  timestamp: 1660013962
- exit_code: -4
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    func is_nested(string: String) -> Bool {\n    \n    // Your code here\n    \n\
    \    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(is_nested(string:\
    \ \"[[]]\") == true)\nassert(is_nested(string: \"[]]]]]]][[[[[]\") == false)\n\
    assert(is_nested(string: \"[][]\") == false)\nassert(is_nested(string: \"[]\"\
    ) == false)\nassert(is_nested(string: \"[[[[]]]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]]]]]\") == false)\nassert(is_nested(string: \"[][][[]]\") == true)\n\
    assert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string: \"[]]\"\
    ) == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: Exception
  stderr: 'tmp4fbozzey/tmp4fbozzey.swift:32: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af698c96c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af69898db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af69898d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af69898c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp4fbozzey                        0x000056101a6522fb <unavailable> + 4859

    5    libc.so.6                          0x00002af698e82460 __libc_start_main +
    245

    6    tmp4fbozzey                        0x000056101a651ee9 <unavailable> + 3817

    '
  stdout: ''
  timestamp: 1660013961
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    func is_nested(string: String) -> Bool {\n    guard let openingBracket = string.firstIndex(of:\
    \ \"[\"),\n        let closingBracket = string.lastIndex(of: \"]\"),\n       \
    \ openingBracket != closingBracket else {\n            return false\n    }\n \
    \   let openingBracketIndex = string.index(string.startIndex, offsetBy: openingBracket)\n\
    \    let closingBracketIndex = string.index(string.startIndex, offsetBy: closingBracket\
    \ + 1)\n    let nestedBrackets = string.substring(from: openingBracketIndex, to:\
    \ closingBracketIndex).count\n    return nestedBrackets > 0\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]][[[[[]\") == false)\nassert(is_nested(string: \"[][]\") == false)\n\
    assert(is_nested(string: \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\"\
    ) == true)\nassert(is_nested(string: \"[]]]]]]]]]]\") == false)\nassert(is_nested(string:\
    \ \"[][][[]]\") == true)\nassert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string:\
    \ \"[]]\") == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmp__3sy24w.swift:17:31: error: instance method 'index(_:offsetBy:)'\
    \ requires that 'String.Index' conform to 'BinaryInteger'\n    let openingBracketIndex\
    \ = string.index(string.startIndex, offsetBy: openingBracket)\n              \
    \                ^\nSwift.Collection:3:17: note: where 'T' = 'String.Index'\n\
    \    public func index<T>(_ i: Self.Index, offsetBy n: T) -> Self.Index where\
    \ T : BinaryInteger\n                ^\n/tmp/tmp__3sy24w.swift:18:73: error: cannot\
    \ convert value of type 'String.Index' to expected argument type 'Int'\n    let\
    \ closingBracketIndex = string.index(string.startIndex, offsetBy: closingBracket\
    \ + 1)\n                                                                     \
    \   ^\n/tmp/tmp__3sy24w.swift:19:33: error: value of type 'String' has no member\
    \ 'substring'\n    let nestedBrackets = string.substring(from: openingBracketIndex,\
    \ to: closingBracketIndex).count\n                         ~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013962
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    func is_nested(string: String) -> Bool {\n    var openingBracketCount = 0\n  \
    \  var closingBracketCount = 0\n    var openingBracketCountStack = [Int]()\n \
    \   var closingBracketCountStack = [Int]()\n    for ch in string {\n        switch\
    \ ch {\n        case '[':\n            openingBracketCountStack.append(openingBracketCount)\n\
    \            openingBracketCount++\n        case ']':\n            closingBracketCountStack.append(closingBracketCount)\n\
    \            closingBracketCount++\n        default:\n            if openingBracketCount\
    \ > 0 && closingBracketCount > 0 {\n                if openingBracketCount > closingBracketCount\
    \ {\n                    return false\n                }\n                if openingBracketCountStack.last\
    \ < closingBracketCountStack.last {\n                    return false\n      \
    \          }\n            }\n        }\n    }\n    return openingBracketCount\
    \ == closingBracketCount\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(is_nested(string:\
    \ \"[[]]\") == true)\nassert(is_nested(string: \"[]]]]]]][[[[[]\") == false)\n\
    assert(is_nested(string: \"[][]\") == false)\nassert(is_nested(string: \"[]\"\
    ) == false)\nassert(is_nested(string: \"[[[[]]]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]]]]]\") == false)\nassert(is_nested(string: \"[][][[]]\") == true)\n\
    assert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string: \"[]]\"\
    ) == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmpextfzq0q.swift:18:14: error: single-quoted string literal found,\
    \ use '\"'\n        case '[':\n             ^~~\n             \"[\"\n/tmp/tmpextfzq0q.swift:21:14:\
    \ error: single-quoted string literal found, use '\"'\n        case ']':\n   \
    \          ^~~\n             \"]\"\n/tmp/tmpextfzq0q.swift:20:32: error: cannot\
    \ find operator '++' in scope; did you mean '+= 1'?\n            openingBracketCount++\n\
    \                               ^~\n/tmp/tmpextfzq0q.swift:23:32: error: cannot\
    \ find operator '++' in scope; did you mean '+= 1'?\n            closingBracketCount++\n\
    \                               ^~\n/tmp/tmpextfzq0q.swift:29:50: error: binary\
    \ operator '<' cannot be applied to two 'Int?' operands\n                if openingBracketCountStack.last\
    \ < closingBracketCountStack.last {\n                   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\
    \ ^ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpextfzq0q.swift:29:50: note: overloads\
    \ for '<' exist with these partially matching parameter lists: (Int, Int)\n  \
    \              if openingBracketCountStack.last < closingBracketCountStack.last\
    \ {\n                                                 ^\n"
  stdout: ''
  timestamp: 1660013962
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    func is_nested(string: String) -> Bool {\n    if string == \"\" {\n        return\
    \ false\n    }\n    var openBrackets = 0\n    var closeBrackets = 0\n    var openBracketsStack\
    \ = [String]()\n    var closeBracketsStack = [String]()\n    for char in string\
    \ {\n        if char == \"[\" {\n            openBracketsStack.append(char)\n\
    \            openBrackets++\n        } else if char == \"]\" {\n            closeBracketsStack.append(char)\n\
    \            closeBrackets++\n        } else if char == \"]\" && openBrackets\
    \ > 0 && closeBrackets == 0 {\n            openBracketsStack.removeLast()\n  \
    \          closeBracketsStack.removeLast()\n            openBrackets--\n     \
    \   } else if char == \"[\" && openBrackets == 0 && closeBrackets > 0 {\n    \
    \        openBracketsStack.removeLast()\n            closeBracketsStack.removeLast()\n\
    \            openBrackets++\n        }\n    }\n    return openBrackets == 0 &&\
    \ closeBrackets == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(is_nested(string:\
    \ \"[[]]\") == true)\nassert(is_nested(string: \"[]]]]]]][[[[[]\") == false)\n\
    assert(is_nested(string: \"[][]\") == false)\nassert(is_nested(string: \"[]\"\
    ) == false)\nassert(is_nested(string: \"[[[[]]]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]]]]]\") == false)\nassert(is_nested(string: \"[][][[]]\") == true)\n\
    assert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string: \"[]]\"\
    ) == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmp8pe_59j2.swift:21:38: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n            openBracketsStack.append(char)\n\
    \                                     ^\n/tmp/tmp8pe_59j2.swift:22:25: error:\
    \ cannot find operator '++' in scope; did you mean '+= 1'?\n            openBrackets++\n\
    \                        ^~\n/tmp/tmp8pe_59j2.swift:24:39: error: cannot convert\
    \ value of type 'Character' to expected argument type 'String'\n            closeBracketsStack.append(char)\n\
    \                                      ^\n/tmp/tmp8pe_59j2.swift:25:26: error:\
    \ cannot find operator '++' in scope; did you mean '+= 1'?\n            closeBrackets++\n\
    \                         ^~\n/tmp/tmp8pe_59j2.swift:29:25: error: cannot find\
    \ operator '--' in scope; did you mean '-= 1'?\n            openBrackets--\n \
    \                       ^~\n/tmp/tmp8pe_59j2.swift:33:25: error: cannot find operator\
    \ '++' in scope; did you mean '+= 1'?\n            openBrackets++\n          \
    \              ^~\n"
  stdout: ''
  timestamp: 1660013962
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    func is_nested(string: String) -> Bool {\n    var stack = [String]()\n    var\
    \ open = 0\n    for idx, char in enumerate(string) {\n        if char == '[' {\n\
    \            open += 1\n            stack.append(char)\n        } else if char\
    \ == ']' {\n            open -= 1\n            if open == 0 {\n              \
    \  stack.removeLast()\n            }\n        }\n    }\n    return open > 0\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]][[[[[]\") == false)\nassert(is_nested(string: \"[][]\") == false)\n\
    assert(is_nested(string: \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\"\
    ) == true)\nassert(is_nested(string: \"[]]]]]]]]]]\") == false)\nassert(is_nested(string:\
    \ \"[][][[]]\") == true)\nassert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string:\
    \ \"[]]\") == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmpreizsuin.swift:14:12: error: expected 'in' after for-each pattern\n\
    \    for idx, char in enumerate(string) {\n           ^\n/tmp/tmpreizsuin.swift:14:12:\
    \ error: expected Sequence expression for for-each loop\n    for idx, char in\
    \ enumerate(string) {\n           ^\n/tmp/tmpreizsuin.swift:15:20: error: single-quoted\
    \ string literal found, use '\"'\n        if char == '[' {\n                 \
    \  ^~~\n                   \"[\"\n/tmp/tmpreizsuin.swift:18:27: error: single-quoted\
    \ string literal found, use '\"'\n        } else if char == ']' {\n          \
    \                ^~~\n                          \"]\"\n"
  stdout: ''
  timestamp: 1660013962
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    func is_nested(string: String) -> Bool {\n    guard let pattern = try? NSRegularExpression(pattern:\
    \ \"\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\\
    [\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\
    \\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\\
    [\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\
    \\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\\
    [\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\
    \\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\\
    [\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\
    \\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\\
    [\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\
    \\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\\
    [\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\
    \\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\\
    [\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\
    \\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\\
    [\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\
    \\[\\\\[\\\\\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(is_nested(string:\
    \ \"[[]]\") == true)\nassert(is_nested(string: \"[]]]]]]][[[[[]\") == false)\n\
    assert(is_nested(string: \"[][]\") == false)\nassert(is_nested(string: \"[]\"\
    ) == false)\nassert(is_nested(string: \"[[[[]]]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]]]]]\") == false)\nassert(is_nested(string: \"[][][[]]\") == true)\n\
    assert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string: \"[]]\"\
    ) == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmp_uad5ls4.swift:12:59: error: unterminated string literal\n    guard\
    \ let pattern = try? NSRegularExpression(pattern: \"\\\\[\\\\[\\\\[\\\\[\\\\[\\\
    \\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\\
    [\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\
    \\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\\
    [\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\
    \\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\\
    [\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\
    \\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\\
    [\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\
    \\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\\
    [\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\
    \\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\\
    [\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\
    \\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\\
    [\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\
    \\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\\
    [\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\\n               \
    \                                           ^\n/tmp/tmp_uad5ls4.swift:12:809:\
    \ error: expected 'else' after 'guard' condition\n    guard let pattern = try?\
    \ NSRegularExpression(pattern: \"\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\\
    [\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\
    \\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\\
    [\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\
    \\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\\
    [\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\
    \\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\\
    [\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\
    \\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\\
    [\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\
    \\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\\
    [\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\
    \\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\\
    [\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\
    \\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\\
    [\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\
    \\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\[\\\\\n                                 \
    \                                                                            \
    \                                                                            \
    \                                          "
  stdout: ''
  timestamp: 1660013962
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    func is_nested(string: String) -> Bool {\n    guard let openBracket = string.index(of:\
    \ \"[\"),\n        let closeBracket = string.index(of: \"]\"),\n        openBracket\
    \ < closeBracket else { return false }\n    \n    var openBracketCount = 0\n \
    \   var closeBracketCount = 0\n    \n    for index in string.indices {\n     \
    \   guard let character = string[index],\n            character == \"[\" else\
    \ { continue }\n        openBracketCount += 1\n        \n        guard let nextIndex\
    \ = string.index(index, offsetBy: 1),\n            string[nextIndex] == \"]\"\
    \ else { continue }\n        closeBracketCount += 1\n    }\n    \n    return openBracketCount\
    \ == closeBracketCount\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(is_nested(string:\
    \ \"[[]]\") == true)\nassert(is_nested(string: \"[]]]]]]][[[[[]\") == false)\n\
    assert(is_nested(string: \"[][]\") == false)\nassert(is_nested(string: \"[]\"\
    ) == false)\nassert(is_nested(string: \"[[[[]]]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]]]]]\") == false)\nassert(is_nested(string: \"[][][[]]\") == true)\n\
    assert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string: \"[]]\"\
    ) == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmpgpct8td0.swift:12:36: warning: 'index(of:)' is deprecated: renamed\
    \ to 'firstIndex(of:)'\n    guard let openBracket = string.index(of: \"[\"),\n\
    \                                   ^\n/tmp/tmpgpct8td0.swift:12:36: note: use\
    \ 'firstIndex(of:)' instead\n    guard let openBracket = string.index(of: \"[\"\
    ),\n                                   ^~~~~\n                               \
    \    firstIndex\n/tmp/tmpgpct8td0.swift:13:35: warning: 'index(of:)' is deprecated:\
    \ renamed to 'firstIndex(of:)'\n        let closeBracket = string.index(of: \"\
    ]\"),\n                                  ^\n/tmp/tmpgpct8td0.swift:13:35: note:\
    \ use 'firstIndex(of:)' instead\n        let closeBracket = string.index(of: \"\
    ]\"),\n                                  ^~~~~\n                             \
    \     firstIndex\n/tmp/tmpgpct8td0.swift:20:15: error: initializer for conditional\
    \ binding must have Optional type, not 'Character'\n        guard let character\
    \ = string[index],\n              ^               ~~~~~~~~~~~~~\n/tmp/tmpgpct8td0.swift:24:15:\
    \ error: initializer for conditional binding must have Optional type, not 'String.Index'\n\
    \        guard let nextIndex = string.index(index, offsetBy: 1),\n           \
    \   ^               ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013962
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    func is_nested(string: String) -> Bool {\n    var stack = [String]()\n    var\
    \ open = 0\n    var close = 0\n    for i := 0; i < len(string); i++ {\n      \
    \  if string[i] == '[' {\n            stack.append(string[i])\n            open++\n\
    \        } else if string[i] == ']' {\n            close++\n            if close\
    \ == open {\n                stack.removeLast()\n            }\n        } else\
    \ if string[i] == '[' {\n            open++\n        } else if string[i] == ']'\
    \ {\n            close++\n        }\n    }\n    return stack.isEmpty\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]][[[[[]\") == false)\nassert(is_nested(string: \"[][]\") == false)\n\
    assert(is_nested(string: \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\"\
    ) == true)\nassert(is_nested(string: \"[]]]]]]]]]]\") == false)\nassert(is_nested(string:\
    \ \"[][][[]]\") == true)\nassert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string:\
    \ \"[]]\") == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmpukxdrsdh.swift:15:12: error: expected type\n    for i := 0; i <\
    \ len(string); i++ {\n           ^\n            <#type#>\n/tmp/tmpukxdrsdh.swift:15:12:\
    \ error: expected 'in' after for-each pattern\n    for i := 0; i < len(string);\
    \ i++ {\n           ^\n/tmp/tmpukxdrsdh.swift:15:12: error: expected Sequence\
    \ expression for for-each loop\n    for i := 0; i < len(string); i++ {\n     \
    \      ^\n/tmp/tmpukxdrsdh.swift:16:25: error: single-quoted string literal found,\
    \ use '\"'\n        if string[i] == '[' {\n                        ^~~\n     \
    \                   \"[\"\n/tmp/tmpukxdrsdh.swift:19:32: error: single-quoted\
    \ string literal found, use '\"'\n        } else if string[i] == ']' {\n     \
    \                          ^~~\n                               \"]\"\n/tmp/tmpukxdrsdh.swift:24:32:\
    \ error: single-quoted string literal found, use '\"'\n        } else if string[i]\
    \ == '[' {\n                               ^~~\n                             \
    \  \"[\"\n/tmp/tmpukxdrsdh.swift:26:32: error: single-quoted string literal found,\
    \ use '\"'\n        } else if string[i] == ']' {\n                           \
    \    ^~~\n                               \"]\"\n"
  stdout: ''
  timestamp: 1660013962
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    func is_nested(string: String) -> Bool {\n    let brackets = string.unicodeScalars\n\
    \        .filter { $0 != '[' }\n        .filter { $0 != ']' }\n        .filter\
    \ { $0 != '{' }\n        .filter { $0 != '}' }\n        .filter { $0 != '(' }\n\
    \        .filter { $0 != ')' }\n    return brackets.count > 0\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]][[[[[]\") == false)\nassert(is_nested(string: \"[][]\") == false)\n\
    assert(is_nested(string: \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\"\
    ) == true)\nassert(is_nested(string: \"[]]]]]]]]]]\") == false)\nassert(is_nested(string:\
    \ \"[][][[]]\") == true)\nassert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string:\
    \ \"[]]\") == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmp55edippv.swift:13:25: error: single-quoted string literal found,\
    \ use '\"'\n        .filter { $0 != '[' }\n                        ^~~\n     \
    \                   \"[\"\n/tmp/tmp55edippv.swift:14:25: error: single-quoted\
    \ string literal found, use '\"'\n        .filter { $0 != ']' }\n            \
    \            ^~~\n                        \"]\"\n/tmp/tmp55edippv.swift:15:25:\
    \ error: single-quoted string literal found, use '\"'\n        .filter { $0 !=\
    \ '{' }\n                        ^~~\n                        \"{\"\n/tmp/tmp55edippv.swift:16:25:\
    \ error: single-quoted string literal found, use '\"'\n        .filter { $0 !=\
    \ '}' }\n                        ^~~\n                        \"}\"\n/tmp/tmp55edippv.swift:17:25:\
    \ error: single-quoted string literal found, use '\"'\n        .filter { $0 !=\
    \ '(' }\n                        ^~~\n                        \"(\"\n/tmp/tmp55edippv.swift:18:25:\
    \ error: single-quoted string literal found, use '\"'\n        .filter { $0 !=\
    \ ')' }\n                        ^~~\n                        \")\"\n/tmp/tmp55edippv.swift:12:27:\
    \ error: ambiguous use of 'filter'\n    let brackets = string.unicodeScalars\n\
    \                          ^\nSwift.RangeReplaceableCollection:3:40: note: found\
    \ this candidate\n    @inlinable public __consuming func filter(_ isIncluded:\
    \ (Self.Element) throws -> Bool) rethrows -> Self\n                          \
    \             ^\nSwift.Sequence:3:40: note: found this candidate\n    @inlinable\
    \ public __consuming func filter(_ isIncluded: (Self.Element) throws -> Bool)\
    \ rethrows -> [Self.Element]\n                                       ^\n"
  stdout: ''
  timestamp: 1660013962
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    func is_nested(string: String) -> Bool {\n    guard let start = string.index(of:\
    \ \"[\"),\n        let end = string.index(of: \"]\"),\n        let start = string.index(of:\
    \ \"[\", range: start..<end),\n        let end = string.index(of: \"]\", range:\
    \ start..<end),\n        let start = string.index(of: \"[\", range: start..<end),\n\
    \        let end = string.index(of: \"]\", range: start..<end),\n        let start\
    \ = string.index(of: \"[\", range: start..<end),\n        let end = string.index(of:\
    \ \"]\", range: start..<end),\n        let start = string.index(of: \"[\", range:\
    \ start..<end),\n        let end = string.index(of: \"]\", range: start..<end),\n\
    \        let start = string.index(of: \"[\", range: start..<end),\n        let\
    \ end = string.index(of: \"]\", range: start..<end),\n        let start = string.index(of:\
    \ \"[\", range: start..<end),\n        let end = string.index(of: \"]\", range:\
    \ start..<end),\n        let start = string.index(of: \"[\", range: start..<end),\n\
    \        let end = string.index(of: \"]\", range: start..<end),\n        let start\
    \ = string.index(of: \"[\", range: start..<end),\n        let end = string.index(of:\
    \ \"]\", range: start..<end),\n        let start = string.index(of: \"[\", range:\
    \ start..<end),\n        let end = string.index(of: \"]\", range: start..<end),\n\
    \        let start = string.index(of: \"[\", range: start..<end),\n        let\
    \ end = string.index(of: \"]\", range: start..<end),\n        let start = string.index(of:\
    \ \"[\", range: start..<end),\n        let end = string.index(of: \"]\", range:\
    \ start..<end),\n        let start = string.index(of: \"[\", range: start..<end),\n\
    \        let end = string.index(of: \"]\", range: start..<end),\n        let start\
    \ = string.index(of: \"[\", range: start..<end),\n        let end = string.index(of:\
    \ \"]\", range: start..<end),\n        let start = string.index(of: \"[\", range:\
    \ start..<end),\n        let end = string.index(of: \"]\", range: start..<end),\n\
    \        let start = string.index(of: \"[\", range: start..<end),\n        let\
    \ end = string.index(of: \"]\", range: start..<end),\n        let start = string.index(of:\
    \ \"[\", range: start.\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(is_nested(string:\
    \ \"[[]]\") == true)\nassert(is_nested(string: \"[]]]]]]][[[[[]\") == false)\n\
    assert(is_nested(string: \"[][]\") == false)\nassert(is_nested(string: \"[]\"\
    ) == false)\nassert(is_nested(string: \"[[[[]]]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]]]]]\") == false)\nassert(is_nested(string: \"[][][[]]\") == true)\n\
    assert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string: \"[]]\"\
    ) == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmpwmsls8_p.swift:44:55: error: expected member name following '.'\n\
    \        let start = string.index(of: \"[\", range: start.\n                 \
    \                                     ^\n/tmp/tmpwmsls8_p.swift:45:1: error: expected\
    \ ')' in expression list\n}\n^\n/tmp/tmpwmsls8_p.swift:44:33: note: to match this\
    \ opening '('\n        let start = string.index(of: \"[\", range: start.\n   \
    \                             ^\n/tmp/tmpwmsls8_p.swift:44:56: error: expected\
    \ 'else' after 'guard' condition\n        let start = string.index(of: \"[\",\
    \ range: start.\n                                                       ^\n/tmp/tmpwmsls8_p.swift:12:30:\
    \ warning: 'index(of:)' is deprecated: renamed to 'firstIndex(of:)'\n    guard\
    \ let start = string.index(of: \"[\"),\n                             ^\n/tmp/tmpwmsls8_p.swift:12:30:\
    \ note: use 'firstIndex(of:)' instead\n    guard let start = string.index(of:\
    \ \"[\"),\n                             ^~~~~\n                             firstIndex\n\
    /tmp/tmpwmsls8_p.swift:13:26: warning: 'index(of:)' is deprecated: renamed to\
    \ 'firstIndex(of:)'\n        let end = string.index(of: \"]\"),\n            \
    \             ^\n/tmp/tmpwmsls8_p.swift:13:26: note: use 'firstIndex(of:)' instead\n\
    \        let end = string.index(of: \"]\"),\n                         ^~~~~\n\
    \                         firstIndex\n/tmp/tmpwmsls8_p.swift:14:55: error: extra\
    \ argument 'range' in call\n        let start = string.index(of: \"[\", range:\
    \ start..<end),\n                                ~~~~~~~~~~~~~~~~~~~~~~^~~~~~~\n\
    /tmp/tmpwmsls8_p.swift:15:53: error: extra argument 'range' in call\n        let\
    \ end = string.index(of: \"]\", range: start..<end),\n                       \
    \       ~~~~~~~~~~~~~~~~~~~~~~^~~~~~~\n/tmp/tmpwmsls8_p.swift:16:55: error: extra\
    \ argument 'range' in call\n        let start = string.index(of: \"[\", range:\
    \ start..<end),\n                                ~~~~~~~~~~~~~~~~~~~~~~^~~~~~~\n\
    /tmp/tmpwmsls8_p.swift:17:53: error: extra argument 'range' in call\n        let\
    \ end = string.index(of: \"]\", range: start..<end),\n                       \
    \       ~~~~~~~~~~~~~~~~~~~~"
  stdout: ''
  timestamp: 1660013961
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    func is_nested(string: String) -> Bool {\n    guard let openingBracket = string.rangeOfString(\"\
    [\", options: .LiteralSearch, range: nil, locale: nil) else {\n        return\
    \ false\n    }\n    guard let closingBracket = string.rangeOfString(\"]\", options:\
    \ .LiteralSearch, range: nil, locale: nil) else {\n        return false\n    }\n\
    \    guard let openingBracketIndex = string.index(of: openingBracket, options:\
    \ .LiteralSearch, range: nil, locale: nil) else {\n        return false\n    }\n\
    \    guard let closingBracketIndex = string.index(of: closingBracket, options:\
    \ .LiteralSearch, range: nil, locale: nil) else {\n        return false\n    }\n\
    \    guard openingBracketIndex != closingBracketIndex else {\n        return false\n\
    \    }\n    guard openingBracketIndex < closingBracketIndex else {\n        return\
    \ false\n    }\n    guard let openingBracket = string.substring(from: openingBracketIndex,\
    \ length: openingBracketIndex - openingBracketIndex + 1) else {\n        return\
    \ false\n    }\n    guard let closingBracket = string.substring(from: closingBracketIndex,\
    \ length: closingBracketIndex - openingBracketIndex + 1) else {\n        return\
    \ false\n    }\n    guard openingBracket == \"[\" else {\n        return false\n\
    \    }\n    guard closingBracket == \"]\" else {\n        return false\n    }\n\
    \    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(is_nested(string:\
    \ \"[[]]\") == true)\nassert(is_nested(string: \"[]]]]]]][[[[[]\") == false)\n\
    assert(is_nested(string: \"[][]\") == false)\nassert(is_nested(string: \"[]\"\
    ) == false)\nassert(is_nested(string: \"[[[[]]]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]]]]]\") == false)\nassert(is_nested(string: \"[][][[]]\") == true)\n\
    assert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string: \"[]]\"\
    ) == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmpvsfu2wjy.swift:12:39: error: value of type 'String' has no member\
    \ 'rangeOfString'\n    guard let openingBracket = string.rangeOfString(\"[\",\
    \ options: .LiteralSearch, range: nil, locale: nil) else {\n                 \
    \              ~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmpvsfu2wjy.swift:12:68: error: cannot\
    \ infer contextual base in reference to member 'LiteralSearch'\n    guard let\
    \ openingBracket = string.rangeOfString(\"[\", options: .LiteralSearch, range:\
    \ nil, locale: nil) else {\n                                                 \
    \                 ~^~~~~~~~~~~~~\n/tmp/tmpvsfu2wjy.swift:12:90: error: 'nil' requires\
    \ a contextual type\n    guard let openingBracket = string.rangeOfString(\"[\"\
    , options: .LiteralSearch, range: nil, locale: nil) else {\n                 \
    \                                                                        ^\n/tmp/tmpvsfu2wjy.swift:12:103:\
    \ error: 'nil' requires a contextual type\n    guard let openingBracket = string.rangeOfString(\"\
    [\", options: .LiteralSearch, range: nil, locale: nil) else {\n              \
    \                                                                            \
    \            ^\n/tmp/tmpvsfu2wjy.swift:15:39: error: value of type 'String' has\
    \ no member 'rangeOfString'\n    guard let closingBracket = string.rangeOfString(\"\
    ]\", options: .LiteralSearch, range: nil, locale: nil) else {\n              \
    \                 ~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmpvsfu2wjy.swift:15:68: error: cannot\
    \ infer contextual base in reference to member 'LiteralSearch'\n    guard let\
    \ closingBracket = string.rangeOfString(\"]\", options: .LiteralSearch, range:\
    \ nil, locale: nil) else {\n                                                 \
    \                 ~^~~~~~~~~~~~~\n/tmp/tmpvsfu2wjy.swift:15:90: error: 'nil' requires\
    \ a contextual type\n    guard let closingBracket = string.rangeOfString(\"]\"\
    , options: .LiteralSearch, range: nil, locale: nil) else {\n                 \
    \                                                                        ^\n/tmp/tmpvsfu2wjy.swift:15:103:\
    \ error: 'nil' requires a contextual type\n    guard let closingBrack"
  stdout: ''
  timestamp: 1660013962
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    func is_nested(string: String) -> Bool {\n    \n    let stack = Stack()\n    \n\
    \    for char in string {\n        \n        if char == '[' {\n            stack.push(char)\n\
    \        } else if char == ']' {\n            if stack.top() == '[' {\n      \
    \          stack.pop()\n            } else {\n                return false\n \
    \           }\n        }\n    }\n    \n    return stack.empty()\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]][[[[[]\") == false)\nassert(is_nested(string: \"[][]\") == false)\n\
    assert(is_nested(string: \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\"\
    ) == true)\nassert(is_nested(string: \"[]]]]]]]]]]\") == false)\nassert(is_nested(string:\
    \ \"[][][[]]\") == true)\nassert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string:\
    \ \"[]]\") == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmp1p9tozd1.swift:17:20: error: single-quoted string literal found,\
    \ use '\"'\n        if char == '[' {\n                   ^~~\n               \
    \    \"[\"\n/tmp/tmp1p9tozd1.swift:19:27: error: single-quoted string literal\
    \ found, use '\"'\n        } else if char == ']' {\n                         \
    \ ^~~\n                          \"]\"\n/tmp/tmp1p9tozd1.swift:20:31: error: single-quoted\
    \ string literal found, use '\"'\n            if stack.top() == '[' {\n      \
    \                        ^~~\n                              \"[\"\n/tmp/tmp1p9tozd1.swift:13:17:\
    \ error: cannot find 'Stack' in scope\n    let stack = Stack()\n             \
    \   ^~~~~\n"
  stdout: ''
  timestamp: 1660013962
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    func is_nested(string: String) -> Bool {\n    var stack = [String]()\n    var\
    \ openBrackets = 0\n    var closeBrackets = 0\n    var openBracketsCount = 0\n\
    \    var closeBracketsCount = 0\n    for char in string {\n        if char ==\
    \ '[' {\n            openBracketsCount += 1\n            stack.append(char)\n\
    \        } else if char == ']' {\n            closeBracketsCount += 1\n      \
    \      if openBracketsCount == closeBracketsCount {\n                if openBrackets\
    \ == closeBrackets {\n                    return true\n                }\n   \
    \             openBracketsCount -= 1\n                closeBracketsCount -= 1\n\
    \                openBrackets -= 1\n                closeBrackets += 1\n     \
    \       } else {\n                openBracketsCount -= 1\n            }\n    \
    \        stack.removeLast()\n        } else if char == '[' {\n            openBrackets\
    \ += 1\n        } else if char == ']' {\n            closeBrackets += 1\n    \
    \    }\n    }\n    return false\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(is_nested(string:\
    \ \"[[]]\") == true)\nassert(is_nested(string: \"[]]]]]]][[[[[]\") == false)\n\
    assert(is_nested(string: \"[][]\") == false)\nassert(is_nested(string: \"[]\"\
    ) == false)\nassert(is_nested(string: \"[[[[]]]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]]]]]\") == false)\nassert(is_nested(string: \"[][][[]]\") == true)\n\
    assert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string: \"[]]\"\
    ) == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmp7roy_ezw.swift:18:20: error: single-quoted string literal found,\
    \ use '\"'\n        if char == '[' {\n                   ^~~\n               \
    \    \"[\"\n/tmp/tmp7roy_ezw.swift:21:27: error: single-quoted string literal\
    \ found, use '\"'\n        } else if char == ']' {\n                         \
    \ ^~~\n                          \"]\"\n/tmp/tmp7roy_ezw.swift:35:27: error: single-quoted\
    \ string literal found, use '\"'\n        } else if char == '[' {\n          \
    \                ^~~\n                          \"[\"\n/tmp/tmp7roy_ezw.swift:37:27:\
    \ error: single-quoted string literal found, use '\"'\n        } else if char\
    \ == ']' {\n                          ^~~\n                          \"]\"\n/tmp/tmp7roy_ezw.swift:20:26:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            stack.append(char)\n                         ^\n"
  stdout: ''
  timestamp: 1660013962
- exit_code: -4
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    func is_nested(string: String) -> Bool {\n    \n    // Your code here\n    \n\
    \    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(is_nested(string:\
    \ \"[[]]\") == true)\nassert(is_nested(string: \"[]]]]]]][[[[[]\") == false)\n\
    assert(is_nested(string: \"[][]\") == false)\nassert(is_nested(string: \"[]\"\
    ) == false)\nassert(is_nested(string: \"[[[[]]]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]]]]]\") == false)\nassert(is_nested(string: \"[][][[]]\") == true)\n\
    assert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string: \"[]]\"\
    ) == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: Exception
  stderr: 'tmp4fbozzey/tmp4fbozzey.swift:32: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af698c96c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af69898db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af69898d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af69898c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp4fbozzey                        0x000056101a6522fb <unavailable> + 4859

    5    libc.so.6                          0x00002af698e82460 __libc_start_main +
    245

    6    tmp4fbozzey                        0x000056101a651ee9 <unavailable> + 3817

    '
  stdout: ''
  timestamp: 1660013961
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    func is_nested(string: String) -> Bool {\n    guard let openingBracket = string.rangeOfString(\"\
    [\", options: .BackwardsSearch) else {\n        return false\n    }\n    guard\
    \ let closingBracket = string.rangeOfString(\"]\", options: .BackwardsSearch)\
    \ else {\n        return false\n    }\n    guard openingBracket.location < closingBracket.location\
    \ else {\n        return false\n    }\n    guard openingBracket.location > 0 else\
    \ {\n        return false\n    }\n    guard closingBracket.location < string.characters.count\
    \ else {\n        return false\n    }\n    guard closingBracket.location > openingBracket.location\
    \ else {\n        return false\n    }\n    guard let openingBracketIndex = string.characters.index(of:\
    \ openingBracket.character) else {\n        return false\n    }\n    guard let\
    \ closingBracketIndex = string.characters.index(of: closingBracket.character)\
    \ else {\n        return false\n    }\n    guard openingBracketIndex < closingBracketIndex\
    \ else {\n        return false\n    }\n    guard openingBracketIndex < string.characters.count\
    \ - 1 else {\n        return false\n    }\n    guard let openingBracket = string.characters[openingBracketIndex\
    \ + 1] else {\n        return false\n    }\n    guard let closingBracket = string.characters[closingBracketIndex\
    \ - 1] else {\n        return false\n    }\n    guard openingBracket == \"[\"\
    \ && closingBracket == \"]\" else {\n        return false\n    }\n    return true\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]][[[[[]\") == false)\nassert(is_nested(string: \"[][]\") == false)\n\
    assert(is_nested(string: \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\"\
    ) == true)\nassert(is_nested(string: \"[]]]]]]]]]]\") == false)\nassert(is_nested(string:\
    \ \"[][][[]]\") == true)\nassert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string:\
    \ \"[]]\") == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmpnnzqual8.swift:12:39: error: value of type 'String' has no member\
    \ 'rangeOfString'\n    guard let openingBracket = string.rangeOfString(\"[\",\
    \ options: .BackwardsSearch) else {\n                               ~~~~~~ ^~~~~~~~~~~~~\n\
    /tmp/tmpnnzqual8.swift:12:68: error: cannot infer contextual base in reference\
    \ to member 'BackwardsSearch'\n    guard let openingBracket = string.rangeOfString(\"\
    [\", options: .BackwardsSearch) else {\n                                     \
    \                             ~^~~~~~~~~~~~~~~\n/tmp/tmpnnzqual8.swift:15:39:\
    \ error: value of type 'String' has no member 'rangeOfString'\n    guard let closingBracket\
    \ = string.rangeOfString(\"]\", options: .BackwardsSearch) else {\n          \
    \                     ~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmpnnzqual8.swift:15:68: error:\
    \ cannot infer contextual base in reference to member 'BackwardsSearch'\n    guard\
    \ let closingBracket = string.rangeOfString(\"]\", options: .BackwardsSearch)\
    \ else {\n                                                                  ~^~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013962
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    func is_nested(string: String) -> Bool {\n    let stack = Stack()\n    for char\
    \ in string {\n        if char == '[' {\n            stack.push(char)\n      \
    \  } else if char == ']' {\n            if stack.top() == '[' {\n            \
    \    stack.pop()\n            } else {\n                return false\n       \
    \     }\n        } else {\n            return false\n        }\n    }\n    return\
    \ stack.empty()\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(is_nested(string:\
    \ \"[[]]\") == true)\nassert(is_nested(string: \"[]]]]]]][[[[[]\") == false)\n\
    assert(is_nested(string: \"[][]\") == false)\nassert(is_nested(string: \"[]\"\
    ) == false)\nassert(is_nested(string: \"[[[[]]]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]]]]]\") == false)\nassert(is_nested(string: \"[][][[]]\") == true)\n\
    assert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string: \"[]]\"\
    ) == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmpghzat_c6.swift:14:20: error: single-quoted string literal found,\
    \ use '\"'\n        if char == '[' {\n                   ^~~\n               \
    \    \"[\"\n/tmp/tmpghzat_c6.swift:16:27: error: single-quoted string literal\
    \ found, use '\"'\n        } else if char == ']' {\n                         \
    \ ^~~\n                          \"]\"\n/tmp/tmpghzat_c6.swift:17:31: error: single-quoted\
    \ string literal found, use '\"'\n            if stack.top() == '[' {\n      \
    \                        ^~~\n                              \"[\"\n/tmp/tmpghzat_c6.swift:12:17:\
    \ error: cannot find 'Stack' in scope\n    let stack = Stack()\n             \
    \   ^~~~~\n"
  stdout: ''
  timestamp: 1660013960
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    func is_nested(string: String) -> Bool {\n    guard let start = string.index(of:\
    \ \"[\"),\n        let end = string.index(of: \"]\"),\n        start < end else\
    \ { return false }\n    var open = 0\n    var close = 0\n    var nesting = 0\n\
    \    for index in string.indices {\n        if string[index] == \"]\" {\n    \
    \        close--\n            if close < 0 {\n                nesting++\n    \
    \            close = open\n            }\n        } else if string[index] == \"\
    [\" {\n            open++\n            if open < 0 {\n                nesting++\n\
    \                open = close\n            }\n        }\n    }\n    return nesting\
    \ > 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(is_nested(string: \"[[]]\"\
    ) == true)\nassert(is_nested(string: \"[]]]]]]][[[[[]\") == false)\nassert(is_nested(string:\
    \ \"[][]\") == false)\nassert(is_nested(string: \"[]\") == false)\nassert(is_nested(string:\
    \ \"[[[[]]]]\") == true)\nassert(is_nested(string: \"[]]]]]]]]]]\") == false)\n\
    assert(is_nested(string: \"[][][[]]\") == true)\nassert(is_nested(string: \"[[]\"\
    ) == false)\nassert(is_nested(string: \"[]]\") == false)\nassert(is_nested(string:\
    \ \"[[]][[\") == true)\nassert(is_nested(string: \"[[][]]\") == true)\nassert(is_nested(string:\
    \ \"\") == false)\nassert(is_nested(string: \"[[[[[[[[\") == false)\nassert(is_nested(string:\
    \ \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmp0copl4gq.swift:12:30: warning: 'index(of:)' is deprecated: renamed\
    \ to 'firstIndex(of:)'\n    guard let start = string.index(of: \"[\"),\n     \
    \                        ^\n/tmp/tmp0copl4gq.swift:12:30: note: use 'firstIndex(of:)'\
    \ instead\n    guard let start = string.index(of: \"[\"),\n                  \
    \           ^~~~~\n                             firstIndex\n/tmp/tmp0copl4gq.swift:13:26:\
    \ warning: 'index(of:)' is deprecated: renamed to 'firstIndex(of:)'\n        let\
    \ end = string.index(of: \"]\"),\n                         ^\n/tmp/tmp0copl4gq.swift:13:26:\
    \ note: use 'firstIndex(of:)' instead\n        let end = string.index(of: \"]\"\
    ),\n                         ^~~~~\n                         firstIndex\n/tmp/tmp0copl4gq.swift:20:18:\
    \ error: cannot find operator '--' in scope; did you mean '-= 1'?\n          \
    \  close--\n                 ^~\n/tmp/tmp0copl4gq.swift:22:24: error: cannot find\
    \ operator '++' in scope; did you mean '+= 1'?\n                nesting++\n  \
    \                     ^~\n/tmp/tmp0copl4gq.swift:26:17: error: cannot find operator\
    \ '++' in scope; did you mean '+= 1'?\n            open++\n                ^~\n\
    /tmp/tmp0copl4gq.swift:28:24: error: cannot find operator '++' in scope; did you\
    \ mean '+= 1'?\n                nesting++\n                       ^~\n"
  stdout: ''
  timestamp: 1660013962
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    func is_nested(string: String) -> Bool {\n    var stack = [String]()\n    var\
    \ openingBrackets = 0\n    for char in string {\n        if char == '[' {\n  \
    \          stack.append(char)\n            openingBrackets += 1\n        } else\
    \ if char == ']' {\n            if openingBrackets > 0 {\n                openingBrackets\
    \ -= 1\n            } else {\n                return false\n            }\n  \
    \      }\n    }\n    return openingBrackets == 0\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]][[[[[]\") == false)\nassert(is_nested(string: \"[][]\") == false)\n\
    assert(is_nested(string: \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\"\
    ) == true)\nassert(is_nested(string: \"[]]]]]]]]]]\") == false)\nassert(is_nested(string:\
    \ \"[][][[]]\") == true)\nassert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string:\
    \ \"[]]\") == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmpg9q_b1hz.swift:15:20: error: single-quoted string literal found,\
    \ use '\"'\n        if char == '[' {\n                   ^~~\n               \
    \    \"[\"\n/tmp/tmpg9q_b1hz.swift:18:27: error: single-quoted string literal\
    \ found, use '\"'\n        } else if char == ']' {\n                         \
    \ ^~~\n                          \"]\"\n/tmp/tmpg9q_b1hz.swift:16:26: error: cannot\
    \ convert value of type 'Character' to expected argument type 'String'\n     \
    \       stack.append(char)\n                         ^\n"
  stdout: ''
  timestamp: 1660013962
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    func is_nested(string: String) -> Bool {\n    guard let start = string.index(of:\
    \ \"[\"),\n        let end = string.index(of: \"]\"),\n        start != end,\n\
    \        start < string.endIndex,\n        end > string.startIndex\n        else\
    \ { return false }\n    \n    var openingBracketCount = 0\n    var closingBracketCount\
    \ = 0\n    var openingBracket: Character?\n    var closingBracket: Character?\n\
    \    \n    for char in string.characters {\n        if char == \"[\" {\n     \
    \       openingBracketCount += 1\n            openingBracket = char\n        }\
    \ else if char == \"]\" {\n            closingBracketCount += 1\n            closingBracket\
    \ = char\n        }\n    }\n    \n    return openingBracketCount > 0 && closingBracketCount\
    \ > 0 && openingBracketCount < closingBracketCount\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]][[[[[]\") == false)\nassert(is_nested(string: \"[][]\") == false)\n\
    assert(is_nested(string: \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\"\
    ) == true)\nassert(is_nested(string: \"[]]]]]]]]]]\") == false)\nassert(is_nested(string:\
    \ \"[][][[]]\") == true)\nassert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string:\
    \ \"[]]\") == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmpswrx7lwj.swift:12:30: warning: 'index(of:)' is deprecated: renamed\
    \ to 'firstIndex(of:)'\n    guard let start = string.index(of: \"[\"),\n     \
    \                        ^\n/tmp/tmpswrx7lwj.swift:12:30: note: use 'firstIndex(of:)'\
    \ instead\n    guard let start = string.index(of: \"[\"),\n                  \
    \           ^~~~~\n                             firstIndex\n/tmp/tmpswrx7lwj.swift:13:26:\
    \ warning: 'index(of:)' is deprecated: renamed to 'firstIndex(of:)'\n        let\
    \ end = string.index(of: \"]\"),\n                         ^\n/tmp/tmpswrx7lwj.swift:13:26:\
    \ note: use 'firstIndex(of:)' instead\n        let end = string.index(of: \"]\"\
    ),\n                         ^~~~~\n                         firstIndex\n/tmp/tmpswrx7lwj.swift:24:24:\
    \ error: 'characters' is unavailable: Please use String directly\n    for char\
    \ in string.characters {\n                       ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmpswrx7lwj.swift:21:9: warning: variable\
    \ 'openingBracket' was written to, but never read\n    var openingBracket: Character?\n\
    \        ^\n/tmp/tmpswrx7lwj.swift:22:9: warning: variable 'closingBracket' was\
    \ written to, but never read\n    var closingBracket: Character?\n        ^\n"
  stdout: ''
  timestamp: 1660013962
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    func is_nested(string: String) -> Bool {\n    var openingBrackets = 0\n    var\
    \ closingBrackets = 0\n    var openingBracketsStack = [String]()\n    var closingBracketsStack\
    \ = [String]()\n    \n    for char in string {\n        switch char {\n      \
    \  case '[':\n            openingBracketsStack.append(char)\n            openingBrackets++\n\
    \        case ']':\n            closingBracketsStack.append(char)\n          \
    \  closingBrackets++\n        default:\n            if openingBrackets == 0 {\n\
    \                if closingBrackets == 0 {\n                    return false\n\
    \                }\n                \n                closingBracketsStack.removeLast()\n\
    \                closingBrackets--\n            } else {\n                openingBracketsStack.removeLast()\n\
    \                openingBrackets--\n            }\n        }\n    }\n    \n  \
    \  return openingBrackets == 0 && closingBrackets == 0\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]][[[[[]\") == false)\nassert(is_nested(string: \"[][]\") == false)\n\
    assert(is_nested(string: \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\"\
    ) == true)\nassert(is_nested(string: \"[]]]]]]]]]]\") == false)\nassert(is_nested(string:\
    \ \"[][][[]]\") == true)\nassert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string:\
    \ \"[]]\") == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmpu3m74fvy.swift:19:14: error: single-quoted string literal found,\
    \ use '\"'\n        case '[':\n             ^~~\n             \"[\"\n/tmp/tmpu3m74fvy.swift:22:14:\
    \ error: single-quoted string literal found, use '\"'\n        case ']':\n   \
    \          ^~~\n             \"]\"\n/tmp/tmpu3m74fvy.swift:20:41: error: cannot\
    \ convert value of type 'Character' to expected argument type 'String'\n     \
    \       openingBracketsStack.append(char)\n                                  \
    \      ^\n/tmp/tmpu3m74fvy.swift:21:28: error: cannot find operator '++' in scope;\
    \ did you mean '+= 1'?\n            openingBrackets++\n                      \
    \     ^~\n/tmp/tmpu3m74fvy.swift:23:41: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n            closingBracketsStack.append(char)\n\
    \                                        ^\n/tmp/tmpu3m74fvy.swift:24:28: error:\
    \ cannot find operator '++' in scope; did you mean '+= 1'?\n            closingBrackets++\n\
    \                           ^~\n/tmp/tmpu3m74fvy.swift:32:32: error: cannot find\
    \ operator '--' in scope; did you mean '-= 1'?\n                closingBrackets--\n\
    \                               ^~\n/tmp/tmpu3m74fvy.swift:35:32: error: cannot\
    \ find operator '--' in scope; did you mean '-= 1'?\n                openingBrackets--\n\
    \                               ^~\n"
  stdout: ''
  timestamp: 1660013962
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    func is_nested(string: String) -> Bool {\n    guard let start = string.index(of:\
    \ \"[\"), let end = string.index(of: \"]\") else {\n        return false\n   \
    \ }\n    return string.distance(from: start, to: end) == 1 && is_nested(string[start..<end])\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]][[[[[]\") == false)\nassert(is_nested(string: \"[][]\") == false)\n\
    assert(is_nested(string: \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\"\
    ) == true)\nassert(is_nested(string: \"[]]]]]]]]]]\") == false)\nassert(is_nested(string:\
    \ \"[][][[]]\") == true)\nassert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string:\
    \ \"[]]\") == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmp2xpm887g.swift:12:30: warning: 'index(of:)' is deprecated: renamed\
    \ to 'firstIndex(of:)'\n    guard let start = string.index(of: \"[\"), let end\
    \ = string.index(of: \"]\") else {\n                             ^\n/tmp/tmp2xpm887g.swift:12:30:\
    \ note: use 'firstIndex(of:)' instead\n    guard let start = string.index(of:\
    \ \"[\"), let end = string.index(of: \"]\") else {\n                         \
    \    ^~~~~\n                             firstIndex\n/tmp/tmp2xpm887g.swift:12:63:\
    \ warning: 'index(of:)' is deprecated: renamed to 'firstIndex(of:)'\n    guard\
    \ let start = string.index(of: \"[\"), let end = string.index(of: \"]\") else\
    \ {\n                                                              ^\n/tmp/tmp2xpm887g.swift:12:63:\
    \ note: use 'firstIndex(of:)' instead\n    guard let start = string.index(of:\
    \ \"[\"), let end = string.index(of: \"]\") else {\n                         \
    \                                     ^~~~~\n                                \
    \                              firstIndex\n/tmp/tmp2xpm887g.swift:15:68: error:\
    \ missing argument label 'string:' in call\n    return string.distance(from: start,\
    \ to: end) == 1 && is_nested(string[start..<end])\n                          \
    \                                         ^\n                                \
    \                                   string: \n/tmp/tmp2xpm887g.swift:15:74: error:\
    \ subscript 'subscript(_:)' requires the types 'String.Index' and 'Int' be equivalent\n\
    \    return string.distance(from: start, to: end) == 1 && is_nested(string[start..<end])\n\
    \                                                                         ^\n\
    Swift.String:5:12: note: where 'R.Bound' = 'String.Index'\n    public subscript<R>(bounds:\
    \ R) -> String where R : RangeExpression, R.Bound == Int { get }\n           ^\n"
  stdout: ''
  timestamp: 1660013962
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    func is_nested(string: String) -> Bool {\n    if string == \"\" {\n        return\
    \ false\n    }\n    var openingBracketCount = 0\n    var closingBracketCount =\
    \ 0\n    var openingBracket: Int = 0\n    var closingBracket: Int = 0\n    var\
    \ openingBracketCountInString = 0\n    var closingBracketCountInString = 0\n \
    \   var openingBracketInString: Int = 0\n    var closingBracketInString: Int =\
    \ 0\n    var openingBracketCountInStringInString = 0\n    var closingBracketCountInStringInString\
    \ = 0\n    var openingBracketInStringInString: Int = 0\n    var closingBracketInStringInString:\
    \ Int = 0\n    var openingBracketCountInStringInStringInString = 0\n    var closingBracketCountInStringInStringInString\
    \ = 0\n    var openingBracketInStringInStringInString: Int = 0\n    var closingBracketInStringInStringInString:\
    \ Int = 0\n    var openingBracketCountInStringInStringInStringInString = 0\n \
    \   var closingBracketCountInStringInStringInStringInString = 0\n    var openingBracketInStringInStringInStringInString:\
    \ Int = 0\n    var closingBracketInStringInStringInStringInString: Int = 0\n \
    \   var openingBracketCountInStringInStringInStringInStringInString = 0\n    var\
    \ closingBracketCountInStringInStringInStringInStringInString = 0\n    var openingBracketInStringInStringInStringInStringInString:\
    \ Int = 0\n    var closingBracketInStringInStringInStringInStringInStringInString:\
    \ Int = 0\n    var openingBracketCountInStringInStringInStringInStringInStringInString\
    \ = 0\n    var closingBracketCountInStringInStringInStringInStringInStringInString\
    \ = 0\n    var openingBracketInStringInStringInStringInStringInStringInStringInString:\
    \ Int = 0\n    var closingBracketInStringInStringInStringInStringInStringInStringInStringInString:\
    \ Int = 0\n    var openingBracketCountInStringInStringInStringInStringInStringInStringInStringInString\
    \ = 0\n    var closingBracketCountInStringInStringInStringInStringInStringInStringInStringInString\
    \ = 0\n    var openingBracketInStringInStringInStringInStringInStringInStringInStringInStringInString:\
    \ Int = 0\n    var closingBracketInStringInStringInStringInStringInStringInStringInStringInStringInStringInString:\
    \ Int = 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(is_nested(string: \"\
    [[]]\") == true)\nassert(is_nested(string: \"[]]]]]]][[[[[]\") == false)\nassert(is_nested(string:\
    \ \"[][]\") == false)\nassert(is_nested(string: \"[]\") == false)\nassert(is_nested(string:\
    \ \"[[[[]]]]\") == true)\nassert(is_nested(string: \"[]]]]]]]]]]\") == false)\n\
    assert(is_nested(string: \"[][][[]]\") == true)\nassert(is_nested(string: \"[[]\"\
    ) == false)\nassert(is_nested(string: \"[]]\") == false)\nassert(is_nested(string:\
    \ \"[[]][[\") == true)\nassert(is_nested(string: \"[[][]]\") == true)\nassert(is_nested(string:\
    \ \"\") == false)\nassert(is_nested(string: \"[[[[[[[[\") == false)\nassert(is_nested(string:\
    \ \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmpowwsn52p.swift:15:9: warning: initialization of variable 'openingBracketCount'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var openingBracketCount = 0\n    ~~~~^~~~~~~~~~~~~~~~~~~\n    _\n/tmp/tmpowwsn52p.swift:16:9:\
    \ warning: initialization of variable 'closingBracketCount' was never used; consider\
    \ replacing with assignment to '_' or removing it\n    var closingBracketCount\
    \ = 0\n    ~~~~^~~~~~~~~~~~~~~~~~~\n    _\n/tmp/tmpowwsn52p.swift:17:9: warning:\
    \ variable 'openingBracket' was never used; consider replacing with '_' or removing\
    \ it\n    var openingBracket: Int = 0\n        ^~~~~~~~~~~~~~\n        _\n/tmp/tmpowwsn52p.swift:18:9:\
    \ warning: variable 'closingBracket' was never used; consider replacing with '_'\
    \ or removing it\n    var closingBracket: Int = 0\n        ^~~~~~~~~~~~~~\n  \
    \      _\n/tmp/tmpowwsn52p.swift:19:9: warning: initialization of variable 'openingBracketCountInString'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var openingBracketCountInString = 0\n    ~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    \    _\n/tmp/tmpowwsn52p.swift:20:9: warning: initialization of variable 'closingBracketCountInString'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var closingBracketCountInString = 0\n    ~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    \    _\n/tmp/tmpowwsn52p.swift:21:9: warning: variable 'openingBracketInString'\
    \ was never used; consider replacing with '_' or removing it\n    var openingBracketInString:\
    \ Int = 0\n        ^~~~~~~~~~~~~~~~~~~~~~\n        _\n/tmp/tmpowwsn52p.swift:22:9:\
    \ warning: variable 'closingBracketInString' was never used; consider replacing\
    \ with '_' or removing it\n    var closingBracketInString: Int = 0\n        ^~~~~~~~~~~~~~~~~~~~~~\n\
    \        _\n/tmp/tmpowwsn52p.swift:23:9: warning: initialization of variable 'openingBracketCountInStringInString'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var openingBracketCountInStringInString = 0\n    ~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    \    _\n/tmp/tmpowwsn52p.swift"
  stdout: ''
  timestamp: 1660013962
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    func is_nested(string: String) -> Bool {\n    var stack = [String]()\n    for\
    \ ch in string {\n        if ch == '[' {\n            stack.append(String(ch))\n\
    \        } else if ch == ']' {\n            if stack.isEmpty {\n             \
    \   return false\n            }\n            stack.removeLast()\n        } else\
    \ if ch == '[' {\n            stack.append(String(ch))\n        } else if ch ==\
    \ ']' {\n            if stack.isEmpty {\n                return false\n      \
    \      }\n            stack.removeLast()\n        } else if stack.isEmpty {\n\
    \            return false\n        }\n    }\n    return stack.isEmpty\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]][[[[[]\") == false)\nassert(is_nested(string: \"[][]\") == false)\n\
    assert(is_nested(string: \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\"\
    ) == true)\nassert(is_nested(string: \"[]]]]]]]]]]\") == false)\nassert(is_nested(string:\
    \ \"[][][[]]\") == true)\nassert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string:\
    \ \"[]]\") == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmpup0l22ew.swift:14:18: error: single-quoted string literal found,\
    \ use '\"'\n        if ch == '[' {\n                 ^~~\n                 \"\
    [\"\n/tmp/tmpup0l22ew.swift:16:25: error: single-quoted string literal found,\
    \ use '\"'\n        } else if ch == ']' {\n                        ^~~\n     \
    \                   \"]\"\n/tmp/tmpup0l22ew.swift:21:25: error: single-quoted\
    \ string literal found, use '\"'\n        } else if ch == '[' {\n            \
    \            ^~~\n                        \"[\"\n/tmp/tmpup0l22ew.swift:23:25:\
    \ error: single-quoted string literal found, use '\"'\n        } else if ch ==\
    \ ']' {\n                        ^~~\n                        \"]\"\n"
  stdout: ''
  timestamp: 1660013962
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    func is_nested(string: String) -> Bool {\n\tlet stack = Stack()\n\tlet openBrackets\
    \ = Set<Character>()\n\tlet closeBrackets = Set<Character>()\n\t\n\tlet openBracketsCount\
    \ = stack.count\n\t\n\tfor char in string {\n\t\tif char == '[' {\n\t\t\topenBrackets.insert(char)\n\
    \t\t} else if char == ']' {\n\t\t\tcloseBrackets.insert(char)\n\t\t} else {\n\t\
    \t\tstack.append(char)\n\t\t}\n\t}\n\t\n\tlet closeBracketsCount = stack.count\n\
    \t\n\tif openBracketsCount != closeBracketsCount {\n\t\treturn false\n\t}\n\t\n\
    \tlet openBracketsStack = stack.copy() as! [Character]\n\t\n\twhile openBracketsStack.count\
    \ > 0 {\n\t\tlet openBracket = openBracketsStack.removeLast()\n\t\t\n\t\tif openBracketsStack.contains(openBracket)\
    \ {\n\t\t\treturn false\n\t\t}\n\t\t\n\t\tif openBrackets.contains(openBracket)\
    \ {\n\t\t\treturn false\n\t\t}\n\t\t\n\t\topenBracketsStack.append(openBracket)\n\
    \t}\n\t\n\treturn true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(is_nested(string:\
    \ \"[[]]\") == true)\nassert(is_nested(string: \"[]]]]]]][[[[[]\") == false)\n\
    assert(is_nested(string: \"[][]\") == false)\nassert(is_nested(string: \"[]\"\
    ) == false)\nassert(is_nested(string: \"[[[[]]]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]]]]]\") == false)\nassert(is_nested(string: \"[][][[]]\") == true)\n\
    assert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string: \"[]]\"\
    ) == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmpviycmzpp.swift:19:14: error: single-quoted string literal found,\
    \ use '\"'\n                if char == '[' {\n                           ^~~\n\
    \                           \"[\"\n/tmp/tmpviycmzpp.swift:21:21: error: single-quoted\
    \ string literal found, use '\"'\n                } else if char == ']' {\n  \
    \                                ^~~\n                                  \"]\"\n\
    /tmp/tmpviycmzpp.swift:12:14: error: cannot find 'Stack' in scope\n        let\
    \ stack = Stack()\n                    ^~~~~\n/tmp/tmpviycmzpp.swift:20:17: error:\
    \ cannot use mutating member on immutable value: 'openBrackets' is a 'let' constant\n\
    \                        openBrackets.insert(char)\n                        ~~~~~~~~~~~~\
    \ ^\n/tmp/tmpviycmzpp.swift:13:2: note: change 'let' to 'var' to make it mutable\n\
    \        let openBrackets = Set<Character>()\n        ^~~\n        var\n/tmp/tmpviycmzpp.swift:22:18:\
    \ error: cannot use mutating member on immutable value: 'closeBrackets' is a 'let'\
    \ constant\n                        closeBrackets.insert(char)\n             \
    \           ~~~~~~~~~~~~~ ^\n/tmp/tmpviycmzpp.swift:14:2: note: change 'let' to\
    \ 'var' to make it mutable\n        let closeBrackets = Set<Character>()\n   \
    \     ^~~\n        var\n"
  stdout: ''
  timestamp: 1660013962
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    func is_nested(string: String) -> Bool {\n    guard let range = string.range(of:\
    \ \"[[]]\") else {\n        return false\n    }\n    \n    let start = string.index(range.lowerBound,\
    \ offsetBy: 1)\n    let end = string.index(range.upperBound, offsetBy: 1)\n  \
    \  \n    return start < end\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(is_nested(string:\
    \ \"[[]]\") == true)\nassert(is_nested(string: \"[]]]]]]][[[[[]\") == false)\n\
    assert(is_nested(string: \"[][]\") == false)\nassert(is_nested(string: \"[]\"\
    ) == false)\nassert(is_nested(string: \"[[[[]]]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]]]]]\") == false)\nassert(is_nested(string: \"[][][[]]\") == true)\n\
    assert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string: \"[]]\"\
    ) == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmp42uskjjy.swift:12:30: error: value of type 'String' has no member\
    \ 'range'\n    guard let range = string.range(of: \"[[]]\") else {\n         \
    \             ~~~~~~ ^~~~~\n"
  stdout: ''
  timestamp: 1660013962
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    func is_nested(string: String) -> Bool {\n    var stack = [String]()\n    var\
    \ open = 0\n    var close = 0\n    for i := 0; i < len(string); i++ {\n      \
    \  if string[i] == '[' {\n            stack.append(string[i])\n            open++\n\
    \        } else if string[i] == ']' {\n            close++\n            if open\
    \ > close {\n                return false\n            }\n            open--\n\
    \        } else {\n            if open > close {\n                return false\n\
    \            }\n        }\n    }\n    return open > close\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]][[[[[]\") == false)\nassert(is_nested(string: \"[][]\") == false)\n\
    assert(is_nested(string: \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\"\
    ) == true)\nassert(is_nested(string: \"[]]]]]]]]]]\") == false)\nassert(is_nested(string:\
    \ \"[][][[]]\") == true)\nassert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string:\
    \ \"[]]\") == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmpnj0ao9iq.swift:15:12: error: expected type\n    for i := 0; i <\
    \ len(string); i++ {\n           ^\n            <#type#>\n/tmp/tmpnj0ao9iq.swift:15:12:\
    \ error: expected 'in' after for-each pattern\n    for i := 0; i < len(string);\
    \ i++ {\n           ^\n/tmp/tmpnj0ao9iq.swift:15:12: error: expected Sequence\
    \ expression for for-each loop\n    for i := 0; i < len(string); i++ {\n     \
    \      ^\n/tmp/tmpnj0ao9iq.swift:16:25: error: single-quoted string literal found,\
    \ use '\"'\n        if string[i] == '[' {\n                        ^~~\n     \
    \                   \"[\"\n/tmp/tmpnj0ao9iq.swift:19:32: error: single-quoted\
    \ string literal found, use '\"'\n        } else if string[i] == ']' {\n     \
    \                          ^~~\n                               \"]\"\n"
  stdout: ''
  timestamp: 1660013962
- exit_code: -4
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    func is_nested(string: String) -> Bool {\n    guard let open = string.index(of:\
    \ \"[\"),\n        let close = string.index(of: \"]\"),\n        open != close\
    \ else {\n        return false\n    }\n    let openBracketCount = string.distance(from:\
    \ open, to: close)\n    let closeBracketCount = string.distance(from: close, to:\
    \ open)\n    return openBracketCount != closeBracketCount\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]][[[[[]\") == false)\nassert(is_nested(string: \"[][]\") == false)\n\
    assert(is_nested(string: \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\"\
    ) == true)\nassert(is_nested(string: \"[]]]]]]]]]]\") == false)\nassert(is_nested(string:\
    \ \"[][][[]]\") == true)\nassert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string:\
    \ \"[]]\") == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: Exception
  stderr: 'tmp99i5fr_4/tmp99i5fr_4.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b3a9b49fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3a9b196b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b3a9b196988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b3a9b1957b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp99i5fr_4                        0x00005604c92ea51b <unavailable> + 5403

    5    libc.so.6                          0x00002b3a9b68b460 __libc_start_main +
    245

    6    tmp99i5fr_4                        0x00005604c92ea109 <unavailable> + 4361

    '
  stdout: ''
  timestamp: 1660013962
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    func is_nested(string: String) -> Bool {\n    guard let start = string.index(of:\
    \ \"[\"), let end = string.index(of: \"]\"), let range = start..end else { return\
    \ false }\n    return string.range(of: \"[\", options: .backwards)?.lowerBound\
    \ == range.lowerBound && string.range(of: \"]\", options: .backwards)?.upperBound\
    \ == range.upperBound\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(is_nested(string:\
    \ \"[[]]\") == true)\nassert(is_nested(string: \"[]]]]]]][[[[[]\") == false)\n\
    assert(is_nested(string: \"[][]\") == false)\nassert(is_nested(string: \"[]\"\
    ) == false)\nassert(is_nested(string: \"[[[[]]]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]]]]]\") == false)\nassert(is_nested(string: \"[][][[]]\") == true)\n\
    assert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string: \"[]]\"\
    ) == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmp264ujwes.swift:12:30: warning: 'index(of:)' is deprecated: renamed\
    \ to 'firstIndex(of:)'\n    guard let start = string.index(of: \"[\"), let end\
    \ = string.index(of: \"]\"), let range = start..end else { return false }\n  \
    \                           ^\n/tmp/tmp264ujwes.swift:12:30: note: use 'firstIndex(of:)'\
    \ instead\n    guard let start = string.index(of: \"[\"), let end = string.index(of:\
    \ \"]\"), let range = start..end else { return false }\n                     \
    \        ^~~~~\n                             firstIndex\n/tmp/tmp264ujwes.swift:12:63:\
    \ warning: 'index(of:)' is deprecated: renamed to 'firstIndex(of:)'\n    guard\
    \ let start = string.index(of: \"[\"), let end = string.index(of: \"]\"), let\
    \ range = start..end else { return false }\n                                 \
    \                             ^\n/tmp/tmp264ujwes.swift:12:63: note: use 'firstIndex(of:)'\
    \ instead\n    guard let start = string.index(of: \"[\"), let end = string.index(of:\
    \ \"]\"), let range = start..end else { return false }\n                     \
    \                                         ^~~~~\n                            \
    \                                  firstIndex\n/tmp/tmp264ujwes.swift:12:96: error:\
    \ cannot find operator '..' in scope; did you mean '...'?\n    guard let start\
    \ = string.index(of: \"[\"), let end = string.index(of: \"]\"), let range = start..end\
    \ else { return false }\n                                                    \
    \                                           ^~\n                             \
    \                                                                  ...\n/tmp/tmp264ujwes.swift:13:19:\
    \ error: value of type 'String' has no member 'range'\n    return string.range(of:\
    \ \"[\", options: .backwards)?.lowerBound == range.lowerBound && string.range(of:\
    \ \"]\", options: .backwards)?.upperBound == range.upperBound\n           ~~~~~~\
    \ ^~~~~\n/tmp/tmp264ujwes.swift:13:97: error: value of type 'String' has no member\
    \ 'range'\n    return string.range(of: \"[\", options: .backwards)?.lowerBound\
    \ == range.lowerBound && string.range(of: \"]\", options: .backwards)?.upperBound\
    \ == range.upp"
  stdout: ''
  timestamp: 1660013962
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    func is_nested(string: String) -> Bool {\n    var stack = [String]()\n    var\
    \ open = 0\n    var close = 0\n    var i = 0\n    var j = 0\n    var openingBrackets\
    \ = 0\n    var closingBrackets = 0\n    var openingBracketsCount = 0\n    var\
    \ closingBracketsCount = 0\n    var openingBracketsCountBefore = 0\n    var closingBracketsCountBefore\
    \ = 0\n    var openingBracketsCountAfter = 0\n    var closingBracketsCountAfter\
    \ = 0\n    var openingBracketsCountBeforeAfter = 0\n    var closingBracketsCountBeforeAfter\
    \ = 0\n    var openingBracketsCountBeforeBefore = 0\n    var closingBracketsCountBeforeBefore\
    \ = 0\n    var openingBracketsCountBeforeAfterAfter = 0\n    var closingBracketsCountBeforeAfterAfter\
    \ = 0\n    var openingBracketsCountAfterAfter = 0\n    var closingBracketsCountAfterAfter\
    \ = 0\n    var openingBracketsCountBeforeBeforeAfter = 0\n    var closingBracketsCountBeforeBeforeAfter\
    \ = 0\n    var openingBracketsCountBeforeBeforeBefore = 0\n    var closingBracketsCountBeforeBeforeBefore\
    \ = 0\n    var openingBracketsCountBeforeAfterAfter = 0\n    var closingBracketsCountBeforeAfterAfter\
    \ = 0\n    var openingBracketsCountAfterAfter = 0\n    var closingBracketsCountAfterAfter\
    \ = 0\n    var openingBracketsCountBeforeBeforeAfter = 0\n    var closingBracketsCountBeforeBeforeAfter\
    \ = 0\n    var openingBracketsCountBeforeBeforeBefore = 0\n    var closingBracketsCountBeforeBeforeBefore\
    \ = 0\n    var openingBracketsCountBeforeAfterAfter = 0\n    var closingBracketsCountBeforeAfterAfter\
    \ = 0\n    var openingBracketsCountAfterAfter = 0\n    var closingBracketsCountAfterAfter\
    \ = 0\n    var openingBracketsCountBeforeBeforeAfter = 0\n    var closingBracketsCountBeforeBeforeAfter\
    \ = 0\n    var openingBracketsCountBeforeBeforeBefore = 0\n    var closingBracketsCountBeforeBeforeBefore\
    \ = 0\n    var openingBracketsCountBeforeAfterAfter = 0\n    var closingBracketsCountBeforeAfterAfter\
    \ = 0\n    var openingBracketsCountAfterAfter = 0\n    var closingBracketsCountAfterAfter\
    \ = 0\n    var openingBracketsCountBeforeBeforeAfter = 0\n    var closingBracketsCountBeforeBeforeAfter\
    \ = 0\n    var openingBracketsCountBeforeBeforeBefore = 0\n    var closingBracketsCountBeforeBeforeBefore\
    \ = 0\n    var openingBracketsCountBeforeAfterAfter = 0\n    var closingBracketsCountBeforeAfter\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]][[[[[]\") == false)\nassert(is_nested(string: \"[][]\") == false)\n\
    assert(is_nested(string: \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\"\
    ) == true)\nassert(is_nested(string: \"[]]]]]]]]]]\") == false)\nassert(is_nested(string:\
    \ \"[][][[]]\") == true)\nassert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string:\
    \ \"[]]\") == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmpu8ixcz4y.swift:37:9: error: invalid redeclaration of 'openingBracketsCountBeforeAfterAfter'\n\
    \    var openingBracketsCountBeforeAfterAfter = 0\n        ^\n/tmp/tmpu8ixcz4y.swift:29:9:\
    \ note: 'openingBracketsCountBeforeAfterAfter' previously declared here\n    var\
    \ openingBracketsCountBeforeAfterAfter = 0\n        ^\n/tmp/tmpu8ixcz4y.swift:38:9:\
    \ error: invalid redeclaration of 'closingBracketsCountBeforeAfterAfter'\n   \
    \ var closingBracketsCountBeforeAfterAfter = 0\n        ^\n/tmp/tmpu8ixcz4y.swift:30:9:\
    \ note: 'closingBracketsCountBeforeAfterAfter' previously declared here\n    var\
    \ closingBracketsCountBeforeAfterAfter = 0\n        ^\n/tmp/tmpu8ixcz4y.swift:39:9:\
    \ error: invalid redeclaration of 'openingBracketsCountAfterAfter'\n    var openingBracketsCountAfterAfter\
    \ = 0\n        ^\n/tmp/tmpu8ixcz4y.swift:31:9: note: 'openingBracketsCountAfterAfter'\
    \ previously declared here\n    var openingBracketsCountAfterAfter = 0\n     \
    \   ^\n/tmp/tmpu8ixcz4y.swift:40:9: error: invalid redeclaration of 'closingBracketsCountAfterAfter'\n\
    \    var closingBracketsCountAfterAfter = 0\n        ^\n/tmp/tmpu8ixcz4y.swift:32:9:\
    \ note: 'closingBracketsCountAfterAfter' previously declared here\n    var closingBracketsCountAfterAfter\
    \ = 0\n        ^\n/tmp/tmpu8ixcz4y.swift:41:9: error: invalid redeclaration of\
    \ 'openingBracketsCountBeforeBeforeAfter'\n    var openingBracketsCountBeforeBeforeAfter\
    \ = 0\n        ^\n/tmp/tmpu8ixcz4y.swift:33:9: note: 'openingBracketsCountBeforeBeforeAfter'\
    \ previously declared here\n    var openingBracketsCountBeforeBeforeAfter = 0\n\
    \        ^\n/tmp/tmpu8ixcz4y.swift:42:9: error: invalid redeclaration of 'closingBracketsCountBeforeBeforeAfter'\n\
    \    var closingBracketsCountBeforeBeforeAfter = 0\n        ^\n/tmp/tmpu8ixcz4y.swift:34:9:\
    \ note: 'closingBracketsCountBeforeBeforeAfter' previously declared here\n   \
    \ var closingBracketsCountBeforeBeforeAfter = 0\n        ^\n/tmp/tmpu8ixcz4y.swift:43:9:\
    \ error: invalid redeclaration of 'openingBracketsCountBeforeBeforeBefore'\n \
    \   var openingBracketsCountBeforeBeforeBefore = 0\n        ^\n/tmp/tmpu8ixcz4y.swift:"
  stdout: ''
  timestamp: 1660013962
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    func is_nested(string: String) -> Bool {\n    let brackets = string.unicodeScalars\n\
    \        .filter({ $0 != CharacterSet.openParenthesis })\n        .filter({ $0\
    \ != CharacterSet.closeParenthesis })\n        .filter({ $0 != CharacterSet.openBracket})\n\
    \        .filter({ $0 != CharacterSet.closeBracket})\n        .filter({ $0 !=\
    \ CharacterSet.openBrace})\n        .filter({ $0 != CharacterSet.closeBrace})\n\
    \    return brackets.count > 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(is_nested(string:\
    \ \"[[]]\") == true)\nassert(is_nested(string: \"[]]]]]]][[[[[]\") == false)\n\
    assert(is_nested(string: \"[][]\") == false)\nassert(is_nested(string: \"[]\"\
    ) == false)\nassert(is_nested(string: \"[[[[]]]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]]]]]\") == false)\nassert(is_nested(string: \"[][][[]]\") == true)\n\
    assert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string: \"[]]\"\
    ) == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmp6agwpixs.swift:13:25: error: cannot find 'CharacterSet' in scope\n\
    \        .filter({ $0 != CharacterSet.openParenthesis })\n                   \
    \     ^~~~~~~~~~~~\n/tmp/tmp6agwpixs.swift:14:25: error: cannot find 'CharacterSet'\
    \ in scope\n        .filter({ $0 != CharacterSet.closeParenthesis })\n       \
    \                 ^~~~~~~~~~~~\n/tmp/tmp6agwpixs.swift:15:25: error: cannot find\
    \ 'CharacterSet' in scope\n        .filter({ $0 != CharacterSet.openBracket})\n\
    \                        ^~~~~~~~~~~~\n/tmp/tmp6agwpixs.swift:16:25: error: cannot\
    \ find 'CharacterSet' in scope\n        .filter({ $0 != CharacterSet.closeBracket})\n\
    \                        ^~~~~~~~~~~~\n/tmp/tmp6agwpixs.swift:17:25: error: cannot\
    \ find 'CharacterSet' in scope\n        .filter({ $0 != CharacterSet.openBrace})\n\
    \                        ^~~~~~~~~~~~\n/tmp/tmp6agwpixs.swift:18:25: error: cannot\
    \ find 'CharacterSet' in scope\n        .filter({ $0 != CharacterSet.closeBrace})\n\
    \                        ^~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013962
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    func is_nested(string: String) -> Bool {\n    var stack = [String]()\n    var\
    \ open = 0\n    for index in 0..<string.characters.count {\n        let char =\
    \ string.characters[index]\n        if char == \"[\" {\n            open++\n \
    \       } else if char == \"]\" {\n            open--\n        } else if char\
    \ == \"{\" {\n            stack.append(char)\n        } else if char == \"}\"\
    \ {\n            if open < 0 {\n                return false\n            }\n\
    \            open--\n        }\n    }\n    return open < 0\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]][[[[[]\") == false)\nassert(is_nested(string: \"[][]\") == false)\n\
    assert(is_nested(string: \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\"\
    ) == true)\nassert(is_nested(string: \"[]]]]]]]]]]\") == false)\nassert(is_nested(string:\
    \ \"[][][[]]\") == true)\nassert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string:\
    \ \"[]]\") == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmpu4sv1hl1.swift:14:29: error: 'characters' is unavailable: Please\
    \ use String directly\n    for index in 0..<string.characters.count {\n      \
    \                      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpu4sv1hl1.swift:15:20: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        let char\
    \ = string.characters[index]\n                   ^~~~~~~~~~~~~~~~~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpu4sv1hl1.swift:15:27:\
    \ error: 'characters' is unavailable: Please use String directly\n        let\
    \ char = string.characters[index]\n                          ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmpu4sv1hl1.swift:17:17: error: cannot find\
    \ operator '++' in scope; did you mean '+= 1'?\n            open++\n         \
    \       ^~\n/tmp/tmpu4sv1hl1.swift:19:17: error: cannot find operator '--' in\
    \ scope; did you mean '-= 1'?\n            open--\n                ^~\n/tmp/tmpu4sv1hl1.swift:21:26:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            stack.append(char)\n                         ^\n/tmp/tmpu4sv1hl1.swift:26:17:\
    \ error: cannot find operator '--' in scope; did you mean '-= 1'?\n          \
    \  open--\n                ^~\n"
  stdout: ''
  timestamp: 1660013962
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    func is_nested(string: String) -> Bool {\n    guard let start = string.index(of:\
    \ \"[\"),\n        let end = string.index(of: \"]\"),\n        start != end,\n\
    \        start < string.endIndex,\n        end > string.startIndex\n        else\
    \ { return false }\n    let start = string.index(before: start)\n    let end =\
    \ string.index(before: end)\n    let range = start..<end\n    let nested = string.substring(with:\
    \ range)\n    return nested.contains(\"[\")\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string: \"\
    []]]]]]][[[[[]\") == false)\nassert(is_nested(string: \"[][]\") == false)\nassert(is_nested(string:\
    \ \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]]]]]\") == false)\nassert(is_nested(string: \"[][][[]]\") == true)\n\
    assert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string: \"[]]\"\
    ) == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmp0nsvgb4k.swift:12:30: warning: 'index(of:)' is deprecated: renamed\
    \ to 'firstIndex(of:)'\n    guard let start = string.index(of: \"[\"),\n     \
    \                        ^\n/tmp/tmp0nsvgb4k.swift:12:30: note: use 'firstIndex(of:)'\
    \ instead\n    guard let start = string.index(of: \"[\"),\n                  \
    \           ^~~~~\n                             firstIndex\n/tmp/tmp0nsvgb4k.swift:13:26:\
    \ warning: 'index(of:)' is deprecated: renamed to 'firstIndex(of:)'\n        let\
    \ end = string.index(of: \"]\"),\n                         ^\n/tmp/tmp0nsvgb4k.swift:13:26:\
    \ note: use 'firstIndex(of:)' instead\n        let end = string.index(of: \"]\"\
    ),\n                         ^~~~~\n                         firstIndex\n/tmp/tmp0nsvgb4k.swift:18:9:\
    \ error: invalid redeclaration of 'start'\n    let start = string.index(before:\
    \ start)\n        ^\n/tmp/tmp0nsvgb4k.swift:12:15: note: 'start' previously declared\
    \ here\n    guard let start = string.index(of: \"[\"),\n              ^\n/tmp/tmp0nsvgb4k.swift:19:9:\
    \ error: invalid redeclaration of 'end'\n    let end = string.index(before: end)\n\
    \        ^\n/tmp/tmp0nsvgb4k.swift:13:13: note: 'end' previously declared here\n\
    \        let end = string.index(of: \"]\"),\n            ^\n/tmp/tmp0nsvgb4k.swift:21:25:\
    \ error: value of type 'String' has no member 'substring'\n    let nested = string.substring(with:\
    \ range)\n                 ~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013962
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    func is_nested(string: String) -> Bool {\n    let stack = Stack()\n    for character\
    \ in string {\n        switch character {\n        case '[':\n            stack.push(character)\n\
    \        case ']':\n            if stack.count > 0 {\n                stack.pop()\n\
    \            } else {\n                return false\n            }\n        default:\n\
    \            return false\n        }\n    }\n    return stack.count == 0\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]][[[[[]\") == false)\nassert(is_nested(string: \"[][]\") == false)\n\
    assert(is_nested(string: \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\"\
    ) == true)\nassert(is_nested(string: \"[]]]]]]]]]]\") == false)\nassert(is_nested(string:\
    \ \"[][][[]]\") == true)\nassert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string:\
    \ \"[]]\") == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmpdgesbegw.swift:15:14: error: single-quoted string literal found,\
    \ use '\"'\n        case '[':\n             ^~~\n             \"[\"\n/tmp/tmpdgesbegw.swift:17:14:\
    \ error: single-quoted string literal found, use '\"'\n        case ']':\n   \
    \          ^~~\n             \"]\"\n/tmp/tmpdgesbegw.swift:12:17: error: cannot\
    \ find 'Stack' in scope\n    let stack = Stack()\n                ^~~~~\n"
  stdout: ''
  timestamp: 1660013962
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    func is_nested(string: String) -> Bool {\n    \n    let brackets = string.replacingOccurrences(of:\
    \ \"[\", with: \"\").replacingOccurrences(of: \"]\", with: \"\")\n    \n    let\
    \ openBrackets = brackets.replacingOccurrences(of: \"(\", with: \"\").replacingOccurrences(of:\
    \ \")\", with: \"\")\n    \n    let closeBrackets = brackets.replacingOccurrences(of:\
    \ \"[\", with: \"\").replacingOccurrences(of: \"]\", with: \"\")\n    \n    let\
    \ openBracketsCount = openBrackets.characters.count\n    \n    let closeBracketsCount\
    \ = closeBrackets.characters.count\n    \n    let openBracketsCount = Int(openBracketsCount)\n\
    \    \n    let closeBracketsCount = Int(closeBracketsCount)\n    \n    if openBracketsCount\
    \ < closeBracketsCount {\n        return false\n    } else {\n        return true\n\
    \    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(is_nested(string: \"[[]]\"\
    ) == true)\nassert(is_nested(string: \"[]]]]]]][[[[[]\") == false)\nassert(is_nested(string:\
    \ \"[][]\") == false)\nassert(is_nested(string: \"[]\") == false)\nassert(is_nested(string:\
    \ \"[[[[]]]]\") == true)\nassert(is_nested(string: \"[]]]]]]]]]]\") == false)\n\
    assert(is_nested(string: \"[][][[]]\") == true)\nassert(is_nested(string: \"[[]\"\
    ) == false)\nassert(is_nested(string: \"[]]\") == false)\nassert(is_nested(string:\
    \ \"[[]][[\") == true)\nassert(is_nested(string: \"[[][]]\") == true)\nassert(is_nested(string:\
    \ \"\") == false)\nassert(is_nested(string: \"[[[[[[[[\") == false)\nassert(is_nested(string:\
    \ \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmp90y0onvs.swift:13:27: error: value of type 'String' has no member\
    \ 'replacingOccurrences'\n    let brackets = string.replacingOccurrences(of: \"\
    [\", with: \"\").replacingOccurrences(of: \"]\", with: \"\")\n               \
    \    ~~~~~~ ^~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013962
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    func is_nested(string: String) -> Bool {\n    guard let pattern = try? NSRegularExpression(pattern:\
    \ \"\\\\[\\\\[\\\\]\\\\]\\\\]\", options: []) else {\n        return false\n \
    \   }\n    \n    guard let range = pattern.range(of: string, options: .regularExpression)\
    \ else { return false }\n    \n    let result = pattern.matches(in: string, options:\
    \ [], range: range)\n    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string: \"\
    []]]]]]][[[[[]\") == false)\nassert(is_nested(string: \"[][]\") == false)\nassert(is_nested(string:\
    \ \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]]]]]\") == false)\nassert(is_nested(string: \"[][][[]]\") == true)\n\
    assert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string: \"[]]\"\
    ) == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmpigqiy_p3.swift:12:30: error: cannot find 'NSRegularExpression'\
    \ in scope\n    guard let pattern = try? NSRegularExpression(pattern: \"\\\\[\\\
    \\[\\\\]\\\\]\\\\]\", options: []) else {\n                             ^~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpigqiy_p3.swift:16:59: error: cannot infer contextual base in reference\
    \ to member 'regularExpression'\n    guard let range = pattern.range(of: string,\
    \ options: .regularExpression) else { return false }\n                       \
    \                                  ~^~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013962
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    func is_nested(string: String) -> Bool {\n    var stack = [String]()\n    var\
    \ opening = false\n    for char in string {\n        if char == '[' {\n      \
    \      stack.append(char)\n        } else if char == ']' {\n            if opening\
    \ = true {\n                return false\n            }\n            stack.removeLast()\n\
    \        } else if char == '[' {\n            opening = true\n        }\n    }\n\
    \    return stack.count == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(is_nested(string:\
    \ \"[[]]\") == true)\nassert(is_nested(string: \"[]]]]]]][[[[[]\") == false)\n\
    assert(is_nested(string: \"[][]\") == false)\nassert(is_nested(string: \"[]\"\
    ) == false)\nassert(is_nested(string: \"[[[[]]]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]]]]]\") == false)\nassert(is_nested(string: \"[][][[]]\") == true)\n\
    assert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string: \"[]]\"\
    ) == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmp_xdhjuyd.swift:15:20: error: single-quoted string literal found,\
    \ use '\"'\n        if char == '[' {\n                   ^~~\n               \
    \    \"[\"\n/tmp/tmp_xdhjuyd.swift:17:27: error: single-quoted string literal\
    \ found, use '\"'\n        } else if char == ']' {\n                         \
    \ ^~~\n                          \"]\"\n/tmp/tmp_xdhjuyd.swift:22:27: error: single-quoted\
    \ string literal found, use '\"'\n        } else if char == '[' {\n          \
    \                ^~~\n                          \"[\"\n/tmp/tmp_xdhjuyd.swift:16:26:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            stack.append(char)\n                         ^\n/tmp/tmp_xdhjuyd.swift:18:24:\
    \ error: use of '=' in a boolean context, did you mean '=='?\n            if opening\
    \ = true {\n               ~~~~~~~ ^ ~~~~\n                       ==\n"
  stdout: ''
  timestamp: 1660013962
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    func is_nested(string: String) -> Bool {\n    guard let openBracket = string.rangeOfString(\"\
    [\", options: .LiteralSearch, range: nil, locale: nil) else {\n        return\
    \ false\n    }\n    guard let closeBracket = string.rangeOfString(\"]\", options:\
    \ .LiteralSearch, range: nil, locale: nil) else {\n        return false\n    }\n\
    \    guard openBracket.location != closeBracket.location else {\n        return\
    \ false\n    }\n    guard openBracket.location > closeBracket.location else {\n\
    \        return false\n    }\n    guard openBracket.location < string.endIndex\
    \ else {\n        return false\n    }\n    guard closeBracket.location > string.endIndex\
    \ else {\n        return false\n    }\n    guard closeBracket.location < openBracket.location\
    \ else {\n        return false\n    }\n    guard let openBracketIndex = string.index(openBracket.location,\
    \ offsetBy: 1) {\n        return false\n    }\n    guard let closeBracketIndex\
    \ = string.index(closeBracket.location, offsetBy: 1) {\n        return false\n\
    \    }\n    guard openBracketIndex < closeBracketIndex else {\n        return\
    \ false\n    }\n    guard openBracketIndex < string.endIndex else {\n        return\
    \ false\n    }\n    guard closeBracketIndex < string.endIndex else {\n       \
    \ return false\n    }\n    guard let openBracket = string[openBracketIndex],\n\
    \        let closeBracket = string[closeBracketIndex],\n        let openBracketIndex\
    \ = string.index(openBracket, offsetBy: 1) {\n        return false\n    }\n  \
    \  guard let closeBracketIndex = string.index(closeBracket, offsetBy: 1) {\n \
    \       return false\n    }\n    guard openBracketIndex < closeBracketIndex else\
    \ {\n        return false\n    }\n    guard openBracketIndex < string.endIndex\
    \ else {\n        return false\n    }\n    guard closeBracketIndex < string.endIndex\
    \ else {\n        return false\n    }\n    guard openBracket == \"[\" else {\n\
    \        return false\n    }\n    guard closeBracket == \"]\" else {\n       \
    \ return false\n    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string: \"[]]]]]]][[[[[]\"\
    ) == false)\nassert(is_nested(string: \"[][]\") == false)\nassert(is_nested(string:\
    \ \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]]]]]\") == false)\nassert(is_nested(string: \"[][][[]]\") == true)\n\
    assert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string: \"[]]\"\
    ) == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmpdiuhlubi.swift:33:82: error: expected 'else' after 'guard' condition\n\
    \    guard let openBracketIndex = string.index(openBracket.location, offsetBy:\
    \ 1) {\n                                                                     \
    \            ^\n                                                             \
    \                    else \n/tmp/tmpdiuhlubi.swift:36:84: error: expected 'else'\
    \ after 'guard' condition\n    guard let closeBracketIndex = string.index(closeBracket.location,\
    \ offsetBy: 1) {\n                                                           \
    \                        ^\n                                                 \
    \                                  else \n/tmp/tmpdiuhlubi.swift:50:71: error:\
    \ expected 'else' after 'guard' condition\n        let openBracketIndex = string.index(openBracket,\
    \ offsetBy: 1) {\n                                                           \
    \           ^\n                                                              \
    \        else \n/tmp/tmpdiuhlubi.swift:53:75: error: expected 'else' after 'guard'\
    \ condition\n    guard let closeBracketIndex = string.index(closeBracket, offsetBy:\
    \ 1) {\n                                                                     \
    \     ^\n                                                                    \
    \      else \n/tmp/tmpdiuhlubi.swift:12:36: error: value of type 'String' has\
    \ no member 'rangeOfString'\n    guard let openBracket = string.rangeOfString(\"\
    [\", options: .LiteralSearch, range: nil, locale: nil) else {\n              \
    \              ~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmpdiuhlubi.swift:12:65: error: cannot\
    \ infer contextual base in reference to member 'LiteralSearch'\n    guard let\
    \ openBracket = string.rangeOfString(\"[\", options: .LiteralSearch, range: nil,\
    \ locale: nil) else {\n                                                      \
    \         ~^~~~~~~~~~~~~\n/tmp/tmpdiuhlubi.swift:12:87: error: 'nil' requires\
    \ a contextual type\n    guard let openBracket = string.rangeOfString(\"[\", options:\
    \ .LiteralSearch, range: nil, locale: nil) else {\n                          \
    \                         "
  stdout: ''
  timestamp: 1660013962
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    func is_nested(string: String) -> Bool {\n    var stack = [String]()\n    for\
    \ ch in string {\n        if ch == '[' {\n            stack.append(ch)\n     \
    \   } else if ch == ']' {\n            if stack.isEmpty {\n                return\
    \ false\n            }\n            stack.removeLast()\n        } else if ch ==\
    \ '[' {\n            stack.append(ch)\n        } else if ch == ']' {\n       \
    \     if stack.isEmpty {\n                return false\n            }\n      \
    \      stack.removeLast()\n        } else if ch == '{' {\n            stack.append(ch)\n\
    \        } else if ch == '}' {\n            if stack.isEmpty {\n             \
    \   return false\n            }\n            stack.removeLast()\n        }\n \
    \   }\n    return stack.isEmpty\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(is_nested(string:\
    \ \"[[]]\") == true)\nassert(is_nested(string: \"[]]]]]]][[[[[]\") == false)\n\
    assert(is_nested(string: \"[][]\") == false)\nassert(is_nested(string: \"[]\"\
    ) == false)\nassert(is_nested(string: \"[[[[]]]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]]]]]\") == false)\nassert(is_nested(string: \"[][][[]]\") == true)\n\
    assert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string: \"[]]\"\
    ) == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmpjblowaz1.swift:14:18: error: single-quoted string literal found,\
    \ use '\"'\n        if ch == '[' {\n                 ^~~\n                 \"\
    [\"\n/tmp/tmpjblowaz1.swift:16:25: error: single-quoted string literal found,\
    \ use '\"'\n        } else if ch == ']' {\n                        ^~~\n     \
    \                   \"]\"\n/tmp/tmpjblowaz1.swift:21:25: error: single-quoted\
    \ string literal found, use '\"'\n        } else if ch == '[' {\n            \
    \            ^~~\n                        \"[\"\n/tmp/tmpjblowaz1.swift:23:25:\
    \ error: single-quoted string literal found, use '\"'\n        } else if ch ==\
    \ ']' {\n                        ^~~\n                        \"]\"\n/tmp/tmpjblowaz1.swift:28:25:\
    \ error: single-quoted string literal found, use '\"'\n        } else if ch ==\
    \ '{' {\n                        ^~~\n                        \"{\"\n/tmp/tmpjblowaz1.swift:30:25:\
    \ error: single-quoted string literal found, use '\"'\n        } else if ch ==\
    \ '}' {\n                        ^~~\n                        \"}\"\n/tmp/tmpjblowaz1.swift:15:26:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            stack.append(ch)\n                         ^\n/tmp/tmpjblowaz1.swift:22:26:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            stack.append(ch)\n                         ^\n/tmp/tmpjblowaz1.swift:29:26:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            stack.append(ch)\n                         ^\n"
  stdout: ''
  timestamp: 1660013962
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    func is_nested(string: String) -> Bool {\n    guard let openingBracket = string.rangeOfString(\"\
    [\", options: .LiteralSearch, range: nil, locale: nil) else {\n        return\
    \ false\n    }\n    guard let closingBracket = string.rangeOfString(\"]\", options:\
    \ .LiteralSearch, range: nil, locale: nil) else {\n        return false\n    }\n\
    \    guard let openingBracketIndex = string.index(of: openingBracket, options:\
    \ .Backwards, range: nil, locale: nil) else {\n        return false\n    }\n \
    \   guard let closingBracketIndex = string.index(of: closingBracket, options:\
    \ .Backwards, range: nil, locale: nil) else {\n        return false\n    }\n \
    \   guard let openingBracketIndex = string.index(of: openingBracket, options:\
    \ .Backwards, range: nil, locale: nil) else {\n        return false\n    }\n \
    \   guard let closingBracketIndex = string.index(of: closingBracket, options:\
    \ .Backwards, range: nil, locale: nil) else {\n        return false\n    }\n \
    \   guard let openingBracketIndex = string.index(of: openingBracket, options:\
    \ .Backwards, range: nil, locale: nil) else {\n        return false\n    }\n \
    \   guard let closingBracketIndex = string.index(of: closingBracket, options:\
    \ .Backwards, range: nil, locale: nil) else {\n        return false\n    }\n \
    \   guard let openingBracketIndex = string.index(of: openingBracket, options:\
    \ .Backwards, range: nil, locale: nil) else {\n        return false\n    }\n \
    \   guard let closingBracketIndex = string.index(of: closingBracket, options:\
    \ .Backwards, range: nil, locale: nil) else {\n        return false\n    }\n \
    \   guard let openingBracketIndex = string.index(of: openingBracket, options:\
    \ .Backwards, range: nil, locale: nil) else {\n        return false\n    }\n \
    \   guard let closingBracketIndex = string.index(of: closingBracket, options:\
    \ .Backwards, range: nil, locale: nil) else {\n        return false\n    }\n \
    \   guard let openingBracketIndex = string.index(of: openingBracket, options:\
    \ .Backwards, range: nil, locale: nil) else {\n        return false\n    }\n \
    \   guard let closingBracketIndex = string.index(of: closingBracket, options:\
    \ .Backwards, range: nil, locale: nil) else {\n        return false\n    }\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]][[[[[]\") == false)\nassert(is_nested(string: \"[][]\") == false)\n\
    assert(is_nested(string: \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\"\
    ) == true)\nassert(is_nested(string: \"[]]]]]]]]]]\") == false)\nassert(is_nested(string:\
    \ \"[][][[]]\") == true)\nassert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string:\
    \ \"[]]\") == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmpbdzov6q2.swift:12:39: error: value of type 'String' has no member\
    \ 'rangeOfString'\n    guard let openingBracket = string.rangeOfString(\"[\",\
    \ options: .LiteralSearch, range: nil, locale: nil) else {\n                 \
    \              ~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmpbdzov6q2.swift:12:68: error: cannot\
    \ infer contextual base in reference to member 'LiteralSearch'\n    guard let\
    \ openingBracket = string.rangeOfString(\"[\", options: .LiteralSearch, range:\
    \ nil, locale: nil) else {\n                                                 \
    \                 ~^~~~~~~~~~~~~\n/tmp/tmpbdzov6q2.swift:12:90: error: 'nil' requires\
    \ a contextual type\n    guard let openingBracket = string.rangeOfString(\"[\"\
    , options: .LiteralSearch, range: nil, locale: nil) else {\n                 \
    \                                                                        ^\n/tmp/tmpbdzov6q2.swift:12:103:\
    \ error: 'nil' requires a contextual type\n    guard let openingBracket = string.rangeOfString(\"\
    [\", options: .LiteralSearch, range: nil, locale: nil) else {\n              \
    \                                                                            \
    \            ^\n/tmp/tmpbdzov6q2.swift:15:39: error: value of type 'String' has\
    \ no member 'rangeOfString'\n    guard let closingBracket = string.rangeOfString(\"\
    ]\", options: .LiteralSearch, range: nil, locale: nil) else {\n              \
    \                 ~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmpbdzov6q2.swift:15:68: error: cannot\
    \ infer contextual base in reference to member 'LiteralSearch'\n    guard let\
    \ closingBracket = string.rangeOfString(\"]\", options: .LiteralSearch, range:\
    \ nil, locale: nil) else {\n                                                 \
    \                 ~^~~~~~~~~~~~~\n/tmp/tmpbdzov6q2.swift:15:90: error: 'nil' requires\
    \ a contextual type\n    guard let closingBracket = string.rangeOfString(\"]\"\
    , options: .LiteralSearch, range: nil, locale: nil) else {\n                 \
    \                                                                        ^\n/tmp/tmpbdzov6q2.swift:15:103:\
    \ error: 'nil' requires a contextual type\n    guard let closingBrack"
  stdout: ''
  timestamp: 1660013962
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    func is_nested(string: String) -> Bool {\n    guard let start = string.index(of:\
    \ \"[\"),\n        let end = string.index(of: \"]\"),\n        start != end,\n\
    \        start < string.endIndex\n        else { return false }\n    \n    var\
    \ openingBracketCount = 0\n    var closingBracketCount = 0\n    \n    for index\
    \ in string.indices(of: \"[\") {\n        if let index = string.index(of: \"]\"\
    , range: start..<index) {\n            closingBracketCount += 1\n        }\n \
    \       openingBracketCount += 1\n    }\n    \n    return openingBracketCount\
    \ > closingBracketCount\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(is_nested(string:\
    \ \"[[]]\") == true)\nassert(is_nested(string: \"[]]]]]]][[[[[]\") == false)\n\
    assert(is_nested(string: \"[][]\") == false)\nassert(is_nested(string: \"[]\"\
    ) == false)\nassert(is_nested(string: \"[[[[]]]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]]]]]\") == false)\nassert(is_nested(string: \"[][][[]]\") == true)\n\
    assert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string: \"[]]\"\
    ) == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmpdtrh55gs.swift:12:30: warning: 'index(of:)' is deprecated: renamed\
    \ to 'firstIndex(of:)'\n    guard let start = string.index(of: \"[\"),\n     \
    \                        ^\n/tmp/tmpdtrh55gs.swift:12:30: note: use 'firstIndex(of:)'\
    \ instead\n    guard let start = string.index(of: \"[\"),\n                  \
    \           ^~~~~\n                             firstIndex\n/tmp/tmpdtrh55gs.swift:13:26:\
    \ warning: 'index(of:)' is deprecated: renamed to 'firstIndex(of:)'\n        let\
    \ end = string.index(of: \"]\"),\n                         ^\n/tmp/tmpdtrh55gs.swift:13:26:\
    \ note: use 'firstIndex(of:)' instead\n        let end = string.index(of: \"]\"\
    ),\n                         ^~~~~\n                         firstIndex\n/tmp/tmpdtrh55gs.swift:21:25:\
    \ error: cannot call value of non-function type 'DefaultIndices<String>'\n   \
    \ for index in string.indices(of: \"[\") {\n                        ^\n/tmp/tmpdtrh55gs.swift:22:58:\
    \ error: extra argument 'range' in call\n        if let index = string.index(of:\
    \ \"]\", range: start..<index) {\n                                   ~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013962
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    func is_nested(string: String) -> Bool {\n    guard let start = string.index(of:\
    \ \"[\"), let end = string.index(of: \"]\") else {\n        return false\n   \
    \ }\n    guard let start = string.index(of: \"[\", range: start..<end) else {\n\
    \        return false\n    }\n    guard let end = string.index(of: \"]\", range:\
    \ start..<end) else {\n        return false\n    }\n    guard let start = string.index(of:\
    \ \"[\", range: start..<end) else {\n        return false\n    }\n    guard let\
    \ end = string.index(of: \"]\", range: start..<end) else {\n        return false\n\
    \    }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(is_nested(string:\
    \ \"[[]]\") == true)\nassert(is_nested(string: \"[]]]]]]][[[[[]\") == false)\n\
    assert(is_nested(string: \"[][]\") == false)\nassert(is_nested(string: \"[]\"\
    ) == false)\nassert(is_nested(string: \"[[[[]]]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]]]]]\") == false)\nassert(is_nested(string: \"[][][[]]\") == true)\n\
    assert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string: \"[]]\"\
    ) == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmpfksiybb3.swift:12:30: warning: 'index(of:)' is deprecated: renamed\
    \ to 'firstIndex(of:)'\n    guard let start = string.index(of: \"[\"), let end\
    \ = string.index(of: \"]\") else {\n                             ^\n/tmp/tmpfksiybb3.swift:12:30:\
    \ note: use 'firstIndex(of:)' instead\n    guard let start = string.index(of:\
    \ \"[\"), let end = string.index(of: \"]\") else {\n                         \
    \    ^~~~~\n                             firstIndex\n/tmp/tmpfksiybb3.swift:12:63:\
    \ warning: 'index(of:)' is deprecated: renamed to 'firstIndex(of:)'\n    guard\
    \ let start = string.index(of: \"[\"), let end = string.index(of: \"]\") else\
    \ {\n                                                              ^\n/tmp/tmpfksiybb3.swift:12:63:\
    \ note: use 'firstIndex(of:)' instead\n    guard let start = string.index(of:\
    \ \"[\"), let end = string.index(of: \"]\") else {\n                         \
    \                                     ^~~~~\n                                \
    \                              firstIndex\n/tmp/tmpfksiybb3.swift:15:57: error:\
    \ extra argument 'range' in call\n    guard let start = string.index(of: \"[\"\
    , range: start..<end) else {\n                                  ~~~~~~~~~~~~~~~~~~~~~~^~~~~~~\n\
    /tmp/tmpfksiybb3.swift:18:55: error: extra argument 'range' in call\n    guard\
    \ let end = string.index(of: \"]\", range: start..<end) else {\n             \
    \                   ~~~~~~~~~~~~~~~~~~~~~~^~~~~~~\n/tmp/tmpfksiybb3.swift:21:57:\
    \ error: extra argument 'range' in call\n    guard let start = string.index(of:\
    \ \"[\", range: start..<end) else {\n                                  ~~~~~~~~~~~~~~~~~~~~~~^~~~~~~\n\
    /tmp/tmpfksiybb3.swift:24:55: error: extra argument 'range' in call\n    guard\
    \ let end = string.index(of: \"]\", range: start..<end) else {\n             \
    \                   ~~~~~~~~~~~~~~~~~~~~~~^~~~~~~\n"
  stdout: ''
  timestamp: 1660013962
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    func is_nested(string: String) -> Bool {\n    var stack = [String]()\n    for\
    \ char in string {\n        if char == '[' {\n            stack.append(char)\n\
    \        } else if char == ']' {\n            if stack.count > 0 {\n         \
    \       stack.removeLast()\n            } else {\n                return false\n\
    \            }\n        } else {\n            return false\n        }\n    }\n\
    \    return stack.count == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(is_nested(string:\
    \ \"[[]]\") == true)\nassert(is_nested(string: \"[]]]]]]][[[[[]\") == false)\n\
    assert(is_nested(string: \"[][]\") == false)\nassert(is_nested(string: \"[]\"\
    ) == false)\nassert(is_nested(string: \"[[[[]]]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]]]]]\") == false)\nassert(is_nested(string: \"[][][[]]\") == true)\n\
    assert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string: \"[]]\"\
    ) == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmphpr2olwy.swift:14:20: error: single-quoted string literal found,\
    \ use '\"'\n        if char == '[' {\n                   ^~~\n               \
    \    \"[\"\n/tmp/tmphpr2olwy.swift:16:27: error: single-quoted string literal\
    \ found, use '\"'\n        } else if char == ']' {\n                         \
    \ ^~~\n                          \"]\"\n/tmp/tmphpr2olwy.swift:15:26: error: cannot\
    \ convert value of type 'Character' to expected argument type 'String'\n     \
    \       stack.append(char)\n                         ^\n"
  stdout: ''
  timestamp: 1660013962
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    func is_nested(string: String) -> Bool {\n    let stack = Stack()\n    for char\
    \ in string {\n        if char == '[' {\n            stack.push(char)\n      \
    \  } else if char == ']' {\n            if stack.top() == '[' {\n            \
    \    stack.pop()\n            } else {\n                return false\n       \
    \     }\n        } else {\n            return false\n        }\n    }\n    return\
    \ stack.top() == nil\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(is_nested(string:\
    \ \"[[]]\") == true)\nassert(is_nested(string: \"[]]]]]]][[[[[]\") == false)\n\
    assert(is_nested(string: \"[][]\") == false)\nassert(is_nested(string: \"[]\"\
    ) == false)\nassert(is_nested(string: \"[[[[]]]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]]]]]\") == false)\nassert(is_nested(string: \"[][][[]]\") == true)\n\
    assert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string: \"[]]\"\
    ) == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmpi7w7jz8u.swift:14:20: error: single-quoted string literal found,\
    \ use '\"'\n        if char == '[' {\n                   ^~~\n               \
    \    \"[\"\n/tmp/tmpi7w7jz8u.swift:16:27: error: single-quoted string literal\
    \ found, use '\"'\n        } else if char == ']' {\n                         \
    \ ^~~\n                          \"]\"\n/tmp/tmpi7w7jz8u.swift:17:31: error: single-quoted\
    \ string literal found, use '\"'\n            if stack.top() == '[' {\n      \
    \                        ^~~\n                              \"[\"\n/tmp/tmpi7w7jz8u.swift:12:17:\
    \ error: cannot find 'Stack' in scope\n    let stack = Stack()\n             \
    \   ^~~~~\n"
  stdout: ''
  timestamp: 1660013962
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    func is_nested(string: String) -> Bool {\n    guard let index = string.index(of:\
    \ \"[\"),\n        let end = string.index(of: \"]\", range: start..<string.endIndex)\
    \ else {\n            return false\n    }\n    return string.substring(from: index..<end).count\
    \ > 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(is_nested(string: \"[[]]\"\
    ) == true)\nassert(is_nested(string: \"[]]]]]]][[[[[]\") == false)\nassert(is_nested(string:\
    \ \"[][]\") == false)\nassert(is_nested(string: \"[]\") == false)\nassert(is_nested(string:\
    \ \"[[[[]]]]\") == true)\nassert(is_nested(string: \"[]]]]]]]]]]\") == false)\n\
    assert(is_nested(string: \"[][][[]]\") == true)\nassert(is_nested(string: \"[[]\"\
    ) == false)\nassert(is_nested(string: \"[]]\") == false)\nassert(is_nested(string:\
    \ \"[[]][[\") == true)\nassert(is_nested(string: \"[[][]]\") == true)\nassert(is_nested(string:\
    \ \"\") == false)\nassert(is_nested(string: \"[[[[[[[[\") == false)\nassert(is_nested(string:\
    \ \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmpb5sok88v.swift:12:30: warning: 'index(of:)' is deprecated: renamed\
    \ to 'firstIndex(of:)'\n    guard let index = string.index(of: \"[\"),\n     \
    \                        ^\n/tmp/tmpb5sok88v.swift:12:30: note: use 'firstIndex(of:)'\
    \ instead\n    guard let index = string.index(of: \"[\"),\n                  \
    \           ^~~~~\n                             firstIndex\n/tmp/tmpb5sok88v.swift:13:48:\
    \ error: cannot find 'start' in scope\n        let end = string.index(of: \"]\"\
    , range: start..<string.endIndex) else {\n                                   \
    \            ^~~~~\n/tmp/tmpb5sok88v.swift:13:53: error: extra argument 'range'\
    \ in call\n        let end = string.index(of: \"]\", range: start..<string.endIndex)\
    \ else {\n                              ~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpb5sok88v.swift:16:19: error: value of type 'String' has no member 'substring'\n\
    \    return string.substring(from: index..<end).count > 0\n           ~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013962
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    func is_nested(string: String) -> Bool {\n    guard let open = string.rangeOfString(\"\
    [\", options: .LiteralSearch, range: nil, locale: nil),\n        let close = string.rangeOfString(\"\
    ]\", options: .LiteralSearch, range: nil, locale: nil) else {\n            return\
    \ false\n    }\n    return open < close\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string: \"[]]]]]]][[[[[]\"\
    ) == false)\nassert(is_nested(string: \"[][]\") == false)\nassert(is_nested(string:\
    \ \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]]]]]\") == false)\nassert(is_nested(string: \"[][][[]]\") == true)\n\
    assert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string: \"[]]\"\
    ) == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmp03k83ee4.swift:12:29: error: value of type 'String' has no member\
    \ 'rangeOfString'\n    guard let open = string.rangeOfString(\"[\", options: .LiteralSearch,\
    \ range: nil, locale: nil),\n                     ~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp03k83ee4.swift:12:58:\
    \ error: cannot infer contextual base in reference to member 'LiteralSearch'\n\
    \    guard let open = string.rangeOfString(\"[\", options: .LiteralSearch, range:\
    \ nil, locale: nil),\n                                                       \
    \ ~^~~~~~~~~~~~~\n/tmp/tmp03k83ee4.swift:12:80: error: 'nil' requires a contextual\
    \ type\n    guard let open = string.rangeOfString(\"[\", options: .LiteralSearch,\
    \ range: nil, locale: nil),\n                                                \
    \                               ^\n/tmp/tmp03k83ee4.swift:12:93: error: 'nil'\
    \ requires a contextual type\n    guard let open = string.rangeOfString(\"[\"\
    , options: .LiteralSearch, range: nil, locale: nil),\n                       \
    \                                                                     ^\n/tmp/tmp03k83ee4.swift:13:28:\
    \ error: value of type 'String' has no member 'rangeOfString'\n        let close\
    \ = string.rangeOfString(\"]\", options: .LiteralSearch, range: nil, locale: nil)\
    \ else {\n                    ~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp03k83ee4.swift:13:57:\
    \ error: cannot infer contextual base in reference to member 'LiteralSearch'\n\
    \        let close = string.rangeOfString(\"]\", options: .LiteralSearch, range:\
    \ nil, locale: nil) else {\n                                                 \
    \      ~^~~~~~~~~~~~~\n/tmp/tmp03k83ee4.swift:13:79: error: 'nil' requires a contextual\
    \ type\n        let close = string.rangeOfString(\"]\", options: .LiteralSearch,\
    \ range: nil, locale: nil) else {\n                                          \
    \                                    ^\n/tmp/tmp03k83ee4.swift:13:92: error: 'nil'\
    \ requires a contextual type\n        let close = string.rangeOfString(\"]\",\
    \ options: .LiteralSearch, range: nil, locale: nil) else {\n                 \
    \                                                                          ^\n"
  stdout: ''
  timestamp: 1660013961
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    func is_nested(string: String) -> Bool {\n    var stack = [String]()\n    var\
    \ openingBrackets = 0\n    for ch in string {\n        if ch == '[' {\n      \
    \      stack.append(ch)\n            openingBrackets += 1\n        } else if ch\
    \ == ']' {\n            openingBrackets -= 1\n            if openingBrackets ==\
    \ 0 {\n                stack.removeLast()\n            }\n        } else if openingBrackets\
    \ > 0 {\n            return false\n        }\n    }\n    return openingBrackets\
    \ == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n  \
    \  if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(is_nested(string: \"[[]]\"\
    ) == true)\nassert(is_nested(string: \"[]]]]]]][[[[[]\") == false)\nassert(is_nested(string:\
    \ \"[][]\") == false)\nassert(is_nested(string: \"[]\") == false)\nassert(is_nested(string:\
    \ \"[[[[]]]]\") == true)\nassert(is_nested(string: \"[]]]]]]]]]]\") == false)\n\
    assert(is_nested(string: \"[][][[]]\") == true)\nassert(is_nested(string: \"[[]\"\
    ) == false)\nassert(is_nested(string: \"[]]\") == false)\nassert(is_nested(string:\
    \ \"[[]][[\") == true)\nassert(is_nested(string: \"[[][]]\") == true)\nassert(is_nested(string:\
    \ \"\") == false)\nassert(is_nested(string: \"[[[[[[[[\") == false)\nassert(is_nested(string:\
    \ \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmpj2856jo3.swift:15:18: error: single-quoted string literal found,\
    \ use '\"'\n        if ch == '[' {\n                 ^~~\n                 \"\
    [\"\n/tmp/tmpj2856jo3.swift:18:25: error: single-quoted string literal found,\
    \ use '\"'\n        } else if ch == ']' {\n                        ^~~\n     \
    \                   \"]\"\n/tmp/tmpj2856jo3.swift:16:26: error: cannot convert\
    \ value of type 'Character' to expected argument type 'String'\n            stack.append(ch)\n\
    \                         ^\n"
  stdout: ''
  timestamp: 1660013962
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    func is_nested(string: String) -> Bool {\n    guard let openBracket = string.rangeOfString(\"\
    [\", options: .BackwardsSearch) else { return false }\n    guard let closeBracket\
    \ = string.rangeOfString(\"]\", options: .BackwardsSearch) else { return false\
    \ }\n    guard openBracket.location != closeBracket.location else { return false\
    \ }\n    guard openBracket.location > closeBracket.location else { return false\
    \ }\n    guard openBracket.location < string.count - 1 else { return false }\n\
    \    guard closeBracket.location > string.count - 1 else { return false }\n  \
    \  guard closeBracket.location < openBracket.location else { return false }\n\
    \    guard openBracket.location < closeBracket.location else { return false }\n\
    \    guard openBracket.location != string.count - 1 else { return false }\n  \
    \  guard closeBracket.location != string.count - 1 else { return false }\n   \
    \ guard openBracket.location != closeBracket.location else { return false }\n\
    \    guard openBracket.location != string.count - 1 else { return false }\n  \
    \  guard closeBracket.location != string.count - 1 else { return false }\n   \
    \ guard openBracket.location != closeBracket.location else { return false }\n\
    \    guard openBracket.location != string.count - 1 else { return false }\n  \
    \  guard closeBracket.location != string.count - 1 else { return false }\n   \
    \ guard openBracket.location != closeBracket.location else { return false }\n\
    \    guard openBracket.location != string.count - 1 else { return false }\n  \
    \  guard closeBracket.location != string.count - 1 else { return false }\n   \
    \ guard openBracket.location != closeBracket.location else { return false }\n\
    \    guard openBracket.location != string.count - 1 else { return false }\n  \
    \  guard closeBracket.location != string.count - 1 else { return false }\n   \
    \ guard openBracket.location != closeBracket.location else { return false }\n\
    \    guard openBracket.location != string.count - 1 else { return false }\n  \
    \  guard closeBracket.location != string.count - 1 else { return false }\n   \
    \ guard openBracket.location != closeBracket.location else { return false }\n\
    \    guard openBracket.location != string.count - 1 else { return false }\n  \
    \  guard closeBracket.location != string.count - 1 else { return false }\n\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]][[[[[]\") == false)\nassert(is_nested(string: \"[][]\") == false)\n\
    assert(is_nested(string: \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\"\
    ) == true)\nassert(is_nested(string: \"[]]]]]]]]]]\") == false)\nassert(is_nested(string:\
    \ \"[][][[]]\") == true)\nassert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string:\
    \ \"[]]\") == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmp7mqpjai2.swift:12:36: error: value of type 'String' has no member\
    \ 'rangeOfString'\n    guard let openBracket = string.rangeOfString(\"[\", options:\
    \ .BackwardsSearch) else { return false }\n                            ~~~~~~\
    \ ^~~~~~~~~~~~~\n/tmp/tmp7mqpjai2.swift:12:65: error: cannot infer contextual\
    \ base in reference to member 'BackwardsSearch'\n    guard let openBracket = string.rangeOfString(\"\
    [\", options: .BackwardsSearch) else { return false }\n                      \
    \                                         ~^~~~~~~~~~~~~~~\n/tmp/tmp7mqpjai2.swift:13:37:\
    \ error: value of type 'String' has no member 'rangeOfString'\n    guard let closeBracket\
    \ = string.rangeOfString(\"]\", options: .BackwardsSearch) else { return false\
    \ }\n                             ~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp7mqpjai2.swift:13:66:\
    \ error: cannot infer contextual base in reference to member 'BackwardsSearch'\n\
    \    guard let closeBracket = string.rangeOfString(\"]\", options: .BackwardsSearch)\
    \ else { return false }\n                                                    \
    \            ~^~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013962
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    func is_nested(string: String) -> Bool {\n\tlet openBrackets = string.rangeOfString(\"\
    [\")\n\tlet closeBrackets = string.rangeOfString(\"]\")\n\t\n\tif openBrackets\
    \ == nil || closeBrackets == nil {\n\t\treturn false\n\t}\n\t\n\tlet openBracketsCount\
    \ = openBrackets?.endIndex\n\tlet closeBracketsCount = closeBrackets?.startIndex\n\
    \t\n\tif openBracketsCount == 0 || closeBracketsCount == 0 {\n\t\treturn false\n\
    \t}\n\t\n\tlet openBracketsCount2 = openBrackets?.endIndex\n\tlet closeBracketsCount2\
    \ = closeBrackets?.startIndex\n\t\n\tif openBracketsCount2 == 0 || closeBracketsCount2\
    \ == 0 {\n\t\treturn false\n\t}\n\t\n\tlet openBracketsCount3 = openBrackets?.endIndex\n\
    \tlet closeBracketsCount3 = closeBrackets?.startIndex\n\t\n\tif openBracketsCount3\
    \ == 0 || closeBracketsCount3 == 0 {\n\t\treturn false\n\t}\n\t\n\tlet openBracketsCount4\
    \ = openBrackets?.endIndex\n\tlet closeBracketsCount4 = closeBrackets?.startIndex\n\
    \t\n\tif openBracketsCount4 == 0 || closeBracketsCount4 == 0 {\n\t\treturn false\n\
    \t}\n\t\n\tlet openBracketsCount5 = openBrackets?.endIndex\n\tlet closeBracketsCount5\
    \ = closeBrackets?.startIndex\n\t\n\tif openBracketsCount5 == 0 || closeBracketsCount5\
    \ == 0 {\n\t\treturn false\n\t}\n\t\n\tlet openBracketsCount6 = openBrackets?.endIndex\n\
    \tlet closeBracketsCount6 = closeBrackets?.startIndex\n\t\n\tif openBracketsCount6\
    \ == 0 || closeBracketsCount6 == 0 {\n\t\treturn false\n\t}\n\t\n\tlet openBracketsCount7\
    \ = openBrackets?.endIndex\n\tlet closeBracketsCount7 = closeBrackets?.startIndex\n\
    \t\n\tif openBracketsCount7 == 0 || closeBracketsCount7 == 0 {\n\t\treturn false\n\
    \t}\n\t\n\tlet openBracketsCount8 = openBrackets?.endIndex\n\tlet closeBracketsCount8\
    \ = closeBrackets?.startIndex\n\t\n\tif openBracketsCount8 == 0 || closeBracketsCount8\
    \ == 0 {\n\t\treturn false\n\t}\n\t\n\t\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string: \"[]]]]]]][[[[[]\"\
    ) == false)\nassert(is_nested(string: \"[][]\") == false)\nassert(is_nested(string:\
    \ \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]]]]]\") == false)\nassert(is_nested(string: \"[][][[]]\") == true)\n\
    assert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string: \"[]]\"\
    ) == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmpg64nybfi.swift:12:28: error: value of type 'String' has no member\
    \ 'rangeOfString'\n        let openBrackets = string.rangeOfString(\"[\")\n  \
    \                         ~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmpg64nybfi.swift:13:29:\
    \ error: value of type 'String' has no member 'rangeOfString'\n        let closeBrackets\
    \ = string.rangeOfString(\"]\")\n                            ~~~~~~ ^~~~~~~~~~~~~\n\
    /tmp/tmpg64nybfi.swift:19:40: error: type of expression is ambiguous without more\
    \ context\n        let openBracketsCount = openBrackets?.endIndex\n          \
    \                      ~~~~~~~~~~~~~~^~~~~~~~\n/tmp/tmpg64nybfi.swift:20:42: error:\
    \ type of expression is ambiguous without more context\n        let closeBracketsCount\
    \ = closeBrackets?.startIndex\n                                 ~~~~~~~~~~~~~~~^~~~~~~~~~\n\
    /tmp/tmpg64nybfi.swift:26:41: error: type of expression is ambiguous without more\
    \ context\n        let openBracketsCount2 = openBrackets?.endIndex\n         \
    \                        ~~~~~~~~~~~~~~^~~~~~~~\n/tmp/tmpg64nybfi.swift:27:43:\
    \ error: type of expression is ambiguous without more context\n        let closeBracketsCount2\
    \ = closeBrackets?.startIndex\n                                  ~~~~~~~~~~~~~~~^~~~~~~~~~\n\
    /tmp/tmpg64nybfi.swift:33:41: error: type of expression is ambiguous without more\
    \ context\n        let openBracketsCount3 = openBrackets?.endIndex\n         \
    \                        ~~~~~~~~~~~~~~^~~~~~~~\n/tmp/tmpg64nybfi.swift:34:43:\
    \ error: type of expression is ambiguous without more context\n        let closeBracketsCount3\
    \ = closeBrackets?.startIndex\n                                  ~~~~~~~~~~~~~~~^~~~~~~~~~\n\
    /tmp/tmpg64nybfi.swift:40:41: error: type of expression is ambiguous without more\
    \ context\n        let openBracketsCount4 = openBrackets?.endIndex\n         \
    \                        ~~~~~~~~~~~~~~^~~~~~~~\n/tmp/tmpg64nybfi.swift:41:43:\
    \ error: type of expression is ambiguous without more context\n        let closeBracketsCount4\
    \ = closeBrackets?.startIndex\n                                  ~~~~~~~~~~~~~~~^~~~~~~~~~\n\
    /tmp/tmpg64nybfi.swi"
  stdout: ''
  timestamp: 1660013962
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    func is_nested(string: String) -> Bool {\n    let stack = Stack()\n    for char\
    \ in string {\n        if char == '[' {\n            stack.push(char)\n      \
    \  } else if char == ']' {\n            if stack.top() == '[' {\n            \
    \    stack.pop()\n            } else {\n                return false\n       \
    \     }\n        }\n    }\n    return stack.top() == nil\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]][[[[[]\") == false)\nassert(is_nested(string: \"[][]\") == false)\n\
    assert(is_nested(string: \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\"\
    ) == true)\nassert(is_nested(string: \"[]]]]]]]]]]\") == false)\nassert(is_nested(string:\
    \ \"[][][[]]\") == true)\nassert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string:\
    \ \"[]]\") == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmpzyiji9c1.swift:14:20: error: single-quoted string literal found,\
    \ use '\"'\n        if char == '[' {\n                   ^~~\n               \
    \    \"[\"\n/tmp/tmpzyiji9c1.swift:16:27: error: single-quoted string literal\
    \ found, use '\"'\n        } else if char == ']' {\n                         \
    \ ^~~\n                          \"]\"\n/tmp/tmpzyiji9c1.swift:17:31: error: single-quoted\
    \ string literal found, use '\"'\n            if stack.top() == '[' {\n      \
    \                        ^~~\n                              \"[\"\n/tmp/tmpzyiji9c1.swift:12:17:\
    \ error: cannot find 'Stack' in scope\n    let stack = Stack()\n             \
    \   ^~~~~\n"
  stdout: ''
  timestamp: 1660013961
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    func is_nested(string: String) -> Bool {\n    guard let start = string.index(of:\
    \ \"[\"),\n        let end = string.index(of: \"]\"),\n        start != end,\n\
    \        let start = string.index(of: \"[\", range: start..<end),\n        let\
    \ end = string.index(of: \"]\", range: start..<end),\n        let start = string.index(of:\
    \ \"[\", range: start..<end),\n        let end = string.index(of: \"]\", range:\
    \ start..<end),\n        let start = string.index(of: \"[\", range: start..<end),\n\
    \        let end = string.index(of: \"]\", range: start..<end),\n        let start\
    \ = string.index(of: \"[\", range: start..<end),\n        let end = string.index(of:\
    \ \"]\", range: start..<end),\n        let start = string.index(of: \"[\", range:\
    \ start..<end),\n        let end = string.index(of: \"]\", range: start..<end),\n\
    \        let start = string.index(of: \"[\", range: start..<end),\n        let\
    \ end = string.index(of: \"]\", range: start..<end),\n        let start = string.index(of:\
    \ \"[\", range: start..<end),\n        let end = string.index(of: \"]\", range:\
    \ start..<end),\n        let start = string.index(of: \"[\", range: start..<end),\n\
    \        let end = string.index(of: \"]\", range: start..<end),\n        let start\
    \ = string.index(of: \"[\", range: start..<end),\n        let end = string.index(of:\
    \ \"]\", range: start..<end),\n        let start = string.index(of: \"[\", range:\
    \ start..<end),\n        let end = string.index(of: \"]\", range: start..<end),\n\
    \        let start = string.index(of: \"[\", range: start..<end),\n        let\
    \ end = string.index(of: \"]\", range: start..<end),\n        let start = string.index(of:\
    \ \"[\", range: start..<end),\n        let end = string.index(of: \"]\", range:\
    \ start..<end),\n        let start = string.index(of: \"[\", range: start..<end),\n\
    \        let end = string.index(of: \"]\", range: start..<end),\n        let start\
    \ = string.index(of: \"[\", range: start..<end),\n        let end = string.index(of:\
    \ \"]\", range: start..<end),\n        let start = string.index(of: \"[\", range:\
    \ start..<end),\n        let end = string.index(of: \"]\", range: start..<end),\n\
    \        let start = string.index(of\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string: \"[]]]]]]][[[[[]\"\
    ) == false)\nassert(is_nested(string: \"[][]\") == false)\nassert(is_nested(string:\
    \ \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]]]]]\") == false)\nassert(is_nested(string: \"[][][[]]\") == true)\n\
    assert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string: \"[]]\"\
    ) == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmpcpiqxbwk.swift:46:1: error: expected ')' in expression list\n}\n\
    ^\n/tmp/tmpcpiqxbwk.swift:45:33: note: to match this opening '('\n        let\
    \ start = string.index(of\n                                ^\n/tmp/tmpcpiqxbwk.swift:45:36:\
    \ error: expected 'else' after 'guard' condition\n        let start = string.index(of\n\
    \                                   ^\n/tmp/tmpcpiqxbwk.swift:12:30: warning:\
    \ 'index(of:)' is deprecated: renamed to 'firstIndex(of:)'\n    guard let start\
    \ = string.index(of: \"[\"),\n                             ^\n/tmp/tmpcpiqxbwk.swift:12:30:\
    \ note: use 'firstIndex(of:)' instead\n    guard let start = string.index(of:\
    \ \"[\"),\n                             ^~~~~\n                             firstIndex\n\
    /tmp/tmpcpiqxbwk.swift:13:26: warning: 'index(of:)' is deprecated: renamed to\
    \ 'firstIndex(of:)'\n        let end = string.index(of: \"]\"),\n            \
    \             ^\n/tmp/tmpcpiqxbwk.swift:13:26: note: use 'firstIndex(of:)' instead\n\
    \        let end = string.index(of: \"]\"),\n                         ^~~~~\n\
    \                         firstIndex\n/tmp/tmpcpiqxbwk.swift:15:55: error: extra\
    \ argument 'range' in call\n        let start = string.index(of: \"[\", range:\
    \ start..<end),\n                                ~~~~~~~~~~~~~~~~~~~~~~^~~~~~~\n\
    /tmp/tmpcpiqxbwk.swift:16:53: error: extra argument 'range' in call\n        let\
    \ end = string.index(of: \"]\", range: start..<end),\n                       \
    \       ~~~~~~~~~~~~~~~~~~~~~~^~~~~~~\n/tmp/tmpcpiqxbwk.swift:17:55: error: extra\
    \ argument 'range' in call\n        let start = string.index(of: \"[\", range:\
    \ start..<end),\n                                ~~~~~~~~~~~~~~~~~~~~~~^~~~~~~\n\
    /tmp/tmpcpiqxbwk.swift:18:53: error: extra argument 'range' in call\n        let\
    \ end = string.index(of: \"]\", range: start..<end),\n                       \
    \       ~~~~~~~~~~~~~~~~~~~~~~^~~~~~~\n/tmp/tmpcpiqxbwk.swift:19:55: error: extra\
    \ argument 'range' in call\n        let start = string.index(of: \"[\", range:\
    \ start..<end),\n                                ~~~~~~~~~~~~~~~~~~~~~~^~~~~~~\n\
    /tmp/tmpcpiqxbwk.swift:20:53: error: extr"
  stdout: ''
  timestamp: 1660013962
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    func is_nested(string: String) -> Bool {\n    let brackets = string.unicodeScalars.filter\
    \ { $0.isBr }\n    \n    if brackets.count < 1 {\n        return false\n    }\n\
    \    \n    let openingBrackets = brackets.filter { $0.isBr }\n    \n    if openingBrackets.count\
    \ < 1 {\n        return false\n    }\n    \n    let closingBrackets = brackets.filter\
    \ { !$0.isBr }\n    \n    if closingBrackets.count < 1 {\n        return false\n\
    \    }\n    \n    let openingBracketsCount = openingBrackets.count\n    let closingBracketsCount\
    \ = closingBrackets.count\n    \n    if openingBracketsCount != closingBracketsCount\
    \ {\n        return false\n    }\n    \n    let openingBracketsString = openingBrackets.map\
    \ { $0.value }\n    let closingBracketsString = closingBrackets.map { $0.value\
    \ }\n    \n    let openingBracketsStringCount = openingBracketsString.count\n\
    \    let closingBracketsStringCount = closingBracketsString.count\n    \n    if\
    \ openingBracketsStringCount != closingBracketsStringCount {\n        return false\n\
    \    }\n    \n    let openingBracketsStringSet = Set(openingBracketsString)\n\
    \    let closingBracketsStringSet = Set(closingBracketsString)\n    \n    if openingBracketsStringSet.count\
    \ != closingBracketsStringSet.count {\n        return false\n    }\n    \n   \
    \ let openingBracketsStringSetCount = openingBracketsStringSet.count\n    let\
    \ closingBracketsStringSetCount = closingBracketsStringSet.count\n    \n    if\
    \ openingBracketsStringSetCount != closingBracketsStringSetCount {\n        return\
    \ false\n    }\n    \n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string: \"[]]]]]]][[[[[]\"\
    ) == false)\nassert(is_nested(string: \"[][]\") == false)\nassert(is_nested(string:\
    \ \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]]]]]\") == false)\nassert(is_nested(string: \"[][][[]]\") == true)\n\
    assert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string: \"[]]\"\
    ) == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmpfoxn2a3j.swift:12:54: error: value of type 'Unicode.Scalar' has\
    \ no member 'isBr'\n    let brackets = string.unicodeScalars.filter { $0.isBr\
    \ }\n                                                  ~~ ^~~~\n"
  stdout: ''
  timestamp: 1660013962
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    func is_nested(string: String) -> Bool {\n    guard let openBracket = string.rangeOfString(\"\
    [\", options: .BackwardsSearch) else { return false }\n    guard let closeBracket\
    \ = string.rangeOfString(\"]\", options: .BackwardsSearch) else { return false\
    \ }\n    guard openBracket.location != closeBracket.location else { return false\
    \ }\n    guard openBracket.location > closeBracket.location else { return false\
    \ }\n    guard openBracket.location < string.endIndex else { return false }\n\
    \    guard closeBracket.location > string.endIndex else { return false }\n   \
    \ guard closeBracket.location < openBracket.location else { return false }\n \
    \   guard openBracket.location != string.startIndex else { return false }\n  \
    \  guard closeBracket.location != string.startIndex else { return false }\n  \
    \  guard openBracket.location != string.endIndex else { return false }\n    guard\
    \ closeBracket.location != string.endIndex else { return false }\n    guard openBracket.location\
    \ != string.startIndex else { return false }\n    guard closeBracket.location\
    \ != string.startIndex else { return false }\n    guard openBracket.location !=\
    \ string.endIndex else { return false }\n    guard closeBracket.location != string.endIndex\
    \ else { return false }\n    return true\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string: \"[]]]]]]][[[[[]\"\
    ) == false)\nassert(is_nested(string: \"[][]\") == false)\nassert(is_nested(string:\
    \ \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]]]]]\") == false)\nassert(is_nested(string: \"[][][[]]\") == true)\n\
    assert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string: \"[]]\"\
    ) == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmp__ivyku4.swift:12:36: error: value of type 'String' has no member\
    \ 'rangeOfString'\n    guard let openBracket = string.rangeOfString(\"[\", options:\
    \ .BackwardsSearch) else { return false }\n                            ~~~~~~\
    \ ^~~~~~~~~~~~~\n/tmp/tmp__ivyku4.swift:12:65: error: cannot infer contextual\
    \ base in reference to member 'BackwardsSearch'\n    guard let openBracket = string.rangeOfString(\"\
    [\", options: .BackwardsSearch) else { return false }\n                      \
    \                                         ~^~~~~~~~~~~~~~~\n/tmp/tmp__ivyku4.swift:13:37:\
    \ error: value of type 'String' has no member 'rangeOfString'\n    guard let closeBracket\
    \ = string.rangeOfString(\"]\", options: .BackwardsSearch) else { return false\
    \ }\n                             ~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp__ivyku4.swift:13:66:\
    \ error: cannot infer contextual base in reference to member 'BackwardsSearch'\n\
    \    guard let closeBracket = string.rangeOfString(\"]\", options: .BackwardsSearch)\
    \ else { return false }\n                                                    \
    \            ~^~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013962
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    func is_nested(string: String) -> Bool {\n\tlet stack = Stack()\n\tlet openingBrackets\
    \ = [String]()\n\tlet closingBrackets = [String]()\n\tlet openingBracketCount\
    \ = 1\n\tlet closingBracketCount = 1\n\t\n\tlet openingBracket = CharacterSet.openingBrackets\n\
    \tlet closingBracket = CharacterSet.closingBrackets\n\t\n\tlet characterSet =\
    \ CharacterSet(charactersIn: string)\n\t\n\tlet openingBracketSet = CharacterSet(charactersIn:\
    \ openingBracket)\n\tlet closingBracketSet = CharacterSet(charactersIn: closingBracket)\n\
    \t\n\tlet openingBracketRange = NSRange(location: openingBracketSet.location(in:\
    \ string), length: openingBracketSet.count(in: string))\n\tlet closingBracketRange\
    \ = NSRange(location: closingBracketSet.location(in: string), length: closingBracketSet.count(in:\
    \ string))\n\t\n\tlet openingBracketRangeCount = openingBracketRange.length\n\t\
    let closingBracketRangeCount = closingBracketRange.length\n\t\n\tlet openingBracketRangeLocation\
    \ = openingBracketRange.location\n\tlet closingBracketRangeLocation = closingBracketRange.location\n\
    \t\n\tlet openingBracketRangeEnd = openingBracketRange.location\n\tlet closingBracketRangeEnd\
    \ = closingBracketRange.location\n\t\n\tlet openingBracketRangeLocation = openingBracketRange.location\n\
    \tlet closingBracketRangeLocation = closingBracketRange.location\n\t\n\tlet openingBracketRangeEnd\
    \ = openingBracketRange.location\n\tlet closingBracketRangeEnd = closingBracketRange.location\n\
    \t\n\tlet openingBracketRangeLocation = openingBracketRange.location\n\tlet closingBracketRangeLocation\
    \ = closingBracketRange.location\n\t\n\tlet openingBracketRangeEnd = openingBracketRange.location\n\
    \tlet closingBracketRangeEnd = closingBracketRange.location\n\t\n\tlet openingBracketRangeLocation\
    \ = openingBracketRange.location\n\tlet closingBracketRangeLocation = closingBracketRange.location\n\
    \t\n\tlet openingBracketRangeEnd = openingBracketRange.location\n\tlet closingBracketRangeEnd\
    \ = closingBracketRange.location\n\t\n\tlet openingBracketRangeLocation = openingBracketRange.location\n\
    \tlet closingBracketRangeLocation = closingBracketRange.location\n\t\n\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]][[[[[]\") == false)\nassert(is_nested(string: \"[][]\") == false)\n\
    assert(is_nested(string: \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\"\
    ) == true)\nassert(is_nested(string: \"[]]]]]]]]]]\") == false)\nassert(is_nested(string:\
    \ \"[][][[]]\") == true)\nassert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string:\
    \ \"[]]\") == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmpqf1kxl1e.swift:12:14: error: cannot find 'Stack' in scope\n   \
    \     let stack = Stack()\n                    ^~~~~\n/tmp/tmpqf1kxl1e.swift:18:23:\
    \ error: cannot find 'CharacterSet' in scope\n        let openingBracket = CharacterSet.openingBrackets\n\
    \                             ^~~~~~~~~~~~\n/tmp/tmpqf1kxl1e.swift:19:23: error:\
    \ cannot find 'CharacterSet' in scope\n        let closingBracket = CharacterSet.closingBrackets\n\
    \                             ^~~~~~~~~~~~\n/tmp/tmpqf1kxl1e.swift:21:21: error:\
    \ cannot find 'CharacterSet' in scope\n        let characterSet = CharacterSet(charactersIn:\
    \ string)\n                           ^~~~~~~~~~~~\n/tmp/tmpqf1kxl1e.swift:23:26:\
    \ error: cannot find 'CharacterSet' in scope\n        let openingBracketSet =\
    \ CharacterSet(charactersIn: openingBracket)\n                               \
    \ ^~~~~~~~~~~~\n/tmp/tmpqf1kxl1e.swift:24:26: error: cannot find 'CharacterSet'\
    \ in scope\n        let closingBracketSet = CharacterSet(charactersIn: closingBracket)\n\
    \                                ^~~~~~~~~~~~\n/tmp/tmpqf1kxl1e.swift:26:28: error:\
    \ cannot find 'NSRange' in scope\n        let openingBracketRange = NSRange(location:\
    \ openingBracketSet.location(in: string), length: openingBracketSet.count(in:\
    \ string))\n                                  ^~~~~~~\n/tmp/tmpqf1kxl1e.swift:27:28:\
    \ error: cannot find 'NSRange' in scope\n        let closingBracketRange = NSRange(location:\
    \ closingBracketSet.location(in: string), length: closingBracketSet.count(in:\
    \ string))\n                                  ^~~~~~~\n"
  stdout: ''
  timestamp: 1660013962
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    func is_nested(string: String) -> Bool {\n    \n    var stack = [String]()\n \
    \   var openBrackets = 0\n    var closeBrackets = 0\n    \n    for character in\
    \ string {\n        if character == '[' {\n            openBrackets += 1\n   \
    \         stack.append(character)\n        } else if character == ']' {\n    \
    \        closeBrackets += 1\n            stack.removeLast()\n            if stack.count\
    \ == 0 {\n                return false\n            }\n        } else if character\
    \ == ']' && openBrackets > 0 && closeBrackets > 0 {\n            openBrackets\
    \ -= 1\n            closeBrackets -= 1\n        }\n    }\n    return openBrackets\
    \ == 0 && closeBrackets == 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(is_nested(string:\
    \ \"[[]]\") == true)\nassert(is_nested(string: \"[]]]]]]][[[[[]\") == false)\n\
    assert(is_nested(string: \"[][]\") == false)\nassert(is_nested(string: \"[]\"\
    ) == false)\nassert(is_nested(string: \"[[[[]]]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]]]]]\") == false)\nassert(is_nested(string: \"[][][[]]\") == true)\n\
    assert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string: \"[]]\"\
    ) == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmpmwnesu2j.swift:18:25: error: single-quoted string literal found,\
    \ use '\"'\n        if character == '[' {\n                        ^~~\n     \
    \                   \"[\"\n/tmp/tmpmwnesu2j.swift:21:32: error: single-quoted\
    \ string literal found, use '\"'\n        } else if character == ']' {\n     \
    \                          ^~~\n                               \"]\"\n/tmp/tmpmwnesu2j.swift:27:32:\
    \ error: single-quoted string literal found, use '\"'\n        } else if character\
    \ == ']' && openBrackets > 0 && closeBrackets > 0 {\n                        \
    \       ^~~\n                               \"]\"\n/tmp/tmpmwnesu2j.swift:20:26:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            stack.append(character)\n                         ^\n"
  stdout: ''
  timestamp: 1660013962
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    func is_nested(string: String) -> Bool {\n\tlet brackets = string.unicodeScalars\n\
    \tlet openingBrackets = brackets.filter({ $0.isOpen })\n\tlet closingBrackets\
    \ = brackets.filter({ $0.isClosing })\n\tlet openingBracketCount = openingBrackets.count\n\
    \tlet closingBracketCount = closingBrackets.count\n\t\n\treturn openingBracketCount\
    \ == closingBracketCount\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(is_nested(string:\
    \ \"[[]]\") == true)\nassert(is_nested(string: \"[]]]]]]][[[[[]\") == false)\n\
    assert(is_nested(string: \"[][]\") == false)\nassert(is_nested(string: \"[]\"\
    ) == false)\nassert(is_nested(string: \"[[[[]]]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]]]]]\") == false)\nassert(is_nested(string: \"[][][[]]\") == true)\n\
    assert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string: \"[]]\"\
    ) == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmp4t7cl7vk.swift:13:45: error: value of type 'Unicode.Scalar' has\
    \ no member 'isOpen'\n        let openingBrackets = brackets.filter({ $0.isOpen\
    \ })\n                                                ~~ ^~~~~~\n/tmp/tmp4t7cl7vk.swift:14:45:\
    \ error: value of type 'Unicode.Scalar' has no member 'isClosing'\n        let\
    \ closingBrackets = brackets.filter({ $0.isClosing })\n                      \
    \                          ~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013962
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    func is_nested(string: String) -> Bool {\n    let stack = Stack<String>()\n  \
    \  for character in string {\n        if character == '[' {\n            stack.push(character)\n\
    \        } else if character == ']' {\n            if stack.count > 0 {\n    \
    \            stack.pop()\n            } else {\n                return false\n\
    \            }\n        }\n    }\n    return stack.count == 0\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]][[[[[]\") == false)\nassert(is_nested(string: \"[][]\") == false)\n\
    assert(is_nested(string: \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\"\
    ) == true)\nassert(is_nested(string: \"[]]]]]]]]]]\") == false)\nassert(is_nested(string:\
    \ \"[][][[]]\") == true)\nassert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string:\
    \ \"[]]\") == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmpzbivf8jl.swift:14:25: error: single-quoted string literal found,\
    \ use '\"'\n        if character == '[' {\n                        ^~~\n     \
    \                   \"[\"\n/tmp/tmpzbivf8jl.swift:16:32: error: single-quoted\
    \ string literal found, use '\"'\n        } else if character == ']' {\n     \
    \                          ^~~\n                               \"]\"\n/tmp/tmpzbivf8jl.swift:12:17:\
    \ error: cannot find 'Stack' in scope\n    let stack = Stack<String>()\n     \
    \           ^~~~~\n"
  stdout: ''
  timestamp: 1660013961
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    func is_nested(string: String) -> Bool {\n    \n    // Initialize a stack to store\
    \ brackets\n    var stack = [Character]()\n    \n    // Iterate over input string\n\
    \    for char in string {\n        \n        // If current character is opening,\
    \ push it to the stack\n        if char == '[' {\n            stack.append(char)\n\
    \        \n        // If current character is closing, pop from the stack\n  \
    \      } else if char == ']' {\n            \n            // If stack is empty,\
    \ return false\n            if stack.count == 0 {\n                return false\n\
    \            }\n            \n            // Pop from the stack\n            stack.removeLast()\n\
    \        }\n    }\n    \n    // If stack is empty, return false\n    if stack.count\
    \ == 0 {\n        return false\n    }\n    \n    // Otherwise, return true\n \
    \   return true\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(is_nested(string:\
    \ \"[[]]\") == true)\nassert(is_nested(string: \"[]]]]]]][[[[[]\") == false)\n\
    assert(is_nested(string: \"[][]\") == false)\nassert(is_nested(string: \"[]\"\
    ) == false)\nassert(is_nested(string: \"[[[[]]]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]]]]]\") == false)\nassert(is_nested(string: \"[][][[]]\") == true)\n\
    assert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string: \"[]]\"\
    ) == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmpasfpcl3y.swift:20:20: error: single-quoted string literal found,\
    \ use '\"'\n        if char == '[' {\n                   ^~~\n               \
    \    \"[\"\n/tmp/tmpasfpcl3y.swift:24:27: error: single-quoted string literal\
    \ found, use '\"'\n        } else if char == ']' {\n                         \
    \ ^~~\n                          \"]\"\n"
  stdout: ''
  timestamp: 1660013962
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    func is_nested(string: String) -> Bool {\n    guard let open = string.rangeOfString(\"\
    [\", options: .LiteralSearch, range: nil, locale: nil),\n        let close = string.rangeOfString(\"\
    ]\", options: .LiteralSearch, range: nil, locale: nil) else {\n            return\
    \ false\n    }\n    return open < close && close > open\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]][[[[[]\") == false)\nassert(is_nested(string: \"[][]\") == false)\n\
    assert(is_nested(string: \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\"\
    ) == true)\nassert(is_nested(string: \"[]]]]]]]]]]\") == false)\nassert(is_nested(string:\
    \ \"[][][[]]\") == true)\nassert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string:\
    \ \"[]]\") == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmp1kfct1bz.swift:12:29: error: value of type 'String' has no member\
    \ 'rangeOfString'\n    guard let open = string.rangeOfString(\"[\", options: .LiteralSearch,\
    \ range: nil, locale: nil),\n                     ~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp1kfct1bz.swift:12:58:\
    \ error: cannot infer contextual base in reference to member 'LiteralSearch'\n\
    \    guard let open = string.rangeOfString(\"[\", options: .LiteralSearch, range:\
    \ nil, locale: nil),\n                                                       \
    \ ~^~~~~~~~~~~~~\n/tmp/tmp1kfct1bz.swift:12:80: error: 'nil' requires a contextual\
    \ type\n    guard let open = string.rangeOfString(\"[\", options: .LiteralSearch,\
    \ range: nil, locale: nil),\n                                                \
    \                               ^\n/tmp/tmp1kfct1bz.swift:12:93: error: 'nil'\
    \ requires a contextual type\n    guard let open = string.rangeOfString(\"[\"\
    , options: .LiteralSearch, range: nil, locale: nil),\n                       \
    \                                                                     ^\n/tmp/tmp1kfct1bz.swift:13:28:\
    \ error: value of type 'String' has no member 'rangeOfString'\n        let close\
    \ = string.rangeOfString(\"]\", options: .LiteralSearch, range: nil, locale: nil)\
    \ else {\n                    ~~~~~~ ^~~~~~~~~~~~~\n/tmp/tmp1kfct1bz.swift:13:57:\
    \ error: cannot infer contextual base in reference to member 'LiteralSearch'\n\
    \        let close = string.rangeOfString(\"]\", options: .LiteralSearch, range:\
    \ nil, locale: nil) else {\n                                                 \
    \      ~^~~~~~~~~~~~~\n/tmp/tmp1kfct1bz.swift:13:79: error: 'nil' requires a contextual\
    \ type\n        let close = string.rangeOfString(\"]\", options: .LiteralSearch,\
    \ range: nil, locale: nil) else {\n                                          \
    \                                    ^\n/tmp/tmp1kfct1bz.swift:13:92: error: 'nil'\
    \ requires a contextual type\n        let close = string.rangeOfString(\"]\",\
    \ options: .LiteralSearch, range: nil, locale: nil) else {\n                 \
    \                                                                          ^\n"
  stdout: ''
  timestamp: 1660013962
- exit_code: 1
  program: "\n/// Create a function that takes a string as input which contains only\
    \ square brackets.\n/// The function should return True if and only if there is\
    \ a valid subsequence of brackets \n/// where at least one bracket in the subsequence\
    \ is nested.\n/// is_nested('[[]]') \u279E True\n/// is_nested('[]]]]]]][[[[[]')\
    \ \u279E False\n/// is_nested('[][]') \u279E False\n/// is_nested('[]') \u279E\
    \ False\n/// is_nested('[[][]]') \u279E True\n/// is_nested('[[]][[') \u279E True\n\
    func is_nested(string: String) -> Bool {\n\tlet openingBrackets = string.unicodeScalars.filter({\
    \ $0.isOpen })\n\tlet closingBrackets = string.unicodeScalars.filter({ $0.isClosing\
    \ })\n\t\n\treturn openingBrackets.count >= closingBrackets.count\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(is_nested(string: \"[[]]\") == true)\nassert(is_nested(string:\
    \ \"[]]]]]]][[[[[]\") == false)\nassert(is_nested(string: \"[][]\") == false)\n\
    assert(is_nested(string: \"[]\") == false)\nassert(is_nested(string: \"[[[[]]]]\"\
    ) == true)\nassert(is_nested(string: \"[]]]]]]]]]]\") == false)\nassert(is_nested(string:\
    \ \"[][][[]]\") == true)\nassert(is_nested(string: \"[[]\") == false)\nassert(is_nested(string:\
    \ \"[]]\") == false)\nassert(is_nested(string: \"[[]][[\") == true)\nassert(is_nested(string:\
    \ \"[[][]]\") == true)\nassert(is_nested(string: \"\") == false)\nassert(is_nested(string:\
    \ \"[[[[[[[[\") == false)\nassert(is_nested(string: \"]]]]]]]]\") == false)"
  status: SyntaxError
  stderr: "/tmp/tmps7sg97r3.swift:12:58: error: value of type 'Unicode.Scalar' has\
    \ no member 'isOpen'\n        let openingBrackets = string.unicodeScalars.filter({\
    \ $0.isOpen })\n                                                             ~~\
    \ ^~~~~~\n/tmp/tmps7sg97r3.swift:13:58: error: value of type 'Unicode.Scalar'\
    \ has no member 'isClosing'\n        let closingBrackets = string.unicodeScalars.filter({\
    \ $0.isClosing })\n                                                          \
    \   ~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1660013962
