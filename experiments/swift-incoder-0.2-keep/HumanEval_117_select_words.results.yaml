language: swift
name: HumanEval_117_select_words
results:
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"\
    ]\n/// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n\
    /// select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfunc\
    \ select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    var count = 0\n    for letter in s.characters {\n        if letter == \"\
    \ \" {\n            if count == n {\n                result.append(\"\\n\")\n\
    \                count = 0\n            } else {\n                count += 1\n\
    \            }\n        } else {\n            if count == n {\n              \
    \  result.append(\"\\n\")\n                count = 0\n            }\n        \
    \    result.append(String(letter))\n            count += 1\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"\
    Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary\
    \ had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpewj8aesy.swift:16:21: error: 'characters' is unavailable: Please\
    \ use String directly\n    for letter in s.characters {\n                    ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660014410
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"\
    ]\n/// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n\
    /// select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfunc\
    \ select_words(s: String, n: Int) -> [String] {\n    var words = [String]()\n\
    \    \n    if s == \"\" {\n        return words\n    }\n    \n    var i = 0\n\
    \    var j = 0\n    \n    while i < s.count {\n        if s[i] == \" \" {\n  \
    \          i += 1\n            continue\n        }\n        \n        if s[i]\
    \ == \" \" {\n            i += 1\n            continue\n        }\n        \n\
    \        if s[i] == \"a\" || s[i] == \"e\" || s[i] == \"i\" || s[i] == \"o\" ||\
    \ s[i] == \"u\" {\n            i += 1\n            continue\n        }\n     \
    \   \n        if s[i] == \"b\" || s[i] == \"c\" || s[i] == \"d\" || s[i] == \"\
    f\" || s[i] == \"g\" || s[i] == \"h\" || s[i] == \"j\" || s[i] == \"k\" || s[i]\
    \ == \"l\" || s[i] == \"m\" || s[i] == \"n\" || s[i] == \"p\" || s[i] == \"q\"\
    \ || s[i] == \"r\" || s[i] == \"s\" || s[i] == \"t\" || s[i] == \"v\" || s[i]\
    \ == \"w\" || s[i] == \"x\" || s[i] == \"y\" || s[i] == \"z\" {\n            i\
    \ += 1\n            continue\n        }\n        \n        if s[i] == \"A\" ||\
    \ s[i] == \"E\" || s[i] == \"I\" || s[i] == \"O\" || s[i] == \"U\" {\n       \
    \     i += 1\n            continue\n        }\n        \n        if s[i] == \"\
    B\" || s[i] == \"C\" || s[i] == \"D\" || s[i] == \"F\" || s[i] == \"G\" || s[i]\
    \ == \"H\" || s[i] == \"J\" || s[i] == \"K\" || s[i] == \"L\" || s[i] == \"M\"\
    \ || s[i] == \"N\" || s[i] == \"P\" || s[i] == \"Q\" || s[i] == \"R\" || s[i]\
    \ == \"S\" || s[i] == \"T\" || s[i] == \"V\" || s[i] == \"W\" || s[i] == \"X\"\
    \ || s[i] == \"Y\" || s[i] == \"Z\" {\n            i += 1\n            continue\n\
    \        }\n        \n        if s[i] == \"0\" {\n            i += 1\n       \
    \     continue\n        }\n        \n        if s[i] == \"1\" {\n            i\
    \ += 1\n            continue\n        }\n        \n        if s[i] == \"2\" {\n\
    \            i += 1\n            continue\n        }\n        \n        if s[i]\
    \ == \"3\" {\n            i += 1\n            continue\n        }\n        \n\
    \        if s[i] == \"4\" {\n            i += 1\n            continue\n      \
    \  }\n        \n        if s[i] == \"5\" {\n            i += 1\n            continue\n\
    \        }\n        \n        if s[i] == \"6\" {\n            i += 1\n       \
    \     continue\n        }\n        \n        if s[i] == \"7\" {\n            i\
    \ += 1\n            continue\n        }\n        \n        if s[i] == \"8\" {\n\
    \            i += 1\n            continue\n        }\n        \n        if s[i]\
    \ == \"9\" {\n            i += 1\n            continue\n        }\n        \n\
    \        if s[i] == \"!\" {\n            i += 1\n            continue\n      \
    \  }\n        \n        if s[i] == \"?\" {\n            i += 1\n            continue\n\
    \        }\n        \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s:\
    \ \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"\
    Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmphp2jd1c2.swift:135:69: error: expected '}' at end of brace statement\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])\n\
    \                                                                    ^\n/tmp/tmphp2jd1c2.swift:13:50:\
    \ note: to match this opening '{'\nfunc select_words(s: String, n: Int) -> [String]\
    \ {\n                                                 ^\n/tmp/tmphp2jd1c2.swift:24:12:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if s[i] == \" \" {\n           ^~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmphp2jd1c2.swift:29:12:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if s[i] == \" \" {\n           ^~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmphp2jd1c2.swift:34:12:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if s[i] == \"a\" || s[i] == \"e\" || s[i]\
    \ == \"i\" || s[i] == \"o\" || s[i] == \"u\" {\n           ^~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmphp2jd1c2.swift:34:27:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if s[i] == \"a\" || s[i] == \"e\" || s[i]\
    \ == \"i\" || s[i] == \"o\" || s[i] == \"u\" {\n                          ^~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmphp2jd1c2.swift:34:42:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if s[i] == \"a\" || s[i] == \"e\" || s[i]\
    \ == \"i\" || s[i] == \"o\" || s[i] == \"u\" {\n                      "
  stdout: ''
  timestamp: 1660014411
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"\
    ]\n/// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n\
    /// select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfunc\
    \ select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    \n    if s == \"\" {\n        return result\n    }\n    \n    var i = 0\n\
    \    var j = 0\n    var k = 0\n    \n    for i < s.count {\n        if s[i] ==\
    \ \" \" {\n            j = i\n            \n            while j < s.count && s[j]\
    \ == \" \" {\n                j += 1\n            }\n            \n          \
    \  if j == s.count {\n                result.append(\"\\n\")\n            }\n\
    \            \n            k = i\n            \n            while k < s.count\
    \ && s[k] != \" \" {\n                k += 1\n            }\n            \n  \
    \          if k == s.count {\n                result.append(\"\\n\")\n       \
    \     }\n            \n            while k < s.count && s[k] == \" \" {\n    \
    \            k += 1\n            }\n            \n            if k == s.count\
    \ {\n                result.append(\"\\n\")\n            }\n            \n   \
    \         i = k\n        }\n        \n        if s[i] == \" \" {\n           \
    \ j = i\n            \n            while j < s.count && s[j] != \" \" {\n    \
    \            j += 1\n            }\n            \n            if j == s.count\
    \ {\n                result.append(\"\\n\")\n            }\n            \n   \
    \         k = i\n            \n            while k < s.count && s[k] != \" \"\
    \ {\n                k += 1\n            }\n            \n            if k ==\
    \ s.count {\n                result.append(\"\\n\")\n            }\n         \
    \   \n            while k < s.count && s[k] == \" \" {\n                k += 1\n\
    \            }\n            \n            if k == s.count {\n                result.append(\"\
    \\n\")\n            }\n            \n            i = k\n        }\n        \n\
    \        if s[i] == \" \" {\n            j = i\n            \n            while\
    \ j < s.count && s[j] != \" \" {\n                j += 1\n            }\n    \
    \        \n            if j == s.count {\n                result.append(\"\\n\"\
    )\n            }\n            \n            k = i\n            \n            while\
    \ k < s.count && s[k] != \" \" {\n                k += 1\n            }\n    \
    \        \n            if k == s.count {\n                result.append(\"\\n\"\
    )\n            }\n            \n            while k < s.count && s[k] == \" \"\
    \ {\n                k += 1\n            }\n            \n            if k ==\
    \ s.count {\n                result.append(\"\\n\")\n            }\n         \
    \   \n            i = k\n        }\n        \n        if s[i] == \" \" {\n   \
    \         j = i\n            \n            while j < s.count && s[j] != \" \"\
    \ {\n                j += 1\n            }\n            \n            if j ==\
    \ s.count {\n                result.append(\"\\n\")\n            }\n         \
    \   \n            k = i\n            \n            while k < s.count && s[k] !=\
    \ \" \" {\n                k += 1\n            }\n            \n            if\
    \ k == s.\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary\
    \ had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had\
    \ a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple\
    \ white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\"\
    , n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"\
    ])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s:\
    \ \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmp7pakkbu3.swift:24:11: error: expected 'in' after for-each pattern\n\
    \    for i < s.count {\n          ^\n/tmp/tmp7pakkbu3.swift:24:11: error: unary\
    \ operator cannot be separated from its operand\n    for i < s.count {\n     \
    \     ^~\n           \n/tmp/tmp7pakkbu3.swift:138:22: error: expected member name\
    \ following '.'\n            if k == s.\n                     ^\n/tmp/tmp7pakkbu3.swift:138:23:\
    \ error: expected '{' after 'if' condition\n            if k == s.\n         \
    \             ^\n/tmp/tmp7pakkbu3.swift:160:69: error: expected '}' at end of\
    \ brace statement\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])\n                                                        \
    \            ^\n/tmp/tmp7pakkbu3.swift:24:21: note: to match this opening '{'\n\
    \    for i < s.count {\n                    ^\n/tmp/tmp7pakkbu3.swift:160:69:\
    \ error: expected '}' at end of brace statement\nassert(select_words(s: \"a b\
    \ c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])\n                        \
    \                                            ^\n/tmp/tmp7pakkbu3.swift:13:50:\
    \ note: to match this opening '{'\nfunc select_words(s: String, n: Int) -> [String]\
    \ {\n                                                 ^\n/tmp/tmp7pakkbu3.swift:24:11:\
    \ error: '<' is not a prefix unary operator\n    for i < s.count {\n         \
    \ ^\n"
  stdout: ''
  timestamp: 1660014410
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"\
    ]\n/// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n\
    /// select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfunc\
    \ select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    var count = 0\n    for letter in s {\n        if letter == \" \" {\n    \
    \        count += 1\n            if count == n {\n                result.append(letter)\n\
    \                count = 0\n            }\n        } else {\n            count\
    \ = 0\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"\
    ])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"\
    lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmp5_xvb3si.swift:20:31: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n                result.append(letter)\n\
    \                              ^\n"
  stdout: ''
  timestamp: 1660014410
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"\
    ]\n/// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n\
    /// select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfunc\
    \ select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    \n    if s == \"\" {\n        return result\n    }\n    \n    var i = 0\n\
    \    var j = 0\n    \n    for char in s {\n        if char == \" \" {\n      \
    \      i += 1\n        }\n        \n        if char == \"a\" || char == \"e\"\
    \ || char == \"i\" || char == \"o\" || char == \"u\" {\n            j += 1\n \
    \       }\n        \n        if j == n {\n            result.append(String(s[i:j]))\n\
    \            i = j + 1\n            j = 0\n        }\n    }\n    \n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary\
    \ had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had\
    \ a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple\
    \ white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\"\
    , n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"\
    ])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s:\
    \ \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpt3egep_i.swift:33:35: error: extraneous argument label 'i:' in\
    \ subscript\n            result.append(String(s[i:j]))\n                     \
    \             ^~~\n                                   \n"
  stdout: ''
  timestamp: 1660014410
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"\
    ]\n/// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n\
    /// select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfunc\
    \ select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    \n    if s == \"\" {\n        return result\n    }\n    \n    let vowels\
    \ = \"aeiouAEIOU\"\n    \n    for char in s.characters {\n        if vowels.contains(String(char))\
    \ {\n            if result.count > n {\n                break\n            }\n\
    \            \n            result.append(String(char))\n        }\n    }\n   \
    \ \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s:\
    \ \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"\
    Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmp7x2mlp57.swift:22:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660014410
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"\
    ]\n/// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n\
    /// select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfunc\
    \ select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    \n    if s == \"\" {\n        return result\n    }\n    \n    var i = 0\n\
    \    var j = 0\n    \n    for i < s.count {\n        if s[i] == \" \" {\n    \
    \        i += 1\n            continue\n        }\n        \n        if s[i] ==\
    \ \" \" {\n            i += 1\n            continue\n        }\n        \n   \
    \     if s[i] == \" \" {\n            i += 1\n            continue\n        }\n\
    \        \n        if s[i] == \" \" {\n            i += 1\n            continue\n\
    \        }\n        \n        if s[i] == \" \" {\n            i += 1\n       \
    \     continue\n        }\n        \n        if s[i] == \" \" {\n            i\
    \ += 1\n            continue\n        }\n        \n        if s[i] == \" \" {\n\
    \            i += 1\n            continue\n        }\n        \n        if s[i]\
    \ == \" \" {\n            i += 1\n            continue\n        }\n        \n\
    \        if s[i] == \" \" {\n            i += 1\n            continue\n      \
    \  }\n        \n        if s[i] == \" \" {\n            i += 1\n            continue\n\
    \        }\n        \n        if s[i] == \" \" {\n            i += 1\n       \
    \     continue\n        }\n        \n        if s[i] == \" \" {\n            i\
    \ += 1\n            continue\n        }\n        \n        if s[i] == \" \" {\n\
    \            i += 1\n            continue\n        }\n        \n        if s[i]\
    \ == \" \" {\n            i += 1\n            continue\n        }\n        \n\
    \        if s[i] == \" \" {\n            i += 1\n            continue\n      \
    \  }\n        \n        if s[i] == \" \" {\n            i += 1\n            continue\n\
    \        }\n        \n        if s[i] == \" \" {\n            i += 1\n       \
    \     continue\n        }\n        \n        if s[i] == \" \" {\n            i\
    \ += 1\n            continue\n        }\n        \n        if s[i] == \" \" {\n\
    \            i += 1\n            continue\n        }\n        \n        if s[i]\
    \ == \" \" {\n            i += 1\n            continue\n        }\n        \n\
    \        if s[i] == \" \" {\n            i += 1\n            continue\n      \
    \  }\n        \n        if s[i] == \" \" {\n            i += 1\n            continue\n\
    \        }\n        \n        if s[i] == \" \" {\n            i += 1\n       \
    \     continue\n        }\n        \n        if s[i] == \" \" {\n            i\
    \ += 1\n            continue\n        }\n        \n        if s[i] == \" \" {\n\
    \            i += 1\n            continue\n        }\n        \n        if s[i]\
    \ == \" \" {\n            i += 1\n            continue\n        }\n        \n\
    \        if s[i] == \" \" {\n            i += 1\n            continue\n      \
    \  }\n        \n        if s[i] == \" \" {\n            i += 1\n            continue\n\
    \        }\n        \n        if s[i] == \" \" {\n            i += 1\n       \
    \     continue\n        }\n        \n        if s[i] == \" \" {\n            i\
    \ += 1\n            continue\n        }\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s:\
    \ \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmps0gattvu.swift:23:11: error: expected 'in' after for-each pattern\n\
    \    for i < s.count {\n          ^\n/tmp/tmps0gattvu.swift:23:11: error: unary\
    \ operator cannot be separated from its operand\n    for i < s.count {\n     \
    \     ^~\n           \n/tmp/tmps0gattvu.swift:194:69: error: expected '}' at end\
    \ of brace statement\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\"\
    , \"c\", \"d\", \"f\"])\n                                                    \
    \                ^\n/tmp/tmps0gattvu.swift:13:50: note: to match this opening\
    \ '{'\nfunc select_words(s: String, n: Int) -> [String] {\n                  \
    \                               ^\n/tmp/tmps0gattvu.swift:23:11: error: '<' is\
    \ not a prefix unary operator\n    for i < s.count {\n          ^\n/tmp/tmps0gattvu.swift:176:6:\
    \ error: operator functions can only be declared at global or in type scope\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660014410
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"\
    ]\n/// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n\
    /// select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfunc\
    \ select_words(s: String, n: Int) -> [String] {\n    var words = [String]()\n\
    \    \n    if s == \"\" {\n        return words\n    }\n    \n    for c in s.characters\
    \ {\n        if c == \" \" {\n            continue\n        }\n        \n    \
    \    if c.isConsonant() {\n            if n == 0 {\n                break\n  \
    \          }\n            \n            n--\n        } else {\n            if\
    \ n == 0 {\n                words.append(String(c.unicodeScalars))\n         \
    \       break\n            }\n            \n            n++\n        }\n    }\n\
    \    \n    return words\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s:\
    \ \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"\
    Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmp34rok0d_.swift:20:16: error: 'characters' is unavailable: Please\
    \ use String directly\n    for c in s.characters {\n               ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmp34rok0d_.swift:25:14:\
    \ error: value of type 'Character' has no member 'isConsonant'\n        if c.isConsonant()\
    \ {\n           ~ ^~~~~~~~~~~\n/tmp/tmp34rok0d_.swift:30:14: error: cannot find\
    \ operator '--' in scope; did you mean '-= 1'?\n            n--\n            \
    \ ^~\n/tmp/tmp34rok0d_.swift:37:14: error: cannot find operator '++' in scope;\
    \ did you mean '+= 1'?\n            n++\n             ^~\n"
  stdout: ''
  timestamp: 1660014410
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"\
    ]\n/// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n\
    /// select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfunc\
    \ select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    \n    if s == \"\" {\n        return result\n    }\n    \n    var i = 0\n\
    \    var j = 0\n    \n    for i < s.count {\n        if s[i] == \" \" {\n    \
    \        i += 1\n            continue\n        }\n        \n        if s[i] ==\
    \ \"a\" || s[i] == \"e\" || s[i] == \"i\" || s[i] == \"o\" || s[i] == \"u\" {\n\
    \            i += 1\n            continue\n        }\n        \n        if s[i]\
    \ == \"b\" || s[i] == \"c\" || s[i] == \"d\" || s[i] == \"f\" || s[i] == \"g\"\
    \ || s[i] == \"h\" || s[i] == \"j\" || s[i] == \"k\" || s[i] == \"l\" || s[i]\
    \ == \"m\" || s[i] == \"n\" || s[i] == \"p\" || s[i] == \"q\" || s[i] == \"r\"\
    \ || s[i] == \"s\" || s[i] == \"t\" || s[i] == \"v\" || s[i] == \"w\" || s[i]\
    \ == \"x\" || s[i] == \"y\" || s[i] == \"z\" {\n            i += 1\n         \
    \   continue\n        }\n        \n        if s[i] == \"A\" || s[i] == \"E\" ||\
    \ s[i] == \"I\" || s[i] == \"O\" || s[i] == \"U\" {\n            i += 1\n    \
    \        continue\n        }\n        \n        if s[i] == \"B\" || s[i] == \"\
    C\" || s[i] == \"D\" || s[i] == \"F\" || s[i] == \"G\" || s[i] == \"H\" || s[i]\
    \ == \"J\" || s[i] == \"K\" || s[i] == \"L\" || s[i] == \"M\" || s[i] == \"N\"\
    \ || s[i] == \"P\" || s[i] == \"Q\" || s[i] == \"R\" || s[i] == \"S\" || s[i]\
    \ == \"T\" || s[i] == \"V\" || s[i] == \"W\" || s[i] == \"X\" || s[i] == \"Y\"\
    \ || s[i] == \"Z\" {\n            i += 1\n            continue\n        }\n  \
    \      \n        if s[i] == \"0\" {\n            i += 1\n            continue\n\
    \        }\n        \n        if s[i] == \"1\" {\n            i += 1\n       \
    \     continue\n        }\n        \n        if s[i] == \"2\" {\n            i\
    \ += 1\n            continue\n        }\n        \n        if s[i] == \"3\" {\n\
    \            i += 1\n            continue\n        }\n        \n        if s[i]\
    \ == \"4\" {\n            i += 1\n            continue\n        }\n        \n\
    \        if s[i] == \"5\" {\n            i += 1\n            continue\n      \
    \  }\n        \n        if s[i] == \"6\" {\n            i += 1\n            continue\n\
    \        }\n        \n        if s[i] == \"7\" {\n            i += 1\n       \
    \     continue\n        }\n        \n        if s[i] == \"8\" {\n            i\
    \ += 1\n            continue\n        }\n        \n        if s[i] == \"9\" {\n\
    \            i += 1\n            continue\n        }\n        \n        if s[i]\
    \ == \".\" {\n            i += 1\n            continue\n        }\n        \n\
    \        if s[i] == \",\" {\n            i += 1\n            continue\n      \
    \  }\n        \n        if s[i] == \"!\" {\n            i += 1\n            continue\n\
    \        }\n        \n\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s:\
    \ \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"\
    Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmp04nx9yix.swift:23:11: error: expected 'in' after for-each pattern\n\
    \    for i < s.count {\n          ^\n/tmp/tmp04nx9yix.swift:23:11: error: unary\
    \ operator cannot be separated from its operand\n    for i < s.count {\n     \
    \     ^~\n           \n/tmp/tmp04nx9yix.swift:136:69: error: expected '}' at end\
    \ of brace statement\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\"\
    , \"c\", \"d\", \"f\"])\n                                                    \
    \                ^\n/tmp/tmp04nx9yix.swift:13:50: note: to match this opening\
    \ '{'\nfunc select_words(s: String, n: Int) -> [String] {\n                  \
    \                               ^\n/tmp/tmp04nx9yix.swift:23:11: error: '<' is\
    \ not a prefix unary operator\n    for i < s.count {\n          ^\n/tmp/tmp04nx9yix.swift:118:6:\
    \ error: operator functions can only be declared at global or in type scope\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660014410
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"\
    ]\n/// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n\
    /// select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfunc\
    \ select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    \n    if s == \"\" {\n        return result\n    }\n    \n    var index =\
    \ 0\n    var consonantCount = 0\n    var consonantIndex = 0\n    \n    for letter\
    \ in s {\n        if letter == \" \" {\n            consonantCount = 0\n     \
    \       consonantIndex = 0\n        }\n        \n        if letter == \"a\" ||\
    \ letter == \"e\" || letter == \"i\" || letter == \"o\" || letter == \"u\" {\n\
    \            consonantCount++\n        }\n        \n        if letter == \"y\"\
    \ {\n            consonantCount++\n        }\n        \n        if letter == \"\
    y\" {\n            consonantCount++\n        }\n        \n        if letter ==\
    \ \"a\" || letter == \"e\" || letter == \"i\" || letter == \"o\" || letter ==\
    \ \"u\" {\n            consonantCount++\n        }\n        \n        if letter\
    \ == \"y\" {\n            consonantCount++\n        }\n        \n        if letter\
    \ == \"y\" {\n            consonantCount++\n        }\n        \n        if letter\
    \ == \"a\" || letter == \"e\" || letter == \"i\" || letter == \"o\" || letter\
    \ == \"u\" {\n            consonantCount++\n        }\n        \n        if letter\
    \ == \"y\" {\n            consonantCount++\n        }\n        \n        if letter\
    \ == \"y\" {\n            consonantCount++\n        }\n        \n        if letter\
    \ == \"a\" || letter == \"e\" || letter == \"i\" || letter == \"o\" || letter\
    \ == \"u\" {\n            consonantCount++\n        }\n        \n        if letter\
    \ == \"y\" {\n            consonantCount++\n        }\n        \n        if letter\
    \ == \"y\" {\n            consonantCount++\n        }\n        \n        if letter\
    \ == \"a\" || letter == \"e\" || letter == \"i\" || letter == \"o\" || letter\
    \ == \"u\" {\n            consonantCount++\n        }\n        \n        if letter\
    \ == \"y\" {\n            consonantCount++\n        }\n        \n        if letter\
    \ == \"y\" {\n            consonantCount++\n        }\n        \n        if letter\
    \ == \"a\" || letter == \"e\" || letter == \"i\" || letter == \"o\" || letter\
    \ == \"u\" {\n            consonantCount++\n        }\n        \n        if letter\
    \ == \"y\" {\n            consonantCount++\n        }\n        \n        if letter\
    \ == \"y\" {\n            consonantCount++\n        }\n        \n        if letter\
    \ == \"a\" || letter == \"e\" || letter == \"i\" || letter == \"o\" || letter\
    \ == \"u\" {\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"\
    Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary\
    \ had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmp96zn8kba.swift:124:69: error: expected '}' at end of brace statement\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])\n\
    \                                                                    ^\n/tmp/tmp96zn8kba.swift:24:21:\
    \ note: to match this opening '{'\n    for letter in s {\n                   \
    \ ^\n/tmp/tmp96zn8kba.swift:124:69: error: expected '}' at end of brace statement\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])\n\
    \                                                                    ^\n/tmp/tmp96zn8kba.swift:13:50:\
    \ note: to match this opening '{'\nfunc select_words(s: String, n: Int) -> [String]\
    \ {\n                                                 ^\n/tmp/tmp96zn8kba.swift:31:27:\
    \ error: cannot find operator '++' in scope; did you mean '+= 1'?\n          \
    \  consonantCount++\n                          ^~\n/tmp/tmp96zn8kba.swift:35:27:\
    \ error: cannot find operator '++' in scope; did you mean '+= 1'?\n          \
    \  consonantCount++\n                          ^~\n/tmp/tmp96zn8kba.swift:39:27:\
    \ error: cannot find operator '++' in scope; did you mean '+= 1'?\n          \
    \  consonantCount++\n                          ^~\n/tmp/tmp96zn8kba.swift:43:27:\
    \ error: cannot find operator '++' in scope; did you mean '+= 1'?\n          \
    \  consonantCount++\n                          ^~\n/tmp/tmp96zn8kba.swift:47:27:\
    \ error: cannot find operator '++' in scope; did you mean '+= 1'?\n          \
    \  consonantCount++\n                          ^~\n/tmp/tmp96zn8kba.swift:51:27:\
    \ error: cannot find operator '++' in scope; did you mean '+= 1'?\n          \
    \  consonantCount++\n                          ^~\n/tmp/tmp96zn8kba.swift:55:27:\
    \ error: cannot find operator '++' in scope; did you mean '+= 1'?\n          \
    \  consonantCount++\n                          ^~\n/tmp/tmp96zn8kba.swift:59:27:\
    \ error: cannot find operator '++' in scope; did you mean '+= 1'?\n          \
    \  consonantCount++\n                          ^~\n/tmp/tmp96zn8kba.swift:63:27:\
    \ error: cannot find operator '++' in scope; did you mean '+= 1'?\n          \
    \  consonantCount++\n       "
  stdout: ''
  timestamp: 1660014410
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"\
    ]\n/// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n\
    /// select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfunc\
    \ select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    for letter in s {\n        if letter == \" \" {\n            continue\n \
    \       }\n        if letter == \"a\" || letter == \"e\" || letter == \"i\" ||\
    \ letter == \"o\" || letter == \"u\" {\n            continue\n        }\n    \
    \    if letter == \"y\" {\n            continue\n        }\n        if letter\
    \ == \"n\" {\n            continue\n        }\n        if letter == \"d\" {\n\
    \            continue\n        }\n        if letter == \"h\" {\n            continue\n\
    \        }\n        if letter == \"r\" {\n            continue\n        }\n  \
    \      if letter == \"s\" {\n            continue\n        }\n        if letter\
    \ == \"t\" {\n            continue\n        }\n        if letter == \"c\" {\n\
    \            continue\n        }\n        if letter == \"m\" {\n            continue\n\
    \        }\n        if letter == \"p\" {\n            continue\n        }\n  \
    \      if letter == \"f\" {\n            continue\n        }\n        if letter\
    \ == \"v\" {\n            continue\n        }\n        if letter == \"b\" {\n\
    \            continue\n        }\n        if letter == \"k\" {\n            continue\n\
    \        }\n        if letter == \"j\" {\n            continue\n        }\n  \
    \      if letter == \"x\" {\n            continue\n        }\n        if letter\
    \ == \"q\" {\n            continue\n        }\n        if letter == \"z\" {\n\
    \            continue\n        }\n        if letter == \"l\" {\n            continue\n\
    \        }\n        if letter == \"m\" {\n            continue\n        }\n  \
    \      if letter == \"n\" {\n            continue\n        }\n        if letter\
    \ == \"k\" {\n            continue\n        }\n        if letter == \"p\" {\n\
    \            continue\n        }\n        if letter == \"q\" {\n            continue\n\
    \        }\n        if letter == \"p\" {\n            continue\n        }\n  \
    \      if letter == \"r\" {\n            continue\n        }\n        if letter\
    \ == \"s\" {\n            continue\n        }\n        if letter == \"t\" {\n\
    \            continue\n        }\n        if letter == \"v\" {\n            continue\n\
    \        }\n        if letter == \"b\" {\n            continue\n        }\n  \
    \      if letter == \"h\" {\n            continue\n        }\n        if letter\
    \ == \"d\" {\n            continue\n        }\n        if letter == \"e\" {\n\
    \            continue\n        }\n        if letter == \"a\" {\n            continue\n\
    \        }\n        if letter == \"e\" {\n            continue\n        }\n  \
    \      if letter == \"i\" {\n            continue\n        }\n        if letter\
    \ == \"o\" {\n            continue\n        }\n        if letter == \"u\" {\n\
    \            continue\n        }\n        if letter == \"y\" {\n            continue\n\
    \        }\n        if letter == \"n\" {\n            continue\n        }\n  \
    \      if letter == \"d\" {\n            continue\n        }\n        if letter\
    \ == \"h\" {\n            continue\n        }\n        if letter\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n:\
    \ 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3)\
    \ == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n:\
    \ 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"\
    world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s:\
    \ \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1)\
    \ == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmp5036lwfw.swift:148:18: error: expected '{' after 'if' condition\n\
    \        if letter\n                 ^\n/tmp/tmp5036lwfw.swift:170:69: error:\
    \ expected '}' at end of brace statement\nassert(select_words(s: \"a b c d e f\"\
    , n: 1) == [\"b\", \"c\", \"d\", \"f\"])\n                                   \
    \                                 ^\n/tmp/tmp5036lwfw.swift:13:50: note: to match\
    \ this opening '{'\nfunc select_words(s: String, n: Int) -> [String] {\n     \
    \                                            ^\n/tmp/tmp5036lwfw.swift:148:12:\
    \ error: cannot convert value of type 'Character' to expected condition type 'Bool'\n\
    \        if letter\n           ^~~~~~\n/tmp/tmp5036lwfw.swift:152:6: error: operator\
    \ functions can only be declared at global or in type scope\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660014410
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"\
    ]\n/// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n\
    /// select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfunc\
    \ select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    var i = 0\n    var j = 0\n    var k = 0\n    var count = 0\n    var last\
    \ = 0\n    var lastCount = 0\n    var lastLast = 0\n    var lastLastCount = 0\n\
    \    var lastLastLast = 0\n    var lastLastLastCount = 0\n    var lastLastLastLast\
    \ = 0\n    var lastLastLastLastCount = 0\n    var lastLastLastLastLast = 0\n \
    \   var lastLastLastLastLastCount = 0\n    var lastLastLastLastLastLast = 0\n\
    \    var lastLastLastLastLastLastCount = 0\n    var lastLastLastLastLastLastLast\
    \ = 0\n    var lastLastLastLastLastLastLastCount = 0\n    var lastLastLastLastLastLastLastLast\
    \ = 0\n    var lastLastLastLastLastLastLastCount = 0\n    var lastLastLastLastLastLastLastLast\
    \ = 0\n    var lastLastLastLastLastLastLastLastCount = 0\n    var lastLastLastLastLastLastLastLastLast\
    \ = 0\n    var lastLastLastLastLastLastLastLastCount = 0\n    var lastLastLastLastLastLastLastLastLast\
    \ = 0\n    var lastLastLastLastLastLastLastLastLastCount = 0\n    var lastLastLastLastLastLastLastLastLastLast\
    \ = 0\n    var lastLastLastLastLastLastLastLastLastCount = 0\n    var lastLastLastLastLastLastLastLastLastLast\
    \ = 0\n    var lastLastLastLastLastLastLastLastLastLastCount = 0\n    var lastLastLastLastLastLastLastLastLastLast\
    \ = 0\n    var lastLastLastLastLastLastLastLastLastLastCount = 0\n    var lastLastLastLastLastLastLastLastLastLastLast\
    \ = 0\n    var lastLastLastLastLastLastLastLastLastLastCount = 0\n    var lastLastLastLastLastLastLastLastLastLastLastLast\
    \ = 0\n    var lastLastLastLastLastLastLastLastLastLastLastCount = 0\n    var\
    \ lastLastLastLastLastLastLastLastLastLastLastLast = 0\n    var lastLastLastLastLastLastLastLastLastLastLastLastCount\
    \ = 0\n    var lastLastLastLastLastLastLastLastLastLastLastLastLast = 0\n    var\
    \ lastLastLastLastLastLastLastLastLastLastLastLastCount = 0\n    var lastLastLastLastLastLastLastLastLastLastLastLast\
    \ = 0\n    var lastLastLastLastLastLastLastLastLastLastLastLastCount = 0\n   \
    \ var lastLastLastLastLastLastLastLastLastLastLastLastLast = 0\n    var lastLastLastLastLastLastLastLastLastLastLastLastCount\
    \ = 0\n    var lastLastLastLastLastLastLastLastLastLastLastLastLast = 0\n    var\
    \ lastLastLastLastLastLastLastLastLastLastLast\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"\
    ])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"\
    lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpor0uazfy.swift:34:9: error: invalid redeclaration of 'lastLastLastLastLastLastLastCount'\n\
    \    var lastLastLastLastLastLastLastCount = 0\n        ^\n/tmp/tmpor0uazfy.swift:32:9:\
    \ note: 'lastLastLastLastLastLastLastCount' previously declared here\n    var\
    \ lastLastLastLastLastLastLastCount = 0\n        ^\n/tmp/tmpor0uazfy.swift:35:9:\
    \ error: invalid redeclaration of 'lastLastLastLastLastLastLastLast'\n    var\
    \ lastLastLastLastLastLastLastLast = 0\n        ^\n/tmp/tmpor0uazfy.swift:33:9:\
    \ note: 'lastLastLastLastLastLastLastLast' previously declared here\n    var lastLastLastLastLastLastLastLast\
    \ = 0\n        ^\n/tmp/tmpor0uazfy.swift:38:9: error: invalid redeclaration of\
    \ 'lastLastLastLastLastLastLastLastCount'\n    var lastLastLastLastLastLastLastLastCount\
    \ = 0\n        ^\n/tmp/tmpor0uazfy.swift:36:9: note: 'lastLastLastLastLastLastLastLastCount'\
    \ previously declared here\n    var lastLastLastLastLastLastLastLastCount = 0\n\
    \        ^\n/tmp/tmpor0uazfy.swift:39:9: error: invalid redeclaration of 'lastLastLastLastLastLastLastLastLast'\n\
    \    var lastLastLastLastLastLastLastLastLast = 0\n        ^\n/tmp/tmpor0uazfy.swift:37:9:\
    \ note: 'lastLastLastLastLastLastLastLastLast' previously declared here\n    var\
    \ lastLastLastLastLastLastLastLastLast = 0\n        ^\n/tmp/tmpor0uazfy.swift:42:9:\
    \ error: invalid redeclaration of 'lastLastLastLastLastLastLastLastLastCount'\n\
    \    var lastLastLastLastLastLastLastLastLastCount = 0\n        ^\n/tmp/tmpor0uazfy.swift:40:9:\
    \ note: 'lastLastLastLastLastLastLastLastLastCount' previously declared here\n\
    \    var lastLastLastLastLastLastLastLastLastCount = 0\n        ^\n/tmp/tmpor0uazfy.swift:43:9:\
    \ error: invalid redeclaration of 'lastLastLastLastLastLastLastLastLastLast'\n\
    \    var lastLastLastLastLastLastLastLastLastLast = 0\n        ^\n/tmp/tmpor0uazfy.swift:41:9:\
    \ note: 'lastLastLastLastLastLastLastLastLastLast' previously declared here\n\
    \    var lastLastLastLastLastLastLastLastLastLast = 0\n        ^\n/tmp/tmpor0uazfy.swift:45:9:\
    \ error: invalid redeclaration of 'lastLastLastLastLastLastLastLastLastLast'\n\
    \    var lastLastLastLastLastLa"
  stdout: ''
  timestamp: 1660014410
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"\
    ]\n/// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n\
    /// select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfunc\
    \ select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    \n    if s == \"\" {\n        return result\n    }\n    \n    var count =\
    \ 0\n    var last = 0\n    var start = 0\n    \n    for c in s.characters {\n\
    \        if c == \" \" {\n            count += 1\n            if count == n {\n\
    \                start = last\n            }\n        } else {\n            count\
    \ = 0\n        }\n        last = count\n    }\n    \n    if count == n {\n   \
    \     result = s.substringWithRange(start..<s.endIndex).componentsSeparatedByString(\"\
    \ \")\n    }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s:\
    \ \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpffc8_dgt.swift:24:16: error: 'characters' is unavailable: Please\
    \ use String directly\n    for c in s.characters {\n               ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpffc8_dgt.swift:37:20:\
    \ error: value of type 'String' has no member 'substringWithRange'\n        result\
    \ = s.substringWithRange(start..<s.endIndex).componentsSeparatedByString(\" \"\
    )\n                 ~ ^~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014410
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"\
    ]\n/// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n\
    /// select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfunc\
    \ select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    var i = 0\n    var j = 0\n    var k = 0\n    var l = 0\n    var m = s.characters.count\n\
    \    var n = n\n    var o = 0\n    var p = 0\n    var q = 0\n    var r = 0\n \
    \   var s = 0\n    var t = 0\n    var u = 0\n    var v = 0\n    var w = 0\n  \
    \  var x = 0\n    var y = 0\n    var z = 0\n    var aa = 0\n    var ab = 0\n \
    \   var ac = 0\n    var ad = 0\n    var ae = 0\n    var af = 0\n    var ag = 0\n\
    \    var ah = 0\n    var ai = 0\n    var aj = 0\n    var ak = 0\n    var al =\
    \ 0\n    var am = 0\n    var an = 0\n    var ao = 0\n    var ap = 0\n    var aq\
    \ = 0\n    var ar = 0\n    var as = 0\n    var at = 0\n    var au = 0\n    var\
    \ av = 0\n    var aw = 0\n    var ax = 0\n    var ay = 0\n    var az = 0\n   \
    \ var ba = 0\n    var bb = 0\n    var bc = 0\n    var bd = 0\n    var be = 0\n\
    \    var bf = 0\n    var bg = 0\n    var bh = 0\n    var bi = 0\n    var bj =\
    \ 0\n    var bk = 0\n    var bl = 0\n    var bm = 0\n    var bn = 0\n    var bo\
    \ = 0\n    var bp = 0\n    var bq = 0\n    var br = 0\n    var bs = 0\n    var\
    \ bt = 0\n    var bu = 0\n    var bv = 0\n    var bw = 0\n    var bx = 0\n   \
    \ var by = 0\n    var bz = 0\n    var ca = 0\n    var cb = 0\n    var cc = 0\n\
    \    var cd = 0\n    var ce = 0\n    var cf = 0\n    var cg = 0\n    var ch =\
    \ 0\n    var ci = 0\n    var cj = 0\n    var ck = 0\n    var cl = 0\n    var cm\
    \ = 0\n    var cn = 0\n    var co = 0\n    var cp = 0\n    var cq = 0\n    var\
    \ cr = 0\n    var cs = 0\n    var ct = 0\n    var cu = 0\n    var cv = 0\n   \
    \ var cw = 0\n    var cx = 0\n    var cy = 0\n    var cz = 0\n    var da = 0\n\
    \    var db = 0\n    var dc = 0\n    var dd = 0\n    var de = 0\n    var df =\
    \ 0\n    var dg = 0\n    var dh = 0\n    var di = 0\n    var dj = 0\n    var dk\
    \ = 0\n    var dl = 0\n    var dm = 0\n    var dn = 0\n    var do = 0\n    var\
    \ dp = 0\n    var dq = 0\n    var dr = 0\n    var ds = 0\n    var dt = 0\n   \
    \ var du = 0\n    var dv = 0\n    var dw = 0\n    var dx = 0\n    var dy = 0\n\
    \    var dz = 0\n    var ea = 0\n    var eb = 0\n    var ec = 0\n    var \n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n:\
    \ 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3)\
    \ == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n:\
    \ 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"\
    world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s:\
    \ \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1)\
    \ == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmp_2w9z75k.swift:51:9: error: keyword 'as' cannot be used as an identifier\
    \ here\n    var as = 0\n        ^\n/tmp/tmp_2w9z75k.swift:51:9: note: if this\
    \ name is unavoidable, use backticks to escape it\n    var as = 0\n        ^~\n\
    \        `as`\n/tmp/tmp_2w9z75k.swift:125:9: error: keyword 'do' cannot be used\
    \ as an identifier here\n    var do = 0\n        ^\n/tmp/tmp_2w9z75k.swift:125:9:\
    \ note: if this name is unavoidable, use backticks to escape it\n    var do =\
    \ 0\n        ^~\n        `do`\n/tmp/tmp_2w9z75k.swift:140:8: error: expected pattern\n\
    \    var \n       ^\n/tmp/tmp_2w9z75k.swift:19:15: error: 'characters' is unavailable:\
    \ Please use String directly\n    var m = s.characters.count\n              ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmp_2w9z75k.swift:14:9:\
    \ warning: initialization of variable 'result' was never used; consider replacing\
    \ with assignment to '_' or removing it\n    var result = [String]()\n    ~~~~^~~~~~\n\
    \    _\n/tmp/tmp_2w9z75k.swift:15:9: warning: initialization of variable 'i' was\
    \ never used; consider replacing with assignment to '_' or removing it\n    var\
    \ i = 0\n    ~~~~^\n    _\n/tmp/tmp_2w9z75k.swift:16:9: warning: initialization\
    \ of variable 'j' was never used; consider replacing with assignment to '_' or\
    \ removing it\n    var j = 0\n    ~~~~^\n    _\n/tmp/tmp_2w9z75k.swift:17:9: warning:\
    \ initialization of variable 'k' was never used; consider replacing with assignment\
    \ to '_' or removing it\n    var k = 0\n    ~~~~^\n    _\n/tmp/tmp_2w9z75k.swift:18:9:\
    \ warning: initialization of variable 'l' was never used; consider replacing with\
    \ assignment to '_' or removing it\n    var l = 0\n    ~~~~^\n    _\n/tmp/tmp_2w9z75k.swift:19:9:\
    \ warning: initialization of variable 'm' was never used; consider replacing with\
    \ assignment to '_' or removing it\n    var m = s.characters.count\n    ~~~~^\n\
    \    _\n/tmp/tmp_2w9z75k.swift:20:9: warning: initialization of variable 'n' was\
    \ never used; consider replacing with assignment to '_' or removing it\n"
  stdout: ''
  timestamp: 1660014410
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"\
    ]\n/// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n\
    /// select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfunc\
    \ select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    \n    if s == \"\" {\n        return result\n    }\n    \n    let vowels\
    \ = \"aeiouAEIOU\"\n    \n    for char in s.characters {\n        if vowels.contains(String(char))\
    \ {\n            if result.count < n {\n                result.append(String(char))\n\
    \            }\n        }\n    }\n    \n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"\
    little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\"\
    , \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmp7dsrx49n.swift:22:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660014410
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"\
    ]\n/// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n\
    /// select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfunc\
    \ select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    \n    if s == \"\" {\n        return result\n    }\n    \n    var i = 0\n\
    \    var j = 0\n    var k = 0\n    \n    for i < s.count {\n        if s[i] ==\
    \ \" \" {\n            j = i\n            for k < s.count {\n                if\
    \ s[k] == \" \" {\n                    k = k + 1\n                } else {\n \
    \                   break\n                }\n            }\n            \n  \
    \          if j - i > n {\n                result.appendContentsOf(s.substringWithRange(i..<j))\n\
    \            }\n            \n            i = j\n        }\n    }\n    \n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary\
    \ had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had\
    \ a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple\
    \ white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\"\
    , n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"\
    ])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s:\
    \ \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpyzh6dhtn.swift:24:11: error: expected 'in' after for-each pattern\n\
    \    for i < s.count {\n          ^\n/tmp/tmpyzh6dhtn.swift:24:11: error: unary\
    \ operator cannot be separated from its operand\n    for i < s.count {\n     \
    \     ^~\n           \n/tmp/tmpyzh6dhtn.swift:27:19: error: expected 'in' after\
    \ for-each pattern\n            for k < s.count {\n                  ^\n/tmp/tmpyzh6dhtn.swift:27:19:\
    \ error: unary operator cannot be separated from its operand\n            for\
    \ k < s.count {\n                  ^~\n                   \n/tmp/tmpyzh6dhtn.swift:24:11:\
    \ error: '<' is not a prefix unary operator\n    for i < s.count {\n         \
    \ ^\n/tmp/tmpyzh6dhtn.swift:27:19: error: '<' is not a prefix unary operator\n\
    \            for k < s.count {\n                  ^\n"
  stdout: ''
  timestamp: 1660014410
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"\
    ]\n/// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n\
    /// select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfunc\
    \ select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    \n    if s == \"\" {\n        return result\n    }\n    \n    let vowels\
    \ = \"aeiouAEIOU\"\n    \n    for char in s.characters {\n        if vowels.contains(String(char))\
    \ {\n            if result.count < n {\n                result.append(String(char))\n\
    \            }\n        }\n    }\n    \n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"\
    little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\"\
    , \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmp7dsrx49n.swift:22:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660014410
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"\
    ]\n/// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n\
    /// select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfunc\
    \ select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    \n    if s == \"\" {\n        return result\n    }\n    \n    var i = 0\n\
    \    var j = 0\n    var k = 0\n    \n    for i < s.count {\n        if s[i] ==\
    \ \" \" {\n            j = i\n            \n            for k < s.count {\n  \
    \              if s[k] == \" \" {\n                    k = k + 1\n           \
    \     } else {\n                    break\n                }\n            }\n\
    \            \n            if k == s.count {\n                result.insert(i,\
    \ s.substring(j, s.count))\n                i = i + 1\n            }\n       \
    \ } else {\n            k = i\n            \n            for j < s.count {\n \
    \               if s[j] == \" \" {\n                    j = j + 1\n          \
    \      } else {\n                    break\n                }\n            }\n\
    \            \n            if j == s.count {\n                result.insert(i,\
    \ s.substring(k, s.count))\n                i = i + 1\n            }\n       \
    \ }\n    }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s:\
    \ \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpjs_k3opy.swift:24:11: error: expected 'in' after for-each pattern\n\
    \    for i < s.count {\n          ^\n/tmp/tmpjs_k3opy.swift:24:11: error: unary\
    \ operator cannot be separated from its operand\n    for i < s.count {\n     \
    \     ^~\n           \n/tmp/tmpjs_k3opy.swift:28:19: error: expected 'in' after\
    \ for-each pattern\n            for k < s.count {\n                  ^\n/tmp/tmpjs_k3opy.swift:28:19:\
    \ error: unary operator cannot be separated from its operand\n            for\
    \ k < s.count {\n                  ^~\n                   \n/tmp/tmpjs_k3opy.swift:43:19:\
    \ error: expected 'in' after for-each pattern\n            for j < s.count {\n\
    \                  ^\n/tmp/tmpjs_k3opy.swift:43:19: error: unary operator cannot\
    \ be separated from its operand\n            for j < s.count {\n             \
    \     ^~\n                   \n/tmp/tmpjs_k3opy.swift:24:11: error: '<' is not\
    \ a prefix unary operator\n    for i < s.count {\n          ^\n/tmp/tmpjs_k3opy.swift:28:19:\
    \ error: '<' is not a prefix unary operator\n            for k < s.count {\n \
    \                 ^\n/tmp/tmpjs_k3opy.swift:43:19: error: '<' is not a prefix\
    \ unary operator\n            for j < s.count {\n                  ^\n"
  stdout: ''
  timestamp: 1660014410
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"\
    ]\n/// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n\
    /// select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfunc\
    \ select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    for word in s.split(\" \") {\n        if word.hasPrefix(\"_\") || word.hasPrefix(\"\
    _\") || word.hasPrefix(\"_\") {\n            continue\n        }\n        if word.hasSuffix(\"\
    _\") || word.hasSuffix(\"_\") || word.hasSuffix(\"_\") {\n            continue\n\
    \        }\n        if word.hasPrefix(\"_\") || word.hasSuffix(\"_\") || word.hasPrefix(\"\
    _\") {\n            continue\n        }\n        if word.hasPrefix(\"_\") || word.hasSuffix(\"\
    _\") || word.hasSuffix(\"_\") {\n            continue\n        }\n        if word.hasPrefix(\"\
    _\") || word.hasSuffix(\"_\") || word.hasPrefix(\"_\") {\n            continue\n\
    \        }\n        if word.hasPrefix(\"_\") || word.hasSuffix(\"_\") || word.hasSuffix(\"\
    _\") {\n            continue\n        }\n        if word.hasPrefix(\"_\") || word.hasSuffix(\"\
    _\") || word.hasSuffix(\"_\") {\n            continue\n        }\n        if word.hasPrefix(\"\
    _\") || word.hasSuffix(\"_\") || word.hasSuffix(\"_\") {\n            continue\n\
    \        }\n        if word.hasPrefix(\"_\") || word.hasSuffix(\"_\") || word.hasSuffix(\"\
    _\") {\n            continue\n        }\n        if word.hasPrefix(\"_\") || word.hasSuffix(\"\
    _\") || word.hasSuffix(\"_\") {\n            continue\n        }\n        if word.hasPrefix(\"\
    _\") || word.hasSuffix(\"_\") || word.hasSuffix(\"_\") {\n            continue\n\
    \        }\n        if word.hasPrefix(\"_\") || word.hasSuffix(\"_\") || word.hasSuffix(\"\
    _\") {\n            continue\n        }\n        if word.hasPrefix(\"_\") || word.hasSuffix(\"\
    _\") || word.hasSuffix(\"_\") {\n            continue\n        }\n        if word.hasPrefix(\"\
    _\") || word.hasSuffix(\"_\") || word.hasSuffix(\"_\") {\n            continue\n\
    \        }\n        if word.hasPrefix(\"_\") || word.hasSuffix(\"_\") || word.hasSuffix(\"\
    _\") {\n            continue\n        }\n        if word.hasPrefix(\"_\") || word.hasSuffix(\"\
    _\") || word.hasSuffix(\"_\") {\n            continue\n        }\n        if word.hasPrefix(\"\
    _\") || word.hasSuffix(\"_\") || word.hasSuffix(\"_\") {\n            continue\n\
    \        }\n        if word.hasPrefix(\"_\") || word.hasSuffix(\"_\") || word.hasSuffix(\"\
    _\") {\n            continue\n        }\n        if word.hasPrefix(\"_\") || word.hasSuffix(\"\
    _\") || word.hasSuffix(\"_\") {\n            continue\n        }\n        if word.hasPrefix\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n:\
    \ 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3)\
    \ == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n:\
    \ 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"\
    world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s:\
    \ \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1)\
    \ == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpa1et2h57.swift:73:26: error: expected '{' after 'if' condition\n\
    \        if word.hasPrefix\n                         ^\n/tmp/tmpa1et2h57.swift:95:69:\
    \ error: expected '}' at end of brace statement\nassert(select_words(s: \"a b\
    \ c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])\n                        \
    \                                            ^\n/tmp/tmpa1et2h57.swift:13:50:\
    \ note: to match this opening '{'\nfunc select_words(s: String, n: Int) -> [String]\
    \ {\n                                                 ^\n/tmp/tmpa1et2h57.swift:15:19:\
    \ error: no exact matches in call to instance method 'split'\n    for word in\
    \ s.split(\" \") {\n                  ^\nSwift.Sequence:2:40: note: incorrect\
    \ labels for candidate (have: '(_:)', expected: '(separator:)')\n    @inlinable\
    \ public __consuming func split(separator: Self.Element, maxSplits: Int = Int.max,\
    \ omittingEmptySubsequences: Bool = true) -> [ArraySlice<Self.Element>]\n    \
    \                                   ^\nSwift.Collection:2:40: note: incorrect\
    \ labels for candidate (have: '(_:)', expected: '(separator:)')\n    @inlinable\
    \ public __consuming func split(separator: Self.Element, maxSplits: Int = Int.max,\
    \ omittingEmptySubsequences: Bool = true) -> [Self.SubSequence]\n            \
    \                           ^\n/tmp/tmpa1et2h57.swift:77:6: error: operator functions\
    \ can only be declared at global or in type scope\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660014410
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"\
    ]\n/// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n\
    /// select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfunc\
    \ select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    \n    if s == \"\" {\n        return result\n    }\n    \n    for char in\
    \ s.characters {\n        if char.unicodeScalars.filter({ $0.isConsonant() }).count\
    \ == n {\n            result.append(String(char))\n        }\n    }\n    \n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"\
    Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary\
    \ had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpzjzed04n.swift:20:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpzjzed04n.swift:21:44:\
    \ error: value of type 'Unicode.Scalar' has no member 'isConsonant'\n        if\
    \ char.unicodeScalars.filter({ $0.isConsonant() }).count == n {\n            \
    \                            ~~ ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014410
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"\
    ]\n/// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n\
    /// select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfunc\
    \ select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    var index = 0\n    var count = 0\n    var last = 0\n    for c in s {\n  \
    \      if c == \" \" {\n            if count > n {\n                last = index\n\
    \            }\n            count = 0\n        } else {\n            count +=\
    \ 1\n        }\n        if count == n {\n            result.append(s[last..<index])\n\
    \            count = 0\n        }\n        index++\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n:\
    \ 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3)\
    \ == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n:\
    \ 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"\
    world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s:\
    \ \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1)\
    \ == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmp4wrkxiux.swift:28:27: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an integer range, use a String.Index range instead.\n\
    \            result.append(s[last..<index])\n                          ^~~~~~~~~~~~~~~\n\
    Swift.String:5:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript<R>(bounds: R) -> String where R : RangeExpression,\
    \ R.Bound == Int { get }\n           ^\n/tmp/tmp4wrkxiux.swift:31:14: error: cannot\
    \ find operator '++' in scope; did you mean '+= 1'?\n        index++\n       \
    \      ^~\n"
  stdout: ''
  timestamp: 1660014410
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"\
    ]\n/// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n\
    /// select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfunc\
    \ select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    \n    if s == \"\" {\n        return result\n    }\n    \n    for letter\
    \ in s.characters {\n        if letter == \" \" {\n            continue\n    \
    \    }\n        \n        if letter == \"a\" || letter == \"e\" || letter == \"\
    i\" || letter == \"o\" || letter == \"u\" {\n            continue\n        }\n\
    \        \n        if letter == \"y\" {\n            if s.characters.count > n\
    \ {\n                continue\n            }\n        }\n        \n        if\
    \ letter == \"s\" {\n            if s.characters.count > n {\n               \
    \ continue\n            }\n        }\n        \n        if letter == \"h\" {\n\
    \            if s.characters.count > n {\n                continue\n         \
    \   }\n        }\n        \n        if letter == \"l\" {\n            if s.characters.count\
    \ > n {\n                continue\n            }\n        }\n        \n      \
    \  if letter == \"m\" {\n            if s.characters.count > n {\n           \
    \     continue\n            }\n        }\n        \n        if letter == \"n\"\
    \ {\n            if s.characters.count > n {\n                continue\n     \
    \       }\n        }\n        \n        if letter == \"t\" {\n            if s.characters.count\
    \ > n {\n                continue\n            }\n        }\n        \n      \
    \  if letter == \"d\" {\n            if s.characters.count > n {\n           \
    \     continue\n            }\n        }\n        \n        if letter == \"r\"\
    \ {\n            if s.characters.count > n {\n                continue\n     \
    \       }\n        }\n        \n        if letter == \"b\" {\n            if s.characters.count\
    \ > n {\n                continue\n            }\n        }\n        \n      \
    \  if letter == \"f\" {\n            if s.characters.count > n {\n           \
    \     continue\n            }\n        }\n        \n        if letter == \"v\"\
    \ {\n            if s.characters.count > n {\n                continue\n     \
    \       }\n        }\n        \n        if letter == \"j\" {\n            if s.characters.count\
    \ > n {\n                continue\n            }\n        }\n        \n      \
    \  if letter == \"q\" {\n            if s.characters.count > n {\n           \
    \     continue\n            }\n        }\n        \n        if letter == \"p\"\
    \ {\n            if s.characters.count > n {\n                continue\n     \
    \       }\n        }\n        \n        if letter == \"k\" {\n            if s.characters.count\
    \ > n {\n                continue\n            }\n        }\n        \n      \
    \  if letter == \"j\" {\n            if s.characters.count > n {\n           \
    \     continue\n            }\n        }\n        \n        if letter == \"z\"\
    \ {\n            if s.characters.count > n {\n                continue\n     \
    \       }\n        }\n        \n        if letter == \"x\" {\n            if s.characters.count\
    \ > n {\n                continue\n            }\n        }\n        \n      \
    \  if letter == \"z\" {\n\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s:\
    \ \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"\
    Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpjdh9xvuo.swift:166:69: error: expected '}' at end of brace statement\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])\n\
    \                                                                    ^\n/tmp/tmpjdh9xvuo.swift:20:32:\
    \ note: to match this opening '{'\n    for letter in s.characters {\n        \
    \                       ^\n/tmp/tmpjdh9xvuo.swift:166:69: error: expected '}'\
    \ at end of brace statement\nassert(select_words(s: \"a b c d e f\", n: 1) ==\
    \ [\"b\", \"c\", \"d\", \"f\"])\n                                            \
    \                        ^\n/tmp/tmpjdh9xvuo.swift:13:50: note: to match this\
    \ opening '{'\nfunc select_words(s: String, n: Int) -> [String] {\n          \
    \                                       ^\n/tmp/tmpjdh9xvuo.swift:20:21: error:\
    \ 'characters' is unavailable: Please use String directly\n    for letter in s.characters\
    \ {\n                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmpjdh9xvuo.swift:30:18: error: 'characters' is unavailable:\
    \ Please use String directly\n            if s.characters.count > n {\n      \
    \           ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in\
    \ Swift 5.0\n    public var characters: String { get set }\n               ^\n\
    /tmp/tmpjdh9xvuo.swift:36:18: error: 'characters' is unavailable: Please use String\
    \ directly\n            if s.characters.count > n {\n                 ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpjdh9xvuo.swift:42:18:\
    \ error: 'characters' is unavailable: Please use String directly\n           \
    \ if s.characters.count > n {\n                 ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmpjdh9xvuo.swift:48:18: error: 'characters'\
    \ is unavailable: Please use String directly\n            if s.characters.count\
    \ > n {\n                 ^~~~~~~~~~\nSwift.Strin"
  stdout: ''
  timestamp: 1660014410
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"\
    ]\n/// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n\
    /// select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfunc\
    \ select_words(s: String, n: Int) -> [String] {\n    \n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"\
    little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\"\
    , \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: '/tmp/tmpuails2sj.swift:15:1: error: missing return in global function expected
    to return ''[String]''

    }

    ^

    '
  stdout: ''
  timestamp: 1660014410
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"\
    ]\n/// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n\
    /// select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfunc\
    \ select_words(s: String, n: Int) -> [String] {\n    var words = [String]()\n\
    \    \n    if s == \"\" {\n        return words\n    }\n    \n    for c in s.characters\
    \ {\n        if c == \" \" {\n            continue\n        }\n        \n    \
    \    if c.isConsonant() {\n            if n == 1 {\n                words.append(String(c.unicodeScalars))\n\
    \            } else {\n                words.append(String(c.unicodeScalars))\n\
    \                \n                if n == 2 {\n                    words.append(String(c.unicodeScalars))\n\
    \                }\n            }\n        }\n    }\n    \n    return words\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n:\
    \ 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3)\
    \ == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n:\
    \ 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"\
    world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s:\
    \ \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1)\
    \ == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpyegirjl3.swift:20:16: error: 'characters' is unavailable: Please\
    \ use String directly\n    for c in s.characters {\n               ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpyegirjl3.swift:25:14:\
    \ error: value of type 'Character' has no member 'isConsonant'\n        if c.isConsonant()\
    \ {\n           ~ ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014410
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"\
    ]\n/// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n\
    /// select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfunc\
    \ select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    \n    if s == \"\" {\n        return result\n    }\n    \n    var i = 0\n\
    \    var j = 0\n    \n    for char in s {\n        if char == \" \" {\n      \
    \      i += 1\n        }\n        \n        if char == \"a\" || char == \"e\"\
    \ || char == \"i\" || char == \"o\" || char == \"u\" {\n            j += 1\n \
    \       }\n        \n        if j == n {\n            result.append(String(s[i:j]))\n\
    \            i = j + 1\n            j = 0\n        }\n    }\n    \n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary\
    \ had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had\
    \ a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple\
    \ white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\"\
    , n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"\
    ])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s:\
    \ \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpt3egep_i.swift:33:35: error: extraneous argument label 'i:' in\
    \ subscript\n            result.append(String(s[i:j]))\n                     \
    \             ^~~\n                                   \n"
  stdout: ''
  timestamp: 1660014410
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"\
    ]\n/// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n\
    /// select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfunc\
    \ select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    \n    if s == \"\" {\n        return result\n    }\n    \n    var i = 0\n\
    \    var j = 0\n    \n    while i < s.count {\n        if s[i] == \" \" {\n  \
    \          j = i\n            while j < s.count && s[j] != \" \" {\n         \
    \       j += 1\n            }\n            \n            if j == s.count {\n \
    \               result.append(s[i:j])\n                i = j\n            }\n\
    \        }\n        i += 1\n    }\n    \n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"\
    little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\"\
    , \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpkpq3et8a.swift:24:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if s[i] ==\
    \ \" \" {\n           ^~~~\nSwift.String:3:12: note: 'subscript(_:)' has been\
    \ explicitly marked unavailable here\n    public subscript(i: Int) -> Character\
    \ { get }\n           ^\n/tmp/tmpkpq3et8a.swift:26:34: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \            while j < s.count && s[j] != \" \" {\n                          \
    \       ^~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly marked\
    \ unavailable here\n    public subscript(i: Int) -> Character { get }\n      \
    \     ^\n/tmp/tmpkpq3et8a.swift:31:32: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n                result.append(s[i:j])\n\
    \                               ^\n/tmp/tmpkpq3et8a.swift:31:32: error: extraneous\
    \ argument label 'i:' in subscript\n                result.append(s[i:j])\n  \
    \                             ^~~\n                                \n"
  stdout: ''
  timestamp: 1660014410
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"\
    ]\n/// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n\
    /// select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfunc\
    \ select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    \n    if s == \"\" {\n        return result\n    }\n    \n    for char in\
    \ s.characters {\n        if char.hasConsonant() {\n            if result.count\
    \ < n {\n                result.append(String(char))\n            }\n        }\n\
    \    }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s:\
    \ \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"\
    Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmp0gyzfckj.swift:20:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmp0gyzfckj.swift:21:17:\
    \ error: value of type 'Character' has no member 'hasConsonant'\n        if char.hasConsonant()\
    \ {\n           ~~~~ ^~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014410
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"\
    ]\n/// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n\
    /// select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfunc\
    \ select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    \n    if s == \"\" {\n        return result\n    }\n    \n    var i = 0\n\
    \    var j = 0\n    \n    while i < s.count {\n        if s[i] == \" \" {\n  \
    \          i += 1\n            continue\n        }\n        \n        if s[i]\
    \ == \"a\" || s[i] == \"e\" || s[i] == \"i\" || s[i] == \"o\" || s[i] == \"u\"\
    \ {\n            i += 1\n            continue\n        }\n        \n        if\
    \ s[i] == \"b\" || s[i] == \"c\" || s[i] == \"d\" || s[i] == \"f\" || s[i] ==\
    \ \"g\" || s[i] == \"h\" || s[i] == \"j\" || s[i] == \"k\" || s[i] == \"l\" ||\
    \ s[i] == \"m\" || s[i] == \"n\" || s[i] == \"p\" || s[i] == \"q\" || s[i] ==\
    \ \"r\" || s[i] == \"s\" || s[i] == \"t\" || s[i] == \"v\" || s[i] == \"w\" ||\
    \ s[i] == \"x\" || s[i] == \"y\" || s[i] == \"z\" {\n            i += 1\n    \
    \        continue\n        }\n        \n        if s[i] == \"A\" || s[i] == \"\
    E\" || s[i] == \"I\" || s[i] == \"O\" || s[i] == \"U\" {\n            i += 1\n\
    \            continue\n        }\n        \n        if s[i] == \"B\" || s[i] ==\
    \ \"C\" || s[i] == \"D\" || s[i] == \"F\" || s[i] == \"G\" || s[i] == \"H\" ||\
    \ s[i] == \"J\" || s[i] == \"K\" || s[i] == \"L\" || s[i] == \"M\" || s[i] ==\
    \ \"N\" || s[i] == \"P\" || s[i] == \"Q\" || s[i] == \"R\" || s[i] == \"S\" ||\
    \ s[i] == \"T\" || s[i] == \"V\" || s[i] == \"W\" || s[i] == \"X\" || s[i] ==\
    \ \"Y\" || s[i] == \"Z\" {\n            i += 1\n            continue\n       \
    \ }\n        \n        if s[i] == \" \" {\n            i += 1\n            continue\n\
    \        }\n        \n        if s[i] == \"a\" || s[i] == \"e\" || s[i] == \"\
    i\" || s[i] == \"o\" || s[i] == \"u\" {\n            i += 1\n            continue\n\
    \        }\n        \n        if s[i] == \"b\" || s[i] == \"c\" || s[i] == \"\
    d\" || s[i] == \"f\" || s[i] == \"g\" || s[i] == \"h\" || s[i] == \"j\" || s[i]\
    \ == \"k\" || s[i] == \"l\" || s[i] == \"m\" || s[i] == \"n\" || s[i] == \"p\"\
    \ || s[i] == \"q\" || s[i] == \"r\" || s[i] == \"s\" || s[i] == \"t\" || s[i]\
    \ == \"v\" || s[i] == \"w\" || s[i] == \"x\" || s[i] == \"y\" || s[i] == \"z\"\
    \ {\n            i += 1\n            continue\n        }\n        \n        if\
    \ s[i] == \"A\" || s[i] == \"E\" || s[i] == \"I\" || s[i] == \"O\" || s[i] ==\
    \ \"U\" {\n            i += 1\n            continue\n        }\n        \n   \
    \     if s[i] == \"B\" || s[i] == \"C\" || s[i] == \"D\" || s[i] == \"F\" || s[i]\
    \ == \"G\" || s[i] == \"H\" || s[i] == \"J\" || \n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"\
    little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\"\
    , \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpihuggq7n.swift:70:1: error: expected expression after operator\n\
    }\n^\n/tmp/tmpihuggq7n.swift:91:69: error: expected '}' at end of brace statement\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])\n\
    \                                                                    ^\n/tmp/tmpihuggq7n.swift:13:50:\
    \ note: to match this opening '{'\nfunc select_words(s: String, n: Int) -> [String]\
    \ {\n                                                 ^\n/tmp/tmpihuggq7n.swift:24:12:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if s[i] == \" \" {\n           ^~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpihuggq7n.swift:29:12:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if s[i] == \"a\" || s[i] == \"e\" || s[i]\
    \ == \"i\" || s[i] == \"o\" || s[i] == \"u\" {\n           ^~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpihuggq7n.swift:29:27:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if s[i] == \"a\" || s[i] == \"e\" || s[i]\
    \ == \"i\" || s[i] == \"o\" || s[i] == \"u\" {\n                          ^~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpihuggq7n.swift:29:42:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if s[i] == \"a\" || s[i] == \"e\" || s[i]\
    \ == \"i\" || s[i] == \"o\" || s[i] == \"u\" {\n                             \
    \            ^~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly\
    \ marked unavailable here\n    public subscript(i: Int) -> Character { get }\n\
    \           ^\n/tmp/tmpihuggq7n.swift:29:57: error: 'subscript(_:)' is unavailable:\
    \ cannot s"
  stdout: ''
  timestamp: 1660014411
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"\
    ]\n/// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n\
    /// select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfunc\
    \ select_words(s: String, n: Int) -> [String] {\n    var words = [String]()\n\
    \    var index = 0\n    var last = 0\n    var found = false\n    for index in\
    \ 0..<s.characters.count {\n        let char = s.characters[index]\n        if\
    \ char == \" \" {\n            if found {\n                words.append(String(s.characters[last..<index]))\n\
    \            }\n            last = index + 1\n            found = false\n    \
    \    } else if char == \"a\" || char == \"e\" || char == \"i\" || char == \"o\"\
    \ || char == \"u\" {\n            if found {\n                words.append(String(s.characters[last..<index]))\n\
    \            }\n            last = index + 1\n            found = false\n    \
    \    } else if char == \"n\" {\n            if found {\n                words.append(String(s.characters[last..<index]))\n\
    \            }\n            last = index + 1\n            found = false\n    \
    \    } else if char == \"s\" {\n            if found {\n                words.append(String(s.characters[last..<index]))\n\
    \            }\n            last = index + 1\n            found = false\n    \
    \    } else if char == \"t\" || char == \"h\" || char == \"r\" || char == \"d\"\
    \ || char == \"g\" || char == \"f\" || char == \"v\" || char == \"b\" || char\
    \ == \"j\" {\n            if found {\n                words.append(String(s.characters[last..<index]))\n\
    \            }\n            last = index + 1\n            found = false\n    \
    \    } else if char == \"c\" || char == \"k\" || char == \"m\" || char == \"p\"\
    \ || char == \"v\" || char == \"b\" || char == \"j\" {\n            if found {\n\
    \                words.append(String(s.characters[last..<index]))\n          \
    \  }\n            last = index + 1\n            found = false\n        } else\
    \ if char == \"n\" {\n            if found {\n                words.append(String(s.characters[last..<index]))\n\
    \            }\n            last = index + 1\n            found = false\n    \
    \    } else if char == \"y\" {\n            if found {\n                words.append(String(s.characters[last..<index]))\n\
    \            }\n            last = index + 1\n            found = false\n    \
    \    } else if char == \"p\" {\n            if found {\n                words.append(String(s.characters[last..<index]))\n\
    \            }\n            last = index + 1\n            found = false\n    \
    \    } else if char == \"t\" {\n            if found {\n                words.append(String(s.characters[last..<index]))\n\
    \            }\n            last = index + 1\n            found = false\n    \
    \    } else if char == \"h\" {\n            if found {\n                words.append(String(s.characters[last..<index]))\n\
    \            }\n            last = index + 1\n            found = false\n    \
    \    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary\
    \ had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had\
    \ a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple\
    \ white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\"\
    , n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"\
    ])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s:\
    \ \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmp5bk9qgh4.swift:108:69: error: expected '}' at end of brace statement\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])\n\
    \                                                                    ^\n/tmp/tmp5bk9qgh4.swift:18:41:\
    \ note: to match this opening '{'\n    for index in 0..<s.characters.count {\n\
    \                                        ^\n/tmp/tmp5bk9qgh4.swift:108:69: error:\
    \ expected '}' at end of brace statement\nassert(select_words(s: \"a b c d e f\"\
    , n: 1) == [\"b\", \"c\", \"d\", \"f\"])\n                                   \
    \                                 ^\n/tmp/tmp5bk9qgh4.swift:13:50: note: to match\
    \ this opening '{'\nfunc select_words(s: String, n: Int) -> [String] {\n     \
    \                                            ^\n/tmp/tmp5bk9qgh4.swift:18:24:\
    \ error: 'characters' is unavailable: Please use String directly\n    for index\
    \ in 0..<s.characters.count {\n                       ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmp5bk9qgh4.swift:19:20: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        let char = s.characters[index]\n                   ^~~~~~~~~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmp5bk9qgh4.swift:19:22:\
    \ error: 'characters' is unavailable: Please use String directly\n        let\
    \ char = s.characters[index]\n                     ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmp5bk9qgh4.swift:22:37: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an integer range, use a String.Index\
    \ range instead.\n                words.append(String(s.characters[last..<index]))\n\
    \                                    ^~~~~~~~~~~~~~~~~~~~~~~~~~\nSwift.String:5:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable"
  stdout: ''
  timestamp: 1660014410
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"\
    ]\n/// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n\
    /// select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfunc\
    \ select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    \n    if s == \"\" {\n        return result\n    }\n    \n    for char in\
    \ s.characters {\n        if char.hasConsonant() {\n            if result.count\
    \ < n {\n                result.append(String(char))\n            }\n        }\n\
    \    }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s:\
    \ \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"\
    Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmp0gyzfckj.swift:20:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmp0gyzfckj.swift:21:17:\
    \ error: value of type 'Character' has no member 'hasConsonant'\n        if char.hasConsonant()\
    \ {\n           ~~~~ ^~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014410
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"\
    ]\n/// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n\
    /// select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfunc\
    \ select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    \n    if s == \"\" {\n        return result\n    }\n    \n    var index =\
    \ 0\n    var currentWord = \"\"\n    \n    for char in s.characters {\n      \
    \  if char == \" \" {\n            if currentWord != \"\" {\n                result.append(currentWord)\n\
    \                currentWord = \"\"\n            }\n        } else {\n       \
    \     if char == \"a\" || char == \"e\" || char == \"i\" || char == \"o\" || char\
    \ == \"u\" {\n                currentWord += char\n            } else {\n    \
    \            if currentWord == \"\" {\n                    currentWord = String(char)\n\
    \                } else {\n                    currentWord += String(char)\n \
    \               }\n            }\n        }\n        \n        if index == n {\n\
    \            result.append(currentWord)\n            currentWord = \"\"\n    \
    \        index = 0\n        }\n        \n        index++\n    }\n    \n    if\
    \ currentWord != \"\" {\n        result.append(currentWord)\n    }\n    \n   \
    \ return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"\
    Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary\
    \ had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpm4m9w0s3.swift:23:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpm4m9w0s3.swift:31:32:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \                currentWord += char\n                               ^\n/tmp/tmpm4m9w0s3.swift:47:14:\
    \ error: cannot find operator '++' in scope; did you mean '+= 1'?\n        index++\n\
    \             ^~\n"
  stdout: ''
  timestamp: 1660014410
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"\
    ]\n/// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n\
    /// select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfunc\
    \ select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    for word in s.split(\" \") {\n        if word.hasPrefix(\"a\") {\n      \
    \      if word.hasPrefix(\"b\") {\n                if word.hasPrefix(\"c\") {\n\
    \                    if word.hasPrefix(\"d\") {\n                        if word.hasPrefix(\"\
    e\") {\n                            if word.hasPrefix(\"f\") {\n             \
    \                   if word.hasPrefix(\"g\") {\n                             \
    \       if word.hasPrefix(\"h\") {\n                                        if\
    \ word.hasPrefix(\"i\") {\n                                            if word.hasPrefix(\"\
    j\") {\n                                                if word.hasPrefix(\"k\"\
    ) {\n                                                    if word.hasPrefix(\"\
    l\") {\n                                                        if word.hasPrefix(\"\
    m\") {\n                                                            if word.hasPrefix(\"\
    n\") {\n                                                                if word.hasPrefix(\"\
    o\") {\n                                                                    if\
    \ word.hasPrefix(\"p\") {\n                                                  \
    \                      if word.hasPrefix(\"q\") {\n                          \
    \                                                  if word.hasPrefix(\"r\") {\n\
    \                                                                            \
    \    if word.hasPrefix(\"s\") {\n                                            \
    \                                        if word.hasPrefix(\"t\") {\n        \
    \                                                                            \
    \    if word.hasPrefix(\"u\") {\n                                            \
    \                                                if word.hasPrefix(\"v\") {\n\
    \                                                                            \
    \                    if word.hasPrefix(\"w\") {\n                            \
    \                                                                        if word.hasPrefix(\"\
    x\") {\n                                                                     \
    \                                   if word.hasPrefix(\"y\") {\n             \
    \                                                                            \
    \                   if word.hasPrefix(\"z\") {\n                             \
    \                                                                            \
    \       if word.hasPrefix(\"A\") {\n                                         \
    \                                                                           if\
    \ word.hasPrefix(\"B\") {\n                                                  \
    \                                                                      if word.hasPrefix(\"\
    C\") {\n                                                                     \
    \                                                       if word.hasPrefix(\"D\"\
    ) {\n                                                                        \
    \                                                                        if word.hasPrefix(\"\
    E\") {\n                                                                     \
    \                                                               if word.hasPrefix(\"\
    F\") {\n                                                                     \
    \                                                                            \
    \       if word.hasPrefix(\"G\") {\n                                         \
    \                                                                            \
    \                                       if word.hasPrefix(\"H\") {\n         \
    \                                                                            \
    \                                                                           if\
    \ word.hasPrefix(\"I\") {\n                                                  \
    \                                                                            \
    \      if word.hasPrefix(\"J\") {\n                                          \
    \                                                                            \
    \                                  if word.hasPrefix(\"K\") {\n              \
    \                                                                            \
    \                                                                  if word.hasPrefix(\"\
    L\") {\n                                                                     \
    \                                                                            \
    \               if word.hasPrefix(\"M\") {\n                                 \
    \                                                                            \
    \                       if word.hasPrefix(\"N\") {\n                         \
    \                                                                            \
    \                                                   if word.hasPrefix(\"O\") {\n\
    \                                                                            \
    \                                                                            \
    \    if word.hasPrefix(\"P\") {\n                                            \
    \                                                                            \
    \                                        if word.hasPrefix(\"Q\") {\n        \
    \                                                                            \
    \                                                if word.hasPrefix(\"R\") {\n\
    \                                                                            \
    \                                                                            if\
    \ word.hasPrefix(\"S\") {\n                                                  \
    \                                                                            \
    \                              if word.hasPrefix(\"T\") {\n                  \
    \                                                                            \
    \                                                                  if word.hasPrefix(\"\
    U\") {\n                                                                     \
    \                                                               if word.hasPrefix(\"\
    V\") {\n                                                                     \
    \                                                                            \
    \       if word.hasPrefix(\"W\") {\n                                         \
    \                                                                            \
    \                                       if word.hasPrefix(\"X\") {\n         \
    \                                                                            \
    \                                                                           if\
    \ word.hasPrefix(\"Y\") {\n                                                  \
    \                                                                            \
    \                                      if word.\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"\
    ])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"\
    lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmp56h4ku_q.swift:67:172: error: expected member name following '.'\n\
    \                                                                            \
    \                                                                            \
    \            if word.\n                                                      \
    \                                                                            \
    \                                         ^\n/tmp/tmp56h4ku_q.swift:67:173: error:\
    \ expected '{' after 'if' condition\n                                        \
    \                                                                            \
    \                                                if word.\n                  \
    \                                                                            \
    \                                                                            \
    \  ^\n/tmp/tmp56h4ku_q.swift:89:69: error: expected '}' at end of brace statement\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])\n\
    \                                                                    ^\n/tmp/tmp56h4ku_q.swift:65:180:\
    \ note: to match this opening '{'\n                                          \
    \                                                                            \
    \                                      if word.hasPrefix(\"X\") {\n          \
    \                                                                            \
    \                                                                            \
    \                 ^\n/tmp/tmp56h4ku_q.swift:89:69: error: expected '}' at end\
    \ of brace statement\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\"\
    , \"c\", \"d\", \"f\"])\n                                                    \
    \                ^\n/tmp/tmp56h4ku_q.swift:64:176: note: to match this opening\
    \ '{'\n                                                                      \
    \                                                                            \
    \      if word.hasPrefix(\"W\") {\n                                          \
    \                                                                         "
  stdout: ''
  timestamp: 1660014410
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"\
    ]\n/// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n\
    /// select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfunc\
    \ select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    if s == \"\" {\n        return result\n    }\n    var count = 0\n    for\
    \ letter in s {\n        if letter == \" \" {\n            count += 1\n      \
    \  }\n        if count == n {\n            result.append(letter)\n           \
    \ count = 0\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"\
    little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\"\
    , \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpwt8qm_vr.swift:24:27: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n            result.append(letter)\n    \
    \                      ^\n"
  stdout: ''
  timestamp: 1660014410
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"\
    ]\n/// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n\
    /// select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfunc\
    \ select_words(s: String, n: Int) -> [String] {\n    var words = [String]()\n\
    \    var i = 0\n    var j = 0\n    var k = 0\n    var l = 0\n    var m = 0\n \
    \   var n = 0\n    var o = 0\n    var p = 0\n    var q = 0\n    var r = 0\n  \
    \  var s = 0\n    var t = 0\n    var u = 0\n    var v = 0\n    var w = 0\n   \
    \ var x = 0\n    var y = 0\n    var z = 0\n    var a = 0\n    var b = 0\n    var\
    \ c = 0\n    var d = 0\n    var e = 0\n    var f = 0\n    var g = 0\n    var h\
    \ = 0\n    var i = 0\n    var j = 0\n    var k = 0\n    var l = 0\n    var m =\
    \ 0\n    var n = 0\n    var o = 0\n    var p = 0\n    var q = 0\n    var r = 0\n\
    \    var s = 0\n    var t = 0\n    var u = 0\n    var v = 0\n    var w = 0\n \
    \   var x = 0\n    var y = 0\n    var z = 0\n    var a = 0\n    var b = 0\n  \
    \  var c = 0\n    var d = 0\n    var e = 0\n    var f = 0\n    var g = 0\n   \
    \ var h = 0\n    var i = 0\n    var j = 0\n    var k = 0\n    var l = 0\n    var\
    \ m = 0\n    var n = 0\n    var o = 0\n    var p = 0\n    var q = 0\n    var r\
    \ = 0\n    var s = 0\n    var t = 0\n    var u = 0\n    var v = 0\n    var w =\
    \ 0\n    var x = 0\n    var y = 0\n    var z = 0\n    var a = 0\n    var b = 0\n\
    \    var c = 0\n    var d = 0\n    var e = 0\n    var f = 0\n    var g = 0\n \
    \   var h = 0\n    var i = 0\n    var j = 0\n    var k = 0\n    var l = 0\n  \
    \  var m = 0\n    var n = 0\n    var o = 0\n    var p = 0\n    var q = 0\n   \
    \ var r = 0\n    var s = 0\n    var t = 0\n    var u = 0\n    var v = 0\n    var\
    \ w = 0\n    var x = 0\n    var y = 0\n    var z = 0\n    var a = 0\n    var b\
    \ = 0\n    var c = 0\n    var d = 0\n    var e = 0\n    var f = 0\n    var g =\
    \ 0\n    var h = 0\n    var i = 0\n    var j = 0\n    var k = 0\n    var l = 0\n\
    \    var m = 0\n    var n = 0\n    var o = 0\n    var p = 0\n    var q = 0\n \
    \   var r = 0\n    var s = 0\n    var t = 0\n    var u = 0\n    var v = 0\n  \
    \  var w = 0\n    var x = 0\n    var y = 0\n    var z = 0\n    var a = 0\n   \
    \ var b = 0\n    var c = 0\n    var d = 0\n    var e = 0\n    var f = 0\n    var\
    \ g = 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary\
    \ had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had\
    \ a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple\
    \ white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\"\
    , n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"\
    ])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s:\
    \ \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmprr1kdnls.swift:41:9: error: invalid redeclaration of 'i'\n    var\
    \ i = 0\n        ^\n/tmp/tmprr1kdnls.swift:15:9: note: 'i' previously declared\
    \ here\n    var i = 0\n        ^\n/tmp/tmprr1kdnls.swift:42:9: error: invalid\
    \ redeclaration of 'j'\n    var j = 0\n        ^\n/tmp/tmprr1kdnls.swift:16:9:\
    \ note: 'j' previously declared here\n    var j = 0\n        ^\n/tmp/tmprr1kdnls.swift:43:9:\
    \ error: invalid redeclaration of 'k'\n    var k = 0\n        ^\n/tmp/tmprr1kdnls.swift:17:9:\
    \ note: 'k' previously declared here\n    var k = 0\n        ^\n/tmp/tmprr1kdnls.swift:44:9:\
    \ error: invalid redeclaration of 'l'\n    var l = 0\n        ^\n/tmp/tmprr1kdnls.swift:18:9:\
    \ note: 'l' previously declared here\n    var l = 0\n        ^\n/tmp/tmprr1kdnls.swift:45:9:\
    \ error: invalid redeclaration of 'm'\n    var m = 0\n        ^\n/tmp/tmprr1kdnls.swift:19:9:\
    \ note: 'm' previously declared here\n    var m = 0\n        ^\n/tmp/tmprr1kdnls.swift:46:9:\
    \ error: invalid redeclaration of 'n'\n    var n = 0\n        ^\n/tmp/tmprr1kdnls.swift:20:9:\
    \ note: 'n' previously declared here\n    var n = 0\n        ^\n/tmp/tmprr1kdnls.swift:47:9:\
    \ error: invalid redeclaration of 'o'\n    var o = 0\n        ^\n/tmp/tmprr1kdnls.swift:21:9:\
    \ note: 'o' previously declared here\n    var o = 0\n        ^\n/tmp/tmprr1kdnls.swift:48:9:\
    \ error: invalid redeclaration of 'p'\n    var p = 0\n        ^\n/tmp/tmprr1kdnls.swift:22:9:\
    \ note: 'p' previously declared here\n    var p = 0\n        ^\n/tmp/tmprr1kdnls.swift:49:9:\
    \ error: invalid redeclaration of 'q'\n    var q = 0\n        ^\n/tmp/tmprr1kdnls.swift:23:9:\
    \ note: 'q' previously declared here\n    var q = 0\n        ^\n/tmp/tmprr1kdnls.swift:50:9:\
    \ error: invalid redeclaration of 'r'\n    var r = 0\n        ^\n/tmp/tmprr1kdnls.swift:24:9:\
    \ note: 'r' previously declared here\n    var r = 0\n        ^\n/tmp/tmprr1kdnls.swift:51:9:\
    \ error: invalid redeclaration of 's'\n    var s = 0\n        ^\n/tmp/tmprr1kdnls.swift:25:9:\
    \ note: 's' previously declared here\n    var s = 0\n        ^\n/tmp/tmprr1kdnls.swift:52:9:\
    \ error: invalid redeclaration of 't'\n    var t = 0\n        ^\n/tmp/tmprr1k"
  stdout: ''
  timestamp: 1660014410
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"\
    ]\n/// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n\
    /// select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfunc\
    \ select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    \n    if s == \"\" {\n        return result\n    }\n    \n    for char in\
    \ s.characters {\n        if char.hasConsonant() {\n            if result.count\
    \ < n {\n                result.append(String(char))\n            }\n        }\n\
    \    }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s:\
    \ \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"\
    Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmp0gyzfckj.swift:20:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmp0gyzfckj.swift:21:17:\
    \ error: value of type 'Character' has no member 'hasConsonant'\n        if char.hasConsonant()\
    \ {\n           ~~~~ ^~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014410
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"\
    ]\n/// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n\
    /// select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfunc\
    \ select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    var i = 0\n    var j = 0\n    var k = 0\n    var l = 0\n    var m = 0\n \
    \   var n = 0\n    var o = 0\n    var p = 0\n    var q = 0\n    var r = 0\n  \
    \  var s = 0\n    var t = 0\n    var u = 0\n    var v = 0\n    var w = 0\n   \
    \ var x = 0\n    var y = 0\n    var z = 0\n    var a = 0\n    var b = 0\n    var\
    \ c = 0\n    var d = 0\n    var e = 0\n    var f = 0\n    var g = 0\n    var h\
    \ = 0\n    var i = 0\n    var j = 0\n    var k = 0\n    var l = 0\n    var m =\
    \ 0\n    var n = 0\n    var o = 0\n    var p = 0\n    var q = 0\n    var r = 0\n\
    \    var s = 0\n    var t = 0\n    var u = 0\n    var v = 0\n    var w = 0\n \
    \   var x = 0\n    var y = 0\n    var z = 0\n    var a = 0\n    var b = 0\n  \
    \  var c = 0\n    var d = 0\n    var e = 0\n    var f = 0\n    var g = 0\n   \
    \ var h = 0\n    var i = 0\n    var j = 0\n    var k = 0\n    var l = 0\n    var\
    \ m = 0\n    var n = 0\n    var o = 0\n    var p = 0\n    var q = 0\n    var r\
    \ = 0\n    var s = 0\n    var t = 0\n    var u = 0\n    var v = 0\n    var w =\
    \ 0\n    var x = 0\n    var y = 0\n    var z = 0\n    var a = 0\n    var b = 0\n\
    \    var c = 0\n    var d = 0\n    var e = 0\n    var f = 0\n    var g = 0\n \
    \   var h = 0\n    var i = 0\n    var j = 0\n    var k = 0\n    var l = 0\n  \
    \  var m = 0\n    var n = 0\n    var o = 0\n    var p = 0\n    var q = 0\n   \
    \ var r = 0\n    var s = 0\n    var t = 0\n    var u = 0\n    var v = 0\n    var\
    \ w = 0\n    var x = 0\n    var y = 0\n    var z = 0\n    var a = 0\n    var b\
    \ = 0\n    var c = 0\n    var d = 0\n    var e = 0\n    var f = 0\n    var g =\
    \ 0\n    var h = 0\n    var i = 0\n    var j = 0\n    var k = 0\n    var l = 0\n\
    \    var m = 0\n    var n = 0\n    var o = 0\n    var p = 0\n    var q = 0\n \
    \   var r = 0\n    var s = 0\n    var t = 0\n    var u = 0\n    var v = 0\n  \
    \  var w = 0\n    var x = 0\n    var y = 0\n    var z = 0\n    var a = 0\n   \
    \ var b = 0\n    var c = 0\n    var d = 0\n    var e = 0\n    var f = 0\n    var\
    \ g = 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary\
    \ had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had\
    \ a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple\
    \ white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\"\
    , n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"\
    ])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s:\
    \ \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpv60dryfr.swift:41:9: error: invalid redeclaration of 'i'\n    var\
    \ i = 0\n        ^\n/tmp/tmpv60dryfr.swift:15:9: note: 'i' previously declared\
    \ here\n    var i = 0\n        ^\n/tmp/tmpv60dryfr.swift:42:9: error: invalid\
    \ redeclaration of 'j'\n    var j = 0\n        ^\n/tmp/tmpv60dryfr.swift:16:9:\
    \ note: 'j' previously declared here\n    var j = 0\n        ^\n/tmp/tmpv60dryfr.swift:43:9:\
    \ error: invalid redeclaration of 'k'\n    var k = 0\n        ^\n/tmp/tmpv60dryfr.swift:17:9:\
    \ note: 'k' previously declared here\n    var k = 0\n        ^\n/tmp/tmpv60dryfr.swift:44:9:\
    \ error: invalid redeclaration of 'l'\n    var l = 0\n        ^\n/tmp/tmpv60dryfr.swift:18:9:\
    \ note: 'l' previously declared here\n    var l = 0\n        ^\n/tmp/tmpv60dryfr.swift:45:9:\
    \ error: invalid redeclaration of 'm'\n    var m = 0\n        ^\n/tmp/tmpv60dryfr.swift:19:9:\
    \ note: 'm' previously declared here\n    var m = 0\n        ^\n/tmp/tmpv60dryfr.swift:46:9:\
    \ error: invalid redeclaration of 'n'\n    var n = 0\n        ^\n/tmp/tmpv60dryfr.swift:20:9:\
    \ note: 'n' previously declared here\n    var n = 0\n        ^\n/tmp/tmpv60dryfr.swift:47:9:\
    \ error: invalid redeclaration of 'o'\n    var o = 0\n        ^\n/tmp/tmpv60dryfr.swift:21:9:\
    \ note: 'o' previously declared here\n    var o = 0\n        ^\n/tmp/tmpv60dryfr.swift:48:9:\
    \ error: invalid redeclaration of 'p'\n    var p = 0\n        ^\n/tmp/tmpv60dryfr.swift:22:9:\
    \ note: 'p' previously declared here\n    var p = 0\n        ^\n/tmp/tmpv60dryfr.swift:49:9:\
    \ error: invalid redeclaration of 'q'\n    var q = 0\n        ^\n/tmp/tmpv60dryfr.swift:23:9:\
    \ note: 'q' previously declared here\n    var q = 0\n        ^\n/tmp/tmpv60dryfr.swift:50:9:\
    \ error: invalid redeclaration of 'r'\n    var r = 0\n        ^\n/tmp/tmpv60dryfr.swift:24:9:\
    \ note: 'r' previously declared here\n    var r = 0\n        ^\n/tmp/tmpv60dryfr.swift:51:9:\
    \ error: invalid redeclaration of 's'\n    var s = 0\n        ^\n/tmp/tmpv60dryfr.swift:25:9:\
    \ note: 's' previously declared here\n    var s = 0\n        ^\n/tmp/tmpv60dryfr.swift:52:9:\
    \ error: invalid redeclaration of 't'\n    var t = 0\n        ^\n/tmp/tmpv60d"
  stdout: ''
  timestamp: 1660014410
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"\
    ]\n/// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n\
    /// select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfunc\
    \ select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    \n    if s == \"\" {\n        return result\n    }\n    \n    let chars =\
    \ s.characters\n    \n    for char in chars {\n        if char == \" \" {\n  \
    \          continue\n        }\n        \n        if char.unicodeScalars.filter({\
    \ $0.isConsonant() == true }).count == n {\n            result.append(String(char))\n\
    \        }\n    }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"\
    ])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"\
    lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpkb1w2jqm.swift:20:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    let chars = s.characters\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpkb1w2jqm.swift:27:44:\
    \ error: value of type 'Unicode.Scalar' has no member 'isConsonant'\n        if\
    \ char.unicodeScalars.filter({ $0.isConsonant() == true }).count == n {\n    \
    \                                    ~~ ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014410
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"\
    ]\n/// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n\
    /// select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfunc\
    \ select_words(s: String, n: Int) -> [String] {\n    \n    let vowels = \"aeiouAEIOU\"\
    \n    \n    var words = [String]()\n    \n    if s.isEmpty {\n        return words\n\
    \    }\n    \n    let vowelsCount = s.characters.filter({ vowels.contains($0)\
    \ }).count\n    \n    if vowelsCount == n {\n        words.append(s)\n    }\n\
    \    \n    let consonantsCount = s.characters.filter({ !vowels.contains($0) }).count\n\
    \    \n    if consonantsCount == n {\n        words.append(s)\n    }\n    \n \
    \   return words\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"\
    Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary\
    \ had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmp3lex78jt.swift:23:25: error: 'characters' is unavailable: Please\
    \ use String directly\n    let vowelsCount = s.characters.filter({ vowels.contains($0)\
    \ }).count\n                        ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmp3lex78jt.swift:29:29: error: 'characters' is unavailable:\
    \ Please use String directly\n    let consonantsCount = s.characters.filter({\
    \ !vowels.contains($0) }).count\n                            ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660014410
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"\
    ]\n/// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n\
    /// select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfunc\
    \ select_words(s: String, n: Int) -> [String] {\n    \n    let vowels = \"aeiouAEIOU\"\
    \n    \n    var result = [String]()\n    \n    if s == \"\" {\n        return\
    \ result\n    }\n    \n    let vowelsCount = s.characters.filter({ vowels.contains($0)\
    \ }).count\n    \n    if vowelsCount == n {\n        return s.characters.filter({\
    \ vowels.contains($0) }).map { String($0) }\n    }\n    \n    let consonantsCount\
    \ = s.characters.filter({ !vowels.contains($0) }).count\n    \n    if consonantsCount\
    \ == n {\n        return s.characters.filter({ !vowels.contains($0) }).map { String($0)\
    \ }\n    }\n    \n    if consonantsCount > n {\n        return select_words(s.substringToIndex(s.startIndex.advancedBy(consonantsCount\
    \ - n)), n)\n    }\n    \n    if vowelsCount > n {\n        return select_words(s.substringToIndex(s.startIndex.advancedBy(vowelsCount\
    \ - n)), n)\n    }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"\
    ])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"\
    lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpgqsrzpfe.swift:23:25: error: 'characters' is unavailable: Please\
    \ use String directly\n    let vowelsCount = s.characters.filter({ vowels.contains($0)\
    \ }).count\n                        ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpgqsrzpfe.swift:26:18: error: 'characters' is unavailable:\
    \ Please use String directly\n        return s.characters.filter({ vowels.contains($0)\
    \ }).map { String($0) }\n                 ^~~~~~~~~~\nSwift.String:5:16: note:\
    \ 'characters' was obsoleted in Swift 5.0\n    public var characters: String {\
    \ get set }\n               ^\n/tmp/tmpgqsrzpfe.swift:29:29: error: 'characters'\
    \ is unavailable: Please use String directly\n    let consonantsCount = s.characters.filter({\
    \ !vowels.contains($0) }).count\n                            ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmpgqsrzpfe.swift:32:18: error: 'characters'\
    \ is unavailable: Please use String directly\n        return s.characters.filter({\
    \ !vowels.contains($0) }).map { String($0) }\n                 ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmpgqsrzpfe.swift:36:28: error: missing\
    \ argument labels 's:n:' in call\n        return select_words(s.substringToIndex(s.startIndex.advancedBy(consonantsCount\
    \ - n)), n)\n                           ^\n                            s:    \
    \                                                            n: \n/tmp/tmpgqsrzpfe.swift:36:31:\
    \ error: value of type 'String' has no member 'substringToIndex'\n        return\
    \ select_words(s.substringToIndex(s.startIndex.advancedBy(consonantsCount - n)),\
    \ n)\n                            ~ ^~~~~~~~~~~~~~~~\n/tmp/tmpgqsrzpfe.swift:36:61:\
    \ error: value of type 'String.Index' has no member 'advancedBy'\n        return\
    \ select_words(s.substringToIndex(s.startIndex.advancedBy(consonantsCount - n)), "
  stdout: ''
  timestamp: 1660014410
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"\
    ]\n/// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n\
    /// select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfunc\
    \ select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    \n    if s == \"\" {\n        return result\n    }\n    \n    let vowels\
    \ = \"aeiou\"\n    \n    for letter in s {\n        if letter == \" \" {\n   \
    \         continue\n        }\n        \n        if letter in vowels {\n     \
    \       if result.count < n {\n                result.append(letter)\n       \
    \     }\n        }\n    }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"\
    little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\"\
    , \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmp010eio8y.swift:27:19: error: expected '{' after 'if' condition\n\
    \        if letter in vowels {\n                  ^\n/tmp/tmp010eio8y.swift:27:12:\
    \ error: cannot convert value of type 'Character' to expected condition type 'Bool'\n\
    \        if letter in vowels {\n           ^~~~~~\n/tmp/tmp010eio8y.swift:29:31:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \                result.append(letter)\n                              ^\n"
  stdout: ''
  timestamp: 1660014410
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"\
    ]\n/// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n\
    /// select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfunc\
    \ select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    \n    if s == \"\" {\n        return result\n    }\n    \n    for char in\
    \ s.characters {\n        if char.hasConsonant() {\n            if result.count\
    \ < n {\n                result.append(String(char))\n            }\n        }\n\
    \    }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s:\
    \ \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"\
    Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmp0gyzfckj.swift:20:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmp0gyzfckj.swift:21:17:\
    \ error: value of type 'Character' has no member 'hasConsonant'\n        if char.hasConsonant()\
    \ {\n           ~~~~ ^~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014410
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"\
    ]\n/// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n\
    /// select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfunc\
    \ select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    var i = 0\n    var j = 0\n    var k = 0\n    var count = 0\n    var last\
    \ = 0\n    var lastCount = 0\n    var lastLast = 0\n    var lastLastCount = 0\n\
    \    var lastLastLast = 0\n    var lastLastLastCount = 0\n    var lastLastLastLast\
    \ = 0\n    var lastLastLastLastCount = 0\n    var lastLastLastLastLast = 0\n \
    \   var lastLastLastLastLastCount = 0\n    var lastLastLastLastLastLast = 0\n\
    \    var lastLastLastLastLastLastCount = 0\n    var lastLastLastLastLastLastLast\
    \ = 0\n    var lastLastLastLastLastLastLastCount = 0\n    var lastLastLastLastLastLastLastLast\
    \ = 0\n    var lastLastLastLastLastLastLastCount = 0\n    var lastLastLastLastLastLastLastLast\
    \ = 0\n    var lastLastLastLastLastLastLastLastCount = 0\n    var lastLastLastLastLastLastLastLastLast\
    \ = 0\n    var lastLastLastLastLastLastLastLastCount = 0\n    var lastLastLastLastLastLastLastLastLast\
    \ = 0\n    var lastLastLastLastLastLastLastLastLastCount = 0\n    var lastLastLastLastLastLastLastLastLastLast\
    \ = 0\n    var lastLastLastLastLastLastLastLastLastCount = 0\n    var lastLastLastLastLastLastLastLastLastLast\
    \ = 0\n    var lastLastLastLastLastLastLastLastLastLastCount = 0\n    var lastLastLastLastLastLastLastLastLastLast\
    \ = 0\n    var lastLastLastLastLastLastLastLastLastLastCount = 0\n    var lastLastLastLastLastLastLastLastLastLastLast\
    \ = 0\n    var lastLastLastLastLastLastLastLastLastLastCount = 0\n    var lastLastLastLastLastLastLastLastLastLastLastLast\
    \ = 0\n    var lastLastLastLastLastLastLastLastLastLastLastCount = 0\n    var\
    \ lastLastLastLastLastLastLastLastLastLastLastLast = 0\n    var lastLastLastLastLastLastLastLastLastLastLastLastCount\
    \ = 0\n    var lastLastLastLastLastLastLastLastLastLastLastLastLast = 0\n    var\
    \ lastLastLastLastLastLastLastLastLastLastLastLastCount = 0\n    var lastLastLastLastLastLastLastLastLastLastLastLast\
    \ = 0\n    var lastLastLastLastLastLastLastLastLastLastLastLastCount = 0\n   \
    \ var lastLastLastLastLastLastLastLastLastLastLastLastLast = 0\n    var lastLastLastLastLastLastLastLastLastLastLastLastCount\
    \ = 0\n    var lastLastLastLastLastLastLastLastLastLastLastLastLast = 0\n    var\
    \ lastLastLastLastLastLastLastLastLastLastLast\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"\
    ])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"\
    lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpor0uazfy.swift:34:9: error: invalid redeclaration of 'lastLastLastLastLastLastLastCount'\n\
    \    var lastLastLastLastLastLastLastCount = 0\n        ^\n/tmp/tmpor0uazfy.swift:32:9:\
    \ note: 'lastLastLastLastLastLastLastCount' previously declared here\n    var\
    \ lastLastLastLastLastLastLastCount = 0\n        ^\n/tmp/tmpor0uazfy.swift:35:9:\
    \ error: invalid redeclaration of 'lastLastLastLastLastLastLastLast'\n    var\
    \ lastLastLastLastLastLastLastLast = 0\n        ^\n/tmp/tmpor0uazfy.swift:33:9:\
    \ note: 'lastLastLastLastLastLastLastLast' previously declared here\n    var lastLastLastLastLastLastLastLast\
    \ = 0\n        ^\n/tmp/tmpor0uazfy.swift:38:9: error: invalid redeclaration of\
    \ 'lastLastLastLastLastLastLastLastCount'\n    var lastLastLastLastLastLastLastLastCount\
    \ = 0\n        ^\n/tmp/tmpor0uazfy.swift:36:9: note: 'lastLastLastLastLastLastLastLastCount'\
    \ previously declared here\n    var lastLastLastLastLastLastLastLastCount = 0\n\
    \        ^\n/tmp/tmpor0uazfy.swift:39:9: error: invalid redeclaration of 'lastLastLastLastLastLastLastLastLast'\n\
    \    var lastLastLastLastLastLastLastLastLast = 0\n        ^\n/tmp/tmpor0uazfy.swift:37:9:\
    \ note: 'lastLastLastLastLastLastLastLastLast' previously declared here\n    var\
    \ lastLastLastLastLastLastLastLastLast = 0\n        ^\n/tmp/tmpor0uazfy.swift:42:9:\
    \ error: invalid redeclaration of 'lastLastLastLastLastLastLastLastLastCount'\n\
    \    var lastLastLastLastLastLastLastLastLastCount = 0\n        ^\n/tmp/tmpor0uazfy.swift:40:9:\
    \ note: 'lastLastLastLastLastLastLastLastLastCount' previously declared here\n\
    \    var lastLastLastLastLastLastLastLastLastCount = 0\n        ^\n/tmp/tmpor0uazfy.swift:43:9:\
    \ error: invalid redeclaration of 'lastLastLastLastLastLastLastLastLastLast'\n\
    \    var lastLastLastLastLastLastLastLastLastLast = 0\n        ^\n/tmp/tmpor0uazfy.swift:41:9:\
    \ note: 'lastLastLastLastLastLastLastLastLastLast' previously declared here\n\
    \    var lastLastLastLastLastLastLastLastLastLast = 0\n        ^\n/tmp/tmpor0uazfy.swift:45:9:\
    \ error: invalid redeclaration of 'lastLastLastLastLastLastLastLastLastLast'\n\
    \    var lastLastLastLastLastLa"
  stdout: ''
  timestamp: 1660014410
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"\
    ]\n/// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n\
    /// select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfunc\
    \ select_words(s: String, n: Int) -> [String] {\n    \n    var result = [String]()\n\
    \    \n    if s == \"\" {\n        return result\n    }\n    \n    for char in\
    \ s {\n        if char == \" \" {\n            continue\n        }\n        \n\
    \        if char == \"a\" || char == \"e\" || char == \"i\" || char == \"o\" ||\
    \ char == \"u\" {\n            continue\n        }\n        \n        if char\
    \ == \"n\" {\n            if n > 1 {\n                continue\n            }\n\
    \        }\n        \n        if char == \"c\" || char == \"d\" || char == \"\
    h\" || char == \"l\" || char == \"r\" || char == \"v\" {\n            if n > 2\
    \ {\n                continue\n            }\n        }\n        \n        if\
    \ char == \"b\" || char == \"f\" || char == \"p\" || char == \"s\" || char ==\
    \ \"t\" {\n            if n > 3 {\n                continue\n            }\n \
    \       }\n        \n        if char == \"m\" || char == \"p\" || char == \"t\"\
    \ || char == \"v\" {\n            if n > 4 {\n                continue\n     \
    \       }\n        }\n        \n        if char == \"k\" || char == \"q\" || char\
    \ == \"x\" || char == \"z\" {\n            if n > 5 {\n                continue\n\
    \            }\n        }\n        \n        if char == \"j\" || char == \"z\"\
    \ {\n            if n > 6 {\n                continue\n            }\n       \
    \ }\n        \n        if char == \"x\" || char == \"z\" {\n            if n >\
    \ 7 {\n                continue\n            }\n        }\n        \n        if\
    \ char == \"w\" || char == \"z\" {\n            if n > 8 {\n                continue\n\
    \            }\n        }\n        \n        if char == \"v\" || char == \"z\"\
    \ {\n            if n > 9 {\n                continue\n            }\n       \
    \ }\n        \n        if char == \"f\" || char == \"z\" {\n            if n >\
    \ 10 {\n                continue\n            }\n        }\n        \n       \
    \ if char == \"b\" || char == \"z\" {\n            if n > 11 {\n             \
    \   continue\n            }\n        }\n        \n        if char == \"s\" ||\
    \ char == \"z\" {\n            if n > 12 {\n                continue\n       \
    \     }\n        }\n        \n        if char == \"p\" || char == \"z\" {\n  \
    \          if n > 13 {\n                continue\n            }\n        }\n \
    \       \n        if char == \"m\" || char == \"z\" {\n            if n > 14 {\n\
    \                continue\n            }\n        }\n        \n        if char\
    \ == \"k\" || char == \"z\" {\n            if n > 15 {\n                continue\n\
    \            }\n        }\n        \n        if char == \"j\" || char == \"z\"\
    \ {\n            if n > 16 {\n                continue\n            }\n      \
    \  }\n        \n        if char == \"x\" || char == \"z\" {\n            if n\
    \ > 17 {\n                continue\n            }\n        }\n        \n\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n:\
    \ 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3)\
    \ == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n:\
    \ 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"\
    world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s:\
    \ \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1)\
    \ == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpvwqx6ccu.swift:154:69: error: expected '}' at end of brace statement\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])\n\
    \                                                                    ^\n/tmp/tmpvwqx6ccu.swift:13:50:\
    \ note: to match this opening '{'\nfunc select_words(s: String, n: Int) -> [String]\
    \ {\n                                                 ^\n/tmp/tmpvwqx6ccu.swift:136:6:\
    \ error: operator functions can only be declared at global or in type scope\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n/tmp/tmpvwqx6ccu.swift:15:9:\
    \ warning: variable 'result' was never mutated; consider changing to 'let' constant\n\
    \    var result = [String]()\n    ~~~ ^\n    let\n"
  stdout: ''
  timestamp: 1660014410
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"\
    ]\n/// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n\
    /// select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfunc\
    \ select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    \n    if s == \"\" {\n        return result\n    }\n    \n    for char in\
    \ s.characters {\n        if char == \" \" {\n            continue\n        }\n\
    \        \n        if char.unicodeScalars.filter({ $0.isConsonant() }).count ==\
    \ n {\n            result.append(String(char))\n        }\n    }\n    \n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary\
    \ had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had\
    \ a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple\
    \ white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\"\
    , n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"\
    ])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s:\
    \ \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpx4e3d80w.swift:20:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpx4e3d80w.swift:25:44:\
    \ error: value of type 'Unicode.Scalar' has no member 'isConsonant'\n        if\
    \ char.unicodeScalars.filter({ $0.isConsonant() }).count == n {\n            \
    \                            ~~ ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014410
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"\
    ]\n/// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n\
    /// select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfunc\
    \ select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    \n    if s == \"\" {\n        return result\n    }\n    \n    var i = 0\n\
    \    var j = 0\n    var k = 0\n    \n    for i < s.count {\n        if s[i] ==\
    \ \" \" {\n            j = i\n            \n            for k < n {\n        \
    \        j++\n            }\n            \n            if j == s.count {\n   \
    \             result.append(\"\\(strings[s.startIndex..<s.endIndex])\")\n    \
    \        }\n            \n            i = j\n            \n            for k <\
    \ n {\n                j++\n            }\n            \n            if j == s.count\
    \ {\n                result.append(\"\\(strings[s.startIndex..<s.endIndex])\"\
    )\n            }\n            \n            i = j\n            \n            for\
    \ k < n {\n                j++\n            }\n            \n            if j\
    \ == s.count {\n                result.append(\"\\(strings[s.startIndex..<s.endIndex])\"\
    )\n            }\n            \n            i = j\n            \n            for\
    \ k < n {\n                j++\n            }\n            \n            if j\
    \ == s.count {\n                result.append(\"\\(strings[s.startIndex..<s.endIndex])\"\
    )\n            }\n            \n            i = j\n            \n            for\
    \ k < n {\n                j++\n            }\n            \n            if j\
    \ == s.count {\n                result.append(\"\\(strings[s.startIndex..<s.endIndex])\"\
    )\n            }\n            \n            i = j\n            \n            for\
    \ k < n {\n                j++\n            }\n            \n            if j\
    \ == s.count {\n                result.append(\"\\(strings[s.startIndex..<s.endIndex])\"\
    )\n            }\n            \n            i = j\n            \n            for\
    \ k < n {\n                j++\n            }\n            \n            if j\
    \ == s.count {\n                result.append(\"\\(strings[s.startIndex..<s.endIndex])\"\
    )\n            }\n            \n            i = j\n            \n            for\
    \ k < n {\n                j++\n            }\n            \n            if j\
    \ == s.count {\n                result.append(\"\\(strings[s.startIndex..<s.endIndex])\"\
    )\n            }\n            \n            i = j\n            \n            for\
    \ k < n {\n                j++\n            }\n            \n            if j\
    \ == s.count {\n                result.append(\"\\(strings[s.startIndex..<s.endIndex])\"\
    )\n            }\n            \n            i = j\n            \n            for\
    \ k < n {\n                j++\n            }\n            \n            if j\
    \ == s.count {\n                result.append(\"\\(strings[s.startIndex..<s.endIndex])\"\
    )\n\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(select_words(s: \"Mary had a\
    \ little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little\
    \ lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white\
    \ space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n:\
    \ 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"\
    ])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s:\
    \ \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpd3be57_d.swift:24:11: error: expected 'in' after for-each pattern\n\
    \    for i < s.count {\n          ^\n/tmp/tmpd3be57_d.swift:24:11: error: unary\
    \ operator cannot be separated from its operand\n    for i < s.count {\n     \
    \     ^~\n           \n/tmp/tmpd3be57_d.swift:28:19: error: expected 'in' after\
    \ for-each pattern\n            for k < n {\n                  ^\n/tmp/tmpd3be57_d.swift:28:19:\
    \ error: unary operator cannot be separated from its operand\n            for\
    \ k < n {\n                  ^~\n                   \n/tmp/tmpd3be57_d.swift:38:19:\
    \ error: expected 'in' after for-each pattern\n            for k < n {\n     \
    \             ^\n/tmp/tmpd3be57_d.swift:38:19: error: unary operator cannot be\
    \ separated from its operand\n            for k < n {\n                  ^~\n\
    \                   \n/tmp/tmpd3be57_d.swift:48:19: error: expected 'in' after\
    \ for-each pattern\n            for k < n {\n                  ^\n/tmp/tmpd3be57_d.swift:48:19:\
    \ error: unary operator cannot be separated from its operand\n            for\
    \ k < n {\n                  ^~\n                   \n/tmp/tmpd3be57_d.swift:58:19:\
    \ error: expected 'in' after for-each pattern\n            for k < n {\n     \
    \             ^\n/tmp/tmpd3be57_d.swift:58:19: error: unary operator cannot be\
    \ separated from its operand\n            for k < n {\n                  ^~\n\
    \                   \n/tmp/tmpd3be57_d.swift:68:19: error: expected 'in' after\
    \ for-each pattern\n            for k < n {\n                  ^\n/tmp/tmpd3be57_d.swift:68:19:\
    \ error: unary operator cannot be separated from its operand\n            for\
    \ k < n {\n                  ^~\n                   \n/tmp/tmpd3be57_d.swift:78:19:\
    \ error: expected 'in' after for-each pattern\n            for k < n {\n     \
    \             ^\n/tmp/tmpd3be57_d.swift:78:19: error: unary operator cannot be\
    \ separated from its operand\n            for k < n {\n                  ^~\n\
    \                   \n/tmp/tmpd3be57_d.swift:88:19: error: expected 'in' after\
    \ for-each pattern\n            for k < n {\n                  ^\n/tmp/tmpd3be57_d.swift:88:19:\
    \ error: unary operator ca"
  stdout: ''
  timestamp: 1660014410
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"\
    ]\n/// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n\
    /// select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfunc\
    \ select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    var index = 0\n    var last = 0\n    for letter in s {\n        if letter\
    \ == \" \" {\n            if index == last {\n                result.append(s[last:index])\n\
    \                last = index + 1\n            }\n        } else {\n         \
    \   if index == last {\n                result.append(s[last:index])\n       \
    \         last = index + 1\n            }\n            if letter == \"a\" || letter\
    \ == \"e\" || letter == \"i\" || letter == \"o\" || letter == \"u\" {\n      \
    \          last = index + 1\n            }\n        }\n        index++\n    }\n\
    \    if last < s.count {\n        result.append(s[last:s.count])\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary\
    \ had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had\
    \ a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple\
    \ white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\"\
    , n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"\
    ])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s:\
    \ \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmp3xaysn3p.swift:20:32: error: extraneous argument label 'last:'\
    \ in subscript\n                result.append(s[last:index])\n               \
    \                ^~~~~~\n                                \n/tmp/tmp3xaysn3p.swift:20:32:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \                result.append(s[last:index])\n                              \
    \ ^\n/tmp/tmp3xaysn3p.swift:25:32: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n                result.append(s[last:index])\n\
    \                               ^\n/tmp/tmp3xaysn3p.swift:25:32: error: extraneous\
    \ argument label 'last:' in subscript\n                result.append(s[last:index])\n\
    \                               ^~~~~~\n                                \n/tmp/tmp3xaysn3p.swift:32:14:\
    \ error: cannot find operator '++' in scope; did you mean '+= 1'?\n        index++\n\
    \             ^~\n/tmp/tmp3xaysn3p.swift:35:24: error: cannot convert value of\
    \ type 'Character' to expected argument type 'String'\n        result.append(s[last:s.count])\n\
    \                       ^\n/tmp/tmp3xaysn3p.swift:35:24: error: extraneous argument\
    \ label 'last:' in subscript\n        result.append(s[last:s.count])\n       \
    \                ^~~~~~\n                        \n"
  stdout: ''
  timestamp: 1660014410
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"\
    ]\n/// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n\
    /// select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfunc\
    \ select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    for letter in s.characters {\n        if letter.isConsonant() {\n       \
    \     if result.count < n {\n                result.append(String(letter))\n \
    \           }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"\
    little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\"\
    , \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpv_x0fico.swift:15:21: error: 'characters' is unavailable: Please\
    \ use String directly\n    for letter in s.characters {\n                    ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpv_x0fico.swift:16:19:\
    \ error: value of type 'Character' has no member 'isConsonant'\n        if letter.isConsonant()\
    \ {\n           ~~~~~~ ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014410
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"\
    ]\n/// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n\
    /// select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfunc\
    \ select_words(s: String, n: Int) -> [String] {\n    var words = [String]()\n\
    \    \n    if s == \"\" {\n        return words\n    }\n    \n    for letter in\
    \ s.characters {\n        if letter == \" \" {\n            continue\n       \
    \ }\n        \n        if let index = s.firstIndex(of: letter) {\n           \
    \ let subString = s[..<index]\n            \n            if subString.hasPrefix(letter)\
    \ && subString.hasSuffix(letter) {\n                words.append(subString)\n\
    \            }\n        }\n    }\n    \n    return words\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"\
    little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\"\
    , \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpbs0kfjjk.swift:20:21: error: 'characters' is unavailable: Please\
    \ use String directly\n    for letter in s.characters {\n                    ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpbs0kfjjk.swift:28:16:\
    \ error: instance method 'hasPrefix' requires that 'Character' conform to 'StringProtocol'\n\
    \            if subString.hasPrefix(letter) && subString.hasSuffix(letter) {\n\
    \               ^\nSwift.StringProtocol:2:28: note: where 'Prefix' = 'Character'\n\
    \    @inlinable public func hasPrefix<Prefix>(_ prefix: Prefix) -> Bool where\
    \ Prefix : StringProtocol\n                           ^\n/tmp/tmpbs0kfjjk.swift:28:47:\
    \ error: instance method 'hasSuffix' requires that 'Character' conform to 'StringProtocol'\n\
    \            if subString.hasPrefix(letter) && subString.hasSuffix(letter) {\n\
    \                                              ^\nSwift.StringProtocol:3:28: note:\
    \ where 'Suffix' = 'Character'\n    @inlinable public func hasSuffix<Suffix>(_\
    \ suffix: Suffix) -> Bool where Suffix : StringProtocol\n                    \
    \       ^\n/tmp/tmpbs0kfjjk.swift:29:23: error: no exact matches in call to instance\
    \ method 'append'\n                words.append(subString)\n                 \
    \     ^\nSwift.Array:6:37: note: candidate expects value of type 'String' for\
    \ parameter #1 (got 'String.SubSequence' (aka 'Substring'))\n    @inlinable public\
    \ mutating func append(_ newElement: __owned Element)\n                      \
    \              ^\nSwift.RangeReplaceableCollection:4:37: note: candidate expects\
    \ value of type 'String' for parameter #1 (got 'String.SubSequence' (aka 'Substring'))\n\
    \    @inlinable public mutating func append(_ newElement: __owned Self.Element)\n\
    \                                    ^\n/tmp/tmpbs0kfjjk.swift:29:23: note: found\
    \ candidate with type '(__owned String.SubSequence) -> ()' (aka '(__owned Substring)\
    \ -> ()')\n                words.append(subString)\n                      ^\n"
  stdout: ''
  timestamp: 1660014410
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"\
    ]\n/// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n\
    /// select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfunc\
    \ select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    var i = 0\n    var j = 0\n    var k = 0\n    var l = 0\n    var m = 0\n \
    \   var n = 0\n    var o = 0\n    var p = 0\n    var q = 0\n    var r = 0\n  \
    \  var s = 0\n    var t = 0\n    var u = 0\n    var v = 0\n    var w = 0\n   \
    \ var x = 0\n    var y = 0\n    var z = 0\n    var a = 0\n    var b = 0\n    var\
    \ c = 0\n    var d = 0\n    var e = 0\n    var f = 0\n    var g = 0\n    var h\
    \ = 0\n    var i = 0\n    var j = 0\n    var k = 0\n    var l = 0\n    var m =\
    \ 0\n    var n = 0\n    var o = 0\n    var p = 0\n    var q = 0\n    var r = 0\n\
    \    var s = 0\n    var t = 0\n    var u = 0\n    var v = 0\n    var w = 0\n \
    \   var x = 0\n    var y = 0\n    var z = 0\n    var a = 0\n    var b = 0\n  \
    \  var c = 0\n    var d = 0\n    var e = 0\n    var f = 0\n    var g = 0\n   \
    \ var h = 0\n    var i = 0\n    var j = 0\n    var k = 0\n    var l = 0\n    var\
    \ m = 0\n    var n = 0\n    var o = 0\n    var p = 0\n    var q = 0\n    var r\
    \ = 0\n    var s = 0\n    var t = 0\n    var u = 0\n    var v = 0\n    var w =\
    \ 0\n    var x = 0\n    var y = 0\n    var z = 0\n    var a = 0\n    var b = 0\n\
    \    var c = 0\n    var d = 0\n    var e = 0\n    var f = 0\n    var g = 0\n \
    \   var h = 0\n    var i = 0\n    var j = 0\n    var k = 0\n    var l = 0\n  \
    \  var m = 0\n    var n = 0\n    var o = 0\n    var p = 0\n    var q = 0\n   \
    \ var r = 0\n    var s = 0\n    var t = 0\n    var u = 0\n    var v = 0\n    var\
    \ w = 0\n    var x = 0\n    var y = 0\n    var z = 0\n    var a = 0\n    var b\
    \ = 0\n    var c = 0\n    var d = 0\n    var e = 0\n    var f = 0\n    var g =\
    \ 0\n    var h = 0\n    var i = 0\n    var j = 0\n    var k = 0\n    var l = 0\n\
    \    var m = 0\n    var n = 0\n    var o = 0\n    var p = 0\n    var q = 0\n \
    \   var r = 0\n    var s = 0\n    var t = 0\n    var u = 0\n    var v = 0\n  \
    \  var w = 0\n    var x = 0\n    var y = 0\n    var z = 0\n    var a = 0\n   \
    \ var b = 0\n    var c = 0\n    var d = 0\n    var e = 0\n    var f = 0\n    var\
    \ g = 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary\
    \ had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had\
    \ a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple\
    \ white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\"\
    , n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"\
    ])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s:\
    \ \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpv60dryfr.swift:41:9: error: invalid redeclaration of 'i'\n    var\
    \ i = 0\n        ^\n/tmp/tmpv60dryfr.swift:15:9: note: 'i' previously declared\
    \ here\n    var i = 0\n        ^\n/tmp/tmpv60dryfr.swift:42:9: error: invalid\
    \ redeclaration of 'j'\n    var j = 0\n        ^\n/tmp/tmpv60dryfr.swift:16:9:\
    \ note: 'j' previously declared here\n    var j = 0\n        ^\n/tmp/tmpv60dryfr.swift:43:9:\
    \ error: invalid redeclaration of 'k'\n    var k = 0\n        ^\n/tmp/tmpv60dryfr.swift:17:9:\
    \ note: 'k' previously declared here\n    var k = 0\n        ^\n/tmp/tmpv60dryfr.swift:44:9:\
    \ error: invalid redeclaration of 'l'\n    var l = 0\n        ^\n/tmp/tmpv60dryfr.swift:18:9:\
    \ note: 'l' previously declared here\n    var l = 0\n        ^\n/tmp/tmpv60dryfr.swift:45:9:\
    \ error: invalid redeclaration of 'm'\n    var m = 0\n        ^\n/tmp/tmpv60dryfr.swift:19:9:\
    \ note: 'm' previously declared here\n    var m = 0\n        ^\n/tmp/tmpv60dryfr.swift:46:9:\
    \ error: invalid redeclaration of 'n'\n    var n = 0\n        ^\n/tmp/tmpv60dryfr.swift:20:9:\
    \ note: 'n' previously declared here\n    var n = 0\n        ^\n/tmp/tmpv60dryfr.swift:47:9:\
    \ error: invalid redeclaration of 'o'\n    var o = 0\n        ^\n/tmp/tmpv60dryfr.swift:21:9:\
    \ note: 'o' previously declared here\n    var o = 0\n        ^\n/tmp/tmpv60dryfr.swift:48:9:\
    \ error: invalid redeclaration of 'p'\n    var p = 0\n        ^\n/tmp/tmpv60dryfr.swift:22:9:\
    \ note: 'p' previously declared here\n    var p = 0\n        ^\n/tmp/tmpv60dryfr.swift:49:9:\
    \ error: invalid redeclaration of 'q'\n    var q = 0\n        ^\n/tmp/tmpv60dryfr.swift:23:9:\
    \ note: 'q' previously declared here\n    var q = 0\n        ^\n/tmp/tmpv60dryfr.swift:50:9:\
    \ error: invalid redeclaration of 'r'\n    var r = 0\n        ^\n/tmp/tmpv60dryfr.swift:24:9:\
    \ note: 'r' previously declared here\n    var r = 0\n        ^\n/tmp/tmpv60dryfr.swift:51:9:\
    \ error: invalid redeclaration of 's'\n    var s = 0\n        ^\n/tmp/tmpv60dryfr.swift:25:9:\
    \ note: 's' previously declared here\n    var s = 0\n        ^\n/tmp/tmpv60dryfr.swift:52:9:\
    \ error: invalid redeclaration of 't'\n    var t = 0\n        ^\n/tmp/tmpv60d"
  stdout: ''
  timestamp: 1660014410
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"\
    ]\n/// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n\
    /// select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfunc\
    \ select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    \n    if s == \"\" {\n        return result\n    }\n    \n    var i = 0\n\
    \    var j = 0\n    var k = 0\n    \n    for k in s.characters {\n        if s.characters[k]\
    \ == \" \" {\n            i = k\n        }\n    }\n    \n    for j in s.characters[i..<s.characters.count]\
    \ {\n        if s.characters[j] == \" \" {\n            i = j\n        }\n   \
    \ }\n    \n    for k in s.characters[i..<s.characters.count] {\n        if s.characters[k]\
    \ == \" \" {\n            i = k\n        }\n    }\n    \n    for j in s.characters[i..<s.characters.count]\
    \ {\n        if s.characters[j] == \" \" {\n            i = j\n        }\n   \
    \ }\n    \n    for k in s.characters[i..<s.characters.count] {\n        if s.characters[k]\
    \ == \" \" {\n            i = k\n        }\n    }\n    \n    for j in s.characters[i..<s.characters.count]\
    \ {\n        if s.characters[j] == \" \" {\n            i = j\n        }\n   \
    \ }\n    \n    for k in s.characters[i..<s.characters.count] {\n        if s.characters[k]\
    \ == \" \" {\n            i = k\n        }\n    }\n    \n    for j in s.characters[i..<s.characters.count]\
    \ {\n        if s.characters[j] == \" \" {\n            i = j\n        }\n   \
    \ }\n    \n    for k in s.characters[i..<s.characters.count] {\n        if s.characters[k]\
    \ == \" \" {\n            i = k\n        }\n    }\n    \n    for j in s.characters[i..<s.characters.count]\
    \ {\n        if s.characters[j] == \" \" {\n            i = j\n        }\n   \
    \ }\n    \n    for k in s.characters[i..<s.characters.count] {\n        if s.characters[k]\
    \ == \" \" {\n            i = k\n        }\n    }\n    \n    for j in s.characters[i..<s.characters.count]\
    \ {\n        if s.characters[j] == \" \" {\n            i = j\n        }\n   \
    \ }\n    \n    for k in s.characters[i..<s.characters.count] {\n        if s.characters[k]\
    \ == \" \" {\n            i = k\n        }\n    }\n    \n    for j in s.characters[i..<s.characters.count]\
    \ {\n        if s.characters[j] == \" \" {\n            i = j\n        }\n   \
    \ }\n    \n    for k in s.characters[i..<s.characters.count] {\n        if s.characters[k]\
    \ == \" \" {\n            i = k\n        }\n    }\n    \n    for j in s.characters[i..<s.characters.count]\
    \ {\n        if s.characters[j] == \" \" {\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"\
    ])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"\
    lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpy9_gw3r3.swift:137:69: error: expected '}' at end of brace statement\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])\n\
    \                                                                    ^\n/tmp/tmpy9_gw3r3.swift:114:51:\
    \ note: to match this opening '{'\n    for j in s.characters[i..<s.characters.count]\
    \ {\n                                                  ^\n/tmp/tmpy9_gw3r3.swift:137:69:\
    \ error: expected '}' at end of brace statement\nassert(select_words(s: \"a b\
    \ c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])\n                        \
    \                                            ^\n/tmp/tmpy9_gw3r3.swift:13:50:\
    \ note: to match this opening '{'\nfunc select_words(s: String, n: Int) -> [String]\
    \ {\n                                                 ^\n/tmp/tmpy9_gw3r3.swift:24:16:\
    \ error: 'characters' is unavailable: Please use String directly\n    for k in\
    \ s.characters {\n               ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpy9_gw3r3.swift:25:24: error: no exact matches in call\
    \ to subscript \n        if s.characters[k] == \" \" {\n                     \
    \  ^\nSwift.String:3:12: note: candidate expects value of type 'Range<String.Index>'\
    \ for parameter #1 (got 'Character')\n    public subscript(r: Range<String.Index>)\
    \ -> Substring { get }\n           ^\nSwift.Collection:3:23: note: candidate expects\
    \ value of type '(UnboundedRange_) -> ()' for parameter #1 (got 'Character')\n\
    \    @inlinable public subscript(x: (UnboundedRange_) -> ()) -> Self.SubSequence\
    \ { get }\n                      ^\n/tmp/tmpy9_gw3r3.swift:26:17: error: cannot\
    \ assign value of type 'Character' to type 'Int'\n            i = k\n        \
    \        ^\n/tmp/tmpy9_gw3r3.swift:30:14: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an integer range, use a String.Index range instead.\n\
    \    for j in s.characters[i..<s.characters.count] {\n             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    Swift.String:5:12: note: 'subscript(_:)' has been explicitly marked"
  stdout: ''
  timestamp: 1660014410
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"\
    ]\n/// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n\
    /// select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfunc\
    \ select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    \n    if s == \"\" {\n        return result\n    }\n    \n    let vowels\
    \ = \"aeiouAEIOU\"\n    \n    for char in s {\n        if vowels.contains(char)\
    \ {\n            if result.count < n {\n                result.append(char)\n\
    \            }\n        }\n    }\n    \n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"\
    little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\"\
    , \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmprlrpjzh_.swift:25:31: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n                result.append(char)\n  \
    \                            ^\n"
  stdout: ''
  timestamp: 1660014410
- exit_code: -4
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"\
    ]\n/// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n\
    /// select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfunc\
    \ select_words(s: String, n: Int) -> [String] {\n    return []\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"\
    little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\"\
    , \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: Exception
  stderr: 'tmpszvxx0ul/tmpszvxx0ul.swift:30: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b89c1917c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b89c160eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b89c160e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b89c160d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpszvxx0ul                        0x000055e491c114c4 <unavailable> + 5316

    5    libc.so.6                          0x00002b89c1b03460 __libc_start_main +
    245

    6    tmpszvxx0ul                        0x000055e491c110c9 <unavailable> + 4297

    '
  stdout: ''
  timestamp: 1660014410
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"\
    ]\n/// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n\
    /// select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfunc\
    \ select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    \n    if s == \"\" {\n        return result\n    }\n    \n    for char in\
    \ s {\n        if char == \" \" {\n            continue\n        }\n        \n\
    \        if char == \"a\" || char == \"e\" || char == \"i\" || char == \"o\" ||\
    \ char == \"u\" {\n            continue\n        }\n        \n        if char\
    \ == \"n\" {\n            if n <= 0 {\n                return result\n       \
    \     }\n            \n            n -= 1\n            continue\n        }\n \
    \       \n        if char == \"c\" || char == \"d\" || char == \"h\" || char ==\
    \ \"l\" || char == \"r\" || char == \"v\" {\n            if n <= 0 {\n       \
    \         return result\n            }\n            \n            n -= 1\n   \
    \         continue\n        }\n        \n        if char == \"b\" || char == \"\
    f\" || char == \"p\" || char == \"s\" || char == \"x\" {\n            if n <=\
    \ 0 {\n                return result\n            }\n            \n          \
    \  n -= 1\n            continue\n        }\n        \n        if char == \"m\"\
    \ || char == \"n\" || char == \"t\" || char == \"v\" {\n            if n <= 0\
    \ {\n                return result\n            }\n            \n            n\
    \ -= 1\n            continue\n        }\n        \n        if char == \"k\" ||\
    \ char == \"q\" || char == \"x\" {\n            if n <= 0 {\n                return\
    \ result\n            }\n            \n            n -= 1\n            continue\n\
    \        }\n        \n        if char == \"j\" || char == \"z\" {\n          \
    \  if n <= 0 {\n                return result\n            }\n            \n \
    \           n -= 1\n            continue\n        }\n        \n        if char\
    \ == \"q\" || char == \"j\" {\n            if n <= 0 {\n                return\
    \ result\n            }\n            \n            n -= 1\n            continue\n\
    \        }\n        \n        if char == \"p\" || char == \"z\" {\n          \
    \  if n <= 0 {\n                return result\n            }\n            \n \
    \           n -= 1\n            continue\n        }\n        \n        if char\
    \ == \"l\" || char == \"z\" {\n            if n <= 0 {\n                return\
    \ result\n            }\n            \n            n -= 1\n            continue\n\
    \        }\n        \n        if char == \"m\" || char == \"n\" || char == \"\
    t\" || char == \"v\" || char == \"z\" {\n            if n <= 0 {\n           \
    \     return result\n            }\n            \n            n -= 1\n       \
    \     continue\n        }\n        \n        if char == \"p\" || char == \"q\"\
    \ || char == \"r\" || char == \"s\" || char == \"t\" || char == \"v\" || char\
    \ == \"z\" {\n            if n <= 0 {\n                return result\n       \
    \     }\n            \n            n -= 1\n            continue\n        }\n \
    \       \n        if char == \"p\" || char == \"q\" || char == \"r\" || char ==\
    \ \"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(select_words(s: \"Mary had a\
    \ little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little\
    \ lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white\
    \ space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n:\
    \ 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"\
    ])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s:\
    \ \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpzc65rlrf.swift:128:65: error: unterminated string literal\n   \
    \     if char == \"p\" || char == \"q\" || char == \"r\" || char == \"\n     \
    \                                                           ^\n/tmp/tmpzc65rlrf.swift:150:69:\
    \ error: expected '}' at end of brace statement\nassert(select_words(s: \"a b\
    \ c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])\n                        \
    \                                            ^\n/tmp/tmpzc65rlrf.swift:13:50:\
    \ note: to match this opening '{'\nfunc select_words(s: String, n: Int) -> [String]\
    \ {\n                                                 ^\n/tmp/tmpzc65rlrf.swift:34:15:\
    \ error: left side of mutating operator isn't mutable: 'n' is a 'let' constant\n\
    \            n -= 1\n            ~ ^\n/tmp/tmpzc65rlrf.swift:43:15: error: left\
    \ side of mutating operator isn't mutable: 'n' is a 'let' constant\n         \
    \   n -= 1\n            ~ ^\n/tmp/tmpzc65rlrf.swift:52:15: error: left side of\
    \ mutating operator isn't mutable: 'n' is a 'let' constant\n            n -= 1\n\
    \            ~ ^\n/tmp/tmpzc65rlrf.swift:61:15: error: left side of mutating operator\
    \ isn't mutable: 'n' is a 'let' constant\n            n -= 1\n            ~ ^\n\
    /tmp/tmpzc65rlrf.swift:70:15: error: left side of mutating operator isn't mutable:\
    \ 'n' is a 'let' constant\n            n -= 1\n            ~ ^\n/tmp/tmpzc65rlrf.swift:79:15:\
    \ error: left side of mutating operator isn't mutable: 'n' is a 'let' constant\n\
    \            n -= 1\n            ~ ^\n/tmp/tmpzc65rlrf.swift:88:15: error: left\
    \ side of mutating operator isn't mutable: 'n' is a 'let' constant\n         \
    \   n -= 1\n            ~ ^\n/tmp/tmpzc65rlrf.swift:97:15: error: left side of\
    \ mutating operator isn't mutable: 'n' is a 'let' constant\n            n -= 1\n\
    \            ~ ^\n/tmp/tmpzc65rlrf.swift:106:15: error: left side of mutating\
    \ operator isn't mutable: 'n' is a 'let' constant\n            n -= 1\n      \
    \      ~ ^\n/tmp/tmpzc65rlrf.swift:115:15: error: left side of mutating operator\
    \ isn't mutable: 'n' is a 'let' constant\n            n -= 1\n            ~ ^\n\
    /tmp/tmpzc65rlrf.swift:124:15: error: left side "
  stdout: ''
  timestamp: 1660014410
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"\
    ]\n/// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n\
    /// select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfunc\
    \ select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    \n    if s == \"\" {\n        return result\n    }\n    \n    var index =\
    \ 0\n    var lastIndex = s.characters.count\n    \n    while index < lastIndex\
    \ {\n        if s.characters[index] == \" \" {\n            index = index + 1\n\
    \            continue\n        }\n        \n        if s.characters[index] ==\
    \ \" \" {\n            index = index + 1\n            continue\n        }\n  \
    \      \n        if s.characters[index] == \" \" {\n            index = index\
    \ + 1\n            continue\n        }\n        \n        if s.characters[index]\
    \ == \" \" {\n            index = index + 1\n            continue\n        }\n\
    \        \n        if s.characters[index] == \" \" {\n            index = index\
    \ + 1\n            continue\n        }\n        \n        if s.characters[index]\
    \ == \" \" {\n            index = index + 1\n            continue\n        }\n\
    \        \n        if s.characters[index] == \" \" {\n            index = index\
    \ + 1\n            continue\n        }\n        \n        if s.characters[index]\
    \ == \" \" {\n            index = index + 1\n            continue\n        }\n\
    \        \n        if s.characters[index] == \" \" {\n            index = index\
    \ + 1\n            continue\n        }\n        \n        if s.characters[index]\
    \ == \" \" {\n            index = index + 1\n            continue\n        }\n\
    \        \n        if s.characters[index] == \" \" {\n            index = index\
    \ + 1\n            continue\n        }\n        \n        if s.characters[index]\
    \ == \" \" {\n            index = index + 1\n            continue\n        }\n\
    \        \n        if s.characters[index] == \" \" {\n            index = index\
    \ + 1\n            continue\n        }\n        \n        if s.characters[index]\
    \ == \" \" {\n            index = index + 1\n            continue\n        }\n\
    \        \n        if s.characters[index] == \" \" {\n            index = index\
    \ + 1\n            continue\n        }\n        \n        if s.characters[index]\
    \ == \" \" {\n            index = index + 1\n            continue\n        }\n\
    \        \n        if s.characters[index] == \" \" {\n            index = index\
    \ + 1\n            continue\n        }\n        \n        if s.characters[index]\
    \ == \" \" {\n            index = index + 1\n            continue\n        }\n\
    \        \n        if s.characters[index] == \" \" {\n            index = index\
    \ + 1\n            continue\n        }\n        \n        if s.characters[index]\
    \ == \" \" {\n            index = index + 1\n            continue\n        }\n\
    \        \n        if s.characters[index] == \" \" {\n            index = index\
    \ + 1\n            continue\n        }\n        \n        if s.characters[index]\
    \ == \" \" {\n            index = index + 1\n            continue\n        }\n\
    \        \n        if s.characters[index] == \" \" {\n            index = index\
    \ + 1\n            continue\n        }\n        \n        if s.characters[index]\
    \ == \" \" {\n            index = index + 1\n\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"\
    ])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"\
    lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmph8exny__.swift:163:69: error: expected '}' at end of brace statement\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])\n\
    \                                                                    ^\n/tmp/tmph8exny__.swift:23:29:\
    \ note: to match this opening '{'\n    while index < lastIndex {\n           \
    \                 ^\n/tmp/tmph8exny__.swift:163:69: error: expected '}' at end\
    \ of brace statement\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\"\
    , \"c\", \"d\", \"f\"])\n                                                    \
    \                ^\n/tmp/tmph8exny__.swift:13:50: note: to match this opening\
    \ '{'\nfunc select_words(s: String, n: Int) -> [String] {\n                  \
    \                               ^\n/tmp/tmph8exny__.swift:21:23: error: 'characters'\
    \ is unavailable: Please use String directly\n    var lastIndex = s.characters.count\n\
    \                      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmph8exny__.swift:24:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if s.characters[index]\
    \ == \" \" {\n           ^~~~~~~~~~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmph8exny__.swift:24:14: error: 'characters'\
    \ is unavailable: Please use String directly\n        if s.characters[index] ==\
    \ \" \" {\n             ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmph8exny__.swift:29:12: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n        if\
    \ s.characters[index] == \" \" {\n           ^~~~~~~~~~~~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmph8exny__.swift:29:14:\
    \ error: 'characte"
  stdout: ''
  timestamp: 1660014410
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"\
    ]\n/// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n\
    /// select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfunc\
    \ select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    \n    if s == \"\" {\n        return result\n    }\n    \n    for char in\
    \ s.characters {\n        if char == \" \" {\n            continue\n        }\n\
    \        \n        if char == \" \" {\n            continue\n        }\n     \
    \   \n        if char == \" \" {\n            continue\n        }\n        \n\
    \        if char == \" \" {\n            continue\n        }\n        \n     \
    \   if char == \" \" {\n            continue\n        }\n        \n        if\
    \ char == \" \" {\n            continue\n        }\n        \n        if char\
    \ == \" \" {\n            continue\n        }\n        \n        if char == \"\
    \ \" {\n            continue\n        }\n        \n        if char == \" \" {\n\
    \            continue\n        }\n        \n        if char == \" \" {\n     \
    \       continue\n        }\n        \n        if char == \" \" {\n          \
    \  continue\n        }\n        \n        if char == \" \" {\n            continue\n\
    \        }\n        \n        if char == \" \" {\n            continue\n     \
    \   }\n        \n        if char == \" \" {\n            continue\n        }\n\
    \        \n        if char == \" \" {\n            continue\n        }\n     \
    \   \n        if char == \" \" {\n            continue\n        }\n        \n\
    \        if char == \" \" {\n            continue\n        }\n        \n     \
    \   if char == \" \" {\n            continue\n        }\n        \n        if\
    \ char == \" \" {\n            continue\n        }\n        \n        if char\
    \ == \" \" {\n            continue\n        }\n        \n        if char == \"\
    \ \" {\n            continue\n        }\n        \n        if char == \" \" {\n\
    \            continue\n        }\n        \n        if char == \" \" {\n     \
    \       continue\n        }\n        \n        if char == \" \" {\n          \
    \  continue\n        }\n        \n        if char == \" \" {\n            continue\n\
    \        }\n        \n        if char == \" \" {\n            continue\n     \
    \   }\n        \n        if char == \" \" {\n            continue\n        }\n\
    \        \n        if char == \" \" {\n            continue\n        }\n     \
    \   \n        if char == \" \" {\n            continue\n        }\n        \n\
    \        if char == \" \" {\n            continue\n        }\n        \n     \
    \   if char == \" \" {\n            continue\n        }\n        \n        if\
    \ char == \" \" {\n            continue\n        }\n        \n        if char\
    \ == \" \" {\n            continue\n        }\n        \n        if char == \"\
    \ \" {\n            continue\n        }\n        \n        if char == \" \" {\n\
    \            continue\n        }\n        \n        if char == \" \" {\n     \
    \       continue\n        }\n        \n        if char == \" \" {\n          \
    \  continue\n        }\n        \n        if char == \" \" \n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"\
    little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\"\
    , \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmph5xrccly.swift:169:23: error: expected '{' after 'if' condition\n\
    \        if char == \" \" \n                      ^\n/tmp/tmph5xrccly.swift:191:69:\
    \ error: expected '}' at end of brace statement\nassert(select_words(s: \"a b\
    \ c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])\n                        \
    \                                            ^\n/tmp/tmph5xrccly.swift:13:50:\
    \ note: to match this opening '{'\nfunc select_words(s: String, n: Int) -> [String]\
    \ {\n                                                 ^\n/tmp/tmph5xrccly.swift:20:19:\
    \ error: 'characters' is unavailable: Please use String directly\n    for char\
    \ in s.characters {\n                  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmph5xrccly.swift:173:6: error: operator functions can\
    \ only be declared at global or in type scope\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n     ^\n/tmp/tmph5xrccly.swift:14:9: warning: variable\
    \ 'result' was never mutated; consider changing to 'let' constant\n    var result\
    \ = [String]()\n    ~~~ ^\n    let\n"
  stdout: ''
  timestamp: 1660014410
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"\
    ]\n/// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n\
    /// select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfunc\
    \ select_words(s: String, n: Int) -> [String] {\n    \n    // BEGIN PSEUDOCODE\n\
    \    \n    // END PSEUDOCODE\n    \n    return words\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"\
    little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\"\
    , \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpdhcngucd.swift:19:12: error: cannot find 'words' in scope\n   \
    \ return words\n           ^~~~~\n"
  stdout: ''
  timestamp: 1660014410
- exit_code: -4
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"\
    ]\n/// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n\
    /// select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfunc\
    \ select_words(s: String, n: Int) -> [String] {\n    return []\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"\
    little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\"\
    , \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: Exception
  stderr: 'tmpszvxx0ul/tmpszvxx0ul.swift:30: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b89c1917c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b89c160eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b89c160e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b89c160d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpszvxx0ul                        0x000055e491c114c4 <unavailable> + 5316

    5    libc.so.6                          0x00002b89c1b03460 __libc_start_main +
    245

    6    tmpszvxx0ul                        0x000055e491c110c9 <unavailable> + 4297

    '
  stdout: ''
  timestamp: 1660014410
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"\
    ]\n/// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n\
    /// select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfunc\
    \ select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    \n    if s == \"\" {\n        return result\n    }\n    \n    var i = 0\n\
    \    var j = 0\n    var k = 0\n    \n    for i < s.count {\n        if s[i] ==\
    \ \" \" {\n            j = i\n            \n            while j < s.count && s[j]\
    \ == \" \" {\n                j += 1\n            }\n            \n          \
    \  k = j\n            \n            while k < s.count && s[k] != \" \" {\n   \
    \             k += 1\n            }\n            \n            if k == j {\n \
    \               result.append(\"\\n\")\n            }\n            \n        \
    \    while j < s.count && s[k] == \" \" {\n                j += 1\n          \
    \      k += 1\n            }\n            \n            if j == s.count {\n  \
    \              result.append(\"\\n\")\n            }\n            \n         \
    \   while k < s.count && s[j] == \" \" {\n                j += 1\n           \
    \     k += 1\n            }\n            \n            if k == s.count {\n   \
    \             result.append(\"\\n\")\n            }\n            \n          \
    \  while j < s.count && s[k] != \" \" {\n                j += 1\n            \
    \    k += 1\n            }\n            \n            if j == s.count {\n    \
    \            result.append(\"\\n\")\n            }\n            \n           \
    \ while k < s.count && s[j] != \" \" {\n                k += 1\n             \
    \   j += 1\n            }\n            \n            if k == s.count {\n     \
    \           result.append(\"\\n\")\n            }\n            \n            while\
    \ j < s.count && s[k] != \" \" {\n                j += 1\n                k +=\
    \ 1\n            }\n            \n            if j == s.count {\n            \
    \    result.append(\"\\n\")\n            }\n            \n            while k\
    \ < s.count && s[j] != \" \" {\n                k += 1\n                j += 1\n\
    \            }\n            \n            if k == s.count {\n                result.append(\"\
    \\n\")\n            }\n            \n            while j < s.count && s[k] !=\
    \ \" \" {\n                j += 1\n                k += 1\n            }\n   \
    \         \n            if j == s.count {\n                result.append(\"\\\
    n\")\n            }\n            \n            while k < s.count && s[j] != \"\
    \ \" {\n                k += 1\n                j += 1\n            }\n      \
    \      \n            if k == s.count {\n                result.append(\"\\n\"\
    )\n            }\n            \n            while j < s.count && s[k] != \" \"\
    \ {\n                j += 1\n                k += 1\n            }\n         \
    \   \n            if j == s.count {\n                result.append(\"\\n\")\n\
    \            }\n            \n            while k < s.count && s[j] != \" \" {\n\
    \                k += 1\n                j += 1\n            }\n            \n\
    \            if k == s.count {\n                result.append(\"\\n\")\n     \
    \       }\n            \n            while j < s.count && s[k] != \" \" {\n\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n:\
    \ 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3)\
    \ == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n:\
    \ 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"\
    world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s:\
    \ \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1)\
    \ == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpxywthxzm.swift:24:11: error: expected 'in' after for-each pattern\n\
    \    for i < s.count {\n          ^\n/tmp/tmpxywthxzm.swift:24:11: error: unary\
    \ operator cannot be separated from its operand\n    for i < s.count {\n     \
    \     ^~\n           \n/tmp/tmpxywthxzm.swift:155:69: error: expected '}' at end\
    \ of brace statement\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\"\
    , \"c\", \"d\", \"f\"])\n                                                    \
    \                ^\n/tmp/tmpxywthxzm.swift:25:24: note: to match this opening\
    \ '{'\n        if s[i] == \" \" {\n                       ^\n/tmp/tmpxywthxzm.swift:155:69:\
    \ error: expected '}' at end of brace statement\nassert(select_words(s: \"a b\
    \ c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])\n                        \
    \                                            ^\n/tmp/tmpxywthxzm.swift:24:21:\
    \ note: to match this opening '{'\n    for i < s.count {\n                   \
    \ ^\n/tmp/tmpxywthxzm.swift:155:69: error: expected '}' at end of brace statement\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])\n\
    \                                                                    ^\n/tmp/tmpxywthxzm.swift:13:50:\
    \ note: to match this opening '{'\nfunc select_words(s: String, n: Int) -> [String]\
    \ {\n                                                 ^\n/tmp/tmpxywthxzm.swift:24:11:\
    \ error: '<' is not a prefix unary operator\n    for i < s.count {\n         \
    \ ^\n"
  stdout: ''
  timestamp: 1660014410
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"\
    ]\n/// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n\
    /// select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfunc\
    \ select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    \n    if s == \"\" {\n        return result\n    }\n    \n    for char in\
    \ s.characters {\n        if char == \" \" {\n            continue\n        }\n\
    \        \n        if char == \"a\" || char == \"e\" || char == \"i\" || char\
    \ == \"o\" || char == \"u\" {\n            continue\n        }\n        \n   \
    \     if char == \"n\" {\n            if n == 1 {\n                result.append(s)\n\
    \            }\n            \n            continue\n        }\n        \n    \
    \    if char == \"h\" || char == \"e\" || char == \"l\" || char == \"l\" || char\
    \ == \"o\" || char == \"r\" || char == \"s\" {\n            if n == 1 {\n    \
    \            result.append(s)\n            }\n            \n            continue\n\
    \        }\n        \n        if char == \"t\" || char == \"a\" || char == \"\
    d\" || char == \"e\" || char == \"h\" || char == \"l\" || char == \"o\" || char\
    \ == \"r\" || char == \"u\" || char == \"y\" {\n            if n == 1 {\n    \
    \            result.append(s)\n            }\n            \n            continue\n\
    \        }\n        \n        if char == \"b\" || char == \"c\" || char == \"\
    d\" || char == \"f\" || char == \"g\" || char == \"h\" || char == \"j\" || char\
    \ == \"k\" || char == \"l\" || char == \"m\" || char == \"n\" || char == \"p\"\
    \ || char == \"q\" || char == \"r\" || char == \"s\" || char == \"t\" || char\
    \ == \"v\" || char == \"w\" || char == \"x\" || char == \"y\" || char == \"z\"\
    \ {\n            if n == 1 {\n                result.append(s)\n            }\n\
    \            \n            continue\n        }\n        \n        if char == \"\
    v\" || char == \"x\" || char == \"z\" {\n            if n == 1 {\n           \
    \     result.append(s)\n            }\n            \n            continue\n  \
    \      }\n        \n        if char == \"d\" || char == \"f\" || char == \"g\"\
    \ || char == \"j\" || char == \"k\" || char == \"l\" || char == \"m\" || char\
    \ == \"n\" || char == \"p\" || char == \"q\" || char == \"r\" || char == \"s\"\
    \ || char == \"t\" || char == \"w\" || char == \"x\" || char == \"y\" || char\
    \ == \"z\" {\n            if n == 1 {\n                result.append(s)\n    \
    \        }\n            \n            continue\n        }\n        \n        if\
    \ char == \"c\" || char == \"b\" || char == \"a\" {\n            if n == 1 {\n\
    \                result.append(s)\n            }\n            \n            continue\n\
    \        }\n        \n        if char == \"m\" || char == \"n\" || char == \"\
    p\" || char == \"q\" || char == \"r\" || char == \"s\" || char == \"t\" || char\
    \ == \"w\" || char == \"x\" || char == \"y\" || char == \"z\" {\n            if\
    \ n == 1 {\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary\
    \ had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had\
    \ a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple\
    \ white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\"\
    , n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"\
    ])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s:\
    \ \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpgwxr7292.swift:108:69: error: expected '}' at end of brace statement\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])\n\
    \                                                                    ^\n/tmp/tmpgwxr7292.swift:85:174:\
    \ note: to match this opening '{'\n        if char == \"m\" || char == \"n\" ||\
    \ char == \"p\" || char == \"q\" || char == \"r\" || char == \"s\" || char ==\
    \ \"t\" || char == \"w\" || char == \"x\" || char == \"y\" || char == \"z\" {\n\
    \                                                                            \
    \                                                                            \
    \                     ^\n/tmp/tmpgwxr7292.swift:108:69: error: expected '}' at\
    \ end of brace statement\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"\
    b\", \"c\", \"d\", \"f\"])\n                                                 \
    \                   ^\n/tmp/tmpgwxr7292.swift:20:30: note: to match this opening\
    \ '{'\n    for char in s.characters {\n                             ^\n/tmp/tmpgwxr7292.swift:108:69:\
    \ error: expected '}' at end of brace statement\nassert(select_words(s: \"a b\
    \ c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])\n                        \
    \                                            ^\n/tmp/tmpgwxr7292.swift:13:50:\
    \ note: to match this opening '{'\nfunc select_words(s: String, n: Int) -> [String]\
    \ {\n                                                 ^\n/tmp/tmpgwxr7292.swift:20:19:\
    \ error: 'characters' is unavailable: Please use String directly\n    for char\
    \ in s.characters {\n                  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpgwxr7292.swift:90:6: error: operator functions can\
    \ only be declared at global or in type scope\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660014410
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"\
    ]\n/// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n\
    /// select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfunc\
    \ select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    var i = 0\n    var j = 0\n    var k = 0\n    var l = 0\n    var m = 0\n \
    \   var n = 0\n    var o = 0\n    var p = 0\n    var q = 0\n    var r = 0\n  \
    \  var s = 0\n    var t = 0\n    var u = 0\n    var v = 0\n    var w = 0\n   \
    \ var x = 0\n    var y = 0\n    var z = 0\n    var a = 0\n    var b = 0\n    var\
    \ c = 0\n    var d = 0\n    var e = 0\n    var f = 0\n    var g = 0\n    var h\
    \ = 0\n    var i = 0\n    var j = 0\n    var k = 0\n    var l = 0\n    var m =\
    \ 0\n    var n = 0\n    var o = 0\n    var p = 0\n    var q = 0\n    var r = 0\n\
    \    var s = 0\n    var t = 0\n    var u = 0\n    var v = 0\n    var w = 0\n \
    \   var x = 0\n    var y = 0\n    var z = 0\n    var a = 0\n    var b = 0\n  \
    \  var c = 0\n    var d = 0\n    var e = 0\n    var f = 0\n    var g = 0\n   \
    \ var h = 0\n    var i = 0\n    var j = 0\n    var k = 0\n    var l = 0\n    var\
    \ m = 0\n    var n = 0\n    var o = 0\n    var p = 0\n    var q = 0\n    var r\
    \ = 0\n    var s = 0\n    var t = 0\n    var u = 0\n    var v = 0\n    var w =\
    \ 0\n    var x = 0\n    var y = 0\n    var z = 0\n    var a = 0\n    var b = 0\n\
    \    var c = 0\n    var d = 0\n    var e = 0\n    var f = 0\n    var g = 0\n \
    \   var h = 0\n    var i = 0\n    var j = 0\n    var k = 0\n    var l = 0\n  \
    \  var m = 0\n    var n = 0\n    var o = 0\n    var p = 0\n    var q = 0\n   \
    \ var r = 0\n    var s = 0\n    var t = 0\n    var u = 0\n    var v = 0\n    var\
    \ w = 0\n    var x = 0\n    var y = 0\n    var z = 0\n    var a = 0\n    var b\
    \ = 0\n    var c = 0\n    var d = 0\n    var e = 0\n    var f = 0\n    var g =\
    \ 0\n    var h = 0\n    var i = 0\n    var j = 0\n    var k = 0\n    var l = 0\n\
    \    var m = 0\n    var n = 0\n    var o = 0\n    var p = 0\n    var q = 0\n \
    \   var r = 0\n    var s = 0\n    var t = 0\n    var u = 0\n    var v = 0\n  \
    \  var w = 0\n    var x = 0\n    var y = 0\n    var z = 0\n    var a = 0\n   \
    \ var b = 0\n    var c = 0\n    var d = 0\n    var e = 0\n    var f = 0\n    var\
    \ g = 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary\
    \ had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had\
    \ a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple\
    \ white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\"\
    , n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"\
    ])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s:\
    \ \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpv60dryfr.swift:41:9: error: invalid redeclaration of 'i'\n    var\
    \ i = 0\n        ^\n/tmp/tmpv60dryfr.swift:15:9: note: 'i' previously declared\
    \ here\n    var i = 0\n        ^\n/tmp/tmpv60dryfr.swift:42:9: error: invalid\
    \ redeclaration of 'j'\n    var j = 0\n        ^\n/tmp/tmpv60dryfr.swift:16:9:\
    \ note: 'j' previously declared here\n    var j = 0\n        ^\n/tmp/tmpv60dryfr.swift:43:9:\
    \ error: invalid redeclaration of 'k'\n    var k = 0\n        ^\n/tmp/tmpv60dryfr.swift:17:9:\
    \ note: 'k' previously declared here\n    var k = 0\n        ^\n/tmp/tmpv60dryfr.swift:44:9:\
    \ error: invalid redeclaration of 'l'\n    var l = 0\n        ^\n/tmp/tmpv60dryfr.swift:18:9:\
    \ note: 'l' previously declared here\n    var l = 0\n        ^\n/tmp/tmpv60dryfr.swift:45:9:\
    \ error: invalid redeclaration of 'm'\n    var m = 0\n        ^\n/tmp/tmpv60dryfr.swift:19:9:\
    \ note: 'm' previously declared here\n    var m = 0\n        ^\n/tmp/tmpv60dryfr.swift:46:9:\
    \ error: invalid redeclaration of 'n'\n    var n = 0\n        ^\n/tmp/tmpv60dryfr.swift:20:9:\
    \ note: 'n' previously declared here\n    var n = 0\n        ^\n/tmp/tmpv60dryfr.swift:47:9:\
    \ error: invalid redeclaration of 'o'\n    var o = 0\n        ^\n/tmp/tmpv60dryfr.swift:21:9:\
    \ note: 'o' previously declared here\n    var o = 0\n        ^\n/tmp/tmpv60dryfr.swift:48:9:\
    \ error: invalid redeclaration of 'p'\n    var p = 0\n        ^\n/tmp/tmpv60dryfr.swift:22:9:\
    \ note: 'p' previously declared here\n    var p = 0\n        ^\n/tmp/tmpv60dryfr.swift:49:9:\
    \ error: invalid redeclaration of 'q'\n    var q = 0\n        ^\n/tmp/tmpv60dryfr.swift:23:9:\
    \ note: 'q' previously declared here\n    var q = 0\n        ^\n/tmp/tmpv60dryfr.swift:50:9:\
    \ error: invalid redeclaration of 'r'\n    var r = 0\n        ^\n/tmp/tmpv60dryfr.swift:24:9:\
    \ note: 'r' previously declared here\n    var r = 0\n        ^\n/tmp/tmpv60dryfr.swift:51:9:\
    \ error: invalid redeclaration of 's'\n    var s = 0\n        ^\n/tmp/tmpv60dryfr.swift:25:9:\
    \ note: 's' previously declared here\n    var s = 0\n        ^\n/tmp/tmpv60dryfr.swift:52:9:\
    \ error: invalid redeclaration of 't'\n    var t = 0\n        ^\n/tmp/tmpv60d"
  stdout: ''
  timestamp: 1660014410
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"\
    ]\n/// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n\
    /// select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfunc\
    \ select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    \n    if s == \"\" {\n        return result\n    }\n    \n    var i = 0\n\
    \    var j = 0\n    \n    for i < s.count {\n        if s[i] == \" \" {\n    \
    \        i += 1\n        }\n        \n        if i == s.count {\n            break\n\
    \        }\n        \n        if s[i] == \" \" {\n            i += 1\n       \
    \ }\n        \n        if s[i] == \" \" {\n            i += 1\n        }\n   \
    \     \n        if s[i] == \" \" {\n            i += 1\n        }\n        \n\
    \        if s[i] == \" \" {\n            i += 1\n        }\n        \n       \
    \ if s[i] == \" \" {\n            i += 1\n        }\n        \n        if s[i]\
    \ == \" \" {\n            i += 1\n        }\n        \n        if s[i] == \" \"\
    \ {\n            i += 1\n        }\n        \n        if s[i] == \" \" {\n   \
    \         i += 1\n        }\n        \n        if s[i] == \" \" {\n          \
    \  i += 1\n        }\n        \n        if s[i] == \" \" {\n            i += 1\n\
    \        }\n        \n        if s[i] == \" \" {\n            i += 1\n       \
    \ }\n        \n        if s[i] == \" \" {\n            i += 1\n        }\n   \
    \     \n        if s[i] == \" \" {\n            i += 1\n        }\n        \n\
    \        if s[i] == \" \" {\n            i += 1\n        }\n        \n       \
    \ if s[i] == \" \" {\n            i += 1\n        }\n        \n        if s[i]\
    \ == \" \" {\n            i += 1\n        }\n        \n        if s[i] == \" \"\
    \ {\n            i += 1\n        }\n        \n        if s[i] == \" \" {\n   \
    \         i += 1\n        }\n        \n        if s[i] == \" \" {\n          \
    \  i += 1\n        }\n        \n        if s[i] == \" \" {\n            i += 1\n\
    \        }\n        \n        if s[i] == \" \" {\n            i += 1\n       \
    \ }\n        \n        if s[i] == \" \" {\n            i += 1\n        }\n   \
    \     \n        if s[i] == \" \" {\n            i += 1\n        }\n        \n\
    \        if s[i] == \" \" {\n            i += 1\n        }\n        \n       \
    \ if s[i] == \" \" {\n            i += 1\n        }\n        \n        if s[i]\
    \ == \" \" {\n            i += 1\n        }\n        \n        if s[i] == \" \"\
    \ {\n            i += 1\n        }\n        \n        if s[i] == \" \" {\n   \
    \         i += 1\n        }\n        \n        if s[i] == \" \" {\n          \
    \  i += 1\n        }\n        \n        if s[i] == \" \" {\n            i += 1\n\
    \        }\n        \n        if s[i] == \" \" {\n            i += 1\n       \
    \ }\n        \n        if s[i] == \" \" {\n            i += 1\n        }\n   \
    \     \n        if s[i] == \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s:\
    \ \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"\
    Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmplt5ane4_.swift:23:11: error: expected 'in' after for-each pattern\n\
    \    for i < s.count {\n          ^\n/tmp/tmplt5ane4_.swift:23:11: error: unary\
    \ operator cannot be separated from its operand\n    for i < s.count {\n     \
    \     ^~\n           \n/tmp/tmplt5ane4_.swift:161:1: error: expected expression\
    \ after operator\n}\n^\n/tmp/tmplt5ane4_.swift:182:69: error: expected '}' at\
    \ end of brace statement\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"\
    b\", \"c\", \"d\", \"f\"])\n                                                 \
    \                   ^\n/tmp/tmplt5ane4_.swift:13:50: note: to match this opening\
    \ '{'\nfunc select_words(s: String, n: Int) -> [String] {\n                  \
    \                               ^\n/tmp/tmplt5ane4_.swift:23:11: error: '<' is\
    \ not a prefix unary operator\n    for i < s.count {\n          ^\n/tmp/tmplt5ane4_.swift:164:6:\
    \ error: operator functions can only be declared at global or in type scope\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660014410
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"\
    ]\n/// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n\
    /// select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfunc\
    \ select_words(s: String, n: Int) -> [String] {\n    \n    var result = [String]()\n\
    \    \n    if s == \"\" {\n        return result\n    }\n    \n    var i = 0\n\
    \    var j = 0\n    \n    while i < s.count {\n        \n        if s[i] == \"\
    \ \" {\n            \n            if j == n {\n                \n            \
    \    i += 1\n                \n                if i == s.count {\n           \
    \         \n                    while i < s.count && s[i] == \" \" {\n       \
    \                 \n                        i += 1\n                    }\n  \
    \                  \n                    result.append(s[i ..< s.count])\n   \
    \             }\n                \n                j = 0\n            } else {\n\
    \                \n                j += 1\n            }\n        } else {\n \
    \           \n            i += 1\n        }\n    }\n    \n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n:\
    \ 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3)\
    \ == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n:\
    \ 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"\
    world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s:\
    \ \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1)\
    \ == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmps54s8ee2.swift:26:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if s[i] ==\
    \ \" \" {\n           ^~~~\nSwift.String:3:12: note: 'subscript(_:)' has been\
    \ explicitly marked unavailable here\n    public subscript(i: Int) -> Character\
    \ { get }\n           ^\n/tmp/tmps54s8ee2.swift:34:42: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \                    while i < s.count && s[i] == \" \" {\n                  \
    \                       ^~~~\nSwift.String:3:12: note: 'subscript(_:)' has been\
    \ explicitly marked unavailable here\n    public subscript(i: Int) -> Character\
    \ { get }\n           ^\n/tmp/tmps54s8ee2.swift:39:35: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an integer range, use a String.Index\
    \ range instead.\n                    result.append(s[i ..< s.count])\n      \
    \                            ^~~~~~~~~~~~~~~~\nSwift.String:5:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript<R>(bounds:\
    \ R) -> String where R : RangeExpression, R.Bound == Int { get }\n           ^\n"
  stdout: ''
  timestamp: 1660014410
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"\
    ]\n/// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n\
    /// select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfunc\
    \ select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    if s == \"\" {\n        return result\n    }\n    var i = 0\n    var j =\
    \ 0\n    var k = 0\n    var count = 0\n    var last = 0\n    var lastCount = 0\n\
    \    var lastLast = 0\n    var lastLastCount = 0\n    var lastLastLast = 0\n \
    \   for i < s.count {\n        if s[i] == \" \" {\n            count += 1\n  \
    \          last = i\n            lastCount = count\n            lastLast = last\n\
    \            lastLastCount = lastCount\n            lastLastLast = lastLast\n\
    \        } else {\n            count = 0\n            last = i\n            lastCount\
    \ = count\n            lastLast = last\n            lastLastCount = lastCount\n\
    \            lastLastLast = lastLast\n        }\n        if count == n {\n   \
    \         if lastCount != lastLastCount {\n                result.insert(lastLast,\
    \ String(s[lastLast:last]))\n            }\n            if lastLastLast != lastLastCount\
    \ {\n                result.insert(lastLastLast, String(s[lastLastLast:lastLast]))\n\
    \            }\n            if lastCount != lastLastCount {\n                result.insert(last,\
    \ String(s[last:last]))\n            }\n            if lastLastLast != lastLastCount\
    \ {\n                result.insert(lastLastLast, String(s[lastLastLast:lastLast]))\n\
    \            }\n            count = 0\n            last = i\n            lastCount\
    \ = count\n            lastLast = last\n            lastLastCount = lastCount\n\
    \            lastLastLast = lastLast\n            lastLastLastCount = lastLastLast\n\
    \            lastLastLastLast = lastLastLast\n        }\n        i += 1\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"\
    Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary\
    \ had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpnx4gemqh.swift:27:11: error: expected 'in' after for-each pattern\n\
    \    for i < s.count {\n          ^\n/tmp/tmpnx4gemqh.swift:27:11: error: unary\
    \ operator cannot be separated from its operand\n    for i < s.count {\n     \
    \     ^~\n           \n/tmp/tmpnx4gemqh.swift:27:11: error: '<' is not a prefix\
    \ unary operator\n    for i < s.count {\n          ^\n"
  stdout: ''
  timestamp: 1660014410
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"\
    ]\n/// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n\
    /// select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfunc\
    \ select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    var i = 0\n    var j = 0\n    var k = 0\n    var l = 0\n    var m = 0\n \
    \   var n = 0\n    var o = 0\n    var p = 0\n    var q = 0\n    var r = 0\n  \
    \  var s = 0\n    var t = 0\n    var u = 0\n    var v = 0\n    var w = 0\n   \
    \ var x = 0\n    var y = 0\n    var z = 0\n    var a = 0\n    var b = 0\n    var\
    \ c = 0\n    var d = 0\n    var e = 0\n    var f = 0\n    var g = 0\n    var h\
    \ = 0\n    var i = 0\n    var j = 0\n    var k = 0\n    var l = 0\n    var m =\
    \ 0\n    var n = 0\n    var o = 0\n    var p = 0\n    var q = 0\n    var r = 0\n\
    \    var s = 0\n    var t = 0\n    var u = 0\n    var v = 0\n    var w = 0\n \
    \   var x = 0\n    var y = 0\n    var z = 0\n    var a = 0\n    var b = 0\n  \
    \  var c = 0\n    var d = 0\n    var e = 0\n    var f = 0\n    var g = 0\n   \
    \ var h = 0\n    var i = 0\n    var j = 0\n    var k = 0\n    var l = 0\n    var\
    \ m = 0\n    var n = 0\n    var o = 0\n    var p = 0\n    var q = 0\n    var r\
    \ = 0\n    var s = 0\n    var t = 0\n    var u = 0\n    var v = 0\n    var w =\
    \ 0\n    var x = 0\n    var y = 0\n    var z = 0\n    var a = 0\n    var b = 0\n\
    \    var c = 0\n    var d = 0\n    var e = 0\n    var f = 0\n    var g = 0\n \
    \   var h = 0\n    var i = 0\n    var j = 0\n    var k = 0\n    var l = 0\n  \
    \  var m = 0\n    var n = 0\n    var o = 0\n    var p = 0\n    var q = 0\n   \
    \ var r = 0\n    var s = 0\n    var t = 0\n    var u = 0\n    var v = 0\n    var\
    \ w = 0\n    var x = 0\n    var y = 0\n    var z = 0\n    var a = 0\n    var b\
    \ = 0\n    var c = 0\n    var d = 0\n    var e = 0\n    var f = 0\n    var g =\
    \ 0\n    var h = 0\n    var i = 0\n    var j = 0\n    var k = 0\n    var l = 0\n\
    \    var m = 0\n    var n = 0\n    var o = 0\n    var p = 0\n    var q = 0\n \
    \   var r = 0\n    var s = 0\n    var t = 0\n    var u = 0\n    var v = 0\n  \
    \  var w = 0\n    var x = 0\n    var y = 0\n    var z = 0\n    var a = 0\n   \
    \ var b = 0\n    var c = 0\n    var d = 0\n    var e = 0\n    var f = 0\n    var\
    \ g = 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary\
    \ had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had\
    \ a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple\
    \ white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\"\
    , n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"\
    ])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s:\
    \ \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpv60dryfr.swift:41:9: error: invalid redeclaration of 'i'\n    var\
    \ i = 0\n        ^\n/tmp/tmpv60dryfr.swift:15:9: note: 'i' previously declared\
    \ here\n    var i = 0\n        ^\n/tmp/tmpv60dryfr.swift:42:9: error: invalid\
    \ redeclaration of 'j'\n    var j = 0\n        ^\n/tmp/tmpv60dryfr.swift:16:9:\
    \ note: 'j' previously declared here\n    var j = 0\n        ^\n/tmp/tmpv60dryfr.swift:43:9:\
    \ error: invalid redeclaration of 'k'\n    var k = 0\n        ^\n/tmp/tmpv60dryfr.swift:17:9:\
    \ note: 'k' previously declared here\n    var k = 0\n        ^\n/tmp/tmpv60dryfr.swift:44:9:\
    \ error: invalid redeclaration of 'l'\n    var l = 0\n        ^\n/tmp/tmpv60dryfr.swift:18:9:\
    \ note: 'l' previously declared here\n    var l = 0\n        ^\n/tmp/tmpv60dryfr.swift:45:9:\
    \ error: invalid redeclaration of 'm'\n    var m = 0\n        ^\n/tmp/tmpv60dryfr.swift:19:9:\
    \ note: 'm' previously declared here\n    var m = 0\n        ^\n/tmp/tmpv60dryfr.swift:46:9:\
    \ error: invalid redeclaration of 'n'\n    var n = 0\n        ^\n/tmp/tmpv60dryfr.swift:20:9:\
    \ note: 'n' previously declared here\n    var n = 0\n        ^\n/tmp/tmpv60dryfr.swift:47:9:\
    \ error: invalid redeclaration of 'o'\n    var o = 0\n        ^\n/tmp/tmpv60dryfr.swift:21:9:\
    \ note: 'o' previously declared here\n    var o = 0\n        ^\n/tmp/tmpv60dryfr.swift:48:9:\
    \ error: invalid redeclaration of 'p'\n    var p = 0\n        ^\n/tmp/tmpv60dryfr.swift:22:9:\
    \ note: 'p' previously declared here\n    var p = 0\n        ^\n/tmp/tmpv60dryfr.swift:49:9:\
    \ error: invalid redeclaration of 'q'\n    var q = 0\n        ^\n/tmp/tmpv60dryfr.swift:23:9:\
    \ note: 'q' previously declared here\n    var q = 0\n        ^\n/tmp/tmpv60dryfr.swift:50:9:\
    \ error: invalid redeclaration of 'r'\n    var r = 0\n        ^\n/tmp/tmpv60dryfr.swift:24:9:\
    \ note: 'r' previously declared here\n    var r = 0\n        ^\n/tmp/tmpv60dryfr.swift:51:9:\
    \ error: invalid redeclaration of 's'\n    var s = 0\n        ^\n/tmp/tmpv60dryfr.swift:25:9:\
    \ note: 's' previously declared here\n    var s = 0\n        ^\n/tmp/tmpv60dryfr.swift:52:9:\
    \ error: invalid redeclaration of 't'\n    var t = 0\n        ^\n/tmp/tmpv60d"
  stdout: ''
  timestamp: 1660014410
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"\
    ]\n/// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n\
    /// select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfunc\
    \ select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    \n    if s == \"\" {\n        return result\n    }\n    \n    for char in\
    \ s.characters {\n        if char == \" \" {\n            continue\n        }\n\
    \        \n        if char == \"a\" || char == \"e\" || char == \"i\" || char\
    \ == \"o\" || char == \"u\" {\n            continue\n        }\n        \n   \
    \     if char == \"n\" {\n            if n == 1 {\n                continue\n\
    \            }\n            \n            if n == 2 {\n                result.append(\"\
    little\")\n                continue\n            }\n            \n           \
    \ if n == 3 {\n                result.append(\"little\")\n                result.append(\"\
    lamb\")\n                continue\n            }\n            \n            if\
    \ n == 4 {\n                result.append(\"little\")\n                result.append(\"\
    lamb\")\n                result.append(\"little\")\n                result.append(\"\
    lamb\")\n                continue\n            }\n            \n            if\
    \ n == 5 {\n                result.append(\"little\")\n                result.append(\"\
    lamb\")\n                result.append(\"little\")\n                result.append(\"\
    lamb\")\n                result.append(\"little\")\n                result.append(\"\
    lamb\")\n                continue\n            }\n            \n            if\
    \ n == 6 {\n                result.append(\"little\")\n                result.append(\"\
    lamb\")\n                result.append(\"little\")\n                result.append(\"\
    lamb\")\n                result.append(\"little\")\n                result.append(\"\
    lamb\")\n                result.append(\"little\")\n                result.append(\"\
    lamb\")\n                continue\n            }\n            \n            if\
    \ n == 7 {\n                result.append(\"little\")\n                result.append(\"\
    lamb\")\n                result.append(\"little\")\n                result.append(\"\
    lamb\")\n                result.append(\"little\")\n                result.append(\"\
    lamb\")\n                result.append(\"little\")\n                result.append(\"\
    lamb\")\n                result.append(\"little\")\n                result.append(\"\
    lamb\")\n                continue\n            }\n            \n            if\
    \ n == 8 {\n                result.append(\"little\")\n                result.append(\"\
    lamb\")\n                result.append(\"little\")\n                result.append(\"\
    lamb\")\n                result.append(\"little\")\n                result.append(\"\
    lamb\")\n                result.append(\"little\")\n                result.append(\"\
    lamb\")\n                result.append(\"little\")\n                result.append(\"\
    lamb\")\n                result.append(\"little\")\n                result.append(\"\
    lamb\")\n                continue\n            }\n            \n            if\
    \ n == 9 {\n                result.append(\"little\")\n                result.append(\"\
    lamb\")\n                result.append(\"little\")\n                result.append(\"\
    lamb\")\n                result.append(\"little\")\n                result.append(\"\
    lamb\")\n                result.append(\"little\")\n                result.append(\"\
    lamb\")\n                result.append(\"little\")\n                result.append(\"\
    lamb\")\n                result.append(\"little\")\n                result.append(\"\
    lamb\")\n                result.append(\"little\")\n                result.append(\"\
    lamb\")\n                continue\n            }\n            \n\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n:\
    \ 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3)\
    \ == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n:\
    \ 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"\
    world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s:\
    \ \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1)\
    \ == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmphj9059ez.swift:145:69: error: expected '}' at end of brace statement\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])\n\
    \                                                                    ^\n/tmp/tmphj9059ez.swift:20:30:\
    \ note: to match this opening '{'\n    for char in s.characters {\n          \
    \                   ^\n/tmp/tmphj9059ez.swift:145:69: error: expected '}' at end\
    \ of brace statement\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\"\
    , \"c\", \"d\", \"f\"])\n                                                    \
    \                ^\n/tmp/tmphj9059ez.swift:13:50: note: to match this opening\
    \ '{'\nfunc select_words(s: String, n: Int) -> [String] {\n                  \
    \                               ^\n/tmp/tmphj9059ez.swift:20:19: error: 'characters'\
    \ is unavailable: Please use String directly\n    for char in s.characters {\n\
    \                  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmphj9059ez.swift:127:6: error: operator functions can only be declared\
    \ at global or in type scope\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660014410
- exit_code: -4
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"\
    ]\n/// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n\
    /// select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfunc\
    \ select_words(s: String, n: Int) -> [String] {\n    return []\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"\
    little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\"\
    , \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: Exception
  stderr: 'tmpszvxx0ul/tmpszvxx0ul.swift:30: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b89c1917c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b89c160eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b89c160e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b89c160d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpszvxx0ul                        0x000055e491c114c4 <unavailable> + 5316

    5    libc.so.6                          0x00002b89c1b03460 __libc_start_main +
    245

    6    tmpszvxx0ul                        0x000055e491c110c9 <unavailable> + 4297

    '
  stdout: ''
  timestamp: 1660014410
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"\
    ]\n/// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n\
    /// select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfunc\
    \ select_words(s: String, n: Int) -> [String] {\n    \n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"\
    little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\"\
    , \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: '/tmp/tmpuails2sj.swift:15:1: error: missing return in global function expected
    to return ''[String]''

    }

    ^

    '
  stdout: ''
  timestamp: 1660014410
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"\
    ]\n/// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n\
    /// select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfunc\
    \ select_words(s: String, n: Int) -> [String] {\n    var words = [String]()\n\
    \    \n    if s == \"\" {\n        return words\n    }\n    \n    var i = 0\n\
    \    var j = 0\n    \n    for i < s.count {\n        if s[i] == \" \" {\n    \
    \        j = i\n            \n            while j < s.count && s[j] == \" \" {\n\
    \                j += 1\n            }\n            \n            if j == s.count\
    \ {\n                words.append(String(s[i:j]))\n                i = j\n   \
    \         }\n        }\n        \n        if s[i] == \" \" || s[i] == \"\\n\"\
    \ {\n            words.append(String(s[i:]))\n            i = s.count\n      \
    \  }\n        \n        if s[i] == \" \" && s[i+1] == \" \" {\n            words.append(String(s[i:i+2]))\n\
    \            i += 2\n        }\n        \n        if s[i] == \" \" && s[i+1] ==\
    \ \"\\n\" {\n            words.append(String(s[i:i+2]))\n            i += 2\n\
    \        }\n        \n        if s[i] == \" \" && s[i+1] == \"\\n\" && s[i+2]\
    \ == \" \" {\n            words.append(String(s[i:i+3]))\n            i += 3\n\
    \        }\n        \n        if s[i] == \" \" && s[i+1] == \"\\n\" && s[i+2]\
    \ == \"\\n\" {\n            words.append(String(s[i:i+3]))\n            i += 3\n\
    \        }\n        \n        if s[i] == \" \" && s[i+1] == \"\\n\" && s[i+2]\
    \ == \"\\n\" && s[i+3] == \" \" {\n            words.append(String(s[i:i+4]))\n\
    \            i += 4\n        }\n        \n        if s[i] == \" \" && s[i+1] ==\
    \ \"\\n\" && s[i+2] == \"\\n\" && s[i+3] == \"\\n\" {\n            words.append(String(s[i:i+4]))\n\
    \            i += 4\n        }\n        \n        if s[i] == \" \" && s[i+1] ==\
    \ \"\\n\" && s[i+2] == \"\\n\" && s[i+3] == \"\\n\" && s[i+4] == \" \" {\n   \
    \         words.append(String(s[i:i+5]))\n            i += 5\n        }\n    \
    \    \n        if s[i] == \" \" && s[i+1] == \"\\n\" && s[i+2] == \"\\n\" && s[i+3]\
    \ == \"\\n\" && s[i+4] == \"\\n\" {\n            words.append(String(s[i:i+5]))\n\
    \            i += 5\n        }\n        \n        if s[i] == \" \" && s[i+1] ==\
    \ \"\\n\" && s[i+2] == \"\\n\" && s[i+3] == \"\\n\" && s[i+4] == \"\\n\" && s[i+5]\
    \ == \" \" {\n            words.append(String(s[i:i+6]))\n            i += 6\n\
    \        }\n        \n        if s[i] == \" \" && s[i+1] == \"\\n\" && s[i+2]\
    \ == \"\\n\" && s[i+3] == \"\\n\" && s[i+4] == \"\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"\
    little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\"\
    , \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmp1_k917ga.swift:23:11: error: expected 'in' after for-each pattern\n\
    \    for i < s.count {\n          ^\n/tmp/tmp1_k917ga.swift:23:11: error: unary\
    \ operator cannot be separated from its operand\n    for i < s.count {\n     \
    \     ^~\n           \n/tmp/tmp1_k917ga.swift:38:37: error: expected expression\
    \ in list of expressions\n            words.append(String(s[i:]))\n          \
    \                          ^\n/tmp/tmp1_k917ga.swift:87:91: error: unterminated\
    \ string literal\n        if s[i] == \" \" && s[i+1] == \"\\n\" && s[i+2] == \"\
    \\n\" && s[i+3] == \"\\n\" && s[i+4] == \"\n                                 \
    \                                                         ^\n/tmp/tmp1_k917ga.swift:109:69:\
    \ error: expected '}' at end of brace statement\nassert(select_words(s: \"a b\
    \ c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])\n                        \
    \                                            ^\n/tmp/tmp1_k917ga.swift:13:50:\
    \ note: to match this opening '{'\nfunc select_words(s: String, n: Int) -> [String]\
    \ {\n                                                 ^\n/tmp/tmp1_k917ga.swift:23:11:\
    \ error: '<' is not a prefix unary operator\n    for i < s.count {\n         \
    \ ^\n/tmp/tmp1_k917ga.swift:91:6: error: operator functions can only be declared\
    \ at global or in type scope\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660014410
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"\
    ]\n/// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n\
    /// select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfunc\
    \ select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    \n    if s == \"\" {\n        return result\n    }\n    \n    var i = 0\n\
    \    var j = 0\n    var k = 0\n    \n    for i < s.count {\n        if s[i] ==\
    \ \" \" {\n            i += 1\n            continue\n        }\n        \n   \
    \     if s[i] == \"a\" || s[i] == \"e\" || s[i] == \"i\" || s[i] == \"o\" || s[i]\
    \ == \"u\" {\n            i += 1\n            continue\n        }\n        \n\
    \        if s[i] == \"y\" || s[i] == \"u\" || s[i] == \"i\" {\n            i +=\
    \ 1\n            continue\n        }\n        \n        if s[i] == \"n\" {\n \
    \           i += 1\n            continue\n        }\n        \n        if s[i]\
    \ == \"t\" || s[i] == \"s\" || s[i] == \"h\" || s[i] == \"r\" || s[i] == \"d\"\
    \ {\n            i += 1\n            continue\n        }\n        \n        if\
    \ s[i] == \"d\" || s[i] == \"b\" || s[i] == \"k\" || s[i] == \"m\" || s[i] ==\
    \ \"l\" {\n            i += 1\n            continue\n        }\n        \n   \
    \     if s[i] == \"c\" || s[i] == \"f\" || s[i] == \"v\" || s[i] == \"r\" || s[i]\
    \ == \"w\" || s[i] == \"x\" {\n            i += 1\n            continue\n    \
    \    }\n        \n        if s[i] == \"b\" || s[i] == \"j\" || s[i] == \"p\" ||\
    \ s[i] == \"v\" || s[i] == \"s\" || s[i] == \"x\" || s[i] == \"z\" {\n       \
    \     i += 1\n            continue\n        }\n        \n        if s[i] == \"\
    m\" || s[i] == \"n\" || s[i] == \"k\" || s[i] == \"l\" || s[i] == \"q\" || s[i]\
    \ == \"p\" || s[i] == \"s\" || s[i] == \"x\" || s[i] == \"z\" {\n            i\
    \ += 1\n            continue\n        }\n        \n        if s[i] == \"l\" ||\
    \ s[i] == \"m\" || s[i] == \"n\" || s[i] == \"k\" || s[i] == \"q\" || s[i] ==\
    \ \"p\" || s[i] == \"s\" || s[i] == \"x\" || s[i] == \"z\" {\n            i +=\
    \ 1\n            continue\n        }\n        \n        if s[i] == \"k\" || s[i]\
    \ == \"l\" || s[i] == \"m\" || s[i] == \"n\" || s[i] == \"q\" || s[i] == \"p\"\
    \ || s[i] == \"s\" || s[i] == \"x\" || s[i] == \"z\" {\n            i += 1\n \
    \           continue\n        }\n        \n        if s[i] == \"q\" || s[i] ==\
    \ \"l\" || s[i] == \"m\" || s[i] == \"n\" || s[i] == \"k\" || s[i] == \"p\" ||\
    \ s[i] == \"s\" || s[i] == \"x\" || s[i] == \"z\" {\n            i += 1\n    \
    \        continue\n        }\n        \n        if s[i] == \"p\" || s[i] == \"\
    l\" || s[i] == \"m\" || s[i] == \"n\" || s[i] == \"k\" || s[i] == \"q\" || s[i]\
    \ == \"s\" || s[i] == \"x\" || s[i] == \"z\" {\n            i += 1\n         \
    \   continue\n        }\n        \n        if s[i] == \"s\" || \n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"\
    little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\"\
    , \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpiduy362d.swift:24:11: error: expected 'in' after for-each pattern\n\
    \    for i < s.count {\n          ^\n/tmp/tmpiduy362d.swift:24:11: error: unary\
    \ operator cannot be separated from its operand\n    for i < s.count {\n     \
    \     ^~\n           \n/tmp/tmpiduy362d.swift:91:1: error: expected expression\
    \ after operator\n}\n^\n/tmp/tmpiduy362d.swift:112:69: error: expected '}' at\
    \ end of brace statement\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"\
    b\", \"c\", \"d\", \"f\"])\n                                                 \
    \                   ^\n/tmp/tmpiduy362d.swift:13:50: note: to match this opening\
    \ '{'\nfunc select_words(s: String, n: Int) -> [String] {\n                  \
    \                               ^\n/tmp/tmpiduy362d.swift:24:11: error: '<' is\
    \ not a prefix unary operator\n    for i < s.count {\n          ^\n/tmp/tmpiduy362d.swift:94:6:\
    \ error: operator functions can only be declared at global or in type scope\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660014410
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"\
    ]\n/// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n\
    /// select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfunc\
    \ select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    \n    if s == \"\" {\n        return result\n    }\n    \n    var i = 0\n\
    \    var j = 0\n    \n    for i < s.count {\n        if s[i] == \" \" {\n    \
    \        j = i\n            \n            for (j; j < s.count; j++ ) {\n     \
    \           if s[j] != \" \" {\n                    break\n                }\n\
    \            }\n            \n            if j == s.count {\n                result.append(\"\
    \\(strings[s.startIndex..<s.endIndex])\")\n            }\n        }\n        \n\
    \        if s[i] == \"a\" || s[i] == \"e\" || s[i] == \"i\" || s[i] == \"o\" ||\
    \ s[i] == \"u\" {\n            j = i\n            \n            for (j; j < s.count;\
    \ j++ ) {\n                if s[j] != s[i] {\n                    break\n    \
    \            }\n            }\n            \n            if j == s.count {\n \
    \               result.append(\"\\(strings[s.startIndex..<s.endIndex])\")\n  \
    \          }\n        }\n        \n        if s[i] == \"y\" {\n            j =\
    \ i\n            \n            for (j; j < s.count; j++ ) {\n                if\
    \ s[j] != s[i] {\n                    break\n                }\n            }\n\
    \            \n            if j == s.count {\n                result.append(\"\
    \\(strings[s.startIndex..<s.endIndex])\")\n            }\n        }\n        \n\
    \        if s[i] == \"s\" {\n            j = i\n            \n            for\
    \ (j; j < s.count; j++ ) {\n                if s[j] != s[i] {\n              \
    \      break\n                }\n            }\n            \n            if j\
    \ == s.count {\n                result.append(\"\\(strings[s.startIndex..<s.endIndex])\"\
    )\n            }\n        }\n        \n        if s[i] == \"d\" || s[i] == \"\
    h\" || s[i] == \"l\" || s[i] == \"m\" || s[i] == \"n\" || s[i] == \"r\" || s[i]\
    \ == \"t\" || s[i] == \"w\" || s[i] == \"v\" || s[i] == \"z\" {\n            j\
    \ = i\n            \n            for (j; j < s.count; j++ ) {\n              \
    \  if s[j] != s[i] {\n                    break\n                }\n         \
    \   }\n            \n            if j == s.count {\n                result.append(\"\
    \\(strings[s.startIndex..<s.endIndex])\")\n            }\n        }\n        \n\
    \        if s[i] == \"b\" || s[i] == \"c\" || s[i] == \"f\" || s[i] == \"k\" ||\
    \ s[i] == \"p\" || s[i] == \"v\" || s[i] == \"x\" || s[i] == \"z\" {\n       \
    \     j = i\n            \n            for (j; j < s.count; j++ ) {\n        \
    \        if s[j] != s[i] {\n                    break\n                }\n   \
    \         }\n            \n            if j == s.count {\n                result.append(\"\
    \\(strings[s.startIndex..<s.\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s:\
    \ \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"\
    Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmp68iz958t.swift:23:11: error: expected 'in' after for-each pattern\n\
    \    for i < s.count {\n          ^\n/tmp/tmp68iz958t.swift:23:11: error: unary\
    \ operator cannot be separated from its operand\n    for i < s.count {\n     \
    \     ^~\n           \n/tmp/tmp68iz958t.swift:27:13: error: C-style for statement\
    \ has been removed in Swift 3\n            for (j; j < s.count; j++ ) {\n    \
    \        ^   ~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp68iz958t.swift:41:13: error: C-style\
    \ for statement has been removed in Swift 3\n            for (j; j < s.count;\
    \ j++ ) {\n            ^   ~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp68iz958t.swift:55:13:\
    \ error: C-style for statement has been removed in Swift 3\n            for (j;\
    \ j < s.count; j++ ) {\n            ^   ~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp68iz958t.swift:69:13:\
    \ error: C-style for statement has been removed in Swift 3\n            for (j;\
    \ j < s.count; j++ ) {\n            ^   ~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp68iz958t.swift:83:13:\
    \ error: C-style for statement has been removed in Swift 3\n            for (j;\
    \ j < s.count; j++ ) {\n            ^   ~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp68iz958t.swift:97:13:\
    \ error: C-style for statement has been removed in Swift 3\n            for (j;\
    \ j < s.count; j++ ) {\n            ^   ~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp68iz958t.swift:104:33:\
    \ error: cannot find ')' to match opening '(' in string interpolation\n      \
    \          result.append(\"\\(strings[s.startIndex..<s.\n                    \
    \            ^\n/tmp/tmp68iz958t.swift:104:31: error: unterminated string literal\n\
    \                result.append(\"\\(strings[s.startIndex..<s.\n              \
    \                ^\n/tmp/tmp68iz958t.swift:126:69: error: expected '}' at end\
    \ of brace statement\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\"\
    , \"c\", \"d\", \"f\"])\n                                                    \
    \                ^\n/tmp/tmp68iz958t.swift:94:129: note: to match this opening\
    \ '{'\n        if s[i] == \"b\" || s[i] == \"c\" || s[i] == \"f\" || s[i] == \"\
    k\" || s[i] == \"p\" || s[i] == \"v\" || s[i] == \"x\" || s[i] == \"z\" {\n  \
    \                                          "
  stdout: ''
  timestamp: 1660014410
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"\
    ]\n/// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n\
    /// select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfunc\
    \ select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    \n    if s == \"\" {\n        return result\n    }\n    \n    var i = 0\n\
    \    var j = 0\n    var k = 0\n    \n    while i < s.count {\n        if s[i]\
    \ == \" \" {\n            j = i\n            while j < s.count && s[j] != \" \"\
    \ {\n                j += 1\n            }\n            \n            if j ==\
    \ s.count {\n                result.append(\"\\n\")\n            } else {\n  \
    \              result.append(\"\\n\")\n                result.append(\"\\t\")\n\
    \                result.append(\"\\n\")\n            }\n            \n       \
    \     i = j\n        } else {\n            k = i\n            while k < s.count\
    \ && s[k] != s[i] {\n                k += 1\n            }\n            \n   \
    \         if k == s.count {\n                result.append(\"\\n\")\n        \
    \    } else {\n                result.append(\"\\n\")\n                result.append(\"\
    \\t\")\n                result.append(\"\\n\")\n            }\n            \n\
    \            i = k\n        }\n    }\n    \n    if n <= result.count {\n     \
    \   return result[n]\n    } else {\n        return result\n    }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n:\
    \ 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3)\
    \ == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n:\
    \ 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"\
    world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s:\
    \ \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1)\
    \ == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpeivtl8fm.swift:25:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if s[i] ==\
    \ \" \" {\n           ^~~~\nSwift.String:3:12: note: 'subscript(_:)' has been\
    \ explicitly marked unavailable here\n    public subscript(i: Int) -> Character\
    \ { get }\n           ^\n/tmp/tmpeivtl8fm.swift:27:34: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \            while j < s.count && s[j] != \" \" {\n                          \
    \       ^~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly marked\
    \ unavailable here\n    public subscript(i: Int) -> Character { get }\n      \
    \     ^\n/tmp/tmpeivtl8fm.swift:42:34: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n         \
    \   while k < s.count && s[k] != s[i] {\n                                 ^~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpeivtl8fm.swift:42:42:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n            while k < s.count && s[k] != s[i] {\n\
    \                                         ^~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpeivtl8fm.swift:59:22: error: cannot\
    \ convert return expression of type 'String' to return type '[String]'\n     \
    \   return result[n]\n               ~~~~~~^~~\n"
  stdout: ''
  timestamp: 1660014410
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"\
    ]\n/// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n\
    /// select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfunc\
    \ select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    var i = 0\n    var j = 0\n    var k = 0\n    var count = 0\n    var word\
    \ = \"\"\n    var words = [String]()\n    \n    for char in s {\n        if char\
    \ == \" \" {\n            words.append(word)\n            word = \"\"\n      \
    \      count = 0\n        }\n        \n        if char == \"a\" || char == \"\
    e\" || char == \"i\" || char == \"o\" || char == \"u\" {\n            word = word\
    \ + char\n            count = count + 1\n        }\n        \n        if char\
    \ == \"n\" {\n            if count >= n {\n                words.append(word)\n\
    \                word = \"\"\n                count = 0\n            }\n     \
    \   }\n        \n        if char == \"s\" {\n            if count >= n {\n   \
    \             words.append(word)\n                word = \"\"\n              \
    \  count = 0\n            }\n        }\n        \n        if char == \"t\" ||\
    \ char == \"h\" || char == \"r\" || char == \"d\" {\n            if count >= n\
    \ {\n                words.append(word)\n                word = \"\"\n       \
    \         count = 0\n            }\n        }\n        \n        if char == \"\
    l\" || char == \"a\" || char == \"m\" || char == \"e\" || char == \"b\" || char\
    \ == \"p\" || char == \"s\" || char == \"d\" || char == \"f\" || char == \"g\"\
    \ || char == \"h\" || char == \"j\" || char == \"k\" || char == \"l\" || char\
    \ == \"m\" || char == \"n\" || char == \"o\" || char == \"p\" || char == \"q\"\
    \ || char == \"r\" || char == \"t\" || char == \"v\" || char == \"w\" || char\
    \ == \"x\" || char == \"y\" || char == \"z\" {\n            if count >= n {\n\
    \                words.append(word)\n                word = \"\"\n           \
    \     count = 0\n            }\n        }\n        \n        if char == \"c\"\
    \ || char == \"f\" || char == \"v\" || char == \"b\" || char == \"d\" || char\
    \ == \"g\" || char == \"j\" || char == \"k\" || char == \"l\" || char == \"m\"\
    \ || char == \"n\" || char == \"p\" || char == \"q\" || char == \"r\" || char\
    \ == \"t\" || char == \"w\" || char == \"x\" || char == \"y\" || char == \"z\"\
    \ {\n            if count >= n {\n                words.append(word)\n       \
    \         word = \"\"\n                count = 0\n            }\n        }\n \
    \       \n        if char == \"b\" || char == \"d\" || char == \"g\" || char ==\
    \ \"j\" || char == \"k\" || char == \"l\" || char == \"m\" || char == \"n\" ||\
    \ char == \"p\" || char == \"q\" || char == \"r\" || char == \"t\" || char ==\
    \ \"w\" || char == \"x\" || char == \"y\" || char == \"z\" {\n            if count\
    \ >= n {\n                word\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s:\
    \ \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"\
    Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmp2pilkc3q.swift:98:69: error: expected '}' at end of brace statement\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])\n\
    \                                                                    ^\n/tmp/tmp2pilkc3q.swift:74:249:\
    \ note: to match this opening '{'\n        if char == \"b\" || char == \"d\" ||\
    \ char == \"g\" || char == \"j\" || char == \"k\" || char == \"l\" || char ==\
    \ \"m\" || char == \"n\" || char == \"p\" || char == \"q\" || char == \"r\" ||\
    \ char == \"t\" || char == \"w\" || char == \"x\" || char == \"y\" || char ==\
    \ \"z\" {\n                                                                  \
    \                                                                            \
    \                                                                            \
    \                              ^\n/tmp/tmp2pilkc3q.swift:98:69: error: expected\
    \ '}' at end of brace statement\nassert(select_words(s: \"a b c d e f\", n: 1)\
    \ == [\"b\", \"c\", \"d\", \"f\"])\n                                         \
    \                           ^\n/tmp/tmp2pilkc3q.swift:22:19: note: to match this\
    \ opening '{'\n    for char in s {\n                  ^\n/tmp/tmp2pilkc3q.swift:98:69:\
    \ error: expected '}' at end of brace statement\nassert(select_words(s: \"a b\
    \ c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])\n                        \
    \                                            ^\n/tmp/tmp2pilkc3q.swift:13:50:\
    \ note: to match this opening '{'\nfunc select_words(s: String, n: Int) -> [String]\
    \ {\n                                                 ^\n/tmp/tmp2pilkc3q.swift:30:27:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            word = word + char\n                          ^\n/tmp/tmp2pilkc3q.swift:76:17:\
    \ warning: variable is unused\n                word\n                ^~~~\n/tmp/tmp2pilkc3q.swift:80:6:\
    \ error: operator functions can only be declared at global or in type scope\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660014410
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"\
    ]\n/// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n\
    /// select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfunc\
    \ select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    \n    if s == \"\" {\n        return result\n    }\n    \n    for char in\
    \ s.characters {\n        if char.unicodeScalars.filter({ $0.isConsonant() }).count\
    \ == n {\n            result.append(String(char))\n        }\n    }\n    \n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"\
    Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary\
    \ had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpzjzed04n.swift:20:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpzjzed04n.swift:21:44:\
    \ error: value of type 'Unicode.Scalar' has no member 'isConsonant'\n        if\
    \ char.unicodeScalars.filter({ $0.isConsonant() }).count == n {\n            \
    \                            ~~ ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014410
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"\
    ]\n/// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n\
    /// select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfunc\
    \ select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    \n    if s == \"\" {\n        return result\n    }\n    \n    var i = 0\n\
    \    var j = 0\n    var k = 0\n    \n    for i < s.count {\n        if s[i] ==\
    \ \" \" {\n            j = i\n            \n            while j < s.count && s[j]\
    \ == \" \" {\n                j += 1\n            }\n            \n          \
    \  if j == s.count {\n                result.append(\"\\n\")\n            }\n\
    \            \n            k = i\n            \n            while k < s.count\
    \ && s[k] != \" \" {\n                k += 1\n            }\n            \n  \
    \          if k == s.count {\n                result.append(\"\\n\")\n       \
    \     }\n            \n            i = k\n        }\n        \n        if s[i]\
    \ == \"a\" || s[i] == \"e\" || s[i] == \"i\" || s[i] == \"o\" || s[i] == \"u\"\
    \ {\n            j = i\n            \n            while j < s.count && s[j] !=\
    \ \"a\" && s[j] != \"e\" && s[j] != \"i\" && s[j] != \"o\" && s[j] != \"u\" {\n\
    \                j += 1\n            }\n            \n            if j == s.count\
    \ {\n                result.append(\"\\n\")\n            }\n            \n   \
    \         k = i\n            \n            while k < s.count && s[k] != \"a\"\
    \ && s[k] != \"e\" && s[k] != \"i\" && s[k] != \"o\" && s[k] != \"u\" {\n    \
    \            k += 1\n            }\n            \n            if k == s.count\
    \ {\n                result.append(\"\\n\")\n            }\n            \n   \
    \         i = k\n        }\n        \n        if s[i] == \"y\" || s[i] == \"a\"\
    \ || s[i] == \"e\" || s[i] == \"i\" || s[i] == \"o\" || s[i] == \"u\" {\n    \
    \        j = i\n            \n            while j < s.count && s[j] != \"y\" &&\
    \ s[j] != \"a\" && s[j] != \"e\" && s[j] != \"i\" && s[j] != \"o\" && s[j] !=\
    \ \"u\" {\n                j += 1\n            }\n            \n            if\
    \ j == s.count {\n                result.append(\"\\n\")\n            }\n    \
    \        \n            k = i\n            \n            while k < s.count && s[k]\
    \ != \"y\" && s[k] != \"a\" && s[k] != \"e\" && s[k] != \"i\" && s[k] != \"o\"\
    \ && s[k] != \"u\" {\n                k += 1\n            }\n            \n  \
    \          if k == s.count {\n                result.append(\"\\n\")\n       \
    \     }\n            \n            i = k\n        }\n        \n        if s[i]\
    \ == \"o\" || s[i] == \"u\" || s[i] == \"a\" || s[i] == \"e\" || s[i] == \"i\"\
    \ || s[i] == \"y\" {\n            j = i\n            \n            while j < s.count\
    \ && s[j] != \"o\" && s[j] != \"u\" && s[j] != \"a\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"\
    little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\"\
    , \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpcwkpru9n.swift:24:11: error: expected 'in' after for-each pattern\n\
    \    for i < s.count {\n          ^\n/tmp/tmpcwkpru9n.swift:24:11: error: unary\
    \ operator cannot be separated from its operand\n    for i < s.count {\n     \
    \     ^~\n           \n/tmp/tmpcwkpru9n.swift:100:72: error: unterminated string\
    \ literal\n            while j < s.count && s[j] != \"o\" && s[j] != \"u\" &&\
    \ s[j] != \"a\n                                                              \
    \         ^\n/tmp/tmpcwkpru9n.swift:122:69: error: expected '}' at end of brace\
    \ statement\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"\
    d\", \"f\"])\n                                                               \
    \     ^\n/tmp/tmpcwkpru9n.swift:24:21: note: to match this opening '{'\n    for\
    \ i < s.count {\n                    ^\n/tmp/tmpcwkpru9n.swift:122:69: error:\
    \ expected '}' at end of brace statement\nassert(select_words(s: \"a b c d e f\"\
    , n: 1) == [\"b\", \"c\", \"d\", \"f\"])\n                                   \
    \                                 ^\n/tmp/tmpcwkpru9n.swift:13:50: note: to match\
    \ this opening '{'\nfunc select_words(s: String, n: Int) -> [String] {\n     \
    \                                            ^\n/tmp/tmpcwkpru9n.swift:24:11:\
    \ error: '<' is not a prefix unary operator\n    for i < s.count {\n         \
    \ ^\n"
  stdout: ''
  timestamp: 1660014410
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"\
    ]\n/// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n\
    /// select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfunc\
    \ select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    \n    if s == \"\" {\n        return result\n    }\n    \n    for char in\
    \ s.characters {\n        if char.unicodeScalars.filter({ $0.isConsonant() }).count\
    \ == n {\n            result.append(String(char))\n        }\n    }\n    \n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"\
    Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary\
    \ had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpzjzed04n.swift:20:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpzjzed04n.swift:21:44:\
    \ error: value of type 'Unicode.Scalar' has no member 'isConsonant'\n        if\
    \ char.unicodeScalars.filter({ $0.isConsonant() }).count == n {\n            \
    \                            ~~ ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014410
- exit_code: -4
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"\
    ]\n/// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n\
    /// select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfunc\
    \ select_words(s: String, n: Int) -> [String] {\n    \n    // TODO: Write your\
    \ code here\n    \n    return []\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s:\
    \ \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"\
    Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: Exception
  stderr: 'tmp6exp7e5i/tmp6exp7e5i.swift:33: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac807309c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac807000b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac807000988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac806fff7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp6exp7e5i                        0x0000564171cb94c4 <unavailable> + 5316

    5    libc.so.6                          0x00002ac8074f5460 __libc_start_main +
    245

    6    tmp6exp7e5i                        0x0000564171cb90c9 <unavailable> + 4297

    '
  stdout: ''
  timestamp: 1660014410
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"\
    ]\n/// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n\
    /// select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfunc\
    \ select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    \n    if s == \"\" {\n        return result\n    }\n    \n    var i = 0\n\
    \    var j = 0\n    \n    for char in s {\n        if char == \" \" {\n      \
    \      j = i\n        }\n        \n        if char == \"a\" || char == \"e\" ||\
    \ char == \"i\" || char == \"o\" || char == \"u\" {\n            j = i\n     \
    \   }\n        \n        if char == \"y\" {\n            j = i\n        }\n  \
    \      \n        if char == \"s\" {\n            j = i\n        }\n        \n\
    \        if char == \"d\" || char == \"h\" || char == \"l\" || char == \"m\" ||\
    \ char == \"n\" || char == \"t\" || char == \"w\" {\n            j = i\n     \
    \   }\n        \n        if char == \"b\" || char == \"c\" || char == \"f\" ||\
    \ char == \"v\" || char == \"x\" || char == \"z\" {\n            j = i\n     \
    \   }\n        \n        if char == \"p\" || char == \"q\" || char == \"r\" ||\
    \ char == \"z\" || char == \"j\" {\n            j = i\n        }\n        \n \
    \       if char == \"k\" || char == \"l\" || char == \"m\" || char == \"n\" ||\
    \ char == \"r\" || char == \"s\" || char == \"t\" || char == \"w\" {\n       \
    \     j = i\n        }\n        \n        if char == \"a\" || char == \"e\" ||\
    \ char == \"i\" || char == \"o\" || char == \"u\" {\n            j = i\n     \
    \   }\n        \n        if char == \"y\" {\n            j = i\n        }\n  \
    \      \n        if char == \"s\" {\n            j = i\n        }\n        \n\
    \        if char == \"d\" || char == \"h\" || char == \"l\" || char == \"m\" ||\
    \ char == \"n\" || char == \"t\" || char == \"w\" {\n            j = i\n     \
    \   }\n        \n        if char == \"b\" || char == \"c\" || char == \"f\" ||\
    \ char == \"v\" || char == \"x\" || char == \"z\" {\n            j = i\n     \
    \   }\n        \n        if char == \"p\" || char == \"q\" || char == \"r\" ||\
    \ char == \"z\" || char == \"j\" {\n            j = i\n        }\n        \n \
    \       if char == \"k\" || char == \"l\" || char == \"m\" || char == \"n\" ||\
    \ char == \"r\" || char == \"s\" || char == \"t\" || char == \"w\" {\n       \
    \     j = i\n        }\n        \n        if char == \"a\" || char == \"e\" ||\
    \ char == \"i\" || char == \"o\" || char == \"u\" {\n            j = i\n     \
    \   }\n        \n        if char == \"y\" {\n            j = i\n        }\n  \
    \      \n        if char\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s:\
    \ \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"\
    Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpm_a_s1zz.swift:92:16: error: expected '{' after 'if' condition\n\
    \        if char\n               ^\n/tmp/tmpm_a_s1zz.swift:114:69: error: expected\
    \ '}' at end of brace statement\nassert(select_words(s: \"a b c d e f\", n: 1)\
    \ == [\"b\", \"c\", \"d\", \"f\"])\n                                         \
    \                           ^\n/tmp/tmpm_a_s1zz.swift:13:50: note: to match this\
    \ opening '{'\nfunc select_words(s: String, n: Int) -> [String] {\n          \
    \                                       ^\n/tmp/tmpm_a_s1zz.swift:92:12: error:\
    \ cannot convert value of type 'Character' to expected condition type 'Bool'\n\
    \        if char\n           ^~~~\n/tmp/tmpm_a_s1zz.swift:96:6: error: operator\
    \ functions can only be declared at global or in type scope\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660014410
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"\
    ]\n/// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n\
    /// select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfunc\
    \ select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    \n    if s == \"\" {\n        return result\n    }\n    \n    for char in\
    \ s.characters {\n        if char == \" \" {\n            continue\n        }\n\
    \        \n        if char == \" \" || char == \"\\t\" {\n            continue\n\
    \        }\n        \n        if char == \"a\" || char == \"e\" || char == \"\
    i\" || char == \"o\" || char == \"u\" {\n            continue\n        }\n   \
    \     \n        if char == \"n\" {\n            if n <= 1 {\n                continue\n\
    \            }\n        }\n        \n        if char == \"M\" || char == \"m\"\
    \ {\n            if n <= 2 {\n                continue\n            }\n      \
    \  }\n        \n        if char == \"P\" || char == \"p\" {\n            if n\
    \ <= 3 {\n                continue\n            }\n        }\n        \n     \
    \   if char == \"T\" || char == \"t\" {\n            if n <= 4 {\n           \
    \     continue\n            }\n        }\n        \n        if char == \"S\" ||\
    \ char == \"s\" {\n            if n <= 5 {\n                continue\n       \
    \     }\n        }\n        \n        if char == \"H\" || char == \"h\" {\n  \
    \          if n <= 6 {\n                continue\n            }\n        }\n \
    \       \n        if char == \"R\" || char == \"r\" {\n            if n <= 7 {\n\
    \                continue\n            }\n        }\n        \n        if char\
    \ == \"L\" || char == \"l\" {\n            if n <= 8 {\n                continue\n\
    \            }\n        }\n        \n        if char == \"U\" || char == \"u\"\
    \ {\n            if n <= 9 {\n                continue\n            }\n      \
    \  }\n        \n        if char == \"D\" || char == \"d\" {\n            if n\
    \ <= 10 {\n                continue\n            }\n        }\n        \n    \
    \    if char == \"F\" || char == \"f\" {\n            if n <= 11 {\n         \
    \       continue\n            }\n        }\n        \n        if char == \"V\"\
    \ || char == \"v\" {\n            if n <= 12 {\n                continue\n   \
    \         }\n        }\n        \n        if char == \"B\" || char == \"b\" {\n\
    \            if n <= 13 {\n                continue\n            }\n        }\n\
    \        \n        if char == \"K\" || char == \"k\" {\n            if n <= 14\
    \ {\n                continue\n            }\n        }\n        \n        if\
    \ char == \"J\" || char == \"j\" {\n            if n <= 15 {\n               \
    \ continue\n            }\n        }\n        \n        if char == \"X\" || char\
    \ == \"x\" {\n            if n <= 16 {\n                continue\n           \
    \ }\n        }\n        \n        if char == \"Z\" || char == \"z\" {\n      \
    \      if n <= 17 {\n                continue\n            }\n        }\n    \
    \    \n        if char == \"M\" || char == \"m\" {\n\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"\
    little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\"\
    , \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpbn4slpjs.swift:158:69: error: expected '}' at end of brace statement\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])\n\
    \                                                                    ^\n/tmp/tmpbn4slpjs.swift:20:30:\
    \ note: to match this opening '{'\n    for char in s.characters {\n          \
    \                   ^\n/tmp/tmpbn4slpjs.swift:158:69: error: expected '}' at end\
    \ of brace statement\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\"\
    , \"c\", \"d\", \"f\"])\n                                                    \
    \                ^\n/tmp/tmpbn4slpjs.swift:13:50: note: to match this opening\
    \ '{'\nfunc select_words(s: String, n: Int) -> [String] {\n                  \
    \                               ^\n/tmp/tmpbn4slpjs.swift:20:19: error: 'characters'\
    \ is unavailable: Please use String directly\n    for char in s.characters {\n\
    \                  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpbn4slpjs.swift:140:6: error: operator functions can only be declared\
    \ at global or in type scope\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n     ^\n/tmp/tmpbn4slpjs.swift:14:9: warning: variable 'result' was\
    \ never mutated; consider changing to 'let' constant\n    var result = [String]()\n\
    \    ~~~ ^\n    let\n"
  stdout: ''
  timestamp: 1660014410
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"\
    ]\n/// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n\
    /// select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfunc\
    \ select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    var i = 0\n    var j = 0\n    var k = 0\n    var l = s.count\n    var m =\
    \ n\n    var n = s.count\n    var o = 0\n    var p = s.count\n    var q = s.count\n\
    \    var r = s.count\n    var s = s.count\n    var t = s.count\n    var u = s.count\n\
    \    var v = s.count\n    var w = s.count\n    var x = s.count\n    var y = s.count\n\
    \    var z = s.count\n    var a = s.count\n    var b = s.count\n    var c = s.count\n\
    \    var d = s.count\n    var e = s.count\n    var f = s.count\n    var g = s.count\n\
    \    var h = s.count\n    var i = s.count\n    var j = s.count\n    var k = s.count\n\
    \    var l = s.count\n    var m = s.count\n    var n = s.count\n    var o = s.count\n\
    \    var p = s.count\n    var q = s.count\n    var r = s.count\n    var s = s.count\n\
    \    var t = s.count\n    var u = s.count\n    var v = s.count\n    var w = s.count\n\
    \    var x = s.count\n    var y = s.count\n    var z = s.count\n    var a = s.count\n\
    \    var b = s.count\n    var c = s.count\n    var d = s.count\n    var e = s.count\n\
    \    var f = s.count\n    var g = s.count\n    var h = s.count\n    var i = s.count\n\
    \    var j = s.count\n    var k = s.count\n    var l = s.count\n    var m = s.count\n\
    \    var n = s.count\n    var o = s.count\n    var p = s.count\n    var q = s.count\n\
    \    var r = s.count\n    var s = s.count\n    var t = s.count\n    var u = s.count\n\
    \    var v = s.count\n    var w = s.count\n    var x = s.count\n    var y = s.count\n\
    \    var z = s.count\n    var a = s.count\n    var b = s.count\n    var c = s.count\n\
    \    var d = s.count\n    var e = s.count\n    var f = s.count\n    var g = s.count\n\
    \    var h = s.count\n    var i = s.count\n    var j = s.count\n    var k = s.count\n\
    \    var l = s.count\n    var m = s.count\n    var n = s.count\n    var o = s.count\n\
    \    var p = s.count\n    var q = s.count\n    var r = s.count\n    var s = s.count\n\
    \    var t = s.count\n    var u = s.count\n    var v = s.count\n    var w = s.count\n\
    \    var x = s.count\n    var y = s.count\n    var z = s.count\n    var a = s.count\n\
    \    var b = s.count\n    var c = s.count\n    var d = s.count\n    var e = s.count\n\
    \    var f = s.count\n    var \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s:\
    \ \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"\
    Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmp3jfwkye1.swift:117:8: error: expected pattern\n    var \n     \
    \  ^\n/tmp/tmp3jfwkye1.swift:26:15: error: value of type 'Int' has no member 'count'\n\
    \    var t = s.count\n            ~ ^~~~~\n/tmp/tmp3jfwkye1.swift:27:15: error:\
    \ value of type 'Int' has no member 'count'\n    var u = s.count\n           \
    \ ~ ^~~~~\n/tmp/tmp3jfwkye1.swift:28:15: error: value of type 'Int' has no member\
    \ 'count'\n    var v = s.count\n            ~ ^~~~~\n/tmp/tmp3jfwkye1.swift:29:15:\
    \ error: value of type 'Int' has no member 'count'\n    var w = s.count\n    \
    \        ~ ^~~~~\n/tmp/tmp3jfwkye1.swift:30:15: error: value of type 'Int' has\
    \ no member 'count'\n    var x = s.count\n            ~ ^~~~~\n/tmp/tmp3jfwkye1.swift:31:15:\
    \ error: value of type 'Int' has no member 'count'\n    var y = s.count\n    \
    \        ~ ^~~~~\n/tmp/tmp3jfwkye1.swift:32:15: error: value of type 'Int' has\
    \ no member 'count'\n    var z = s.count\n            ~ ^~~~~\n/tmp/tmp3jfwkye1.swift:33:15:\
    \ error: value of type 'Int' has no member 'count'\n    var a = s.count\n    \
    \        ~ ^~~~~\n/tmp/tmp3jfwkye1.swift:34:15: error: value of type 'Int' has\
    \ no member 'count'\n    var b = s.count\n            ~ ^~~~~\n/tmp/tmp3jfwkye1.swift:35:15:\
    \ error: value of type 'Int' has no member 'count'\n    var c = s.count\n    \
    \        ~ ^~~~~\n/tmp/tmp3jfwkye1.swift:36:15: error: value of type 'Int' has\
    \ no member 'count'\n    var d = s.count\n            ~ ^~~~~\n/tmp/tmp3jfwkye1.swift:37:15:\
    \ error: value of type 'Int' has no member 'count'\n    var e = s.count\n    \
    \        ~ ^~~~~\n/tmp/tmp3jfwkye1.swift:38:15: error: value of type 'Int' has\
    \ no member 'count'\n    var f = s.count\n            ~ ^~~~~\n/tmp/tmp3jfwkye1.swift:39:15:\
    \ error: value of type 'Int' has no member 'count'\n    var g = s.count\n    \
    \        ~ ^~~~~\n/tmp/tmp3jfwkye1.swift:40:15: error: value of type 'Int' has\
    \ no member 'count'\n    var h = s.count\n            ~ ^~~~~\n/tmp/tmp3jfwkye1.swift:41:15:\
    \ error: value of type 'Int' has no member 'count'\n    var i = s.count\n    \
    \        ~ ^~~~~\n/tmp/tmp3jfwkye1.swift:42:15: error: value of type 'Int' has\
    \ no member '"
  stdout: ''
  timestamp: 1660014410
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"\
    ]\n/// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n\
    /// select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfunc\
    \ select_words(s: String, n: Int) -> [String] {\n    var words = [String]()\n\
    \    \n    if s == \"\" {\n        return words\n    }\n    \n    for letter in\
    \ s {\n        if letter == \" \" {\n            words.append(\"\")\n        }\
    \ else {\n            if letter == \"a\" || letter == \"e\" || letter == \"i\"\
    \ || letter == \"o\" || letter == \"u\" {\n                words.append(letter)\n\
    \            }\n        }\n    }\n    \n    return words\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"\
    little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\"\
    , \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpd25tn0by.swift:25:30: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n                words.append(letter)\n \
    \                            ^\n"
  stdout: ''
  timestamp: 1660014410
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"\
    ]\n/// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n\
    /// select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfunc\
    \ select_words(s: String, n: Int) -> [String] {\n    \n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"\
    little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\"\
    , \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: '/tmp/tmpuails2sj.swift:15:1: error: missing return in global function expected
    to return ''[String]''

    }

    ^

    '
  stdout: ''
  timestamp: 1660014410
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"\
    ]\n/// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n\
    /// select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfunc\
    \ select_words(s: String, n: Int) -> [String] {\n    \n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"\
    little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\"\
    , \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: '/tmp/tmpuails2sj.swift:15:1: error: missing return in global function expected
    to return ''[String]''

    }

    ^

    '
  stdout: ''
  timestamp: 1660014410
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"\
    ]\n/// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n\
    /// select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfunc\
    \ select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    \n    if s == \"\" {\n        return result\n    }\n    \n    var i = 0\n\
    \    var j = 0\n    var k = 0\n    \n    for i < s.count {\n        if s[i] ==\
    \ \" \" {\n            i += 1\n            continue\n        }\n        \n   \
    \     if s[i] == \" \" {\n            i += 1\n            continue\n        }\n\
    \        \n        if s[i] == \" \" {\n            i += 1\n            continue\n\
    \        }\n        \n        if s[i] == \" \" {\n            i += 1\n       \
    \     continue\n        }\n        \n        if s[i] == \" \" {\n            i\
    \ += 1\n            continue\n        }\n        \n        if s[i] == \" \" {\n\
    \            i += 1\n            continue\n        }\n        \n        if s[i]\
    \ == \" \" {\n            i += 1\n            continue\n        }\n        \n\
    \        if s[i] == \" \" {\n            i += 1\n            continue\n      \
    \  }\n        \n        if s[i] == \" \" {\n            i += 1\n            continue\n\
    \        }\n        \n        if s[i] == \" \" {\n            i += 1\n       \
    \     continue\n        }\n        \n        if s[i] == \" \" {\n            i\
    \ += 1\n            continue\n        }\n        \n        if s[i] == \" \" {\n\
    \            i += 1\n            continue\n        }\n        \n        if s[i]\
    \ == \" \" {\n            i += 1\n            continue\n        }\n        \n\
    \        if s[i] == \" \" {\n            i += 1\n            continue\n      \
    \  }\n        \n        if s[i] == \" \" {\n            i += 1\n            continue\n\
    \        }\n        \n        if s[i] == \" \" {\n            i += 1\n       \
    \     continue\n        }\n        \n        if s[i] == \" \" {\n            i\
    \ += 1\n            continue\n        }\n        \n        if s[i] == \" \" {\n\
    \            i += 1\n            continue\n        }\n        \n        if s[i]\
    \ == \" \" {\n            i += 1\n            continue\n        }\n        \n\
    \        if s[i] == \" \" {\n            i += 1\n            continue\n      \
    \  }\n        \n        if s[i] == \" \" {\n            i += 1\n            continue\n\
    \        }\n        \n        if s[i] == \" \" {\n            i += 1\n       \
    \     continue\n        }\n        \n        if s[i] == \" \" {\n            i\
    \ += 1\n            continue\n        }\n        \n        if s[i] == \" \" {\n\
    \            i += 1\n            continue\n        }\n        \n        if s[i]\
    \ == \" \" {\n            i += 1\n            continue\n        }\n        \n\
    \        if s[i] == \" \" {\n            i += 1\n            continue\n      \
    \  }\n        \n        if s[i] == \" \" {\n            i += 1\n            continue\n\
    \        }\n        \n        if s[i] == \" \" {\n            i += 1\n       \
    \     continue\n        }\n        \n        if s[i] == \" \" {\n            i\
    \ += 1\n            continue\n        }\n        \n        if s[i] == \" \" {\n\
    \            i += 1\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"\
    Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary\
    \ had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpat8iespb.swift:24:11: error: expected 'in' after for-each pattern\n\
    \    for i < s.count {\n          ^\n/tmp/tmpat8iespb.swift:24:11: error: unary\
    \ operator cannot be separated from its operand\n    for i < s.count {\n     \
    \     ^~\n           \n/tmp/tmpat8iespb.swift:193:69: error: expected '}' at end\
    \ of brace statement\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\"\
    , \"c\", \"d\", \"f\"])\n                                                    \
    \                ^\n/tmp/tmpat8iespb.swift:24:21: note: to match this opening\
    \ '{'\n    for i < s.count {\n                    ^\n/tmp/tmpat8iespb.swift:193:69:\
    \ error: expected '}' at end of brace statement\nassert(select_words(s: \"a b\
    \ c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])\n                        \
    \                                            ^\n/tmp/tmpat8iespb.swift:13:50:\
    \ note: to match this opening '{'\nfunc select_words(s: String, n: Int) -> [String]\
    \ {\n                                                 ^\n/tmp/tmpat8iespb.swift:24:11:\
    \ error: '<' is not a prefix unary operator\n    for i < s.count {\n         \
    \ ^\n"
  stdout: ''
  timestamp: 1660014410
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"\
    ]\n/// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n\
    /// select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfunc\
    \ select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    \n    if s == \"\" {\n        return result\n    }\n    \n    let chars =\
    \ s.characters\n    \n    for char in chars {\n        if char == \" \" {\n  \
    \          continue\n        }\n        \n        if char.unicodeScalars.filter({\
    \ $0.isConsonant() == true }).count == n {\n            result.append(String(char))\n\
    \        }\n    }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"\
    ])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"\
    lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpkb1w2jqm.swift:20:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    let chars = s.characters\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpkb1w2jqm.swift:27:44:\
    \ error: value of type 'Unicode.Scalar' has no member 'isConsonant'\n        if\
    \ char.unicodeScalars.filter({ $0.isConsonant() == true }).count == n {\n    \
    \                                    ~~ ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014410
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"\
    ]\n/// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n\
    /// select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfunc\
    \ select_words(s: String, n: Int) -> [String] {\n    return select_words(s, n,\
    \ 0)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(select_words(s: \"Mary had a\
    \ little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little\
    \ lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white\
    \ space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n:\
    \ 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"\
    ])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s:\
    \ \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpn5506xvh.swift:14:31: error: extra argument in call\n    return\
    \ select_words(s, n, 0)\n                       ~~~~~~~^~\n"
  stdout: ''
  timestamp: 1660014410
- exit_code: -4
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"\
    ]\n/// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n\
    /// select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfunc\
    \ select_words(s: String, n: Int) -> [String] {\n    return []\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"\
    little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\"\
    , \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: Exception
  stderr: 'tmpszvxx0ul/tmpszvxx0ul.swift:30: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b89c1917c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b89c160eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b89c160e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b89c160d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpszvxx0ul                        0x000055e491c114c4 <unavailable> + 5316

    5    libc.so.6                          0x00002b89c1b03460 __libc_start_main +
    245

    6    tmpszvxx0ul                        0x000055e491c110c9 <unavailable> + 4297

    '
  stdout: ''
  timestamp: 1660014410
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"\
    ]\n/// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n\
    /// select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfunc\
    \ select_words(s: String, n: Int) -> [String] {\n    var words = [String]()\n\
    \    \n    if s == \"\" {\n        return words\n    }\n    \n    var i = 0\n\
    \    var j = 0\n    \n    for i < s.count {\n        if s[i] == \" \" {\n    \
    \        j = i\n            \n            while j < s.count && s[j] == \" \" {\n\
    \                j += 1\n            }\n            \n            if j - i > n\
    \ {\n                words = append(words, s[i : j])\n            }\n        \
    \    i = j\n        }\n    }\n    \n    return words\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"\
    little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\"\
    , \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpaq3zjil0.swift:23:11: error: expected 'in' after for-each pattern\n\
    \    for i < s.count {\n          ^\n/tmp/tmpaq3zjil0.swift:23:11: error: unary\
    \ operator cannot be separated from its operand\n    for i < s.count {\n     \
    \     ^~\n           \n/tmp/tmpaq3zjil0.swift:23:11: error: '<' is not a prefix\
    \ unary operator\n    for i < s.count {\n          ^\n"
  stdout: ''
  timestamp: 1660014410
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"\
    ]\n/// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n\
    /// select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfunc\
    \ select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    \n    if s == \"\" {\n        return result\n    }\n    \n    for char in\
    \ s.characters {\n        if char.unicodeScalars.filter({ $0.isConsonant() }).count\
    \ == n {\n            result.append(String(char))\n        }\n    }\n    \n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"\
    Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary\
    \ had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpzjzed04n.swift:20:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpzjzed04n.swift:21:44:\
    \ error: value of type 'Unicode.Scalar' has no member 'isConsonant'\n        if\
    \ char.unicodeScalars.filter({ $0.isConsonant() }).count == n {\n            \
    \                            ~~ ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014410
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"\
    ]\n/// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n\
    /// select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfunc\
    \ select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    \n    if s == \"\" {\n        return result\n    }\n    \n    var i = 0\n\
    \    var j = 0\n    var k = 0\n    \n    while i < s.count {\n        if s[i]\
    \ == \" \" {\n            i += 1\n            continue\n        }\n        \n\
    \        if s[i] == \"a\" {\n            i += 1\n            if j == n {\n   \
    \             result.append(\"a\")\n                j = 0\n                i +=\
    \ 1\n                continue\n            }\n        }\n        \n        if\
    \ s[i] == \"e\" {\n            i += 1\n            if j == n {\n             \
    \   result.append(\"e\")\n                j = 0\n                i += 1\n    \
    \            continue\n            }\n        }\n        \n        if s[i] ==\
    \ \"i\" {\n            i += 1\n            if j == n {\n                result.append(\"\
    i\")\n                j = 0\n                i += 1\n                continue\n\
    \            }\n        }\n        \n        if s[i] == \"o\" {\n            i\
    \ += 1\n            if j == n {\n                result.append(\"o\")\n      \
    \          j = 0\n                i += 1\n                continue\n         \
    \   }\n        }\n        \n        if s[i] == \"u\" {\n            i += 1\n \
    \           if j == n {\n                result.append(\"u\")\n              \
    \  j = 0\n                i += 1\n                continue\n            }\n  \
    \      }\n        \n        if s[i] == \"y\" {\n            i += 1\n         \
    \   if j == n {\n                result.append(\"y\")\n                j = 0\n\
    \                i += 1\n                continue\n            }\n        }\n\
    \        \n        if s[i] == \"A\" {\n            i += 1\n            if j ==\
    \ n {\n                result.append(\"A\")\n                j = 0\n         \
    \       i += 1\n                continue\n            }\n        }\n        \n\
    \        if s[i] == \"E\" {\n            i += 1\n            if j == n {\n   \
    \             result.append(\"E\")\n                j = 0\n                i +=\
    \ 1\n                continue\n            }\n        }\n        \n        if\
    \ s[i] == \"I\" {\n            i += 1\n            if j == n {\n             \
    \   result.append(\"I\")\n                j = 0\n                i += 1\n    \
    \            continue\n            }\n        }\n        \n        if s[i] ==\
    \ \"O\" {\n            i += 1\n            if j == n {\n                result.append(\"\
    O\")\n                j = 0\n                i += 1\n                continue\n\
    \            }\n        }\n        \n        if s[i] == \"U\" {\n            i\
    \ += 1\n            if j == n {\n                result.append(\"U\")\n      \
    \          j = 0\n                i += 1\n                continue\n         \
    \   }\n        }\n        \n        if s[i] == \"Y\" {\n            i += 1\n \
    \           if j == n {\n                result.append(\"Y\")\n              \
    \  j = 0\n                i += 1\n                continue\n            }\n  \
    \      }\n        \n        if s[i] == \"b\" {\n            i += 1\n         \
    \   if j == n {\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"\
    Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary\
    \ had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpt7l6sw87.swift:174:69: error: expected '}' at end of brace statement\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])\n\
    \                                                                    ^\n/tmp/tmpt7l6sw87.swift:150:24:\
    \ note: to match this opening '{'\n        if s[i] == \"b\" {\n              \
    \         ^\n/tmp/tmpt7l6sw87.swift:174:69: error: expected '}' at end of brace\
    \ statement\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"\
    d\", \"f\"])\n                                                               \
    \     ^\n/tmp/tmpt7l6sw87.swift:24:23: note: to match this opening '{'\n    while\
    \ i < s.count {\n                      ^\n/tmp/tmpt7l6sw87.swift:174:69: error:\
    \ expected '}' at end of brace statement\nassert(select_words(s: \"a b c d e f\"\
    , n: 1) == [\"b\", \"c\", \"d\", \"f\"])\n                                   \
    \                                 ^\n/tmp/tmpt7l6sw87.swift:13:50: note: to match\
    \ this opening '{'\nfunc select_words(s: String, n: Int) -> [String] {\n     \
    \                                            ^\n/tmp/tmpt7l6sw87.swift:25:12:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if s[i] == \" \" {\n           ^~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpt7l6sw87.swift:30:12:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if s[i] == \"a\" {\n           ^~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpt7l6sw87.swift:40:12:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if s[i] == \"e\" {\n           ^~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpt7l6sw87.swift:50:12:\
    \ error: 'subscr"
  stdout: ''
  timestamp: 1660014411
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"\
    ]\n/// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n\
    /// select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfunc\
    \ select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    \n    if s == \"\" {\n        return result\n    }\n    \n    for char in\
    \ s.characters {\n        if char.unicodeScalars.filter({ $0.isConsonant() }).count\
    \ == n {\n            result.append(String(char))\n        }\n    }\n    \n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"\
    Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary\
    \ had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpzjzed04n.swift:20:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpzjzed04n.swift:21:44:\
    \ error: value of type 'Unicode.Scalar' has no member 'isConsonant'\n        if\
    \ char.unicodeScalars.filter({ $0.isConsonant() }).count == n {\n            \
    \                            ~~ ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014410
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"\
    ]\n/// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n\
    /// select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfunc\
    \ select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    \n    if s == \"\" {\n        return result\n    }\n    \n    var i = 0\n\
    \    var j = 0\n    \n    for char in s.characters {\n        if char == \" \"\
    \ {\n            if i == n {\n                result.appendContentsOf(select_words(s.substringWithRange(i..<j),\
    \ n))\n                i = j + 1\n            }\n        }\n        \n       \
    \ if char == \"a\" || char == \"e\" || char == \"i\" || char == \"o\" || char\
    \ == \"u\" {\n            if i == n {\n                result.appendContentsOf(select_words(s.substringWithRange(i..<j),\
    \ n))\n                i = j + 1\n            }\n        }\n        \n       \
    \ if char == \"y\" {\n            if i == n {\n                result.appendContentsOf(select_words(s.substringWithRange(i..<j),\
    \ n))\n                i = j + 1\n            }\n        }\n        \n       \
    \ if char == \"s\" {\n            if i == n {\n                result.appendContentsOf(select_words(s.substringWithRange(i..<j),\
    \ n))\n                i = j + 1\n            }\n        }\n        \n       \
    \ if char == \"h\" {\n            if i == n {\n                result.appendContentsOf(select_words(s.substringWithRange(i..<j),\
    \ n))\n                i = j + 1\n            }\n        }\n        \n       \
    \ if char == \"l\" {\n            if i == n {\n                result.appendContentsOf(select_words(s.substringWithRange(i..<j),\
    \ n))\n                i = j + 1\n            }\n        }\n        \n       \
    \ if char == \"d\" {\n            if i == n {\n                result.appendContentsOf(select_words(s.substringWithRange(i..<j),\
    \ n))\n                i = j + 1\n            }\n        }\n        \n       \
    \ if char == \"t\" {\n            if i == n {\n                result.appendContentsOf(select_words(s.substringWithRange(i..<j),\
    \ n))\n                i = j + 1\n            }\n        }\n        \n       \
    \ if char == \"n\" {\n            if i == n {\n                result.appendContentsOf(select_words(s.substringWithRange(i..<j),\
    \ n))\n                i = j + 1\n            }\n        }\n        \n       \
    \ if char == \"g\" {\n            if i == n {\n                result.appendContentsOf(select_words(s.substringWithRange(i..<j),\
    \ n))\n                i = j + 1\n            }\n        }\n        \n       \
    \ if char == \"p\" {\n            if i == n {\n                result.appendContentsOf(select_words(s.substringWithRange(i..<j),\
    \ n))\n                i = j + 1\n            }\n        }\n        \n       \
    \ if char == \"b\" {\n            if i == n {\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"\
    ])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"\
    lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpyc5g03up.swift:124:69: error: expected '}' at end of brace statement\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])\n\
    \                                                                    ^\n/tmp/tmpyc5g03up.swift:101:24:\
    \ note: to match this opening '{'\n        if char == \"b\" {\n              \
    \         ^\n/tmp/tmpyc5g03up.swift:124:69: error: expected '}' at end of brace\
    \ statement\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"\
    d\", \"f\"])\n                                                               \
    \     ^\n/tmp/tmpyc5g03up.swift:23:30: note: to match this opening '{'\n    for\
    \ char in s.characters {\n                             ^\n/tmp/tmpyc5g03up.swift:124:69:\
    \ error: expected '}' at end of brace statement\nassert(select_words(s: \"a b\
    \ c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])\n                        \
    \                                            ^\n/tmp/tmpyc5g03up.swift:13:50:\
    \ note: to match this opening '{'\nfunc select_words(s: String, n: Int) -> [String]\
    \ {\n                                                 ^\n/tmp/tmpyc5g03up.swift:23:19:\
    \ error: 'characters' is unavailable: Please use String directly\n    for char\
    \ in s.characters {\n                  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpyc5g03up.swift:26:24: error: value of type '[String]'\
    \ has no member 'appendContentsOf'\n                result.appendContentsOf(select_words(s.substringWithRange(i..<j),\
    \ n))\n                ~~~~~~ ^~~~~~~~~~~~~~~~\n/tmp/tmpyc5g03up.swift:26:53:\
    \ error: missing argument labels 's:n:' in call\n                result.appendContentsOf(select_words(s.substringWithRange(i..<j),\
    \ n))\n                                                    ^\n               \
    \                                      s:                           n: \n/tmp/tmpyc5g03up.swift:26:56:\
    \ error: value of type 'String' has no member 'substringWithRange'\n         \
    \       result.appendContentsOf(select_words(s.substringWithRange(i..<j), n))\n\
    \              "
  stdout: ''
  timestamp: 1660014410
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"\
    ]\n/// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n\
    /// select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfunc\
    \ select_words(s: String, n: Int) -> [String] {\n    \n    var result = [String]()\n\
    \    \n    if s == \"\" {\n        return result\n    }\n    \n    var i = 0\n\
    \    var j = 0\n    var k = 0\n    \n    while i < s.count {\n        \n     \
    \   if s[i] == \" \" {\n            \n            i += 1\n            \n     \
    \       if i == s.count {\n                \n                i += 1\n        \
    \        \n                if i == s.count {\n                    \n         \
    \           i += 1\n                    \n                    if i == s.count\
    \ {\n                        \n                        i += 1\n              \
    \          \n                        if i == s.count {\n                     \
    \       \n                            i += 1\n                            \n \
    \                           if i == s.count {\n                              \
    \  \n                                i += 1\n                                \n\
    \                                if i == s.count {\n                         \
    \           \n                                    i += 1\n                   \
    \                 \n                                    if i == s.count {\n  \
    \                                      \n                                    \
    \    i += 1\n                                        \n                      \
    \                  if i == s.count {\n                                       \
    \     \n                                            i += 1\n                 \
    \                           \n                                            if i\
    \ == s.count {\n                                                \n           \
    \                                     i += 1\n                               \
    \                 \n                                                if i == s.count\
    \ {\n                                                    \n                  \
    \                                  i += 1\n                                  \
    \                  \n                                                    if i\
    \ == s.count {\n                                                        \n   \
    \                                                     i += 1\n               \
    \                                         \n                                 \
    \                       if i == s.count {\n                                  \
    \                          \n                                                \
    \            i += 1\n                                                        \
    \    \n                                                            if i == s.count\
    \ {\n                                                                \n      \
    \                                                          i += 1\n          \
    \                                                      \n                    \
    \                                            if i == s.count {\n             \
    \                                                       \n                   \
    \                                                 i += 1\n                   \
    \                                                 \n                         \
    \                                           if i == s.count {\n              \
    \                                                          \n                \
    \                                                        i += 1\n            \
    \                                                            \n              \
    \                                                          if i == s.count {\n\
    \                                                                            \n\
    \                                                                            i\
    \ += 1\n                                                                     \
    \       \n                                                                   \
    \         if i == s.count {\n                                                \
    \                                \n                                          \
    \                                      i += 1\n                              \
    \                                                  \n                        \
    \                                                        if i == s.count {\n \
    \                                                                            \
    \       \n                                                                   \
    \                 i += 1\n                                                   \
    \                                 \n                                         \
    \                                           if i == s.count {\n              \
    \                                                                          \n\
    \                                                                            \
    \            i += 1\n                                                        \
    \                                \n                                          \
    \                                              if i == s.count {\n           \
    \                                                                            \
    \     \n                                                                     \
    \                       i += 1\n                                             \
    \                                               \n                           \
    \                                                                 if i == s.count\
    \ {\n                                                                        \
    \                        \n                                                  \
    \                                              i += 1\n                      \
    \                                                                          \n\
    \                                                                            \
    \                    if i == s.count {\n                                     \
    \                                                               \n           \
    \                                                                            \
    \             i += 1\n                                                       \
    \                                             \n                             \
    \                                                                       if i ==\
    \ s.count {\n                                                                \
    \                                        \n                                  \
    \                                                                      i += 1\n\
    \                                                                            \
    \                            \n                                              \
    \                                                          if i == s.count {\n\
    \                                                                            \
    \                                \n                                          \
    \                                                                  i += 1\n  \
    \                                                                            \
    \                              \n                                            \
    \                                                                if i == s.count\
    \ {\n                                                                        \
    \                                        \n                                  \
    \                                                                            \
    \  i += 1\n                                                                  \
    \                                              \n                            \
    \                                                                            \
    \        if i == s.count {\n                                                 \
    \                                                                   \n       \
    \                                                                            \
    \                                 i += 1\n                                   \
    \                                                                            \
    \     \n                                                                     \
    \                                               if i == s.count {\n          \
    \                                                                            \
    \                                  \n                                        \
    \                                                                            \
    \    i += 1\n                                                                \
    \                                                        \n                  \
    \                                                                            \
    \                          if i == s.count {\n                               \
    \                                                                            \
    \                 \n                                                         \
    \                                                                   i += 1\n \
    \                                                                            \
    \                                               \n                           \
    \                                                                            \
    \                     if i == s.count {\n                                    \
    \                                                                            \
    \                \n                                                          \
    \                                                                      i += 1\n\
    \                                                                \n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n:\
    \ 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3)\
    \ == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n:\
    \ 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"\
    world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s:\
    \ \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1)\
    \ == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpbt7t6jek.swift:168:69: error: expected '}' at end of brace statement\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])\n\
    \                                                                    ^\n/tmp/tmpbt7t6jek.swift:139:137:\
    \ note: to match this opening '{'\n                                          \
    \                                                                            \
    \  if i == s.count {\n                                                       \
    \                                                                            \
    \     ^\n/tmp/tmpbt7t6jek.swift:168:69: error: expected '}' at end of brace statement\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])\n\
    \                                                                    ^\n/tmp/tmpbt7t6jek.swift:135:133:\
    \ note: to match this opening '{'\n                                          \
    \                                                                          if\
    \ i == s.count {\n                                                           \
    \                                                                         ^\n\
    /tmp/tmpbt7t6jek.swift:168:69: error: expected '}' at end of brace statement\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])\n\
    \                                                                    ^\n/tmp/tmpbt7t6jek.swift:131:129:\
    \ note: to match this opening '{'\n                                          \
    \                                                                      if i ==\
    \ s.count {\n                                                                \
    \                                                                ^\n/tmp/tmpbt7t6jek.swift:168:69:\
    \ error: expected '}' at end of brace statement\nassert(select_words(s: \"a b\
    \ c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])\n                        \
    \                                            ^\n/tmp/tmpbt7t6jek.swift:127:125:\
    \ note: to match this opening '{'\n                                          \
    \                                                                  if i == s.count "
  stdout: ''
  timestamp: 1660014411
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"\
    ]\n/// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n\
    /// select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfunc\
    \ select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    if s == \"\" {\n        return result\n    }\n    var i = 0\n    var j =\
    \ 0\n    var k = 0\n    var l = s.count\n    for i < l {\n        if s[i] == \"\
    \ \" {\n            i += 1\n            continue\n        }\n        if s[i] ==\
    \ \"a\" {\n            i += 1\n            if j == n {\n                result.append(\"\
    a\")\n                i += 1\n                j = 0\n                k += 1\n\
    \                continue\n            }\n            if k == n {\n          \
    \      result.append(\"a\")\n                i += 1\n                j = 0\n \
    \               k += 1\n                continue\n            }\n            if\
    \ j == n {\n                result.append(\"a\")\n                i += 1\n   \
    \             j = 0\n                k += 1\n                continue\n      \
    \      }\n            if k == n {\n                result.append(\"a\")\n    \
    \            i += 1\n                j = 0\n                k += 1\n         \
    \       continue\n            }\n            if j == n {\n                result.append(\"\
    a\")\n                i += 1\n                j = 0\n                k += 1\n\
    \                continue\n            }\n            if k == n {\n          \
    \      result.append(\"a\")\n                i += 1\n                j = 0\n \
    \               k += 1\n                continue\n            }\n            if\
    \ j == n {\n                result.append(\"a\")\n                i += 1\n   \
    \             j = 0\n                k += 1\n                continue\n      \
    \      }\n            if k == n {\n                result.append(\"a\")\n    \
    \            i += 1\n                j = 0\n                k += 1\n         \
    \       continue\n            }\n            if j == n {\n                result.append(\"\
    a\")\n                i += 1\n                j = 0\n                k += 1\n\
    \                continue\n            }\n            if k == n {\n          \
    \      result.append(\"a\")\n                i += 1\n                j = 0\n \
    \               k += 1\n                continue\n            }\n            if\
    \ j == n {\n                result.append(\"a\")\n                i += 1\n   \
    \             j = 0\n                k += 1\n                continue\n      \
    \      }\n            if k == n {\n                result.append(\"a\")\n    \
    \            i += 1\n                j = 0\n                k += 1\n         \
    \       continue\n            }\n            if j == n {\n                result.append(\"\
    a\")\n                i += 1\n                j = 0\n                k += 1\n\
    \                continue\n            }\n            if k == n {\n          \
    \      result.append(\"a\")\n                i += 1\n                j = 0\n \
    \               k += 1\n                continue\n            }\n            if\
    \ j == n {\n                result.append(\"a\")\n                i += 1\n   \
    \             j = 0\n                k += 1\n                continue\n      \
    \      }\n            if k == n {\n                result.append(\"a\")\n    \
    \            i += 1\n                j = 0\n                k += 1\n         \
    \       continue\n            }\n            if j == n {\n                result.append(\"\
    a\")\n                i += 1\n                j = 0\n                k += 1\n\
    \                continue\n            }\n            if k == n {\n          \
    \      result.append(\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s:\
    \ \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"\
    Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpj5huusdz.swift:22:11: error: expected 'in' after for-each pattern\n\
    \    for i < l {\n          ^\n/tmp/tmpj5huusdz.swift:22:11: error: unary operator\
    \ cannot be separated from its operand\n    for i < l {\n          ^~\n      \
    \     \n/tmp/tmpj5huusdz.swift:149:31: error: unterminated string literal\n  \
    \              result.append(\"\n                              ^\n/tmp/tmpj5huusdz.swift:171:69:\
    \ error: expected '}' at end of brace statement\nassert(select_words(s: \"a b\
    \ c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])\n                        \
    \                                            ^\n/tmp/tmpj5huusdz.swift:27:24:\
    \ note: to match this opening '{'\n        if s[i] == \"a\" {\n              \
    \         ^\n/tmp/tmpj5huusdz.swift:171:69: error: expected '}' at end of brace\
    \ statement\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"\
    d\", \"f\"])\n                                                               \
    \     ^\n/tmp/tmpj5huusdz.swift:22:15: note: to match this opening '{'\n    for\
    \ i < l {\n              ^\n/tmp/tmpj5huusdz.swift:171:69: error: expected '}'\
    \ at end of brace statement\nassert(select_words(s: \"a b c d e f\", n: 1) ==\
    \ [\"b\", \"c\", \"d\", \"f\"])\n                                            \
    \                        ^\n/tmp/tmpj5huusdz.swift:13:50: note: to match this\
    \ opening '{'\nfunc select_words(s: String, n: Int) -> [String] {\n          \
    \                                       ^\n/tmp/tmpj5huusdz.swift:22:11: error:\
    \ '<' is not a prefix unary operator\n    for i < l {\n          ^\n"
  stdout: ''
  timestamp: 1660014410
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"\
    ]\n/// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n\
    /// select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfunc\
    \ select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    \n    if s == \"\" {\n        return result\n    }\n    \n    var i = 0\n\
    \    var j = 0\n    \n    for char in s {\n        if char == \" \" {\n      \
    \      if i == n {\n                result.append(\"\\n\")\n                j\
    \ = 0\n            }\n            \n            if j == n {\n                result.append(\"\
    \\n\")\n                j = 0\n            }\n            \n            if j ==\
    \ 0 {\n                result.append(\"\\n\")\n            }\n            \n \
    \           i = 0\n            j++\n        } else {\n            if i == n {\n\
    \                result.append(\"\\n\")\n                j = 0\n            }\n\
    \            \n            if j == n {\n                result.append(\"\\n\"\
    )\n                j = 0\n            }\n            \n            if j == 0 {\n\
    \                result.append(\"\\n\")\n            }\n            \n       \
    \     i += 1\n        }\n    }\n    \n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"\
    little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\"\
    , \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmp5biavw9i.swift:40:14: error: cannot find operator '++' in scope;\
    \ did you mean '+= 1'?\n            j++\n             ^~\n"
  stdout: ''
  timestamp: 1660014410
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"\
    ]\n/// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n\
    /// select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfunc\
    \ select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    \n    if s == \"\" {\n        return result\n    }\n    \n    var i = 0\n\
    \    var j = 0\n    var k = 0\n    \n    while i < s.count {\n        if s[i]\
    \ == \" \" {\n            j = i\n            \n            while j < s.count &&\
    \ s[j] != \" \" {\n                j += 1\n            }\n            \n     \
    \       if j == s.count {\n                result.append(\"_\")\n            }\
    \ else {\n                result.append(\"_\")\n                result.appendContentsOf(select_words(String(s.suffix(j)),\
    \ n))\n            }\n            \n            i = j\n        } else {\n    \
    \        k = i\n            \n            while k < s.count && s[k] != \" \" {\n\
    \                k += 1\n            }\n            \n            if k == s.count\
    \ {\n                result.append(\"_\")\n            } else {\n            \
    \    result.append(\"_\")\n                result.appendContentsOf(select_words(String(s.suffix(k)),\
    \ n))\n            }\n            \n            i = k\n        }\n    }\n    \n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"\
    Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary\
    \ had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpms2cvrmr.swift:25:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if s[i] ==\
    \ \" \" {\n           ^~~~\nSwift.String:3:12: note: 'subscript(_:)' has been\
    \ explicitly marked unavailable here\n    public subscript(i: Int) -> Character\
    \ { get }\n           ^\n/tmp/tmpms2cvrmr.swift:28:34: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \            while j < s.count && s[j] != \" \" {\n                          \
    \       ^~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly marked\
    \ unavailable here\n    public subscript(i: Int) -> Character { get }\n      \
    \     ^\n/tmp/tmpms2cvrmr.swift:36:24: error: value of type '[String]' has no\
    \ member 'appendContentsOf'\n                result.appendContentsOf(select_words(String(s.suffix(j)),\
    \ n))\n                ~~~~~~ ^~~~~~~~~~~~~~~~\n/tmp/tmpms2cvrmr.swift:36:53:\
    \ error: missing argument labels 's:n:' in call\n                result.appendContentsOf(select_words(String(s.suffix(j)),\
    \ n))\n                                                    ^\n               \
    \                                      s:                   n: \n/tmp/tmpms2cvrmr.swift:43:34:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n            while k < s.count && s[k] != \" \"\
    \ {\n                                 ^~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpms2cvrmr.swift:51:24: error: value\
    \ of type '[String]' has no member 'appendContentsOf'\n                result.appendContentsOf(select_words(String(s.suffix(k)),\
    \ n))\n                ~~~~~~ ^~~~~~~~~~~~~~~~\n/tmp/tmpms2cvrmr.swift:51:53:\
    \ error: missing argument labels 's:n:' in call\n                result.appendContentsOf(select_words(String(s.suffix(k)),\
    \ n))\n                                                    ^\n               \
    \                                      s:                "
  stdout: ''
  timestamp: 1660014410
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"\
    ]\n/// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n\
    /// select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfunc\
    \ select_words(s: String, n: Int) -> [String] {\n    return select_words_helper(s.characters,\
    \ s.characters.count, n, [])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s:\
    \ \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"\
    Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmp6ddqt2jm.swift:14:12: error: cannot find 'select_words_helper'\
    \ in scope\n    return select_words_helper(s.characters, s.characters.count, n,\
    \ [])\n           ^~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014410
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"\
    ]\n/// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n\
    /// select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfunc\
    \ select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    \n    if s == \"\" {\n        return result\n    }\n    \n    let vowels\
    \ = \"aeiouAEIOU\"\n    \n    for char in s {\n        if vowels.contains(char)\
    \ {\n            if result.count < n {\n                result.append(char)\n\
    \            }\n        }\n    }\n    \n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"\
    little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\"\
    , \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmprlrpjzh_.swift:25:31: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n                result.append(char)\n  \
    \                            ^\n"
  stdout: ''
  timestamp: 1660014410
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"\
    ]\n/// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n\
    /// select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfunc\
    \ select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    \n    if s == \"\" {\n        return result\n    }\n    \n    for char in\
    \ s.characters {\n        if char.unicodeScalars.count > n {\n            continue\n\
    \        }\n        \n        if char.unicodeScalars.count == n {\n          \
    \  result.append(String(char))\n        }\n    }\n    \n    return result\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n:\
    \ 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3)\
    \ == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n:\
    \ 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"\
    world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s:\
    \ \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1)\
    \ == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmp8pvk_q44.swift:20:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660014410
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"\
    ]\n/// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n\
    /// select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfunc\
    \ select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    \n    if s == \"\" {\n        return result\n    }\n    \n    var i = 0\n\
    \    var j = 0\n    var k = 0\n    \n    while i < s.count {\n        if s[i]\
    \ == \" \" {\n            j = i\n            while j < s.count && s[j] != \" \"\
    \ {\n                j += 1\n            }\n            \n            if j ==\
    \ s.count {\n                result.append(\"\\n\")\n                i = j\n \
    \               continue\n            }\n            \n            k = j + 1\n\
    \            while k < s.count && s[k] != \" \" {\n                k += 1\n  \
    \          }\n            \n            if k == s.count {\n                result.append(\"\
    \\n\")\n                i = k\n                continue\n            }\n     \
    \       \n            if j > k {\n                result.append(\"\\n\")\n   \
    \             i = j\n                continue\n            }\n            \n \
    \           if j == k {\n                result.append(\"\\n\")\n            \
    \    i = j\n                continue\n            }\n            \n          \
    \  i = k\n            continue\n        }\n        \n        if s[i] == \"\\n\"\
    \ {\n            i = i + 1\n            continue\n        }\n        \n      \
    \  if s[i] == \" \" {\n            i = i + 1\n            continue\n        }\n\
    \        \n        if s[i] == \" \" {\n            i = i + 1\n            continue\n\
    \        }\n        \n        if s[i] == \" \" {\n            i = i + 1\n    \
    \        continue\n        }\n        \n        if s[i] == \" \" {\n         \
    \   i = i + 1\n            continue\n        }\n        \n        if s[i] == \"\
    \ \" {\n            i = i + 1\n            continue\n        }\n        \n   \
    \     if s[i] == \" \" {\n            i = i + 1\n            continue\n      \
    \  }\n        \n        if s[i] == \" \" {\n            i = i + 1\n          \
    \  continue\n        }\n        \n        if s[i] == \" \" {\n            i =\
    \ i + 1\n            continue\n        }\n        \n        if s[i] == \" \" {\n\
    \            i = i + 1\n            continue\n        }\n        \n        if\
    \ s[i] == \" \" {\n            i = i + 1\n            continue\n        }\n  \
    \      \n        if s[i] == \" \" {\n            i = i + 1\n            continue\n\
    \        }\n        \n        if s[i] == \" \" {\n            i = i + 1\n    \
    \        continue\n        }\n        \n        if s[i] == \" \" {\n         \
    \   i = i + 1\n            continue\n        }\n        \n        if s[i] == \"\
    \ \" {\n            i = i + 1\n            continue\n        }\n        \n   \
    \     if s[i] == \" \" {\n            i = i + 1\n            continue\n      \
    \  }\n        \n        if s[i] == \" \" {\n            i = i + 1\n          \
    \  continue\n        }\n        \n        if s[i] == \" \" {\n            i =\
    \ i + 1\n            continue\n        }\n        \n        if s[i] == \" \" {\n\
    \            i = i + 1\n            continue\n        }\n        \n\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n:\
    \ 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3)\
    \ == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n:\
    \ 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"\
    world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s:\
    \ \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1)\
    \ == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmp6a4sgtvz.swift:181:69: error: expected '}' at end of brace statement\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])\n\
    \                                                                    ^\n/tmp/tmp6a4sgtvz.swift:13:50:\
    \ note: to match this opening '{'\nfunc select_words(s: String, n: Int) -> [String]\
    \ {\n                                                 ^\n/tmp/tmp6a4sgtvz.swift:25:12:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if s[i] == \" \" {\n           ^~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmp6a4sgtvz.swift:27:34:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n            while j < s.count && s[j] != \" \"\
    \ {\n                                 ^~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmp6a4sgtvz.swift:38:34: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \            while k < s.count && s[k] != \" \" {\n                          \
    \       ^~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly marked\
    \ unavailable here\n    public subscript(i: Int) -> Character { get }\n      \
    \     ^\n/tmp/tmp6a4sgtvz.swift:64:12: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n        if\
    \ s[i] == \"\\n\" {\n           ^~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmp6a4sgtvz.swift:69:12: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if s[i] == \" \" {\n           ^~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int"
  stdout: ''
  timestamp: 1660014411
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"\
    ]\n/// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n\
    /// select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfunc\
    \ select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    \n    if s == \"\" {\n        return result\n    }\n    \n    let vowels\
    \ = \"aeiou\"\n    \n    for char in s.characters {\n        if vowels.contains(String(char))\
    \ {\n            if result.count < n {\n                result.append(String(char))\n\
    \            }\n        }\n    }\n    \n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"\
    little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\"\
    , \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmp5hhi0fsc.swift:22:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660014410
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"\
    ]\n/// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n\
    /// select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfunc\
    \ select_words(s: String, n: Int) -> [String] {\n    var words: [String] = []\n\
    \    var index = 0\n    var lastIndex = s.characters.count - 1\n    var currentWord\
    \ = \"\"\n    \n    while index < lastIndex {\n        if s[index] == \" \" {\n\
    \            if currentWord != \"\" {\n                words.append(currentWord)\n\
    \                currentWord = \"\"\n            }\n        } else {\n       \
    \     if currentWord == \"\" {\n                currentWord = String(s[index])\n\
    \            } else {\n                currentWord += String(s[index])\n     \
    \       }\n        }\n        index += 1\n    }\n    \n    if currentWord != \"\
    \" {\n        words.append(currentWord)\n    }\n    \n    return words\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n:\
    \ 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3)\
    \ == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n:\
    \ 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"\
    world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s:\
    \ \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1)\
    \ == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpi5n84_op.swift:16:23: error: 'characters' is unavailable: Please\
    \ use String directly\n    var lastIndex = s.characters.count - 1\n          \
    \            ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in\
    \ Swift 5.0\n    public var characters: String { get set }\n               ^\n\
    /tmp/tmpi5n84_op.swift:20:12: error: 'subscript(_:)' is unavailable: cannot subscript\
    \ String with an Int, use a String.Index instead.\n        if s[index] == \" \"\
    \ {\n           ^~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly\
    \ marked unavailable here\n    public subscript(i: Int) -> Character { get }\n\
    \           ^\n/tmp/tmpi5n84_op.swift:27:38: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n         \
    \       currentWord = String(s[index])\n                                     ^~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpi5n84_op.swift:29:39:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n                currentWord += String(s[index])\n\
    \                                      ^~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpi5n84_op.swift:16:9: warning: variable\
    \ 'lastIndex' was never mutated; consider changing to 'let' constant\n    var\
    \ lastIndex = s.characters.count - 1\n    ~~~ ^\n    let\n"
  stdout: ''
  timestamp: 1660014411
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"\
    ]\n/// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n\
    /// select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfunc\
    \ select_words(s: String, n: Int) -> [String] {\n    var words = [String]()\n\
    \    var i = 0\n    var j = 0\n    var k = 0\n    var count = 0\n    var lastChar\
    \ = \" \"\n    var lastCharCount = 0\n    var lastWord = \"\"\n    var lastWordCount\
    \ = 0\n    var lastWordLength = 0\n    var lastWordStart = 0\n    var lastWordEnd\
    \ = 0\n    var lastWordChar = \"\"\n    var lastWordCharCount = 0\n    var lastWordCharLength\
    \ = 0\n    var lastWordCharStart = 0\n    var lastWordCharEnd = 0\n    var lastWordCharBefore\
    \ = \"\"\n    var lastWordCharBeforeCount = 0\n    var lastWordCharBeforeLength\
    \ = 0\n    var lastWordCharBeforeStart = 0\n    var lastWordCharBeforeEnd = 0\n\
    \    var lastWordCharAfter = \"\"\n    var lastWordCharAfterCount = 0\n    var\
    \ lastWordCharAfterLength = 0\n    var lastWordCharAfterStart = 0\n    var lastWordCharAfterEnd\
    \ = 0\n    var lastWordCharBeforeAfter = \"\"\n    var lastWordCharBeforeAfterCount\
    \ = 0\n    var lastWordCharBeforeAfterLength = 0\n    var lastWordCharBeforeAfterStart\
    \ = 0\n    var lastWordCharBeforeAfterEnd = 0\n    var lastWordCharBeforeAfterChar\
    \ = \"\"\n    var lastWordCharBeforeAfterCharCount = 0\n    var lastWordCharBeforeAfterCharLength\
    \ = 0\n    var lastWordCharBeforeAfterCharStart = 0\n    var lastWordCharBeforeAfterCharEnd\
    \ = 0\n    var lastWordCharBeforeAfterCharBefore = \"\"\n    var lastWordCharBeforeAfterCharBeforeCount\
    \ = 0\n    var lastWordCharBeforeAfterCharBeforeLength = 0\n    var lastWordCharBeforeAfterCharBeforeStart\
    \ = 0\n    var lastWordCharBeforeAfterCharBeforeEnd = 0\n    var lastWordCharBeforeAfterCharAfter\
    \ = \"\"\n    var lastWordCharBeforeAfterCharAfterCount = 0\n    var lastWordCharBeforeAfterCharAfterLength\
    \ = 0\n    var lastWordCharBeforeAfterCharAfterStart = 0\n    var lastWordCharBeforeAfterCharAfterEnd\
    \ = 0\n    var lastWordCharBeforeAfterCharBeforeAfter = \"\"\n    var lastWordCharBeforeAfterCharBeforeAfterCount\
    \ = 0\n    var lastWordCharBeforeAfterCharBeforeAfterLength = 0\n    var lastWordCharBeforeAfterCharBeforeAfterStart\
    \ = 0\n    var lastWordCharBeforeAfterCharBeforeAfterEnd = 0\n    var lastWordCharBeforeAfterCharBeforeAfterChar\
    \ = \"\"\n    var lastWordCharBeforeAfterCharBeforeAfterCharCount = 0\n    var\
    \ lastWordCharBeforeAfterCharBeforeAfterCharLength = 0\n    var lastWordCharBeforeAfterCharBeforeAfterCharStart\
    \ = 0\n    var lastWordCharBeforeAfterCharBeforeAfterCharEnd = 0\n    var lastWordCharBeforeAfterCharBeforeAfterCharBefore\
    \ = \"\"\n    var \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"\
    Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary\
    \ had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpovbgr4hm.swift:72:8: error: expected pattern\n    var \n      \
    \ ^\n/tmp/tmpovbgr4hm.swift:14:9: warning: initialization of variable 'words'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var words = [String]()\n    ~~~~^~~~~\n    _\n/tmp/tmpovbgr4hm.swift:15:9:\
    \ warning: initialization of variable 'i' was never used; consider replacing with\
    \ assignment to '_' or removing it\n    var i = 0\n    ~~~~^\n    _\n/tmp/tmpovbgr4hm.swift:16:9:\
    \ warning: initialization of variable 'j' was never used; consider replacing with\
    \ assignment to '_' or removing it\n    var j = 0\n    ~~~~^\n    _\n/tmp/tmpovbgr4hm.swift:17:9:\
    \ warning: initialization of variable 'k' was never used; consider replacing with\
    \ assignment to '_' or removing it\n    var k = 0\n    ~~~~^\n    _\n/tmp/tmpovbgr4hm.swift:18:9:\
    \ warning: initialization of variable 'count' was never used; consider replacing\
    \ with assignment to '_' or removing it\n    var count = 0\n    ~~~~^~~~~\n  \
    \  _\n/tmp/tmpovbgr4hm.swift:19:9: warning: initialization of variable 'lastChar'\
    \ was never used; consider replacing with assignment to '_' or removing it\n \
    \   var lastChar = \" \"\n    ~~~~^~~~~~~~\n    _\n/tmp/tmpovbgr4hm.swift:20:9:\
    \ warning: initialization of variable 'lastCharCount' was never used; consider\
    \ replacing with assignment to '_' or removing it\n    var lastCharCount = 0\n\
    \    ~~~~^~~~~~~~~~~~~\n    _\n/tmp/tmpovbgr4hm.swift:21:9: warning: initialization\
    \ of variable 'lastWord' was never used; consider replacing with assignment to\
    \ '_' or removing it\n    var lastWord = \"\"\n    ~~~~^~~~~~~~\n    _\n/tmp/tmpovbgr4hm.swift:22:9:\
    \ warning: initialization of variable 'lastWordCount' was never used; consider\
    \ replacing with assignment to '_' or removing it\n    var lastWordCount = 0\n\
    \    ~~~~^~~~~~~~~~~~~\n    _\n/tmp/tmpovbgr4hm.swift:23:9: warning: initialization\
    \ of variable 'lastWordLength' was never used; consider replacing with assignment\
    \ to '_' or removing it\n    var lastWordLength = 0\n    ~~~~^~~~~~~~~~~~~~\n\
    \    _\n/tmp/tmpovbgr4hm.swift:24:9: warning: initialization of variable 'la"
  stdout: ''
  timestamp: 1660014411
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"\
    ]\n/// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n\
    /// select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfunc\
    \ select_words(s: String, n: Int) -> [String] {\n    var words = [String]()\n\
    \    \n    if s == \"\" {\n        return words\n    }\n    \n    var i = 0\n\
    \    var j = 0\n    var k = 0\n    \n    for i < s.count {\n        if s[i] ==\
    \ \" \" {\n            j = i\n            \n            while j < s.count && s[j]\
    \ == \" \" {\n                j += 1\n            }\n            \n          \
    \  k = j\n            \n            while k < s.count && s[k] != \" \" {\n   \
    \             k += 1\n            }\n            \n            if k == j {\n \
    \               words.append(String(s[i:j]))\n                i = j + 1\n    \
    \        }\n        }\n        \n        if s[i] == \"a\" || s[i] == \"e\" ||\
    \ s[i] == \"i\" || s[i] == \"o\" || s[i] == \"u\" {\n            j = i\n     \
    \       \n            while j < s.count && s[j] != \"a\" && s[j] != \"e\" && s[j]\
    \ != \"i\" && s[j] != \"o\" && s[j] != \"u\" {\n                j += 1\n     \
    \       }\n            \n            k = j\n            \n            while k\
    \ < s.count && s[k] != \"a\" && s[k] != \"e\" && s[k] != \"i\" && s[k] != \"o\"\
    \ && s[k] != \"u\" {\n                k += 1\n            }\n            \n  \
    \          if k == j {\n                words.append(String(s[i:j]))\n       \
    \         i = j + 1\n            }\n        }\n        \n        if s[i] == \"\
    y\" || s[i] == \"a\" || s[i] == \"e\" || s[i] == \"i\" || s[i] == \"o\" || s[i]\
    \ == \"u\" {\n            j = i\n            \n            while j < s.count &&\
    \ s[j] != \"y\" && s[j] != \"a\" && s[j] != \"e\" && s[j] != \"i\" && s[j] !=\
    \ \"o\" && s[j] != \"u\" {\n                j += 1\n            }\n          \
    \  \n            k = j\n            \n            while k < s.count && s[k] !=\
    \ \"y\" && s[k] != \"a\" && s[k] != \"e\" && s[k] != \"i\" && s[k] != \"o\" &&\
    \ s[k] != \"u\" {\n                k += 1\n            }\n            \n     \
    \       if k == j {\n                words.append(String(s[i:j]))\n          \
    \      i = j + 1\n            }\n        }\n        \n        if s[i] == \"o\"\
    \ || s[i] == \"u\" || s[i] == \"a\" || s[i] == \"e\" || s[i] == \"i\" || s[i]\
    \ == \"y\" {\n            j = i\n            \n            while j < s.count &&\
    \ s[j] != \"o\" && s[j] != \"u\" && s[j] != \"a\" && s[j] != \"e\" && s[j] !=\
    \ \"i\" && s[j] != \"y\" {\n                j += 1\n            }\n          \
    \  \n            k = j\n            \n            while k < s.count && s[k] !=\
    \ \"o\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary\
    \ had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had\
    \ a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple\
    \ white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\"\
    , n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"\
    ])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s:\
    \ \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpw3e8ywme.swift:24:11: error: expected 'in' after for-each pattern\n\
    \    for i < s.count {\n          ^\n/tmp/tmpw3e8ywme.swift:24:11: error: unary\
    \ operator cannot be separated from its operand\n    for i < s.count {\n     \
    \     ^~\n           \n/tmp/tmpw3e8ywme.swift:91:42: error: unterminated string\
    \ literal\n            while k < s.count && s[k] != \"o\n                    \
    \                     ^\n/tmp/tmpw3e8ywme.swift:113:69: error: expected '}' at\
    \ end of brace statement\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"\
    b\", \"c\", \"d\", \"f\"])\n                                                 \
    \                   ^\n/tmp/tmpw3e8ywme.swift:24:21: note: to match this opening\
    \ '{'\n    for i < s.count {\n                    ^\n/tmp/tmpw3e8ywme.swift:113:69:\
    \ error: expected '}' at end of brace statement\nassert(select_words(s: \"a b\
    \ c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])\n                        \
    \                                            ^\n/tmp/tmpw3e8ywme.swift:13:50:\
    \ note: to match this opening '{'\nfunc select_words(s: String, n: Int) -> [String]\
    \ {\n                                                 ^\n/tmp/tmpw3e8ywme.swift:24:11:\
    \ error: '<' is not a prefix unary operator\n    for i < s.count {\n         \
    \ ^\n"
  stdout: ''
  timestamp: 1660014411
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"\
    ]\n/// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n\
    /// select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfunc\
    \ select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    \n    if s == \"\" {\n        return result\n    }\n    \n    let vowels\
    \ = \"aeiou\"\n    \n    for char in s.characters {\n        if vowels.contains(char)\
    \ {\n            if n == 1 {\n                result.append(String(char))\n  \
    \          } else {\n                let index = vowels.firstIndex(of: char)\n\
    \                \n                if index != nil {\n                    result.append(String(char))\n\
    \                    \n                    let subString = String(s[index.advanced(by:\
    \ 1)])\n                    \n                    if subString.characters.count\
    \ == n {\n                        result.append(subString)\n                 \
    \   }\n                }\n            }\n        }\n    }\n    \n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n:\
    \ 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3)\
    \ == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n:\
    \ 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"\
    world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s:\
    \ \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1)\
    \ == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmph2nec2jh.swift:22:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmph2nec2jh.swift:32:52:\
    \ error: value of type 'String.Index?' has no member 'advanced'\n            \
    \        let subString = String(s[index.advanced(by: 1)])\n                  \
    \                           ~~~~~ ^~~~~~~~\n"
  stdout: ''
  timestamp: 1660014411
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"\
    ]\n/// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n\
    /// select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfunc\
    \ select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    \n    if s == \"\" {\n        return result\n    }\n    \n    let vowels\
    \ = \"aeiou\"\n    \n    for letter in s.characters {\n        if letter in vowels\
    \ {\n            if result.count < n {\n                result.append(String(letter))\n\
    \            }\n        }\n    }\n    \n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"\
    little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\"\
    , \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpg4kl3fha.swift:23:19: error: expected '{' after 'if' condition\n\
    \        if letter in vowels {\n                  ^\n/tmp/tmpg4kl3fha.swift:22:21:\
    \ error: 'characters' is unavailable: Please use String directly\n    for letter\
    \ in s.characters {\n                    ^~~~~~~~~~\nSwift.String:5:16: note:\
    \ 'characters' was obsoleted in Swift 5.0\n    public var characters: String {\
    \ get set }\n               ^\n/tmp/tmpg4kl3fha.swift:23:12: error: cannot convert\
    \ value of type 'Character' to expected condition type 'Bool'\n        if letter\
    \ in vowels {\n           ^~~~~~\n"
  stdout: ''
  timestamp: 1660014411
- exit_code: -4
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"\
    ]\n/// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n\
    /// select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfunc\
    \ select_words(s: String, n: Int) -> [String] {\n    \n    // Your code here\n\
    \    \n    return []\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s:\
    \ \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"\
    Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: Exception
  stderr: 'tmpa4traokp/tmpa4traokp.swift:33: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1684f48c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b1684c3fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b1684c3f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b1684c3e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpa4traokp                        0x000055d84e2e34c4 <unavailable> + 5316

    5    libc.so.6                          0x00002b1685134460 __libc_start_main +
    245

    6    tmpa4traokp                        0x000055d84e2e30c9 <unavailable> + 4297

    '
  stdout: ''
  timestamp: 1660014411
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"\
    ]\n/// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n\
    /// select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfunc\
    \ select_words(s: String, n: Int) -> [String] {\n    var words = [String]()\n\
    \    \n    if s == \"\" {\n        return words\n    }\n    \n    var i = 0\n\
    \    var j = 0\n    \n    while i < s.count {\n        if s[i] == \" \" {\n  \
    \          j = i\n            while j < s.count && s[j] == \" \" {\n         \
    \       j += 1\n            }\n            \n            if j == s.count {\n \
    \               words.append(String(s[i:j]))\n                i = j\n        \
    \    } else {\n                words.append(String(s[i:j]))\n                i\
    \ = j + 1\n            }\n        } else {\n            i += 1\n        }\n  \
    \  }\n    \n    if n == 1 {\n        return words\n    }\n    \n    var count\
    \ = 0\n    \n    for word in words {\n        if word.characters.count >= n {\n\
    \            count += 1\n        }\n    }\n    \n    return words.filter({$0.characters.count\
    \ == count})\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"\
    Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary\
    \ had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmp_bvd8we7.swift:24:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if s[i] ==\
    \ \" \" {\n           ^~~~\nSwift.String:3:12: note: 'subscript(_:)' has been\
    \ explicitly marked unavailable here\n    public subscript(i: Int) -> Character\
    \ { get }\n           ^\n/tmp/tmp_bvd8we7.swift:26:34: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \            while j < s.count && s[j] == \" \" {\n                          \
    \       ^~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly marked\
    \ unavailable here\n    public subscript(i: Int) -> Character { get }\n      \
    \     ^\n/tmp/tmp_bvd8we7.swift:31:38: error: extraneous argument label 'i:' in\
    \ subscript\n                words.append(String(s[i:j]))\n                  \
    \                   ^~~\n                                      \n/tmp/tmp_bvd8we7.swift:34:38:\
    \ error: extraneous argument label 'i:' in subscript\n                words.append(String(s[i:j]))\n\
    \                                     ^~~\n                                  \
    \    \n/tmp/tmp_bvd8we7.swift:49:17: error: 'characters' is unavailable: Please\
    \ use String directly\n        if word.characters.count >= n {\n             \
    \   ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n\
    \    public var characters: String { get set }\n               ^\n/tmp/tmp_bvd8we7.swift:54:29:\
    \ error: 'characters' is unavailable: Please use String directly\n    return words.filter({$0.characters.count\
    \ == count})\n                            ^~~~~~~~~~\nSwift.String:5:16: note:\
    \ 'characters' was obsoleted in Swift 5.0\n    public var characters: String {\
    \ get set }\n               ^\n"
  stdout: ''
  timestamp: 1660014411
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"\
    ]\n/// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n\
    /// select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfunc\
    \ select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    \n    if s == \"\" {\n        return result\n    }\n    \n    for c in s.characters\
    \ {\n        if c.isConsonant() {\n            if n == 1 {\n                result.append(s)\n\
    \            }\n            else {\n                result.append(s.substringToIndex(s.startIndex.advancedBy(c.isConsonantIndex)))\n\
    \            }\n            \n            n -= 1\n        }\n    }\n    \n   \
    \ return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"\
    Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary\
    \ had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpi2xojxxi.swift:20:16: error: 'characters' is unavailable: Please\
    \ use String directly\n    for c in s.characters {\n               ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpi2xojxxi.swift:21:14:\
    \ error: value of type 'Character' has no member 'isConsonant'\n        if c.isConsonant()\
    \ {\n           ~ ^~~~~~~~~~~\n/tmp/tmpi2xojxxi.swift:26:33: error: value of type\
    \ 'String' has no member 'substringToIndex'\n                result.append(s.substringToIndex(s.startIndex.advancedBy(c.isConsonantIndex)))\n\
    \                              ~ ^~~~~~~~~~~~~~~~\n/tmp/tmpi2xojxxi.swift:26:63:\
    \ error: value of type 'String.Index' has no member 'advancedBy'\n           \
    \     result.append(s.substringToIndex(s.startIndex.advancedBy(c.isConsonantIndex)))\n\
    \                                                 ~~~~~~~~~~~~ ^~~~~~~~~~\n/tmp/tmpi2xojxxi.swift:26:76:\
    \ error: value of type 'Character' has no member 'isConsonantIndex'\n        \
    \        result.append(s.substringToIndex(s.startIndex.advancedBy(c.isConsonantIndex)))\n\
    \                                                                         ~ ^~~~~~~~~~~~~~~~\n\
    /tmp/tmpi2xojxxi.swift:29:15: error: left side of mutating operator isn't mutable:\
    \ 'n' is a 'let' constant\n            n -= 1\n            ~ ^\n"
  stdout: ''
  timestamp: 1660014411
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"\
    ]\n/// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n\
    /// select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfunc\
    \ select_words(s: String, n: Int) -> [String] {\n    return s.split(\" \").filter{\
    \ $0.contains(String(repeating: \"a\", count: n)) }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"\
    little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\"\
    , \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpcnrim_h7.swift:14:14: error: no exact matches in call to instance\
    \ method 'split'\n    return s.split(\" \").filter{ $0.contains(String(repeating:\
    \ \"a\", count: n)) }\n             ^\n/tmp/tmpcnrim_h7.swift:14:14: note: found\
    \ candidate with type '(String.Element, Int, Bool) -> [ArraySlice<String.Element>]'\
    \ (aka '(Character, Int, Bool) -> Array<ArraySlice<Character>>')\n    return s.split(\"\
    \ \").filter{ $0.contains(String(repeating: \"a\", count: n)) }\n            \
    \ ^\n/tmp/tmpcnrim_h7.swift:14:14: note: found candidate with type '(String.Element,\
    \ Int, Bool) -> [String.SubSequence]' (aka '(Character, Int, Bool) -> Array<Substring>')\n\
    \    return s.split(\" \").filter{ $0.contains(String(repeating: \"a\", count:\
    \ n)) }\n             ^\n"
  stdout: ''
  timestamp: 1660014411
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"\
    ]\n/// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n\
    /// select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfunc\
    \ select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    \n    if s == \"\" {\n        return result\n    }\n    \n    for c in s\
    \ {\n        if c.isLetter() {\n            if c.isUppercase() {\n           \
    \     if n == 1 {\n                    result.append(c.lowercaseString)\n    \
    \            }\n                \n                if n > 1 {\n               \
    \     result.append(c.lowercaseString)\n                }\n            }\n   \
    \         \n            if c.isLowercase() {\n                if n == 1 {\n  \
    \                  result.append(c.uppercaseString)\n                }\n     \
    \           \n                if n > 1 {\n                    result.append(c.uppercaseString)\n\
    \                }\n            }\n        }\n    }\n    \n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n:\
    \ 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3)\
    \ == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n:\
    \ 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"\
    world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s:\
    \ \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1)\
    \ == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpdv14txzf.swift:21:14: error: cannot call value of non-function\
    \ type 'Bool'\n        if c.isLetter() {\n             ^       ~~\n          \
    \           \n/tmp/tmpdv14txzf.swift:22:18: error: cannot call value of non-function\
    \ type 'Bool'\n            if c.isUppercase() {\n                 ^          ~~\n\
    \                            \n/tmp/tmpdv14txzf.swift:24:37: error: value of type\
    \ 'Character' has no member 'lowercaseString'\n                    result.append(c.lowercaseString)\n\
    \                                  ~ ^~~~~~~~~~~~~~~\n/tmp/tmpdv14txzf.swift:28:37:\
    \ error: value of type 'Character' has no member 'lowercaseString'\n         \
    \           result.append(c.lowercaseString)\n                               \
    \   ~ ^~~~~~~~~~~~~~~\n/tmp/tmpdv14txzf.swift:32:18: error: cannot call value\
    \ of non-function type 'Bool'\n            if c.isLowercase() {\n            \
    \     ^          ~~\n                            \n/tmp/tmpdv14txzf.swift:34:37:\
    \ error: value of type 'Character' has no member 'uppercaseString'\n         \
    \           result.append(c.uppercaseString)\n                               \
    \   ~ ^~~~~~~~~~~~~~~\n/tmp/tmpdv14txzf.swift:38:37: error: value of type 'Character'\
    \ has no member 'uppercaseString'\n                    result.append(c.uppercaseString)\n\
    \                                  ~ ^~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014411
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"\
    ]\n/// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n\
    /// select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfunc\
    \ select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    \n    if s == \"\" {\n        return result\n    }\n    \n    var i = 0\n\
    \    var j = 0\n    var k = 0\n    \n    for i < s.count {\n        if s[i] ==\
    \ \" \" {\n            j = i\n            \n            for k < s.count {\n  \
    \              if s[k] == \" \" {\n                    k = k + 1\n           \
    \     } else {\n                    break\n                }\n            }\n\
    \            \n            if k == s.count {\n                result.insert(i,\
    \ s.substringWithRange(i..<j))\n                i = j + 1\n            }\n   \
    \     }\n    }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s:\
    \ \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpzcyiur51.swift:24:11: error: expected 'in' after for-each pattern\n\
    \    for i < s.count {\n          ^\n/tmp/tmpzcyiur51.swift:24:11: error: unary\
    \ operator cannot be separated from its operand\n    for i < s.count {\n     \
    \     ^~\n           \n/tmp/tmpzcyiur51.swift:28:19: error: expected 'in' after\
    \ for-each pattern\n            for k < s.count {\n                  ^\n/tmp/tmpzcyiur51.swift:28:19:\
    \ error: unary operator cannot be separated from its operand\n            for\
    \ k < s.count {\n                  ^~\n                   \n/tmp/tmpzcyiur51.swift:24:11:\
    \ error: '<' is not a prefix unary operator\n    for i < s.count {\n         \
    \ ^\n/tmp/tmpzcyiur51.swift:28:19: error: '<' is not a prefix unary operator\n\
    \            for k < s.count {\n                  ^\n"
  stdout: ''
  timestamp: 1660014411
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"\
    ]\n/// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n\
    /// select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfunc\
    \ select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    \n    if s == \"\" {\n        return result\n    }\n    \n    var i = 0\n\
    \    var j = 0\n    \n    while i < s.count {\n        if s[i] == \" \" {\n  \
    \          i += 1\n            continue\n        }\n        \n        if j ==\
    \ n {\n            result.append(String(s[i..<s.endIndex]))\n            i = s.endIndex\n\
    \        } else {\n            j += 1\n        }\n    }\n    \n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n:\
    \ 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3)\
    \ == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n:\
    \ 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"\
    world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s:\
    \ \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1)\
    \ == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpcd0xcwvu.swift:24:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if s[i] ==\
    \ \" \" {\n           ^~~~\nSwift.String:3:12: note: 'subscript(_:)' has been\
    \ explicitly marked unavailable here\n    public subscript(i: Int) -> Character\
    \ { get }\n           ^\n/tmp/tmpcd0xcwvu.swift:30:36: error: cannot convert value\
    \ of type 'Int' to expected argument type 'String.Index'\n            result.append(String(s[i..<s.endIndex]))\n\
    \                                   ^\n/tmp/tmpcd0xcwvu.swift:31:19: error: cannot\
    \ assign value of type 'String.Index' to type 'Int'\n            i = s.endIndex\n\
    \                ~~^~~~~~~~\n"
  stdout: ''
  timestamp: 1660014411
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"\
    ]\n/// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n\
    /// select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfunc\
    \ select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    \n    if s == \"\" {\n        return result\n    }\n    \n    for char in\
    \ s.characters {\n        if char.unicodeScalars.filter({ $0.isConsonant() }).count\
    \ == n {\n            result.append(String(char))\n        }\n    }\n    \n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"\
    Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary\
    \ had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpzjzed04n.swift:20:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpzjzed04n.swift:21:44:\
    \ error: value of type 'Unicode.Scalar' has no member 'isConsonant'\n        if\
    \ char.unicodeScalars.filter({ $0.isConsonant() }).count == n {\n            \
    \                            ~~ ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014410
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"\
    ]\n/// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n\
    /// select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfunc\
    \ select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    \n    if s == \"\" {\n        return result\n    }\n    \n    var i = 0\n\
    \    var j = 0\n    var k = 0\n    \n    for i < s.count {\n        if s[i] ==\
    \ \" \" {\n            j = i\n            \n            for k < s.count {\n  \
    \              if s[k] == \" \" {\n                    k = k + 1\n           \
    \     } else {\n                    break\n                }\n            }\n\
    \            \n            if j == k {\n                result.append(\"\\n\"\
    )\n            }\n            \n            for k < s.count {\n              \
    \  if s[k] != \" \" {\n                    break\n                }\n        \
    \        k = k + 1\n            }\n            \n            if k == s.count {\n\
    \                result.append(String(s[i:j]))\n            }\n            i =\
    \ j + 1\n        } else {\n            i = i + 1\n        }\n    }\n    \n   \
    \ return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"\
    Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary\
    \ had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpr_z7wig2.swift:24:11: error: expected 'in' after for-each pattern\n\
    \    for i < s.count {\n          ^\n/tmp/tmpr_z7wig2.swift:24:11: error: unary\
    \ operator cannot be separated from its operand\n    for i < s.count {\n     \
    \     ^~\n           \n/tmp/tmpr_z7wig2.swift:28:19: error: expected 'in' after\
    \ for-each pattern\n            for k < s.count {\n                  ^\n/tmp/tmpr_z7wig2.swift:28:19:\
    \ error: unary operator cannot be separated from its operand\n            for\
    \ k < s.count {\n                  ^~\n                   \n/tmp/tmpr_z7wig2.swift:40:19:\
    \ error: expected 'in' after for-each pattern\n            for k < s.count {\n\
    \                  ^\n/tmp/tmpr_z7wig2.swift:40:19: error: unary operator cannot\
    \ be separated from its operand\n            for k < s.count {\n             \
    \     ^~\n                   \n/tmp/tmpr_z7wig2.swift:24:11: error: '<' is not\
    \ a prefix unary operator\n    for i < s.count {\n          ^\n/tmp/tmpr_z7wig2.swift:28:19:\
    \ error: '<' is not a prefix unary operator\n            for k < s.count {\n \
    \                 ^\n/tmp/tmpr_z7wig2.swift:40:19: error: '<' is not a prefix\
    \ unary operator\n            for k < s.count {\n                  ^\n"
  stdout: ''
  timestamp: 1660014411
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"\
    ]\n/// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n\
    /// select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfunc\
    \ select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    for char in s.characters {\n        if char.unicodeScalars.filter({ $0.isConsonant()\
    \ }).count == n {\n            result.append(String(char))\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"\
    Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary\
    \ had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmphdl4x47g.swift:15:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmphdl4x47g.swift:16:44:\
    \ error: value of type 'Unicode.Scalar' has no member 'isConsonant'\n        if\
    \ char.unicodeScalars.filter({ $0.isConsonant() }).count == n {\n            \
    \                            ~~ ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014411
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"\
    ]\n/// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n\
    /// select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfunc\
    \ select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    \n    if s == \"\" {\n        return result\n    }\n    \n    for char in\
    \ s.characters {\n        if char == \" \" {\n            continue\n        }\n\
    \        \n        if char.unicodeScalars.filter({ $0.isConsonant() }).count ==\
    \ n {\n            result.append(String(char))\n        }\n    }\n    \n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary\
    \ had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had\
    \ a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple\
    \ white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\"\
    , n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"\
    ])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s:\
    \ \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpx4e3d80w.swift:20:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpx4e3d80w.swift:25:44:\
    \ error: value of type 'Unicode.Scalar' has no member 'isConsonant'\n        if\
    \ char.unicodeScalars.filter({ $0.isConsonant() }).count == n {\n            \
    \                            ~~ ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014410
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"\
    ]\n/// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n\
    /// select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfunc\
    \ select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    \n    if s == \"\" {\n        return result\n    }\n    \n    let vowels\
    \ = \"aeiou\"\n    \n    for letter in s.characters {\n        if letter in vowels\
    \ {\n            continue\n        }\n        \n        if s.characters.filter({\
    \ $0 == letter }).count == n {\n            result.append(String(letter))\n  \
    \      }\n    }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s:\
    \ \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmp3_cgauhp.swift:23:19: error: expected '{' after 'if' condition\n\
    \        if letter in vowels {\n                  ^\n/tmp/tmp3_cgauhp.swift:22:21:\
    \ error: 'characters' is unavailable: Please use String directly\n    for letter\
    \ in s.characters {\n                    ^~~~~~~~~~\nSwift.String:5:16: note:\
    \ 'characters' was obsoleted in Swift 5.0\n    public var characters: String {\
    \ get set }\n               ^\n/tmp/tmp3_cgauhp.swift:23:12: error: cannot convert\
    \ value of type 'Character' to expected condition type 'Bool'\n        if letter\
    \ in vowels {\n           ^~~~~~\n/tmp/tmp3_cgauhp.swift:27:14: error: 'characters'\
    \ is unavailable: Please use String directly\n        if s.characters.filter({\
    \ $0 == letter }).count == n {\n             ^~~~~~~~~~\nSwift.String:5:16: note:\
    \ 'characters' was obsoleted in Swift 5.0\n    public var characters: String {\
    \ get set }\n               ^\n"
  stdout: ''
  timestamp: 1660014411
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"\
    ]\n/// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n\
    /// select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfunc\
    \ select_words(s: String, n: Int) -> [String] {\n    var words = [String]()\n\
    \    var i = 0\n    var j = 0\n    var k = 0\n    var l = 0\n    var m = 0\n \
    \   var n = 0\n    var o = 0\n    var p = 0\n    var q = 0\n    var r = 0\n  \
    \  var s = 0\n    var t = 0\n    var u = 0\n    var v = 0\n    var w = 0\n   \
    \ var x = 0\n    var y = 0\n    var z = 0\n    var a = 0\n    var b = 0\n    var\
    \ c = 0\n    var d = 0\n    var e = 0\n    var f = 0\n    var g = 0\n    var h\
    \ = 0\n    var i = 0\n    var j = 0\n    var k = 0\n    var l = 0\n    var m =\
    \ 0\n    var n = 0\n    var o = 0\n    var p = 0\n    var q = 0\n    var r = 0\n\
    \    var s = 0\n    var t = 0\n    var u = 0\n    var v = 0\n    var w = 0\n \
    \   var x = 0\n    var y = 0\n    var z = 0\n    var a = 0\n    var b = 0\n  \
    \  var c = 0\n    var d = 0\n    var e = 0\n    var f = 0\n    var g = 0\n   \
    \ var h = 0\n    var i = 0\n    var j = 0\n    var k = 0\n    var l = 0\n    var\
    \ m = 0\n    var n = 0\n    var o = 0\n    var p = 0\n    var q = 0\n    var r\
    \ = 0\n    var s = 0\n    var t = 0\n    var u = 0\n    var v = 0\n    var w =\
    \ 0\n    var x = 0\n    var y = 0\n    var z = 0\n    var a = 0\n    var b = 0\n\
    \    var c = 0\n    var d = 0\n    var e = 0\n    var f = 0\n    var g = 0\n \
    \   var h = 0\n    var i = 0\n    var j = 0\n    var k = 0\n    var l = 0\n  \
    \  var m = 0\n    var n = 0\n    var o = 0\n    var p = 0\n    var q = 0\n   \
    \ var r = 0\n    var s = 0\n    var t = 0\n    var u = 0\n    var v = 0\n    var\
    \ w = 0\n    var x = 0\n    var y = 0\n    var z = 0\n    var a = 0\n    var b\
    \ = 0\n    var c = 0\n    var d = 0\n    var e = 0\n    var f = 0\n    var g =\
    \ 0\n    var h = 0\n    var i = 0\n    var j = 0\n    var k = 0\n    var l = 0\n\
    \    var m = 0\n    var n = 0\n    var o = 0\n    var p = 0\n    var q = 0\n \
    \   var r = 0\n    var s = 0\n    var t = 0\n    var u = 0\n    var v = 0\n  \
    \  var w = 0\n    var x = 0\n    var y = 0\n    var z = 0\n    var a = 0\n   \
    \ var b = 0\n    var c = 0\n    var d = 0\n    var e = 0\n    var f = 0\n    var\
    \ g = 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary\
    \ had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had\
    \ a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple\
    \ white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\"\
    , n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"\
    ])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s:\
    \ \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmprr1kdnls.swift:41:9: error: invalid redeclaration of 'i'\n    var\
    \ i = 0\n        ^\n/tmp/tmprr1kdnls.swift:15:9: note: 'i' previously declared\
    \ here\n    var i = 0\n        ^\n/tmp/tmprr1kdnls.swift:42:9: error: invalid\
    \ redeclaration of 'j'\n    var j = 0\n        ^\n/tmp/tmprr1kdnls.swift:16:9:\
    \ note: 'j' previously declared here\n    var j = 0\n        ^\n/tmp/tmprr1kdnls.swift:43:9:\
    \ error: invalid redeclaration of 'k'\n    var k = 0\n        ^\n/tmp/tmprr1kdnls.swift:17:9:\
    \ note: 'k' previously declared here\n    var k = 0\n        ^\n/tmp/tmprr1kdnls.swift:44:9:\
    \ error: invalid redeclaration of 'l'\n    var l = 0\n        ^\n/tmp/tmprr1kdnls.swift:18:9:\
    \ note: 'l' previously declared here\n    var l = 0\n        ^\n/tmp/tmprr1kdnls.swift:45:9:\
    \ error: invalid redeclaration of 'm'\n    var m = 0\n        ^\n/tmp/tmprr1kdnls.swift:19:9:\
    \ note: 'm' previously declared here\n    var m = 0\n        ^\n/tmp/tmprr1kdnls.swift:46:9:\
    \ error: invalid redeclaration of 'n'\n    var n = 0\n        ^\n/tmp/tmprr1kdnls.swift:20:9:\
    \ note: 'n' previously declared here\n    var n = 0\n        ^\n/tmp/tmprr1kdnls.swift:47:9:\
    \ error: invalid redeclaration of 'o'\n    var o = 0\n        ^\n/tmp/tmprr1kdnls.swift:21:9:\
    \ note: 'o' previously declared here\n    var o = 0\n        ^\n/tmp/tmprr1kdnls.swift:48:9:\
    \ error: invalid redeclaration of 'p'\n    var p = 0\n        ^\n/tmp/tmprr1kdnls.swift:22:9:\
    \ note: 'p' previously declared here\n    var p = 0\n        ^\n/tmp/tmprr1kdnls.swift:49:9:\
    \ error: invalid redeclaration of 'q'\n    var q = 0\n        ^\n/tmp/tmprr1kdnls.swift:23:9:\
    \ note: 'q' previously declared here\n    var q = 0\n        ^\n/tmp/tmprr1kdnls.swift:50:9:\
    \ error: invalid redeclaration of 'r'\n    var r = 0\n        ^\n/tmp/tmprr1kdnls.swift:24:9:\
    \ note: 'r' previously declared here\n    var r = 0\n        ^\n/tmp/tmprr1kdnls.swift:51:9:\
    \ error: invalid redeclaration of 's'\n    var s = 0\n        ^\n/tmp/tmprr1kdnls.swift:25:9:\
    \ note: 's' previously declared here\n    var s = 0\n        ^\n/tmp/tmprr1kdnls.swift:52:9:\
    \ error: invalid redeclaration of 't'\n    var t = 0\n        ^\n/tmp/tmprr1k"
  stdout: ''
  timestamp: 1660014410
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"\
    ]\n/// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n\
    /// select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfunc\
    \ select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    \n    if s == \"\" {\n        return result\n    }\n    \n    for c in s\
    \ {\n        if c.isConsonant() {\n            if n == 1 {\n                result.append(c)\n\
    \            } else {\n                result.insert(c, at: 0)\n            }\n\
    \        }\n    }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"\
    ])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"\
    lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpycrit2r0.swift:21:14: error: value of type 'Character' has no member\
    \ 'isConsonant'\n        if c.isConsonant() {\n           ~ ^~~~~~~~~~~\n/tmp/tmpycrit2r0.swift:23:31:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \                result.append(c)\n                              ^\n/tmp/tmpycrit2r0.swift:25:31:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \                result.insert(c, at: 0)\n                              ^\n"
  stdout: ''
  timestamp: 1660014411
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"\
    ]\n/// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n\
    /// select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfunc\
    \ select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    \n    if s == \"\" {\n        return result\n    }\n    \n    var i = 0\n\
    \    var j = 0\n    \n    for _ in 0..<s.characters.count {\n        if s[i] ==\
    \ \" \" {\n            i += 1\n        }\n        \n        if i == n {\n    \
    \        result.append(String(s[j..<s.characters.count]))\n            i = j\n\
    \            j = 0\n        }\n        \n        if s[i] == \" \" {\n        \
    \    i += 1\n        }\n        \n        if s[i] == \" \" {\n            i +=\
    \ 1\n        }\n        \n        if s[i] == \" \" {\n            i += 1\n   \
    \     }\n        \n        if s[i] == \" \" {\n            i += 1\n        }\n\
    \        \n        if s[i] == \" \" {\n            i += 1\n        }\n       \
    \ \n        if s[i] == \" \" {\n            i += 1\n        }\n        \n    \
    \    if s[i] == \" \" {\n            i += 1\n        }\n        \n        if s[i]\
    \ == \" \" {\n            i += 1\n        }\n        \n        if s[i] == \" \"\
    \ {\n            i += 1\n        }\n        \n        if s[i] == \" \" {\n   \
    \         i += 1\n        }\n        \n        if s[i] == \" \" {\n          \
    \  i += 1\n        }\n        \n        if s[i] == \" \" {\n            i += 1\n\
    \        }\n        \n        if s[i] == \" \" {\n            i += 1\n       \
    \ }\n        \n        if s[i] == \" \" {\n            i += 1\n        }\n   \
    \     \n        if s[i] == \" \" {\n            i += 1\n        }\n        \n\
    \        if s[i] == \" \" {\n            i += 1\n        }\n        \n       \
    \ if s[i] == \" \" {\n            i += 1\n        }\n        \n        if s[i]\
    \ == \" \" {\n            i += 1\n        }\n        \n        if s[i] == \" \"\
    \ {\n            i += 1\n        }\n        \n        if s[i] == \" \" {\n   \
    \         i += 1\n        }\n        \n        if s[i] == \" \" {\n          \
    \  i += 1\n        }\n        \n        if s[i] == \" \" {\n            i += 1\n\
    \        }\n        \n        if s[i] == \" \" {\n            i += 1\n       \
    \ }\n        \n        if s[i] == \" \" {\n            i += 1\n        }\n   \
    \     \n        if s[i] == \" \" {\n            i += 1\n        }\n        \n\
    \        if s[i] == \" \" {\n            i += 1\n        }\n        \n       \
    \ if s[i] == \" \" {\n            i += 1\n        }\n        \n        if s[i]\
    \ == \" \" {\n            i += 1\n        }\n        \n        if s[i] == \" \"\
    \ {\n            i += 1\n        }\n        \n        if s[i] == \" \" {\n   \
    \         i += 1\n        }\n        \n        if s[i] == \" \" {\n          \
    \  i += 1\n        }\n\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s:\
    \ \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"\
    Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmptto3mi89.swift:179:69: error: expected '}' at end of brace statement\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])\n\
    \                                                                    ^\n/tmp/tmptto3mi89.swift:13:50:\
    \ note: to match this opening '{'\nfunc select_words(s: String, n: Int) -> [String]\
    \ {\n                                                 ^\n/tmp/tmptto3mi89.swift:23:20:\
    \ error: 'characters' is unavailable: Please use String directly\n    for _ in\
    \ 0..<s.characters.count {\n                   ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmptto3mi89.swift:24:12: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if s[i] == \" \" {\n           ^~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmptto3mi89.swift:29:34: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an integer range, use a String.Index\
    \ range instead.\n            result.append(String(s[j..<s.characters.count]))\n\
    \                                 ^~~~~~~~~~~~~~~~~~~~~~~~~\nSwift.String:5:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript<R>(bounds: R) -> String where R : RangeExpression, R.Bound == Int\
    \ { get }\n           ^\n/tmp/tmptto3mi89.swift:29:42: error: 'characters' is\
    \ unavailable: Please use String directly\n            result.append(String(s[j..<s.characters.count]))\n\
    \                                         ^~~~~~~~~~\nSwift.String:5:16: note:\
    \ 'characters' was obsoleted in Swift 5.0\n    public var characters: String {\
    \ get set }\n               ^\n/tmp/tmptto3mi89.swift:34:12: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if s[i] == \" \" {\n           ^~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here"
  stdout: ''
  timestamp: 1660014411
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"\
    ]\n/// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n\
    /// select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfunc\
    \ select_words(s: String, n: Int) -> [String] {\n    return s.split(\" \").filter{\
    \ $0.contains(String(repeating: \"a\", count: n)) }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"\
    little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\"\
    , \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpcnrim_h7.swift:14:14: error: no exact matches in call to instance\
    \ method 'split'\n    return s.split(\" \").filter{ $0.contains(String(repeating:\
    \ \"a\", count: n)) }\n             ^\n/tmp/tmpcnrim_h7.swift:14:14: note: found\
    \ candidate with type '(String.Element, Int, Bool) -> [ArraySlice<String.Element>]'\
    \ (aka '(Character, Int, Bool) -> Array<ArraySlice<Character>>')\n    return s.split(\"\
    \ \").filter{ $0.contains(String(repeating: \"a\", count: n)) }\n            \
    \ ^\n/tmp/tmpcnrim_h7.swift:14:14: note: found candidate with type '(String.Element,\
    \ Int, Bool) -> [String.SubSequence]' (aka '(Character, Int, Bool) -> Array<Substring>')\n\
    \    return s.split(\" \").filter{ $0.contains(String(repeating: \"a\", count:\
    \ n)) }\n             ^\n"
  stdout: ''
  timestamp: 1660014411
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"\
    ]\n/// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n\
    /// select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfunc\
    \ select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    if s == \"\" {\n        return result\n    }\n    var i = 0\n    var j =\
    \ 0\n    var k = 0\n    for i < s.count {\n        if s[i] == \" \" {\n      \
    \      j = i\n            for k < s.count {\n                if s[k] == \" \"\
    \ {\n                    k = k + 1\n                } else {\n               \
    \     break\n                }\n            }\n            if k == s.count {\n\
    \                result.insert(i, s.substring(i, j))\n                i = j +\
    \ 1\n            }\n        } else {\n            k = i\n            for j < s.count\
    \ {\n                if s[j] == \" \" {\n                    j = j + 1\n     \
    \           } else {\n                    break\n                }\n         \
    \   }\n            if j == s.count {\n                result.insert(i, s.substring(i,\
    \ j))\n                i = j + 1\n            }\n        }\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary\
    \ had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had\
    \ a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple\
    \ white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\"\
    , n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"\
    ])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s:\
    \ \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpx7o1tr5l.swift:21:11: error: expected 'in' after for-each pattern\n\
    \    for i < s.count {\n          ^\n/tmp/tmpx7o1tr5l.swift:21:11: error: unary\
    \ operator cannot be separated from its operand\n    for i < s.count {\n     \
    \     ^~\n           \n/tmp/tmpx7o1tr5l.swift:24:19: error: expected 'in' after\
    \ for-each pattern\n            for k < s.count {\n                  ^\n/tmp/tmpx7o1tr5l.swift:24:19:\
    \ error: unary operator cannot be separated from its operand\n            for\
    \ k < s.count {\n                  ^~\n                   \n/tmp/tmpx7o1tr5l.swift:37:19:\
    \ error: expected 'in' after for-each pattern\n            for j < s.count {\n\
    \                  ^\n/tmp/tmpx7o1tr5l.swift:37:19: error: unary operator cannot\
    \ be separated from its operand\n            for j < s.count {\n             \
    \     ^~\n                   \n/tmp/tmpx7o1tr5l.swift:21:11: error: '<' is not\
    \ a prefix unary operator\n    for i < s.count {\n          ^\n/tmp/tmpx7o1tr5l.swift:24:19:\
    \ error: '<' is not a prefix unary operator\n            for k < s.count {\n \
    \                 ^\n/tmp/tmpx7o1tr5l.swift:37:19: error: '<' is not a prefix\
    \ unary operator\n            for j < s.count {\n                  ^\n"
  stdout: ''
  timestamp: 1660014411
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"\
    ]\n/// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n\
    /// select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfunc\
    \ select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    \n    if s == \"\" {\n        return result\n    }\n    \n    for char in\
    \ s.characters {\n        if char.unicodeScalars.filter({ $0.isConsonant() }).count\
    \ == n {\n            result.append(String(char))\n        }\n    }\n    \n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"\
    Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary\
    \ had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpzjzed04n.swift:20:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpzjzed04n.swift:21:44:\
    \ error: value of type 'Unicode.Scalar' has no member 'isConsonant'\n        if\
    \ char.unicodeScalars.filter({ $0.isConsonant() }).count == n {\n            \
    \                            ~~ ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014410
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"\
    ]\n/// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n\
    /// select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfunc\
    \ select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    var i = 0\n    var j = 0\n    var k = 0\n    var l = 0\n    var m = 0\n \
    \   var n = 0\n    var o = 0\n    var p = 0\n    var q = 0\n    var r = 0\n  \
    \  var s = 0\n    var t = 0\n    var u = 0\n    var v = 0\n    var w = 0\n   \
    \ var x = 0\n    var y = 0\n    var z = 0\n    var a = 0\n    var b = 0\n    var\
    \ c = 0\n    var d = 0\n    var e = 0\n    var f = 0\n    var g = 0\n    var h\
    \ = 0\n    var i = 0\n    var j = 0\n    var k = 0\n    var l = 0\n    var m =\
    \ 0\n    var n = 0\n    var o = 0\n    var p = 0\n    var q = 0\n    var r = 0\n\
    \    var s = 0\n    var t = 0\n    var u = 0\n    var v = 0\n    var w = 0\n \
    \   var x = 0\n    var y = 0\n    var z = 0\n    var a = 0\n    var b = 0\n  \
    \  var c = 0\n    var d = 0\n    var e = 0\n    var f = 0\n    var g = 0\n   \
    \ var h = 0\n    var i = 0\n    var j = 0\n    var k = 0\n    var l = 0\n    var\
    \ m = 0\n    var n = 0\n    var o = 0\n    var p = 0\n    var q = 0\n    var r\
    \ = 0\n    var s = 0\n    var t = 0\n    var u = 0\n    var v = 0\n    var w =\
    \ 0\n    var x = 0\n    var y = 0\n    var z = 0\n    var a = 0\n    var b = 0\n\
    \    var c = 0\n    var d = 0\n    var e = 0\n    var f = 0\n    var g = 0\n \
    \   var h = 0\n    var i = 0\n    var j = 0\n    var k = 0\n    var l = 0\n  \
    \  var m = 0\n    var n = 0\n    var o = 0\n    var p = 0\n    var q = 0\n   \
    \ var r = 0\n    var s = 0\n    var t = 0\n    var u = 0\n    var v = 0\n    var\
    \ w = 0\n    var x = 0\n    var y = 0\n    var z = 0\n    var a = 0\n    var b\
    \ = 0\n    var c = 0\n    var d = 0\n    var e = 0\n    var f = 0\n    var g =\
    \ 0\n    var h = 0\n    var i = 0\n    var j = 0\n    var k = 0\n    var l = 0\n\
    \    var m = 0\n    var n = 0\n    var o = 0\n    var p = 0\n    var q = 0\n \
    \   var r = 0\n    var s = 0\n    var t = 0\n    var u = 0\n    var v = 0\n  \
    \  var w = 0\n    var x = 0\n    var y = 0\n    var z = 0\n    var a = 0\n   \
    \ var b = 0\n    var c = 0\n    var d = 0\n    var e = 0\n    var f = 0\n    var\
    \ g = 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary\
    \ had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had\
    \ a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple\
    \ white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\"\
    , n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"\
    ])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s:\
    \ \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpv60dryfr.swift:41:9: error: invalid redeclaration of 'i'\n    var\
    \ i = 0\n        ^\n/tmp/tmpv60dryfr.swift:15:9: note: 'i' previously declared\
    \ here\n    var i = 0\n        ^\n/tmp/tmpv60dryfr.swift:42:9: error: invalid\
    \ redeclaration of 'j'\n    var j = 0\n        ^\n/tmp/tmpv60dryfr.swift:16:9:\
    \ note: 'j' previously declared here\n    var j = 0\n        ^\n/tmp/tmpv60dryfr.swift:43:9:\
    \ error: invalid redeclaration of 'k'\n    var k = 0\n        ^\n/tmp/tmpv60dryfr.swift:17:9:\
    \ note: 'k' previously declared here\n    var k = 0\n        ^\n/tmp/tmpv60dryfr.swift:44:9:\
    \ error: invalid redeclaration of 'l'\n    var l = 0\n        ^\n/tmp/tmpv60dryfr.swift:18:9:\
    \ note: 'l' previously declared here\n    var l = 0\n        ^\n/tmp/tmpv60dryfr.swift:45:9:\
    \ error: invalid redeclaration of 'm'\n    var m = 0\n        ^\n/tmp/tmpv60dryfr.swift:19:9:\
    \ note: 'm' previously declared here\n    var m = 0\n        ^\n/tmp/tmpv60dryfr.swift:46:9:\
    \ error: invalid redeclaration of 'n'\n    var n = 0\n        ^\n/tmp/tmpv60dryfr.swift:20:9:\
    \ note: 'n' previously declared here\n    var n = 0\n        ^\n/tmp/tmpv60dryfr.swift:47:9:\
    \ error: invalid redeclaration of 'o'\n    var o = 0\n        ^\n/tmp/tmpv60dryfr.swift:21:9:\
    \ note: 'o' previously declared here\n    var o = 0\n        ^\n/tmp/tmpv60dryfr.swift:48:9:\
    \ error: invalid redeclaration of 'p'\n    var p = 0\n        ^\n/tmp/tmpv60dryfr.swift:22:9:\
    \ note: 'p' previously declared here\n    var p = 0\n        ^\n/tmp/tmpv60dryfr.swift:49:9:\
    \ error: invalid redeclaration of 'q'\n    var q = 0\n        ^\n/tmp/tmpv60dryfr.swift:23:9:\
    \ note: 'q' previously declared here\n    var q = 0\n        ^\n/tmp/tmpv60dryfr.swift:50:9:\
    \ error: invalid redeclaration of 'r'\n    var r = 0\n        ^\n/tmp/tmpv60dryfr.swift:24:9:\
    \ note: 'r' previously declared here\n    var r = 0\n        ^\n/tmp/tmpv60dryfr.swift:51:9:\
    \ error: invalid redeclaration of 's'\n    var s = 0\n        ^\n/tmp/tmpv60dryfr.swift:25:9:\
    \ note: 's' previously declared here\n    var s = 0\n        ^\n/tmp/tmpv60dryfr.swift:52:9:\
    \ error: invalid redeclaration of 't'\n    var t = 0\n        ^\n/tmp/tmpv60d"
  stdout: ''
  timestamp: 1660014410
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"\
    ]\n/// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n\
    /// select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfunc\
    \ select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    \n    if s == \"\" {\n        return result\n    }\n    \n    var i = 0\n\
    \    var j = 0\n    \n    for i < s.count {\n        if s[i] == \" \" {\n    \
    \        j = i\n            \n            while j < s.count && s[j] != \" \" {\n\
    \                j++\n            }\n            \n            if j == s.count\
    \ {\n                result.append(\"\\n\")\n            }\n            \n   \
    \         i += j - i\n        }\n        \n        if s[i] == \" \" {\n      \
    \      j = i\n            \n            while j < s.count && s[j] != \" \" {\n\
    \                j++\n            }\n            \n            if j == s.count\
    \ {\n                result.append(\"\\n\")\n            }\n            \n   \
    \         i += j - i\n        }\n        \n        if s[i] == \"a\" || s[i] ==\
    \ \"e\" || s[i] == \"i\" || s[i] == \"o\" || s[i] == \"u\" {\n            j =\
    \ i\n            \n            while j < s.count && s[j] != \" \" {\n        \
    \        j++\n            }\n            \n            if j == s.count {\n   \
    \             result.append(\"\\n\")\n            }\n            \n          \
    \  i += j - i\n        }\n        \n        if s[i] == \"a\" || s[i] == \"e\"\
    \ || s[i] == \"i\" || s[i] == \"o\" || s[i] == \"u\" || s[i] == \"y\" {\n    \
    \        j = i\n            \n            while j < s.count && s[j] != \" \" {\n\
    \                j++\n            }\n            \n            if j == s.count\
    \ {\n                result.append(\"\\n\")\n            }\n            \n   \
    \         i += j - i\n        }\n        \n        if s[i] == \"a\" || s[i] ==\
    \ \"e\" || s[i] == \"i\" || s[i] == \"o\" || s[i] == \"u\" || s[i] == \"y\" ||\
    \ s[i] == \"s\" {\n            j = i\n            \n            while j < s.count\
    \ && s[j] != \" \" {\n                j++\n            }\n            \n     \
    \       if j == s.count {\n                result.append(\"\\n\")\n          \
    \  }\n            \n            i += j - i\n        }\n        \n        if s[i]\
    \ == \"a\" || s[i] == \"e\" || s[i] == \"i\" || s[i] == \"o\" || s[i] == \"u\"\
    \ || s[i] == \"y\" || s[i] == \"s\" || s[i] == \"t\" {\n            j = i\n  \
    \          \n            while j < s.count && s[j] != \" \" {\n              \
    \  j++\n            }\n            \n            if j == s.count {\n         \
    \       result.append(\"\\n\")\n            }\n            \n            i +=\
    \ j - i\n        }\n        \n        if s[i] == \"a\" || s[i] == \"e\" || s[i]\
    \ == \"i\" || s[i] == \"o\" || s[i] == \"u\" || s[i] == \"y\" || s[i] == \"s\"\
    \ || s[i] == \"t\" || s[i] == \"w\" {\n            j = i\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"\
    little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\"\
    , \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmppd_ukkmw.swift:23:11: error: expected 'in' after for-each pattern\n\
    \    for i < s.count {\n          ^\n/tmp/tmppd_ukkmw.swift:23:11: error: unary\
    \ operator cannot be separated from its operand\n    for i < s.count {\n     \
    \     ^~\n           \n/tmp/tmppd_ukkmw.swift:131:69: error: expected '}' at end\
    \ of brace statement\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\"\
    , \"c\", \"d\", \"f\"])\n                                                    \
    \                ^\n/tmp/tmppd_ukkmw.swift:23:21: note: to match this opening\
    \ '{'\n    for i < s.count {\n                    ^\n/tmp/tmppd_ukkmw.swift:131:69:\
    \ error: expected '}' at end of brace statement\nassert(select_words(s: \"a b\
    \ c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])\n                        \
    \                                            ^\n/tmp/tmppd_ukkmw.swift:13:50:\
    \ note: to match this opening '{'\nfunc select_words(s: String, n: Int) -> [String]\
    \ {\n                                                 ^\n/tmp/tmppd_ukkmw.swift:23:11:\
    \ error: '<' is not a prefix unary operator\n    for i < s.count {\n         \
    \ ^\n"
  stdout: ''
  timestamp: 1660014411
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"\
    ]\n/// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n\
    /// select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfunc\
    \ select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    \n    if s == \"\" {\n        return result\n    }\n    \n    var i = 0\n\
    \    var j = 0\n    \n    while i < s.count {\n        if s[i] == \" \" {\n  \
    \          i += 1\n            continue\n        }\n        \n        if s[i]\
    \ == \" \" {\n            i += 1\n            continue\n        }\n        \n\
    \        if s[i] == \" \" {\n            i += 1\n            continue\n      \
    \  }\n        \n        if s[i] == \" \" {\n            i += 1\n            continue\n\
    \        }\n        \n        if s[i] == \" \" {\n            i += 1\n       \
    \     continue\n        }\n        \n        if s[i] == \" \" {\n            i\
    \ += 1\n            continue\n        }\n        \n        if s[i] == \" \" {\n\
    \            i += 1\n            continue\n        }\n        \n        if s[i]\
    \ == \" \" {\n            i += 1\n            continue\n        }\n        \n\
    \        if s[i] == \" \" {\n            i += 1\n            continue\n      \
    \  }\n        \n        if s[i] == \" \" {\n            i += 1\n            continue\n\
    \        }\n        \n        if s[i] == \" \" {\n            i += 1\n       \
    \     continue\n        }\n        \n        if s[i] == \" \" {\n            i\
    \ += 1\n            continue\n        }\n        \n        if s[i] == \" \" {\n\
    \            i += 1\n            continue\n        }\n        \n        if s[i]\
    \ == \" \" {\n            i += 1\n            continue\n        }\n        \n\
    \        if s[i] == \" \" {\n            i += 1\n            continue\n      \
    \  }\n        \n        if s[i] == \" \" {\n            i += 1\n            continue\n\
    \        }\n        \n        if s[i] == \" \" {\n            i += 1\n       \
    \     continue\n        }\n        \n        if s[i] == \" \" {\n            i\
    \ += 1\n            continue\n        }\n        \n        if s[i] == \" \" {\n\
    \            i += 1\n            continue\n        }\n        \n        if s[i]\
    \ == \" \" {\n            i += 1\n            continue\n        }\n        \n\
    \        if s[i] == \" \" {\n            i += 1\n            continue\n      \
    \  }\n        \n        if s[i] == \" \" {\n            i += 1\n            continue\n\
    \        }\n        \n        if s[i] == \" \" {\n            i += 1\n       \
    \     continue\n        }\n        \n        if s[i] == \" \" {\n            i\
    \ += 1\n            continue\n        }\n        \n        if s[i] == \" \" {\n\
    \            i += 1\n            continue\n        }\n        \n        if s[i]\
    \ == \" \" {\n            i += 1\n            continue\n        }\n        \n\
    \        if s[i] == \" \" {\n            i += 1\n            continue\n      \
    \  }\n        \n        if s[i] == \" \" {\n            i += 1\n            continue\n\
    \        }\n        \n        if s[i] == \" \" {\n            i += 1\n       \
    \     continue\n        }\n        \n        if s[i] == \" \" {\n            i\
    \ += 1\n            continue\n        }\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s:\
    \ \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpg2hi2yir.swift:194:69: error: expected '}' at end of brace statement\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])\n\
    \                                                                    ^\n/tmp/tmpg2hi2yir.swift:13:50:\
    \ note: to match this opening '{'\nfunc select_words(s: String, n: Int) -> [String]\
    \ {\n                                                 ^\n/tmp/tmpg2hi2yir.swift:24:12:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if s[i] == \" \" {\n           ^~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpg2hi2yir.swift:29:12:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if s[i] == \" \" {\n           ^~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpg2hi2yir.swift:34:12:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if s[i] == \" \" {\n           ^~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpg2hi2yir.swift:39:12:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if s[i] == \" \" {\n           ^~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpg2hi2yir.swift:44:12:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if s[i] == \" \" {\n           ^~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpg2hi2yir.swift:49:12:\
    \ error: 'subscript(_:)' "
  stdout: ''
  timestamp: 1660014411
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"\
    ]\n/// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n\
    /// select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfunc\
    \ select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    \n    if s == \"\" {\n        return result\n    }\n    \n    for char in\
    \ s.characters {\n        if char.hasConsonant() {\n            if result.count\
    \ < n {\n                result.append(String(char))\n            }\n        }\n\
    \    }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s:\
    \ \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"\
    Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmp0gyzfckj.swift:20:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmp0gyzfckj.swift:21:17:\
    \ error: value of type 'Character' has no member 'hasConsonant'\n        if char.hasConsonant()\
    \ {\n           ~~~~ ^~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014410
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"\
    ]\n/// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n\
    /// select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfunc\
    \ select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    for word in s.split(\" \") {\n        if word.hasPrefix(\"a\") {\n      \
    \      if word.hasPrefix(\"b\") {\n                if word.hasPrefix(\"c\") {\n\
    \                    if word.hasPrefix(\"d\") {\n                        if word.hasPrefix(\"\
    e\") {\n                            if word.hasPrefix(\"f\") {\n             \
    \                   if word.hasPrefix(\"g\") {\n                             \
    \       if word.hasPrefix(\"h\") {\n                                        if\
    \ word.hasPrefix(\"i\") {\n                                            if word.hasPrefix(\"\
    j\") {\n                                                if word.hasPrefix(\"k\"\
    ) {\n                                                    if word.hasPrefix(\"\
    l\") {\n                                                        if word.hasPrefix(\"\
    m\") {\n                                                            if word.hasPrefix(\"\
    n\") {\n                                                                if word.hasPrefix(\"\
    o\") {\n                                                                    if\
    \ word.hasPrefix(\"p\") {\n                                                  \
    \                      if word.hasPrefix(\"q\") {\n                          \
    \                                                  if word.hasPrefix(\"r\") {\n\
    \                                                                            \
    \    if word.hasPrefix(\"s\") {\n                                            \
    \                                        if word.hasPrefix(\"t\") {\n        \
    \                                                                            \
    \    if word.hasPrefix(\"u\") {\n                                            \
    \                                                if word.hasPrefix(\"v\") {\n\
    \                                                                            \
    \                    if word.hasPrefix(\"w\") {\n                            \
    \                                                                        if word.hasPrefix(\"\
    x\") {\n                                                                     \
    \                                   if word.hasPrefix(\"y\") {\n             \
    \                                                                            \
    \                   if word.hasPrefix(\"z\") {\n                             \
    \                                                                            \
    \       if word.hasPrefix(\"A\") {\n                                         \
    \                                                                           if\
    \ word.hasPrefix(\"B\") {\n                                                  \
    \                                                                      if word.hasPrefix(\"\
    C\") {\n                                                                     \
    \                                                       if word.hasPrefix(\"D\"\
    ) {\n                                                                        \
    \                                                                        if word.hasPrefix(\"\
    E\") {\n                                                                     \
    \                                                               if word.hasPrefix(\"\
    F\") {\n                                                                     \
    \                                                                            \
    \       if word.hasPrefix(\"G\") {\n                                         \
    \                                                                            \
    \                                       if word.hasPrefix(\"H\") {\n         \
    \                                                                            \
    \                                                                           if\
    \ word.hasPrefix(\"I\") {\n                                                  \
    \                                                                            \
    \      if word.hasPrefix(\"J\") {\n                                          \
    \                                                                            \
    \                                  if word.hasPrefix(\"K\") {\n              \
    \                                                                            \
    \                                                                  if word.hasPrefix(\"\
    L\") {\n                                                                     \
    \                                                                            \
    \               if word.hasPrefix(\"M\") {\n                                 \
    \                                                                            \
    \                       if word.hasPrefix(\"N\") {\n                         \
    \                                                                            \
    \                                                   if word.hasPrefix(\"O\") {\n\
    \                                                                            \
    \                                                                            \
    \    if word.hasPrefix(\"P\") {\n                                            \
    \                                                                            \
    \                                        if word.hasPrefix(\"Q\") {\n        \
    \                                                                            \
    \                                                if word.hasPrefix(\"R\") {\n\
    \                                                                            \
    \                                                                            if\
    \ word.hasPrefix(\"S\") {\n                                                  \
    \                                                                            \
    \                              if word.hasPrefix(\"T\") {\n                  \
    \                                                                            \
    \                                                                  if word.hasPrefix(\"\
    U\") {\n                                                                     \
    \                                                               if word.hasPrefix(\"\
    V\") {\n                                                                     \
    \                                                                            \
    \       if word.hasPrefix(\"W\") {\n                                         \
    \                                                                            \
    \                                       if word.hasPrefix(\"X\") {\n         \
    \                                                                            \
    \                                                                           if\
    \ word.hasPrefix(\"Y\") {\n                                                  \
    \              \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"\
    Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary\
    \ had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmp2agrpztm.swift:89:69: error: expected '}' at end of brace statement\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])\n\
    \                                                                    ^\n/tmp/tmp2agrpztm.swift:65:180:\
    \ note: to match this opening '{'\n                                          \
    \                                                                            \
    \                                      if word.hasPrefix(\"X\") {\n          \
    \                                                                            \
    \                                                                            \
    \                 ^\n/tmp/tmp2agrpztm.swift:89:69: error: expected '}' at end\
    \ of brace statement\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\"\
    , \"c\", \"d\", \"f\"])\n                                                    \
    \                ^\n/tmp/tmp2agrpztm.swift:64:176: note: to match this opening\
    \ '{'\n                                                                      \
    \                                                                            \
    \      if word.hasPrefix(\"W\") {\n                                          \
    \                                                                            \
    \                                                         ^\n/tmp/tmp2agrpztm.swift:89:69:\
    \ error: expected '}' at end of brace statement\nassert(select_words(s: \"a b\
    \ c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])\n                        \
    \                                            ^\n/tmp/tmp2agrpztm.swift:63:156:\
    \ note: to match this opening '{'\n                                          \
    \                                                                            \
    \              if word.hasPrefix(\"V\") {\n                                  \
    \                                                                            \
    \                                             ^\n/tmp/tmp2agrpztm.swift:89:69:\
    \ error: expected '}' at end of brace statement\nassert(select_words(s: \"a b\
    \ c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])\n                        \
    \               "
  stdout: ''
  timestamp: 1660014411
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"\
    ]\n/// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n\
    /// select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfunc\
    \ select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    \n    if s == \"\" {\n        return result\n    }\n    \n    for char in\
    \ s.characters {\n        if char.unicodeScalars.filter({ $0.isConsonant() }).count\
    \ == n {\n            result.append(String(char))\n        }\n    }\n    \n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"\
    Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary\
    \ had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpzjzed04n.swift:20:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpzjzed04n.swift:21:44:\
    \ error: value of type 'Unicode.Scalar' has no member 'isConsonant'\n        if\
    \ char.unicodeScalars.filter({ $0.isConsonant() }).count == n {\n            \
    \                            ~~ ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014410
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"\
    ]\n/// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n\
    /// select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfunc\
    \ select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    \n    if s == \"\" {\n        return result\n    }\n    \n    var i = 0\n\
    \    var j = 0\n    var k = 0\n    \n    while i < s.count {\n        if s[i]\
    \ == \" \" {\n            i += 1\n            \n            if j == n {\n    \
    \            result.append(String(s[k:i]))\n                k = 0\n          \
    \      j = 0\n            } else {\n                j += 1\n            }\n  \
    \      } else {\n            k += 1\n        }\n        i += 1\n    }\n    \n\
    \    if j == n {\n        result.append(String(s[k:]))\n    }\n    \n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary\
    \ had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had\
    \ a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple\
    \ white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\"\
    , n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"\
    ])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s:\
    \ \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmp3erdy_u2.swift:42:34: error: expected expression in list of expressions\n\
    \        result.append(String(s[k:]))\n                                 ^\n/tmp/tmp3erdy_u2.swift:25:12:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if s[i] == \" \" {\n           ^~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmp3erdy_u2.swift:29:39:\
    \ error: extraneous argument label 'k:' in subscript\n                result.append(String(s[k:i]))\n\
    \                                      ^~~\n                                 \
    \      \n/tmp/tmp3erdy_u2.swift:42:34: error: missing argument for parameter #1\
    \ in call\n        result.append(String(s[k:]))\n                            \
    \     ^\n                                 <#String.Index#>\nSwift.String:12:12:\
    \ note: 'subscript(_:)' declared here\n    public subscript(i: String.Index) ->\
    \ Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1660014411
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"\
    ]\n/// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n\
    /// select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfunc\
    \ select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    \n    if s == \"\" {\n        return result\n    }\n    \n    for char in\
    \ s.characters {\n        if char.unicodeScalars.filter({ $0.isConsonant() }).count\
    \ == n {\n            result.append(String(char))\n        }\n    }\n    \n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"\
    Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary\
    \ had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpzjzed04n.swift:20:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpzjzed04n.swift:21:44:\
    \ error: value of type 'Unicode.Scalar' has no member 'isConsonant'\n        if\
    \ char.unicodeScalars.filter({ $0.isConsonant() }).count == n {\n            \
    \                            ~~ ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014410
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"\
    ]\n/// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n\
    /// select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfunc\
    \ select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    \n    if s == \"\" {\n        return result\n    }\n    \n    for c in s\
    \ {\n        if c.isConsonant() {\n            if n == 1 {\n                result.append(c)\n\
    \            } else {\n                result.insert(c, at: 0)\n            }\n\
    \        }\n    }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"\
    ])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"\
    lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpycrit2r0.swift:21:14: error: value of type 'Character' has no member\
    \ 'isConsonant'\n        if c.isConsonant() {\n           ~ ^~~~~~~~~~~\n/tmp/tmpycrit2r0.swift:23:31:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \                result.append(c)\n                              ^\n/tmp/tmpycrit2r0.swift:25:31:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \                result.insert(c, at: 0)\n                              ^\n"
  stdout: ''
  timestamp: 1660014411
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"\
    ]\n/// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n\
    /// select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfunc\
    \ select_words(s: String, n: Int) -> [String] {\n    \n    var result = [String]()\n\
    \    \n    if s == \"\" {\n        return result\n    }\n    \n    var i = 0\n\
    \    var j = 0\n    \n    while i < s.count {\n        if s[i] == \" \" {\n  \
    \          i += 1\n        }\n        if i == s.count {\n            break\n \
    \       }\n        if s[i] == \" \" {\n            i += 1\n        }\n       \
    \ if s[i] == \" \" {\n            i += 1\n        }\n        if s[i] == \" \"\
    \ {\n            i += 1\n        }\n        if s[i] == \" \" {\n            i\
    \ += 1\n        }\n        if s[i] == \" \" {\n            i += 1\n        }\n\
    \        if s[i] == \" \" {\n            i += 1\n        }\n        if s[i] ==\
    \ \" \" {\n            i += 1\n        }\n        if s[i] == \" \" {\n       \
    \     i += 1\n        }\n        if s[i] == \" \" {\n            i += 1\n    \
    \    }\n        if s[i] == \" \" {\n            i += 1\n        }\n        if\
    \ s[i] == \" \" {\n            i += 1\n        }\n        if s[i] == \" \" {\n\
    \            i += 1\n        }\n        if s[i] == \" \" {\n            i += 1\n\
    \        }\n        if s[i] == \" \" {\n            i += 1\n        }\n      \
    \  if s[i] == \" \" {\n            i += 1\n        }\n        if s[i] == \" \"\
    \ {\n            i += 1\n        }\n        if s[i] == \" \" {\n            i\
    \ += 1\n        }\n        if s[i] == \" \" {\n            i += 1\n        }\n\
    \        if s[i] == \" \" {\n            i += 1\n        }\n        if s[i] ==\
    \ \" \" {\n            i += 1\n        }\n        if s[i] == \" \" {\n       \
    \     i += 1\n        }\n        if s[i] == \" \" {\n            i += 1\n    \
    \    }\n        if s[i] == \" \" {\n            i += 1\n        }\n        if\
    \ s[i] == \" \" {\n            i += 1\n        }\n        if s[i] == \" \" {\n\
    \            i += 1\n        }\n        if s[i] == \" \" {\n            i += 1\n\
    \        }\n        if s[i] == \" \" {\n            i += 1\n        }\n      \
    \  if s[i] == \" \" {\n            i += 1\n        }\n        if s[i] == \" \"\
    \ {\n            i += 1\n        }\n        if s[i] == \" \" {\n            i\
    \ += 1\n        }\n        if s[i] == \" \" {\n            i += 1\n        }\n\
    \        if s[i] == \" \" {\n            i += 1\n        }\n        if s[i] ==\
    \ \" \" {\n            i += 1\n        }\n        if s[i] == \" \" {\n       \
    \     i += 1\n        }\n        if s[i] == \" \" {\n            i += 1\n    \
    \    }\n        if s[i] == \" \" {\n            i += 1\n        }\n        if\
    \ s[i] == \" \" {\n            i += 1\n        }\n        if s[i] == \" \" {\n\
    \            i += 1\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"\
    Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary\
    \ had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpu6op2d55.swift:165:69: error: expected '}' at end of brace statement\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])\n\
    \                                                                    ^\n/tmp/tmpu6op2d55.swift:24:23:\
    \ note: to match this opening '{'\n    while i < s.count {\n                 \
    \     ^\n/tmp/tmpu6op2d55.swift:165:69: error: expected '}' at end of brace statement\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])\n\
    \                                                                    ^\n/tmp/tmpu6op2d55.swift:13:50:\
    \ note: to match this opening '{'\nfunc select_words(s: String, n: Int) -> [String]\
    \ {\n                                                 ^\n/tmp/tmpu6op2d55.swift:25:12:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if s[i] == \" \" {\n           ^~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpu6op2d55.swift:31:12:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if s[i] == \" \" {\n           ^~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpu6op2d55.swift:34:12:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if s[i] == \" \" {\n           ^~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpu6op2d55.swift:37:12:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if s[i] == \" \" {\n           ^~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpu6op2d55.swift:40:12:\
    \ error: 'subscript(_:"
  stdout: ''
  timestamp: 1660014411
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"\
    ]\n/// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n\
    /// select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfunc\
    \ select_words(s: String, n: Int) -> [String] {\n    var words = [String]()\n\
    \    for letter in s.characters {\n        if letter == \" \" {\n            words.append(\"\
    \")\n        } else {\n            if letter == \"a\" || letter == \"e\" || letter\
    \ == \"i\" || letter == \"o\" || letter == \"u\" {\n                words.append(letter)\n\
    \            } else {\n                let count = count_consonants(letter)\n\
    \                if count == n {\n                    words.append(letter)\n \
    \               }\n            }\n        }\n    }\n    return words\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n:\
    \ 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3)\
    \ == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n:\
    \ 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"\
    world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s:\
    \ \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1)\
    \ == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpisyh_bwc.swift:15:21: error: 'characters' is unavailable: Please\
    \ use String directly\n    for letter in s.characters {\n                    ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpisyh_bwc.swift:20:30:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \                words.append(letter)\n                             ^\n/tmp/tmpisyh_bwc.swift:22:29:\
    \ error: cannot find 'count_consonants' in scope\n                let count =\
    \ count_consonants(letter)\n                            ^~~~~~~~~~~~~~~~\n/tmp/tmpisyh_bwc.swift:24:34:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \                    words.append(letter)\n                                 ^\n"
  stdout: ''
  timestamp: 1660014411
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"\
    ]\n/// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n\
    /// select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfunc\
    \ select_words(s: String, n: Int) -> [String] {\n    var words = [String]()\n\
    \    var index = 0\n    var last = 0\n    var current = 0\n    var count = 0\n\
    \    var letters = [Character]()\n    var letter = s[0]\n    var isLetter = true\n\
    \    var isSpace = false\n    var isLetterOrSpace = false\n    \n    while index\
    \ < s.count {\n        current = s[index]\n        \n        if current == ' '\
    \ {\n            isSpace = true\n            isLetterOrSpace = true\n        }\n\
    \        \n        if current == '.' || current == ',' || current == ' ' || current\
    \ == '!' || current == '?' || current == ';' || current == '?' || current == '!'\
    \ || current == ';' || current == '-' || current == '_' || current == '*' || current\
    \ == '?' || current == '&' || current == '(' || current == ')' || current == '['\
    \ || current == ']' || current == '{' || current == '}' || current == '<' || current\
    \ == '>' || current == '/' || current == '|' || current == '\\\\' || current ==\
    \ '^' || current == '~' || current == '%' || current == '$' || current == '@'\
    \ || current == '!' || current == '#' || current == '$' || current == '%' || current\
    \ == '&' || current == '*' || current == '+' || current == '-' || current == '='\
    \ || current == '|' || current == ';' || current == ';' || current == ';' || current\
    \ == ';' || current == ';' || current == ';' || current == ';' || current == ';'\
    \ || current == ';' || current == ';' || current == ';' || current == ';' || current\
    \ == ';' || current == ';' || current == ';' || current == ';' || current == ';'\
    \ || current == ';' || current == ';' || current == ';' || current == ';' || current\
    \ == ';' || current == ';' || current == ';' || current == ';' || current == ';'\
    \ || current == ';' || current == ';' || current == ';' || current == ';' || current\
    \ == ';' || current == ';' || current == ';' || current == ';' || current == ';'\
    \ || current == ';' || current == ';' || current == ';' || current == ';' || current\
    \ == ';' || current == ';' || current == ';' || current == ';' || current == ';'\
    \ || current == ';' || current == ';' || current == ';' || current == ';' || current\
    \ == ';' || current == ';' || current == ';' || current == ';' || current == ';'\
    \ || current == ';' || current == ';' || current == ';' || current == ';' || current\
    \ == ';' || current == ';' || current == ';' || current == ';' || current == ';'\
    \ || current == ';' || current == ';' || current == ';' || current == ';\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n:\
    \ 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3)\
    \ == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n:\
    \ 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"\
    world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s:\
    \ \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1)\
    \ == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpv1ug9r2d.swift:28:23: error: single-quoted string literal found,\
    \ use '\"'\n        if current == ' ' {\n                      ^~~\n         \
    \             \" \"\n/tmp/tmpv1ug9r2d.swift:33:23: error: single-quoted string\
    \ literal found, use '\"'\n        if current == '.' || current == ',' || current\
    \ == ' ' || current == '!' || current == '?' || current == ';' || current == '?'\
    \ || current == '!' || current == ';' || current == '-' || current == '_' || current\
    \ == '*' || current == '?' || current == '&' || current == '(' || current == ')'\
    \ || current == '[' || current == ']' || current == '{' || current == '}' || current\
    \ == '<' || current == '>' || current == '/' || current == '|' || current == '\\\
    \\' || current == '^' || current == '~' || current == '%' || current == '$' ||\
    \ current == '@' || current == '!' || current == '#' || current == '$' || current\
    \ == '%' || current == '&' || current == '*' || current == '+' || current == '-'\
    \ || current == '=' || current == '|' || current == ';' || current == ';' || current\
    \ == ';' || current == ';' || current == ';' || current == ';' || current == ';'\
    \ || current == ';' || current == ';' || current == ';' || current == ';' || current\
    \ == ';' || current == ';' || current == ';' || current == ';' || current == ';'\
    \ || current == ';' || current == ';' || current == ';' || current == ';' || current\
    \ == ';' || current == ';' || current == ';' || current == ';' || current == ';'\
    \ || current == ';' || current == ';' || current == ';' || current == ';' || current\
    \ == ';' || current == ';' || current == ';' || current == ';' || current == ';'\
    \ || current == ';' || current == ';' || current == ';' || current == ';' || current\
    \ == ';' || current == ';' || current == ';' || current == ';' || current == ';'\
    \ || current == ';' || current == ';' || current == ';' || current == ';' || current\
    \ == ';' || current == ';' || current == ';' || current == ';' || current == ';'\
    \ || current == ';' || current == ';' || current == ';' || current == ';' || current\
    \ == ';' || current == ';' || current == ';' || current == '"
  stdout: ''
  timestamp: 1660014411
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"\
    ]\n/// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n\
    /// select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfunc\
    \ select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    var i = 0\n    for letter in s.characters {\n        if letter == \" \" {\n\
    \            if i == n {\n                break\n            }\n            i\
    \ += 1\n            continue\n        }\n        if letter == \"a\" || letter\
    \ == \"e\" || letter == \"i\" || letter == \"o\" || letter == \"u\" {\n      \
    \      if i == n {\n                break\n            }\n            i += 1\n\
    \            continue\n        }\n        if letter == \"y\" {\n            if\
    \ i == n {\n                break\n            }\n            i += 1\n       \
    \     continue\n        }\n        if letter == \"s\" {\n            if i == n\
    \ {\n                break\n            }\n            i += 1\n            continue\n\
    \        }\n        if letter == \"d\" || letter == \"h\" || letter == \"l\" ||\
    \ letter == \"m\" || letter == \"n\" {\n            if i == n {\n            \
    \    break\n            }\n            i += 1\n            continue\n        }\n\
    \        if letter == \"t\" || letter == \"r\" || letter == \"l\" || letter ==\
    \ \"w\" || letter == \"v\" {\n            if i == n {\n                break\n\
    \            }\n            i += 1\n            continue\n        }\n        if\
    \ letter == \"b\" || letter == \"c\" || letter == \"k\" || letter == \"p\" ||\
    \ letter == \"v\" {\n            if i == n {\n                break\n        \
    \    }\n            i += 1\n            continue\n        }\n        if letter\
    \ == \"f\" || letter == \"v\" || letter == \"z\" {\n            if i == n {\n\
    \                break\n            }\n            i += 1\n            continue\n\
    \        }\n        if letter == \"g\" || letter == \"q\" || letter == \"x\" {\n\
    \            if i == n {\n                break\n            }\n            i\
    \ += 1\n            continue\n        }\n        if letter == \"z\" {\n      \
    \      if i == n {\n                break\n            }\n            i += 1\n\
    \            continue\n        }\n        if letter == \"j\" {\n            if\
    \ i == n {\n                break\n            }\n            i += 1\n       \
    \     continue\n        }\n        if letter == \"q\" {\n            if i == n\
    \ {\n                break\n            }\n            i += 1\n            continue\n\
    \        }\n        if letter == \"p\" {\n            if i == n {\n          \
    \      break\n            }\n            i += 1\n            continue\n      \
    \  }\n        if letter == \"k\" {\n            if i == n {\n                break\n\
    \            }\n            i += 1\n            continue\n        }\n        if\
    \ letter == \"l\" {\n            if i == n {\n                break\n        \
    \    }\n            i += 1\n            continue\n        }\n        if letter\
    \ == \"m\" {\n            if i == n {\n                break\n            }\n\
    \            i += 1\n            continue\n        }\n        if letter == \"\
    n\" {\n            if i == n {\n                break\n            }\n       \
    \     i += 1\n            continue\n        }\n        if letter == \"o\" {\n\
    \            if i == n {\n                break\n            }\n            i\
    \ += 1\n            continue\n        }\n        if letter\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"\
    little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\"\
    , \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpcipspa87.swift:143:18: error: expected '{' after 'if' condition\n\
    \        if letter\n                 ^\n/tmp/tmpcipspa87.swift:165:69: error:\
    \ expected '}' at end of brace statement\nassert(select_words(s: \"a b c d e f\"\
    , n: 1) == [\"b\", \"c\", \"d\", \"f\"])\n                                   \
    \                                 ^\n/tmp/tmpcipspa87.swift:13:50: note: to match\
    \ this opening '{'\nfunc select_words(s: String, n: Int) -> [String] {\n     \
    \                                            ^\n/tmp/tmpcipspa87.swift:16:21:\
    \ error: 'characters' is unavailable: Please use String directly\n    for letter\
    \ in s.characters {\n                    ^~~~~~~~~~\nSwift.String:5:16: note:\
    \ 'characters' was obsoleted in Swift 5.0\n    public var characters: String {\
    \ get set }\n               ^\n/tmp/tmpcipspa87.swift:143:12: error: cannot convert\
    \ value of type 'Character' to expected condition type 'Bool'\n        if letter\n\
    \           ^~~~~~\n/tmp/tmpcipspa87.swift:147:6: error: operator functions can\
    \ only be declared at global or in type scope\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660014411
- exit_code: -4
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"\
    ]\n/// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n\
    /// select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfunc\
    \ select_words(s: String, n: Int) -> [String] {\n    return []\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"\
    little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\"\
    , \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: Exception
  stderr: 'tmpszvxx0ul/tmpszvxx0ul.swift:30: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b89c1917c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b89c160eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b89c160e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b89c160d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpszvxx0ul                        0x000055e491c114c4 <unavailable> + 5316

    5    libc.so.6                          0x00002b89c1b03460 __libc_start_main +
    245

    6    tmpszvxx0ul                        0x000055e491c110c9 <unavailable> + 4297

    '
  stdout: ''
  timestamp: 1660014410
- exit_code: -4
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"\
    ]\n/// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n\
    /// select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfunc\
    \ select_words(s: String, n: Int) -> [String] {\n    \n    // Your code here\n\
    \    \n    return []\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s:\
    \ \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"\
    Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: Exception
  stderr: 'tmpa4traokp/tmpa4traokp.swift:33: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1684f48c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b1684c3fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b1684c3f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b1684c3e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpa4traokp                        0x000055d84e2e34c4 <unavailable> + 5316

    5    libc.so.6                          0x00002b1685134460 __libc_start_main +
    245

    6    tmpa4traokp                        0x000055d84e2e30c9 <unavailable> + 4297

    '
  stdout: ''
  timestamp: 1660014411
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"\
    ]\n/// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n\
    /// select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfunc\
    \ select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    \n    if s == \"\" {\n        return result\n    }\n    \n    let vowels\
    \ = \"aeiou\"\n    \n    for char in s.characters {\n        if vowels.contains(String(char))\
    \ {\n            if result.count < n {\n                result.append(String(char))\n\
    \            }\n        }\n    }\n    \n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"\
    little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\"\
    , \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmp5hhi0fsc.swift:22:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n"
  stdout: ''
  timestamp: 1660014410
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"\
    ]\n/// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n\
    /// select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfunc\
    \ select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    var i = 0\n    var j = 0\n    var k = 0\n    var count = 0\n    var word\
    \ = \"\"\n    var words = [String]()\n    \n    while i < s.count {\n        word\
    \ = String(s[i:i+1])\n        if word == \"a\" || word == \"e\" || word == \"\
    i\" || word == \"o\" || word == \"u\" {\n            words.append(word)\n    \
    \        i += 1\n            count += 1\n            if count == n {\n       \
    \         result += words\n                words = [String]()\n              \
    \  count = 0\n            }\n        } else {\n            words.append(word)\n\
    \            i += 1\n        }\n    }\n    \n    if count > 0 {\n        result\
    \ += words\n    }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"\
    ])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"\
    lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpyg0nydzl.swift:23:24: error: extraneous argument label 'i:' in\
    \ subscript\n        word = String(s[i:i+1])\n                       ^~~\n   \
    \                     \n"
  stdout: ''
  timestamp: 1660014411
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"\
    ]\n/// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n\
    /// select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfunc\
    \ select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    \n    if s == \"\" {\n        return result\n    }\n    \n    for char in\
    \ s.characters {\n        if char == \" \" {\n            continue\n        }\n\
    \        \n        if char == \"a\" || char == \"e\" || char == \"i\" || char\
    \ == \"o\" || char == \"u\" {\n            continue\n        }\n        \n   \
    \     if char == \"n\" {\n            if s.characters.count > n {\n          \
    \      continue\n            }\n        }\n        \n        if char == \"t\"\
    \ || char == \"s\" || char == \"h\" {\n            if s.characters.count > n {\n\
    \                continue\n            }\n        }\n        \n        if char\
    \ == \"d\" || char == \"r\" || char == \"b\" || char == \"g\" || char == \"p\"\
    \ {\n            if s.characters.count > n {\n                continue\n     \
    \       }\n        }\n        \n        if char == \"f\" || char == \"v\" || char\
    \ == \"l\" || char == \"m\" || char == \"n\" {\n            if s.characters.count\
    \ > n {\n                continue\n            }\n        }\n        \n      \
    \  if char == \"c\" || char == \"k\" || char == \"q\" || char == \"j\" {\n   \
    \         if s.characters.count > n {\n                continue\n            }\n\
    \        }\n        \n        if char == \"v\" || char == \"s\" || char == \"\
    r\" || char == \"b\" || char == \"g\" || char == \"p\" {\n            if s.characters.count\
    \ > n {\n                continue\n            }\n        }\n        \n      \
    \  if char == \"t\" || char == \"s\" || char == \"h\" {\n            if s.characters.count\
    \ > n {\n                continue\n            }\n        }\n        \n      \
    \  if char == \"d\" || char == \"r\" || char == \"b\" || char == \"g\" || char\
    \ == \"p\" {\n            if s.characters.count > n {\n                continue\n\
    \            }\n        }\n        \n        if char == \"f\" || char == \"v\"\
    \ || char == \"l\" || char == \"m\" || char == \"n\" {\n            if s.characters.count\
    \ > n {\n                continue\n            }\n        }\n        \n      \
    \  if char == \"c\" || char == \"k\" || char == \"q\" || char == \"j\" {\n   \
    \         if s.characters.count > n {\n                continue\n            }\n\
    \        }\n        \n        if char == \"v\" || char == \"s\" || char == \"\
    r\" || char == \"b\" || char == \"g\" || char == \"p\" {\n            if s.characters.count\
    \ > n {\n                continue\n            }\n        }\n        \n      \
    \  if char == \"t\" || char == \"s\" || char == \"h\" {\n            if s.characters.count\
    \ > n {\n                continue\n            }\n        }\n        \n      \
    \  if char == \"d\" || char == \"r\" || char == \"b\" || char == \"g\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n:\
    \ 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3)\
    \ == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n:\
    \ 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"\
    world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s:\
    \ \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1)\
    \ == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmppni0qsvz.swift:101:65: error: unterminated string literal\n   \
    \     if char == \"d\" || char == \"r\" || char == \"b\" || char == \"g\n    \
    \                                                            ^\n/tmp/tmppni0qsvz.swift:123:69:\
    \ error: expected '}' at end of brace statement\nassert(select_words(s: \"a b\
    \ c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])\n                        \
    \                                            ^\n/tmp/tmppni0qsvz.swift:13:50:\
    \ note: to match this opening '{'\nfunc select_words(s: String, n: Int) -> [String]\
    \ {\n                                                 ^\n/tmp/tmppni0qsvz.swift:20:19:\
    \ error: 'characters' is unavailable: Please use String directly\n    for char\
    \ in s.characters {\n                  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmppni0qsvz.swift:30:18: error: 'characters' is unavailable:\
    \ Please use String directly\n            if s.characters.count > n {\n      \
    \           ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in\
    \ Swift 5.0\n    public var characters: String { get set }\n               ^\n\
    /tmp/tmppni0qsvz.swift:36:18: error: 'characters' is unavailable: Please use String\
    \ directly\n            if s.characters.count > n {\n                 ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmppni0qsvz.swift:42:18:\
    \ error: 'characters' is unavailable: Please use String directly\n           \
    \ if s.characters.count > n {\n                 ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmppni0qsvz.swift:48:18: error: 'characters'\
    \ is unavailable: Please use String directly\n            if s.characters.count\
    \ > n {\n                 ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was\
    \ obsoleted in Swift 5.0\n    public var characters: String { get set }\n    \
    \           ^\n/tmp/tmppni0qsvz.swift:54:18: er"
  stdout: ''
  timestamp: 1660014411
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"\
    ]\n/// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n\
    /// select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfunc\
    \ select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    \n    if s == \"\" {\n        return result\n    }\n    \n    var i = 0\n\
    \    var j = 0\n    var k = 0\n    \n    for i < s.count {\n        if s[i] ==\
    \ \" \" {\n            j = i\n            \n            while j < s.count && s[j]\
    \ != \" \" {\n                j += 1\n            }\n            \n          \
    \  k = j\n            \n            while k < s.count && s[k] != \" \" {\n   \
    \             k += 1\n            }\n            \n            if k == j {\n \
    \               result.appendContentsOf(s[i : j])\n            }\n        }\n\
    \        \n        i += 1\n    }\n    \n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"\
    little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\"\
    , \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpfba8357z.swift:24:11: error: expected 'in' after for-each pattern\n\
    \    for i < s.count {\n          ^\n/tmp/tmpfba8357z.swift:24:11: error: unary\
    \ operator cannot be separated from its operand\n    for i < s.count {\n     \
    \     ^~\n           \n/tmp/tmpfba8357z.swift:24:11: error: '<' is not a prefix\
    \ unary operator\n    for i < s.count {\n          ^\n"
  stdout: ''
  timestamp: 1660014411
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"\
    ]\n/// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n\
    /// select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfunc\
    \ select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    \n    if s == \"\" {\n        return result\n    }\n    \n    var i = 0\n\
    \    var j = 0\n    \n    for i < s.count {\n        if s[i] == \" \" {\n    \
    \        j = i\n            \n            while j < s.count && s[j] == \" \" {\n\
    \                j += 1\n            }\n            \n            if j == s.count\
    \ {\n                result.append(\"\\n\")\n            }\n            else {\n\
    \                result.append(String(s[i..j]))\n            }\n            \n\
    \            i = j + 1\n        }\n        \n        if s[i] == \"a\" || s[i]\
    \ == \"e\" || s[i] == \"i\" || s[i] == \"o\" || s[i] == \"u\" {\n            j\
    \ = i\n            \n            while j < s.count && s[j] != \"a\" && s[j] !=\
    \ \"e\" && s[j] != \"i\" && s[j] != \"o\" && s[j] != \"u\" {\n               \
    \ j += 1\n            }\n            \n            if j == s.count {\n       \
    \         result.append(\"\\n\")\n            }\n            else {\n        \
    \        result.append(String(s[i..j]))\n            }\n            \n       \
    \     i = j + 1\n        }\n        \n        if s[i] == \"n\" {\n           \
    \ j = i\n            \n            while j < s.count && s[j] != \"n\" {\n    \
    \            j += 1\n            }\n            \n            if j == s.count\
    \ {\n                result.append(\"\\n\")\n            }\n            else {\n\
    \                result.append(String(s[i..j]))\n            }\n            \n\
    \            i = j + 1\n        }\n        \n        if s[i] == \"t\" || s[i]\
    \ == \"h\" || s[i] == \"e\" || s[i] == \"l\" || s[i] == \"l\" || s[i] == \"o\"\
    \ || s[i] == \"s\" || s[i] == \"s\" {\n            j = i\n            \n     \
    \       while j < s.count && s[j] != \"t\" && s[j] != \"h\" && s[j] != \"e\" &&\
    \ s[j] != \"l\" && s[j] != \"l\" && s[j] != \"o\" && s[j] != \"s\" && s[j] !=\
    \ \"s\" {\n                j += 1\n            }\n            \n            if\
    \ j == s.count {\n                result.append(\"\\n\")\n            }\n    \
    \        else {\n                result.append(String(s[i..j]))\n            }\n\
    \            \n            i = j + 1\n        }\n        \n        if s[i] ==\
    \ \"d\" || s[i] == \"s\" || s[i] == \"s\" || s[i] == \"s\" {\n            j =\
    \ i\n            \n            while j < s.count && s[j] != \"d\" && s[j] != \"\
    s\" && s[j] != \"s\" {\n                j += 1\n            }\n            \n\
    \            if j == s.count {\n                result.append(\"\\n\")\n     \
    \       }\n            else {\n                result.append(String(s[i..j]))\n\
    \            }\n            \n            i = j + 1\n        }\n        \n   \
    \     if s[i] == \"c\" || s[i] == \"h\" || s[i] == \"\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"\
    little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\"\
    , \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmp0rx_oql4.swift:23:11: error: expected 'in' after for-each pattern\n\
    \    for i < s.count {\n          ^\n/tmp/tmp0rx_oql4.swift:23:11: error: unary\
    \ operator cannot be separated from its operand\n    for i < s.count {\n     \
    \     ^~\n           \n/tmp/tmp0rx_oql4.swift:109:50: error: unterminated string\
    \ literal\n        if s[i] == \"c\" || s[i] == \"h\" || s[i] == \"\n         \
    \                                        ^\n/tmp/tmp0rx_oql4.swift:131:69: error:\
    \ expected '}' at end of brace statement\nassert(select_words(s: \"a b c d e f\"\
    , n: 1) == [\"b\", \"c\", \"d\", \"f\"])\n                                   \
    \                                 ^\n/tmp/tmp0rx_oql4.swift:13:50: note: to match\
    \ this opening '{'\nfunc select_words(s: String, n: Int) -> [String] {\n     \
    \                                            ^\n/tmp/tmp0rx_oql4.swift:23:11:\
    \ error: '<' is not a prefix unary operator\n    for i < s.count {\n         \
    \ ^\n/tmp/tmp0rx_oql4.swift:113:6: error: operator functions can only be declared\
    \ at global or in type scope\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660014411
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"\
    ]\n/// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n\
    /// select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfunc\
    \ select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    \n    if s == \"\" {\n        return result\n    }\n    \n    var i = 0\n\
    \    var j = 0\n    \n    for char in s {\n        if char == \" \" {\n      \
    \      if i == n {\n                result.insert(j, String(s[i:j]))\n       \
    \         i = j + 1\n            }\n            j = i\n        } else {\n    \
    \        i += 1\n        }\n    }\n    \n    if i != n {\n        result.insert(j,\
    \ String(s[i:]))\n    }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"\
    little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\"\
    , \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpvbcchvyu.swift:36:37: error: expected expression in list of expressions\n\
    \        result.insert(j, String(s[i:]))\n                                   \
    \ ^\n/tmp/tmpvbcchvyu.swift:26:17: error: instance method 'insert(contentsOf:at:)'\
    \ requires that 'Int' conform to 'Collection'\n                result.insert(j,\
    \ String(s[i:j]))\n                ^\nSwift.RangeReplaceableCollection:7:37: note:\
    \ where 'C' = 'Int'\n    @inlinable public mutating func insert<C>(contentsOf\
    \ newElements: __owned C, at i: Self.Index) where C : Collection, Self.Element\
    \ == C.Element\n                                    ^\n/tmp/tmpvbcchvyu.swift:26:30:\
    \ error: missing argument labels 'contentsOf:at:' in call\n                result.insert(j,\
    \ String(s[i:j]))\n                             ^\n                          \
    \    contentsOf:  at: \n/tmp/tmpvbcchvyu.swift:26:34: error: cannot convert value\
    \ of type 'String' to expected argument type 'Array<String>.Index' (aka 'Int')\n\
    \                result.insert(j, String(s[i:j]))\n                          \
    \       ^\n/tmp/tmpvbcchvyu.swift:26:42: error: extraneous argument label 'i:'\
    \ in subscript\n                result.insert(j, String(s[i:j]))\n           \
    \                              ^~~\n                                         \
    \ \n/tmp/tmpvbcchvyu.swift:36:37: error: missing argument for parameter #1 in\
    \ call\n        result.insert(j, String(s[i:]))\n                            \
    \        ^\n                                    <#String.Index#>\nSwift.String:12:12:\
    \ note: 'subscript(_:)' declared here\n    public subscript(i: String.Index) ->\
    \ Character { get }\n           ^\n/tmp/tmpvbcchvyu.swift:36:22: error: missing\
    \ argument labels 'contentsOf:at:' in call\n        result.insert(j, String(s[i:]))\n\
    \                     ^\n                      contentsOf:  at: \n"
  stdout: ''
  timestamp: 1660014411
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"\
    ]\n/// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n\
    /// select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfunc\
    \ select_words(s: String, n: Int) -> [String] {\n    var words = [String]()\n\
    \    var i = 0\n    var j = 0\n    var k = 0\n    var l = 0\n    var m = 0\n \
    \   var n = 0\n    var o = 0\n    var p = 0\n    var q = 0\n    var r = 0\n  \
    \  var s = 0\n    var t = 0\n    var u = 0\n    var v = 0\n    var w = 0\n   \
    \ var x = 0\n    var y = 0\n    var z = 0\n    var a = 0\n    var b = 0\n    var\
    \ c = 0\n    var d = 0\n    var e = 0\n    var f = 0\n    var g = 0\n    var h\
    \ = 0\n    var i = 0\n    var j = 0\n    var k = 0\n    var l = 0\n    var m =\
    \ 0\n    var n = 0\n    var o = 0\n    var p = 0\n    var q = 0\n    var r = 0\n\
    \    var s = 0\n    var t = 0\n    var u = 0\n    var v = 0\n    var w = 0\n \
    \   var x = 0\n    var y = 0\n    var z = 0\n    var a = 0\n    var b = 0\n  \
    \  var c = 0\n    var d = 0\n    var e = 0\n    var f = 0\n    var g = 0\n   \
    \ var h = 0\n    var i = 0\n    var j = 0\n    var k = 0\n    var l = 0\n    var\
    \ m = 0\n    var n = 0\n    var o = 0\n    var p = 0\n    var q = 0\n    var r\
    \ = 0\n    var s = 0\n    var t = 0\n    var u = 0\n    var v = 0\n    var w =\
    \ 0\n    var x = 0\n    var y = 0\n    var z = 0\n    var a = 0\n    var b = 0\n\
    \    var c = 0\n    var d = 0\n    var e = 0\n    var f = 0\n    var g = 0\n \
    \   var h = 0\n    var i = 0\n    var j = 0\n    var k = 0\n    var l = 0\n  \
    \  var m = 0\n    var n = 0\n    var o = 0\n    var p = 0\n    var q = 0\n   \
    \ var r = 0\n    var s = 0\n    var t = 0\n    var u = 0\n    var v = 0\n    var\
    \ w = 0\n    var x = 0\n    var y = 0\n    var z = 0\n    var a = 0\n    var b\
    \ = 0\n    var c = 0\n    var d = 0\n    var e = 0\n    var f = 0\n    var g =\
    \ 0\n    var h = 0\n    var i = 0\n    var j = 0\n    var k = 0\n    var l = 0\n\
    \    var m = 0\n    var n = 0\n    var o = 0\n    var p = 0\n    var q = 0\n \
    \   var r = 0\n    var s = 0\n    var t = 0\n    var u = 0\n    var v = 0\n  \
    \  var w = 0\n    var x = 0\n    var y = 0\n    var z = 0\n    var a = 0\n   \
    \ var b = 0\n    var c = 0\n    var d = 0\n    var e = 0\n    var f = 0\n    var\
    \ g = 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary\
    \ had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had\
    \ a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple\
    \ white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\"\
    , n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"\
    ])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s:\
    \ \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmprr1kdnls.swift:41:9: error: invalid redeclaration of 'i'\n    var\
    \ i = 0\n        ^\n/tmp/tmprr1kdnls.swift:15:9: note: 'i' previously declared\
    \ here\n    var i = 0\n        ^\n/tmp/tmprr1kdnls.swift:42:9: error: invalid\
    \ redeclaration of 'j'\n    var j = 0\n        ^\n/tmp/tmprr1kdnls.swift:16:9:\
    \ note: 'j' previously declared here\n    var j = 0\n        ^\n/tmp/tmprr1kdnls.swift:43:9:\
    \ error: invalid redeclaration of 'k'\n    var k = 0\n        ^\n/tmp/tmprr1kdnls.swift:17:9:\
    \ note: 'k' previously declared here\n    var k = 0\n        ^\n/tmp/tmprr1kdnls.swift:44:9:\
    \ error: invalid redeclaration of 'l'\n    var l = 0\n        ^\n/tmp/tmprr1kdnls.swift:18:9:\
    \ note: 'l' previously declared here\n    var l = 0\n        ^\n/tmp/tmprr1kdnls.swift:45:9:\
    \ error: invalid redeclaration of 'm'\n    var m = 0\n        ^\n/tmp/tmprr1kdnls.swift:19:9:\
    \ note: 'm' previously declared here\n    var m = 0\n        ^\n/tmp/tmprr1kdnls.swift:46:9:\
    \ error: invalid redeclaration of 'n'\n    var n = 0\n        ^\n/tmp/tmprr1kdnls.swift:20:9:\
    \ note: 'n' previously declared here\n    var n = 0\n        ^\n/tmp/tmprr1kdnls.swift:47:9:\
    \ error: invalid redeclaration of 'o'\n    var o = 0\n        ^\n/tmp/tmprr1kdnls.swift:21:9:\
    \ note: 'o' previously declared here\n    var o = 0\n        ^\n/tmp/tmprr1kdnls.swift:48:9:\
    \ error: invalid redeclaration of 'p'\n    var p = 0\n        ^\n/tmp/tmprr1kdnls.swift:22:9:\
    \ note: 'p' previously declared here\n    var p = 0\n        ^\n/tmp/tmprr1kdnls.swift:49:9:\
    \ error: invalid redeclaration of 'q'\n    var q = 0\n        ^\n/tmp/tmprr1kdnls.swift:23:9:\
    \ note: 'q' previously declared here\n    var q = 0\n        ^\n/tmp/tmprr1kdnls.swift:50:9:\
    \ error: invalid redeclaration of 'r'\n    var r = 0\n        ^\n/tmp/tmprr1kdnls.swift:24:9:\
    \ note: 'r' previously declared here\n    var r = 0\n        ^\n/tmp/tmprr1kdnls.swift:51:9:\
    \ error: invalid redeclaration of 's'\n    var s = 0\n        ^\n/tmp/tmprr1kdnls.swift:25:9:\
    \ note: 's' previously declared here\n    var s = 0\n        ^\n/tmp/tmprr1kdnls.swift:52:9:\
    \ error: invalid redeclaration of 't'\n    var t = 0\n        ^\n/tmp/tmprr1k"
  stdout: ''
  timestamp: 1660014410
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"\
    ]\n/// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n\
    /// select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfunc\
    \ select_words(s: String, n: Int) -> [String] {\n    var words = [String]()\n\
    \    var i = 0\n    var j = 0\n    var k = 0\n    var count = 0\n    var lastChar\
    \ = \" \"\n    var lastCharCount = 0\n    var lastWord = \"\"\n    var lastWordCount\
    \ = 0\n    var lastWordLength = 0\n    var lastWordChar = \"\"\n    var lastWordCharCount\
    \ = 0\n    var lastWordCharLength = 0\n    var lastWordCharCount = 0\n    var\
    \ lastWordCharLength = 0\n    var lastWordCharCount = 0\n    var lastWordCharLength\
    \ = 0\n    var lastWordCharCount = 0\n    var lastWordCharLength = 0\n    var\
    \ lastWordCharCount = 0\n    var lastWordCharLength = 0\n    var lastWordCharCount\
    \ = 0\n    var lastWordCharLength = 0\n    var lastWordCharCount = 0\n    var\
    \ lastWordCharLength = 0\n    var lastWordCharCount = 0\n    var lastWordCharLength\
    \ = 0\n    var lastWordCharCount = 0\n    var lastWordCharLength = 0\n    var\
    \ lastWordCharCount = 0\n    var lastWordCharLength = 0\n    var lastWordCharCount\
    \ = 0\n    var lastWordCharLength = 0\n    var lastWordCharCount = 0\n    var\
    \ lastWordCharLength = 0\n    var lastWordCharCount = 0\n    var lastWordCharLength\
    \ = 0\n    var lastWordCharCount = 0\n    var lastWordCharLength = 0\n    var\
    \ lastWordCharCount = 0\n    var lastWordCharLength = 0\n    var lastWordCharCount\
    \ = 0\n    var lastWordCharLength = 0\n    var lastWordCharCount = 0\n    var\
    \ lastWordCharLength = 0\n    var lastWordCharCount = 0\n    var lastWordCharLength\
    \ = 0\n    var lastWordCharCount = 0\n    var lastWordCharLength = 0\n    var\
    \ lastWordCharCount = 0\n    var lastWordCharLength = 0\n    var lastWordCharCount\
    \ = 0\n    var lastWordCharLength = 0\n    var lastWordCharCount = 0\n    var\
    \ lastWordCharLength = 0\n    var lastWordCharCount = 0\n    var lastWordCharLength\
    \ = 0\n    var lastWordCharCount = 0\n    var lastWordCharLength = 0\n    var\
    \ lastWordCharCount = 0\n    var lastWordCharLength = 0\n    var lastWordCharCount\
    \ = 0\n    var lastWordCharLength = 0\n    var lastWordCharCount = 0\n    var\
    \ lastWordCharLength = 0\n    var lastWordCharCount = 0\n    var lastWordCharLength\
    \ = 0\n    var lastWordCharCount = 0\n    var lastWordCharLength = 0\n    var\
    \ lastWordCharCount = 0\n    var lastWordCharLength = 0\n    var lastWordCharCount\
    \ = 0\n    var lastWordCharLength = 0\n    var lastWordCharCount = 0\n    var\
    \ lastWordCharLength = 0\n    var lastWordCharCount = 0\n    var \n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n:\
    \ 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3)\
    \ == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n:\
    \ 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"\
    world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s:\
    \ \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1)\
    \ == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpl1n75ep7.swift:90:8: error: expected pattern\n    var \n      \
    \ ^\n/tmp/tmpl1n75ep7.swift:27:9: error: invalid redeclaration of 'lastWordCharCount'\n\
    \    var lastWordCharCount = 0\n        ^\n/tmp/tmpl1n75ep7.swift:25:9: note:\
    \ 'lastWordCharCount' previously declared here\n    var lastWordCharCount = 0\n\
    \        ^\n/tmp/tmpl1n75ep7.swift:28:9: error: invalid redeclaration of 'lastWordCharLength'\n\
    \    var lastWordCharLength = 0\n        ^\n/tmp/tmpl1n75ep7.swift:26:9: note:\
    \ 'lastWordCharLength' previously declared here\n    var lastWordCharLength =\
    \ 0\n        ^\n/tmp/tmpl1n75ep7.swift:29:9: error: invalid redeclaration of 'lastWordCharCount'\n\
    \    var lastWordCharCount = 0\n        ^\n/tmp/tmpl1n75ep7.swift:25:9: note:\
    \ 'lastWordCharCount' previously declared here\n    var lastWordCharCount = 0\n\
    \        ^\n/tmp/tmpl1n75ep7.swift:30:9: error: invalid redeclaration of 'lastWordCharLength'\n\
    \    var lastWordCharLength = 0\n        ^\n/tmp/tmpl1n75ep7.swift:26:9: note:\
    \ 'lastWordCharLength' previously declared here\n    var lastWordCharLength =\
    \ 0\n        ^\n/tmp/tmpl1n75ep7.swift:31:9: error: invalid redeclaration of 'lastWordCharCount'\n\
    \    var lastWordCharCount = 0\n        ^\n/tmp/tmpl1n75ep7.swift:25:9: note:\
    \ 'lastWordCharCount' previously declared here\n    var lastWordCharCount = 0\n\
    \        ^\n/tmp/tmpl1n75ep7.swift:32:9: error: invalid redeclaration of 'lastWordCharLength'\n\
    \    var lastWordCharLength = 0\n        ^\n/tmp/tmpl1n75ep7.swift:26:9: note:\
    \ 'lastWordCharLength' previously declared here\n    var lastWordCharLength =\
    \ 0\n        ^\n/tmp/tmpl1n75ep7.swift:33:9: error: invalid redeclaration of 'lastWordCharCount'\n\
    \    var lastWordCharCount = 0\n        ^\n/tmp/tmpl1n75ep7.swift:25:9: note:\
    \ 'lastWordCharCount' previously declared here\n    var lastWordCharCount = 0\n\
    \        ^\n/tmp/tmpl1n75ep7.swift:34:9: error: invalid redeclaration of 'lastWordCharLength'\n\
    \    var lastWordCharLength = 0\n        ^\n/tmp/tmpl1n75ep7.swift:26:9: note:\
    \ 'lastWordCharLength' previously declared here\n    var lastWordCharLength =\
    \ 0\n        ^\n/tmp/tmpl1n75ep7.swift:35:9: erro"
  stdout: ''
  timestamp: 1660014411
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"\
    ]\n/// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n\
    /// select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfunc\
    \ select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    \n    if s == \"\" {\n        return result\n    }\n    \n    let vowels\
    \ = \"aeiouAEIOU\"\n    \n    let vowelsSet = Set(vowels)\n    \n    let vowelsCount\
    \ = vowels.characters.count\n    \n    let vowelsSetCount = vowelsSet.count\n\
    \    \n    let vowelsSetCount = vowelsSet.characters.count\n    \n    let vowelsSetCount\
    \ = vowelsSet.characters.count\n    \n    let vowelsSetCount = vowelsSet.characters.count\n\
    \    \n    let vowelsSetCount = vowelsSet.characters.count\n    \n    let vowelsSetCount\
    \ = vowelsSet.characters.count\n    \n    let vowelsSetCount = vowelsSet.characters.count\n\
    \    \n    let vowelsSetCount = vowelsSet.characters.count\n    \n    let vowelsSetCount\
    \ = vowelsSet.characters.count\n    \n    let vowelsSetCount = vowelsSet.characters.count\n\
    \    \n    let vowelsSetCount = vowelsSet.characters.count\n    \n    let vowelsSetCount\
    \ = vowelsSet.characters.count\n    \n    let vowelsSetCount = vowelsSet.characters.count\n\
    \    \n    let vowelsSetCount = vowelsSet.characters.count\n    \n    let vowelsSetCount\
    \ = vowelsSet.characters.count\n    \n    let vowelsSetCount = vowelsSet.characters.count\n\
    \    \n    let vowelsSetCount = vowelsSet.characters.count\n    \n    let vowelsSetCount\
    \ = vowelsSet.characters.count\n    \n    let vowelsSetCount = vowelsSet.characters.count\n\
    \    \n    let vowelsSetCount = vowelsSet.characters.count\n    \n    let vowelsSetCount\
    \ = vowelsSet.characters.count\n    \n    let vowelsSetCount = vowelsSet.characters.count\n\
    \    \n    let vowelsSetCount = vowelsSet.characters.count\n    \n    let vowelsSetCount\
    \ = vowelsSet.characters.count\n    \n    let vowelsSetCount = vowelsSet.characters.count\n\
    \    \n    let vowelsSetCount = vowelsSet.characters.count\n    \n    let vowelsSetCount\
    \ = vowelsSet.characters.count\n    \n    let vowelsSetCount = vowelsSet.characters.count\n\
    \    \n    let vowelsSetCount = vowelsSet.characters.count\n    \n    let vowelsSetCount\
    \ = vowelsSet.characters.count\n    \n    let vowelsSetCount = vowelsSet.characters.count\n\
    \    \n    let vowelsSetCount = vowelsSet.characters.count\n    \n    let vowelsSetCount\
    \ = vowelsSet.characters.count\n    \n    let vowelsSetCount = vowelsSet.characters.count\n\
    \    \n    let vowelsSetCount = vowelsSet.characters.count\n    \n    let vowelsSet\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n:\
    \ 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3)\
    \ == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n:\
    \ 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"\
    world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s:\
    \ \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1)\
    \ == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpvqmm6avy.swift:24:30: error: 'characters' is unavailable: Please\
    \ use String directly\n    let vowelsCount = vowels.characters.count\n       \
    \                      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpvqmm6avy.swift:28:36: error: value of type 'Set<String.Element>'\
    \ (aka 'Set<Character>') has no member 'characters'\n    let vowelsSetCount =\
    \ vowelsSet.characters.count\n                         ~~~~~~~~~ ^~~~~~~~~~\n\
    /tmp/tmpvqmm6avy.swift:30:36: error: value of type 'Set<String.Element>' (aka\
    \ 'Set<Character>') has no member 'characters'\n    let vowelsSetCount = vowelsSet.characters.count\n\
    \                         ~~~~~~~~~ ^~~~~~~~~~\n/tmp/tmpvqmm6avy.swift:32:36:\
    \ error: value of type 'Set<String.Element>' (aka 'Set<Character>') has no member\
    \ 'characters'\n    let vowelsSetCount = vowelsSet.characters.count\n        \
    \                 ~~~~~~~~~ ^~~~~~~~~~\n/tmp/tmpvqmm6avy.swift:34:36: error: value\
    \ of type 'Set<String.Element>' (aka 'Set<Character>') has no member 'characters'\n\
    \    let vowelsSetCount = vowelsSet.characters.count\n                       \
    \  ~~~~~~~~~ ^~~~~~~~~~\n/tmp/tmpvqmm6avy.swift:36:36: error: value of type 'Set<String.Element>'\
    \ (aka 'Set<Character>') has no member 'characters'\n    let vowelsSetCount =\
    \ vowelsSet.characters.count\n                         ~~~~~~~~~ ^~~~~~~~~~\n\
    /tmp/tmpvqmm6avy.swift:38:36: error: value of type 'Set<String.Element>' (aka\
    \ 'Set<Character>') has no member 'characters'\n    let vowelsSetCount = vowelsSet.characters.count\n\
    \                         ~~~~~~~~~ ^~~~~~~~~~\n/tmp/tmpvqmm6avy.swift:40:36:\
    \ error: value of type 'Set<String.Element>' (aka 'Set<Character>') has no member\
    \ 'characters'\n    let vowelsSetCount = vowelsSet.characters.count\n        \
    \                 ~~~~~~~~~ ^~~~~~~~~~\n/tmp/tmpvqmm6avy.swift:42:36: error: value\
    \ of type 'Set<String.Element>' (aka 'Set<Character>') has no member 'characters'\n\
    \    let vowelsSetCount = vowelsSet.characters.count\n                   "
  stdout: ''
  timestamp: 1660014411
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"\
    ]\n/// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n\
    /// select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfunc\
    \ select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    \n    if s == \"\" {\n        return result\n    }\n    \n    var i = 0\n\
    \    var j = 0\n    var k = 0\n    \n    for i < s.count {\n        if s[i] ==\
    \ \" \" {\n            j = i\n            \n            for k < s.count {\n  \
    \              if s[k] == \" \" {\n                    k = k + 1\n           \
    \     } else {\n                    break\n                }\n            }\n\
    \            \n            if k == s.count {\n                result.insert(i,\
    \ s.substring(j, s.count))\n                i = i + 1\n            }\n       \
    \ } else {\n            k = k + 1\n        }\n    }\n    \n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n:\
    \ 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3)\
    \ == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n:\
    \ 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"\
    world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s:\
    \ \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1)\
    \ == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpj398186b.swift:24:11: error: expected 'in' after for-each pattern\n\
    \    for i < s.count {\n          ^\n/tmp/tmpj398186b.swift:24:11: error: unary\
    \ operator cannot be separated from its operand\n    for i < s.count {\n     \
    \     ^~\n           \n/tmp/tmpj398186b.swift:28:19: error: expected 'in' after\
    \ for-each pattern\n            for k < s.count {\n                  ^\n/tmp/tmpj398186b.swift:28:19:\
    \ error: unary operator cannot be separated from its operand\n            for\
    \ k < s.count {\n                  ^~\n                   \n/tmp/tmpj398186b.swift:24:11:\
    \ error: '<' is not a prefix unary operator\n    for i < s.count {\n         \
    \ ^\n/tmp/tmpj398186b.swift:28:19: error: '<' is not a prefix unary operator\n\
    \            for k < s.count {\n                  ^\n"
  stdout: ''
  timestamp: 1660014411
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"\
    ]\n/// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n\
    /// select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfunc\
    \ select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    \n    if s == \"\" {\n        return result\n    }\n    \n    for char in\
    \ s.characters {\n        if char.hasConsonant() {\n            if result.count\
    \ < n {\n                result.append(String(char))\n            }\n        }\n\
    \    }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s:\
    \ \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"\
    Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmp0gyzfckj.swift:20:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmp0gyzfckj.swift:21:17:\
    \ error: value of type 'Character' has no member 'hasConsonant'\n        if char.hasConsonant()\
    \ {\n           ~~~~ ^~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014410
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"\
    ]\n/// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n\
    /// select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfunc\
    \ select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    \n    if s == \"\" {\n        return result\n    }\n    \n    for letter\
    \ in s {\n        if letter == \" \" {\n            continue\n        }\n    \
    \    \n        if s.rangeOfCharacter(from: CharacterSet.letters.inverted) != nil\
    \ {\n            if s.rangeOfCharacter(from: CharacterSet.letters) != nil {\n\
    \                if s.rangeOfCharacter(from: CharacterSet.letters.inverted) !=\
    \ nil {\n                    if s.rangeOfCharacter(from: CharacterSet.letters.inverted)\
    \ != nil {\n                        if s.rangeOfCharacter(from: CharacterSet.letters.inverted)\
    \ != nil {\n                            if s.rangeOfCharacter(from: CharacterSet.letters.inverted)\
    \ != nil {\n                                if s.rangeOfCharacter(from: CharacterSet.letters.inverted)\
    \ != nil {\n                                    if s.rangeOfCharacter(from: CharacterSet.letters.inverted)\
    \ != nil {\n                                        if s.rangeOfCharacter(from:\
    \ CharacterSet.letters.inverted) != nil {\n                                  \
    \          if s.rangeOfCharacter(from: CharacterSet.letters.inverted) != nil {\n\
    \                                                if s.rangeOfCharacter(from: CharacterSet.letters.inverted)\
    \ != nil {\n                                                    if s.rangeOfCharacter(from:\
    \ CharacterSet.letters.inverted) != nil {\n                                  \
    \                      if s.rangeOfCharacter(from: CharacterSet.letters.inverted)\
    \ != nil {\n                                                            if s.rangeOfCharacter(from:\
    \ CharacterSet.letters.inverted) != nil {\n                                  \
    \                              if s.rangeOfCharacter(from: CharacterSet.letters.inverted)\
    \ != nil {\n                                                                 \
    \   if s.rangeOfCharacter(from: CharacterSet.letters.inverted) != nil {\n    \
    \                                                                    if s.rangeOfCharacter(from:\
    \ CharacterSet.letters.inverted) != nil {\n                                  \
    \                                          if s.rangeOfCharacter(from: CharacterSet.letters.inverted)\
    \ != nil {\n                                                                 \
    \               if s.rangeOfCharacter(from: CharacterSet.letters.inverted) !=\
    \ nil {\n                                                                    \
    \                if s.rangeOfCharacter(from: CharacterSet.letters.inverted) !=\
    \ nil {\n                                                                    \
    \                    if s.rangeOfCharacter(from: CharacterSet.letters.inverted)\
    \ != nil {\n                                                                 \
    \                           if s.rangeOfCharacter(from: CharacterSet.letters.inverted)\
    \ != nil {\n                                                                 \
    \                               if s.rangeOfCharacter(from: CharacterSet.letters.inverted)\
    \ != nil {\n                                                                 \
    \                                   if s.rangeOfCharacter(from: CharacterSet.letters.inverted)\
    \ != nil {\n                                                                 \
    \                                       if s.rangeOfCharacter(from: CharacterSet.letters.inverted)\
    \ != nil {\n                                                                 \
    \                                           if s.rangeOfCharacter(from: CharacterSet.letters.inverted)\
    \ != nil {\n                                                                 \
    \                                               if s.rangeOfCharacter(from: Character\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n:\
    \ 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3)\
    \ == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n:\
    \ 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"\
    world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s:\
    \ \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1)\
    \ == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmp60bvcmgj.swift:52:1: error: expected ')' in expression list\n}\n\
    ^\n/tmp/tmp60bvcmgj.swift:51:134: note: to match this opening '('\n          \
    \                                                                            \
    \                          if s.rangeOfCharacter(from: Character\n           \
    \                                                                            \
    \                                              ^\n/tmp/tmp60bvcmgj.swift:73:69:\
    \ error: expected '}' at end of brace statement\nassert(select_words(s: \"a b\
    \ c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])\n                        \
    \                                            ^\n/tmp/tmp60bvcmgj.swift:49:171:\
    \ note: to match this opening '{'\n                                          \
    \                                                              if s.rangeOfCharacter(from:\
    \ CharacterSet.letters.inverted) != nil {\n                                  \
    \                                                                            \
    \                                                            ^\n/tmp/tmp60bvcmgj.swift:73:69:\
    \ error: expected '}' at end of brace statement\nassert(select_words(s: \"a b\
    \ c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])\n                        \
    \                                            ^\n/tmp/tmp60bvcmgj.swift:48:167:\
    \ note: to match this opening '{'\n                                          \
    \                                                          if s.rangeOfCharacter(from:\
    \ CharacterSet.letters.inverted) != nil {\n                                  \
    \                                                                            \
    \                                                        ^\n/tmp/tmp60bvcmgj.swift:73:69:\
    \ error: expected '}' at end of brace statement\nassert(select_words(s: \"a b\
    \ c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])\n                        \
    \                                            ^\n/tmp/tmp60bvcmgj.swift:47:163:\
    \ note: to match this opening '{'\n                                          \
    \                                                      if s.rangeOfCharac"
  stdout: ''
  timestamp: 1660014411
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"\
    ]\n/// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n\
    /// select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfunc\
    \ select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    \n    if s == \"\" {\n        return result\n    }\n    \n    var i = 0\n\
    \    var j = 0\n    \n    while i < s.count {\n        if s[i] == \" \" {\n  \
    \          j = i\n            while j < s.count && s[j] != \" \" {\n         \
    \       j += 1\n            }\n            \n            if j == s.count {\n \
    \               i += 1\n            } else {\n                result.insert(s.substringWithRange(NSMakeRange(i,\
    \ j - i)), atIndex: 0)\n                i = j + 1\n            }\n        } else\
    \ {\n            i += 1\n        }\n    }\n    \n    if n == 0 {\n        return\
    \ result\n    }\n    \n    var i = 0\n    var j = 0\n    \n    while i < s.count\
    \ {\n        if s[i] == \" \" {\n            j = i\n            while j < s.count\
    \ && s[j] != \" \" {\n                j += 1\n            }\n            \n  \
    \          if j == s.count {\n                i += 1\n            } else {\n \
    \               result.insert(s.substringWithRange(NSMakeRange(i, j - i)), atIndex:\
    \ 0)\n                i = j + 1\n            }\n        } else {\n           \
    \ i += 1\n        }\n    }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"\
    little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\"\
    , \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpjyyq5ykw.swift:24:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if s[i] ==\
    \ \" \" {\n           ^~~~\nSwift.String:3:12: note: 'subscript(_:)' has been\
    \ explicitly marked unavailable here\n    public subscript(i: Int) -> Character\
    \ { get }\n           ^\n/tmp/tmpjyyq5ykw.swift:26:34: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \            while j < s.count && s[j] != \" \" {\n                          \
    \       ^~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly marked\
    \ unavailable here\n    public subscript(i: Int) -> Character { get }\n      \
    \     ^\n/tmp/tmpjyyq5ykw.swift:33:52: error: cannot find 'NSMakeRange' in scope\n\
    \                result.insert(s.substringWithRange(NSMakeRange(i, j - i)), atIndex:\
    \ 0)\n                                                   ^~~~~~~~~~~\n/tmp/tmpjyyq5ykw.swift:33:24:\
    \ error: no exact matches in call to instance method 'insert'\n              \
    \  result.insert(s.substringWithRange(NSMakeRange(i, j - i)), atIndex: 0)\n  \
    \                     ^\n/tmp/tmpjyyq5ykw.swift:33:24: note: found candidate with\
    \ type '(__owned String, Int) -> ()'\n                result.insert(s.substringWithRange(NSMakeRange(i,\
    \ j - i)), atIndex: 0)\n                       ^\n/tmp/tmpjyyq5ykw.swift:33:33:\
    \ error: value of type 'String' has no member 'substringWithRange'\n         \
    \       result.insert(s.substringWithRange(NSMakeRange(i, j - i)), atIndex: 0)\n\
    \                              ~ ^~~~~~~~~~~~~~~~~~\n/tmp/tmpjyyq5ykw.swift:45:9:\
    \ error: invalid redeclaration of 'i'\n    var i = 0\n        ^\n/tmp/tmpjyyq5ykw.swift:20:9:\
    \ note: 'i' previously declared here\n    var i = 0\n        ^\n/tmp/tmpjyyq5ykw.swift:46:9:\
    \ error: invalid redeclaration of 'j'\n    var j = 0\n        ^\n/tmp/tmpjyyq5ykw.swift:21:9:\
    \ note: 'j' previously declared here\n    var j = 0\n        ^\n/tmp/tmpjyyq5ykw.swift:58:52:\
    \ error: cannot find 'NSMakeRange' in scope\n                result.insert(s.substringWithRange(NSMakeRange(i,\
    \ j - i"
  stdout: ''
  timestamp: 1660014411
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"\
    ]\n/// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n\
    /// select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfunc\
    \ select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    \n    if s == \"\" {\n        return result\n    }\n    \n    var i = 0\n\
    \    var j = 0\n    var k = 0\n    \n    for i < s.count {\n        if s[i] ==\
    \ \" \" {\n            j = i\n            \n            while j < s.count && s[j]\
    \ == \" \" {\n                j += 1\n            }\n            \n          \
    \  if j - i > n {\n                for k = i; k < j; k++ {\n                 \
    \   result.append(String(s[k]))\n                }\n            }\n          \
    \  i = j\n        }\n    }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"\
    little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\"\
    , \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmp4a5nxmkt.swift:24:11: error: expected 'in' after for-each pattern\n\
    \    for i < s.count {\n          ^\n/tmp/tmp4a5nxmkt.swift:24:11: error: unary\
    \ operator cannot be separated from its operand\n    for i < s.count {\n     \
    \     ^~\n           \n/tmp/tmp4a5nxmkt.swift:33:17: error: C-style for statement\
    \ has been removed in Swift 3\n                for k = i; k < j; k++ {\n     \
    \           ^   ~~~~~~~~~~~~~~~~~\n/tmp/tmp4a5nxmkt.swift:24:11: error: '<' is\
    \ not a prefix unary operator\n    for i < s.count {\n          ^\n"
  stdout: ''
  timestamp: 1660014411
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"\
    ]\n/// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n\
    /// select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfunc\
    \ select_words(s: String, n: Int) -> [String] {\n    \n    var words = [String]()\n\
    \    \n    if s == \"\" {\n        return words\n    }\n    \n    var i = 0\n\
    \    var j = 0\n    var k = 0\n    \n    while i < s.count {\n        if s[i]\
    \ == \" \" {\n            j = i\n            while j < s.count && s[j] != \" \"\
    \ {\n                j += 1\n            }\n            k = j\n            while\
    \ k < s.count && s[k] != \" \" {\n                k += 1\n            }\n    \
    \        if k == j {\n                words.append(String(s[i:j]))\n         \
    \   }\n            i = k\n        } else {\n            i += 1\n        }\n  \
    \  }\n    \n    return words\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s:\
    \ \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"\
    Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpxti3skm0.swift:26:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if s[i] ==\
    \ \" \" {\n           ^~~~\nSwift.String:3:12: note: 'subscript(_:)' has been\
    \ explicitly marked unavailable here\n    public subscript(i: Int) -> Character\
    \ { get }\n           ^\n/tmp/tmpxti3skm0.swift:28:34: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \            while j < s.count && s[j] != \" \" {\n                          \
    \       ^~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly marked\
    \ unavailable here\n    public subscript(i: Int) -> Character { get }\n      \
    \     ^\n/tmp/tmpxti3skm0.swift:32:34: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n         \
    \   while k < s.count && s[k] != \" \" {\n                                 ^~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpxti3skm0.swift:36:38:\
    \ error: extraneous argument label 'i:' in subscript\n                words.append(String(s[i:j]))\n\
    \                                     ^~~\n                                  \
    \    \n"
  stdout: ''
  timestamp: 1660014411
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"\
    ]\n/// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n\
    /// select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfunc\
    \ select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    for char in s.characters {\n        if char == \" \" {\n            continue\n\
    \        }\n        if char == \"a\" || char == \"e\" || char == \"i\" || char\
    \ == \"o\" || char == \"u\" {\n            continue\n        }\n        if char\
    \ == \"y\" {\n            continue\n        }\n        if char == \"n\" {\n  \
    \          continue\n        }\n        if char == \"s\" {\n            continue\n\
    \        }\n        if char == \"t\" {\n            continue\n        }\n    \
    \    if char == \"d\" {\n            continue\n        }\n        if char == \"\
    h\" {\n            continue\n        }\n        if char == \"r\" {\n         \
    \   continue\n        }\n        if char == \"l\" {\n            continue\n  \
    \      }\n        if char == \"m\" {\n            continue\n        }\n      \
    \  if char == \"p\" {\n            continue\n        }\n        if char == \"\
    f\" {\n            continue\n        }\n        if char == \"v\" {\n         \
    \   continue\n        }\n        if char == \"b\" {\n            continue\n  \
    \      }\n        if char == \"k\" {\n            continue\n        }\n      \
    \  if char == \"j\" {\n            continue\n        }\n        if char == \"\
    q\" {\n            continue\n        }\n        if char == \"z\" {\n         \
    \   continue\n        }\n        if char == \"x\" {\n            continue\n  \
    \      }\n        if char == \"c\" {\n            continue\n        }\n      \
    \  if char == \"m\" {\n            continue\n        }\n        if char == \"\
    v\" {\n            continue\n        }\n        if char == \"b\" {\n         \
    \   continue\n        }\n        if char == \"k\" {\n            continue\n  \
    \      }\n        if char == \"j\" {\n            continue\n        }\n      \
    \  if char == \"q\" {\n            continue\n        }\n        if char == \"\
    z\" {\n            continue\n        }\n        if char == \"x\" {\n         \
    \   continue\n        }\n        if char == \"c\" {\n            continue\n  \
    \      }\n        if char == \"m\" {\n            continue\n        }\n      \
    \  if char == \"v\" {\n            continue\n        }\n        if char == \"\
    b\" {\n            continue\n        }\n        if char == \"k\" {\n         \
    \   continue\n        }\n        if char == \"j\" {\n            continue\n  \
    \      }\n        if char == \"q\" {\n            continue\n        }\n      \
    \  if char == \"z\" {\n            continue\n        }\n        if char == \"\
    x\" {\n            continue\n        }\n        if char == \"c\" {\n         \
    \   continue\n        }\n        if char == \"m\" {\n            continue\n  \
    \      }\n        if char == \"v\" {\n            continue\n        }\n      \
    \  if char == \"b\" {\n            continue\n        }\n        if char == \"\
    k\" {\n            continue\n        }\n        if char == \"j\" {\n         \
    \   continue\n        }\n\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s:\
    \ \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"\
    Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpmjohee4z.swift:170:69: error: expected '}' at end of brace statement\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])\n\
    \                                                                    ^\n/tmp/tmpmjohee4z.swift:13:50:\
    \ note: to match this opening '{'\nfunc select_words(s: String, n: Int) -> [String]\
    \ {\n                                                 ^\n/tmp/tmpmjohee4z.swift:15:19:\
    \ error: 'characters' is unavailable: Please use String directly\n    for char\
    \ in s.characters {\n                  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n/tmp/tmpmjohee4z.swift:152:6: error: operator functions can\
    \ only be declared at global or in type scope\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n     ^\n/tmp/tmpmjohee4z.swift:14:9: warning: initialization\
    \ of variable 'result' was never used; consider replacing with assignment to '_'\
    \ or removing it\n    var result = [String]()\n    ~~~~^~~~~~\n    _\n"
  stdout: ''
  timestamp: 1660014411
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"\
    ]\n/// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n\
    /// select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfunc\
    \ select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    \n    if s == \"\" {\n        return result\n    }\n    \n    var i = 0\n\
    \    var j = 0\n    \n    for char in s {\n        if char == \" \" {\n      \
    \      i += 1\n        }\n        \n        if char == \"a\" || char == \"e\"\
    \ || char == \"i\" || char == \"o\" || char == \"u\" {\n            j += 1\n \
    \       }\n        \n        if j == n {\n            result.append(String(s[i:j]))\n\
    \            i = j\n            j = 0\n        }\n    }\n    \n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n:\
    \ 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3)\
    \ == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n:\
    \ 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"\
    world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s:\
    \ \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1)\
    \ == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpiokqbi88.swift:33:35: error: extraneous argument label 'i:' in\
    \ subscript\n            result.append(String(s[i:j]))\n                     \
    \             ^~~\n                                   \n"
  stdout: ''
  timestamp: 1660014411
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"\
    ]\n/// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n\
    /// select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfunc\
    \ select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    \n    if s == \"\" {\n        return result\n    }\n    \n    var i = 0\n\
    \    var j = 0\n    \n    for i < s.count {\n        if s[i] == \" \" {\n    \
    \        j = i\n            \n            while j < s.count && s[j] == \" \" {\n\
    \                j += 1\n            }\n            \n            if j == s.count\
    \ {\n                result.append(\"\\n\")\n            }\n            \n   \
    \         i += j - i\n        }\n        \n        if s[i] == \"a\" || s[i] ==\
    \ \"e\" || s[i] == \"i\" || s[i] == \"o\" || s[i] == \"u\" {\n            j =\
    \ i\n            \n            while j < s.count && s[j] != \"a\" && s[j] != \"\
    e\" && s[j] != \"i\" && s[j] != \"o\" && s[j] != \"u\" {\n                j +=\
    \ 1\n            }\n            \n            if j == s.count {\n            \
    \    result.append(\"\\n\")\n            }\n            \n            i += j -\
    \ i\n        }\n        \n        if s[i] == \" \" {\n            j = i\n    \
    \        \n            while j < s.count && s[j] == \" \" {\n                j\
    \ += 1\n            }\n            \n            if j == s.count {\n         \
    \       result.append(\"\\n\")\n            }\n            \n            i +=\
    \ j - i\n        }\n        \n        if s[i] == \"n\" {\n            j = i\n\
    \            \n            while j < s.count && s[j] != \"n\" {\n            \
    \    j += 1\n            }\n            \n            if j == s.count {\n    \
    \            result.append(\"\\n\")\n            }\n            \n           \
    \ i += j - i\n        }\n        \n        if s[i] == \"t\" {\n            j =\
    \ i\n            \n            while j < s.count && s[j] != \"t\" {\n        \
    \        j += 1\n            }\n            \n            if j == s.count {\n\
    \                result.append(\"\\n\")\n            }\n            \n       \
    \     i += j - i\n        }\n        \n        if s[i] == \"h\" {\n          \
    \  j = i\n            \n            while j < s.count && s[j] != \"h\" {\n   \
    \             j += 1\n            }\n            \n            if j == s.count\
    \ {\n                result.append(\"\\n\")\n            }\n            \n   \
    \         i += j - i\n        }\n        \n        if s[i] == \"a\" || s[i] ==\
    \ \"e\" || s[i] == \"i\" || s[i] == \"o\" || s[i] == \"u\" {\n            j =\
    \ i\n            \n            while j < s.count && s[j] != \"a\" && s[j] != \"\
    e\" && s[j] != \"i\" && s[j] != \"o\" && s[j] != \"u\" {\n                j +=\
    \ 1\n            }\n            \n            if j == s.count {\n            \
    \    result.append(\"\\n\")\n            }\n            \n            i += j -\
    \ \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(select_words(s: \"Mary had a\
    \ little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little\
    \ lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white\
    \ space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n:\
    \ 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"\
    ])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s:\
    \ \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpvmi3nbnv.swift:23:11: error: expected 'in' after for-each pattern\n\
    \    for i < s.count {\n          ^\n/tmp/tmpvmi3nbnv.swift:23:11: error: unary\
    \ operator cannot be separated from its operand\n    for i < s.count {\n     \
    \     ^~\n           \n/tmp/tmpvmi3nbnv.swift:120:1: error: expected expression\
    \ after operator\n}\n^\n/tmp/tmpvmi3nbnv.swift:141:69: error: expected '}' at\
    \ end of brace statement\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"\
    b\", \"c\", \"d\", \"f\"])\n                                                 \
    \                   ^\n/tmp/tmpvmi3nbnv.swift:23:21: note: to match this opening\
    \ '{'\n    for i < s.count {\n                    ^\n/tmp/tmpvmi3nbnv.swift:141:69:\
    \ error: expected '}' at end of brace statement\nassert(select_words(s: \"a b\
    \ c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])\n                        \
    \                                            ^\n/tmp/tmpvmi3nbnv.swift:13:50:\
    \ note: to match this opening '{'\nfunc select_words(s: String, n: Int) -> [String]\
    \ {\n                                                 ^\n/tmp/tmpvmi3nbnv.swift:23:11:\
    \ error: '<' is not a prefix unary operator\n    for i < s.count {\n         \
    \ ^\n"
  stdout: ''
  timestamp: 1660014411
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"\
    ]\n/// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n\
    /// select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfunc\
    \ select_words(s: String, n: Int) -> [String] {\n    var words = [String]()\n\
    \    \n    if s == \"\" {\n        return words\n    }\n    \n    for c in s.characters\
    \ {\n        if c == \" \" {\n            continue\n        }\n        \n    \
    \    if c.isConsonant() {\n            if n == 1 {\n                words.append(s)\n\
    \            } else {\n                words.append(s[s.startIndex.advancedBy(c.startIndex)])\n\
    \            }\n        }\n    }\n    \n    return words\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"\
    little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\"\
    , \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmprb0zmzer.swift:20:16: error: 'characters' is unavailable: Please\
    \ use String directly\n    for c in s.characters {\n               ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmprb0zmzer.swift:25:14:\
    \ error: value of type 'Character' has no member 'isConsonant'\n        if c.isConsonant()\
    \ {\n           ~ ^~~~~~~~~~~\n/tmp/tmprb0zmzer.swift:29:45: error: value of type\
    \ 'String.Index' has no member 'advancedBy'\n                words.append(s[s.startIndex.advancedBy(c.startIndex)])\n\
    \                               ~~~~~~~~~~~~ ^~~~~~~~~~\n/tmp/tmprb0zmzer.swift:29:58:\
    \ error: value of type 'Character' has no member 'startIndex'\n              \
    \  words.append(s[s.startIndex.advancedBy(c.startIndex)])\n                  \
    \                                     ~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014411
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"\
    ]\n/// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n\
    /// select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfunc\
    \ select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    for c in s {\n        if c.isConsonant() {\n            if n == 1 {\n   \
    \             result.append(c)\n            } else {\n                result.appendContentsOf(select_words(c,\
    \ n-1))\n            }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"\
    little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\"\
    , \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpjwiesodh.swift:16:14: error: value of type 'Character' has no member\
    \ 'isConsonant'\n        if c.isConsonant() {\n           ~ ^~~~~~~~~~~\n/tmp/tmpjwiesodh.swift:18:31:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \                result.append(c)\n                              ^\n/tmp/tmpjwiesodh.swift:20:24:\
    \ error: value of type '[String]' has no member 'appendContentsOf'\n         \
    \       result.appendContentsOf(select_words(c, n-1))\n                ~~~~~~\
    \ ^~~~~~~~~~~~~~~~\n/tmp/tmpjwiesodh.swift:20:53: error: missing argument labels\
    \ 's:n:' in call\n                result.appendContentsOf(select_words(c, n-1))\n\
    \                                                    ^\n                     \
    \                                s: n: \n/tmp/tmpjwiesodh.swift:20:54: error:\
    \ cannot convert value of type 'Character' to expected argument type 'String'\n\
    \                result.appendContentsOf(select_words(c, n-1))\n             \
    \                                        ^\n"
  stdout: ''
  timestamp: 1660014411
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"\
    ]\n/// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n\
    /// select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfunc\
    \ select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    \n    if s == \"\" {\n        return result\n    }\n    \n    var i = 0\n\
    \    var j = 0\n    \n    for i < s.count {\n        if s[i] == \" \" {\n    \
    \        j = i\n            \n            while j < s.count && s[j] == \" \" {\n\
    \                j += 1\n            }\n            \n            if j == s.count\
    \ {\n                result.append(\"\\n\")\n            }\n            \n   \
    \         i += j - i\n        }\n        \n        if s[i] == \"a\" || s[i] ==\
    \ \"e\" || s[i] == \"i\" || s[i] == \"o\" || s[i] == \"u\" {\n            j =\
    \ i\n            \n            while j < s.count && s[j] != \"a\" && s[j] != \"\
    e\" && s[j] != \"i\" && s[j] != \"o\" && s[j] != \"u\" {\n                j +=\
    \ 1\n            }\n            \n            if j == s.count {\n            \
    \    result.append(\"\\n\")\n            }\n            \n            i += j -\
    \ i\n        }\n        \n        if s[i] == \"n\" {\n            j = i\n    \
    \        \n            while j < s.count && s[j] != \"n\" {\n                j\
    \ += 1\n            }\n            \n            if j == s.count {\n         \
    \       result.append(\"\\n\")\n            }\n            \n            i +=\
    \ j - i\n        }\n        \n        if s[i] == \"t\" || s[i] == \"h\" || s[i]\
    \ == \"e\" || s[i] == \"l\" || s[i] == \"l\" || s[i] == \"o\" || s[i] == \"s\"\
    \ {\n            j = i\n            \n            while j < s.count && s[j] !=\
    \ \"t\" && s[j] != \"h\" && s[j] != \"e\" && s[j] != \"l\" && s[j] != \"l\" &&\
    \ s[j] != \"o\" && s[j] != \"s\" {\n                j += 1\n            }\n  \
    \          \n            if j == s.count {\n                result.append(\"\\\
    n\")\n            }\n            \n            i += j - i\n        }\n       \
    \ \n        if s[i] == \"d\" || s[i] == \"r\" || s[i] == \"e\" || s[i] == \"s\"\
    \ || s[i] == \"s\" || s[i] == \"s\" {\n            j = i\n            \n     \
    \       while j < s.count && s[j] != \"d\" && s[j] != \"r\" && s[j] != \"e\" &&\
    \ s[j] != \"s\" && s[j] != \"s\" {\n                j += 1\n            }\n  \
    \          \n            if j == s.count {\n                result.append(\"\\\
    n\")\n            }\n            \n            i += j - i\n        }\n       \
    \ \n        if s[i] == \"c\" || s[i] == \"l\" || s[i] == \"a\" || s[i] == \"r\"\
    \ || s[i] == \"e\" || s[i] == \"s\" || s[i] == \"s\" {\n            j = i\n  \
    \          \n            while j < s.count && s[j] != \"c\" && s[j] != \"l\" &&\
    \ s[j] != \"a\" && s[j\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s:\
    \ \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"\
    Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpr91dhydw.swift:23:11: error: expected 'in' after for-each pattern\n\
    \    for i < s.count {\n          ^\n/tmp/tmpr91dhydw.swift:23:11: error: unary\
    \ operator cannot be separated from its operand\n    for i < s.count {\n     \
    \     ^~\n           \n/tmp/tmpr91dhydw.swift:98:1: error: expected ']' in expression\
    \ list\n}\n^\n/tmp/tmpr91dhydw.swift:97:80: note: to match this opening '['\n\
    \            while j < s.count && s[j] != \"c\" && s[j] != \"l\" && s[j] != \"\
    a\" && s[j\n                                                                 \
    \              ^\n/tmp/tmpr91dhydw.swift:119:69: error: expected '}' at end of\
    \ brace statement\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])\n                                                        \
    \            ^\n/tmp/tmpr91dhydw.swift:23:21: note: to match this opening '{'\n\
    \    for i < s.count {\n                    ^\n/tmp/tmpr91dhydw.swift:119:69:\
    \ error: expected '}' at end of brace statement\nassert(select_words(s: \"a b\
    \ c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])\n                        \
    \                                            ^\n/tmp/tmpr91dhydw.swift:13:50:\
    \ note: to match this opening '{'\nfunc select_words(s: String, n: Int) -> [String]\
    \ {\n                                                 ^\n/tmp/tmpr91dhydw.swift:23:11:\
    \ error: '<' is not a prefix unary operator\n    for i < s.count {\n         \
    \ ^\n"
  stdout: ''
  timestamp: 1660014411
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"\
    ]\n/// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n\
    /// select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfunc\
    \ select_words(s: String, n: Int) -> [String] {\n    var words = [String]()\n\
    \    var index = 0\n    var last = 0\n    var count = 0\n    for c in s {\n  \
    \      if c == \" \" {\n            words.append(s[last:index])\n            last\
    \ = index\n            count = 0\n        }\n        if c == \" \" || c == \"\\\
    n\" {\n            words.append(s[last:index])\n            last = index\n   \
    \         count = 0\n        }\n        if c != \"a\" && c != \"e\" && c != \"\
    i\" && c != \"o\" && c != \"u\" {\n            count += 1\n        }\n       \
    \ if count == n {\n            words.append(s[last:index])\n            last =\
    \ index\n            count = 0\n        }\n        index += 1\n    }\n    words.append(s[last:index])\n\
    \    return words\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"\
    Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary\
    \ had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpo3st7ie5.swift:20:27: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n            words.append(s[last:index])\n\
    \                          ^\n/tmp/tmpo3st7ie5.swift:20:27: error: extraneous\
    \ argument label 'last:' in subscript\n            words.append(s[last:index])\n\
    \                          ^~~~~~\n                           \n/tmp/tmpo3st7ie5.swift:25:27:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            words.append(s[last:index])\n                          ^\n/tmp/tmpo3st7ie5.swift:25:27:\
    \ error: extraneous argument label 'last:' in subscript\n            words.append(s[last:index])\n\
    \                          ^~~~~~\n                           \n/tmp/tmpo3st7ie5.swift:33:27:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \            words.append(s[last:index])\n                          ^\n/tmp/tmpo3st7ie5.swift:33:27:\
    \ error: extraneous argument label 'last:' in subscript\n            words.append(s[last:index])\n\
    \                          ^~~~~~\n                           \n/tmp/tmpo3st7ie5.swift:39:19:\
    \ error: extraneous argument label 'last:' in subscript\n    words.append(s[last:index])\n\
    \                  ^~~~~~\n                   \n/tmp/tmpo3st7ie5.swift:39:19:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \    words.append(s[last:index])\n                  ^\n"
  stdout: ''
  timestamp: 1660014411
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"\
    ]\n/// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n\
    /// select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfunc\
    \ select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    \n    if s == \"\" {\n        return result\n    }\n    \n    for char in\
    \ s.characters {\n        if char.hasConsonant() {\n            if result.count\
    \ < n {\n                result.append(String(char))\n            }\n        }\n\
    \    }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s:\
    \ \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"\
    Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmp0gyzfckj.swift:20:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmp0gyzfckj.swift:21:17:\
    \ error: value of type 'Character' has no member 'hasConsonant'\n        if char.hasConsonant()\
    \ {\n           ~~~~ ^~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014410
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"\
    ]\n/// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n\
    /// select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfunc\
    \ select_words(s: String, n: Int) -> [String] {\n    var words: [String] = []\n\
    \    \n    if s == \"\" {\n        return words\n    }\n    \n    for c in s.characters\
    \ {\n        if c.isConsonant() {\n            if n == 1 {\n                words.append(s)\n\
    \            }\n            else {\n                words.append(s.substringToIndex(s.startIndex.advancedBy(c.isConsonant())))\n\
    \            }\n        }\n    }\n    \n    return words\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"\
    little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\"\
    , \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmp0jk72co5.swift:20:16: error: 'characters' is unavailable: Please\
    \ use String directly\n    for c in s.characters {\n               ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmp0jk72co5.swift:21:14:\
    \ error: value of type 'Character' has no member 'isConsonant'\n        if c.isConsonant()\
    \ {\n           ~ ^~~~~~~~~~~\n/tmp/tmp0jk72co5.swift:26:32: error: value of type\
    \ 'String' has no member 'substringToIndex'\n                words.append(s.substringToIndex(s.startIndex.advancedBy(c.isConsonant())))\n\
    \                             ~ ^~~~~~~~~~~~~~~~\n/tmp/tmp0jk72co5.swift:26:62:\
    \ error: value of type 'String.Index' has no member 'advancedBy'\n           \
    \     words.append(s.substringToIndex(s.startIndex.advancedBy(c.isConsonant())))\n\
    \                                                ~~~~~~~~~~~~ ^~~~~~~~~~\n/tmp/tmp0jk72co5.swift:26:75:\
    \ error: value of type 'Character' has no member 'isConsonant'\n             \
    \   words.append(s.substringToIndex(s.startIndex.advancedBy(c.isConsonant())))\n\
    \                                                                        ~ ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014411
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"\
    ]\n/// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n\
    /// select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfunc\
    \ select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    \n    if s == \"\" {\n        return result\n    }\n    \n    for char in\
    \ s {\n        if char == \" \" {\n            continue\n        }\n        \n\
    \        if char == \" \" {\n            continue\n        }\n        \n     \
    \   if char == \" \" {\n            continue\n        }\n        \n        if\
    \ char == \" \" {\n            continue\n        }\n        \n        if char\
    \ == \" \" {\n            continue\n        }\n        \n        if char == \"\
    \ \" {\n            continue\n        }\n        \n        if char == \" \" {\n\
    \            continue\n        }\n        \n        if char == \" \" {\n     \
    \       continue\n        }\n        \n        if char == \" \" {\n          \
    \  continue\n        }\n        \n        if char == \" \" {\n            continue\n\
    \        }\n        \n        if char == \" \" {\n            continue\n     \
    \   }\n        \n        if char == \" \" {\n            continue\n        }\n\
    \        \n        if char == \" \" {\n            continue\n        }\n     \
    \   \n        if char == \" \" {\n            continue\n        }\n        \n\
    \        if char == \" \" {\n            continue\n        }\n        \n     \
    \   if char == \" \" {\n            continue\n        }\n        \n        if\
    \ char == \" \" {\n            continue\n        }\n        \n        if char\
    \ == \" \" {\n            continue\n        }\n        \n        if char == \"\
    \ \" {\n            continue\n        }\n        \n        if char == \" \" {\n\
    \            continue\n        }\n        \n        if char == \" \" {\n     \
    \       continue\n        }\n        \n        if char == \" \" {\n          \
    \  continue\n        }\n        \n        if char == \" \" {\n            continue\n\
    \        }\n        \n        if char == \" \" {\n            continue\n     \
    \   }\n        \n        if char == \" \" {\n            continue\n        }\n\
    \        \n        if char == \" \" {\n            continue\n        }\n     \
    \   \n        if char == \" \" {\n            continue\n        }\n        \n\
    \        if char == \" \" {\n            continue\n        }\n        \n     \
    \   if char == \" \" {\n            continue\n        }\n        \n        if\
    \ char == \" \" {\n            continue\n        }\n        \n        if char\
    \ == \" \" {\n            continue\n        }\n        \n        if char == \"\
    \ \" {\n            continue\n        }\n        \n        if char == \" \" {\n\
    \            continue\n        }\n        \n        if char == \" \" {\n     \
    \       continue\n        }\n        \n        if char == \" \" {\n          \
    \  continue\n        }\n        \n        if char == \" \" {\n            continue\n\
    \        }\n        \n        if char == \" \" {\n            continue\n     \
    \   }\n        \n        if char == \" \" {\n\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"\
    ])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"\
    lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpbregee12.swift:192:69: error: expected '}' at end of brace statement\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])\n\
    \                                                                    ^\n/tmp/tmpbregee12.swift:20:19:\
    \ note: to match this opening '{'\n    for char in s {\n                  ^\n\
    /tmp/tmpbregee12.swift:192:69: error: expected '}' at end of brace statement\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])\n\
    \                                                                    ^\n/tmp/tmpbregee12.swift:13:50:\
    \ note: to match this opening '{'\nfunc select_words(s: String, n: Int) -> [String]\
    \ {\n                                                 ^\n/tmp/tmpbregee12.swift:174:6:\
    \ error: operator functions can only be declared at global or in type scope\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n/tmp/tmpbregee12.swift:14:9:\
    \ warning: variable 'result' was never mutated; consider changing to 'let' constant\n\
    \    var result = [String]()\n    ~~~ ^\n    let\n"
  stdout: ''
  timestamp: 1660014411
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"\
    ]\n/// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n\
    /// select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfunc\
    \ select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    \n    if s == \"\" {\n        return result\n    }\n    \n    var i = 0\n\
    \    var j = 0\n    \n    while i < s.count {\n        if s[i] == \" \" {\n  \
    \          i += 1\n            \n            if j == n {\n                result.append(String(s[i..<s.endIndex]))\n\
    \                \n                i = s.endIndex\n                j = 0\n   \
    \         } else {\n                j += 1\n            }\n        } else {\n\
    \            i += 1\n        }\n    }\n    \n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"\
    little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\"\
    , \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpxf7s36_r.swift:24:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if s[i] ==\
    \ \" \" {\n           ^~~~\nSwift.String:3:12: note: 'subscript(_:)' has been\
    \ explicitly marked unavailable here\n    public subscript(i: Int) -> Character\
    \ { get }\n           ^\n/tmp/tmpxf7s36_r.swift:28:40: error: cannot convert value\
    \ of type 'Int' to expected argument type 'String.Index'\n                result.append(String(s[i..<s.endIndex]))\n\
    \                                       ^\n/tmp/tmpxf7s36_r.swift:30:23: error:\
    \ cannot assign value of type 'String.Index' to type 'Int'\n                i\
    \ = s.endIndex\n                    ~~^~~~~~~~\n"
  stdout: ''
  timestamp: 1660014411
- exit_code: -4
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"\
    ]\n/// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n\
    /// select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfunc\
    \ select_words(s: String, n: Int) -> [String] {\n    return []\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"\
    little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\"\
    , \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: Exception
  stderr: 'tmpszvxx0ul/tmpszvxx0ul.swift:30: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b89c1917c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b89c160eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b89c160e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b89c160d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpszvxx0ul                        0x000055e491c114c4 <unavailable> + 5316

    5    libc.so.6                          0x00002b89c1b03460 __libc_start_main +
    245

    6    tmpszvxx0ul                        0x000055e491c110c9 <unavailable> + 4297

    '
  stdout: ''
  timestamp: 1660014410
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"\
    ]\n/// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n\
    /// select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfunc\
    \ select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    \n    if s == \"\" {\n        return result\n    }\n    \n    let vowels\
    \ = \"aeiouAEIOU\"\n    \n    for char in s {\n        if vowels.contains(char)\
    \ {\n            if result.count < n {\n                result.append(char)\n\
    \            }\n        }\n    }\n    \n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"\
    little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\"\
    , \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmprlrpjzh_.swift:25:31: error: cannot convert value of type 'Character'\
    \ to expected argument type 'String'\n                result.append(char)\n  \
    \                            ^\n"
  stdout: ''
  timestamp: 1660014410
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"\
    ]\n/// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n\
    /// select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfunc\
    \ select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    for char in s.characters {\n        if char.hasConsonant() {\n          \
    \  if result.count < n {\n                result.append(String(char))\n      \
    \      }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"\
    ])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"\
    lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmp4qhlv3wh.swift:15:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmp4qhlv3wh.swift:16:17:\
    \ error: value of type 'Character' has no member 'hasConsonant'\n        if char.hasConsonant()\
    \ {\n           ~~~~ ^~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014411
- exit_code: -4
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"\
    ]\n/// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n\
    /// select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfunc\
    \ select_words(s: String, n: Int) -> [String] {\n    return []\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"\
    little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\"\
    , \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: Exception
  stderr: 'tmpszvxx0ul/tmpszvxx0ul.swift:30: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b89c1917c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b89c160eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b89c160e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b89c160d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpszvxx0ul                        0x000055e491c114c4 <unavailable> + 5316

    5    libc.so.6                          0x00002b89c1b03460 __libc_start_main +
    245

    6    tmpszvxx0ul                        0x000055e491c110c9 <unavailable> + 4297

    '
  stdout: ''
  timestamp: 1660014410
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"\
    ]\n/// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n\
    /// select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfunc\
    \ select_words(s: String, n: Int) -> [String] {\n    \n    var result = [String]()\n\
    \    \n    if s == \"\" {\n        return result\n    }\n    \n    var i = 0\n\
    \    var j = 0\n    \n    while i < s.count {\n        if s[i] == \" \" {\n  \
    \          i += 1\n        }\n        \n        if s[i] == \"a\" {\n         \
    \   i += 1\n        }\n        \n        if s[i] == \"e\" {\n            i +=\
    \ 1\n        }\n        \n        if s[i] == \"i\" {\n            i += 1\n   \
    \     }\n        \n        if s[i] == \"o\" {\n            i += 1\n        }\n\
    \        \n        if s[i] == \"u\" {\n            i += 1\n        }\n       \
    \ \n        if s[i] == \"y\" {\n            i += 1\n        }\n        \n    \
    \    if s[i] == \"A\" {\n            i += 1\n        }\n        \n        if s[i]\
    \ == \"E\" {\n            i += 1\n        }\n        \n        if s[i] == \"I\"\
    \ {\n            i += 1\n        }\n        \n        if s[i] == \"O\" {\n   \
    \         i += 1\n        }\n        \n        if s[i] == \"U\" {\n          \
    \  i += 1\n        }\n        \n        if s[i] == \"Y\" {\n            i += 1\n\
    \        }\n        \n        if s[i] == \" \" {\n            i += 1\n       \
    \ }\n        \n        if s[i] == \"b\" {\n            i += 1\n        }\n   \
    \     \n        if s[i] == \"c\" {\n            i += 1\n        }\n        \n\
    \        if s[i] == \"d\" {\n            i += 1\n        }\n        \n       \
    \ if s[i] == \"f\" {\n            i += 1\n        }\n        \n        if s[i]\
    \ == \"g\" {\n            i += 1\n        }\n        \n        if s[i] == \"h\"\
    \ {\n            i += 1\n        }\n        \n        if s[i] == \"j\" {\n   \
    \         i += 1\n        }\n        \n        if s[i] == \"k\" {\n          \
    \  i += 1\n        }\n        \n        if s[i] == \"l\" {\n            i += 1\n\
    \        }\n        \n        if s[i] == \"m\" {\n            i += 1\n       \
    \ }\n        \n        if s[i] == \"n\" {\n            i += 1\n        }\n   \
    \     \n        if s[i] == \"p\" {\n            i += 1\n        }\n        \n\
    \        if s[i] == \"q\" {\n            i += 1\n        }\n        \n       \
    \ if s[i] == \"r\" {\n            i += 1\n        }\n        \n        if s[i]\
    \ == \"s\" {\n            i += 1\n        }\n        \n        if s[i] == \"t\"\
    \ {\n            i += 1\n        }\n        \n        if s[i] == \"v\" {\n   \
    \         i += 1\n        }\n        \n        if s[i] == \"w\" {\n          \
    \  i += 1\n        }\n        \n        if s[i] == \"x\" {\n            i += 1\n\
    \        }\n        \n        if s[i] == \"z\" {\n            i += 1\n       \
    \ }\n        \n\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"\
    Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary\
    \ had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmp6o7abbhi.swift:183:69: error: expected '}' at end of brace statement\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])\n\
    \                                                                    ^\n/tmp/tmp6o7abbhi.swift:13:50:\
    \ note: to match this opening '{'\nfunc select_words(s: String, n: Int) -> [String]\
    \ {\n                                                 ^\n/tmp/tmp6o7abbhi.swift:25:12:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if s[i] == \" \" {\n           ^~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmp6o7abbhi.swift:29:12:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if s[i] == \"a\" {\n           ^~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmp6o7abbhi.swift:33:12:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if s[i] == \"e\" {\n           ^~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmp6o7abbhi.swift:37:12:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if s[i] == \"i\" {\n           ^~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmp6o7abbhi.swift:41:12:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if s[i] == \"o\" {\n           ^~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmp6o7abbhi.swift:45:12:\
    \ error: 'subscript(_:)' "
  stdout: ''
  timestamp: 1660014412
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"\
    ]\n/// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n\
    /// select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfunc\
    \ select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    \n    if s == \"\" {\n        return result\n    }\n    \n    var i = 0\n\
    \    var j = 0\n    var k = 0\n    \n    while i < s.count {\n        if s[i]\
    \ == \" \" {\n            i += 1\n            continue\n        }\n        \n\
    \        if s[i] == \"a\" || s[i] == \"e\" || s[i] == \"i\" || s[i] == \"o\" ||\
    \ s[i] == \"u\" {\n            i += 1\n            continue\n        }\n     \
    \   \n        if s[i] == \"b\" || s[i] == \"c\" || s[i] == \"d\" || s[i] == \"\
    f\" || s[i] == \"g\" || s[i] == \"h\" || s[i] == \"j\" || s[i] == \"k\" || s[i]\
    \ == \"l\" || s[i] == \"m\" || s[i] == \"n\" || s[i] == \"p\" || s[i] == \"q\"\
    \ || s[i] == \"r\" || s[i] == \"s\" || s[i] == \"t\" || s[i] == \"v\" || s[i]\
    \ == \"w\" || s[i] == \"x\" || s[i] == \"y\" || s[i] == \"z\" {\n            i\
    \ += 1\n            continue\n        }\n        \n        if s[i] == \"A\" ||\
    \ s[i] == \"E\" || s[i] == \"I\" || s[i] == \"O\" || s[i] == \"U\" {\n       \
    \     i += 1\n            continue\n        }\n        \n        if s[i] == \"\
    B\" || s[i] == \"C\" || s[i] == \"D\" || s[i] == \"F\" || s[i] == \"G\" || s[i]\
    \ == \"H\" || s[i] == \"J\" || s[i] == \"K\" || s[i] == \"L\" || s[i] == \"M\"\
    \ || s[i] == \"N\" || s[i] == \"P\" || s[i] == \"Q\" || s[i] == \"R\" || s[i]\
    \ == \"S\" || s[i] == \"T\" || s[i] == \"V\" || s[i] == \"W\" || s[i] == \"X\"\
    \ || s[i] == \"Y\" || s[i] == \"Z\" {\n            i += 1\n            continue\n\
    \        }\n        \n        if s[i] == \"0\" {\n            i += 1\n       \
    \     continue\n        }\n        \n        if s[i] == \"1\" {\n            i\
    \ += 1\n            continue\n        }\n        \n        if s[i] == \"2\" {\n\
    \            i += 1\n            continue\n        }\n        \n        if s[i]\
    \ == \"3\" {\n            i += 1\n            continue\n        }\n        \n\
    \        if s[i] == \"4\" {\n            i += 1\n            continue\n      \
    \  }\n        \n        if s[i] == \"5\" {\n            i += 1\n            continue\n\
    \        }\n        \n        if s[i] == \"6\" {\n            i += 1\n       \
    \     continue\n        }\n        \n        if s[i] == \"7\" {\n            i\
    \ += 1\n            continue\n        }\n        \n        if s[i] == \"8\" {\n\
    \            i += 1\n            continue\n        }\n        \n        if s[i]\
    \ == \"9\" {\n            i += 1\n            continue\n        }\n        \n\
    \        if s[i] == \" \" {\n            i += 1\n            continue\n      \
    \  }\n        \n        if s[i] == \"a\" || s[i] == \"e\" || s[i] == \"i\" ||\
    \ s[i] == \"o\" || s[i] == \"u\" {\n            i += 1\n            continue\n\
    \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n:\
    \ 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3)\
    \ == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n:\
    \ 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"\
    world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s:\
    \ \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1)\
    \ == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmp9_jn35kk.swift:130:69: error: expected '}' at end of brace statement\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])\n\
    \                                                                    ^\n/tmp/tmp9_jn35kk.swift:24:23:\
    \ note: to match this opening '{'\n    while i < s.count {\n                 \
    \     ^\n/tmp/tmp9_jn35kk.swift:130:69: error: expected '}' at end of brace statement\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])\n\
    \                                                                    ^\n/tmp/tmp9_jn35kk.swift:13:50:\
    \ note: to match this opening '{'\nfunc select_words(s: String, n: Int) -> [String]\
    \ {\n                                                 ^\n/tmp/tmp9_jn35kk.swift:25:12:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if s[i] == \" \" {\n           ^~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmp9_jn35kk.swift:30:12:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if s[i] == \"a\" || s[i] == \"e\" || s[i]\
    \ == \"i\" || s[i] == \"o\" || s[i] == \"u\" {\n           ^~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmp9_jn35kk.swift:30:27:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if s[i] == \"a\" || s[i] == \"e\" || s[i]\
    \ == \"i\" || s[i] == \"o\" || s[i] == \"u\" {\n                          ^~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmp9_jn35kk.swift:30:42:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if s[i] == \"a\" || s[i] == \"e\" || s[i]\
    \ == \"i\" || s[i] == \"o\" || s[i] == \"u\" {\n                   "
  stdout: ''
  timestamp: 1660014412
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"\
    ]\n/// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n\
    /// select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfunc\
    \ select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    \n    if s == \"\" {\n        return result\n    }\n    \n    var count =\
    \ 0\n    var lastChar = \"\"\n    \n    for char in s {\n        if char == lastChar\
    \ {\n            count += 1\n        } else {\n            if count == n {\n \
    \               result.append(String(lastChar))\n            }\n            count\
    \ = 0\n            lastChar = char\n        }\n    }\n    \n    if count > n {\n\
    \        result.append(String(lastChar))\n    }\n    \n    return result\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n:\
    \ 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3)\
    \ == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n:\
    \ 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"\
    world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s:\
    \ \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1)\
    \ == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmppdkzehb3.swift:24:17: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        if char == lastChar {\n\
    \           ~~~~ ^  ~~~~~~~~\n/tmp/tmppdkzehb3.swift:24:17: note: overloads for\
    \ '==' exist with these partially matching parameter lists: (Character, Character),\
    \ (String, String)\n        if char == lastChar {\n                ^\n/tmp/tmppdkzehb3.swift:31:24:\
    \ error: cannot assign value of type 'Character' to type 'String'\n          \
    \  lastChar = char\n                       ^~~~\n"
  stdout: ''
  timestamp: 1660014411
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"\
    ]\n/// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n\
    /// select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfunc\
    \ select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    if s == \"\" {\n        return result\n    }\n    var i = 0\n    var j =\
    \ 0\n    var k = 0\n    var l = 0\n    var m = 0\n    var n = 0\n    var o = 0\n\
    \    var p = 0\n    var q = 0\n    var r = 0\n    var s = 0\n    var t = 0\n \
    \   var u = 0\n    var v = 0\n    var w = 0\n    var x = 0\n    var y = 0\n  \
    \  var z = 0\n    var a = 0\n    var b = 0\n    var c = 0\n    var d = 0\n   \
    \ var e = 0\n    var f = 0\n    var g = 0\n    var h = 0\n    var i = 0\n    var\
    \ j = 0\n    var k = 0\n    var l = 0\n    var m = 0\n    var n = 0\n    var o\
    \ = 0\n    var p = 0\n    var q = 0\n    var r = 0\n    var s = 0\n    var t =\
    \ 0\n    var u = 0\n    var v = 0\n    var w = 0\n    var x = 0\n    var y = 0\n\
    \    var z = 0\n    var a = 0\n    var b = 0\n    var c = 0\n    var d = 0\n \
    \   var e = 0\n    var f = 0\n    var g = 0\n    var h = 0\n    var i = 0\n  \
    \  var j = 0\n    var k = 0\n    var l = 0\n    var m = 0\n    var n = 0\n   \
    \ var o = 0\n    var p = 0\n    var q = 0\n    var r = 0\n    var s = 0\n    var\
    \ t = 0\n    var u = 0\n    var v = 0\n    var w = 0\n    var x = 0\n    var y\
    \ = 0\n    var z = 0\n    var a = 0\n    var b = 0\n    var c = 0\n    var d =\
    \ 0\n    var e = 0\n    var f = 0\n    var g = 0\n    var h = 0\n    var i = 0\n\
    \    var j = 0\n    var k = 0\n    var l = 0\n    var m = 0\n    var n = 0\n \
    \   var o = 0\n    var p = 0\n    var q = 0\n    var r = 0\n    var s = 0\n  \
    \  var t = 0\n    var u = 0\n    var v = 0\n    var w = 0\n    var x = 0\n   \
    \ var y = 0\n    var z = 0\n    var a = 0\n    var b = 0\n    var c = 0\n    var\
    \ d = 0\n    var e = 0\n    var f = 0\n    var g = 0\n    var h = 0\n    var i\
    \ = 0\n    var j = 0\n    var k = 0\n    var l = 0\n    var m = 0\n    var n =\
    \ 0\n    var o = 0\n    var p = 0\n    var q = 0\n    var r = 0\n    var s = 0\n\
    \    var t = 0\n    var u = 0\n    var v = 0\n    var w = 0\n    var x = 0\n \
    \   var y = 0\n    var z = 0\n    var a = 0\n    var b = 0\n    var c = 0\n  \
    \  var d = 0\n    var e\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s:\
    \ \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"\
    Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpfeo9gyge.swift:44:9: error: invalid redeclaration of 'i'\n    var\
    \ i = 0\n        ^\n/tmp/tmpfeo9gyge.swift:18:9: note: 'i' previously declared\
    \ here\n    var i = 0\n        ^\n/tmp/tmpfeo9gyge.swift:45:9: error: invalid\
    \ redeclaration of 'j'\n    var j = 0\n        ^\n/tmp/tmpfeo9gyge.swift:19:9:\
    \ note: 'j' previously declared here\n    var j = 0\n        ^\n/tmp/tmpfeo9gyge.swift:46:9:\
    \ error: invalid redeclaration of 'k'\n    var k = 0\n        ^\n/tmp/tmpfeo9gyge.swift:20:9:\
    \ note: 'k' previously declared here\n    var k = 0\n        ^\n/tmp/tmpfeo9gyge.swift:47:9:\
    \ error: invalid redeclaration of 'l'\n    var l = 0\n        ^\n/tmp/tmpfeo9gyge.swift:21:9:\
    \ note: 'l' previously declared here\n    var l = 0\n        ^\n/tmp/tmpfeo9gyge.swift:48:9:\
    \ error: invalid redeclaration of 'm'\n    var m = 0\n        ^\n/tmp/tmpfeo9gyge.swift:22:9:\
    \ note: 'm' previously declared here\n    var m = 0\n        ^\n/tmp/tmpfeo9gyge.swift:49:9:\
    \ error: invalid redeclaration of 'n'\n    var n = 0\n        ^\n/tmp/tmpfeo9gyge.swift:23:9:\
    \ note: 'n' previously declared here\n    var n = 0\n        ^\n/tmp/tmpfeo9gyge.swift:50:9:\
    \ error: invalid redeclaration of 'o'\n    var o = 0\n        ^\n/tmp/tmpfeo9gyge.swift:24:9:\
    \ note: 'o' previously declared here\n    var o = 0\n        ^\n/tmp/tmpfeo9gyge.swift:51:9:\
    \ error: invalid redeclaration of 'p'\n    var p = 0\n        ^\n/tmp/tmpfeo9gyge.swift:25:9:\
    \ note: 'p' previously declared here\n    var p = 0\n        ^\n/tmp/tmpfeo9gyge.swift:52:9:\
    \ error: invalid redeclaration of 'q'\n    var q = 0\n        ^\n/tmp/tmpfeo9gyge.swift:26:9:\
    \ note: 'q' previously declared here\n    var q = 0\n        ^\n/tmp/tmpfeo9gyge.swift:53:9:\
    \ error: invalid redeclaration of 'r'\n    var r = 0\n        ^\n/tmp/tmpfeo9gyge.swift:27:9:\
    \ note: 'r' previously declared here\n    var r = 0\n        ^\n/tmp/tmpfeo9gyge.swift:54:9:\
    \ error: invalid redeclaration of 's'\n    var s = 0\n        ^\n/tmp/tmpfeo9gyge.swift:28:9:\
    \ note: 's' previously declared here\n    var s = 0\n        ^\n/tmp/tmpfeo9gyge.swift:55:9:\
    \ error: invalid redeclaration of 't'\n    var t = 0\n        ^\n/tmp/tmpfeo9"
  stdout: ''
  timestamp: 1660014411
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"\
    ]\n/// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n\
    /// select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfunc\
    \ select_words(s: String, n: Int) -> [String] {\n    var words = [String]()\n\
    \    \n    if s == \"\" {\n        return words\n    }\n    \n    for c in s {\n\
    \        if c.isConsonant() {\n            if n == 1 {\n                words.append(c)\n\
    \            } else {\n                words.append(c)\n                n -= 1\n\
    \            }\n        }\n    }\n    \n    return words\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"\
    little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\"\
    , \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpr_evb7h0.swift:21:14: error: value of type 'Character' has no member\
    \ 'isConsonant'\n        if c.isConsonant() {\n           ~ ^~~~~~~~~~~\n/tmp/tmpr_evb7h0.swift:23:30:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \                words.append(c)\n                             ^\n/tmp/tmpr_evb7h0.swift:25:30:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \                words.append(c)\n                             ^\n/tmp/tmpr_evb7h0.swift:26:19:\
    \ error: left side of mutating operator isn't mutable: 'n' is a 'let' constant\n\
    \                n -= 1\n                ~ ^\n"
  stdout: ''
  timestamp: 1660014411
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"\
    ]\n/// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n\
    /// select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfunc\
    \ select_words(s: String, n: Int) -> [String] {\n    var words = [String]()\n\
    \    \n    if s == \"\" {\n        return words\n    }\n    \n    for char in\
    \ s.characters {\n        if char == \" \" {\n            continue\n        }\n\
    \        \n        if char.unicodeScalars.filter({ $0.isConsonant() }).count ==\
    \ n {\n            words.append(String(char))\n        }\n    }\n    \n    return\
    \ words\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary\
    \ had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had\
    \ a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple\
    \ white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\"\
    , n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"\
    ])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s:\
    \ \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpyuonk9xx.swift:20:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpyuonk9xx.swift:25:44:\
    \ error: value of type 'Unicode.Scalar' has no member 'isConsonant'\n        if\
    \ char.unicodeScalars.filter({ $0.isConsonant() }).count == n {\n            \
    \                            ~~ ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014411
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"\
    ]\n/// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n\
    /// select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfunc\
    \ select_words(s: String, n: Int) -> [String] {\n    \n    var words = [String]()\n\
    \    \n    if s == \"\" {\n        return words\n    }\n    \n    for letter in\
    \ s {\n        if letter == \" \" {\n            continue\n        }\n       \
    \ \n        if letter == \"a\" || letter == \"e\" || letter == \"i\" || letter\
    \ == \"o\" || letter == \"u\" {\n            continue\n        }\n        \n \
    \       if letter == \"n\" {\n            if n == 1 {\n                continue\n\
    \            }\n            \n            if n == 2 {\n                words.append(s[s.startIndex..<s.endIndex])\n\
    \                continue\n            }\n            \n            if n == 3\
    \ {\n                words.append(s[s.startIndex..<s.endIndex])\n            \
    \    words.append(s[s.startIndex..<s.endIndex])\n                continue\n  \
    \          }\n            \n            if n == 4 {\n                words.append(s[s.startIndex..<s.endIndex])\n\
    \                words.append(s[s.startIndex..<s.endIndex])\n                words.append(s[s.startIndex..<s.endIndex])\n\
    \                continue\n            }\n            \n            if n == 5\
    \ {\n                words.append(s[s.startIndex..<s.endIndex])\n            \
    \    words.append(s[s.startIndex..<s.endIndex])\n                words.append(s[s.startIndex..<s.endIndex])\n\
    \                words.append(s[s.startIndex..<s.endIndex])\n                continue\n\
    \            }\n            \n            if n == 6 {\n                words.append(s[s.startIndex..<s.endIndex])\n\
    \                words.append(s[s.startIndex..<s.endIndex])\n                words.append(s[s.startIndex..<s.endIndex])\n\
    \                words.append(s[s.startIndex..<s.endIndex])\n                words.append(s[s.startIndex..<s.endIndex])\n\
    \                continue\n            }\n            \n            if n == 7\
    \ {\n                words.append(s[s.startIndex..<s.endIndex])\n            \
    \    words.append(s[s.startIndex..<s.endIndex])\n                words.append(s[s.startIndex..<s.endIndex])\n\
    \                words.append(s[s.startIndex..<s.endIndex])\n                words.append(s[s.startIndex..<s.endIndex])\n\
    \                words.append(s[s.startIndex..<s.endIndex])\n                continue\n\
    \            }\n            \n            if n == 8 {\n                words.append(s[s.startIndex..<s.endIndex])\n\
    \                words.append(s[s.startIndex..<s.endIndex])\n                words.append(s[s.startIndex..<s.endIndex])\n\
    \                words.append(s[s.startIndex..<s.endIndex])\n                words.append(s[s.startIndex\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n:\
    \ 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3)\
    \ == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n:\
    \ 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"\
    world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s:\
    \ \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1)\
    \ == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpb2x6w_bh.swift:86:1: error: expected ']' in expression list\n}\n\
    ^\n/tmp/tmpb2x6w_bh.swift:85:31: note: to match this opening '['\n           \
    \     words.append(s[s.startIndex\n                              ^\n/tmp/tmpb2x6w_bh.swift:107:69:\
    \ error: expected '}' at end of brace statement\nassert(select_words(s: \"a b\
    \ c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])\n                        \
    \                                            ^\n/tmp/tmpb2x6w_bh.swift:30:26:\
    \ note: to match this opening '{'\n        if letter == \"n\" {\n            \
    \             ^\n/tmp/tmpb2x6w_bh.swift:107:69: error: expected '}' at end of\
    \ brace statement\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])\n                                                        \
    \            ^\n/tmp/tmpb2x6w_bh.swift:21:21: note: to match this opening '{'\n\
    \    for letter in s {\n                    ^\n/tmp/tmpb2x6w_bh.swift:107:69:\
    \ error: expected '}' at end of brace statement\nassert(select_words(s: \"a b\
    \ c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])\n                        \
    \                                            ^\n/tmp/tmpb2x6w_bh.swift:13:50:\
    \ note: to match this opening '{'\nfunc select_words(s: String, n: Int) -> [String]\
    \ {\n                                                 ^\n/tmp/tmpb2x6w_bh.swift:36:31:\
    \ error: subscript 'subscript(_:)' requires the types 'String.Index' and 'Int'\
    \ be equivalent\n                words.append(s[s.startIndex..<s.endIndex])\n\
    \                              ^\nSwift.String:5:12: note: where 'R.Bound' = 'String.Index'\n\
    \    public subscript<R>(bounds: R) -> String where R : RangeExpression, R.Bound\
    \ == Int { get }\n           ^\n/tmp/tmpb2x6w_bh.swift:41:31: error: subscript\
    \ 'subscript(_:)' requires the types 'String.Index' and 'Int' be equivalent\n\
    \                words.append(s[s.startIndex..<s.endIndex])\n                \
    \              ^\nSwift.String:5:12: note: where 'R.Bound' = 'String.Index'\n\
    \    public subscript<R>(bounds: R) -> String where R : RangeExpression, R.Bound\
    \ == Int { get }\n           ^\n/tmp/tmpb2x6w_bh.swift:42:31: error: subscript\
    \ '"
  stdout: ''
  timestamp: 1660014411
- exit_code: -4
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"\
    ]\n/// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n\
    /// select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfunc\
    \ select_words(s: String, n: Int) -> [String] {\n    return []\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"\
    little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\"\
    , \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: Exception
  stderr: 'tmpszvxx0ul/tmpszvxx0ul.swift:30: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b89c1917c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b89c160eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b89c160e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b89c160d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpszvxx0ul                        0x000055e491c114c4 <unavailable> + 5316

    5    libc.so.6                          0x00002b89c1b03460 __libc_start_main +
    245

    6    tmpszvxx0ul                        0x000055e491c110c9 <unavailable> + 4297

    '
  stdout: ''
  timestamp: 1660014410
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"\
    ]\n/// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n\
    /// select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfunc\
    \ select_words(s: String, n: Int) -> [String] {\n    var words = [String]()\n\
    \    \n    if s == \"\" {\n        return words\n    }\n    \n    var i = 0\n\
    \    var j = 0\n    var k = 0\n    \n    for i < s.count {\n        if s[i] ==\
    \ \" \" {\n            j = i\n            \n            for k < n {\n        \
    \        j++\n            }\n            \n            if j == s.count {\n   \
    \             words.append(String(s[i:]))\n            }\n        }\n        \n\
    \        i++\n    }\n    \n    return words\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"\
    ])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"\
    lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpbewt9__f.swift:24:11: error: expected 'in' after for-each pattern\n\
    \    for i < s.count {\n          ^\n/tmp/tmpbewt9__f.swift:24:11: error: unary\
    \ operator cannot be separated from its operand\n    for i < s.count {\n     \
    \     ^~\n           \n/tmp/tmpbewt9__f.swift:28:19: error: expected 'in' after\
    \ for-each pattern\n            for k < n {\n                  ^\n/tmp/tmpbewt9__f.swift:28:19:\
    \ error: unary operator cannot be separated from its operand\n            for\
    \ k < n {\n                  ^~\n                   \n/tmp/tmpbewt9__f.swift:33:41:\
    \ error: expected expression in list of expressions\n                words.append(String(s[i:]))\n\
    \                                        ^\n/tmp/tmpbewt9__f.swift:24:11: error:\
    \ '<' is not a prefix unary operator\n    for i < s.count {\n          ^\n/tmp/tmpbewt9__f.swift:28:19:\
    \ error: '<' is not a prefix unary operator\n            for k < n {\n       \
    \           ^\n"
  stdout: ''
  timestamp: 1660014411
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"\
    ]\n/// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n\
    /// select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfunc\
    \ select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    \n    if s == \"\" {\n        return result\n    }\n    \n    var index =\
    \ 0\n    var count = 0\n    \n    for letter in s {\n        if letter == \" \"\
    \ {\n            count += 1\n            if count == n {\n                result.insert(index,\
    \ String(letter))\n                index++\n                count = 0\n      \
    \      }\n        } else {\n            count = 0\n        }\n    }\n    \n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"\
    Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary\
    \ had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpkldmc05e.swift:27:17: error: instance method 'insert(contentsOf:at:)'\
    \ requires that 'Int' conform to 'Collection'\n                result.insert(index,\
    \ String(letter))\n                ^\nSwift.RangeReplaceableCollection:7:37: note:\
    \ where 'C' = 'Int'\n    @inlinable public mutating func insert<C>(contentsOf\
    \ newElements: __owned C, at i: Self.Index) where C : Collection, Self.Element\
    \ == C.Element\n                                    ^\n/tmp/tmpkldmc05e.swift:27:30:\
    \ error: missing argument labels 'contentsOf:at:' in call\n                result.insert(index,\
    \ String(letter))\n                             ^\n                          \
    \    contentsOf:  at: \n/tmp/tmpkldmc05e.swift:27:38: error: cannot convert value\
    \ of type 'String' to expected argument type 'Array<String>.Index' (aka 'Int')\n\
    \                result.insert(index, String(letter))\n                      \
    \               ^\n/tmp/tmpkldmc05e.swift:28:22: error: cannot find operator '++'\
    \ in scope; did you mean '+= 1'?\n                index++\n                  \
    \   ^~\n"
  stdout: ''
  timestamp: 1660014411
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"\
    ]\n/// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n\
    /// select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfunc\
    \ select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    \n    if s == \"\" {\n        return result\n    }\n    \n    var i = 0\n\
    \    var j = 0\n    var k = 0\n    \n    for i < s.count {\n        if s[i] ==\
    \ \" \" {\n            j = i\n            \n            while j < s.count && s[j]\
    \ == \" \" {\n                j += 1\n            }\n            \n          \
    \  if j == s.count {\n                result.append(\"\\n\")\n            }\n\
    \            else {\n                result.append(\"\\n\")\n                result.append(\"\
    \\t\")\n                \n                for k = i; k < j; k++ {\n          \
    \          result.append(s[k])\n                }\n            }\n           \
    \ \n            i = j + 1\n        }\n        \n        if s[i] == \" \" {\n \
    \           j = i\n            \n            while j < s.count && s[j] != \" \"\
    \ {\n                j += 1\n            }\n            \n            if j ==\
    \ s.count {\n                result.append(\"\\n\")\n            }\n         \
    \   else {\n                result.append(\"\\n\")\n                result.append(\"\
    \\t\")\n                \n                for k = i; k < j; k++ {\n          \
    \          result.append(s[k])\n                }\n            }\n           \
    \ \n            i = j + 1\n        }\n        \n        if s[i] == \" \" {\n \
    \           j = i\n            \n            while j < s.count && s[j] != \" \"\
    \ {\n                j += 1\n            }\n            \n            if j ==\
    \ s.count {\n                result.append(\"\\n\")\n            }\n         \
    \   else {\n                result.append(\"\\n\")\n                result.append(\"\
    \\t\")\n                \n                for k = i; k < j; k++ {\n          \
    \          result.append(s[k])\n                }\n            }\n           \
    \ \n            i = j + 1\n        }\n        \n        if s[i] == \" \" {\n \
    \           j = i\n            \n            while j < s.count && s[j] != \" \"\
    \ {\n                j += 1\n            }\n            \n            if j ==\
    \ s.count {\n                result.append(\"\\n\")\n            }\n         \
    \   else {\n                result.append(\"\\n\")\n                result.append(\"\
    \\t\")\n                \n                for k = i; k < j; k++ {\n          \
    \          result.append(s[k])\n                }\n            }\n           \
    \ \n            i = j + 1\n        }\n        \n        if s[i] == \" \" {\n \
    \           j = i\n            \n            while j < s.count && s[j] != \" \"\
    \ {\n                j += 1\n            }\n            \n            if j ==\
    \ s.count {\n                result.append(\"\\n\")\n            }\n         \
    \   else {\n                result.append(\"\\n\")\n                result.append(\"\
    \\t\")\n                \n                for k = i; k < j; k++ {\n          \
    \          result.append(s[k])\n                }\n            }\n           \
    \ \n            i = j + 1\n        }\n        \n        if s[i] == \" \" {\n \
    \           \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"\
    Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary\
    \ had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmprbxadqqi.swift:24:11: error: expected 'in' after for-each pattern\n\
    \    for i < s.count {\n          ^\n/tmp/tmprbxadqqi.swift:24:11: error: unary\
    \ operator cannot be separated from its operand\n    for i < s.count {\n     \
    \     ^~\n           \n/tmp/tmprbxadqqi.swift:39:17: error: C-style for statement\
    \ has been removed in Swift 3\n                for k = i; k < j; k++ {\n     \
    \           ^   ~~~~~~~~~~~~~~~~~\n/tmp/tmprbxadqqi.swift:61:17: error: C-style\
    \ for statement has been removed in Swift 3\n                for k = i; k < j;\
    \ k++ {\n                ^   ~~~~~~~~~~~~~~~~~\n/tmp/tmprbxadqqi.swift:83:17:\
    \ error: C-style for statement has been removed in Swift 3\n                for\
    \ k = i; k < j; k++ {\n                ^   ~~~~~~~~~~~~~~~~~\n/tmp/tmprbxadqqi.swift:105:17:\
    \ error: C-style for statement has been removed in Swift 3\n                for\
    \ k = i; k < j; k++ {\n                ^   ~~~~~~~~~~~~~~~~~\n/tmp/tmprbxadqqi.swift:127:17:\
    \ error: C-style for statement has been removed in Swift 3\n                for\
    \ k = i; k < j; k++ {\n                ^   ~~~~~~~~~~~~~~~~~\n/tmp/tmprbxadqqi.swift:158:69:\
    \ error: expected '}' at end of brace statement\nassert(select_words(s: \"a b\
    \ c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])\n                        \
    \                                            ^\n/tmp/tmprbxadqqi.swift:24:21:\
    \ note: to match this opening '{'\n    for i < s.count {\n                   \
    \ ^\n/tmp/tmprbxadqqi.swift:158:69: error: expected '}' at end of brace statement\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])\n\
    \                                                                    ^\n/tmp/tmprbxadqqi.swift:13:50:\
    \ note: to match this opening '{'\nfunc select_words(s: String, n: Int) -> [String]\
    \ {\n                                                 ^\n/tmp/tmprbxadqqi.swift:24:11:\
    \ error: '<' is not a prefix unary operator\n    for i < s.count {\n         \
    \ ^\n"
  stdout: ''
  timestamp: 1660014411
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"\
    ]\n/// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n\
    /// select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfunc\
    \ select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    \n    if s == \"\" {\n        return result\n    }\n    \n    for char in\
    \ s {\n        if char == \" \" {\n            continue\n        }\n        \n\
    \        if char == \"a\" || char == \"e\" || char == \"i\" || char == \"o\" ||\
    \ char == \"u\" {\n            continue\n        }\n        \n        if char\
    \ == \"n\" {\n            if n == 1 {\n                result.append(s)\n    \
    \        }\n            \n            continue\n        }\n        \n        if\
    \ char == \"c\" || char == \"d\" || char == \"h\" || char == \"r\" || char ==\
    \ \"v\" {\n            if n == 1 {\n                result.append(s)\n       \
    \     }\n            \n            continue\n        }\n        \n        if char\
    \ == \"b\" {\n            if n == 2 {\n                result.append(s)\n    \
    \        }\n            \n            continue\n        }\n        \n        if\
    \ char == \"g\" || char == \"f\" || char == \"j\" || char == \"k\" || char ==\
    \ \"l\" || char == \"m\" || char == \"p\" || char == \"s\" || char == \"t\" ||\
    \ char == \"w\" || char == \"x\" {\n            if n == 2 {\n                result.append(s)\n\
    \            }\n            \n            continue\n        }\n        \n    \
    \    if char == \"z\" {\n            if n == 3 {\n                result.append(s)\n\
    \            }\n            \n            continue\n        }\n        \n    \
    \    if char == \"k\" {\n            if n == 4 {\n                result.append(s)\n\
    \            }\n            \n            continue\n        }\n        \n    \
    \    if char == \"q\" {\n            if n == 5 {\n                result.append(s)\n\
    \            }\n            \n            continue\n        }\n        \n    \
    \    if char == \"p\" {\n            if n == 6 {\n                result.append(s)\n\
    \            }\n            \n            continue\n        }\n        \n    \
    \    if char == \"v\" {\n            if n == 7 {\n                result.append(s)\n\
    \            }\n            \n            continue\n        }\n        \n    \
    \    if char == \"j\" {\n            if n == 8 {\n                result.append(s)\n\
    \            }\n            \n            continue\n        }\n        \n    \
    \    if char == \"q\" {\n            if n == 9 {\n                result.append(s)\n\
    \            }\n            \n            continue\n        }\n        \n    \
    \    if char == \"z\" {\n            if n == 10 {\n                result.append(s)\n\
    \            }\n            \n            continue\n        }\n        \n    \
    \    if char == \"k\" {\n            if n == 11 {\n                result.append(s)\n\
    \            }\n            \n            continue\n        }\n        \n    \
    \    if char == \"p\" {\n            if n == 12 {\n                result.append(s)\n\
    \            }\n            \n            continue\n        }\n        \n    \
    \    if char == \"v\" {\n            if n == 13 {\n                result.append(s)\n\
    \            }\n            \n            continue\n        }\n        \n    \
    \    if char == \"j\" {\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s:\
    \ \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"\
    Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpjrih2gne.swift:171:69: error: expected '}' at end of brace statement\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])\n\
    \                                                                    ^\n/tmp/tmpjrih2gne.swift:20:19:\
    \ note: to match this opening '{'\n    for char in s {\n                  ^\n\
    /tmp/tmpjrih2gne.swift:171:69: error: expected '}' at end of brace statement\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])\n\
    \                                                                    ^\n/tmp/tmpjrih2gne.swift:13:50:\
    \ note: to match this opening '{'\nfunc select_words(s: String, n: Int) -> [String]\
    \ {\n                                                 ^\n/tmp/tmpjrih2gne.swift:153:6:\
    \ error: operator functions can only be declared at global or in type scope\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660014411
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"\
    ]\n/// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n\
    /// select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfunc\
    \ select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    \n    if s == \"\" {\n        return result\n    }\n    \n    for char in\
    \ s.characters {\n        if char == \" \" {\n            continue\n        }\n\
    \        \n        if char.hasConsonant() {\n            if result.count < n {\n\
    \                result.append(String(char))\n            }\n        }\n    }\n\
    \    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s:\
    \ \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"\
    Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmp99p2cj70.swift:20:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmp99p2cj70.swift:25:17:\
    \ error: value of type 'Character' has no member 'hasConsonant'\n        if char.hasConsonant()\
    \ {\n           ~~~~ ^~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014411
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"\
    ]\n/// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n\
    /// select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfunc\
    \ select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    \n    if s == \"\" {\n        return result\n    }\n    \n    for char in\
    \ s {\n        if char == \" \" {\n            continue\n        }\n        \n\
    \        if char == \"a\" || char == \"e\" || char == \"i\" || char == \"o\" ||\
    \ char == \"u\" {\n            continue\n        }\n        \n        if char\
    \ == \"n\" {\n            if n == 1 {\n                result.append(s)\n    \
    \        }\n            \n            continue\n        }\n        \n        if\
    \ char == \"t\" || char == \"s\" || char == \"h\" {\n            if n == 1 {\n\
    \                result.append(s)\n            }\n            \n            continue\n\
    \        }\n        \n        if char == \"d\" || char == \"r\" || char == \"\
    b\" || char == \"g\" || char == \"p\" {\n            if n == 1 {\n           \
    \     result.append(s)\n            }\n            \n            continue\n  \
    \      }\n        \n        if char == \"l\" || char == \"m\" || char == \"k\"\
    \ {\n            if n == 1 {\n                result.append(s)\n            }\n\
    \            \n            continue\n        }\n        \n        if char == \"\
    f\" || char == \"v\" || char == \"y\" {\n            if n == 1 {\n           \
    \     result.append(s)\n            }\n            \n            continue\n  \
    \      }\n        \n        if char == \"w\" || char == \"z\" {\n            if\
    \ n == 1 {\n                result.append(s)\n            }\n            \n  \
    \          continue\n        }\n        \n        if char == \"c\" || char ==\
    \ \"m\" || char == \"p\" {\n            if n == 1 {\n                result.append(s)\n\
    \            }\n            \n            continue\n        }\n        \n    \
    \    if char == \"k\" || char == \"b\" || char == \"j\" || char == \"q\" || char\
    \ == \"x\" {\n            if n == 1 {\n                result.append(s)\n    \
    \        }\n            \n            continue\n        }\n        \n        if\
    \ char == \"v\" || char == \"r\" || char == \"s\" || char == \"x\" {\n       \
    \     if n == 1 {\n                result.append(s)\n            }\n         \
    \   \n            continue\n        }\n        \n        if char == \"m\" || char\
    \ == \"e\" || char == \"r\" || char == \"t\" || char == \"s\" || char == \"x\"\
    \ {\n            if n == 1 {\n                result.append(s)\n            }\n\
    \            \n            continue\n        }\n        \n        if char == \"\
    p\" || char == \"e\" || char == \"s\" || char == \"t\" || char == \"h\" || char\
    \ == \"w\" || char == \"x\" {\n            if n == 1 {\n                result.append(s)\n\
    \            }\n            \n            continue\n        }\n        \n    \
    \    if char == \"v\" || char == \"e\" || char == \"r\" || char == \"t\" || char\
    \ == \"h\" || char == \"w\" || char == \"x\" {\n            if n == 1 {\n    \
    \            result.append(s)\n            }\n            \n            continue\n\
    \        }\n\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"\
    Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary\
    \ had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpaci2kjmy.swift:146:69: error: expected '}' at end of brace statement\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])\n\
    \                                                                    ^\n/tmp/tmpaci2kjmy.swift:13:50:\
    \ note: to match this opening '{'\nfunc select_words(s: String, n: Int) -> [String]\
    \ {\n                                                 ^\n/tmp/tmpaci2kjmy.swift:128:6:\
    \ error: operator functions can only be declared at global or in type scope\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660014411
- exit_code: -4
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"\
    ]\n/// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n\
    /// select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfunc\
    \ select_words(s: String, n: Int) -> [String] {\n    return []\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"\
    little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\"\
    , \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: Exception
  stderr: 'tmpszvxx0ul/tmpszvxx0ul.swift:30: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b89c1917c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b89c160eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b89c160e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b89c160d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpszvxx0ul                        0x000055e491c114c4 <unavailable> + 5316

    5    libc.so.6                          0x00002b89c1b03460 __libc_start_main +
    245

    6    tmpszvxx0ul                        0x000055e491c110c9 <unavailable> + 4297

    '
  stdout: ''
  timestamp: 1660014410
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"\
    ]\n/// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n\
    /// select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfunc\
    \ select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    if s == \"\" {\n        return result\n    }\n    var i = 0\n    var j =\
    \ 0\n    var k = 0\n    for i < s.count {\n        if s[i] == \" \" {\n      \
    \      i += 1\n            continue\n        }\n        if s[i] == \"a\" {\n \
    \           i += 1\n            continue\n        }\n        if s[i] == \"e\"\
    \ {\n            i += 1\n            continue\n        }\n        if s[i] == \"\
    i\" {\n            i += 1\n            continue\n        }\n        if s[i] ==\
    \ \"o\" {\n            i += 1\n            continue\n        }\n        if s[i]\
    \ == \"u\" {\n            i += 1\n            continue\n        }\n        if\
    \ s[i] == \"y\" {\n            i += 1\n            continue\n        }\n     \
    \   if s[i] == \"A\" {\n            i += 1\n            continue\n        }\n\
    \        if s[i] == \"E\" {\n            i += 1\n            continue\n      \
    \  }\n        if s[i] == \"I\" {\n            i += 1\n            continue\n \
    \       }\n        if s[i] == \"O\" {\n            i += 1\n            continue\n\
    \        }\n        if s[i] == \"U\" {\n            i += 1\n            continue\n\
    \        }\n        if s[i] == \"Y\" {\n            i += 1\n            continue\n\
    \        }\n        if s[i] == \"n\" {\n            i += 1\n            continue\n\
    \        }\n        if s[i] == \"h\" {\n            i += 1\n            continue\n\
    \        }\n        if s[i] == \"a\" {\n            i += 1\n            continue\n\
    \        }\n        if s[i] == \"e\" {\n            i += 1\n            continue\n\
    \        }\n        if s[i] == \"i\" {\n            i += 1\n            continue\n\
    \        }\n        if s[i] == \"o\" {\n            i += 1\n            continue\n\
    \        }\n        if s[i] == \"u\" {\n            i += 1\n            continue\n\
    \        }\n        if s[i] == \"y\" {\n            i += 1\n            continue\n\
    \        }\n        if s[i] == \"A\" {\n            i += 1\n            continue\n\
    \        }\n        if s[i] == \"E\" {\n            i += 1\n            continue\n\
    \        }\n        if s[i] == \"I\" {\n            i += 1\n            continue\n\
    \        }\n        if s[i] == \"O\" {\n            i += 1\n            continue\n\
    \        }\n        if s[i] == \"U\" {\n            i += 1\n            continue\n\
    \        }\n        if s[i] == \"Y\" {\n            i += 1\n            continue\n\
    \        }\n        if s[i] == \"n\" {\n            i += 1\n            continue\n\
    \        }\n        if s[i] == \"h\" {\n            i += 1\n            continue\n\
    \        }\n        if s[i] == \"a\" {\n            i += 1\n            continue\n\
    \        }\n        if s[i] == \"e\" {\n            i += 1\n            continue\n\
    \        }\n        if s[i] == \"i\" {\n            i += 1\n            continue\n\
    \        }\n        if s[i] == \"o\" {\n            i += 1\n            continue\n\
    \        }\n        if s[i] == \"u\" {\n            i += 1\n            continue\n\
    \        }\n        if s[i] == \"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s:\
    \ \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"\
    Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpjkdfr_s0.swift:21:11: error: expected 'in' after for-each pattern\n\
    \    for i < s.count {\n          ^\n/tmp/tmpjkdfr_s0.swift:21:11: error: unary\
    \ operator cannot be separated from its operand\n    for i < s.count {\n     \
    \     ^~\n           \n/tmp/tmpjkdfr_s0.swift:158:20: error: unterminated string\
    \ literal\n        if s[i] == \"\n                   ^\n/tmp/tmpjkdfr_s0.swift:180:69:\
    \ error: expected '}' at end of brace statement\nassert(select_words(s: \"a b\
    \ c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])\n                        \
    \                                            ^\n/tmp/tmpjkdfr_s0.swift:13:50:\
    \ note: to match this opening '{'\nfunc select_words(s: String, n: Int) -> [String]\
    \ {\n                                                 ^\n/tmp/tmpjkdfr_s0.swift:21:11:\
    \ error: '<' is not a prefix unary operator\n    for i < s.count {\n         \
    \ ^\n/tmp/tmpjkdfr_s0.swift:162:6: error: operator functions can only be declared\
    \ at global or in type scope\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660014411
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"\
    ]\n/// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n\
    /// select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfunc\
    \ select_words(s: String, n: Int) -> [String] {\n    var words = [String]()\n\
    \    \n    if s == \"\" {\n        return words\n    }\n    \n    for c in s {\n\
    \        if c.isConsonant() {\n            if n == 1 {\n                words.append(c)\n\
    \            } else {\n                words.append(c)\n                n -= 1\n\
    \            }\n        }\n    }\n    \n    return words\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"\
    little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\"\
    , \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpr_evb7h0.swift:21:14: error: value of type 'Character' has no member\
    \ 'isConsonant'\n        if c.isConsonant() {\n           ~ ^~~~~~~~~~~\n/tmp/tmpr_evb7h0.swift:23:30:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \                words.append(c)\n                             ^\n/tmp/tmpr_evb7h0.swift:25:30:\
    \ error: cannot convert value of type 'Character' to expected argument type 'String'\n\
    \                words.append(c)\n                             ^\n/tmp/tmpr_evb7h0.swift:26:19:\
    \ error: left side of mutating operator isn't mutable: 'n' is a 'let' constant\n\
    \                n -= 1\n                ~ ^\n"
  stdout: ''
  timestamp: 1660014411
- exit_code: -4
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"\
    ]\n/// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n\
    /// select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfunc\
    \ select_words(s: String, n: Int) -> [String] {\n    return []\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"\
    little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\"\
    , \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: Exception
  stderr: 'tmpszvxx0ul/tmpszvxx0ul.swift:30: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b89c1917c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b89c160eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b89c160e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b89c160d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpszvxx0ul                        0x000055e491c114c4 <unavailable> + 5316

    5    libc.so.6                          0x00002b89c1b03460 __libc_start_main +
    245

    6    tmpszvxx0ul                        0x000055e491c110c9 <unavailable> + 4297

    '
  stdout: ''
  timestamp: 1660014410
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"\
    ]\n/// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n\
    /// select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfunc\
    \ select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    \n    if s == \"\" {\n        return result\n    }\n    \n    var i = 0\n\
    \    var j = 0\n    var k = 0\n    \n    while i < s.count {\n        if s[i]\
    \ == \" \" {\n            i += 1\n            continue\n        }\n        \n\
    \        if s[i] == \"a\" || s[i] == \"e\" || s[i] == \"i\" || s[i] == \"o\" ||\
    \ s[i] == \"u\" {\n            i += 1\n            continue\n        }\n     \
    \   \n        if s[i] == \"y\" || s[i] == \"a\" || s[i] == \"o\" {\n         \
    \   i += 1\n            continue\n        }\n        \n        if s[i] == \"y\"\
    \ || s[i] == \"e\" || s[i] == \"i\" || s[i] == \"o\" || s[i] == \"u\" {\n    \
    \        i += 1\n            continue\n        }\n        \n        if s[i] ==\
    \ \"y\" || s[i] == \"a\" || s[i] == \"e\" || s[i] == \"i\" || s[i] == \"o\" ||\
    \ s[i] == \"u\" {\n            i += 1\n            continue\n        }\n     \
    \   \n        if s[i] == \"y\" || s[i] == \"a\" || s[i] == \"e\" || s[i] == \"\
    i\" || s[i] == \"o\" || s[i] == \"u\" {\n            i += 1\n            continue\n\
    \        }\n        \n        if s[i] == \"y\" || s[i] == \"a\" || s[i] == \"\
    e\" || s[i] == \"i\" || s[i] == \"o\" || s[i] == \"u\" {\n            i += 1\n\
    \            continue\n        }\n        \n        if s[i] == \"y\" || s[i] ==\
    \ \"a\" || s[i] == \"e\" || s[i] == \"i\" || s[i] == \"o\" || s[i] == \"u\" {\n\
    \            i += 1\n            continue\n        }\n        \n        if s[i]\
    \ == \"y\" || s[i] == \"a\" || s[i] == \"e\" || s[i] == \"i\" || s[i] == \"o\"\
    \ || s[i] == \"u\" {\n            i += 1\n            continue\n        }\n  \
    \      \n        if s[i] == \"y\" || s[i] == \"a\" || s[i] == \"e\" || s[i] ==\
    \ \"i\" || s[i] == \"o\" || s[i] == \"u\" {\n            i += 1\n            continue\n\
    \        }\n        \n        if s[i] == \"y\" || s[i] == \"a\" || s[i] == \"\
    e\" || s[i] == \"i\" || s[i] == \"o\" || s[i] == \"u\" {\n            i += 1\n\
    \            continue\n        }\n        \n        if s[i] == \"y\" || s[i] ==\
    \ \"a\" || s[i] == \"e\" || s[i] == \"i\" || s[i] == \"o\" || s[i] == \"u\" {\n\
    \            i += 1\n            continue\n        }\n        \n        if s[i]\
    \ == \"y\" || s[i] == \"a\" || s[i] == \"e\" || s[i] == \"i\" || s[i] == \"o\"\
    \ || s[i] == \"u\" {\n            i += 1\n            continue\n        }\n  \
    \      \n        if s[i] == \"y\" || s[i] == \"a\" || s[i] == \"e\" || s[i] ==\
    \ \"i\" || s[i] == \"o\" || s[i] == \"u\" {\n            i += 1\n            continue\n\
    \        }\n        \n        if s[i] == \"y\" || s[i] == \"a\" || \n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n:\
    \ 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3)\
    \ == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n:\
    \ 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"\
    world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s:\
    \ \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1)\
    \ == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmp_x0ck6q1.swift:96:1: error: expected expression after operator\n\
    }\n^\n/tmp/tmp_x0ck6q1.swift:117:69: error: expected '}' at end of brace statement\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])\n\
    \                                                                    ^\n/tmp/tmp_x0ck6q1.swift:13:50:\
    \ note: to match this opening '{'\nfunc select_words(s: String, n: Int) -> [String]\
    \ {\n                                                 ^\n/tmp/tmp_x0ck6q1.swift:25:12:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if s[i] == \" \" {\n           ^~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmp_x0ck6q1.swift:30:12:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if s[i] == \"a\" || s[i] == \"e\" || s[i]\
    \ == \"i\" || s[i] == \"o\" || s[i] == \"u\" {\n           ^~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmp_x0ck6q1.swift:30:27:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if s[i] == \"a\" || s[i] == \"e\" || s[i]\
    \ == \"i\" || s[i] == \"o\" || s[i] == \"u\" {\n                          ^~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmp_x0ck6q1.swift:30:42:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if s[i] == \"a\" || s[i] == \"e\" || s[i]\
    \ == \"i\" || s[i] == \"o\" || s[i] == \"u\" {\n                             \
    \            ^~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly\
    \ marked unavailable here\n    public subscript(i: Int) -> Character { get }\n\
    \           ^\n/tmp/tmp_x0ck6q1.swift:30:57: error: 'subscript(_:)' is unavailable:\
    \ cannot "
  stdout: ''
  timestamp: 1660014412
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"\
    ]\n/// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n\
    /// select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfunc\
    \ select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    \n    if s == \"\" {\n        return result\n    }\n    \n    for char in\
    \ s.characters {\n        if char == \" \" {\n            continue\n        }\n\
    \        \n        if char.hasConsonant() {\n            if result.count < n {\n\
    \                result.append(String(char))\n            }\n        }\n    }\n\
    \    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(select_words(s:\
    \ \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"\
    Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmp99p2cj70.swift:20:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmp99p2cj70.swift:25:17:\
    \ error: value of type 'Character' has no member 'hasConsonant'\n        if char.hasConsonant()\
    \ {\n           ~~~~ ^~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014411
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"\
    ]\n/// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n\
    /// select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfunc\
    \ select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    \n    if s == \"\" {\n        return result\n    }\n    \n    var i = 0\n\
    \    var j = 0\n    \n    for char in s {\n        if char == \" \" {\n      \
    \      i += 1\n        }\n        \n        if char == \"a\" || char == \"e\"\
    \ || char == \"i\" || char == \"o\" || char == \"u\" {\n            j += 1\n \
    \       }\n        \n        if j == n {\n            result.append(String(s[i:j]))\n\
    \            i = j\n            j = 0\n        }\n    }\n    \n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(select_words(s: \"Mary had a little lamb\", n:\
    \ 4) == [\"little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3)\
    \ == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple white space\", n:\
    \ 2) == [] as [String])\nassert(select_words(s: \"Hello world\", n: 4) == [\"\
    world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s:\
    \ \"\", n: 4) == [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1)\
    \ == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpiokqbi88.swift:33:35: error: extraneous argument label 'i:' in\
    \ subscript\n            result.append(String(s[i:j]))\n                     \
    \             ^~~\n                                   \n"
  stdout: ''
  timestamp: 1660014411
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"\
    ]\n/// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n\
    /// select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfunc\
    \ select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    \n    if s == \"\" {\n        return result\n    }\n    \n    var index =\
    \ 0\n    var count = 0\n    \n    for letter in s {\n        if letter == \" \"\
    \ {\n            count += 1\n            if count == n {\n                result.insert(index,\
    \ String(letter))\n                index++\n                count = 0\n      \
    \      }\n        } else {\n            count = 0\n        }\n    }\n    \n  \
    \  return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(select_words(s: \"\
    Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary\
    \ had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpkldmc05e.swift:27:17: error: instance method 'insert(contentsOf:at:)'\
    \ requires that 'Int' conform to 'Collection'\n                result.insert(index,\
    \ String(letter))\n                ^\nSwift.RangeReplaceableCollection:7:37: note:\
    \ where 'C' = 'Int'\n    @inlinable public mutating func insert<C>(contentsOf\
    \ newElements: __owned C, at i: Self.Index) where C : Collection, Self.Element\
    \ == C.Element\n                                    ^\n/tmp/tmpkldmc05e.swift:27:30:\
    \ error: missing argument labels 'contentsOf:at:' in call\n                result.insert(index,\
    \ String(letter))\n                             ^\n                          \
    \    contentsOf:  at: \n/tmp/tmpkldmc05e.swift:27:38: error: cannot convert value\
    \ of type 'String' to expected argument type 'Array<String>.Index' (aka 'Int')\n\
    \                result.insert(index, String(letter))\n                      \
    \               ^\n/tmp/tmpkldmc05e.swift:28:22: error: cannot find operator '++'\
    \ in scope; did you mean '+= 1'?\n                index++\n                  \
    \   ^~\n"
  stdout: ''
  timestamp: 1660014411
- exit_code: -4
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"\
    ]\n/// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n\
    /// select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfunc\
    \ select_words(s: String, n: Int) -> [String] {\n    return []\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"\
    little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\"\
    , \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: Exception
  stderr: 'tmpszvxx0ul/tmpszvxx0ul.swift:30: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b89c1917c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b89c160eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b89c160e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b89c160d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpszvxx0ul                        0x000055e491c114c4 <unavailable> + 5316

    5    libc.so.6                          0x00002b89c1b03460 __libc_start_main +
    245

    6    tmpszvxx0ul                        0x000055e491c110c9 <unavailable> + 4297

    '
  stdout: ''
  timestamp: 1660014410
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"\
    ]\n/// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n\
    /// select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfunc\
    \ select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    \n    if s == \"\" {\n        return result\n    }\n    \n    var i = 0\n\
    \    var j = 0\n    \n    for char in s {\n        if char == \" \" {\n      \
    \      j = i\n        }\n        \n        if char == \"a\" || char == \"e\" ||\
    \ char == \"i\" || char == \"o\" || char == \"u\" {\n            i = j\n     \
    \   }\n        \n        if char == \" \" {\n            j = i\n        }\n  \
    \      \n        if char == \" \" {\n            j = i\n        }\n        \n\
    \        if char == \"a\" || char == \"e\" || char == \"i\" || char == \"o\" ||\
    \ char == \"u\" {\n            i = j\n        }\n        \n        if char ==\
    \ \" \" {\n            j = i\n        }\n        \n        if char == \" \" {\n\
    \            j = i\n        }\n        \n        if char == \"a\" || char == \"\
    e\" || char == \"i\" || char == \"o\" || char == \"u\" {\n            i = j\n\
    \        }\n        \n        if char == \" \" {\n            j = i\n        }\n\
    \        \n        if char == \" \" {\n            j = i\n        }\n        \n\
    \        if char == \"a\" || char == \"e\" || char == \"i\" || char == \"o\" ||\
    \ char == \"u\" {\n            i = j\n        }\n        \n        if char ==\
    \ \" \" {\n            j = i\n        }\n        \n        if char == \" \" {\n\
    \            j = i\n        }\n        \n        if char == \"a\" || char == \"\
    e\" || char == \"i\" || char == \"o\" || char == \"u\" {\n            i = j\n\
    \        }\n        \n        if char == \" \" {\n            j = i\n        }\n\
    \        \n        if char == \" \" {\n            j = i\n        }\n        \n\
    \        if char == \"a\" || char == \"e\" || char == \"i\" || char == \"o\" ||\
    \ char == \"u\" {\n            i = j\n        }\n        \n        if char ==\
    \ \" \" {\n            j = i\n        }\n        \n        if char == \" \" {\n\
    \            j = i\n        }\n        \n        if char == \"a\" || char == \"\
    e\" || char == \"i\" || char == \"o\" || char == \"u\" {\n            i = j\n\
    \        }\n        \n        if char == \" \" {\n            j = i\n        }\n\
    \        \n        if char == \" \" {\n            j = i\n        }\n        \n\
    \        if char == \"a\" || char == \"e\" || char == \"i\" || char == \"o\" ||\
    \ char == \"u\" {\n            i = j\n        }\n        \n        if char ==\
    \ \" \" {\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary\
    \ had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had\
    \ a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple\
    \ white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\"\
    , n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"\
    ])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s:\
    \ \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpys410nrd.swift:138:69: error: expected '}' at end of brace statement\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])\n\
    \                                                                    ^\n/tmp/tmpys410nrd.swift:23:19:\
    \ note: to match this opening '{'\n    for char in s {\n                  ^\n\
    /tmp/tmpys410nrd.swift:138:69: error: expected '}' at end of brace statement\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])\n\
    \                                                                    ^\n/tmp/tmpys410nrd.swift:13:50:\
    \ note: to match this opening '{'\nfunc select_words(s: String, n: Int) -> [String]\
    \ {\n                                                 ^\n/tmp/tmpys410nrd.swift:120:6:\
    \ error: operator functions can only be declared at global or in type scope\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n/tmp/tmpys410nrd.swift:14:9:\
    \ warning: variable 'result' was never mutated; consider changing to 'let' constant\n\
    \    var result = [String]()\n    ~~~ ^\n    let\n"
  stdout: ''
  timestamp: 1660014412
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"\
    ]\n/// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n\
    /// select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfunc\
    \ select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    \n    if s == \"\" {\n        return result\n    }\n    \n    var i = 0\n\
    \    var j = 0\n    \n    for i < s.count {\n        if s[i] == \" \" {\n    \
    \        i += 1\n            continue\n        }\n        \n        if s[i] ==\
    \ \" \" {\n            i += 1\n            continue\n        }\n        \n   \
    \     if s[i] == \" \" {\n            i += 1\n            continue\n        }\n\
    \        \n        if s[i] == \" \" {\n            i += 1\n            continue\n\
    \        }\n        \n        if s[i] == \" \" {\n            i += 1\n       \
    \     continue\n        }\n        \n        if s[i] == \" \" {\n            i\
    \ += 1\n            continue\n        }\n        \n        if s[i] == \" \" {\n\
    \            i += 1\n            continue\n        }\n        \n        if s[i]\
    \ == \" \" {\n            i += 1\n            continue\n        }\n        \n\
    \        if s[i] == \" \" {\n            i += 1\n            continue\n      \
    \  }\n        \n        if s[i] == \" \" {\n            i += 1\n            continue\n\
    \        }\n        \n        if s[i] == \" \" {\n            i += 1\n       \
    \     continue\n        }\n        \n        if s[i] == \" \" {\n            i\
    \ += 1\n            continue\n        }\n        \n        if s[i] == \" \" {\n\
    \            i += 1\n            continue\n        }\n        \n        if s[i]\
    \ == \" \" {\n            i += 1\n            continue\n        }\n        \n\
    \        if s[i] == \" \" {\n            i += 1\n            continue\n      \
    \  }\n        \n        if s[i] == \" \" {\n            i += 1\n            continue\n\
    \        }\n        \n        if s[i] == \" \" {\n            i += 1\n       \
    \     continue\n        }\n        \n        if s[i] == \" \" {\n            i\
    \ += 1\n            continue\n        }\n        \n        if s[i] == \" \" {\n\
    \            i += 1\n            continue\n        }\n        \n        if s[i]\
    \ == \" \" {\n            i += 1\n            continue\n        }\n        \n\
    \        if s[i] == \" \" {\n            i += 1\n            continue\n      \
    \  }\n        \n        if s[i] == \" \" {\n            i += 1\n            continue\n\
    \        }\n        \n        if s[i] == \" \" {\n            i += 1\n       \
    \     continue\n        }\n        \n        if s[i] == \" \" {\n            i\
    \ += 1\n            continue\n        }\n        \n        if s[i] == \" \" {\n\
    \            i += 1\n            continue\n        }\n        \n        if s[i]\
    \ == \" \" {\n            i += 1\n            continue\n        }\n        \n\
    \        if s[i] == \" \" {\n            i += 1\n            continue\n      \
    \  }\n        \n        if s[i] == \" \" {\n            i += 1\n            continue\n\
    \        }\n        \n        if s[i] == \" \" {\n            i += 1\n       \
    \     continue\n        }\n        \n        if s[i] == \" \" {\n            i\
    \ += 1\n            continue\n        }\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s:\
    \ \"Mary had a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s:\
    \ \"simple white space\", n: 2) == [] as [String])\nassert(select_words(s: \"\
    Hello world\", n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n:\
    \ 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) == [] as [String])\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmps0gattvu.swift:23:11: error: expected 'in' after for-each pattern\n\
    \    for i < s.count {\n          ^\n/tmp/tmps0gattvu.swift:23:11: error: unary\
    \ operator cannot be separated from its operand\n    for i < s.count {\n     \
    \     ^~\n           \n/tmp/tmps0gattvu.swift:194:69: error: expected '}' at end\
    \ of brace statement\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\"\
    , \"c\", \"d\", \"f\"])\n                                                    \
    \                ^\n/tmp/tmps0gattvu.swift:13:50: note: to match this opening\
    \ '{'\nfunc select_words(s: String, n: Int) -> [String] {\n                  \
    \                               ^\n/tmp/tmps0gattvu.swift:23:11: error: '<' is\
    \ not a prefix unary operator\n    for i < s.count {\n          ^\n/tmp/tmps0gattvu.swift:176:6:\
    \ error: operator functions can only be declared at global or in type scope\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1660014410
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"\
    ]\n/// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n\
    /// select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfunc\
    \ select_words(s: String, n: Int) -> [String] {\n    return select_words_helper(s,\
    \ n, 0)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary\
    \ had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had\
    \ a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple\
    \ white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\"\
    , n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"\
    ])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s:\
    \ \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpcf26dtro.swift:14:12: error: cannot find 'select_words_helper'\
    \ in scope\n    return select_words_helper(s, n, 0)\n           ^~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014412
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"\
    ]\n/// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n\
    /// select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfunc\
    \ select_words(s: String, n: Int) -> [String] {\n    \n    var words = [String]()\n\
    \    \n    if s == \"\" {\n        return words\n    }\n    \n    for letter in\
    \ s.characters {\n        if letter.isConsonant() {\n            if n == 1 {\n\
    \                words.append(String(letter))\n            } else {\n        \
    \        words.append(String(letter))\n                words.append(String(letter))\n\
    \            }\n        }\n    }\n    \n    return words\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"\
    little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\"\
    , \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmp88rfruql.swift:21:21: error: 'characters' is unavailable: Please\
    \ use String directly\n    for letter in s.characters {\n                    ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmp88rfruql.swift:22:19:\
    \ error: value of type 'Character' has no member 'isConsonant'\n        if letter.isConsonant()\
    \ {\n           ~~~~~~ ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014412
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"\
    ]\n/// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n\
    /// select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfunc\
    \ select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    var i = 0\n    var j = 0\n    var k = 0\n    var l = 0\n    var m = 0\n \
    \   var n = 0\n    var o = 0\n    var p = 0\n    var q = 0\n    var r = 0\n  \
    \  var s = 0\n    var t = 0\n    var u = 0\n    var v = 0\n    var w = 0\n   \
    \ var x = 0\n    var y = 0\n    var z = 0\n    var a = 0\n    var b = 0\n    var\
    \ c = 0\n    var d = 0\n    var e = 0\n    var f = 0\n    var g = 0\n    var h\
    \ = 0\n    var i = 0\n    var j = 0\n    var k = 0\n    var l = 0\n    var m =\
    \ 0\n    var n = 0\n    var o = 0\n    var p = 0\n    var q = 0\n    var r = 0\n\
    \    var s = 0\n    var t = 0\n    var u = 0\n    var v = 0\n    var w = 0\n \
    \   var x = 0\n    var y = 0\n    var z = 0\n    var a = 0\n    var b = 0\n  \
    \  var c = 0\n    var d = 0\n    var e = 0\n    var f = 0\n    var g = 0\n   \
    \ var h = 0\n    var i = 0\n    var j = 0\n    var k = 0\n    var l = 0\n    var\
    \ m = 0\n    var n = 0\n    var o = 0\n    var p = 0\n    var q = 0\n    var r\
    \ = 0\n    var s = 0\n    var t = 0\n    var u = 0\n    var v = 0\n    var w =\
    \ 0\n    var x = 0\n    var y = 0\n    var z = 0\n    var a = 0\n    var b = 0\n\
    \    var c = 0\n    var d = 0\n    var e = 0\n    var f = 0\n    var g = 0\n \
    \   var h = 0\n    var i = 0\n    var j = 0\n    var k = 0\n    var l = 0\n  \
    \  var m = 0\n    var n = 0\n    var o = 0\n    var p = 0\n    var q = 0\n   \
    \ var r = 0\n    var s = 0\n    var t = 0\n    var u = 0\n    var v = 0\n    var\
    \ w = 0\n    var x = 0\n    var y = 0\n    var z = 0\n    var a = 0\n    var b\
    \ = 0\n    var c = 0\n    var d = 0\n    var e = 0\n    var f = 0\n    var g =\
    \ 0\n    var h = 0\n    var i = 0\n    var j = 0\n    var k = 0\n    var l = 0\n\
    \    var m = 0\n    var n = 0\n    var o = 0\n    var p = 0\n    var q = 0\n \
    \   var r = 0\n    var s = 0\n    var t = 0\n    var u = 0\n    var v = 0\n  \
    \  var w = 0\n    var x = 0\n    var y = 0\n    var z = 0\n    var a = 0\n   \
    \ var b = 0\n    var c = 0\n    var d = 0\n    var e = 0\n    var f = 0\n    var\
    \ g = 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary\
    \ had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had\
    \ a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple\
    \ white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\"\
    , n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"\
    ])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s:\
    \ \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpv60dryfr.swift:41:9: error: invalid redeclaration of 'i'\n    var\
    \ i = 0\n        ^\n/tmp/tmpv60dryfr.swift:15:9: note: 'i' previously declared\
    \ here\n    var i = 0\n        ^\n/tmp/tmpv60dryfr.swift:42:9: error: invalid\
    \ redeclaration of 'j'\n    var j = 0\n        ^\n/tmp/tmpv60dryfr.swift:16:9:\
    \ note: 'j' previously declared here\n    var j = 0\n        ^\n/tmp/tmpv60dryfr.swift:43:9:\
    \ error: invalid redeclaration of 'k'\n    var k = 0\n        ^\n/tmp/tmpv60dryfr.swift:17:9:\
    \ note: 'k' previously declared here\n    var k = 0\n        ^\n/tmp/tmpv60dryfr.swift:44:9:\
    \ error: invalid redeclaration of 'l'\n    var l = 0\n        ^\n/tmp/tmpv60dryfr.swift:18:9:\
    \ note: 'l' previously declared here\n    var l = 0\n        ^\n/tmp/tmpv60dryfr.swift:45:9:\
    \ error: invalid redeclaration of 'm'\n    var m = 0\n        ^\n/tmp/tmpv60dryfr.swift:19:9:\
    \ note: 'm' previously declared here\n    var m = 0\n        ^\n/tmp/tmpv60dryfr.swift:46:9:\
    \ error: invalid redeclaration of 'n'\n    var n = 0\n        ^\n/tmp/tmpv60dryfr.swift:20:9:\
    \ note: 'n' previously declared here\n    var n = 0\n        ^\n/tmp/tmpv60dryfr.swift:47:9:\
    \ error: invalid redeclaration of 'o'\n    var o = 0\n        ^\n/tmp/tmpv60dryfr.swift:21:9:\
    \ note: 'o' previously declared here\n    var o = 0\n        ^\n/tmp/tmpv60dryfr.swift:48:9:\
    \ error: invalid redeclaration of 'p'\n    var p = 0\n        ^\n/tmp/tmpv60dryfr.swift:22:9:\
    \ note: 'p' previously declared here\n    var p = 0\n        ^\n/tmp/tmpv60dryfr.swift:49:9:\
    \ error: invalid redeclaration of 'q'\n    var q = 0\n        ^\n/tmp/tmpv60dryfr.swift:23:9:\
    \ note: 'q' previously declared here\n    var q = 0\n        ^\n/tmp/tmpv60dryfr.swift:50:9:\
    \ error: invalid redeclaration of 'r'\n    var r = 0\n        ^\n/tmp/tmpv60dryfr.swift:24:9:\
    \ note: 'r' previously declared here\n    var r = 0\n        ^\n/tmp/tmpv60dryfr.swift:51:9:\
    \ error: invalid redeclaration of 's'\n    var s = 0\n        ^\n/tmp/tmpv60dryfr.swift:25:9:\
    \ note: 's' previously declared here\n    var s = 0\n        ^\n/tmp/tmpv60dryfr.swift:52:9:\
    \ error: invalid redeclaration of 't'\n    var t = 0\n        ^\n/tmp/tmpv60d"
  stdout: ''
  timestamp: 1660014410
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"\
    ]\n/// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n\
    /// select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfunc\
    \ select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    var i = 0\n    while i < s.characters.count {\n        if s.characters[i]\
    \ != \" \" {\n            if s.characters[i] == \" \" && s.characters[i+1] ==\
    \ \" \" {\n                i += 1\n                continue\n            }\n \
    \           if s.characters[i] == \" \" {\n                i += 1\n          \
    \      continue\n            }\n            if s.characters[i] != \" \" && s.characters[i]\
    \ != \" \" && s.characters[i] != \" \" {\n                if s.characters[i] ==\
    \ s.characters[i+1] {\n                    i += 1\n                    continue\n\
    \                }\n                if s.characters[i] == s.characters[i+1] &&\
    \ s.characters[i+1] == s.characters[i+2] {\n                    i += 2\n     \
    \               continue\n                }\n                if s.characters[i]\
    \ == s.characters[i+1] && s.characters[i+1] == s.characters[i+2] && s.characters[i+2]\
    \ == s.characters[i+3] {\n                    i += 3\n                    continue\n\
    \                }\n                if s.characters[i] == s.characters[i+1] &&\
    \ s.characters[i+1] == s.characters[i+2] && s.characters[i+2] == s.characters[i+3]\
    \ && s.characters[i+3] == s.characters[i+4] {\n                    i += 4\n  \
    \                  continue\n                }\n                if s.characters[i]\
    \ == s.characters[i+1] && s.characters[i+1] == s.characters[i+2] && s.characters[i+2]\
    \ == s.characters[i+3] && s.characters[i+3] == s.characters[i+4] && s.characters[i+4]\
    \ == s.characters[i+5] {\n                    i += 5\n                    continue\n\
    \                }\n                if s.characters[i] == s.characters[i+1] &&\
    \ s.characters[i+1] == s.characters[i+2] && s.characters[i+2] == s.characters[i+3]\
    \ && s.characters[i+3] == s.characters[i+4] && s.characters[i+4] == s.characters[i+5]\
    \ && s.characters[i+5] == s.characters[i+6] {\n                    i += 6\n  \
    \                  continue\n                }\n                if s.characters[i]\
    \ == s.characters[i+1] && s.characters[i+1] == s.characters[i+2] && s.characters[i+2]\
    \ == s.characters[i+3] && s.characters[i+3] == s.characters[i+4] && s.characters[i+4]\
    \ == s.characters[i+5] && s.characters[i+5] == s.characters[i+6] && s.characters[i+6]\
    \ == s.characters[i+7] {\n                    i += 7\n                    continue\n\
    \                }\n                if s.characters[i] == s.characters[i+1] &&\
    \ s.characters[i+1] == s.characters[i+2] && s.characters[i+2] == s.characters[i+3]\
    \ && s.characters[i+3] == s.characters[i+4] && s.characters[i\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"\
    little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\"\
    , \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmp4jq3v6y7.swift:56:1: error: expected ']' in expression list\n}\n\
    ^\n/tmp/tmp4jq3v6y7.swift:55:198: note: to match this opening '['\n          \
    \      if s.characters[i] == s.characters[i+1] && s.characters[i+1] == s.characters[i+2]\
    \ && s.characters[i+2] == s.characters[i+3] && s.characters[i+3] == s.characters[i+4]\
    \ && s.characters[i\n                                                        \
    \                                                                            \
    \                                                                 ^\n/tmp/tmp4jq3v6y7.swift:77:69:\
    \ error: expected '}' at end of brace statement\nassert(select_words(s: \"a b\
    \ c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])\n                        \
    \                                            ^\n/tmp/tmp4jq3v6y7.swift:17:35:\
    \ note: to match this opening '{'\n        if s.characters[i] != \" \" {\n   \
    \                               ^\n/tmp/tmp4jq3v6y7.swift:77:69: error: expected\
    \ '}' at end of brace statement\nassert(select_words(s: \"a b c d e f\", n: 1)\
    \ == [\"b\", \"c\", \"d\", \"f\"])\n                                         \
    \                           ^\n/tmp/tmp4jq3v6y7.swift:16:34: note: to match this\
    \ opening '{'\n    while i < s.characters.count {\n                          \
    \       ^\n/tmp/tmp4jq3v6y7.swift:77:69: error: expected '}' at end of brace statement\n\
    assert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])\n\
    \                                                                    ^\n/tmp/tmp4jq3v6y7.swift:13:50:\
    \ note: to match this opening '{'\nfunc select_words(s: String, n: Int) -> [String]\
    \ {\n                                                 ^\n/tmp/tmp4jq3v6y7.swift:16:17:\
    \ error: 'characters' is unavailable: Please use String directly\n    while i\
    \ < s.characters.count {\n                ^~~~~~~~~~\nSwift.String:5:16: note:\
    \ 'characters' was obsoleted in Swift 5.0\n    public var characters: String {\
    \ get set }\n               ^\n/tmp/tmp4jq3v6y7.swift:17:12: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if s.character"
  stdout: ''
  timestamp: 1660014413
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"\
    ]\n/// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n\
    /// select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfunc\
    \ select_words(s: String, n: Int) -> [String] {\n    var result = [String]()\n\
    \    \n    if s == \"\" {\n        return result\n    }\n    \n    var i = 0\n\
    \    var j = 0\n    var k = 0\n    \n    for i < s.count {\n        if s[i] ==\
    \ \" \" {\n            i += 1\n            continue\n        }\n        \n   \
    \     if s[i] == \"a\" {\n            i += 1\n            continue\n        }\n\
    \        \n        if s[i] == \"e\" {\n            i += 1\n            continue\n\
    \        }\n        \n        if s[i] == \"i\" {\n            i += 1\n       \
    \     continue\n        }\n        \n        if s[i] == \"o\" {\n            i\
    \ += 1\n            continue\n        }\n        \n        if s[i] == \"u\" {\n\
    \            i += 1\n            continue\n        }\n        \n        if s[i]\
    \ == \"y\" {\n            i += 1\n            continue\n        }\n        \n\
    \        if s[i] == \"A\" {\n            i += 1\n            continue\n      \
    \  }\n        \n        if s[i] == \"E\" {\n            i += 1\n            continue\n\
    \        }\n        \n        if s[i] == \"I\" {\n            i += 1\n       \
    \     continue\n        }\n        \n        if s[i] == \"O\" {\n            i\
    \ += 1\n            continue\n        }\n        \n        if s[i] == \"U\" {\n\
    \            i += 1\n            continue\n        }\n        \n        if s[i]\
    \ == \"Y\" {\n            i += 1\n            continue\n        }\n        \n\
    \        if s[i] == \"n\" {\n            i += 1\n            continue\n      \
    \  }\n        \n        if s[i] == \"s\" {\n            i += 1\n            continue\n\
    \        }\n        \n        if s[i] == \"t\" {\n            i += 1\n       \
    \     continue\n        }\n        \n        if s[i] == \"h\" {\n            i\
    \ += 1\n            continue\n        }\n        \n        if s[i] == \"l\" {\n\
    \            i += 1\n            continue\n        }\n        \n        if s[i]\
    \ == \"a\" {\n            i += 1\n            continue\n        }\n        \n\
    \        if s[i] == \"d\" {\n            i += 1\n            continue\n      \
    \  }\n        \n        if s[i] == \"e\" {\n            i += 1\n            continue\n\
    \        }\n        \n        if s[i] == \"l\" {\n            i += 1\n       \
    \     continue\n        }\n        \n        if s[i] == \"m\" {\n            i\
    \ += 1\n            continue\n        }\n        \n        if s[i] == \"p\" {\n\
    \            i += 1\n            continue\n        }\n        \n        if s[i]\
    \ == \"r\" {\n            i += 1\n            continue\n        }\n        \n\
    \        if s[i] == \"e\" {\n            i += 1\n            continue\n      \
    \  }\n        \n        if s[i] == \"s\" {\n            i += 1\n            continue\n\
    \        }\n        \n        if s[i] == \"t\" {\n            i += 1\n       \
    \     continue\n        }\n        \n        if s[i] == \"w\" {\n            i\
    \ += 1\n            continue\n        }\n        \n        if s[i] == \"h\" {\n\
    \            i += 1\n            continue\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"little\"\
    ])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\", \"\
    lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpmni5m8ym.swift:24:11: error: expected 'in' after for-each pattern\n\
    \    for i < s.count {\n          ^\n/tmp/tmpmni5m8ym.swift:24:11: error: unary\
    \ operator cannot be separated from its operand\n    for i < s.count {\n     \
    \     ^~\n           \n/tmp/tmpmni5m8ym.swift:194:69: error: expected '}' at end\
    \ of brace statement\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\"\
    , \"c\", \"d\", \"f\"])\n                                                    \
    \                ^\n/tmp/tmpmni5m8ym.swift:24:21: note: to match this opening\
    \ '{'\n    for i < s.count {\n                    ^\n/tmp/tmpmni5m8ym.swift:194:69:\
    \ error: expected '}' at end of brace statement\nassert(select_words(s: \"a b\
    \ c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])\n                        \
    \                                            ^\n/tmp/tmpmni5m8ym.swift:13:50:\
    \ note: to match this opening '{'\nfunc select_words(s: String, n: Int) -> [String]\
    \ {\n                                                 ^\n/tmp/tmpmni5m8ym.swift:24:11:\
    \ error: '<' is not a prefix unary operator\n    for i < s.count {\n         \
    \ ^\n"
  stdout: ''
  timestamp: 1660014412
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"\
    ]\n/// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n\
    /// select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfunc\
    \ select_words(s: String, n: Int) -> [String] {\n    \n    var result = [String]()\n\
    \    \n    if s == \"\" {\n        return result\n    }\n    \n    for char in\
    \ s.characters {\n        if char == \" \" {\n            continue\n        }\n\
    \        \n        if char.unicodeScalars.filter({ $0.isConsonant() }).count ==\
    \ n {\n            result.append(String(char))\n        }\n    }\n    \n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(select_words(s: \"Mary\
    \ had a little lamb\", n: 4) == [\"little\"])\nassert(select_words(s: \"Mary had\
    \ a little lamb\", n: 3) == [\"Mary\", \"lamb\"])\nassert(select_words(s: \"simple\
    \ white space\", n: 2) == [] as [String])\nassert(select_words(s: \"Hello world\"\
    , n: 4) == [\"world\"])\nassert(select_words(s: \"Uncle sam\", n: 3) == [\"Uncle\"\
    ])\nassert(select_words(s: \"\", n: 4) == [] as [String])\nassert(select_words(s:\
    \ \"a b c d e f\", n: 1) == [\"b\", \"c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: "/tmp/tmpn52ve1p_.swift:21:19: error: 'characters' is unavailable: Please\
    \ use String directly\n    for char in s.characters {\n                  ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpn52ve1p_.swift:26:44:\
    \ error: value of type 'Unicode.Scalar' has no member 'isConsonant'\n        if\
    \ char.unicodeScalars.filter({ $0.isConsonant() }).count == n {\n            \
    \                            ~~ ^~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1660014412
- exit_code: 1
  program: "\n/// Given a string s and a natural number n, you have been tasked to\
    \ implement \n/// a function that returns a list of all words from string s that\
    \ contain exactly \n/// n consonants, in order these words appear in the string\
    \ s.\n/// If the string s is empty then the function should return an empty list.\n\
    /// Note: you may assume the input string contains only letters and spaces.\n\
    /// Examples:\n/// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"\
    ]\n/// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n\
    /// select_words(\"simple white space\", 2) ==> []\n/// select_words(\"Hello world\"\
    , 4) ==> [\"world\"]\n/// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nfunc\
    \ select_words(s: String, n: Int) -> [String] {\n    \n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(select_words(s: \"Mary had a little lamb\", n: 4) == [\"\
    little\"])\nassert(select_words(s: \"Mary had a little lamb\", n: 3) == [\"Mary\"\
    , \"lamb\"])\nassert(select_words(s: \"simple white space\", n: 2) == [] as [String])\n\
    assert(select_words(s: \"Hello world\", n: 4) == [\"world\"])\nassert(select_words(s:\
    \ \"Uncle sam\", n: 3) == [\"Uncle\"])\nassert(select_words(s: \"\", n: 4) ==\
    \ [] as [String])\nassert(select_words(s: \"a b c d e f\", n: 1) == [\"b\", \"\
    c\", \"d\", \"f\"])"
  status: SyntaxError
  stderr: '/tmp/tmpuails2sj.swift:15:1: error: missing return in global function expected
    to return ''[String]''

    }

    ^

    '
  stdout: ''
  timestamp: 1660014410
