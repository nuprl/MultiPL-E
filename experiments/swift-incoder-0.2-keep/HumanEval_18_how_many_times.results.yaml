language: swift
name: HumanEval_18_how_many_times
results:
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if\
    \ string == \"\" {\n        return 0\n    }\n    if substring == \"\" {\n    \
    \    return count(string)\n    }\n    var count = 0\n    var start = 0\n    var\
    \ end = count(string)\n    while start < end {\n        start = string.index(substring,\
    \ start) + 1\n        end = string.index(substring, end) + 1\n        count +=\
    \ 1\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp8ibbbtc3.swift:14:16: error: use of local variable 'count' before\
    \ its declaration\n        return count(string)\n               ^\n/tmp/tmp8ibbbtc3.swift:16:9:\
    \ note: 'count' declared here\n    var count = 0\n        ^\n/tmp/tmp8ibbbtc3.swift:18:15:\
    \ error: cannot call value of non-function type 'Int'\n    var end = count(string)\n\
    \              ^\n/tmp/tmp8ibbbtc3.swift:20:24: error: no exact matches in call\
    \ to instance method 'index'\n        start = string.index(substring, start) +\
    \ 1\n                       ^\n/tmp/tmp8ibbbtc3.swift:20:24: note: candidate has\
    \ partially matching parameter list (String.Index, offsetBy: Int)\n        start\
    \ = string.index(substring, start) + 1\n                       ^\n/tmp/tmp8ibbbtc3.swift:20:24:\
    \ note: candidate has partially matching parameter list (String.Index, offsetBy:\
    \ Int)\n        start = string.index(substring, start) + 1\n                 \
    \      ^\n/tmp/tmp8ibbbtc3.swift:20:24: note: candidate has partially matching\
    \ parameter list (String.Index, offsetBy: Int)\n        start = string.index(substring,\
    \ start) + 1\n                       ^\n/tmp/tmp8ibbbtc3.swift:20:24: error: cannot\
    \ convert value of type 'String.Index' to expected argument type 'Int'\n     \
    \   start = string.index(substring, start) + 1\n                       ^\n/tmp/tmp8ibbbtc3.swift:21:22:\
    \ error: no exact matches in call to instance method 'index'\n        end = string.index(substring,\
    \ end) + 1\n                     ^\n/tmp/tmp8ibbbtc3.swift:21:22: note: found\
    \ candidate with type '(String.Index, Int) -> String.Index'\n        end = string.index(substring,\
    \ end) + 1\n                     ^\n/tmp/tmp8ibbbtc3.swift:21:22: error: cannot\
    \ convert value of type 'String.Index' to expected argument type 'Int'\n     \
    \   end = string.index(substring, end) + 1\n                     ^\n"
  stdout: ''
  timestamp: 1659824939
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if\
    \ string == \"\" {\n        return 0\n    }\n    if substring == \"\" {\n    \
    \    return countOccurrences(string, \"\")\n    }\n    var count = 0\n    var\
    \ i = 0\n    var j = 0\n    var k = string.startIndex\n    var l = string.endIndex\n\
    \    while i < l {\n        if string.hasPrefix(substring, k) {\n            count\
    \ = count + 1\n            k = k + substring.length\n        }\n        if string.hasSuffix(substring,\
    \ k) {\n            count = count + 1\n            l = l - substring.length\n\
    \        }\n        if string.hasPrefix(substring, k) || string.hasSuffix(substring,\
    \ k) {\n            count = count + 1\n            k = k + substring.length\n\
    \        }\n        if string.hasPrefix(substring, k) {\n            count = count\
    \ + 1\n            k = k + substring.length\n        }\n        if string.hasSuffix(substring,\
    \ k) {\n            count = count + 1\n            l = l - substring.length\n\
    \        }\n        if string.hasPrefix(substring, k) || string.hasSuffix(substring,\
    \ k) {\n            count = count + 1\n            k = k + substring.length\n\
    \        }\n        if string.hasPrefix(substring, k) {\n            count = count\
    \ + 1\n            k = k + substring.length\n        }\n        if string.hasSuffix(substring,\
    \ k) {\n            count = count + 1\n            l = l - substring.length\n\
    \        }\n        if string.hasPrefix(substring, k) || string.hasSuffix(substring,\
    \ k) {\n            count = count + 1\n            k = k + substring.length\n\
    \        }\n        if string.hasPrefix(substring, k) {\n            count = count\
    \ + 1\n            k = k + substring.length\n        }\n        if string.hasSuffix(substring,\
    \ k) {\n            count = count + 1\n            l = l - substring.length\n\
    \        }\n        if string.hasPrefix(substring, k) || string.hasSuffix(substring,\
    \ k) {\n            count = count + 1\n            k = k + substring.length\n\
    \        }\n        if string.hasPrefix(substring, k) {\n            count = count\
    \ + 1\n            k = k + substring.length\n        }\n        if string.hasSuffix(substring,\
    \ k) {\n            count = count + 1\n            l = l - substring.length\n\
    \        }\n        if string.hasPrefix(substring, k) || string.hasSuffix(substring,\
    \ k) {\n            count = count + 1\n            k = k + substring.length\n\
    \        }\n        if string.hasPrefix(substring, k) {\n            count = count\
    \ + 1\n            k = k + substring.length\n        }\n        if string.hasSuffix(substring,\
    \ k) {\n            count = count + 1\n            l = l - substring.length\n\
    \        }\n        if string.hasPrefix(substring, k) || string.\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpfej5leag.swift:90:52: error: expected member name following '.'\n\
    \        if string.hasPrefix(substring, k) || string.\n                      \
    \                             ^\n/tmp/tmpfej5leag.swift:90:53: error: expected\
    \ '{' after 'if' condition\n        if string.hasPrefix(substring, k) || string.\n\
    \                                                    ^\n/tmp/tmpfej5leag.swift:109:67:\
    \ error: expected '}' at end of brace statement\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)\n                                 \
    \                                 ^\n/tmp/tmpfej5leag.swift:9:63: note: to match\
    \ this opening '{'\nfunc how_many_times(string: String, substring: String) ->\
    \ Int {\n                                                              ^\n/tmp/tmpfej5leag.swift:14:16:\
    \ error: cannot find 'countOccurrences' in scope\n        return countOccurrences(string,\
    \ \"\")\n               ^~~~~~~~~~~~~~~~\n/tmp/tmpfej5leag.swift:21:13: error:\
    \ operator function '<' requires that 'String.Index' conform to 'BinaryInteger'\n\
    \    while i < l {\n            ^\nSwift.BinaryInteger:4:24: note: where 'Other'\
    \ = 'String.Index'\n    public static func < <Other>(lhs: Self, rhs: Other) ->\
    \ Bool where Other : BinaryInteger\n                       ^\n/tmp/tmpfej5leag.swift:22:40:\
    \ error: extra argument in call\n        if string.hasPrefix(substring, k) {\n\
    \                           ~~~~~~~~~~~~^~\n/tmp/tmpfej5leag.swift:24:19: error:\
    \ cannot assign value of type 'Never' to type 'String.Index'\n            k =\
    \ k + substring.length\n                ~~^~~~~~~~~~~~~~~~~~\n/tmp/tmpfej5leag.swift:24:19:\
    \ error: referencing operator function '+' on 'Sequence' requires that 'String.Index'\
    \ conform to 'Sequence'\n            k = k + substring.length\n              \
    \    ^\nSwift.Sequence:1:11: note: where 'Self' = 'String.Index'\nextension Sequence\
    \ where Self.Element == String {\n          ^\n/tmp/tmpfej5leag.swift:24:31: error:\
    \ value of type 'String' has no member 'length'\n            k = k + substring.length\n\
    \                    ~~~~~~~~~ ^~~~~~\n/tmp/tmpfej5leag.swift:26:"
  stdout: ''
  timestamp: 1659824939
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if\
    \ string == \"\" || substring == \"\" {\n        return 0\n    }\n    var count\
    \ = 0\n    var i = 0\n    var j = string.characters.count\n    var k = substring.characters.count\n\
    \    while i < j {\n        if string[i] != substring[j] {\n            count\
    \ += 1\n        }\n        i += 1\n        j += 1\n    }\n    while i < k {\n\
    \        if string[i] != substring[k] {\n            count += 1\n        }\n \
    \       i += 1\n        k += 1\n    }\n    return count\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\n\
    assert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string:\
    \ \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john\
    \ doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpqbqlpurz.swift:15:20: error: 'characters' is unavailable: Please\
    \ use String directly\n    var j = string.characters.count\n                 \
    \  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n\
    \    public var characters: String { get set }\n               ^\n/tmp/tmpqbqlpurz.swift:16:23:\
    \ error: 'characters' is unavailable: Please use String directly\n    var k =\
    \ substring.characters.count\n                      ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmpqbqlpurz.swift:18:12: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if string[i] != substring[j] {\n           ^~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpqbqlpurz.swift:18:25:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if string[i] != substring[j] {\n      \
    \                  ^~~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has\
    \ been explicitly marked unavailable here\n    public subscript(i: Int) -> Character\
    \ { get }\n           ^\n/tmp/tmpqbqlpurz.swift:25:12: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if string[i] != substring[k] {\n           ^~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpqbqlpurz.swift:25:25:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if string[i] != substring[k] {\n      \
    \                  ^~~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has\
    \ been explicitly marked unavailable here\n    public subscript(i: Int) -> Character\
    \ { get }\n           ^\n"
  stdout: ''
  timestamp: 1659824939
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if\
    \ string == \"\" {\n        return 0\n    }\n    if substring == \"\" {\n    \
    \    return countOccurrences(string, \"\")\n    }\n    var count = 0\n    var\
    \ i = 0\n    var j = string.count\n    var k = substring.count\n    while i <\
    \ j {\n        if string[i] == substring[0] {\n            count += 1\n      \
    \      i += k\n        } else {\n            i += 1\n        }\n    }\n    return\
    \ count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpby2c39k2.swift:14:16: error: cannot find 'countOccurrences' in\
    \ scope\n        return countOccurrences(string, \"\")\n               ^~~~~~~~~~~~~~~~\n\
    /tmp/tmpby2c39k2.swift:21:12: error: 'subscript(_:)' is unavailable: cannot subscript\
    \ String with an Int, use a String.Index instead.\n        if string[i] == substring[0]\
    \ {\n           ^~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly\
    \ marked unavailable here\n    public subscript(i: Int) -> Character { get }\n\
    \           ^\n/tmp/tmpby2c39k2.swift:21:25: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n        if\
    \ string[i] == substring[0] {\n                        ^~~~~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1659824939
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if\
    \ string == \"\" {\n        return 0\n    }\n    if substring == \"\" {\n    \
    \    return countOccurrences(string, \"\")\n    }\n    var count = 0\n    var\
    \ startIndex = 0\n    var endIndex = 0\n    while startIndex < string.count {\n\
    \        endIndex = string.index(substring, startIndex)\n        if endIndex ==\
    \ startIndex {\n            count += 1\n            startIndex += 1\n        }\
    \ else {\n            count += countOccurrences(string, substring[startIndex..<endIndex])\n\
    \            startIndex = endIndex + 1\n        }\n    }\n    return count\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp_e3guzq_.swift:14:16: error: cannot find 'countOccurrences' in\
    \ scope\n        return countOccurrences(string, \"\")\n               ^~~~~~~~~~~~~~~~\n\
    /tmp/tmp_e3guzq_.swift:20:27: error: no exact matches in call to instance method\
    \ 'index'\n        endIndex = string.index(substring, startIndex)\n          \
    \                ^\n/tmp/tmp_e3guzq_.swift:20:27: note: found candidate with type\
    \ '(String.Index, Int) -> String.Index'\n        endIndex = string.index(substring,\
    \ startIndex)\n                          ^\n/tmp/tmp_e3guzq_.swift:20:27: error:\
    \ cannot assign value of type 'String.Index' to type 'Int'\n        endIndex =\
    \ string.index(substring, startIndex)\n                   ~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmp_e3guzq_.swift:25:22: error: cannot find 'countOccurrences' in scope\n\
    \            count += countOccurrences(string, substring[startIndex..<endIndex])\n\
    \                     ^~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824939
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if\
    \ string == \"\" {\n        return 0\n    }\n    if substring == \"\" {\n    \
    \    return countOccurrences(string, \"\")\n    }\n    var count = 0\n    var\
    \ startIndex = 0\n    var endIndex = 0\n    while startIndex < string.count {\n\
    \        endIndex = string.index(substring, startIndex)\n        if endIndex ==\
    \ startIndex {\n            count += 1\n            startIndex += 1\n        }\
    \ else {\n            count += endIndex - startIndex + 1\n            startIndex\
    \ = endIndex + 1\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp84ngcn5c.swift:14:16: error: cannot find 'countOccurrences' in\
    \ scope\n        return countOccurrences(string, \"\")\n               ^~~~~~~~~~~~~~~~\n\
    /tmp/tmp84ngcn5c.swift:20:27: error: no exact matches in call to instance method\
    \ 'index'\n        endIndex = string.index(substring, startIndex)\n          \
    \                ^\n/tmp/tmp84ngcn5c.swift:20:27: note: found candidate with type\
    \ '(String.Index, Int) -> String.Index'\n        endIndex = string.index(substring,\
    \ startIndex)\n                          ^\n/tmp/tmp84ngcn5c.swift:20:27: error:\
    \ cannot assign value of type 'String.Index' to type 'Int'\n        endIndex =\
    \ string.index(substring, startIndex)\n                   ~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824939
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if\
    \ string == \"\" {\n        return 0\n    }\n    if substring == \"\" {\n    \
    \    return countOccurrences(string, \"\")\n    }\n    var count = 0\n    var\
    \ last = 0\n    for index in 0..<string.characters.count {\n        if string.characters[index]\
    \ == substring.characters[0] {\n            count += countOccurrences(string,\
    \ substring.characters[1..<index])\n            last = index\n        }\n    }\n\
    \    return count + countOccurrences(string, substring.characters[last..<string.characters.count])\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpru1ntf42.swift:14:16: error: cannot find 'countOccurrences' in\
    \ scope\n        return countOccurrences(string, \"\")\n               ^~~~~~~~~~~~~~~~\n\
    /tmp/tmpru1ntf42.swift:18:29: error: 'characters' is unavailable: Please use String\
    \ directly\n    for index in 0..<string.characters.count {\n                 \
    \           ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in\
    \ Swift 5.0\n    public var characters: String { get set }\n               ^\n\
    /tmp/tmpru1ntf42.swift:19:12: error: 'subscript(_:)' is unavailable: cannot subscript\
    \ String with an Int, use a String.Index instead.\n        if string.characters[index]\
    \ == substring.characters[0] {\n           ^~~~~~~~~~~~~~~~~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpru1ntf42.swift:19:19:\
    \ error: 'characters' is unavailable: Please use String directly\n        if string.characters[index]\
    \ == substring.characters[0] {\n                  ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmpru1ntf42.swift:19:40: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if string.characters[index] == substring.characters[0] {\n          \
    \                             ^~~~~~~~~~~~~~~~~~~~~~~\nSwift.String:3:12: note:\
    \ 'subscript(_:)' has been explicitly marked unavailable here\n    public subscript(i:\
    \ Int) -> Character { get }\n           ^\n/tmp/tmpru1ntf42.swift:19:50: error:\
    \ 'characters' is unavailable: Please use String directly\n        if string.characters[index]\
    \ == substring.characters[0] {\n                                             \
    \    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmpru1ntf42.swift:20:22:\
    \ error: cannot find 'countOccurrences' in scope\n            count += countOccurrences(string,\
    \ substring.c"
  stdout: ''
  timestamp: 1659824939
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if\
    \ string == \"\" {\n        return 0\n    }\n    if substring == \"\" {\n    \
    \    return countOccurrences(string, \"\")\n    }\n    var count = 0\n    var\
    \ last = 0\n    for index in 0..<string.characters.count {\n        let start\
    \ = string.index(string.startIndex, offsetBy: index)\n        let end = string.index(start,\
    \ offsetBy: substring.length)\n        if string.substring(with: start..<end)\
    \ == substring {\n            count += 1\n            last = index\n        }\n\
    \    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpp2ompboo.swift:14:16: error: cannot find 'countOccurrences' in\
    \ scope\n        return countOccurrences(string, \"\")\n               ^~~~~~~~~~~~~~~~\n\
    /tmp/tmpp2ompboo.swift:18:29: error: 'characters' is unavailable: Please use String\
    \ directly\n    for index in 0..<string.characters.count {\n                 \
    \           ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in\
    \ Swift 5.0\n    public var characters: String { get set }\n               ^\n\
    /tmp/tmpp2ompboo.swift:20:59: error: value of type 'String' has no member 'length'\n\
    \        let end = string.index(start, offsetBy: substring.length)\n         \
    \                                       ~~~~~~~~~ ^~~~~~\n/tmp/tmpp2ompboo.swift:21:19:\
    \ error: value of type 'String' has no member 'substring'\n        if string.substring(with:\
    \ start..<end) == substring {\n           ~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824939
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    let\
    \ index = string.firstIndex(of: substring)\n    if index == nil {\n        return\
    \ 0\n    }\n    let count = string.distance(from: string.startIndex, to: index!)\n\
    \    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpw5ndwr2k.swift:10:39: error: cannot convert value of type 'String'\
    \ to expected argument type 'String.Element' (aka 'Character')\n    let index\
    \ = string.firstIndex(of: substring)\n                                      ^\n"
  stdout: ''
  timestamp: 1659824939
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    let\
    \ index = string.firstIndex(of: substring)\n    if index == nil {\n        return\
    \ 0\n    }\n    let start = index!\n    let end = string.index(start, offsetBy:\
    \ substring.count)\n    return string.distance(from: start, to: end) + 1\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpmih96b2h.swift:10:39: error: cannot convert value of type 'String'\
    \ to expected argument type 'String.Element' (aka 'Character')\n    let index\
    \ = string.firstIndex(of: substring)\n                                      ^\n"
  stdout: ''
  timestamp: 1659824939
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if\
    \ string == \"\" || substring == \"\" {\n        return 0\n    }\n    var count\
    \ = 0\n    var last = 0\n    for index in string.indices(of: substring) {\n  \
    \      count += 1\n        last = index\n    }\n    return count\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp6qjitue4.swift:15:25: error: cannot call value of non-function\
    \ type 'DefaultIndices<String>'\n    for index in string.indices(of: substring)\
    \ {\n                        ^\n"
  stdout: ''
  timestamp: 1659824939
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if\
    \ string == \"\" {\n        return 0\n    }\n    if substring == \"\" {\n    \
    \    return string.count\n    }\n    var count = 0\n    var i = 0\n    var j =\
    \ string.count\n    while i < j {\n        if string[i] == substring[0] {\n  \
    \          count += 1\n            i += substring.length - 1\n        } else if\
    \ string[i] == substring[1] {\n            count += 1\n            i += substring.length\
    \ - 1\n        } else if string[i] == substring[2] {\n            count += 1\n\
    \            i += substring.length - 1\n        } else if string[i] == substring[3]\
    \ {\n            count += 1\n            i += substring.length - 1\n        }\
    \ else if string[i] == substring[4] {\n            count += 1\n            i +=\
    \ substring.length - 1\n        } else if string[i] == substring[5] {\n      \
    \      count += 1\n            i += substring.length - 1\n        } else if string[i]\
    \ == substring[6] {\n            count += 1\n            i += substring.length\
    \ - 1\n        } else if string[i] == substring[7] {\n            count += 1\n\
    \            i += substring.length - 1\n        } else if string[i] == substring[8]\
    \ {\n            count += 1\n            i += substring.length - 1\n        }\
    \ else if string[i] == substring[9] {\n            count += 1\n            i +=\
    \ substring.length - 1\n        } else if string[i] == substring[10] {\n     \
    \       count += 1\n            i += substring.length - 1\n        } else if string[i]\
    \ == substring[11] {\n            count += 1\n            i += substring.length\
    \ - 1\n        } else if string[i] == substring[12] {\n            count += 1\n\
    \            i += substring.length - 1\n        } else if string[i] == substring[13]\
    \ {\n            count += 1\n            i += substring.length - 1\n        }\
    \ else if string[i] == substring[14] {\n            count += 1\n            i\
    \ += substring.length - 1\n        } else if string[i] == substring[15] {\n  \
    \          count += 1\n            i += substring.length - 1\n        } else if\
    \ string[i] == substring[16] {\n            count += 1\n            i += substring.length\
    \ - 1\n        } else if string[i] == substring[17] {\n            count += 1\n\
    \            i += substring.length - 1\n        } else if string[i] == substring[18]\
    \ {\n            count += 1\n            i += substring.length - 1\n        }\
    \ else if string[i] == substring[19] {\n            count += 1\n            i\
    \ += substring.length - 1\n        } else if string[i] == substring[20] {\n  \
    \          count += 1\n            i += substring.length - 1\n        } else if\
    \ string[i] == substring[21] {\n            count += 1\n            i += substring.length\
    \ - 1\n        } else if string[i] == substring[22] {\n            count += 1\n\
    \            i += substring.length - 1\n        } else if string[i] == substring[23]\
    \ {\n            count += 1\n            i += substring.length - 1\n        }\
    \ else if string[i] == substring[24] {\n            count += 1\n            i\
    \ += substring.length - 1\n        } else if string[i] == substring[25] {\n  \
    \          count += 1\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpkxyyvbd9.swift:115:67: error: expected '}' at end of brace statement\n\
    assert(how_many_times(string: \"john doe\", substring: \"john\") == 1)\n     \
    \                                                             ^\n/tmp/tmpkxyyvbd9.swift:19:17:\
    \ note: to match this opening '{'\n    while i < j {\n                ^\n/tmp/tmpkxyyvbd9.swift:115:67:\
    \ error: expected '}' at end of brace statement\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)\n                                 \
    \                                 ^\n/tmp/tmpkxyyvbd9.swift:9:63: note: to match\
    \ this opening '{'\nfunc how_many_times(string: String, substring: String) ->\
    \ Int {\n                                                              ^\n/tmp/tmpkxyyvbd9.swift:20:12:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if string[i] == substring[0] {\n      \
    \     ^~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly\
    \ marked unavailable here\n    public subscript(i: Int) -> Character { get }\n\
    \           ^\n/tmp/tmpkxyyvbd9.swift:20:25: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n        if\
    \ string[i] == substring[0] {\n                        ^~~~~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpkxyyvbd9.swift:22:28:\
    \ error: value of type 'String' has no member 'length'\n            i += substring.length\
    \ - 1\n                 ~~~~~~~~~ ^~~~~~\n/tmp/tmpkxyyvbd9.swift:23:19: error:\
    \ 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index\
    \ instead.\n        } else if string[i] == substring[1] {\n                  ^~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpkxyyvbd9.swift:23:32:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index i"
  stdout: ''
  timestamp: 1659824940
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if\
    \ string == \"\" {\n        return 0\n    }\n    if substring == \"\" {\n    \
    \    return count(string)\n    }\n    var count = 0\n    var i = 0\n    var j\
    \ = string.count\n    while i < j {\n        if string[i] == substring[0] {\n\
    \            count += 1\n            i += count(substring)\n        } else {\n\
    \            i += 1\n        }\n    }\n    return count\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\n\
    assert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string:\
    \ \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john\
    \ doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmphm35p0q2.swift:14:16: error: use of local variable 'count' before\
    \ its declaration\n        return count(string)\n               ^\n/tmp/tmphm35p0q2.swift:16:9:\
    \ note: 'count' declared here\n    var count = 0\n        ^\n/tmp/tmphm35p0q2.swift:20:12:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if string[i] == substring[0] {\n      \
    \     ^~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly\
    \ marked unavailable here\n    public subscript(i: Int) -> Character { get }\n\
    \           ^\n/tmp/tmphm35p0q2.swift:20:25: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n        if\
    \ string[i] == substring[0] {\n                        ^~~~~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmphm35p0q2.swift:22:18:\
    \ error: cannot call value of non-function type 'Int'\n            i += count(substring)\n\
    \                 ^\n"
  stdout: ''
  timestamp: 1659824939
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if\
    \ string == \"\" {\n        return 0\n    }\n    if substring == \"\" {\n    \
    \    return string.count\n    }\n    var count = 0\n    var i = 0\n    var j =\
    \ string.count\n    while i < j {\n        if string[i] == substring[0] {\n  \
    \          count += 1\n            i += substring.length - 1\n        } else if\
    \ string[i] == substring[1] {\n            count += 1\n            i += substring.length\
    \ - 1\n        } else if string[i] == substring[2] {\n            count += 1\n\
    \            i += substring.length - 1\n        } else if string[i] == substring[3]\
    \ {\n            count += 1\n            i += substring.length - 1\n        }\
    \ else if string[i] == substring[4] {\n            count += 1\n            i +=\
    \ substring.length - 1\n        } else if string[i] == substring[5] {\n      \
    \      count += 1\n            i += substring.length - 1\n        } else if string[i]\
    \ == substring[6] {\n            count += 1\n            i += substring.length\
    \ - 1\n        } else if string[i] == substring[7] {\n            count += 1\n\
    \            i += substring.length - 1\n        } else if string[i] == substring[8]\
    \ {\n            count += 1\n            i += substring.length - 1\n        }\
    \ else if string[i] == substring[9] {\n            count += 1\n            i +=\
    \ substring.length - 1\n        } else if string[i] == substring[10] {\n     \
    \       count += 1\n            i += substring.length - 1\n        } else if string[i]\
    \ == substring[11] {\n            count += 1\n            i += substring.length\
    \ - 1\n        } else if string[i] == substring[12] {\n            count += 1\n\
    \            i += substring.length - 1\n        } else if string[i] == substring[13]\
    \ {\n            count += 1\n            i += substring.length - 1\n        }\
    \ else if string[i] == substring[14] {\n            count += 1\n            i\
    \ += substring.length - 1\n        } else if string[i] == substring[15] {\n  \
    \          count += 1\n            i += substring.length - 1\n        } else if\
    \ string[i] == substring[16] {\n            count += 1\n            i += substring.length\
    \ - 1\n        } else if string[i] == substring[17] {\n            count += 1\n\
    \            i += substring.length - 1\n        } else if string[i] == substring[18]\
    \ {\n            count += 1\n            i += substring.length - 1\n        }\
    \ else if string[i] == substring[19] {\n            count += 1\n            i\
    \ += substring.length - 1\n        } else if string[i] == substring[20] {\n  \
    \          count += 1\n            i += substring.length - 1\n        } else if\
    \ string[i] == substring[21] {\n            count += 1\n            i += substring.length\
    \ - 1\n        } else if string[i] == substring[22] {\n            count += 1\n\
    \            i += substring.length - 1\n        } else if string[i] == substring[23]\
    \ {\n            count += 1\n            i += substring.length - 1\n        }\
    \ else if string[i] == substring[24] {\n            count += 1\n            i\
    \ += substring.length - 1\n        } else if string[i] == substring[25] {\n  \
    \          count += 1\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpkxyyvbd9.swift:115:67: error: expected '}' at end of brace statement\n\
    assert(how_many_times(string: \"john doe\", substring: \"john\") == 1)\n     \
    \                                                             ^\n/tmp/tmpkxyyvbd9.swift:19:17:\
    \ note: to match this opening '{'\n    while i < j {\n                ^\n/tmp/tmpkxyyvbd9.swift:115:67:\
    \ error: expected '}' at end of brace statement\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)\n                                 \
    \                                 ^\n/tmp/tmpkxyyvbd9.swift:9:63: note: to match\
    \ this opening '{'\nfunc how_many_times(string: String, substring: String) ->\
    \ Int {\n                                                              ^\n/tmp/tmpkxyyvbd9.swift:20:12:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if string[i] == substring[0] {\n      \
    \     ^~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly\
    \ marked unavailable here\n    public subscript(i: Int) -> Character { get }\n\
    \           ^\n/tmp/tmpkxyyvbd9.swift:20:25: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n        if\
    \ string[i] == substring[0] {\n                        ^~~~~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpkxyyvbd9.swift:22:28:\
    \ error: value of type 'String' has no member 'length'\n            i += substring.length\
    \ - 1\n                 ~~~~~~~~~ ^~~~~~\n/tmp/tmpkxyyvbd9.swift:23:19: error:\
    \ 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index\
    \ instead.\n        } else if string[i] == substring[1] {\n                  ^~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpkxyyvbd9.swift:23:32:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index i"
  stdout: ''
  timestamp: 1659824940
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    var\
    \ count = 0\n    for c in string.unicodeScalars {\n        if c == substring {\n\
    \            count += 1\n        }\n    }\n    return count\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\n\
    assert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string:\
    \ \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john\
    \ doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpd3rykh2s.swift:12:14: error: referencing operator function '=='\
    \ on 'StringProtocol' requires that 'Unicode.Scalar' conform to 'StringProtocol'\n\
    \        if c == substring {\n             ^\nSwift.StringProtocol:1:11: note:\
    \ where 'Self' = 'Unicode.Scalar'\nextension StringProtocol {\n          ^\n"
  stdout: ''
  timestamp: 1659824939
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    var\
    \ count = 0\n    for c in string.unicodeScalars {\n        if c == substring {\n\
    \            count += 1\n        } else if string.unicodeScalars.contains(substring)\
    \ {\n            count += substringCount(substring)\n        }\n    }\n    return\
    \ count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp1rzwwsy2.swift:12:14: error: referencing operator function '=='\
    \ on 'StringProtocol' requires that 'Unicode.Scalar' conform to 'StringProtocol'\n\
    \        if c == substring {\n             ^\nSwift.StringProtocol:1:11: note:\
    \ where 'Self' = 'Unicode.Scalar'\nextension StringProtocol {\n          ^\n/tmp/tmp1rzwwsy2.swift:14:26:\
    \ error: instance method 'contains' requires the types 'Unicode.Scalar' and 'String.Element'\
    \ (aka 'Character') be equivalent\n        } else if string.unicodeScalars.contains(substring)\
    \ {\n                         ^\n_StringProcessing.Collection:3:17: note: where\
    \ 'Self.Element' = 'Unicode.Scalar', 'C.Element' = 'String.Element' (aka 'Character')\n\
    \    public func contains<C>(_ other: C) -> Bool where C : Collection, Self.Element\
    \ == C.Element\n                ^\n/tmp/tmp1rzwwsy2.swift:15:22: error: cannot\
    \ find 'substringCount' in scope\n            count += substringCount(substring)\n\
    \                     ^~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824939
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if\
    \ string == \"\" {\n        return 0\n    }\n    if substring == \"\" {\n    \
    \    return count(string)\n    }\n    var count = 0\n    var i = 0\n    var j\
    \ = 0\n    var k = 0\n    var last = 0\n    var last2 = 0\n    var last3 = 0\n\
    \    var last4 = 0\n    var last5 = 0\n    var last6 = 0\n    var last7 = 0\n\
    \    var last8 = 0\n    var last9 = 0\n    var last10 = 0\n    var last11 = 0\n\
    \    var last12 = 0\n    var last13 = 0\n    var last14 = 0\n    var last15 =\
    \ 0\n    var last16 = 0\n    var last17 = 0\n    var last18 = 0\n    var last19\
    \ = 0\n    var last20 = 0\n    var last21 = 0\n    var last22 = 0\n    var last23\
    \ = 0\n    var last24 = 0\n    var last25 = 0\n    var last26 = 0\n    var last27\
    \ = 0\n    var last28 = 0\n    var last29 = 0\n    var last30 = 0\n    var last31\
    \ = 0\n    var last32 = 0\n    var last33 = 0\n    var last34 = 0\n    var last35\
    \ = 0\n    var last36 = 0\n    var last37 = 0\n    var last38 = 0\n    var last39\
    \ = 0\n    var last40 = 0\n    var last41 = 0\n    var last42 = 0\n    var last43\
    \ = 0\n    var last44 = 0\n    var last45 = 0\n    var last46 = 0\n    var last47\
    \ = 0\n    var last48 = 0\n    var last49 = 0\n    var last50 = 0\n    var last51\
    \ = 0\n    var last52 = 0\n    var last53 = 0\n    var last54 = 0\n    var last55\
    \ = 0\n    var last56 = 0\n    var last57 = 0\n    var last58 = 0\n    var last59\
    \ = 0\n    var last60 = 0\n    var last61 = 0\n    var last62 = 0\n    var last63\
    \ = 0\n    var last64 = 0\n    var last65 = 0\n    var last66 = 0\n    var last67\
    \ = 0\n    var last68 = 0\n    var last69 = 0\n    var last70 = 0\n    var last71\
    \ = 0\n    var last72 = 0\n    var last73 = 0\n    var last74 = 0\n    var last75\
    \ = 0\n    var last76 = 0\n    var last77 = 0\n    var last78 = 0\n    var last79\
    \ = 0\n    var last80 = 0\n    var last81 = 0\n    var last82 = 0\n    var last83\
    \ = 0\n    var last84 = 0\n    var last85 = 0\n    var last86 = 0\n    var last87\
    \ = 0\n    var last88 = 0\n    var last89 = 0\n    var last90 = 0\n    var last91\
    \ = 0\n    var last92 = 0\n    var last93 = 0\n    var last94 = 0\n    var last95\
    \ = 0\n    var \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpdcagbxl6.swift:115:8: error: expected pattern\n    var \n     \
    \  ^\n/tmp/tmpdcagbxl6.swift:14:16: error: use of local variable 'count' before\
    \ its declaration\n        return count(string)\n               ^\n/tmp/tmpdcagbxl6.swift:16:9:\
    \ note: 'count' declared here\n    var count = 0\n        ^\n"
  stdout: ''
  timestamp: 1659824939
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if\
    \ string == \"\" {\n        return 0\n    }\n    if substring == \"\" {\n    \
    \    return count(string)\n    }\n    var count = 0\n    var start = 0\n    var\
    \ end = count(string)\n    while start < end {\n        start = find(string, substring,\
    \ start)\n        end = find(string, substring, end + 1)\n        if start ==\
    \ end {\n            count += 1\n        }\n    }\n    return count\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpz__4o2rn.swift:14:16: error: use of local variable 'count' before\
    \ its declaration\n        return count(string)\n               ^\n/tmp/tmpz__4o2rn.swift:16:9:\
    \ note: 'count' declared here\n    var count = 0\n        ^\n/tmp/tmpz__4o2rn.swift:18:15:\
    \ error: cannot call value of non-function type 'Int'\n    var end = count(string)\n\
    \              ^\n/tmp/tmpz__4o2rn.swift:20:17: error: cannot find 'find' in scope\n\
    \        start = find(string, substring, start)\n                ^~~~\n/tmp/tmpz__4o2rn.swift:21:15:\
    \ error: cannot find 'find' in scope\n        end = find(string, substring, end\
    \ + 1)\n              ^~~~\n"
  stdout: ''
  timestamp: 1659824939
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if\
    \ string == \"\" {\n        return 0\n    }\n    if substring == \"\" {\n    \
    \    return countOccurrences(string, \"\")\n    }\n    var count = 0\n    var\
    \ i = 0\n    var j = string.count\n    var k = substring.count\n    while i <\
    \ j && k < string.count {\n        if string[i] == substring[k] {\n          \
    \  count += 1\n            i += 1\n            k += 1\n        } else if string[i]\
    \ < substring[k] {\n            i += 1\n        } else {\n            k += 1\n\
    \        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpx8stke_6.swift:14:16: error: cannot find 'countOccurrences' in\
    \ scope\n        return countOccurrences(string, \"\")\n               ^~~~~~~~~~~~~~~~\n\
    /tmp/tmpx8stke_6.swift:21:12: error: 'subscript(_:)' is unavailable: cannot subscript\
    \ String with an Int, use a String.Index instead.\n        if string[i] == substring[k]\
    \ {\n           ^~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly\
    \ marked unavailable here\n    public subscript(i: Int) -> Character { get }\n\
    \           ^\n/tmp/tmpx8stke_6.swift:21:25: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n        if\
    \ string[i] == substring[k] {\n                        ^~~~~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpx8stke_6.swift:25:19:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        } else if string[i] < substring[k] {\n\
    \                  ^~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has been\
    \ explicitly marked unavailable here\n    public subscript(i: Int) -> Character\
    \ { get }\n           ^\n/tmp/tmpx8stke_6.swift:25:31: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        } else if string[i] < substring[k] {\n                              ^~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1659824939
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if\
    \ string == \"\" {\n        return 0\n    }\n    if substring == \"\" {\n    \
    \    return countOccurrences(string, \"\")\n    }\n    var count = 0\n    var\
    \ last = 0\n    for i := 0; i < len(string); i++ {\n        if string[i] == substring[0]\
    \ {\n            count++\n            last = i\n        }\n        if string[i]\
    \ == substring[1] {\n            count++\n            last = i\n        }\n  \
    \      if string[i] == substring[2] {\n            count++\n            last =\
    \ i\n        }\n        if string[i] == substring[3] {\n            count++\n\
    \            last = i\n        }\n        if string[i] == substring[4] {\n   \
    \         count++\n            last = i\n        }\n        if string[i] == substring[5]\
    \ {\n            count++\n            last = i\n        }\n        if string[i]\
    \ == substring[6] {\n            count++\n            last = i\n        }\n  \
    \      if string[i] == substring[7] {\n            count++\n            last =\
    \ i\n        }\n        if string[i] == substring[8] {\n            count++\n\
    \            last = i\n        }\n        if string[i] == substring[9] {\n   \
    \         count++\n            last = i\n        }\n        if string[i] == substring[10]\
    \ {\n            count++\n            last = i\n        }\n        if string[i]\
    \ == substring[11] {\n            count++\n            last = i\n        }\n \
    \       if string[i] == substring[12] {\n            count++\n            last\
    \ = i\n        }\n        if string[i] == substring[13] {\n            count++\n\
    \            last = i\n        }\n        if string[i] == substring[14] {\n  \
    \          count++\n            last = i\n        }\n        if string[i] == substring[15]\
    \ {\n            count++\n            last = i\n        }\n        if string[i]\
    \ == substring[16] {\n            count++\n            last = i\n        }\n \
    \       if string[i] == substring[17] {\n            count++\n            last\
    \ = i\n        }\n        if string[i] == substring[18] {\n            count++\n\
    \            last = i\n        }\n        if string[i] == substring[19] {\n  \
    \          count++\n            last = i\n        }\n        if string[i] == substring[20]\
    \ {\n            count++\n            last = i\n        }\n        if string[i]\
    \ == substring[21] {\n            count++\n            last = i\n        }\n \
    \       if string[i] == substring[22] {\n            count++\n            last\
    \ = i\n        }\n        if string[i] == substring[23] {\n            count++\n\
    \            last = i\n        }\n        if string[i] == substring[24] {\n  \
    \          count++\n            last = i\n        }\n        if string[i] == substring[25]\
    \ {\n            count++\n            last = i\n        }\n        if string[i]\
    \ == substring[26] {\n            count++\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpw9vg85ay.swift:18:12: error: expected type\n    for i := 0; i <\
    \ len(string); i++ {\n           ^\n            <#type#>\n/tmp/tmpw9vg85ay.swift:18:12:\
    \ error: expected 'in' after for-each pattern\n    for i := 0; i < len(string);\
    \ i++ {\n           ^\n/tmp/tmpw9vg85ay.swift:18:12: error: expected Sequence\
    \ expression for for-each loop\n    for i := 0; i < len(string); i++ {\n     \
    \      ^\n/tmp/tmpw9vg85ay.swift:143:67: error: expected '}' at end of brace statement\n\
    assert(how_many_times(string: \"john doe\", substring: \"john\") == 1)\n     \
    \                                                             ^\n/tmp/tmpw9vg85ay.swift:18:38:\
    \ note: to match this opening '{'\n    for i := 0; i < len(string); i++ {\n  \
    \                                   ^\n/tmp/tmpw9vg85ay.swift:143:67: error: expected\
    \ '}' at end of brace statement\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)\n                                                          \
    \        ^\n/tmp/tmpw9vg85ay.swift:9:63: note: to match this opening '{'\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n               \
    \                                               ^\n/tmp/tmpw9vg85ay.swift:14:16:\
    \ error: cannot find 'countOccurrences' in scope\n        return countOccurrences(string,\
    \ \"\")\n               ^~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824939
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if\
    \ string == \"\" || substring == \"\" {\n        return 0\n    }\n\n    var count\
    \ = 0\n    var start = 0\n    var end = string.characters.count\n\n    while start\
    \ < end {\n        let index = string.characters.index(of: substring, options:\
    \ .caseInsensitive)\n        if index == nil {\n            break\n        }\n\
    \n        if index! < start {\n            start = index!\n        }\n\n     \
    \   if index! > end {\n            end = index!\n        }\n\n        count +=\
    \ 1\n    }\n\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpbx40n1wp.swift:16:22: error: 'characters' is unavailable: Please\
    \ use String directly\n    var end = string.characters.count\n               \
    \      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmpbx40n1wp.swift:19:70:\
    \ error: extra argument 'options' in call\n        let index = string.characters.index(of:\
    \ substring, options: .caseInsensitive)\n                                    \
    \       ~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~\n/tmp/tmpbx40n1wp.swift:19:49:\
    \ error: cannot convert value of type 'String' to expected argument type 'String.Element'\
    \ (aka 'Character')\n        let index = string.characters.index(of: substring,\
    \ options: .caseInsensitive)\n                                               \
    \ ^\n/tmp/tmpbx40n1wp.swift:19:70: error: cannot infer contextual base in reference\
    \ to member 'caseInsensitive'\n        let index = string.characters.index(of:\
    \ substring, options: .caseInsensitive)\n                                    \
    \                                ~^~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824939
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if\
    \ string == \"\" || substring == \"\" {\n        return 0\n    }\n\n    var count\
    \ = 0\n    var i = 0\n    var j = string.count\n\n    while i < j {\n        if\
    \ string[i] == substring[0] {\n            count += 1\n            i += substring.length\
    \ - 1\n        } else if string[i] == substring[1] {\n            count += 1\n\
    \            i += substring.length - 1\n        } else if string[i] == substring[2]\
    \ {\n            count += 1\n            i += substring.length - 1\n        }\
    \ else if string[i] == substring[3] {\n            count += 1\n            i +=\
    \ substring.length - 1\n        } else if string[i] == substring[4] {\n      \
    \      count += 1\n            i += substring.length - 1\n        } else if string[i]\
    \ == substring[5] {\n            count += 1\n            i += substring.length\
    \ - 1\n        } else if string[i] == substring[6] {\n            count += 1\n\
    \            i += substring.length - 1\n        } else if string[i] == substring[7]\
    \ {\n            count += 1\n            i += substring.length - 1\n        }\
    \ else if string[i] == substring[8] {\n            count += 1\n            i +=\
    \ substring.length - 1\n        } else if string[i] == substring[9] {\n      \
    \      count += 1\n            i += substring.length - 1\n        } else if string[i]\
    \ == substring[10] {\n            count += 1\n            i += substring.length\
    \ - 1\n        } else if string[i] == substring[11] {\n            count += 1\n\
    \            i += substring.length - 1\n        } else if string[i] == substring[12]\
    \ {\n            count += 1\n            i += substring.length - 1\n        }\
    \ else if string[i] == substring[13] {\n            count += 1\n            i\
    \ += substring.length - 1\n        } else if string[i] == substring[14] {\n  \
    \          count += 1\n            i += substring.length - 1\n        } else if\
    \ string[i] == substring[15] {\n            count += 1\n            i += substring.length\
    \ - 1\n        } else if string[i] == substring[16] {\n            count += 1\n\
    \            i += substring.length - 1\n        } else if string[i] == substring[17]\
    \ {\n            count += 1\n            i += substring.length - 1\n        }\
    \ else if string[i] == substring[18] {\n            count += 1\n            i\
    \ += substring.length - 1\n        } else if string[i] == substring[19] {\n  \
    \          count += 1\n            i += substring.length - 1\n        } else if\
    \ string[i] == substring[20] {\n            count += 1\n            i += substring.length\
    \ - 1\n        } else if string[i] == substring[21] {\n            count += 1\n\
    \            i += substring.length - 1\n        } else if string[i] == substring[22]\
    \ {\n            count += 1\n            i += substring.length - 1\n        }\
    \ else if string[i] == substring[23] {\n            count += 1\n            i\
    \ += substring.length - 1\n        } else if string[i] == substring[24] {\n  \
    \          count += 1\n            i += substring.length - 1\n        } else if\
    \ string[i] == substring[25] {\n            count += 1\n            i += substring.length\
    \ - 1\n        \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmppg106vvu.swift:116:67: error: expected '}' at end of brace statement\n\
    assert(how_many_times(string: \"john doe\", substring: \"john\") == 1)\n     \
    \                                                             ^\n/tmp/tmppg106vvu.swift:18:17:\
    \ note: to match this opening '{'\n    while i < j {\n                ^\n/tmp/tmppg106vvu.swift:116:67:\
    \ error: expected '}' at end of brace statement\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)\n                                 \
    \                                 ^\n/tmp/tmppg106vvu.swift:9:63: note: to match\
    \ this opening '{'\nfunc how_many_times(string: String, substring: String) ->\
    \ Int {\n                                                              ^\n/tmp/tmppg106vvu.swift:19:12:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if string[i] == substring[0] {\n      \
    \     ^~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly\
    \ marked unavailable here\n    public subscript(i: Int) -> Character { get }\n\
    \           ^\n/tmp/tmppg106vvu.swift:19:25: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n        if\
    \ string[i] == substring[0] {\n                        ^~~~~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmppg106vvu.swift:21:28:\
    \ error: value of type 'String' has no member 'length'\n            i += substring.length\
    \ - 1\n                 ~~~~~~~~~ ^~~~~~\n/tmp/tmppg106vvu.swift:22:19: error:\
    \ 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index\
    \ instead.\n        } else if string[i] == substring[1] {\n                  ^~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmppg106vvu.swift:22:32:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index i"
  stdout: ''
  timestamp: 1659824940
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if\
    \ string == \"\" {\n        return 0\n    }\n    if substring == \"\" {\n    \
    \    return count(string)\n    }\n    var count = 0\n    var i = 0\n    var j\
    \ = string.characters.count\n    var k = substring.characters.count\n    while\
    \ i < j {\n        if string[i] == substring[0] {\n            count = count +\
    \ 1\n            i = i + 1\n            if i == k {\n                return count\n\
    \            }\n        }\n        if string[i] == substring[1] {\n          \
    \  count = count + 1\n            i = i + 1\n            if i == k {\n       \
    \         return count\n            }\n        }\n        if string[i] == substring[2]\
    \ {\n            count = count + 1\n            i = i + 1\n            if i ==\
    \ k {\n                return count\n            }\n        }\n        if string[i]\
    \ == substring[3] {\n            count = count + 1\n            i = i + 1\n  \
    \          if i == k {\n                return count\n            }\n        }\n\
    \        if string[i] == substring[4] {\n            count = count + 1\n     \
    \       i = i + 1\n            if i == k {\n                return count\n   \
    \         }\n        }\n        if string[i] == substring[5] {\n            count\
    \ = count + 1\n            i = i + 1\n            if i == k {\n              \
    \  return count\n            }\n        }\n        if string[i] == substring[6]\
    \ {\n            count = count + 1\n            i = i + 1\n            if i ==\
    \ k {\n                return count\n            }\n        }\n        if string[i]\
    \ == substring[7] {\n            count = count + 1\n            i = i + 1\n  \
    \          if i == k {\n                return count\n            }\n        }\n\
    \        if string[i] == substring[8] {\n            count = count + 1\n     \
    \       i = i + 1\n            if i == k {\n                return count\n   \
    \         }\n        }\n        if string[i] == substring[9] {\n            count\
    \ = count + 1\n            i = i + 1\n            if i == k {\n              \
    \  return count\n            }\n        }\n        if string[i] == substring[10]\
    \ {\n            count = count + 1\n            i = i + 1\n            if i ==\
    \ k {\n                return count\n            }\n        }\n        if string[i]\
    \ == substring[11] {\n            count = count + 1\n            i = i + 1\n \
    \           if i == k {\n                return count\n            }\n       \
    \ }\n        if string[i] == substring[12] {\n            count = count + 1\n\
    \            i = i + 1\n            if i == k {\n                return count\n\
    \            }\n        }\n        if string[i] == substring[13] {\n         \
    \   count = count + 1\n            i = i + 1\n            if i == k {\n      \
    \          return count\n            }\n        }\n        if string[i] == substring[14]\
    \ {\n            count = count + 1\n            i = i + 1\n            if i ==\
    \ k {\n                return count\n            }\n        }\n        if string[i]\
    \ == substring[15] {\n            count = count + 1\n            i = i + 1\n \
    \           if i == k {\n                return count\n            }\n       \
    \ }\n        if string[i] == substring[16] {\n            count = count + 1\n\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpojcctq64.swift:154:67: error: expected '}' at end of brace statement\n\
    assert(how_many_times(string: \"john doe\", substring: \"john\") == 1)\n     \
    \                                                             ^\n/tmp/tmpojcctq64.swift:20:17:\
    \ note: to match this opening '{'\n    while i < j {\n                ^\n/tmp/tmpojcctq64.swift:154:67:\
    \ error: expected '}' at end of brace statement\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)\n                                 \
    \                                 ^\n/tmp/tmpojcctq64.swift:9:63: note: to match\
    \ this opening '{'\nfunc how_many_times(string: String, substring: String) ->\
    \ Int {\n                                                              ^\n/tmp/tmpojcctq64.swift:14:16:\
    \ error: use of local variable 'count' before its declaration\n        return\
    \ count(string)\n               ^\n/tmp/tmpojcctq64.swift:16:9: note: 'count'\
    \ declared here\n    var count = 0\n        ^\n/tmp/tmpojcctq64.swift:18:20: error:\
    \ 'characters' is unavailable: Please use String directly\n    var j = string.characters.count\n\
    \                   ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpojcctq64.swift:19:23: error: 'characters' is unavailable: Please\
    \ use String directly\n    var k = substring.characters.count\n              \
    \        ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmpojcctq64.swift:21:12:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if string[i] == substring[0] {\n      \
    \     ^~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly\
    \ marked unavailable here\n    public subscript(i: Int) -> Character { get }\n\
    \           ^\n/tmp/tmpojcctq64.swift:21:25: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n        if\
    \ string[i] == substring[0] {\n                     "
  stdout: ''
  timestamp: 1659824940
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if\
    \ string == \"\" {\n        return 0\n    }\n    if substring == \"\" {\n    \
    \    return string.length\n    }\n    var count = 0\n    var i = 0\n    var j\
    \ = string.length - 1\n    while i < j {\n        if string[i] == substring[0]\
    \ {\n            count += 1\n            i -= 1\n        } else if string[j] ==\
    \ substring[0] {\n            count -= 1\n            j -= 1\n        } else {\n\
    \            i += 1\n            j += 1\n        }\n    }\n    return count\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpb13ek1nn.swift:14:23: error: value of type 'String' has no member\
    \ 'length'\n        return string.length\n               ~~~~~~ ^~~~~~\n/tmp/tmpb13ek1nn.swift:18:20:\
    \ error: value of type 'String' has no member 'length'\n    var j = string.length\
    \ - 1\n            ~~~~~~ ^~~~~~\n/tmp/tmpb13ek1nn.swift:20:12: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if string[i] == substring[0] {\n           ^~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpb13ek1nn.swift:20:25:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if string[i] == substring[0] {\n      \
    \                  ^~~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has\
    \ been explicitly marked unavailable here\n    public subscript(i: Int) -> Character\
    \ { get }\n           ^\n"
  stdout: ''
  timestamp: 1659824939
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if\
    \ string == \"\" || substring == \"\" {\n        return 0\n    }\n    var count\
    \ = 0\n    var start = 0\n    var end = string.count\n    while start < end {\n\
    \        let index = string.index(start, offsetBy: substring.count)\n        if\
    \ index == nil {\n            break\n        }\n        start = index!\n     \
    \   count += 1\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpig5gmp3b.swift:17:34: error: cannot convert value of type 'Int'\
    \ to expected argument type 'String.Index'\n        let index = string.index(start,\
    \ offsetBy: substring.count)\n                                 ^\n"
  stdout: ''
  timestamp: 1659824940
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    var\
    \ count = 0\n    for index in 0..<string.characters.count {\n        if string.substring(index,\
    \ string.characters.count) == substring {\n            count += 1\n        }\n\
    \    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpja6rt6dx.swift:11:29: error: 'characters' is unavailable: Please\
    \ use String directly\n    for index in 0..<string.characters.count {\n      \
    \                      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpja6rt6dx.swift:12:19: error: value of type 'String' has no member\
    \ 'substring'\n        if string.substring(index, string.characters.count) ==\
    \ substring {\n           ~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824940
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if\
    \ string == \"\" {\n        return 0\n    }\n    if substring == \"\" {\n    \
    \    return countOccurrences(string, \"\")\n    }\n    var count = 0\n    var\
    \ start = 0\n    var end = string.count\n    while start < end {\n        start\
    \ = string.startIndex.advanced(by: start)\n        end = string.endIndex.advanced(by:\
    \ end)\n        if string.substring(from: start, length: substring.length) ==\
    \ substring {\n            count += 1\n        }\n    }\n    return count\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmptzan6cwy.swift:14:16: error: cannot find 'countOccurrences' in\
    \ scope\n        return countOccurrences(string, \"\")\n               ^~~~~~~~~~~~~~~~\n\
    /tmp/tmptzan6cwy.swift:20:35: error: value of type 'String.Index' has no member\
    \ 'advanced'\n        start = string.startIndex.advanced(by: start)\n        \
    \        ~~~~~~~~~~~~~~~~~ ^~~~~~~~\n/tmp/tmptzan6cwy.swift:21:31: error: value\
    \ of type 'String.Index' has no member 'advanced'\n        end = string.endIndex.advanced(by:\
    \ end)\n              ~~~~~~~~~~~~~~~ ^~~~~~~~\n/tmp/tmptzan6cwy.swift:22:19:\
    \ error: value of type 'String' has no member 'substring'\n        if string.substring(from:\
    \ start, length: substring.length) == substring {\n           ~~~~~~ ^~~~~~~~~\n\
    /tmp/tmptzan6cwy.swift:22:60: error: value of type 'String' has no member 'length'\n\
    \        if string.substring(from: start, length: substring.length) == substring\
    \ {\n                                                 ~~~~~~~~~ ^~~~~~\n"
  stdout: ''
  timestamp: 1659824940
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if\
    \ string == \"\" {\n        return 0\n    }\n    if substring == \"\" {\n    \
    \    return string.count\n    }\n    var count = 0\n    var start = 0\n    var\
    \ end = string.count\n    while start < end {\n        let mid = start + (end\
    \ - start) / 2\n        if string.substring(from: mid, length: substring.length)\
    \ == substring {\n            count += 1\n            start = mid + 1\n      \
    \  } else {\n            end = mid\n        }\n    }\n    return count\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp6v5pfc_u.swift:21:19: error: value of type 'String' has no member\
    \ 'substring'\n        if string.substring(from: mid, length: substring.length)\
    \ == substring {\n           ~~~~~~ ^~~~~~~~~\n/tmp/tmp6v5pfc_u.swift:21:58: error:\
    \ value of type 'String' has no member 'length'\n        if string.substring(from:\
    \ mid, length: substring.length) == substring {\n                            \
    \                   ~~~~~~~~~ ^~~~~~\n"
  stdout: ''
  timestamp: 1659824940
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    var\
    \ count = 0\n    for c in string.unicodeScalars {\n        if c == substring {\n\
    \            count += 1\n        }\n    }\n    return count\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\n\
    assert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string:\
    \ \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john\
    \ doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpd3rykh2s.swift:12:14: error: referencing operator function '=='\
    \ on 'StringProtocol' requires that 'Unicode.Scalar' conform to 'StringProtocol'\n\
    \        if c == substring {\n             ^\nSwift.StringProtocol:1:11: note:\
    \ where 'Self' = 'Unicode.Scalar'\nextension StringProtocol {\n          ^\n"
  stdout: ''
  timestamp: 1659824939
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if\
    \ string == \"\" {\n        return 0\n    }\n    if substring == \"\" {\n    \
    \    return count(string)\n    }\n    var count = 0\n    var i = 0\n    var j\
    \ = string.count\n    var k = substring.count\n    while i < j {\n        if string[i]\
    \ != substring[k] {\n            count = count + 1\n        }\n        i = i +\
    \ 1\n        k = k + 1\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp_uehf5fa.swift:14:16: error: use of local variable 'count' before\
    \ its declaration\n        return count(string)\n               ^\n/tmp/tmp_uehf5fa.swift:16:9:\
    \ note: 'count' declared here\n    var count = 0\n        ^\n/tmp/tmp_uehf5fa.swift:21:12:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if string[i] != substring[k] {\n      \
    \     ^~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly\
    \ marked unavailable here\n    public subscript(i: Int) -> Character { get }\n\
    \           ^\n/tmp/tmp_uehf5fa.swift:21:25: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n        if\
    \ string[i] != substring[k] {\n                        ^~~~~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1659824940
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    var\
    \ count = 0\n    for index in 0..<string.characters.count {\n        if string.substring(index,\
    \ string.characters.count) == substring {\n            count += 1\n        }\n\
    \    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpja6rt6dx.swift:11:29: error: 'characters' is unavailable: Please\
    \ use String directly\n    for index in 0..<string.characters.count {\n      \
    \                      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpja6rt6dx.swift:12:19: error: value of type 'String' has no member\
    \ 'substring'\n        if string.substring(index, string.characters.count) ==\
    \ substring {\n           ~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824940
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if\
    \ string == \"\" {\n        return 0\n    }\n    if substring == \"\" {\n    \
    \    return count(string)\n    }\n    var count = 0\n    var i = 0\n    var j\
    \ = string.characters.count\n    var k = substring.characters.count\n    while\
    \ i < j {\n        if string[i] == substring[j] {\n            count += 1\n  \
    \          i += 1\n            j += 1\n            k += 1\n        } else if string[i]\
    \ < substring[j] {\n            i += 1\n        } else {\n            j += 1\n\
    \        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpeq2cutr1.swift:14:16: error: use of local variable 'count' before\
    \ its declaration\n        return count(string)\n               ^\n/tmp/tmpeq2cutr1.swift:16:9:\
    \ note: 'count' declared here\n    var count = 0\n        ^\n/tmp/tmpeq2cutr1.swift:18:20:\
    \ error: 'characters' is unavailable: Please use String directly\n    var j =\
    \ string.characters.count\n                   ^~~~~~~~~~\nSwift.String:5:16: note:\
    \ 'characters' was obsoleted in Swift 5.0\n    public var characters: String {\
    \ get set }\n               ^\n/tmp/tmpeq2cutr1.swift:19:23: error: 'characters'\
    \ is unavailable: Please use String directly\n    var k = substring.characters.count\n\
    \                      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpeq2cutr1.swift:21:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if string[i]\
    \ == substring[j] {\n           ^~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpeq2cutr1.swift:21:25: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if string[i] == substring[j] {\n                        ^~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpeq2cutr1.swift:26:19:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        } else if string[i] < substring[j] {\n\
    \                  ^~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has been\
    \ explicitly marked unavailable here\n    public subscript(i: Int) -> Character\
    \ { get }\n           ^\n/tmp/tmpeq2cutr1.swift:26:31: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        } else if string[i] < substring[j] {\n             "
  stdout: ''
  timestamp: 1659824940
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if\
    \ string == \"\" {\n        return 0\n    }\n    if substring == \"\" {\n    \
    \    return count(string)\n    }\n    var count = 0\n    var start = 0\n    var\
    \ end = count(string)\n    while start < end {\n        let mid = start + (end\
    \ - start) / 2\n        if string[mid] == substring[0] {\n            start =\
    \ mid + 1\n            count += 1\n        } else if string[mid] == substring[1]\
    \ {\n            end = mid - 1\n            count += 2\n        } else {\n   \
    \         start = mid + 1\n            end = mid\n        }\n    }\n    return\
    \ count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp10n10zkg.swift:14:16: error: use of local variable 'count' before\
    \ its declaration\n        return count(string)\n               ^\n/tmp/tmp10n10zkg.swift:16:9:\
    \ note: 'count' declared here\n    var count = 0\n        ^\n/tmp/tmp10n10zkg.swift:18:15:\
    \ error: cannot call value of non-function type 'Int'\n    var end = count(string)\n\
    \              ^\n"
  stdout: ''
  timestamp: 1659824940
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    var\
    \ count = 0\n    for c in string.unicodeScalars {\n        if c == substring {\n\
    \            count += 1\n        }\n    }\n    return count\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\n\
    assert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string:\
    \ \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john\
    \ doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpd3rykh2s.swift:12:14: error: referencing operator function '=='\
    \ on 'StringProtocol' requires that 'Unicode.Scalar' conform to 'StringProtocol'\n\
    \        if c == substring {\n             ^\nSwift.StringProtocol:1:11: note:\
    \ where 'Self' = 'Unicode.Scalar'\nextension StringProtocol {\n          ^\n"
  stdout: ''
  timestamp: 1659824939
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    let\
    \ start = string.startIndex.advancedBy(substring.startIndex)\n    let end = string.endIndex.advancedBy(substring.endIndex)\n\
    \    let index = string.index(start, offsetBy: substring.count)\n    return index\
    \ == end ? 0 : index - start\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpm_c8mzvt.swift:10:35: error: value of type 'String.Index' has no\
    \ member 'advancedBy'\n    let start = string.startIndex.advancedBy(substring.startIndex)\n\
    \                ~~~~~~~~~~~~~~~~~ ^~~~~~~~~~\n/tmp/tmpm_c8mzvt.swift:11:31: error:\
    \ value of type 'String.Index' has no member 'advancedBy'\n    let end = string.endIndex.advancedBy(substring.endIndex)\n\
    \              ~~~~~~~~~~~~~~~ ^~~~~~~~~~\n/tmp/tmpm_c8mzvt.swift:13:25: error:\
    \ cannot convert return expression of type 'Duration' to return type 'Int'\n \
    \   return index == end ? 0 : index - start\n           ~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824940
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if\
    \ string == \"\" || substring == \"\" {\n        return 0\n    }\n    var count\
    \ = 0\n    var start = 0\n    var end = string.count\n    while start < end {\n\
    \        let index = string.index(start, offsetBy: substring.count)\n        if\
    \ index == nil {\n            break\n        }\n        start = index!\n     \
    \   count += 1\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpig5gmp3b.swift:17:34: error: cannot convert value of type 'Int'\
    \ to expected argument type 'String.Index'\n        let index = string.index(start,\
    \ offsetBy: substring.count)\n                                 ^\n"
  stdout: ''
  timestamp: 1659824940
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    var\
    \ count = 0\n    for index in 0..<string.characters.count {\n        if string.substring(index,\
    \ string.characters.count) == substring {\n            count += 1\n        }\n\
    \    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpja6rt6dx.swift:11:29: error: 'characters' is unavailable: Please\
    \ use String directly\n    for index in 0..<string.characters.count {\n      \
    \                      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpja6rt6dx.swift:12:19: error: value of type 'String' has no member\
    \ 'substring'\n        if string.substring(index, string.characters.count) ==\
    \ substring {\n           ~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824940
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if\
    \ string == \"\" {\n        return 0\n    }\n    if substring == \"\" {\n    \
    \    return count(string)\n    }\n    var count = 0\n    var i = 0\n    var j\
    \ = 0\n    var k = 0\n    var last = 0\n    var last2 = 0\n    var last3 = 0\n\
    \    var last4 = 0\n    var last5 = 0\n    var last6 = 0\n    var last7 = 0\n\
    \    var last8 = 0\n    var last9 = 0\n    var last10 = 0\n    var last11 = 0\n\
    \    var last12 = 0\n    var last13 = 0\n    var last14 = 0\n    var last15 =\
    \ 0\n    var last16 = 0\n    var last17 = 0\n    var last18 = 0\n    var last19\
    \ = 0\n    var last20 = 0\n    var last21 = 0\n    var last22 = 0\n    var last23\
    \ = 0\n    var last24 = 0\n    var last25 = 0\n    var last26 = 0\n    var last27\
    \ = 0\n    var last28 = 0\n    var last29 = 0\n    var last30 = 0\n    var last31\
    \ = 0\n    var last32 = 0\n    var last33 = 0\n    var last34 = 0\n    var last35\
    \ = 0\n    var last36 = 0\n    var last37 = 0\n    var last38 = 0\n    var last39\
    \ = 0\n    var last40 = 0\n    var last41 = 0\n    var last42 = 0\n    var last43\
    \ = 0\n    var last44 = 0\n    var last45 = 0\n    var last46 = 0\n    var last47\
    \ = 0\n    var last48 = 0\n    var last49 = 0\n    var last50 = 0\n    var last51\
    \ = 0\n    var last52 = 0\n    var last53 = 0\n    var last54 = 0\n    var last55\
    \ = 0\n    var last56 = 0\n    var last57 = 0\n    var last58 = 0\n    var last59\
    \ = 0\n    var last60 = 0\n    var last61 = 0\n    var last62 = 0\n    var last63\
    \ = 0\n    var last64 = 0\n    var last65 = 0\n    var last66 = 0\n    var last67\
    \ = 0\n    var last68 = 0\n    var last69 = 0\n    var last70 = 0\n    var last71\
    \ = 0\n    var last72 = 0\n    var last73 = 0\n    var last74 = 0\n    var last75\
    \ = 0\n    var last76 = 0\n    var last77 = 0\n    var last78 = 0\n    var last79\
    \ = 0\n    var last80 = 0\n    var last81 = 0\n    var last82 = 0\n    var last83\
    \ = 0\n    var last84 = 0\n    var last85 = 0\n    var last86 = 0\n    var last87\
    \ = 0\n    var last88 = 0\n    var last89 = 0\n    var last90 = 0\n    var last91\
    \ = 0\n    var last92 = 0\n    var last93 = 0\n    var last94 = 0\n    var last95\
    \ = 0\n    var \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpdcagbxl6.swift:115:8: error: expected pattern\n    var \n     \
    \  ^\n/tmp/tmpdcagbxl6.swift:14:16: error: use of local variable 'count' before\
    \ its declaration\n        return count(string)\n               ^\n/tmp/tmpdcagbxl6.swift:16:9:\
    \ note: 'count' declared here\n    var count = 0\n        ^\n"
  stdout: ''
  timestamp: 1659824939
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if\
    \ string == \"\" {\n        return 0\n    }\n    if substring == \"\" {\n    \
    \    return countOccurrences(string, \"\")\n    }\n    var count = 0\n    var\
    \ last = 0\n    for i := 0; i < len(string); i++ {\n        if string[i] == substring[0]\
    \ {\n            count += countOccurrences(string, substring[1:])\n          \
    \  last = i + 1\n        }\n    }\n    return count + countOccurrences(string,\
    \ substring[last:])\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp4klit3np.swift:18:12: error: expected type\n    for i := 0; i <\
    \ len(string); i++ {\n           ^\n            <#type#>\n/tmp/tmp4klit3np.swift:18:12:\
    \ error: expected 'in' after for-each pattern\n    for i := 0; i < len(string);\
    \ i++ {\n           ^\n/tmp/tmp4klit3np.swift:18:12: error: expected Sequence\
    \ expression for for-each loop\n    for i := 0; i < len(string); i++ {\n     \
    \      ^\n/tmp/tmp4klit3np.swift:20:58: error: expected ',' separator\n      \
    \      count += countOccurrences(string, substring[1:])\n                    \
    \                                     ^\n                                    \
    \                     ,\n/tmp/tmp4klit3np.swift:20:58: error: expected expression\
    \ in list of expressions\n            count += countOccurrences(string, substring[1:])\n\
    \                                                         ^\n/tmp/tmp4klit3np.swift:24:60:\
    \ error: expected expression in list of expressions\n    return count + countOccurrences(string,\
    \ substring[last:])\n                                                        \
    \   ^\n/tmp/tmp4klit3np.swift:14:16: error: cannot find 'countOccurrences' in\
    \ scope\n        return countOccurrences(string, \"\")\n               ^~~~~~~~~~~~~~~~\n\
    /tmp/tmp4klit3np.swift:24:20: error: cannot find 'countOccurrences' in scope\n\
    \    return count + countOccurrences(string, substring[last:])\n             \
    \      ^~~~~~~~~~~~~~~~\n/tmp/tmp4klit3np.swift:24:60: error: missing argument\
    \ for parameter #1 in call\n    return count + countOccurrences(string, substring[last:])\n\
    \                                                           ^\n              \
    \                                             <#String.Index#>\nSwift.String:12:12:\
    \ note: 'subscript(_:)' declared here\n    public subscript(i: String.Index) ->\
    \ Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1659824940
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if\
    \ string == \"\" {\n        return 0\n    }\n    if substring == \"\" {\n    \
    \    return string.length\n    }\n    var count = 0\n    var i = 0\n    var j\
    \ = string.length - 1\n    while i < j {\n        if string[i] == substring[0]\
    \ {\n            count += 1\n            i += substring.length - 1\n        }\
    \ else if string[j] == substring[0] {\n            count -= 1\n            j -=\
    \ 1\n        } else {\n            i += 1\n            j += 1\n        }\n   \
    \ }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmplf1hn_2x.swift:14:23: error: value of type 'String' has no member\
    \ 'length'\n        return string.length\n               ~~~~~~ ^~~~~~\n/tmp/tmplf1hn_2x.swift:18:20:\
    \ error: value of type 'String' has no member 'length'\n    var j = string.length\
    \ - 1\n            ~~~~~~ ^~~~~~\n/tmp/tmplf1hn_2x.swift:20:12: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if string[i] == substring[0] {\n           ^~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmplf1hn_2x.swift:20:25:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if string[i] == substring[0] {\n      \
    \                  ^~~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has\
    \ been explicitly marked unavailable here\n    public subscript(i: Int) -> Character\
    \ { get }\n           ^\n/tmp/tmplf1hn_2x.swift:22:28: error: value of type 'String'\
    \ has no member 'length'\n            i += substring.length - 1\n            \
    \     ~~~~~~~~~ ^~~~~~\n"
  stdout: ''
  timestamp: 1659824940
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    var\
    \ count = 0\n    for index in 0..<string.characters.count {\n        if string.substring(from:\
    \ index).lowercased() == substring.lowercased() {\n            count += 1\n  \
    \      }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpzebs1vtl.swift:11:29: error: 'characters' is unavailable: Please\
    \ use String directly\n    for index in 0..<string.characters.count {\n      \
    \                      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpzebs1vtl.swift:12:19: error: value of type 'String' has no member\
    \ 'substring'\n        if string.substring(from: index).lowercased() == substring.lowercased()\
    \ {\n           ~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824940
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    var\
    \ count = 0\n    for index in 0..<string.characters.count {\n        if string.substring(from:\
    \ index).contains(substring) {\n            count += 1\n        }\n    }\n   \
    \ return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpc_6mk6oo.swift:11:29: error: 'characters' is unavailable: Please\
    \ use String directly\n    for index in 0..<string.characters.count {\n      \
    \                      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpc_6mk6oo.swift:12:19: error: value of type 'String' has no member\
    \ 'substring'\n        if string.substring(from: index).contains(substring) {\n\
    \           ~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824940
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    var\
    \ count = 0\n    for index in 0..<string.characters.count {\n        if string.characters[index]\
    \ == substring.characters[index] {\n            count += 1\n        }\n    }\n\
    \    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpgtz4l7mp.swift:11:29: error: 'characters' is unavailable: Please\
    \ use String directly\n    for index in 0..<string.characters.count {\n      \
    \                      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpgtz4l7mp.swift:12:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if string.characters[index]\
    \ == substring.characters[index] {\n           ^~~~~~~~~~~~~~~~~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpgtz4l7mp.swift:12:19:\
    \ error: 'characters' is unavailable: Please use String directly\n        if string.characters[index]\
    \ == substring.characters[index] {\n                  ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmpgtz4l7mp.swift:12:40: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if string.characters[index] == substring.characters[index] {\n      \
    \                                 ^~~~~~~~~~~~~~~~~~~~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpgtz4l7mp.swift:12:50:\
    \ error: 'characters' is unavailable: Please use String directly\n        if string.characters[index]\
    \ == substring.characters[index] {\n                                         \
    \        ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n"
  stdout: ''
  timestamp: 1659824940
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if\
    \ string == \"\" || substring == \"\" {\n        return 0\n    }\n    var count\
    \ = 0\n    var i = 0\n    var j = string.count\n    var k = substring.count\n\
    \    while i < j {\n        if string[i] == substring[k] {\n            count\
    \ += 1\n            i += 1\n            k += 1\n            if k == substring.count\
    \ {\n                k = 0\n            }\n        } else {\n            i +=\
    \ 1\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpq3nu528u.swift:18:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if string[i]\
    \ == substring[k] {\n           ^~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpq3nu528u.swift:18:25: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if string[i] == substring[k] {\n                        ^~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpq3nu528u.swift:15:9:\
    \ warning: variable 'j' was never mutated; consider changing to 'let' constant\n\
    \    var j = string.count\n    ~~~ ^\n    let\n"
  stdout: ''
  timestamp: 1659824940
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if\
    \ string == \"\" {\n        return 0\n    }\n    if substring == \"\" {\n    \
    \    return countOccurrences(string, \"\")\n    }\n    var count = 0\n    var\
    \ start = 0\n    var end = string.count\n    var substringLength = substring.count\n\
    \    while start < end {\n        let index = string.index(start, offsetBy: substringLength)\n\
    \        if index == nil {\n            break\n        }\n        if string.substring(with:\
    \ index) == substring {\n            count += 1\n            start = index\n \
    \       } else {\n            start = index\n        }\n    }\n    return count\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmptfvt7f5j.swift:14:16: error: cannot find 'countOccurrences' in\
    \ scope\n        return countOccurrences(string, \"\")\n               ^~~~~~~~~~~~~~~~\n\
    /tmp/tmptfvt7f5j.swift:21:34: error: cannot convert value of type 'Int' to expected\
    \ argument type 'String.Index'\n        let index = string.index(start, offsetBy:\
    \ substringLength)\n                                 ^\n/tmp/tmptfvt7f5j.swift:25:19:\
    \ error: value of type 'String' has no member 'substring'\n        if string.substring(with:\
    \ index) == substring {\n           ~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824940
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if\
    \ string == \"\" {\n        return 0\n    }\n    if substring == \"\" {\n    \
    \    return countOccurrences(string, \"\")\n    }\n    var count = 0\n    var\
    \ i = 0\n    for c in string {\n        if c == substring {\n            count\
    \ = count + 1\n        }\n        if i == len(string) - 1 {\n            break\n\
    \        }\n        if c == substring[i] {\n            count = count + 1\n  \
    \      }\n        i += 1\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmprbpiyb2a.swift:14:16: error: cannot find 'countOccurrences' in\
    \ scope\n        return countOccurrences(string, \"\")\n               ^~~~~~~~~~~~~~~~\n\
    /tmp/tmprbpiyb2a.swift:19:14: error: binary operator '==' cannot be applied to\
    \ operands of type 'Character' and 'String'\n        if c == substring {\n   \
    \        ~ ^  ~~~~~~~~~\n/tmp/tmprbpiyb2a.swift:19:14: note: overloads for '=='\
    \ exist with these partially matching parameter lists: (Character, Character),\
    \ (String, String)\n        if c == substring {\n             ^\n/tmp/tmprbpiyb2a.swift:22:17:\
    \ error: cannot find 'len' in scope\n        if i == len(string) - 1 {\n     \
    \           ^~~\n/tmp/tmprbpiyb2a.swift:25:17: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n        if\
    \ c == substring[i] {\n                ^~~~~~~~~~~~\nSwift.String:3:12: note:\
    \ 'subscript(_:)' has been explicitly marked unavailable here\n    public subscript(i:\
    \ Int) -> Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1659824940
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if\
    \ string == \"\" {\n        return 0\n    }\n    if substring == \"\" {\n    \
    \    return count(string)\n    }\n    var count = 0\n    var i = 0\n    var j\
    \ = 0\n    var k = 0\n    var stringLength = count(string)\n    var substringLength\
    \ = count(substring)\n    while i < stringLength && j < substringLength {\n  \
    \      if string[i] == substring[j] {\n            count += 1\n            i +=\
    \ 1\n            j += 1\n        } else if string[i] == substring[k] {\n     \
    \       count += 1\n            i += 1\n            k += 1\n        } else {\n\
    \            i += 1\n        }\n    }\n    return count\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\n\
    assert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string:\
    \ \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john\
    \ doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpcpkbo0ii.swift:14:16: error: use of local variable 'count' before\
    \ its declaration\n        return count(string)\n               ^\n/tmp/tmpcpkbo0ii.swift:16:9:\
    \ note: 'count' declared here\n    var count = 0\n        ^\n/tmp/tmpcpkbo0ii.swift:20:24:\
    \ error: cannot call value of non-function type 'Int'\n    var stringLength =\
    \ count(string)\n                       ^\n/tmp/tmpcpkbo0ii.swift:21:27: error:\
    \ cannot call value of non-function type 'Int'\n    var substringLength = count(substring)\n\
    \                          ^\n/tmp/tmpcpkbo0ii.swift:23:12: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if string[i] == substring[j] {\n           ^~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpcpkbo0ii.swift:23:25:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if string[i] == substring[j] {\n      \
    \                  ^~~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has\
    \ been explicitly marked unavailable here\n    public subscript(i: Int) -> Character\
    \ { get }\n           ^\n/tmp/tmpcpkbo0ii.swift:27:19: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        } else if string[i] == substring[k] {\n                  ^~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpcpkbo0ii.swift:27:32:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        } else if string[i] == substring[k] {\n\
    \                               ^~~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1659824940
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if\
    \ string == \"\" {\n        return 0\n    }\n    if substring == \"\" {\n    \
    \    return count(string)\n    }\n    var count = 0\n    var i = 0\n    var j\
    \ = string.count\n    var k = substring.count\n    while i < j {\n        if string[i]\
    \ == substring[0] {\n            count += 1\n            i += k\n        } else\
    \ {\n            i += 1\n        }\n    }\n    return count\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\n\
    assert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string:\
    \ \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john\
    \ doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp2jpnlaru.swift:14:16: error: use of local variable 'count' before\
    \ its declaration\n        return count(string)\n               ^\n/tmp/tmp2jpnlaru.swift:16:9:\
    \ note: 'count' declared here\n    var count = 0\n        ^\n/tmp/tmp2jpnlaru.swift:21:12:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if string[i] == substring[0] {\n      \
    \     ^~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly\
    \ marked unavailable here\n    public subscript(i: Int) -> Character { get }\n\
    \           ^\n/tmp/tmp2jpnlaru.swift:21:25: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n        if\
    \ string[i] == substring[0] {\n                        ^~~~~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1659824940
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if\
    \ string == \"\" {\n        return 0\n    }\n    if substring == \"\" {\n    \
    \    return countOccurrences(string, \"\")\n    }\n    var count = 0\n    var\
    \ lastIndex = string.startIndex\n    for _ in string.unicodeScalars {\n      \
    \  if string.unicodeScalars.contains(substring) {\n            count += 1\n  \
    \          lastIndex = string.index(lastIndex, offsetBy: 1)\n        } else {\n\
    \            lastIndex = string.index(lastIndex, offsetBy: -1)\n        }\n  \
    \  }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpf0__juv3.swift:14:16: error: cannot find 'countOccurrences' in\
    \ scope\n        return countOccurrences(string, \"\")\n               ^~~~~~~~~~~~~~~~\n\
    /tmp/tmpf0__juv3.swift:19:19: error: instance method 'contains' requires the types\
    \ 'Unicode.Scalar' and 'String.Element' (aka 'Character') be equivalent\n    \
    \    if string.unicodeScalars.contains(substring) {\n                  ^\n_StringProcessing.Collection:3:17:\
    \ note: where 'Self.Element' = 'Unicode.Scalar', 'C.Element' = 'String.Element'\
    \ (aka 'Character')\n    public func contains<C>(_ other: C) -> Bool where C :\
    \ Collection, Self.Element == C.Element\n                ^\n"
  stdout: ''
  timestamp: 1659824940
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if\
    \ string == \"\" {\n        return 0\n    }\n    if substring == \"\" {\n    \
    \    return countOccurrences(string, \"\")\n    }\n    var count = 0\n    var\
    \ i = 0\n    var j = 0\n    var k = 0\n    var l = 0\n    var m = 0\n    var n\
    \ = 0\n    var o = 0\n    var p = 0\n    var q = 0\n    var r = 0\n    var s =\
    \ 0\n    var t = 0\n    var u = 0\n    var v = 0\n    var w = 0\n    var x = 0\n\
    \    var y = 0\n    var z = 0\n    var A = 0\n    var B = 0\n    var C = 0\n \
    \   var D = 0\n    var E = 0\n    var F = 0\n    var G = 0\n    var H = 0\n  \
    \  var I = 0\n    var J = 0\n    var K = 0\n    var L = 0\n    var M = 0\n   \
    \ var N = 0\n    var O = 0\n    var P = 0\n    var Q = 0\n    var R = 0\n    var\
    \ S = 0\n    var T = 0\n    var U = 0\n    var V = 0\n    var W = 0\n    var X\
    \ = 0\n    var Y = 0\n    var Z = 0\n    var a = 0\n    var b = 0\n    var c =\
    \ 0\n    var d = 0\n    var e = 0\n    var f = 0\n    var g = 0\n    var h = 0\n\
    \    var i = 0\n    var j = 0\n    var k = 0\n    var l = 0\n    var m = 0\n \
    \   var n = 0\n    var o = 0\n    var p = 0\n    var q = 0\n    var r = 0\n  \
    \  var s = 0\n    var t = 0\n    var u = 0\n    var v = 0\n    var w = 0\n   \
    \ var x = 0\n    var y = 0\n    var z = 0\n    var A = 0\n    var B = 0\n    var\
    \ C = 0\n    var D = 0\n    var E = 0\n    var F = 0\n    var G = 0\n    var H\
    \ = 0\n    var I = 0\n    var J = 0\n    var K = 0\n    var L = 0\n    var M =\
    \ 0\n    var N = 0\n    var O = 0\n    var P = 0\n    var Q = 0\n    var R = 0\n\
    \    var S = 0\n    var T = 0\n    var U = 0\n    var V = 0\n    var W = 0\n \
    \   var X = 0\n    var Y = 0\n    var Z = 0\n    var a = 0\n    var b = 0\n  \
    \  var c = 0\n    var d = 0\n    var e = 0\n    var f = 0\n    var g = 0\n   \
    \ var h = 0\n    var i = 0\n    var j = 0\n    var k = 0\n    var l = 0\n    var\
    \ m = 0\n    var n = 0\n    var o = 0\n    var p = 0\n    var q = 0\n    var r\
    \ = 0\n    var s = 0\n    var t = 0\n    var u = 0\n    var v = 0\n    var w =\
    \ 0\n    var x = 0\n    var y = 0\n    var z = 0\n\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp5wvgi5uy.swift:14:16: error: cannot find 'countOccurrences' in\
    \ scope\n        return countOccurrences(string, \"\")\n               ^~~~~~~~~~~~~~~~\n\
    /tmp/tmp5wvgi5uy.swift:69:9: error: invalid redeclaration of 'i'\n    var i =\
    \ 0\n        ^\n/tmp/tmp5wvgi5uy.swift:17:9: note: 'i' previously declared here\n\
    \    var i = 0\n        ^\n/tmp/tmp5wvgi5uy.swift:70:9: error: invalid redeclaration\
    \ of 'j'\n    var j = 0\n        ^\n/tmp/tmp5wvgi5uy.swift:18:9: note: 'j' previously\
    \ declared here\n    var j = 0\n        ^\n/tmp/tmp5wvgi5uy.swift:71:9: error:\
    \ invalid redeclaration of 'k'\n    var k = 0\n        ^\n/tmp/tmp5wvgi5uy.swift:19:9:\
    \ note: 'k' previously declared here\n    var k = 0\n        ^\n/tmp/tmp5wvgi5uy.swift:72:9:\
    \ error: invalid redeclaration of 'l'\n    var l = 0\n        ^\n/tmp/tmp5wvgi5uy.swift:20:9:\
    \ note: 'l' previously declared here\n    var l = 0\n        ^\n/tmp/tmp5wvgi5uy.swift:73:9:\
    \ error: invalid redeclaration of 'm'\n    var m = 0\n        ^\n/tmp/tmp5wvgi5uy.swift:21:9:\
    \ note: 'm' previously declared here\n    var m = 0\n        ^\n/tmp/tmp5wvgi5uy.swift:74:9:\
    \ error: invalid redeclaration of 'n'\n    var n = 0\n        ^\n/tmp/tmp5wvgi5uy.swift:22:9:\
    \ note: 'n' previously declared here\n    var n = 0\n        ^\n/tmp/tmp5wvgi5uy.swift:75:9:\
    \ error: invalid redeclaration of 'o'\n    var o = 0\n        ^\n/tmp/tmp5wvgi5uy.swift:23:9:\
    \ note: 'o' previously declared here\n    var o = 0\n        ^\n/tmp/tmp5wvgi5uy.swift:76:9:\
    \ error: invalid redeclaration of 'p'\n    var p = 0\n        ^\n/tmp/tmp5wvgi5uy.swift:24:9:\
    \ note: 'p' previously declared here\n    var p = 0\n        ^\n/tmp/tmp5wvgi5uy.swift:77:9:\
    \ error: invalid redeclaration of 'q'\n    var q = 0\n        ^\n/tmp/tmp5wvgi5uy.swift:25:9:\
    \ note: 'q' previously declared here\n    var q = 0\n        ^\n/tmp/tmp5wvgi5uy.swift:78:9:\
    \ error: invalid redeclaration of 'r'\n    var r = 0\n        ^\n/tmp/tmp5wvgi5uy.swift:26:9:\
    \ note: 'r' previously declared here\n    var r = 0\n        ^\n/tmp/tmp5wvgi5uy.swift:79:9:\
    \ error: invalid redeclaration of 's'\n    var s = 0\n        ^\n/tmp/tmp5wvgi5uy.swift:27:9:\
    \ note: '"
  stdout: ''
  timestamp: 1659824940
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    return\
    \ count_overlapping_cases(string, substring)\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp__9p21xq.swift:10:12: error: cannot find 'count_overlapping_cases'\
    \ in scope\n    return count_overlapping_cases(string, substring)\n          \
    \ ^~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824940
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if\
    \ string == \"\" {\n        return 0\n    }\n    if substring == \"\" {\n    \
    \    return 1\n    }\n    var count = 0\n    var last = 0\n    for i := 0; i <\
    \ len(string); i++ {\n        if string[i] == substring[0] {\n            count++\n\
    \            last = i\n        }\n    }\n    for i := 0; i < len(substring); i++\
    \ {\n        if string[last+i] != substring[i] {\n            count++\n      \
    \  }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp1he1txsk.swift:18:12: error: expected type\n    for i := 0; i <\
    \ len(string); i++ {\n           ^\n            <#type#>\n/tmp/tmp1he1txsk.swift:18:12:\
    \ error: expected 'in' after for-each pattern\n    for i := 0; i < len(string);\
    \ i++ {\n           ^\n/tmp/tmp1he1txsk.swift:18:12: error: expected Sequence\
    \ expression for for-each loop\n    for i := 0; i < len(string); i++ {\n     \
    \      ^\n/tmp/tmp1he1txsk.swift:24:12: error: expected type\n    for i := 0;\
    \ i < len(substring); i++ {\n           ^\n            <#type#>\n/tmp/tmp1he1txsk.swift:24:12:\
    \ error: expected 'in' after for-each pattern\n    for i := 0; i < len(substring);\
    \ i++ {\n           ^\n/tmp/tmp1he1txsk.swift:24:12: error: expected Sequence\
    \ expression for for-each loop\n    for i := 0; i < len(substring); i++ {\n  \
    \         ^\n"
  stdout: ''
  timestamp: 1659824940
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if\
    \ string == \"\" {\n        return 0\n    }\n    if substring == \"\" {\n    \
    \    return string.count\n    }\n    var count = 0\n    var i = 0\n    var j =\
    \ 0\n    var k = string.startIndex\n    while i < string.count {\n        j =\
    \ string.startIndex\n        while j < string.count && substring[j] == string[i]\
    \ {\n            j += 1\n        }\n        if j == string.startIndex {\n    \
    \        count += 1\n            i = k\n        } else {\n            count +=\
    \ j - k\n            k = j\n        }\n    }\n    return count\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\n\
    assert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string:\
    \ \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john\
    \ doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpfahncsia.swift:21:20: error: cannot assign value of type 'String.Index'\
    \ to type 'Int'\n        j = string.startIndex\n            ~~~~~~~^~~~~~~~~~\n\
    /tmp/tmpfahncsia.swift:22:35: error: 'subscript(_:)' is unavailable: cannot subscript\
    \ String with an Int, use a String.Index instead.\n        while j < string.count\
    \ && substring[j] == string[i] {\n                                  ^~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpfahncsia.swift:22:51:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        while j < string.count && substring[j]\
    \ == string[i] {\n                                                  ^~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpfahncsia.swift:25:14:\
    \ error: operator function '==' requires that 'String.Index' conform to 'BinaryInteger'\n\
    \        if j == string.startIndex {\n             ^\nSwift.BinaryInteger:2:24:\
    \ note: where 'Other' = 'String.Index'\n    public static func == <Other>(lhs:\
    \ Self, rhs: Other) -> Bool where Other : BinaryInteger\n                    \
    \   ^\n/tmp/tmpfahncsia.swift:27:17: error: cannot assign value of type 'String.Index'\
    \ to type 'Int'\n            i = k\n                ^\n/tmp/tmpfahncsia.swift:29:26:\
    \ error: cannot convert value of type 'String.Index' to expected argument type\
    \ 'Int'\n            count += j - k\n                         ^\n/tmp/tmpfahncsia.swift:30:17:\
    \ error: cannot assign value of type 'Int' to type 'String.Index'\n          \
    \  k = j\n                ^\n"
  stdout: ''
  timestamp: 1659824940
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if\
    \ string == \"\" {\n        return 0\n    }\n    if substring == \"\" {\n    \
    \    return countOccurrences(string, \"\")\n    }\n    return countOccurrences(string,\
    \ substring)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpwm9imvn4.swift:14:16: error: cannot find 'countOccurrences' in\
    \ scope\n        return countOccurrences(string, \"\")\n               ^~~~~~~~~~~~~~~~\n\
    /tmp/tmpwm9imvn4.swift:16:12: error: cannot find 'countOccurrences' in scope\n\
    \    return countOccurrences(string, substring)\n           ^~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824940
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    var\
    \ count = 0\n    for char in string.unicodeScalars {\n        if char == substring\
    \ {\n            count += 1\n        }\n    }\n    return count\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\n\
    assert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string:\
    \ \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john\
    \ doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpm2wc1w40.swift:12:17: error: referencing operator function '=='\
    \ on 'StringProtocol' requires that 'Unicode.Scalar' conform to 'StringProtocol'\n\
    \        if char == substring {\n                ^\nSwift.StringProtocol:1:11:\
    \ note: where 'Self' = 'Unicode.Scalar'\nextension StringProtocol {\n        \
    \  ^\n"
  stdout: ''
  timestamp: 1659824940
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if\
    \ string == \"\" {\n        return 0\n    }\n    if substring == \"\" {\n    \
    \    return count(string)\n    }\n    var count = 0\n    var i = 0\n    var j\
    \ = 0\n    var k = string.startIndex\n    while i < string.endIndex {\n      \
    \  if string[i] == substring[j] {\n            count += 1\n            i += 1\n\
    \            j += 1\n            if j == substring.endIndex {\n              \
    \  i += 1\n                j = 0\n            }\n        } else {\n          \
    \  if j == substring.startIndex {\n                i += 1\n                j =\
    \ 0\n            }\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpm4cuble5.swift:14:16: error: use of local variable 'count' before\
    \ its declaration\n        return count(string)\n               ^\n/tmp/tmpm4cuble5.swift:16:9:\
    \ note: 'count' declared here\n    var count = 0\n        ^\n/tmp/tmpm4cuble5.swift:20:13:\
    \ error: operator function '<' requires that 'String.Index' conform to 'BinaryInteger'\n\
    \    while i < string.endIndex {\n            ^\nSwift.BinaryInteger:4:24: note:\
    \ where 'Other' = 'String.Index'\n    public static func < <Other>(lhs: Self,\
    \ rhs: Other) -> Bool where Other : BinaryInteger\n                       ^\n\
    /tmp/tmpm4cuble5.swift:21:12: error: 'subscript(_:)' is unavailable: cannot subscript\
    \ String with an Int, use a String.Index instead.\n        if string[i] == substring[j]\
    \ {\n           ^~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly\
    \ marked unavailable here\n    public subscript(i: Int) -> Character { get }\n\
    \           ^\n/tmp/tmpm4cuble5.swift:21:25: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n        if\
    \ string[i] == substring[j] {\n                        ^~~~~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpm4cuble5.swift:25:18:\
    \ error: operator function '==' requires that 'String.Index' conform to 'BinaryInteger'\n\
    \            if j == substring.endIndex {\n                 ^\nSwift.BinaryInteger:2:24:\
    \ note: where 'Other' = 'String.Index'\n    public static func == <Other>(lhs:\
    \ Self, rhs: Other) -> Bool where Other : BinaryInteger\n                    \
    \   ^\n/tmp/tmpm4cuble5.swift:30:18: error: operator function '==' requires that\
    \ 'String.Index' conform to 'BinaryInteger'\n            if j == substring.startIndex\
    \ {\n                 ^\nSwift.BinaryInteger:2:24: note: where 'Other' = 'String.Index'\n\
    \    public static func == <Other>(lhs: Self, rhs: Other) -> Bool where Other\
    \ : BinaryInteger\n                       ^\n"
  stdout: ''
  timestamp: 1659824940
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if\
    \ string == \"\" {\n        return 0\n    }\n    if substring == \"\" {\n    \
    \    return count(string)\n    }\n    var count = 0\n    var i = 0\n    var j\
    \ = string.count\n    var k = substring.count\n    while i < j {\n        if string[i]\
    \ == substring[0] {\n            count += 1\n            i += k\n        } else\
    \ {\n            i += 1\n        }\n    }\n    return count\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\n\
    assert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string:\
    \ \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john\
    \ doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp2jpnlaru.swift:14:16: error: use of local variable 'count' before\
    \ its declaration\n        return count(string)\n               ^\n/tmp/tmp2jpnlaru.swift:16:9:\
    \ note: 'count' declared here\n    var count = 0\n        ^\n/tmp/tmp2jpnlaru.swift:21:12:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if string[i] == substring[0] {\n      \
    \     ^~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly\
    \ marked unavailable here\n    public subscript(i: Int) -> Character { get }\n\
    \           ^\n/tmp/tmp2jpnlaru.swift:21:25: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n        if\
    \ string[i] == substring[0] {\n                        ^~~~~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1659824940
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if\
    \ string == \"\" {\n        return 0\n    }\n    if substring == \"\" {\n    \
    \    return count(string)\n    }\n    var count = 0\n    var i = 0\n    var j\
    \ = string.count\n    var k = substring.count\n    while i < j {\n        if string[i]\
    \ == substring[0] {\n            count += 1\n            i += k\n        } else\
    \ if string[i] == substring[1] {\n            count += 1\n            i += k\n\
    \        } else if string[i] == substring[2] {\n            count += 1\n     \
    \       i += k\n        } else if string[i] == substring[3] {\n            count\
    \ += 1\n            i += k\n        } else if string[i] == substring[4] {\n  \
    \          count += 1\n            i += k\n        } else if string[i] == substring[5]\
    \ {\n            count += 1\n            i += k\n        } else if string[i] ==\
    \ substring[6] {\n            count += 1\n            i += k\n        } else if\
    \ string[i] == substring[7] {\n            count += 1\n            i += k\n  \
    \      } else if string[i] == substring[8] {\n            count += 1\n       \
    \     i += k\n        } else if string[i] == substring[9] {\n            count\
    \ += 1\n            i += k\n        } else if string[i] == substring[10] {\n \
    \           count += 1\n            i += k\n        } else if string[i] == substring[11]\
    \ {\n            count += 1\n            i += k\n        } else if string[i] ==\
    \ substring[12] {\n            count += 1\n            i += k\n        } else\
    \ if string[i] == substring[13] {\n            count += 1\n            i += k\n\
    \        } else if string[i] == substring[14] {\n            count += 1\n    \
    \        i += k\n        } else if string[i] == substring[15] {\n            count\
    \ += 1\n            i += k\n        } else if string[i] == substring[16] {\n \
    \           count += 1\n            i += k\n        } else if string[i] == substring[17]\
    \ {\n            count += 1\n            i += k\n        } else if string[i] ==\
    \ substring[18] {\n            count += 1\n            i += k\n        } else\
    \ if string[i] == substring[19] {\n            count += 1\n            i += k\n\
    \        } else if string[i] == substring[20] {\n            count += 1\n    \
    \        i += k\n        } else if string[i] == substring[21] {\n            count\
    \ += 1\n            i += k\n        } else if string[i] == substring[22] {\n \
    \           count += 1\n            i += k\n        } else if string[i] == substring[23]\
    \ {\n            count += 1\n            i += k\n        } else if string[i] ==\
    \ substring[24] {\n            count += 1\n            i += k\n        } else\
    \ if string[i] == substring[25] {\n            count += 1\n            i += k\n\
    \        } else if string[i] == substring[26] {\n            count += 1\n    \
    \        i += k\n        } else if string[i] == substring[27] {\n            count\
    \ += 1\n            i += k\n        } else if string[i] == \n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\n\
    assert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string:\
    \ \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john\
    \ doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpanzdg3mk.swift:106:1: error: expected expression after operator\n\
    }\n^\n/tmp/tmpanzdg3mk.swift:124:67: error: expected '}' at end of brace statement\n\
    assert(how_many_times(string: \"john doe\", substring: \"john\") == 1)\n     \
    \                                                             ^\n/tmp/tmpanzdg3mk.swift:9:63:\
    \ note: to match this opening '{'\nfunc how_many_times(string: String, substring:\
    \ String) -> Int {\n                                                         \
    \     ^\n/tmp/tmpanzdg3mk.swift:14:16: error: use of local variable 'count' before\
    \ its declaration\n        return count(string)\n               ^\n/tmp/tmpanzdg3mk.swift:16:9:\
    \ note: 'count' declared here\n    var count = 0\n        ^\n/tmp/tmpanzdg3mk.swift:21:12:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if string[i] == substring[0] {\n      \
    \     ^~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly\
    \ marked unavailable here\n    public subscript(i: Int) -> Character { get }\n\
    \           ^\n/tmp/tmpanzdg3mk.swift:21:25: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n        if\
    \ string[i] == substring[0] {\n                        ^~~~~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpanzdg3mk.swift:24:19:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        } else if string[i] == substring[1] {\n\
    \                  ^~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has been\
    \ explicitly marked unavailable here\n    public subscript(i: Int) -> Character\
    \ { get }\n           ^\n/tmp/tmpanzdg3mk.swift:24:32: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        } else if string[i] == substring[1] {\n                             \
    \  ^~~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly\
    \ marked un"
  stdout: ''
  timestamp: 1659824941
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if\
    \ string == \"\" {\n        return 0\n    }\n    if substring == \"\" {\n    \
    \    return countOccurrences(string, \"\")\n    }\n    var count = 0\n    var\
    \ i = 0\n    var j = 0\n    var k = string.startIndex\n    while i < string.endIndex\
    \ {\n        if string[k] == substring[j] {\n            count += 1\n        \
    \    i += 1\n            j += 1\n            if j == substring.endIndex {\n  \
    \              j += 1\n                k += 1\n            }\n        } else {\n\
    \            i = 0\n            j += 1\n            k += 1\n        }\n    }\n\
    \    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpb5oexpz5.swift:14:16: error: cannot find 'countOccurrences' in\
    \ scope\n        return countOccurrences(string, \"\")\n               ^~~~~~~~~~~~~~~~\n\
    /tmp/tmpb5oexpz5.swift:20:13: error: operator function '<' requires that 'String.Index'\
    \ conform to 'BinaryInteger'\n    while i < string.endIndex {\n            ^\n\
    Swift.BinaryInteger:4:24: note: where 'Other' = 'String.Index'\n    public static\
    \ func < <Other>(lhs: Self, rhs: Other) -> Bool where Other : BinaryInteger\n\
    \                       ^\n/tmp/tmpb5oexpz5.swift:21:25: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if string[k] == substring[j] {\n                        ^~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpb5oexpz5.swift:25:18:\
    \ error: operator function '==' requires that 'String.Index' conform to 'BinaryInteger'\n\
    \            if j == substring.endIndex {\n                 ^\nSwift.BinaryInteger:2:24:\
    \ note: where 'Other' = 'String.Index'\n    public static func == <Other>(lhs:\
    \ Self, rhs: Other) -> Bool where Other : BinaryInteger\n                    \
    \   ^\n/tmp/tmpb5oexpz5.swift:27:19: error: binary operator '+=' cannot be applied\
    \ to operands of type 'String.Index' and 'Int'\n                k += 1\n     \
    \           ~ ^  ~\n/tmp/tmpb5oexpz5.swift:32:15: error: binary operator '+='\
    \ cannot be applied to operands of type 'String.Index' and 'Int'\n           \
    \ k += 1\n            ~ ^  ~\n"
  stdout: ''
  timestamp: 1659824940
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if\
    \ string == \"\" || substring == \"\" {\n        return 0\n    }\n    var count\
    \ = 0\n    var i = 0\n    var j = string.count\n    var k = substring.count\n\
    \    while i < j {\n        if string[i] == substring[k] {\n            count\
    \ = count + 1\n            i = i + 1\n            k = k - 1\n        }\n     \
    \   j = j - 1\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpclhov3n4.swift:18:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if string[i]\
    \ == substring[k] {\n           ^~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpclhov3n4.swift:18:25: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if string[i] == substring[k] {\n                        ^~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1659824940
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if\
    \ string == \"\" {\n        return 0\n    }\n    if substring == \"\" {\n    \
    \    return 1\n    }\n    var count = 0\n    var last = 0\n    for i := 0; i <\
    \ len(string); i++ {\n        if string[i] == substring[0] {\n            count++\n\
    \            last = i\n        }\n        if string[i] == substring[1] {\n   \
    \         count++\n            last = i\n        }\n        if string[i] == substring[2]\
    \ {\n            count++\n            last = i\n        }\n        if string[i]\
    \ == substring[3] {\n            count++\n            last = i\n        }\n  \
    \      if string[i] == substring[4] {\n            count++\n            last =\
    \ i\n        }\n        if string[i] == substring[5] {\n            count++\n\
    \            last = i\n        }\n        if string[i] == substring[6] {\n   \
    \         count++\n            last = i\n        }\n        if string[i] == substring[7]\
    \ {\n            count++\n            last = i\n        }\n        if string[i]\
    \ == substring[8] {\n            count++\n            last = i\n        }\n  \
    \      if string[i] == substring[9] {\n            count++\n            last =\
    \ i\n        }\n        if string[i] == substring[10] {\n            count++\n\
    \            last = i\n        }\n        if string[i] == substring[11] {\n  \
    \          count++\n            last = i\n        }\n        if string[i] == substring[12]\
    \ {\n            count++\n            last = i\n        }\n        if string[i]\
    \ == substring[13] {\n            count++\n            last = i\n        }\n \
    \       if string[i] == substring[14] {\n            count++\n            last\
    \ = i\n        }\n        if string[i] == substring[15] {\n            count++\n\
    \            last = i\n        }\n        if string[i] == substring[16] {\n  \
    \          count++\n            last = i\n        }\n        if string[i] == substring[17]\
    \ {\n            count++\n            last = i\n        }\n        if string[i]\
    \ == substring[18] {\n            count++\n            last = i\n        }\n \
    \       if string[i] == substring[19] {\n            count++\n            last\
    \ = i\n        }\n        if string[i] == substring[20] {\n            count++\n\
    \            last = i\n        }\n        if string[i] == substring[21] {\n  \
    \          count++\n            last = i\n        }\n        if string[i] == substring[22]\
    \ {\n            count++\n            last = i\n        }\n        if string[i]\
    \ == substring[23] {\n            count++\n            last = i\n        }\n \
    \       if string[i] == substring[24] {\n            count++\n            last\
    \ = i\n        }\n        if string[i] == substring[25] {\n            count++\n\
    \            last = i\n        }\n        if string[i] == substring[26] {\n  \
    \          count++\n            last = i\n        }\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmps0lk27jy.swift:18:12: error: expected type\n    for i := 0; i <\
    \ len(string); i++ {\n           ^\n            <#type#>\n/tmp/tmps0lk27jy.swift:18:12:\
    \ error: expected 'in' after for-each pattern\n    for i := 0; i < len(string);\
    \ i++ {\n           ^\n/tmp/tmps0lk27jy.swift:18:12: error: expected Sequence\
    \ expression for for-each loop\n    for i := 0; i < len(string); i++ {\n     \
    \      ^\n/tmp/tmps0lk27jy.swift:145:67: error: expected '}' at end of brace statement\n\
    assert(how_many_times(string: \"john doe\", substring: \"john\") == 1)\n     \
    \                                                             ^\n/tmp/tmps0lk27jy.swift:9:63:\
    \ note: to match this opening '{'\nfunc how_many_times(string: String, substring:\
    \ String) -> Int {\n                                                         \
    \     ^\n/tmp/tmps0lk27jy.swift:130:6: error: operator functions can only be declared\
    \ at global or in type scope\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1659824940
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if\
    \ string == \"\" || substring == \"\" {\n        return 0\n    }\n    var count\
    \ = 0\n    var start = 0\n    var end = string.characters.count\n    while start\
    \ < end {\n        let index = string.index(string.startIndex, offsetBy: start)\n\
    \        let substringIndex = string.index(index, offsetBy: substring.characters.count)\n\
    \        if substringIndex == nil {\n            count += 1\n            start\
    \ = index + 1\n        } else {\n            start = substringIndex!.offsetBy\n\
    \        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp0jaxczdl.swift:15:22: error: 'characters' is unavailable: Please\
    \ use String directly\n    var end = string.characters.count\n               \
    \      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmp0jaxczdl.swift:18:70:\
    \ error: 'characters' is unavailable: Please use String directly\n        let\
    \ substringIndex = string.index(index, offsetBy: substring.characters.count)\n\
    \                                                                     ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmp0jaxczdl.swift:19:27:\
    \ warning: comparing non-optional value of type 'String.Index' to 'nil' always\
    \ returns false\n        if substringIndex == nil {\n           ~~~~~~~~~~~~~~\
    \ ^  ~~~\n/tmp/tmp0jaxczdl.swift:21:21: error: cannot convert value of type 'String.Index'\
    \ to expected argument type 'Int'\n            start = index + 1\n           \
    \         ^\n/tmp/tmp0jaxczdl.swift:23:35: error: cannot force unwrap value of\
    \ non-optional type 'String.Index'\n            start = substringIndex!.offsetBy\n\
    \                    ~~~~~~~~~~~~~~^\n                                  \n/tmp/tmp0jaxczdl.swift:23:37:\
    \ error: value of type 'String.Index' has no member 'offsetBy'\n            start\
    \ = substringIndex!.offsetBy\n                    ~~~~~~~~~~~~~~~ ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659824940
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    var\
    \ count = 0\n    for index in 0..<string.characters.count {\n        if string.substring(index,\
    \ string.characters.count) == substring {\n            count += 1\n        }\n\
    \    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpja6rt6dx.swift:11:29: error: 'characters' is unavailable: Please\
    \ use String directly\n    for index in 0..<string.characters.count {\n      \
    \                      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpja6rt6dx.swift:12:19: error: value of type 'String' has no member\
    \ 'substring'\n        if string.substring(index, string.characters.count) ==\
    \ substring {\n           ~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824940
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    var\
    \ count = 0\n    for index in 0..<string.characters.count {\n        if string.characters.contains(substring,\
    \ at: index) {\n            count += 1\n        }\n    }\n    return count\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpvmqb7rry.swift:11:29: error: 'characters' is unavailable: Please\
    \ use String directly\n    for index in 0..<string.characters.count {\n      \
    \                      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpvmqb7rry.swift:12:54: error: extra argument 'at' in call\n      \
    \  if string.characters.contains(substring, at: index) {\n                   \
    \                  ~~~~~~~~~~~~~~~~^~~~~~\n"
  stdout: ''
  timestamp: 1659824940
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if\
    \ string == \"\" || substring == \"\" {\n        return 0\n    }\n    var count\
    \ = 0\n    var i = 0\n    var j = string.count\n    var k = substring.count\n\
    \    while i < j {\n        if string[i] == substring[k] {\n            count\
    \ += 1\n            i += k\n            k += k\n        }\n        i += 1\n  \
    \  }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpgni0cqyv.swift:18:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if string[i]\
    \ == substring[k] {\n           ^~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpgni0cqyv.swift:18:25: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if string[i] == substring[k] {\n                        ^~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpgni0cqyv.swift:15:9:\
    \ warning: variable 'j' was never mutated; consider changing to 'let' constant\n\
    \    var j = string.count\n    ~~~ ^\n    let\n"
  stdout: ''
  timestamp: 1659824940
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if\
    \ string == \"\" {\n        return 0\n    }\n    if substring == \"\" {\n    \
    \    return count(string)\n    }\n    var count = 0\n    var i = 0\n    var j\
    \ = string.count\n    var k = substring.count\n    while i < j {\n        if string[i]\
    \ == substring[0] {\n            count = count + 1\n            i = i + 1\n  \
    \          while i < j && string[i] == substring[1] {\n                count =\
    \ count + 1\n                i = i + 1\n            }\n        } else {\n    \
    \        i = i + 1\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp7dx8ubf8.swift:14:16: error: use of local variable 'count' before\
    \ its declaration\n        return count(string)\n               ^\n/tmp/tmp7dx8ubf8.swift:16:9:\
    \ note: 'count' declared here\n    var count = 0\n        ^\n/tmp/tmp7dx8ubf8.swift:21:12:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if string[i] == substring[0] {\n      \
    \     ^~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly\
    \ marked unavailable here\n    public subscript(i: Int) -> Character { get }\n\
    \           ^\n/tmp/tmp7dx8ubf8.swift:21:25: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n        if\
    \ string[i] == substring[0] {\n                        ^~~~~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmp7dx8ubf8.swift:24:28:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n            while i < j && string[i] == substring[1]\
    \ {\n                           ^~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmp7dx8ubf8.swift:24:41: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \            while i < j && string[i] == substring[1] {\n                    \
    \                    ^~~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has\
    \ been explicitly marked unavailable here\n    public subscript(i: Int) -> Character\
    \ { get }\n           ^\n"
  stdout: ''
  timestamp: 1659824940
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if\
    \ string == \"\" || substring == \"\" {\n        return 0\n    }\n    var count\
    \ = 0\n    var i = 0\n    var j = 0\n    var k = 0\n    var stringLength = string.characters.count\n\
    \    var substringLength = substring.characters.count\n    for (i = 0; i < stringLength\
    \ && j < substringLength; i++) {\n        if string.characters[i] == substring.characters[j]\
    \ {\n            count++\n            j = j + 1\n            k = k + 1\n     \
    \       if k == substringLength {\n                j = j + 1\n               \
    \ k = 0\n            }\n        } else {\n            j = j + 1\n            k\
    \ = 0\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp0cn7d3jo.swift:19:5: error: C-style for statement has been removed\
    \ in Swift 3\n    for (i = 0; i < stringLength && j < substringLength; i++) {\n\
    \    ^   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp0cn7d3jo.swift:17:31:\
    \ error: 'characters' is unavailable: Please use String directly\n    var stringLength\
    \ = string.characters.count\n                              ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmp0cn7d3jo.swift:18:37: error: 'characters'\
    \ is unavailable: Please use String directly\n    var substringLength = substring.characters.count\n\
    \                                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n"
  stdout: ''
  timestamp: 1659824940
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    let\
    \ startIndex = string.startIndex.advancedBy(substring.startIndex)\n    let endIndex\
    \ = string.endIndex.advancedBy(-substring.endIndex)\n    let range = startIndex..<endIndex\n\
    \    return string.distance(from: range, to: startIndex) + string.distance(from:\
    \ range, to: endIndex)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp6jfj6hk9.swift:10:40: error: value of type 'String.Index' has no\
    \ member 'advancedBy'\n    let startIndex = string.startIndex.advancedBy(substring.startIndex)\n\
    \                     ~~~~~~~~~~~~~~~~~ ^~~~~~~~~~\n/tmp/tmp6jfj6hk9.swift:11:47:\
    \ error: unary operator '-' cannot be applied to an operand of type 'String.Index'\n\
    \    let endIndex = string.endIndex.advancedBy(-substring.endIndex)\n        \
    \                                      ^\n/tmp/tmp6jfj6hk9.swift:11:47: note:\
    \ overloads for '-' exist with these partially matching parameter lists: (Double),\
    \ (Float), (Float16), (Float80)\n    let endIndex = string.endIndex.advancedBy(-substring.endIndex)\n\
    \                                              ^\n/tmp/tmp6jfj6hk9.swift:11:36:\
    \ error: value of type 'String.Index' has no member 'advancedBy'\n    let endIndex\
    \ = string.endIndex.advancedBy(-substring.endIndex)\n                   ~~~~~~~~~~~~~~~\
    \ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824940
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    var\
    \ count = 0\n    for index in 0..<string.characters.count {\n        if string.substring(from:\
    \ index).lowercased() == substring.lowercased() {\n            count += 1\n  \
    \      }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpzebs1vtl.swift:11:29: error: 'characters' is unavailable: Please\
    \ use String directly\n    for index in 0..<string.characters.count {\n      \
    \                      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpzebs1vtl.swift:12:19: error: value of type 'String' has no member\
    \ 'substring'\n        if string.substring(from: index).lowercased() == substring.lowercased()\
    \ {\n           ~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824940
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    var\
    \ count = 0\n    for c in string {\n        if c == substring {\n            count\
    \ += 1\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp1o2nzo8z.swift:12:14: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        if c == substring {\n\
    \           ~ ^  ~~~~~~~~~\n/tmp/tmp1o2nzo8z.swift:12:14: note: overloads for\
    \ '==' exist with these partially matching parameter lists: (Character, Character),\
    \ (String, String)\n        if c == substring {\n             ^\n"
  stdout: ''
  timestamp: 1659824940
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    let\
    \ startIndex = string.startIndex.advancedBy(substring.startIndex)\n    let endIndex\
    \ = string.endIndex.advancedBy(-substring.endIndex)\n    return string.distance(from:\
    \ startIndex, to: endIndex) + 1\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp2ux503lb.swift:10:40: error: value of type 'String.Index' has no\
    \ member 'advancedBy'\n    let startIndex = string.startIndex.advancedBy(substring.startIndex)\n\
    \                     ~~~~~~~~~~~~~~~~~ ^~~~~~~~~~\n/tmp/tmp2ux503lb.swift:11:47:\
    \ error: unary operator '-' cannot be applied to an operand of type 'String.Index'\n\
    \    let endIndex = string.endIndex.advancedBy(-substring.endIndex)\n        \
    \                                      ^\n/tmp/tmp2ux503lb.swift:11:47: note:\
    \ overloads for '-' exist with these partially matching parameter lists: (Double),\
    \ (Float), (Float16), (Float80)\n    let endIndex = string.endIndex.advancedBy(-substring.endIndex)\n\
    \                                              ^\n/tmp/tmp2ux503lb.swift:11:36:\
    \ error: value of type 'String.Index' has no member 'advancedBy'\n    let endIndex\
    \ = string.endIndex.advancedBy(-substring.endIndex)\n                   ~~~~~~~~~~~~~~~\
    \ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824940
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    var\
    \ count = 0\n    for c in string.unicodeScalars {\n        if c == substring {\n\
    \            count += 1\n        }\n    }\n    return count\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\n\
    assert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string:\
    \ \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john\
    \ doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpd3rykh2s.swift:12:14: error: referencing operator function '=='\
    \ on 'StringProtocol' requires that 'Unicode.Scalar' conform to 'StringProtocol'\n\
    \        if c == substring {\n             ^\nSwift.StringProtocol:1:11: note:\
    \ where 'Self' = 'Unicode.Scalar'\nextension StringProtocol {\n          ^\n"
  stdout: ''
  timestamp: 1659824939
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if\
    \ string == \"\" {\n        return 0\n    }\n    if substring == \"\" {\n    \
    \    return count(string)\n    }\n    var count = 0\n    var i = 0\n    var j\
    \ = string.count\n    while i < j {\n        if string[i] == substring[0] {\n\
    \            count += 1\n            i += count(substring)\n        } else {\n\
    \            i += 1\n        }\n    }\n    return count\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\n\
    assert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string:\
    \ \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john\
    \ doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmphm35p0q2.swift:14:16: error: use of local variable 'count' before\
    \ its declaration\n        return count(string)\n               ^\n/tmp/tmphm35p0q2.swift:16:9:\
    \ note: 'count' declared here\n    var count = 0\n        ^\n/tmp/tmphm35p0q2.swift:20:12:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if string[i] == substring[0] {\n      \
    \     ^~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly\
    \ marked unavailable here\n    public subscript(i: Int) -> Character { get }\n\
    \           ^\n/tmp/tmphm35p0q2.swift:20:25: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n        if\
    \ string[i] == substring[0] {\n                        ^~~~~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmphm35p0q2.swift:22:18:\
    \ error: cannot call value of non-function type 'Int'\n            i += count(substring)\n\
    \                 ^\n"
  stdout: ''
  timestamp: 1659824939
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    var\
    \ count = 0\n    for index in 0..<string.characters.count {\n        if string.characters.contains(substring,\
    \ range: NSMakeRange(index, substring.length)) {\n            count += 1\n   \
    \     }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpx5x5b6sb.swift:11:29: error: 'characters' is unavailable: Please\
    \ use String directly\n    for index in 0..<string.characters.count {\n      \
    \                      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpx5x5b6sb.swift:12:57: error: cannot find 'NSMakeRange' in scope\n\
    \        if string.characters.contains(substring, range: NSMakeRange(index, substring.length))\
    \ {\n                                                        ^~~~~~~~~~~\n/tmp/tmpx5x5b6sb.swift:12:57:\
    \ error: extra argument 'range' in call\n        if string.characters.contains(substring,\
    \ range: NSMakeRange(index, substring.length)) {\n                           \
    \          ~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpx5x5b6sb.swift:12:86:\
    \ error: value of type 'String' has no member 'length'\n        if string.characters.contains(substring,\
    \ range: NSMakeRange(index, substring.length)) {\n                           \
    \                                                ~~~~~~~~~ ^~~~~~\n"
  stdout: ''
  timestamp: 1659824940
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if\
    \ string == \"\" || substring == \"\" {\n        return 0\n    }\n    var count\
    \ = 0\n    var start = 0\n    var end = string.characters.count\n    while start\
    \ < end {\n        let index = string.index(string.startIndex, offsetBy: start)\n\
    \        let substringIndex = string.index(index, offsetBy: substring.characters.count)\n\
    \        if substringIndex != nil {\n            count += 1\n            start\
    \ = substringIndex!.offset\n        } else {\n            start = index!.offset\n\
    \        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpdz5xb52w.swift:15:22: error: 'characters' is unavailable: Please\
    \ use String directly\n    var end = string.characters.count\n               \
    \      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmpdz5xb52w.swift:18:70:\
    \ error: 'characters' is unavailable: Please use String directly\n        let\
    \ substringIndex = string.index(index, offsetBy: substring.characters.count)\n\
    \                                                                     ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpdz5xb52w.swift:19:27:\
    \ warning: comparing non-optional value of type 'String.Index' to 'nil' always\
    \ returns true\n        if substringIndex != nil {\n           ~~~~~~~~~~~~~~\
    \ ^  ~~~\n/tmp/tmpdz5xb52w.swift:21:35: error: cannot force unwrap value of non-optional\
    \ type 'String.Index'\n            start = substringIndex!.offset\n          \
    \          ~~~~~~~~~~~~~~^\n                                  \n/tmp/tmpdz5xb52w.swift:21:37:\
    \ error: value of type 'String.Index' has no member 'offset'\n            start\
    \ = substringIndex!.offset\n                    ~~~~~~~~~~~~~~~ ^~~~~~\n/tmp/tmpdz5xb52w.swift:23:26:\
    \ error: cannot force unwrap value of non-optional type 'String.Index'\n     \
    \       start = index!.offset\n                    ~~~~~^\n                  \
    \       \n/tmp/tmpdz5xb52w.swift:23:28: error: value of type 'String.Index' has\
    \ no member 'offset'\n            start = index!.offset\n                    ~~~~~~\
    \ ^~~~~~\n"
  stdout: ''
  timestamp: 1659824940
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if\
    \ string == \"\" {\n        return 0\n    }\n    if substring == \"\" {\n    \
    \    return countOccurrences(string, \"\")\n    }\n    var count = 0\n    var\
    \ last = 0\n    for i := 0; i < len(string); i++ {\n        if string[i] == substring[0]\
    \ {\n            count += countOccurrences(string, substring)\n            last\
    \ = i + 1\n        }\n    }\n    if last < len(string) {\n        count += countOccurrences(string,\
    \ substring[last:])\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpzqy9pmcm.swift:18:12: error: expected type\n    for i := 0; i <\
    \ len(string); i++ {\n           ^\n            <#type#>\n/tmp/tmpzqy9pmcm.swift:18:12:\
    \ error: expected 'in' after for-each pattern\n    for i := 0; i < len(string);\
    \ i++ {\n           ^\n/tmp/tmpzqy9pmcm.swift:18:12: error: expected Sequence\
    \ expression for for-each loop\n    for i := 0; i < len(string); i++ {\n     \
    \      ^\n/tmp/tmpzqy9pmcm.swift:25:58: error: expected expression in list of\
    \ expressions\n        count += countOccurrences(string, substring[last:])\n \
    \                                                        ^\n/tmp/tmpzqy9pmcm.swift:14:16:\
    \ error: cannot find 'countOccurrences' in scope\n        return countOccurrences(string,\
    \ \"\")\n               ^~~~~~~~~~~~~~~~\n/tmp/tmpzqy9pmcm.swift:24:15: error:\
    \ cannot find 'len' in scope\n    if last < len(string) {\n              ^~~\n\
    /tmp/tmpzqy9pmcm.swift:25:18: error: cannot find 'countOccurrences' in scope\n\
    \        count += countOccurrences(string, substring[last:])\n               \
    \  ^~~~~~~~~~~~~~~~\n/tmp/tmpzqy9pmcm.swift:25:58: error: missing argument for\
    \ parameter #1 in call\n        count += countOccurrences(string, substring[last:])\n\
    \                                                         ^\n                \
    \                                         <#String.Index#>\nSwift.String:12:12:\
    \ note: 'subscript(_:)' declared here\n    public subscript(i: String.Index) ->\
    \ Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1659824940
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if\
    \ string == \"\" {\n        return 0\n    }\n    if substring == \"\" {\n    \
    \    return 1\n    }\n    var count = 0\n    var start = 0\n    var end = string.count\n\
    \    while start < end {\n        start = string.index(substring, start) + 1\n\
    \        end = string.index(substring, end) + 1\n        count += 1\n    }\n \
    \   return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpm0v4ybnh.swift:20:24: error: no exact matches in call to instance\
    \ method 'index'\n        start = string.index(substring, start) + 1\n       \
    \                ^\n/tmp/tmpm0v4ybnh.swift:20:24: note: candidate has partially\
    \ matching parameter list (String.Index, offsetBy: Int)\n        start = string.index(substring,\
    \ start) + 1\n                       ^\n/tmp/tmpm0v4ybnh.swift:20:24: note: candidate\
    \ has partially matching parameter list (String.Index, offsetBy: Int)\n      \
    \  start = string.index(substring, start) + 1\n                       ^\n/tmp/tmpm0v4ybnh.swift:20:24:\
    \ note: candidate has partially matching parameter list (String.Index, offsetBy:\
    \ Int)\n        start = string.index(substring, start) + 1\n                 \
    \      ^\n/tmp/tmpm0v4ybnh.swift:20:24: error: cannot convert value of type 'String.Index'\
    \ to expected argument type 'Int'\n        start = string.index(substring, start)\
    \ + 1\n                       ^\n/tmp/tmpm0v4ybnh.swift:21:22: error: no exact\
    \ matches in call to instance method 'index'\n        end = string.index(substring,\
    \ end) + 1\n                     ^\n/tmp/tmpm0v4ybnh.swift:21:22: note: candidate\
    \ has partially matching parameter list (String.Index, offsetBy: Int)\n      \
    \  end = string.index(substring, end) + 1\n                     ^\n/tmp/tmpm0v4ybnh.swift:21:22:\
    \ note: candidate has partially matching parameter list (String.Index, offsetBy:\
    \ Int)\n        end = string.index(substring, end) + 1\n                     ^\n\
    /tmp/tmpm0v4ybnh.swift:21:22: note: candidate has partially matching parameter\
    \ list (String.Index, offsetBy: Int)\n        end = string.index(substring, end)\
    \ + 1\n                     ^\n/tmp/tmpm0v4ybnh.swift:21:22: error: cannot convert\
    \ value of type 'String.Index' to expected argument type 'Int'\n        end =\
    \ string.index(substring, end) + 1\n                     ^\n"
  stdout: ''
  timestamp: 1659824940
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if\
    \ string == \"\" {\n        return 0\n    }\n    if substring == \"\" {\n    \
    \    return count(string)\n    }\n    var count = 0\n    var i = 0\n    var j\
    \ = 0\n    var k = 0\n    var l = string.characters.count\n    var m = substring.characters.count\n\
    \    while i < l && j < m {\n        if string[i] == substring[j] {\n        \
    \    count += 1\n            i += 1\n            j += 1\n        } else if string[i]\
    \ < substring[j] {\n            i += 1\n        } else {\n            j += 1\n\
    \        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp8w9ct6bg.swift:14:16: error: use of local variable 'count' before\
    \ its declaration\n        return count(string)\n               ^\n/tmp/tmp8w9ct6bg.swift:16:9:\
    \ note: 'count' declared here\n    var count = 0\n        ^\n/tmp/tmp8w9ct6bg.swift:20:20:\
    \ error: 'characters' is unavailable: Please use String directly\n    var l =\
    \ string.characters.count\n                   ^~~~~~~~~~\nSwift.String:5:16: note:\
    \ 'characters' was obsoleted in Swift 5.0\n    public var characters: String {\
    \ get set }\n               ^\n/tmp/tmp8w9ct6bg.swift:21:23: error: 'characters'\
    \ is unavailable: Please use String directly\n    var m = substring.characters.count\n\
    \                      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmp8w9ct6bg.swift:23:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if string[i]\
    \ == substring[j] {\n           ^~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmp8w9ct6bg.swift:23:25: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if string[i] == substring[j] {\n                        ^~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmp8w9ct6bg.swift:27:19:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        } else if string[i] < substring[j] {\n\
    \                  ^~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has been\
    \ explicitly marked unavailable here\n    public subscript(i: Int) -> Character\
    \ { get }\n           ^\n/tmp/tmp8w9ct6bg.swift:27:31: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        } else if string[i] < substring[j] {\n             "
  stdout: ''
  timestamp: 1659824940
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if\
    \ string == \"\" || substring == \"\" {\n        return 0\n    }\n    var count\
    \ = 0\n    var i = 0\n    var j = string.count\n    while i < j {\n        if\
    \ string[i] == substring[0] {\n            count += 1\n            i += substring.length\
    \ - 1\n        } else if string[i] == substring[1] {\n            count += 1\n\
    \            i += substring.length - 1\n        } else if string[i] == substring[2]\
    \ {\n            count += 1\n            i += substring.length - 1\n        }\
    \ else if string[i] == substring[3] {\n            count += 1\n            i +=\
    \ substring.length - 1\n        } else if string[i] == substring[4] {\n      \
    \      count += 1\n            i += substring.length - 1\n        } else if string[i]\
    \ == substring[5] {\n            count += 1\n            i += substring.length\
    \ - 1\n        } else if string[i] == substring[6] {\n            count += 1\n\
    \            i += substring.length - 1\n        } else if string[i] == substring[7]\
    \ {\n            count += 1\n            i += substring.length - 1\n        }\
    \ else if string[i] == substring[8] {\n            count += 1\n            i +=\
    \ substring.length - 1\n        } else if string[i] == substring[9] {\n      \
    \      count += 1\n            i += substring.length - 1\n        } else if string[i]\
    \ == substring[10] {\n            count += 1\n            i += substring.length\
    \ - 1\n        } else if string[i] == substring[11] {\n            count += 1\n\
    \            i += substring.length - 1\n        } else if string[i] == substring[12]\
    \ {\n            count += 1\n            i += substring.length - 1\n        }\
    \ else if string[i] == substring[13] {\n            count += 1\n            i\
    \ += substring.length - 1\n        } else if string[i] == substring[14] {\n  \
    \          count += 1\n            i += substring.length - 1\n        } else if\
    \ string[i] == substring[15] {\n            count += 1\n            i += substring.length\
    \ - 1\n        } else if string[i] == substring[16] {\n            count += 1\n\
    \            i += substring.length - 1\n        } else if string[i] == substring[17]\
    \ {\n            count += 1\n            i += substring.length - 1\n        }\
    \ else if string[i] == substring[18] {\n            count += 1\n            i\
    \ += substring.length - 1\n        } else if string[i] == substring[19] {\n  \
    \          count += 1\n            i += substring.length - 1\n        } else if\
    \ string[i] == substring[20] {\n            count += 1\n            i += substring.length\
    \ - 1\n        } else if string[i] == substring[21] {\n            count += 1\n\
    \            i += substring.length - 1\n        } else if string[i] == substring[22]\
    \ {\n            count += 1\n            i += substring.length - 1\n        }\
    \ else if string[i] == substring[23] {\n            count += 1\n            i\
    \ += substring.length - 1\n        } else if string[i] == substring[24] {\n  \
    \          count += 1\n            i += substring.length - 1\n        } else if\
    \ string[i] == substring[25] {\n            count += 1\n            i += substring.length\
    \ - 1\n        \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpx3wqt44p.swift:114:67: error: expected '}' at end of brace statement\n\
    assert(how_many_times(string: \"john doe\", substring: \"john\") == 1)\n     \
    \                                                             ^\n/tmp/tmpx3wqt44p.swift:16:17:\
    \ note: to match this opening '{'\n    while i < j {\n                ^\n/tmp/tmpx3wqt44p.swift:114:67:\
    \ error: expected '}' at end of brace statement\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)\n                                 \
    \                                 ^\n/tmp/tmpx3wqt44p.swift:9:63: note: to match\
    \ this opening '{'\nfunc how_many_times(string: String, substring: String) ->\
    \ Int {\n                                                              ^\n/tmp/tmpx3wqt44p.swift:17:12:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if string[i] == substring[0] {\n      \
    \     ^~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly\
    \ marked unavailable here\n    public subscript(i: Int) -> Character { get }\n\
    \           ^\n/tmp/tmpx3wqt44p.swift:17:25: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n        if\
    \ string[i] == substring[0] {\n                        ^~~~~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpx3wqt44p.swift:19:28:\
    \ error: value of type 'String' has no member 'length'\n            i += substring.length\
    \ - 1\n                 ~~~~~~~~~ ^~~~~~\n/tmp/tmpx3wqt44p.swift:20:19: error:\
    \ 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index\
    \ instead.\n        } else if string[i] == substring[1] {\n                  ^~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpx3wqt44p.swift:20:32:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index i"
  stdout: ''
  timestamp: 1659824941
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if\
    \ string == \"\" {\n        return 0\n    }\n    if substring == \"\" {\n    \
    \    return string.count\n    }\n    var count = 0\n    var i = 0\n    var j =\
    \ string.count\n    while i < j {\n        if string[i] == substring[0] {\n  \
    \          count += 1\n            i += substring.length - 1\n        } else if\
    \ string[i] == substring[1] {\n            count += 1\n            i += substring.length\
    \ - 1\n        } else if string[i] == substring[2] {\n            count += 1\n\
    \            i += substring.length - 1\n        } else if string[i] == substring[3]\
    \ {\n            count += 1\n            i += substring.length - 1\n        }\
    \ else if string[i] == substring[4] {\n            count += 1\n            i +=\
    \ substring.length - 1\n        } else if string[i] == substring[5] {\n      \
    \      count += 1\n            i += substring.length - 1\n        } else if string[i]\
    \ == substring[6] {\n            count += 1\n            i += substring.length\
    \ - 1\n        } else if string[i] == substring[7] {\n            count += 1\n\
    \            i += substring.length - 1\n        } else if string[i] == substring[8]\
    \ {\n            count += 1\n            i += substring.length - 1\n        }\
    \ else if string[i] == substring[9] {\n            count += 1\n            i +=\
    \ substring.length - 1\n        } else if string[i] == substring[10] {\n     \
    \       count += 1\n            i += substring.length - 1\n        } else if string[i]\
    \ == substring[11] {\n            count += 1\n            i += substring.length\
    \ - 1\n        } else if string[i] == substring[12] {\n            count += 1\n\
    \            i += substring.length - 1\n        } else if string[i] == substring[13]\
    \ {\n            count += 1\n            i += substring.length - 1\n        }\
    \ else if string[i] == substring[14] {\n            count += 1\n            i\
    \ += substring.length - 1\n        } else if string[i] == substring[15] {\n  \
    \          count += 1\n            i += substring.length - 1\n        } else if\
    \ string[i] == substring[16] {\n            count += 1\n            i += substring.length\
    \ - 1\n        } else if string[i] == substring[17] {\n            count += 1\n\
    \            i += substring.length - 1\n        } else if string[i] == substring[18]\
    \ {\n            count += 1\n            i += substring.length - 1\n        }\
    \ else if string[i] == substring[19] {\n            count += 1\n            i\
    \ += substring.length - 1\n        } else if string[i] == substring[20] {\n  \
    \          count += 1\n            i += substring.length - 1\n        } else if\
    \ string[i] == substring[21] {\n            count += 1\n            i += substring.length\
    \ - 1\n        } else if string[i] == substring[22] {\n            count += 1\n\
    \            i += substring.length - 1\n        } else if string[i] == substring[23]\
    \ {\n            count += 1\n            i += substring.length - 1\n        }\
    \ else if string[i] == substring[24] {\n            count += 1\n            i\
    \ += substring.length - 1\n        } else if string[i] == substring[25] {\n  \
    \          count += 1\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpkxyyvbd9.swift:115:67: error: expected '}' at end of brace statement\n\
    assert(how_many_times(string: \"john doe\", substring: \"john\") == 1)\n     \
    \                                                             ^\n/tmp/tmpkxyyvbd9.swift:19:17:\
    \ note: to match this opening '{'\n    while i < j {\n                ^\n/tmp/tmpkxyyvbd9.swift:115:67:\
    \ error: expected '}' at end of brace statement\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)\n                                 \
    \                                 ^\n/tmp/tmpkxyyvbd9.swift:9:63: note: to match\
    \ this opening '{'\nfunc how_many_times(string: String, substring: String) ->\
    \ Int {\n                                                              ^\n/tmp/tmpkxyyvbd9.swift:20:12:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if string[i] == substring[0] {\n      \
    \     ^~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly\
    \ marked unavailable here\n    public subscript(i: Int) -> Character { get }\n\
    \           ^\n/tmp/tmpkxyyvbd9.swift:20:25: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n        if\
    \ string[i] == substring[0] {\n                        ^~~~~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpkxyyvbd9.swift:22:28:\
    \ error: value of type 'String' has no member 'length'\n            i += substring.length\
    \ - 1\n                 ~~~~~~~~~ ^~~~~~\n/tmp/tmpkxyyvbd9.swift:23:19: error:\
    \ 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index\
    \ instead.\n        } else if string[i] == substring[1] {\n                  ^~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpkxyyvbd9.swift:23:32:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index i"
  stdout: ''
  timestamp: 1659824940
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if\
    \ string == \"\" {\n        return 0\n    }\n    if substring == \"\" {\n    \
    \    return countOccurrences(string, \"\")\n    }\n    var count = 0\n    var\
    \ i = 0\n    var j = 0\n    var k = string.startIndex\n    var l = string.endIndex\n\
    \    while i < l {\n        if string[k] == substring[j] {\n            count\
    \ += 1\n            i += k\n            k += k\n            j += 1\n         \
    \   if j == substring.count {\n                j = 0\n                k += k\n\
    \            }\n        } else {\n            i += 1\n        }\n    }\n    return\
    \ count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpt9s2gq10.swift:14:16: error: cannot find 'countOccurrences' in\
    \ scope\n        return countOccurrences(string, \"\")\n               ^~~~~~~~~~~~~~~~\n\
    /tmp/tmpt9s2gq10.swift:21:13: error: operator function '<' requires that 'String.Index'\
    \ conform to 'BinaryInteger'\n    while i < l {\n            ^\nSwift.BinaryInteger:4:24:\
    \ note: where 'Other' = 'String.Index'\n    public static func < <Other>(lhs:\
    \ Self, rhs: Other) -> Bool where Other : BinaryInteger\n                    \
    \   ^\n/tmp/tmpt9s2gq10.swift:22:25: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if string[k]\
    \ == substring[j] {\n                        ^~~~~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpt9s2gq10.swift:24:18:\
    \ error: cannot convert value of type 'String.Index' to expected argument type\
    \ 'Int'\n            i += k\n                 ^\n/tmp/tmpt9s2gq10.swift:25:15:\
    \ error: binary operator '+=' cannot be applied to two 'String.Index' operands\n\
    \            k += k\n            ~ ^  ~\n/tmp/tmpt9s2gq10.swift:29:19: error:\
    \ binary operator '+=' cannot be applied to two 'String.Index' operands\n    \
    \            k += k\n                ~ ^  ~\n"
  stdout: ''
  timestamp: 1659824940
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if\
    \ string == \"\" {\n        return 0\n    }\n    if substring == \"\" {\n    \
    \    return countOccurrences(string, \"\")\n    }\n    var count = 0\n    var\
    \ i = 0\n    var j = string.count\n    var k = substring.count\n    while i <\
    \ j {\n        if string[i] == substring[k] {\n            count = count + 1\n\
    \            i = i + 1\n            k = k - 1\n            if k == 0 {\n     \
    \           break\n            }\n        } else {\n            i = i + 1\n  \
    \      }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpnkqasjo0.swift:14:16: error: cannot find 'countOccurrences' in\
    \ scope\n        return countOccurrences(string, \"\")\n               ^~~~~~~~~~~~~~~~\n\
    /tmp/tmpnkqasjo0.swift:21:12: error: 'subscript(_:)' is unavailable: cannot subscript\
    \ String with an Int, use a String.Index instead.\n        if string[i] == substring[k]\
    \ {\n           ^~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly\
    \ marked unavailable here\n    public subscript(i: Int) -> Character { get }\n\
    \           ^\n/tmp/tmpnkqasjo0.swift:21:25: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n        if\
    \ string[i] == substring[k] {\n                        ^~~~~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1659824940
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if\
    \ string == \"\" {\n        return 0\n    }\n    if substring == \"\" {\n    \
    \    return count(string)\n    }\n    var count = 0\n    var start = 0\n    var\
    \ end = count(string)\n    while start < end {\n        start = find(string, substring,\
    \ start)\n        end = find(string, substring, end + 1)\n        if start ==\
    \ end {\n            count += 1\n        }\n    }\n    return count\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpz__4o2rn.swift:14:16: error: use of local variable 'count' before\
    \ its declaration\n        return count(string)\n               ^\n/tmp/tmpz__4o2rn.swift:16:9:\
    \ note: 'count' declared here\n    var count = 0\n        ^\n/tmp/tmpz__4o2rn.swift:18:15:\
    \ error: cannot call value of non-function type 'Int'\n    var end = count(string)\n\
    \              ^\n/tmp/tmpz__4o2rn.swift:20:17: error: cannot find 'find' in scope\n\
    \        start = find(string, substring, start)\n                ^~~~\n/tmp/tmpz__4o2rn.swift:21:15:\
    \ error: cannot find 'find' in scope\n        end = find(string, substring, end\
    \ + 1)\n              ^~~~\n"
  stdout: ''
  timestamp: 1659824939
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if\
    \ string == \"\" {\n        return 0\n    }\n    if substring == \"\" {\n    \
    \    return countOccurrences(string, \"\")\n    }\n    var count = 0\n    var\
    \ start = 0\n    var end = string.count\n    while start < end {\n        start\
    \ = string.startIndex.advanced(by: start)\n        end = string.endIndex.advanced(by:\
    \ end)\n        if string.substring(from: start) == substring {\n            count\
    \ += 1\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpr63azmgw.swift:14:16: error: cannot find 'countOccurrences' in\
    \ scope\n        return countOccurrences(string, \"\")\n               ^~~~~~~~~~~~~~~~\n\
    /tmp/tmpr63azmgw.swift:20:35: error: value of type 'String.Index' has no member\
    \ 'advanced'\n        start = string.startIndex.advanced(by: start)\n        \
    \        ~~~~~~~~~~~~~~~~~ ^~~~~~~~\n/tmp/tmpr63azmgw.swift:21:31: error: value\
    \ of type 'String.Index' has no member 'advanced'\n        end = string.endIndex.advanced(by:\
    \ end)\n              ~~~~~~~~~~~~~~~ ^~~~~~~~\n/tmp/tmpr63azmgw.swift:22:19:\
    \ error: value of type 'String' has no member 'substring'\n        if string.substring(from:\
    \ start) == substring {\n           ~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824940
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    return\
    \ count_occurrences(string, substring)\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpy7uot6pw.swift:10:12: error: cannot find 'count_occurrences' in\
    \ scope\n    return count_occurrences(string, substring)\n           ^~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824940
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if\
    \ string == \"\" || substring == \"\" {\n        return 0\n    }\n    var count\
    \ = 0\n    var i = 0\n    var j = string.characters.count\n    var k = substring.characters.count\n\
    \    while i < j {\n        if string[i] != substring[j] {\n            count\
    \ = count + 1\n        }\n        i = i + 1\n        j = j - 1\n    }\n    if\
    \ k > 0 {\n        count = count + how_many_times(string, substring[k-1])\n  \
    \  }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmps0ue7y_x.swift:15:20: error: 'characters' is unavailable: Please\
    \ use String directly\n    var j = string.characters.count\n                 \
    \  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n\
    \    public var characters: String { get set }\n               ^\n/tmp/tmps0ue7y_x.swift:16:23:\
    \ error: 'characters' is unavailable: Please use String directly\n    var k =\
    \ substring.characters.count\n                      ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmps0ue7y_x.swift:18:12: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if string[i] != substring[j] {\n           ^~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmps0ue7y_x.swift:18:25:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if string[i] != substring[j] {\n      \
    \                  ^~~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has\
    \ been explicitly marked unavailable here\n    public subscript(i: Int) -> Character\
    \ { get }\n           ^\n/tmp/tmps0ue7y_x.swift:25:39: error: missing argument\
    \ labels 'string:substring:' in call\n        count = count + how_many_times(string,\
    \ substring[k-1])\n                                      ^\n                 \
    \                      string: substring: \n/tmp/tmps0ue7y_x.swift:25:57: error:\
    \ cannot convert value of type 'Character' to expected argument type 'String'\n\
    \        count = count + how_many_times(string, substring[k-1])\n            \
    \                                            ^\n"
  stdout: ''
  timestamp: 1659824940
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if\
    \ string == \"\" {\n        return 0\n    }\n    if substring == \"\" {\n    \
    \    return countOccurrences(string, \"\")\n    }\n    var count = 0\n    var\
    \ start = 0\n    var end = string.count\n    while start < end {\n        start\
    \ = string.startIndex.advanced(by: start)\n        end = string.endIndex.advanced(by:\
    \ end)\n        if string.substring(from: start, length: substring.length) ==\
    \ substring {\n            count += 1\n        }\n    }\n    return count\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmptzan6cwy.swift:14:16: error: cannot find 'countOccurrences' in\
    \ scope\n        return countOccurrences(string, \"\")\n               ^~~~~~~~~~~~~~~~\n\
    /tmp/tmptzan6cwy.swift:20:35: error: value of type 'String.Index' has no member\
    \ 'advanced'\n        start = string.startIndex.advanced(by: start)\n        \
    \        ~~~~~~~~~~~~~~~~~ ^~~~~~~~\n/tmp/tmptzan6cwy.swift:21:31: error: value\
    \ of type 'String.Index' has no member 'advanced'\n        end = string.endIndex.advanced(by:\
    \ end)\n              ~~~~~~~~~~~~~~~ ^~~~~~~~\n/tmp/tmptzan6cwy.swift:22:19:\
    \ error: value of type 'String' has no member 'substring'\n        if string.substring(from:\
    \ start, length: substring.length) == substring {\n           ~~~~~~ ^~~~~~~~~\n\
    /tmp/tmptzan6cwy.swift:22:60: error: value of type 'String' has no member 'length'\n\
    \        if string.substring(from: start, length: substring.length) == substring\
    \ {\n                                                 ~~~~~~~~~ ^~~~~~\n"
  stdout: ''
  timestamp: 1659824940
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    let\
    \ start = string.startIndex.advancedBy(substring.startIndex)\n    let end = string.endIndex.advancedBy(-substring.endIndex)\n\
    \    let count = string.distance(from: start, to: end)\n    return count\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpf1hg49o7.swift:10:35: error: value of type 'String.Index' has no\
    \ member 'advancedBy'\n    let start = string.startIndex.advancedBy(substring.startIndex)\n\
    \                ~~~~~~~~~~~~~~~~~ ^~~~~~~~~~\n/tmp/tmpf1hg49o7.swift:11:42: error:\
    \ unary operator '-' cannot be applied to an operand of type 'String.Index'\n\
    \    let end = string.endIndex.advancedBy(-substring.endIndex)\n             \
    \                            ^\n/tmp/tmpf1hg49o7.swift:11:42: note: overloads\
    \ for '-' exist with these partially matching parameter lists: (Double), (Float),\
    \ (Float16), (Float80)\n    let end = string.endIndex.advancedBy(-substring.endIndex)\n\
    \                                         ^\n/tmp/tmpf1hg49o7.swift:11:31: error:\
    \ value of type 'String.Index' has no member 'advancedBy'\n    let end = string.endIndex.advancedBy(-substring.endIndex)\n\
    \              ~~~~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824940
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    var\
    \ count = 0\n    for index in 0..<string.characters.count {\n        if string.substring(index,\
    \ string.characters.count) == substring {\n            count += 1\n        }\n\
    \    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpja6rt6dx.swift:11:29: error: 'characters' is unavailable: Please\
    \ use String directly\n    for index in 0..<string.characters.count {\n      \
    \                      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpja6rt6dx.swift:12:19: error: value of type 'String' has no member\
    \ 'substring'\n        if string.substring(index, string.characters.count) ==\
    \ substring {\n           ~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824940
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if\
    \ string == \"\" {\n        return 0\n    }\n    if substring == \"\" {\n    \
    \    return count(string)\n    }\n    var count = 0\n    var i = 0\n    var j\
    \ = string.count\n    while i < j {\n        if string[i] == substring[0] {\n\
    \            count += 1\n            i += count(substring)\n        } else {\n\
    \            i += 1\n        }\n    }\n    return count\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\n\
    assert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string:\
    \ \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john\
    \ doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmphm35p0q2.swift:14:16: error: use of local variable 'count' before\
    \ its declaration\n        return count(string)\n               ^\n/tmp/tmphm35p0q2.swift:16:9:\
    \ note: 'count' declared here\n    var count = 0\n        ^\n/tmp/tmphm35p0q2.swift:20:12:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if string[i] == substring[0] {\n      \
    \     ^~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly\
    \ marked unavailable here\n    public subscript(i: Int) -> Character { get }\n\
    \           ^\n/tmp/tmphm35p0q2.swift:20:25: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n        if\
    \ string[i] == substring[0] {\n                        ^~~~~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmphm35p0q2.swift:22:18:\
    \ error: cannot call value of non-function type 'Int'\n            i += count(substring)\n\
    \                 ^\n"
  stdout: ''
  timestamp: 1659824939
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if\
    \ string == \"\" {\n        return 0\n    }\n    if substring == \"\" {\n    \
    \    return countOccurrences(string, \"\")\n    }\n    var count = 0\n    var\
    \ startIndex = 0\n    var endIndex = 0\n    while startIndex < string.count {\n\
    \        endIndex = string.index(substring, startIndex)\n        if endIndex ==\
    \ startIndex {\n            count += 1\n            startIndex = endIndex + 1\n\
    \        } else {\n            count += countOccurrences(string, substring[startIndex..<endIndex])\n\
    \            startIndex = endIndex + 1\n        }\n    }\n    return count\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp90dvrejt.swift:14:16: error: cannot find 'countOccurrences' in\
    \ scope\n        return countOccurrences(string, \"\")\n               ^~~~~~~~~~~~~~~~\n\
    /tmp/tmp90dvrejt.swift:20:27: error: no exact matches in call to instance method\
    \ 'index'\n        endIndex = string.index(substring, startIndex)\n          \
    \                ^\n/tmp/tmp90dvrejt.swift:20:27: note: found candidate with type\
    \ '(String.Index, Int) -> String.Index'\n        endIndex = string.index(substring,\
    \ startIndex)\n                          ^\n/tmp/tmp90dvrejt.swift:20:27: error:\
    \ cannot assign value of type 'String.Index' to type 'Int'\n        endIndex =\
    \ string.index(substring, startIndex)\n                   ~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmp90dvrejt.swift:25:22: error: cannot find 'countOccurrences' in scope\n\
    \            count += countOccurrences(string, substring[startIndex..<endIndex])\n\
    \                     ^~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824940
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if\
    \ string == \"\" {\n        return 0\n    }\n    if substring == \"\" {\n    \
    \    return countOccurrences(string, \"\")\n    }\n    var count = 0\n    var\
    \ i = 0\n    var j = 0\n    var k = 0\n    var lastCharIndex = 0\n    var lastSubstringIndex\
    \ = 0\n    for i = string.startIndex; lastCharIndex < string.endIndex; i++ {\n\
    \        if string[i] == substring[k] {\n            count++\n            lastCharIndex\
    \ = i\n            lastSubstringIndex = k\n            k++\n        } else {\n\
    \            if k > 0 {\n                k--\n            } else {\n         \
    \       j++\n            }\n        }\n    }\n    if k > 0 {\n        count++\n\
    \        lastCharIndex = i\n        lastSubstringIndex = k\n    }\n    if lastCharIndex\
    \ == string.endIndex {\n        return countOccurrences(string, substring)\n \
    \   }\n    if lastSubstringIndex == 0 {\n        return countOccurrences(string,\
    \ substring)\n    }\n    return countOccurrences(string, substring) + how_many_times(string.substringFromIndex(lastCharIndex),\
    \ substring) + how_many_times(string.substringFromIndex(lastCharIndex), string.substringFromIndex(lastSubstringIndex))\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpwxxhf65z.swift:22:5: error: C-style for statement has been removed\
    \ in Swift 3\n    for i = string.startIndex; lastCharIndex < string.endIndex;\
    \ i++ {\n    ^   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpwxxhf65z.swift:14:16: error: cannot find 'countOccurrences' in scope\n\
    \        return countOccurrences(string, \"\")\n               ^~~~~~~~~~~~~~~~\n\
    /tmp/tmpwxxhf65z.swift:37:14: error: cannot find operator '++' in scope; did you\
    \ mean '+= 1'?\n        count++\n             ^~\n/tmp/tmpwxxhf65z.swift:41:22:\
    \ error: operator function '==' requires that 'String.Index' conform to 'BinaryInteger'\n\
    \    if lastCharIndex == string.endIndex {\n                     ^\nSwift.BinaryInteger:2:24:\
    \ note: where 'Other' = 'String.Index'\n    public static func == <Other>(lhs:\
    \ Self, rhs: Other) -> Bool where Other : BinaryInteger\n                    \
    \   ^\n/tmp/tmpwxxhf65z.swift:42:16: error: cannot find 'countOccurrences' in\
    \ scope\n        return countOccurrences(string, substring)\n               ^~~~~~~~~~~~~~~~\n\
    /tmp/tmpwxxhf65z.swift:45:16: error: cannot find 'countOccurrences' in scope\n\
    \        return countOccurrences(string, substring)\n               ^~~~~~~~~~~~~~~~\n\
    /tmp/tmpwxxhf65z.swift:47:12: error: cannot find 'countOccurrences' in scope\n\
    \    return countOccurrences(string, substring) + how_many_times(string.substringFromIndex(lastCharIndex),\
    \ substring) + how_many_times(string.substringFromIndex(lastCharIndex), string.substringFromIndex(lastSubstringIndex))\n\
    \           ^~~~~~~~~~~~~~~~\n/tmp/tmpwxxhf65z.swift:47:64: error: missing argument\
    \ labels 'string:substring:' in call\n    return countOccurrences(string, substring)\
    \ + how_many_times(string.substringFromIndex(lastCharIndex), substring) + how_many_times(string.substringFromIndex(lastCharIndex),\
    \ string.substringFromIndex(lastSubstringIndex))\n                           \
    \                                    ^\n                                     \
    \                           string:                                   substring:\
    \ \n/tmp/tmpwxxhf65z.swift:47:72: error: val"
  stdout: ''
  timestamp: 1659824940
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if\
    \ string == \"\" {\n        return 0\n    }\n    if substring == \"\" {\n    \
    \    return string.count\n    }\n    var count = 0\n    var i = 0\n    var j =\
    \ string.count\n    while i < j {\n        if string[i] == substring[0] {\n  \
    \          count += 1\n            i += substring.length - 1\n        } else if\
    \ string[i] == substring[1] {\n            count += 1\n            i += substring.length\
    \ - 1\n        } else if string[i] == substring[2] {\n            count += 1\n\
    \            i += substring.length - 1\n        } else if string[i] == substring[3]\
    \ {\n            count += 1\n            i += substring.length - 1\n        }\
    \ else if string[i] == substring[4] {\n            count += 1\n            i +=\
    \ substring.length - 1\n        } else if string[i] == substring[5] {\n      \
    \      count += 1\n            i += substring.length - 1\n        } else if string[i]\
    \ == substring[6] {\n            count += 1\n            i += substring.length\
    \ - 1\n        } else if string[i] == substring[7] {\n            count += 1\n\
    \            i += substring.length - 1\n        } else if string[i] == substring[8]\
    \ {\n            count += 1\n            i += substring.length - 1\n        }\
    \ else if string[i] == substring[9] {\n            count += 1\n            i +=\
    \ substring.length - 1\n        } else if string[i] == substring[10] {\n     \
    \       count += 1\n            i += substring.length - 1\n        } else if string[i]\
    \ == substring[11] {\n            count += 1\n            i += substring.length\
    \ - 1\n        } else if string[i] == substring[12] {\n            count += 1\n\
    \            i += substring.length - 1\n        } else if string[i] == substring[13]\
    \ {\n            count += 1\n            i += substring.length - 1\n        }\
    \ else if string[i] == substring[14] {\n            count += 1\n            i\
    \ += substring.length - 1\n        } else if string[i] == substring[15] {\n  \
    \          count += 1\n            i += substring.length - 1\n        } else if\
    \ string[i] == substring[16] {\n            count += 1\n            i += substring.length\
    \ - 1\n        } else if string[i] == substring[17] {\n            count += 1\n\
    \            i += substring.length - 1\n        } else if string[i] == substring[18]\
    \ {\n            count += 1\n            i += substring.length - 1\n        }\
    \ else if string[i] == substring[19] {\n            count += 1\n            i\
    \ += substring.length - 1\n        } else if string[i] == substring[20] {\n  \
    \          count += 1\n            i += substring.length - 1\n        } else if\
    \ string[i] == substring[21] {\n            count += 1\n            i += substring.length\
    \ - 1\n        } else if string[i] == substring[22] {\n            count += 1\n\
    \            i += substring.length - 1\n        } else if string[i] == substring[23]\
    \ {\n            count += 1\n            i += substring.length - 1\n        }\
    \ else if string[i] == substring[24] {\n            count += 1\n            i\
    \ += substring.length - 1\n        } else if string[i] == substring[25] {\n  \
    \          count += 1\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpkxyyvbd9.swift:115:67: error: expected '}' at end of brace statement\n\
    assert(how_many_times(string: \"john doe\", substring: \"john\") == 1)\n     \
    \                                                             ^\n/tmp/tmpkxyyvbd9.swift:19:17:\
    \ note: to match this opening '{'\n    while i < j {\n                ^\n/tmp/tmpkxyyvbd9.swift:115:67:\
    \ error: expected '}' at end of brace statement\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)\n                                 \
    \                                 ^\n/tmp/tmpkxyyvbd9.swift:9:63: note: to match\
    \ this opening '{'\nfunc how_many_times(string: String, substring: String) ->\
    \ Int {\n                                                              ^\n/tmp/tmpkxyyvbd9.swift:20:12:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if string[i] == substring[0] {\n      \
    \     ^~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly\
    \ marked unavailable here\n    public subscript(i: Int) -> Character { get }\n\
    \           ^\n/tmp/tmpkxyyvbd9.swift:20:25: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n        if\
    \ string[i] == substring[0] {\n                        ^~~~~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpkxyyvbd9.swift:22:28:\
    \ error: value of type 'String' has no member 'length'\n            i += substring.length\
    \ - 1\n                 ~~~~~~~~~ ^~~~~~\n/tmp/tmpkxyyvbd9.swift:23:19: error:\
    \ 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index\
    \ instead.\n        } else if string[i] == substring[1] {\n                  ^~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpkxyyvbd9.swift:23:32:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index i"
  stdout: ''
  timestamp: 1659824940
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    var\
    \ count = 0\n    for index in 0..<string.characters.count {\n        if string.characters.contains(substring,\
    \ at: index) {\n            count += 1\n        }\n    }\n    return count\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpvmqb7rry.swift:11:29: error: 'characters' is unavailable: Please\
    \ use String directly\n    for index in 0..<string.characters.count {\n      \
    \                      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpvmqb7rry.swift:12:54: error: extra argument 'at' in call\n      \
    \  if string.characters.contains(substring, at: index) {\n                   \
    \                  ~~~~~~~~~~~~~~~~^~~~~~\n"
  stdout: ''
  timestamp: 1659824940
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if\
    \ string == \"\" {\n        return 0\n    }\n    if substring == \"\" {\n    \
    \    return countOccurrences(string, \"\")\n    }\n    return countOccurrences(string,\
    \ substring)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpwm9imvn4.swift:14:16: error: cannot find 'countOccurrences' in\
    \ scope\n        return countOccurrences(string, \"\")\n               ^~~~~~~~~~~~~~~~\n\
    /tmp/tmpwm9imvn4.swift:16:12: error: cannot find 'countOccurrences' in scope\n\
    \    return countOccurrences(string, substring)\n           ^~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824940
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if\
    \ string == \"\" || substring == \"\" {\n        return 0\n    }\n    var count\
    \ = 0\n    var i = 0\n    var j = 0\n    var k = 0\n    var stringLength = string.characters.count\n\
    \    var substringLength = substring.characters.count\n    for (i; i < stringLength;\
    \ i++ {\n        for (j; j < substringLength; j++ {\n            if string[i]\
    \ == substring[j] {\n                count++\n                k++\n          \
    \  }\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp557berwu.swift:19:5: error: C-style for statement has been removed\
    \ in Swift 3\n    for (i; i < stringLength; i++ {\n    ^   ~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmp557berwu.swift:27:17: error: expected '{' to start the body of for-each\
    \ loop\n    return count\n                ^\n/tmp/tmp557berwu.swift:17:31: error:\
    \ 'characters' is unavailable: Please use String directly\n    var stringLength\
    \ = string.characters.count\n                              ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmp557berwu.swift:18:37: error: 'characters'\
    \ is unavailable: Please use String directly\n    var substringLength = substring.characters.count\n\
    \                                    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters'\
    \ was obsoleted in Swift 5.0\n    public var characters: String { get set }\n\
    \               ^\n"
  stdout: ''
  timestamp: 1659824940
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if\
    \ string == \"\" {\n        return 0\n    }\n    if substring == \"\" {\n    \
    \    return 1\n    }\n    var count = 0\n    var i = 0\n    var j = string.count\n\
    \    var k = substring.count\n    while i < j {\n        if string[i] == substring[0]\
    \ {\n            count += 1\n            i += k\n        } else {\n          \
    \  i += 1\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpwi275v0y.swift:21:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if string[i]\
    \ == substring[0] {\n           ^~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpwi275v0y.swift:21:25: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if string[i] == substring[0] {\n                        ^~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpwi275v0y.swift:18:9:\
    \ warning: variable 'j' was never mutated; consider changing to 'let' constant\n\
    \    var j = string.count\n    ~~~ ^\n    let\n/tmp/tmpwi275v0y.swift:19:9: warning:\
    \ variable 'k' was never mutated; consider changing to 'let' constant\n    var\
    \ k = substring.count\n    ~~~ ^\n    let\n"
  stdout: ''
  timestamp: 1659824940
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if\
    \ string == \"\" || substring == \"\" {\n        return 0\n    }\n    var count\
    \ = 0\n    var i = 0\n    var j = string.characters.count\n    var k = substring.characters.count\n\
    \    while i < j {\n        if string[i] == substring[k] {\n            count\
    \ += 1\n            i += k\n            k += 1\n        }\n        i += 1\n  \
    \  }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpa_bd8xqa.swift:15:20: error: 'characters' is unavailable: Please\
    \ use String directly\n    var j = string.characters.count\n                 \
    \  ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n\
    \    public var characters: String { get set }\n               ^\n/tmp/tmpa_bd8xqa.swift:16:23:\
    \ error: 'characters' is unavailable: Please use String directly\n    var k =\
    \ substring.characters.count\n                      ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmpa_bd8xqa.swift:18:12: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if string[i] == substring[k] {\n           ^~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpa_bd8xqa.swift:18:25:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if string[i] == substring[k] {\n      \
    \                  ^~~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has\
    \ been explicitly marked unavailable here\n    public subscript(i: Int) -> Character\
    \ { get }\n           ^\n/tmp/tmpa_bd8xqa.swift:15:9: warning: variable 'j' was\
    \ never mutated; consider changing to 'let' constant\n    var j = string.characters.count\n\
    \    ~~~ ^\n    let\n"
  stdout: ''
  timestamp: 1659824940
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if\
    \ string == \"\" {\n        return 0\n    }\n    if substring == \"\" {\n    \
    \    return string.length\n    }\n    var count = 0\n    var i = 0\n    var j\
    \ = string.length - 1\n    while i < j {\n        if string[i] == substring[0]\
    \ {\n            count += 1\n            i += substring.length - 1\n        }\
    \ else if string[j] == substring[0] {\n            count -= 1\n            j -=\
    \ 1\n        } else {\n            i += 1\n            j += 1\n        }\n   \
    \ }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmplf1hn_2x.swift:14:23: error: value of type 'String' has no member\
    \ 'length'\n        return string.length\n               ~~~~~~ ^~~~~~\n/tmp/tmplf1hn_2x.swift:18:20:\
    \ error: value of type 'String' has no member 'length'\n    var j = string.length\
    \ - 1\n            ~~~~~~ ^~~~~~\n/tmp/tmplf1hn_2x.swift:20:12: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if string[i] == substring[0] {\n           ^~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmplf1hn_2x.swift:20:25:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if string[i] == substring[0] {\n      \
    \                  ^~~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has\
    \ been explicitly marked unavailable here\n    public subscript(i: Int) -> Character\
    \ { get }\n           ^\n/tmp/tmplf1hn_2x.swift:22:28: error: value of type 'String'\
    \ has no member 'length'\n            i += substring.length - 1\n            \
    \     ~~~~~~~~~ ^~~~~~\n"
  stdout: ''
  timestamp: 1659824940
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    let\
    \ start = string.startIndex.advancedBy(substring.startIndex)\n    let end = string.endIndex.advancedBy(-substring.endIndex)\n\
    \    let count = string.distance(from: start, to: end)\n    return count\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpf1hg49o7.swift:10:35: error: value of type 'String.Index' has no\
    \ member 'advancedBy'\n    let start = string.startIndex.advancedBy(substring.startIndex)\n\
    \                ~~~~~~~~~~~~~~~~~ ^~~~~~~~~~\n/tmp/tmpf1hg49o7.swift:11:42: error:\
    \ unary operator '-' cannot be applied to an operand of type 'String.Index'\n\
    \    let end = string.endIndex.advancedBy(-substring.endIndex)\n             \
    \                            ^\n/tmp/tmpf1hg49o7.swift:11:42: note: overloads\
    \ for '-' exist with these partially matching parameter lists: (Double), (Float),\
    \ (Float16), (Float80)\n    let end = string.endIndex.advancedBy(-substring.endIndex)\n\
    \                                         ^\n/tmp/tmpf1hg49o7.swift:11:31: error:\
    \ value of type 'String.Index' has no member 'advancedBy'\n    let end = string.endIndex.advancedBy(-substring.endIndex)\n\
    \              ~~~~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824940
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if\
    \ string == \"\" {\n        return 0\n    }\n    if substring == \"\" {\n    \
    \    return count(string)\n    }\n    var count = 0\n    var i = 0\n    var j\
    \ = string.count\n    var k = substring.count\n    while i < j {\n        if string[i]\
    \ == substring[0] {\n            count += k\n            i += k\n            k\
    \ = k - 1\n        } else {\n            i += 1\n        }\n    }\n    return\
    \ count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp8rgl17y5.swift:14:16: error: use of local variable 'count' before\
    \ its declaration\n        return count(string)\n               ^\n/tmp/tmp8rgl17y5.swift:16:9:\
    \ note: 'count' declared here\n    var count = 0\n        ^\n/tmp/tmp8rgl17y5.swift:21:12:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if string[i] == substring[0] {\n      \
    \     ^~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly\
    \ marked unavailable here\n    public subscript(i: Int) -> Character { get }\n\
    \           ^\n/tmp/tmp8rgl17y5.swift:21:25: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n        if\
    \ string[i] == substring[0] {\n                        ^~~~~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1659824940
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if\
    \ string == \"\" || substring == \"\" {\n        return 0\n    }\n    var count\
    \ = 0\n    var startIndex = 0\n    var endIndex = string.count\n    while startIndex\
    \ < endIndex {\n        let index = string.index(startIndex, offsetBy: substring.count)\n\
    \        if index == startIndex {\n            startIndex += substring.count\n\
    \            continue\n        }\n        if index == endIndex {\n           \
    \ endIndex -= substring.count\n            continue\n        }\n        if string.substring(from:\
    \ index).lowercased() == substring.lowercased() {\n            count += 1\n  \
    \          startIndex = index\n        }\n        startIndex = index\n    }\n\
    \    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmph8g_yi3_.swift:17:34: error: cannot convert value of type 'Int'\
    \ to expected argument type 'String.Index'\n        let index = string.index(startIndex,\
    \ offsetBy: substring.count)\n                                 ^\n/tmp/tmph8g_yi3_.swift:26:19:\
    \ error: value of type 'String' has no member 'substring'\n        if string.substring(from:\
    \ index).lowercased() == substring.lowercased() {\n           ~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824940
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if\
    \ string == \"\" {\n        return 0\n    }\n    if substring == \"\" {\n    \
    \    return countOccurrences(string, \"\")\n    }\n    var count = 0\n    var\
    \ startIndex = 0\n    var endIndex = 0\n    while startIndex < string.count {\n\
    \        endIndex = string.index(substring, startIndex)\n        if endIndex ==\
    \ startIndex {\n            count += 1\n            startIndex = string.index(substring,\
    \ startIndex) + 1\n        } else {\n            count += 1\n            startIndex\
    \ = endIndex + 1\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmptsshyj19.swift:14:16: error: cannot find 'countOccurrences' in\
    \ scope\n        return countOccurrences(string, \"\")\n               ^~~~~~~~~~~~~~~~\n\
    /tmp/tmptsshyj19.swift:20:27: error: no exact matches in call to instance method\
    \ 'index'\n        endIndex = string.index(substring, startIndex)\n          \
    \                ^\n/tmp/tmptsshyj19.swift:20:27: note: found candidate with type\
    \ '(String.Index, Int) -> String.Index'\n        endIndex = string.index(substring,\
    \ startIndex)\n                          ^\n/tmp/tmptsshyj19.swift:20:27: error:\
    \ cannot assign value of type 'String.Index' to type 'Int'\n        endIndex =\
    \ string.index(substring, startIndex)\n                   ~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmptsshyj19.swift:23:33: error: cannot convert value of type 'String.Index'\
    \ to expected argument type 'Int'\n            startIndex = string.index(substring,\
    \ startIndex) + 1\n                                ^\n/tmp/tmptsshyj19.swift:23:33:\
    \ error: no exact matches in call to instance method 'index'\n            startIndex\
    \ = string.index(substring, startIndex) + 1\n                                ^\n\
    /tmp/tmptsshyj19.swift:23:33: note: candidate has partially matching parameter\
    \ list (String.Index, offsetBy: Int)\n            startIndex = string.index(substring,\
    \ startIndex) + 1\n                                ^\n/tmp/tmptsshyj19.swift:23:33:\
    \ note: candidate has partially matching parameter list (String.Index, offsetBy:\
    \ Int)\n            startIndex = string.index(substring, startIndex) + 1\n   \
    \                             ^\n/tmp/tmptsshyj19.swift:23:33: note: candidate\
    \ has partially matching parameter list (String.Index, offsetBy: Int)\n      \
    \      startIndex = string.index(substring, startIndex) + 1\n                \
    \                ^\n"
  stdout: ''
  timestamp: 1659824940
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    var\
    \ count = 0\n    for index in 0..<string.characters.count {\n        if string.characters.contains(substring,\
    \ at: index) {\n            count += 1\n        }\n    }\n    return count\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpvmqb7rry.swift:11:29: error: 'characters' is unavailable: Please\
    \ use String directly\n    for index in 0..<string.characters.count {\n      \
    \                      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpvmqb7rry.swift:12:54: error: extra argument 'at' in call\n      \
    \  if string.characters.contains(substring, at: index) {\n                   \
    \                  ~~~~~~~~~~~~~~~~^~~~~~\n"
  stdout: ''
  timestamp: 1659824940
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    var\
    \ count = 0\n    for index in 0..<string.characters.count {\n        if string.substring(index,\
    \ string.characters.count) == substring {\n            count += 1\n        }\n\
    \    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpja6rt6dx.swift:11:29: error: 'characters' is unavailable: Please\
    \ use String directly\n    for index in 0..<string.characters.count {\n      \
    \                      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpja6rt6dx.swift:12:19: error: value of type 'String' has no member\
    \ 'substring'\n        if string.substring(index, string.characters.count) ==\
    \ substring {\n           ~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824940
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    var\
    \ count = 0\n    for c in string.unicodeScalars {\n        if c == substring {\n\
    \            count += 1\n        }\n    }\n    return count\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\n\
    assert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string:\
    \ \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john\
    \ doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpd3rykh2s.swift:12:14: error: referencing operator function '=='\
    \ on 'StringProtocol' requires that 'Unicode.Scalar' conform to 'StringProtocol'\n\
    \        if c == substring {\n             ^\nSwift.StringProtocol:1:11: note:\
    \ where 'Self' = 'Unicode.Scalar'\nextension StringProtocol {\n          ^\n"
  stdout: ''
  timestamp: 1659824939
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if\
    \ string == \"\" {\n        return 0\n    }\n    if substring == \"\" {\n    \
    \    return string.length\n    }\n    var count = 0\n    var i = 0\n    var j\
    \ = 0\n    var k = 0\n    var l = string.length\n    while i < l {\n        if\
    \ string[i] == substring[j] {\n            count += 1\n            i += substring.length\
    \ - 1\n            j++\n        }\n        if j == substring.length {\n      \
    \      j = 0\n            k += 1\n        }\n        if k == substring.length\
    \ {\n            k = 0\n            i += 1\n        }\n    }\n    return count\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp8jd8tu3a.swift:14:23: error: value of type 'String' has no member\
    \ 'length'\n        return string.length\n               ~~~~~~ ^~~~~~\n/tmp/tmp8jd8tu3a.swift:20:20:\
    \ error: value of type 'String' has no member 'length'\n    var l = string.length\n\
    \            ~~~~~~ ^~~~~~\n/tmp/tmp8jd8tu3a.swift:22:12: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if string[i] == substring[j] {\n           ^~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmp8jd8tu3a.swift:22:25:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if string[i] == substring[j] {\n      \
    \                  ^~~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has\
    \ been explicitly marked unavailable here\n    public subscript(i: Int) -> Character\
    \ { get }\n           ^\n/tmp/tmp8jd8tu3a.swift:24:28: error: value of type 'String'\
    \ has no member 'length'\n            i += substring.length - 1\n            \
    \     ~~~~~~~~~ ^~~~~~\n/tmp/tmp8jd8tu3a.swift:25:14: error: cannot find operator\
    \ '++' in scope; did you mean '+= 1'?\n            j++\n             ^~\n/tmp/tmp8jd8tu3a.swift:27:27:\
    \ error: value of type 'String' has no member 'length'\n        if j == substring.length\
    \ {\n                ~~~~~~~~~ ^~~~~~\n/tmp/tmp8jd8tu3a.swift:31:27: error: value\
    \ of type 'String' has no member 'length'\n        if k == substring.length {\n\
    \                ~~~~~~~~~ ^~~~~~\n"
  stdout: ''
  timestamp: 1659824940
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if\
    \ string == \"\" {\n        return 0\n    }\n    if substring == \"\" {\n    \
    \    return count(string)\n    }\n    var count = 0\n    var i = 0\n    var j\
    \ = string.characters.count\n    while i < j {\n        if string[i] == substring[0]\
    \ {\n            count += 1\n            i += count(substring)\n        } else\
    \ {\n            i += 1\n        }\n    }\n    return count\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\n\
    assert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string:\
    \ \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john\
    \ doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpan2_o30_.swift:14:16: error: use of local variable 'count' before\
    \ its declaration\n        return count(string)\n               ^\n/tmp/tmpan2_o30_.swift:16:9:\
    \ note: 'count' declared here\n    var count = 0\n        ^\n/tmp/tmpan2_o30_.swift:18:20:\
    \ error: 'characters' is unavailable: Please use String directly\n    var j =\
    \ string.characters.count\n                   ^~~~~~~~~~\nSwift.String:5:16: note:\
    \ 'characters' was obsoleted in Swift 5.0\n    public var characters: String {\
    \ get set }\n               ^\n/tmp/tmpan2_o30_.swift:20:12: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if string[i] == substring[0] {\n           ^~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpan2_o30_.swift:20:25:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if string[i] == substring[0] {\n      \
    \                  ^~~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has\
    \ been explicitly marked unavailable here\n    public subscript(i: Int) -> Character\
    \ { get }\n           ^\n/tmp/tmpan2_o30_.swift:22:18: error: cannot call value\
    \ of non-function type 'Int'\n            i += count(substring)\n            \
    \     ^\n"
  stdout: ''
  timestamp: 1659824940
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if\
    \ string == \"\" {\n        return 0\n    }\n    if substring == \"\" {\n    \
    \    return count(string)\n    }\n    var count = 0\n    var i = 0\n    var j\
    \ = string.startIndex\n    var k = string.endIndex\n    while i < k {\n      \
    \  if string[j] != substring[i] {\n            count = count + 1\n        }\n\
    \        if string[j] == substring[i] {\n            j = j + 1\n        }\n  \
    \      i = i + 1\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpc58o6uss.swift:14:16: error: use of local variable 'count' before\
    \ its declaration\n        return count(string)\n               ^\n/tmp/tmpc58o6uss.swift:16:9:\
    \ note: 'count' declared here\n    var count = 0\n        ^\n/tmp/tmpc58o6uss.swift:20:13:\
    \ error: operator function '<' requires that 'String.Index' conform to 'BinaryInteger'\n\
    \    while i < k {\n            ^\nSwift.BinaryInteger:4:24: note: where 'Other'\
    \ = 'String.Index'\n    public static func < <Other>(lhs: Self, rhs: Other) ->\
    \ Bool where Other : BinaryInteger\n                       ^\n/tmp/tmpc58o6uss.swift:21:25:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if string[j] != substring[i] {\n      \
    \                  ^~~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has\
    \ been explicitly marked unavailable here\n    public subscript(i: Int) -> Character\
    \ { get }\n           ^\n/tmp/tmpc58o6uss.swift:24:25: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if string[j] == substring[i] {\n                        ^~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpc58o6uss.swift:25:19:\
    \ error: binary operator '+' cannot be applied to operands of type 'String.Index'\
    \ and 'Int'\n            j = j + 1\n                ~ ^ ~\n/tmp/tmpc58o6uss.swift:25:19:\
    \ note: overloads for '+' exist with these partially matching parameter lists:\
    \ (Int, Int)\n            j = j + 1\n                  ^\n"
  stdout: ''
  timestamp: 1659824940
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if\
    \ string == \"\" {\n        return 0\n    }\n    if substring == \"\" {\n    \
    \    return count(string)\n    }\n    var count = 0\n    var start = 0\n    var\
    \ end = count(string)\n    while start < end {\n        start = find(string, substring,\
    \ start)\n        end = find(string, substring, end + 1)\n        if start ==\
    \ end {\n            count += 1\n        }\n    }\n    return count\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpz__4o2rn.swift:14:16: error: use of local variable 'count' before\
    \ its declaration\n        return count(string)\n               ^\n/tmp/tmpz__4o2rn.swift:16:9:\
    \ note: 'count' declared here\n    var count = 0\n        ^\n/tmp/tmpz__4o2rn.swift:18:15:\
    \ error: cannot call value of non-function type 'Int'\n    var end = count(string)\n\
    \              ^\n/tmp/tmpz__4o2rn.swift:20:17: error: cannot find 'find' in scope\n\
    \        start = find(string, substring, start)\n                ^~~~\n/tmp/tmpz__4o2rn.swift:21:15:\
    \ error: cannot find 'find' in scope\n        end = find(string, substring, end\
    \ + 1)\n              ^~~~\n"
  stdout: ''
  timestamp: 1659824939
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if\
    \ string == \"\" {\n        return 0\n    }\n    if substring == \"\" {\n    \
    \    return countOccurrences(string, \"\")\n    }\n    var count = 0\n    var\
    \ last = 0\n    for index in 0..<string.characters.count {\n        if string.characters[index]\
    \ == substring.characters[0] {\n            count += 1\n            last = index\n\
    \        }\n    }\n    if last < string.characters.count {\n        count += countOccurrences(string,\
    \ string.characters[last..<string.characters.count])\n    }\n    return count\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmprpqbpw7d.swift:14:16: error: cannot find 'countOccurrences' in\
    \ scope\n        return countOccurrences(string, \"\")\n               ^~~~~~~~~~~~~~~~\n\
    /tmp/tmprpqbpw7d.swift:18:29: error: 'characters' is unavailable: Please use String\
    \ directly\n    for index in 0..<string.characters.count {\n                 \
    \           ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in\
    \ Swift 5.0\n    public var characters: String { get set }\n               ^\n\
    /tmp/tmprpqbpw7d.swift:19:12: error: 'subscript(_:)' is unavailable: cannot subscript\
    \ String with an Int, use a String.Index instead.\n        if string.characters[index]\
    \ == substring.characters[0] {\n           ^~~~~~~~~~~~~~~~~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmprpqbpw7d.swift:19:19:\
    \ error: 'characters' is unavailable: Please use String directly\n        if string.characters[index]\
    \ == substring.characters[0] {\n                  ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmprpqbpw7d.swift:19:40: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if string.characters[index] == substring.characters[0] {\n          \
    \                             ^~~~~~~~~~~~~~~~~~~~~~~\nSwift.String:3:12: note:\
    \ 'subscript(_:)' has been explicitly marked unavailable here\n    public subscript(i:\
    \ Int) -> Character { get }\n           ^\n/tmp/tmprpqbpw7d.swift:19:50: error:\
    \ 'characters' is unavailable: Please use String directly\n        if string.characters[index]\
    \ == substring.characters[0] {\n                                             \
    \    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmprpqbpw7d.swift:24:22:\
    \ error: 'characters' is unavailable: Please use String directly\n    if last\
    \ < string.characters.count {\n "
  stdout: ''
  timestamp: 1659824940
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if\
    \ string == \"\" || substring == \"\" {\n        return 0\n    }\n    var count\
    \ = 0\n    var i = 0\n    var j = string.count\n    var k = substring.count\n\
    \    while i < j {\n        if string[i] == substring[k] {\n            count\
    \ += 1\n            i += k\n            k -= 1\n        }\n        i += 1\n  \
    \  }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpqah73p9z.swift:18:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if string[i]\
    \ == substring[k] {\n           ^~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpqah73p9z.swift:18:25: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if string[i] == substring[k] {\n                        ^~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpqah73p9z.swift:15:9:\
    \ warning: variable 'j' was never mutated; consider changing to 'let' constant\n\
    \    var j = string.count\n    ~~~ ^\n    let\n"
  stdout: ''
  timestamp: 1659824940
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    var\
    \ count = 0\n    for c in string {\n        if c == substring {\n            count\
    \ += 1\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp1o2nzo8z.swift:12:14: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        if c == substring {\n\
    \           ~ ^  ~~~~~~~~~\n/tmp/tmp1o2nzo8z.swift:12:14: note: overloads for\
    \ '==' exist with these partially matching parameter lists: (Character, Character),\
    \ (String, String)\n        if c == substring {\n             ^\n"
  stdout: ''
  timestamp: 1659824940
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if\
    \ string == \"\" {\n        return 0\n    }\n    if substring == \"\" {\n    \
    \    return countOccurrences(string, \"\")\n    }\n    var count = 0\n    var\
    \ start = 0\n    var end = string.count\n    while start < end {\n        let\
    \ index = string.index(start, offsetBy: substring.length)\n        if index ==\
    \ nil {\n            break\n        }\n        start = index!\n        count +=\
    \ 1\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp0on8ya66.swift:14:16: error: cannot find 'countOccurrences' in\
    \ scope\n        return countOccurrences(string, \"\")\n               ^~~~~~~~~~~~~~~~\n\
    /tmp/tmp0on8ya66.swift:20:34: error: cannot convert value of type 'Int' to expected\
    \ argument type 'String.Index'\n        let index = string.index(start, offsetBy:\
    \ substring.length)\n                                 ^\n/tmp/tmp0on8ya66.swift:20:61:\
    \ error: value of type 'String' has no member 'length'\n        let index = string.index(start,\
    \ offsetBy: substring.length)\n                                              \
    \    ~~~~~~~~~ ^~~~~~\n"
  stdout: ''
  timestamp: 1659824940
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    var\
    \ count = 0\n    for index in 0..<string.characters.count {\n        if string.substring(index,\
    \ string.characters.count) == substring {\n            count += 1\n        }\n\
    \    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpja6rt6dx.swift:11:29: error: 'characters' is unavailable: Please\
    \ use String directly\n    for index in 0..<string.characters.count {\n      \
    \                      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpja6rt6dx.swift:12:19: error: value of type 'String' has no member\
    \ 'substring'\n        if string.substring(index, string.characters.count) ==\
    \ substring {\n           ~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824940
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if\
    \ string == \"\" {\n        return 0\n    }\n    if substring == \"\" {\n    \
    \    return countOccurrences(string, \"\")\n    }\n    var count = 0\n    var\
    \ startIndex = 0\n    var endIndex = string.count\n    while startIndex < endIndex\
    \ {\n        var index = string.index(startIndex, offsetBy: substring.count)\n\
    \        if index == NSNotFound {\n            break\n        }\n        if string.substring(with:\
    \ index).lowercased() == substring.lowercased() {\n            count += 1\n  \
    \          startIndex = index\n        } else {\n            endIndex = index\n\
    \        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpv5yt1l1o.swift:14:16: error: cannot find 'countOccurrences' in\
    \ scope\n        return countOccurrences(string, \"\")\n               ^~~~~~~~~~~~~~~~\n\
    /tmp/tmpv5yt1l1o.swift:20:34: error: cannot convert value of type 'Int' to expected\
    \ argument type 'String.Index'\n        var index = string.index(startIndex, offsetBy:\
    \ substring.count)\n                                 ^\n/tmp/tmpv5yt1l1o.swift:21:21:\
    \ error: cannot find 'NSNotFound' in scope\n        if index == NSNotFound {\n\
    \                    ^~~~~~~~~~\n/tmp/tmpv5yt1l1o.swift:24:19: error: value of\
    \ type 'String' has no member 'substring'\n        if string.substring(with: index).lowercased()\
    \ == substring.lowercased() {\n           ~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824940
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    let\
    \ count = string.characters.filter({ $0 == substring }).count\n    return count\
    \ > 0 ? count : 0\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp0k83al8w.swift:10:47: error: binary operator '==' cannot be applied\
    \ to operands of type 'String.Element' (aka 'Character') and 'String'\n    let\
    \ count = string.characters.filter({ $0 == substring }).count\n              \
    \                             ~~ ^  ~~~~~~~~~\n/tmp/tmp0k83al8w.swift:10:47: note:\
    \ overloads for '==' exist with these partially matching parameter lists: (Character,\
    \ Character), (String, String)\n    let count = string.characters.filter({ $0\
    \ == substring }).count\n                                              ^\n"
  stdout: ''
  timestamp: 1659824940
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if\
    \ string == \"\" {\n        return 0\n    }\n    if substring == \"\" {\n    \
    \    return count(string)\n    }\n    var count = 0\n    var i = 0\n    var j\
    \ = string.count\n    var k = substring.count\n    while i < j && k < string.count\
    \ {\n        if string[i] != substring[k] {\n            count = count + 1\n \
    \       }\n        i += 1\n        k += 1\n    }\n    return count\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpa08f1sdx.swift:14:16: error: use of local variable 'count' before\
    \ its declaration\n        return count(string)\n               ^\n/tmp/tmpa08f1sdx.swift:16:9:\
    \ note: 'count' declared here\n    var count = 0\n        ^\n/tmp/tmpa08f1sdx.swift:21:12:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if string[i] != substring[k] {\n      \
    \     ^~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly\
    \ marked unavailable here\n    public subscript(i: Int) -> Character { get }\n\
    \           ^\n/tmp/tmpa08f1sdx.swift:21:25: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n        if\
    \ string[i] != substring[k] {\n                        ^~~~~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1659824940
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if\
    \ string == \"\" {\n        return 0\n    }\n    if substring == \"\" {\n    \
    \    return count(string)\n    }\n    var count = 0\n    var i = 0\n    var j\
    \ = string.startIndex\n    while i < string.endIndex {\n        if string[i] ==\
    \ substring[0] {\n            count += 1\n            i += 1\n            while\
    \ i < string.endIndex && string[i] == substring[1] {\n                i += 1\n\
    \            }\n            j = i\n        } else {\n            j = i\n     \
    \   }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpf6xrsts8.swift:14:16: error: use of local variable 'count' before\
    \ its declaration\n        return count(string)\n               ^\n/tmp/tmpf6xrsts8.swift:16:9:\
    \ note: 'count' declared here\n    var count = 0\n        ^\n/tmp/tmpf6xrsts8.swift:19:13:\
    \ error: operator function '<' requires that 'String.Index' conform to 'BinaryInteger'\n\
    \    while i < string.endIndex {\n            ^\nSwift.BinaryInteger:4:24: note:\
    \ where 'Other' = 'String.Index'\n    public static func < <Other>(lhs: Self,\
    \ rhs: Other) -> Bool where Other : BinaryInteger\n                       ^\n\
    /tmp/tmpf6xrsts8.swift:20:12: error: 'subscript(_:)' is unavailable: cannot subscript\
    \ String with an Int, use a String.Index instead.\n        if string[i] == substring[0]\
    \ {\n           ^~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly\
    \ marked unavailable here\n    public subscript(i: Int) -> Character { get }\n\
    \           ^\n/tmp/tmpf6xrsts8.swift:20:25: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n        if\
    \ string[i] == substring[0] {\n                        ^~~~~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpf6xrsts8.swift:23:21:\
    \ error: operator function '<' requires that 'String.Index' conform to 'BinaryInteger'\n\
    \            while i < string.endIndex && string[i] == substring[1] {\n      \
    \              ^\nSwift.BinaryInteger:4:24: note: where 'Other' = 'String.Index'\n\
    \    public static func < <Other>(lhs: Self, rhs: Other) -> Bool where Other :\
    \ BinaryInteger\n                       ^\n/tmp/tmpf6xrsts8.swift:26:17: error:\
    \ cannot assign value of type 'Int' to type 'String.Index'\n            j = i\n\
    \                ^\n/tmp/tmpf6xrsts8.swift:28:17: error: cannot assign value of\
    \ type 'Int' to type 'String.Index'\n            j = i\n                ^\n"
  stdout: ''
  timestamp: 1659824940
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    var\
    \ count = 0\n    for index in 0..<string.characters.count {\n        if string.substring(index,\
    \ string.characters.count) == substring {\n            count += 1\n        }\n\
    \    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpja6rt6dx.swift:11:29: error: 'characters' is unavailable: Please\
    \ use String directly\n    for index in 0..<string.characters.count {\n      \
    \                      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpja6rt6dx.swift:12:19: error: value of type 'String' has no member\
    \ 'substring'\n        if string.substring(index, string.characters.count) ==\
    \ substring {\n           ~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824940
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if\
    \ string == \"\" {\n        return 0\n    }\n    if substring == \"\" {\n    \
    \    return string.count\n    }\n    var count = 0\n    var i = 0\n    var j =\
    \ string.count\n    var k = substring.count\n    while i < j {\n        if string[i]\
    \ == substring[0] {\n            count = count + 1\n            i = i + 1\n  \
    \          if i == k {\n                return count\n            }\n        }\
    \ else {\n            i = i + 1\n        }\n    }\n    return count\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmph9polkye.swift:21:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if string[i]\
    \ == substring[0] {\n           ^~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmph9polkye.swift:21:25: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if string[i] == substring[0] {\n                        ^~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmph9polkye.swift:18:9:\
    \ warning: variable 'j' was never mutated; consider changing to 'let' constant\n\
    \    var j = string.count\n    ~~~ ^\n    let\n/tmp/tmph9polkye.swift:19:9: warning:\
    \ variable 'k' was never mutated; consider changing to 'let' constant\n    var\
    \ k = substring.count\n    ~~~ ^\n    let\n"
  stdout: ''
  timestamp: 1659824940
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if\
    \ string == \"\" || substring == \"\" {\n        return 0\n    }\n    var count\
    \ = 0\n    var i = 0\n    var j = 0\n    var k = 0\n    var l = string.count\n\
    \    var m = substring.count\n    for (i; i < l; i++ {\n        if string[i] ==\
    \ substring[j] {\n            count++\n            j = j + 1\n            if j\
    \ == m {\n                j = 0\n                k = k + 1\n            }\n  \
    \      }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpfugj1kqf.swift:19:5: error: C-style for statement has been removed\
    \ in Swift 3\n    for (i; i < l; i++ {\n    ^   ~~~~~~~~~~~~~~~~\n/tmp/tmpfugj1kqf.swift:29:17:\
    \ error: expected '{' to start the body of for-each loop\n    return count\n \
    \               ^\n"
  stdout: ''
  timestamp: 1659824940
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if\
    \ string == \"\" {\n        return 0\n    }\n    if substring == \"\" {\n    \
    \    return countOccurrences(string, \"\")\n    }\n    var count = 0\n    var\
    \ i = 0\n    var j = string.characters.count\n    var k = substring.characters.count\n\
    \    while i < j {\n        if string[i] != substring[j] {\n            count\
    \ = count + 1\n        }\n        i = i + 1\n        j = j - 1\n    }\n    while\
    \ i < k {\n        if string[i] != substring[k] {\n            count = count +\
    \ 1\n        }\n        i = i + 1\n        k = k - 1\n    }\n    return count\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpztt9okbi.swift:14:16: error: cannot find 'countOccurrences' in\
    \ scope\n        return countOccurrences(string, \"\")\n               ^~~~~~~~~~~~~~~~\n\
    /tmp/tmpztt9okbi.swift:18:20: error: 'characters' is unavailable: Please use String\
    \ directly\n    var j = string.characters.count\n                   ^~~~~~~~~~\n\
    Swift.String:5:16: note: 'characters' was obsoleted in Swift 5.0\n    public var\
    \ characters: String { get set }\n               ^\n/tmp/tmpztt9okbi.swift:19:23:\
    \ error: 'characters' is unavailable: Please use String directly\n    var k =\
    \ substring.characters.count\n                      ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmpztt9okbi.swift:21:12: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if string[i] != substring[j] {\n           ^~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpztt9okbi.swift:21:25:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if string[i] != substring[j] {\n      \
    \                  ^~~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has\
    \ been explicitly marked unavailable here\n    public subscript(i: Int) -> Character\
    \ { get }\n           ^\n/tmp/tmpztt9okbi.swift:28:12: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if string[i] != substring[k] {\n           ^~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpztt9okbi.swift:28:25:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if string[i] != substring[k] {\n      \
    \                  ^~~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has\
    \ been explicitly ma"
  stdout: ''
  timestamp: 1659824940
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if\
    \ string == \"\" {\n        return 0\n    }\n    if substring == \"\" {\n    \
    \    return countOccurrences(string, \"\")\n    }\n    var count = 0\n    var\
    \ last = 0\n    for index in 0..<string.characters.count {\n        if string.characters[index]\
    \ == substring.characters[0] {\n            count += countOccurrences(string,\
    \ string.characters[index])\n            last = index\n        }\n    }\n    if\
    \ last < string.characters.count {\n        count += countOccurrences(string,\
    \ string.characters[last])\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpsecffq23.swift:14:16: error: cannot find 'countOccurrences' in\
    \ scope\n        return countOccurrences(string, \"\")\n               ^~~~~~~~~~~~~~~~\n\
    /tmp/tmpsecffq23.swift:18:29: error: 'characters' is unavailable: Please use String\
    \ directly\n    for index in 0..<string.characters.count {\n                 \
    \           ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in\
    \ Swift 5.0\n    public var characters: String { get set }\n               ^\n\
    /tmp/tmpsecffq23.swift:19:12: error: 'subscript(_:)' is unavailable: cannot subscript\
    \ String with an Int, use a String.Index instead.\n        if string.characters[index]\
    \ == substring.characters[0] {\n           ^~~~~~~~~~~~~~~~~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpsecffq23.swift:19:19:\
    \ error: 'characters' is unavailable: Please use String directly\n        if string.characters[index]\
    \ == substring.characters[0] {\n                  ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmpsecffq23.swift:19:40: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if string.characters[index] == substring.characters[0] {\n          \
    \                             ^~~~~~~~~~~~~~~~~~~~~~~\nSwift.String:3:12: note:\
    \ 'subscript(_:)' has been explicitly marked unavailable here\n    public subscript(i:\
    \ Int) -> Character { get }\n           ^\n/tmp/tmpsecffq23.swift:19:50: error:\
    \ 'characters' is unavailable: Please use String directly\n        if string.characters[index]\
    \ == substring.characters[0] {\n                                             \
    \    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmpsecffq23.swift:20:22:\
    \ error: cannot find 'countOccurrences' in scope\n            count += countOccurrences(string,\
    \ string.char"
  stdout: ''
  timestamp: 1659824941
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    var\
    \ count = 0\n    for index in 0..<string.characters.count {\n        if string.substring(from:\
    \ index).lowercased() == substring.lowercased() {\n            count += 1\n  \
    \      }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpzebs1vtl.swift:11:29: error: 'characters' is unavailable: Please\
    \ use String directly\n    for index in 0..<string.characters.count {\n      \
    \                      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpzebs1vtl.swift:12:19: error: value of type 'String' has no member\
    \ 'substring'\n        if string.substring(from: index).lowercased() == substring.lowercased()\
    \ {\n           ~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824940
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    var\
    \ count = 0\n    for c in string.unicodeScalars {\n        if c == substring {\n\
    \            count += 1\n        }\n    }\n    return count\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\n\
    assert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string:\
    \ \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john\
    \ doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpd3rykh2s.swift:12:14: error: referencing operator function '=='\
    \ on 'StringProtocol' requires that 'Unicode.Scalar' conform to 'StringProtocol'\n\
    \        if c == substring {\n             ^\nSwift.StringProtocol:1:11: note:\
    \ where 'Self' = 'Unicode.Scalar'\nextension StringProtocol {\n          ^\n"
  stdout: ''
  timestamp: 1659824939
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if\
    \ string == \"\" {\n        return 0\n    }\n    if substring == \"\" {\n    \
    \    return 1\n    }\n    var count = 0\n    var i = 0\n    var j = string.count\n\
    \    var k = substring.count\n    while i < j {\n        if string[i] == substring[0]\
    \ {\n            i += 1\n            count += k\n            if i < j {\n    \
    \            if string[i] == substring[1] {\n                    i += 1\n    \
    \                count += k\n                    if i < j {\n                \
    \        if string[i] == substring[2] {\n                            i += 1\n\
    \                            count += k\n                            if i < j\
    \ {\n                                if string[i] == substring[3] {\n        \
    \                            i += 1\n                                    count\
    \ += k\n                                    if i < j {\n                     \
    \                   if string[i] == substring[4] {\n                         \
    \                   i += 1\n                                            count\
    \ += k\n                                            if i < j {\n             \
    \                                   if string[i] == substring[5] {\n         \
    \                                           i += 1\n                         \
    \                           count += k\n                                     \
    \               if i < j {\n                                                 \
    \       if string[i] == substring[6] {\n                                     \
    \                       i += 1\n                                             \
    \               count += k\n                                                 \
    \           if i < j {\n                                                     \
    \           if string[i] == substring[7] {\n                                 \
    \                                   i += 1\n                                 \
    \                                   count += k\n                             \
    \                                       if i < j {\n                         \
    \                                               if string[i] == substring[8] {\n\
    \                                                                        i +=\
    \ 1\n                                                                        count\
    \ += k\n                                                            if i < j {\n\
    \                                                                            if\
    \ string[i] == substring[9] {\n                                              \
    \                                  i += 1\n                                  \
    \                                              count += k\n                  \
    \                                                              if i < j {\n  \
    \                                                                            \
    \      if string[i] == substring[10] {\n                                     \
    \                                                   i += 1\n                 \
    \                                                                       count\
    \ += k\n                                                                     \
    \                   if i < j {\n                                             \
    \                                               if string[i] == substring[11]\
    \ {\n                                                                        \
    \                        i += 1\n                                            \
    \                                                    count += k\n            \
    \                                                                            \
    \        if i < j {\n                                                        \
    \                                            if string[i] == substring[12] {\n\
    \                                                                            \
    \                            i += 1\n                                        \
    \                                                                count += k\n\
    \                                                                            \
    \                            if i < j {\n                                    \
    \                                                                        if string[i]\
    \ == substring[13] {\n                                                       \
    \                                                         i += 1\n           \
    \                                                                            \
    \                         count += k\n                                       \
    \                                                                         if i\
    \ < j {\n                                                                    \
    \                                                if string[i] == substring[14]\
    \ {\n                                                                        \
    \                                                i += 1\n                    \
    \                                                                            \
    \                        count += k\n                                        \
    \                                                                            \
    \    if i < j {\n                                                            \
    \                                                                if string[i]\
    \ == substring[15] {\n                                                       \
    \                                                                         i +=\
    \ 1\n                                                                        \
    \                                                        count += k\n        \
    \                                                                            \
    \                                                if i < j {\n                \
    \                                                                            \
    \                                            if string[i] == substring[16] {\n\
    \                                                                            \
    \                                                                i += 1\n    \
    \                                                                            \
    \                                                            count += k\n    \
    \                                                                            \
    \                                                    if i < j {\n            \
    \                                                                            \
    \                                                if string[i] == substring[17]\
    \ {\n                                                                        \
    \                                                                    i += 1\n\
    \                                                                            \
    \                                                                count += k\n\
    \                                                                            \
    \                                                        if i < j {\n        \
    \                                                                            \
    \                                                    if string[i] == substring[18]\
    \ {\n                                                                        \
    \                                                                    i += 1\n\
    \                                                                            \
    \                                                                count += k\n\
    \                                                                            \
    \                                                        if i < j\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpkmdjiii8.swift:96:141: error: expected '{' after 'if' condition\n\
    \                                                                            \
    \                                                        if i < j\n          \
    \                                                                            \
    \                                                      ^\n/tmp/tmpkmdjiii8.swift:115:67:\
    \ error: expected '}' at end of brace statement\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)\n                                 \
    \                                 ^\n/tmp/tmpkmdjiii8.swift:92:142: note: to match\
    \ this opening '{'\n                                                         \
    \                                                                           if\
    \ i < j {\n                                                                  \
    \                                                                           ^\n\
    /tmp/tmpkmdjiii8.swift:115:67: error: expected '}' at end of brace statement\n\
    assert(how_many_times(string: \"john doe\", substring: \"john\") == 1)\n     \
    \                                                             ^\n/tmp/tmpkmdjiii8.swift:89:167:\
    \ note: to match this opening '{'\n                                          \
    \                                                                            \
    \                  if string[i] == substring[17] {\n                         \
    \                                                                            \
    \                                                                 ^\n/tmp/tmpkmdjiii8.swift:115:67:\
    \ error: expected '}' at end of brace statement\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)\n                                 \
    \                                 ^\n/tmp/tmpkmdjiii8.swift:88:142: note: to match\
    \ this opening '{'\n                                                         \
    \                                                                           if\
    \ i < j {\n                                                                  \
    \                                     "
  stdout: ''
  timestamp: 1659824941
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if\
    \ string == \"\" {\n        return 0\n    }\n    if substring == \"\" {\n    \
    \    return string.count\n    }\n    var count = 0\n    var i = 0\n    var j =\
    \ 0\n    for i < string.count {\n        if string[i] == substring[0] {\n    \
    \        count += 1\n            i += substring.length - 1\n        } else {\n\
    \            count = 0\n        }\n        if j == substring.count {\n       \
    \     count += 1\n            j = 0\n        } else {\n            j += 1\n  \
    \      }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpocuqcvhl.swift:19:11: error: expected 'in' after for-each pattern\n\
    \    for i < string.count {\n          ^\n/tmp/tmpocuqcvhl.swift:19:11: error:\
    \ unary operator cannot be separated from its operand\n    for i < string.count\
    \ {\n          ^~\n           \n/tmp/tmpocuqcvhl.swift:19:11: error: '<' is not\
    \ a prefix unary operator\n    for i < string.count {\n          ^\n"
  stdout: ''
  timestamp: 1659824940
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    var\
    \ count = 0\n    var i = 0\n    var j = string.count\n    var k = substring.count\n\
    \    while i < j {\n        if string[i] == substring[k] {\n            count\
    \ += 1\n            i += k\n            k += k\n        } else {\n           \
    \ i += 1\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp1l5soohc.swift:15:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if string[i]\
    \ == substring[k] {\n           ^~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmp1l5soohc.swift:15:25: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if string[i] == substring[k] {\n                        ^~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmp1l5soohc.swift:12:9:\
    \ warning: variable 'j' was never mutated; consider changing to 'let' constant\n\
    \    var j = string.count\n    ~~~ ^\n    let\n"
  stdout: ''
  timestamp: 1659824940
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if\
    \ string == \"\" || substring == \"\" {\n        return 0\n    }\n    var count\
    \ = 0\n    var startIndex = 0\n    var endIndex = 0\n    while startIndex < string.count\
    \ {\n        endIndex = string.index(substring, startIndex)\n        if endIndex\
    \ == startIndex {\n            count += 1\n            startIndex = string.index(substring,\
    \ startIndex) + 1\n        } else {\n            count += endIndex - startIndex\n\
    \            startIndex = endIndex + 1\n        }\n    }\n    return count\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpbuwjvfpx.swift:17:27: error: no exact matches in call to instance\
    \ method 'index'\n        endIndex = string.index(substring, startIndex)\n   \
    \                       ^\n/tmp/tmpbuwjvfpx.swift:17:27: note: found candidate\
    \ with type '(String.Index, Int) -> String.Index'\n        endIndex = string.index(substring,\
    \ startIndex)\n                          ^\n/tmp/tmpbuwjvfpx.swift:17:27: error:\
    \ cannot assign value of type 'String.Index' to type 'Int'\n        endIndex =\
    \ string.index(substring, startIndex)\n                   ~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpbuwjvfpx.swift:20:33: error: cannot convert value of type 'String.Index'\
    \ to expected argument type 'Int'\n            startIndex = string.index(substring,\
    \ startIndex) + 1\n                                ^\n/tmp/tmpbuwjvfpx.swift:20:33:\
    \ error: no exact matches in call to instance method 'index'\n            startIndex\
    \ = string.index(substring, startIndex) + 1\n                                ^\n\
    /tmp/tmpbuwjvfpx.swift:20:33: note: candidate has partially matching parameter\
    \ list (String.Index, offsetBy: Int)\n            startIndex = string.index(substring,\
    \ startIndex) + 1\n                                ^\n/tmp/tmpbuwjvfpx.swift:20:33:\
    \ note: candidate has partially matching parameter list (String.Index, offsetBy:\
    \ Int)\n            startIndex = string.index(substring, startIndex) + 1\n   \
    \                             ^\n/tmp/tmpbuwjvfpx.swift:20:33: note: candidate\
    \ has partially matching parameter list (String.Index, offsetBy: Int)\n      \
    \      startIndex = string.index(substring, startIndex) + 1\n                \
    \                ^\n"
  stdout: ''
  timestamp: 1659824941
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if\
    \ string == \"\" {\n        return 0\n    }\n    if substring == \"\" {\n    \
    \    return countOccurrences(string, \"\")\n    }\n    var count = 0\n    var\
    \ i = 0\n    var j = string.count\n    var k = substring.count\n    while i <\
    \ j {\n        if string[i] == substring[0] {\n            count += countOccurrences(&string[i+1],\
    \ substring[1:])\n            i += k\n        } else {\n            count += countOccurrences(&string[i],\
    \ substring)\n            i += 1\n        }\n    }\n    return count\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp0qa27frd.swift:22:64: error: expected ',' separator\n         \
    \   count += countOccurrences(&string[i+1], substring[1:])\n                 \
    \                                              ^\n                           \
    \                                    ,\n/tmp/tmp0qa27frd.swift:22:64: error: expected\
    \ expression in list of expressions\n            count += countOccurrences(&string[i+1],\
    \ substring[1:])\n                                                           \
    \    ^\n/tmp/tmp0qa27frd.swift:14:16: error: cannot find 'countOccurrences' in\
    \ scope\n        return countOccurrences(string, \"\")\n               ^~~~~~~~~~~~~~~~\n\
    /tmp/tmp0qa27frd.swift:21:12: error: 'subscript(_:)' is unavailable: cannot subscript\
    \ String with an Int, use a String.Index instead.\n        if string[i] == substring[0]\
    \ {\n           ^~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly\
    \ marked unavailable here\n    public subscript(i: Int) -> Character { get }\n\
    \           ^\n/tmp/tmp0qa27frd.swift:21:25: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n        if\
    \ string[i] == substring[0] {\n                        ^~~~~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmp0qa27frd.swift:22:22:\
    \ error: cannot find 'countOccurrences' in scope\n            count += countOccurrences(&string[i+1],\
    \ substring[1:])\n                     ^~~~~~~~~~~~~~~~\n/tmp/tmp0qa27frd.swift:22:39:\
    \ error: cannot pass immutable value as inout argument: subscript is get-only\n\
    \            count += countOccurrences(&string[i+1], substring[1:])\n        \
    \                              ^~~~~~~~~~~~\n/tmp/tmp0qa27frd.swift:25:22: error:\
    \ cannot find 'countOccurrences' in scope\n            count += countOccurrences(&string[i],\
    \ substring)\n                     ^~~~~~~~~~~~~~~~\n/tmp/tmp0qa27frd.swift:25:39:\
    \ error: cannot pass immutable value as inout argument: subscript is get-only\n\
    \            count += countOccurrences("
  stdout: ''
  timestamp: 1659824941
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if\
    \ string == \"\" {\n        return 0\n    }\n    if substring == \"\" {\n    \
    \    return count(string)\n    }\n    var count = 0\n    var start = 0\n    var\
    \ end = count(string)\n    while start < end {\n        let mid = start + (end\
    \ - start) / 2\n        if string[mid] == substring {\n            count += 1\n\
    \            start = mid + 1\n        } else {\n            if string[mid] > substring\
    \ {\n                end = mid\n            } else {\n                start =\
    \ mid + 1\n            }\n        }\n    }\n    return count\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\n\
    assert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string:\
    \ \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john\
    \ doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmph30if8rw.swift:14:16: error: use of local variable 'count' before\
    \ its declaration\n        return count(string)\n               ^\n/tmp/tmph30if8rw.swift:16:9:\
    \ note: 'count' declared here\n    var count = 0\n        ^\n/tmp/tmph30if8rw.swift:18:15:\
    \ error: cannot call value of non-function type 'Int'\n    var end = count(string)\n\
    \              ^\n"
  stdout: ''
  timestamp: 1659824941
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if\
    \ string == \"\" {\n        return 0\n    }\n    if substring == \"\" {\n    \
    \    return countOccurrences(string, \"\")\n    }\n    var count = 0\n    var\
    \ last = 0\n    for index in 0..<string.characters.count {\n        if string.characters[index]\
    \ == substring.characters[0] {\n            count++\n            last = index\n\
    \        }\n    }\n    if last < string.characters.count {\n        for index\
    \ in last..<string.characters.count {\n            if string.characters[index]\
    \ == substring.characters[0] {\n                count++\n            }\n     \
    \   }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmph_3u4n7d.swift:14:16: error: cannot find 'countOccurrences' in\
    \ scope\n        return countOccurrences(string, \"\")\n               ^~~~~~~~~~~~~~~~\n\
    /tmp/tmph_3u4n7d.swift:18:29: error: 'characters' is unavailable: Please use String\
    \ directly\n    for index in 0..<string.characters.count {\n                 \
    \           ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in\
    \ Swift 5.0\n    public var characters: String { get set }\n               ^\n\
    /tmp/tmph_3u4n7d.swift:19:12: error: 'subscript(_:)' is unavailable: cannot subscript\
    \ String with an Int, use a String.Index instead.\n        if string.characters[index]\
    \ == substring.characters[0] {\n           ^~~~~~~~~~~~~~~~~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmph_3u4n7d.swift:19:19:\
    \ error: 'characters' is unavailable: Please use String directly\n        if string.characters[index]\
    \ == substring.characters[0] {\n                  ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmph_3u4n7d.swift:19:40: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if string.characters[index] == substring.characters[0] {\n          \
    \                             ^~~~~~~~~~~~~~~~~~~~~~~\nSwift.String:3:12: note:\
    \ 'subscript(_:)' has been explicitly marked unavailable here\n    public subscript(i:\
    \ Int) -> Character { get }\n           ^\n/tmp/tmph_3u4n7d.swift:19:50: error:\
    \ 'characters' is unavailable: Please use String directly\n        if string.characters[index]\
    \ == substring.characters[0] {\n                                             \
    \    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmph_3u4n7d.swift:20:18:\
    \ error: cannot find operator '++' in scope; did you mean '+= 1'?\n          \
    \  count++\n                 ^~\n"
  stdout: ''
  timestamp: 1659824941
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    return\
    \ count_overlapping_cases(string, substring)\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp__9p21xq.swift:10:12: error: cannot find 'count_overlapping_cases'\
    \ in scope\n    return count_overlapping_cases(string, substring)\n          \
    \ ^~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824940
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if\
    \ string == \"\" || substring == \"\" {\n        return 0\n    }\n    var count\
    \ = 0\n    var startIndex = 0\n    var endIndex = 0\n    while startIndex < string.count\
    \ {\n        endIndex = string.index(substring, startIndex)\n        if endIndex\
    \ == startIndex {\n            count += 1\n            startIndex = string.index(substring,\
    \ startIndex) + 1\n        } else {\n            count += 1\n            startIndex\
    \ = endIndex + 1\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpqpanlajp.swift:17:27: error: no exact matches in call to instance\
    \ method 'index'\n        endIndex = string.index(substring, startIndex)\n   \
    \                       ^\n/tmp/tmpqpanlajp.swift:17:27: note: found candidate\
    \ with type '(String.Index, Int) -> String.Index'\n        endIndex = string.index(substring,\
    \ startIndex)\n                          ^\n/tmp/tmpqpanlajp.swift:17:27: error:\
    \ cannot assign value of type 'String.Index' to type 'Int'\n        endIndex =\
    \ string.index(substring, startIndex)\n                   ~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpqpanlajp.swift:20:33: error: no exact matches in call to instance method\
    \ 'index'\n            startIndex = string.index(substring, startIndex) + 1\n\
    \                                ^\n/tmp/tmpqpanlajp.swift:20:33: note: candidate\
    \ has partially matching parameter list (String.Index, offsetBy: Int)\n      \
    \      startIndex = string.index(substring, startIndex) + 1\n                \
    \                ^\n/tmp/tmpqpanlajp.swift:20:33: note: candidate has partially\
    \ matching parameter list (String.Index, offsetBy: Int)\n            startIndex\
    \ = string.index(substring, startIndex) + 1\n                                ^\n\
    /tmp/tmpqpanlajp.swift:20:33: note: candidate has partially matching parameter\
    \ list (String.Index, offsetBy: Int)\n            startIndex = string.index(substring,\
    \ startIndex) + 1\n                                ^\n/tmp/tmpqpanlajp.swift:20:33:\
    \ error: cannot convert value of type 'String.Index' to expected argument type\
    \ 'Int'\n            startIndex = string.index(substring, startIndex) + 1\n  \
    \                              ^\n"
  stdout: ''
  timestamp: 1659824941
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    return\
    \ count_overlapping_cases(string, substring)\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp__9p21xq.swift:10:12: error: cannot find 'count_overlapping_cases'\
    \ in scope\n    return count_overlapping_cases(string, substring)\n          \
    \ ^~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824940
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    let\
    \ count = string.characters.reduce(0) { (sum, character) -> Int in\n        if\
    \ character == substring {\n            sum += 1;\n        }\n        return sum;\n\
    \    }\n    return count;\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpucxta_3h.swift:11:22: error: binary operator '==' cannot be applied\
    \ to operands of type 'String.Element' (aka 'Character') and 'String'\n      \
    \  if character == substring {\n           ~~~~~~~~~ ^  ~~~~~~~~~\n/tmp/tmpucxta_3h.swift:11:22:\
    \ note: overloads for '==' exist with these partially matching parameter lists:\
    \ (Character, Character), (String, String)\n        if character == substring\
    \ {\n                     ^\n"
  stdout: ''
  timestamp: 1659824941
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if\
    \ string == \"\" {\n        return 0\n    }\n    if substring == \"\" {\n    \
    \    return count(string)\n    }\n    var count = 0\n    var i = 0\n    var j\
    \ = string.count\n    var k = substring.count\n    while i < j {\n        if string[i]\
    \ == substring[0] {\n            count = count + 1\n            i = i + 1\n  \
    \          while i < j && string[i] == substring[1] {\n                count =\
    \ count + 1\n                i = i + 1\n            }\n            i = i + 1\n\
    \        } else {\n            i = i + 1\n        }\n    }\n    return count\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpsp17ugwj.swift:14:16: error: use of local variable 'count' before\
    \ its declaration\n        return count(string)\n               ^\n/tmp/tmpsp17ugwj.swift:16:9:\
    \ note: 'count' declared here\n    var count = 0\n        ^\n/tmp/tmpsp17ugwj.swift:21:12:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if string[i] == substring[0] {\n      \
    \     ^~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly\
    \ marked unavailable here\n    public subscript(i: Int) -> Character { get }\n\
    \           ^\n/tmp/tmpsp17ugwj.swift:21:25: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n        if\
    \ string[i] == substring[0] {\n                        ^~~~~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpsp17ugwj.swift:24:28:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n            while i < j && string[i] == substring[1]\
    \ {\n                           ^~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpsp17ugwj.swift:24:41: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \            while i < j && string[i] == substring[1] {\n                    \
    \                    ^~~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has\
    \ been explicitly marked unavailable here\n    public subscript(i: Int) -> Character\
    \ { get }\n           ^\n"
  stdout: ''
  timestamp: 1659824941
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if\
    \ string == \"\" || substring == \"\" {\n        return 0\n    }\n    var count\
    \ = 0\n    var i = 0\n    var j = string.count\n    var k = substring.count\n\
    \    while i < j {\n        if string[i] == substring[k] {\n            count\
    \ += 1\n            i += k\n            k += k\n        }\n        i += 1\n  \
    \  }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpgni0cqyv.swift:18:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if string[i]\
    \ == substring[k] {\n           ^~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpgni0cqyv.swift:18:25: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if string[i] == substring[k] {\n                        ^~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpgni0cqyv.swift:15:9:\
    \ warning: variable 'j' was never mutated; consider changing to 'let' constant\n\
    \    var j = string.count\n    ~~~ ^\n    let\n"
  stdout: ''
  timestamp: 1659824940
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    let\
    \ count = string.countSubstrings(of: substring)\n    return count ?? 0\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp0wh4vokx.swift:10:24: error: value of type 'String' has no member\
    \ 'countSubstrings'\n    let count = string.countSubstrings(of: substring)\n \
    \               ~~~~~~ ^~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824941
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if\
    \ string == \"\" {\n        return 0\n    }\n    if substring == \"\" {\n    \
    \    return count(string)\n    }\n    var count = 0\n    var i = 0\n    var j\
    \ = string.count\n    while i < j {\n        if string[i] == substring[0] {\n\
    \            count += 1\n            i += count(substring)\n        } else {\n\
    \            i += 1\n        }\n    }\n    return count\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\n\
    assert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string:\
    \ \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john\
    \ doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmphm35p0q2.swift:14:16: error: use of local variable 'count' before\
    \ its declaration\n        return count(string)\n               ^\n/tmp/tmphm35p0q2.swift:16:9:\
    \ note: 'count' declared here\n    var count = 0\n        ^\n/tmp/tmphm35p0q2.swift:20:12:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if string[i] == substring[0] {\n      \
    \     ^~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly\
    \ marked unavailable here\n    public subscript(i: Int) -> Character { get }\n\
    \           ^\n/tmp/tmphm35p0q2.swift:20:25: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n        if\
    \ string[i] == substring[0] {\n                        ^~~~~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmphm35p0q2.swift:22:18:\
    \ error: cannot call value of non-function type 'Int'\n            i += count(substring)\n\
    \                 ^\n"
  stdout: ''
  timestamp: 1659824939
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    let\
    \ start = string.startIndex.advancedBy(substring.startIndex.distanceTo(string.startIndex))\n\
    \    let end = string.endIndex.advancedBy(substring.endIndex.distanceTo(string.endIndex))\n\
    \    let count = string.distance(from: start, to: end)\n    return count\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpo4csj3ay.swift:10:35: error: value of type 'String.Index' has no\
    \ member 'advancedBy'\n    let start = string.startIndex.advancedBy(substring.startIndex.distanceTo(string.startIndex))\n\
    \                ~~~~~~~~~~~~~~~~~ ^~~~~~~~~~\n/tmp/tmpo4csj3ay.swift:10:67: error:\
    \ value of type 'String.Index' has no member 'distanceTo'\n    let start = string.startIndex.advancedBy(substring.startIndex.distanceTo(string.startIndex))\n\
    \                                             ~~~~~~~~~~~~~~~~~~~~ ^~~~~~~~~~\n\
    /tmp/tmpo4csj3ay.swift:11:31: error: value of type 'String.Index' has no member\
    \ 'advancedBy'\n    let end = string.endIndex.advancedBy(substring.endIndex.distanceTo(string.endIndex))\n\
    \              ~~~~~~~~~~~~~~~ ^~~~~~~~~~\n/tmp/tmpo4csj3ay.swift:11:61: error:\
    \ value of type 'String.Index' has no member 'distanceTo'\n    let end = string.endIndex.advancedBy(substring.endIndex.distanceTo(string.endIndex))\n\
    \                                         ~~~~~~~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824941
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    let\
    \ start = string.startIndex.advancedBy(substring.startIndex)\n    let end = string.endIndex.advancedBy(substring.endIndex)\n\
    \    let range = start..<end\n    return string.distance(from: range, to: end)\
    \ + 1\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp_zyng0ai.swift:10:35: error: value of type 'String.Index' has no\
    \ member 'advancedBy'\n    let start = string.startIndex.advancedBy(substring.startIndex)\n\
    \                ~~~~~~~~~~~~~~~~~ ^~~~~~~~~~\n/tmp/tmp_zyng0ai.swift:11:31: error:\
    \ value of type 'String.Index' has no member 'advancedBy'\n    let end = string.endIndex.advancedBy(substring.endIndex)\n\
    \              ~~~~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824941
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    let\
    \ count = string.countSubstrings(of: substring)\n    return count ?? 0\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp0wh4vokx.swift:10:24: error: value of type 'String' has no member\
    \ 'countSubstrings'\n    let count = string.countSubstrings(of: substring)\n \
    \               ~~~~~~ ^~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824941
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if\
    \ string == \"\" {\n        return 0\n    }\n    if substring == \"\" {\n    \
    \    return countOccurrences(string, \"\")\n    }\n    var count = 0\n    var\
    \ i = 0\n    var j = string.count\n    var k = substring.count\n    while i <\
    \ j {\n        if string[i] == substring[k] {\n            count += 1\n      \
    \      i += k\n            k += 1\n        }\n        if k > substring.count {\n\
    \            break\n        }\n        i += 1\n    }\n    return count\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpz8hzqbch.swift:14:16: error: cannot find 'countOccurrences' in\
    \ scope\n        return countOccurrences(string, \"\")\n               ^~~~~~~~~~~~~~~~\n\
    /tmp/tmpz8hzqbch.swift:21:12: error: 'subscript(_:)' is unavailable: cannot subscript\
    \ String with an Int, use a String.Index instead.\n        if string[i] == substring[k]\
    \ {\n           ^~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly\
    \ marked unavailable here\n    public subscript(i: Int) -> Character { get }\n\
    \           ^\n/tmp/tmpz8hzqbch.swift:21:25: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n        if\
    \ string[i] == substring[k] {\n                        ^~~~~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1659824941
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    let\
    \ count = string.characters.reduce(0) { (result, character) in\n        if character\
    \ == substring {\n            result + 1\n        }\n        return result\n \
    \   }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpmlw2abql.swift:11:22: error: binary operator '==' cannot be applied\
    \ to operands of type 'String.Element' (aka 'Character') and 'String'\n      \
    \  if character == substring {\n           ~~~~~~~~~ ^  ~~~~~~~~~\n/tmp/tmpmlw2abql.swift:11:22:\
    \ note: overloads for '==' exist with these partially matching parameter lists:\
    \ (Character, Character), (String, String)\n        if character == substring\
    \ {\n                     ^\n"
  stdout: ''
  timestamp: 1659824941
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if\
    \ string == \"\" {\n        return 0\n    }\n    if substring == \"\" {\n    \
    \    return count(string)\n    }\n    var count = 0\n    var last = 0\n    for\
    \ i := 0; i < len(string); i++ {\n        if string[i] == substring[0] {\n   \
    \         count++\n            last = i\n        }\n        if string[i] == substring[1]\
    \ {\n            count++\n            last = i\n        }\n        if string[i]\
    \ == substring[2] {\n            count++\n            last = i\n        }\n  \
    \      if string[i] == substring[3] {\n            count++\n            last =\
    \ i\n        }\n        if string[i] == substring[4] {\n            count++\n\
    \            last = i\n        }\n        if string[i] == substring[5] {\n   \
    \         count++\n            last = i\n        }\n        if string[i] == substring[6]\
    \ {\n            count++\n            last = i\n        }\n        if string[i]\
    \ == substring[7] {\n            count++\n            last = i\n        }\n  \
    \      if string[i] == substring[8] {\n            count++\n            last =\
    \ i\n        }\n        if string[i] == substring[9] {\n            count++\n\
    \            last = i\n        }\n        if string[i] == substring[10] {\n  \
    \          count++\n            last = i\n        }\n        if string[i] == substring[11]\
    \ {\n            count++\n            last = i\n        }\n        if string[i]\
    \ == substring[12] {\n            count++\n            last = i\n        }\n \
    \       if string[i] == substring[13] {\n            count++\n            last\
    \ = i\n        }\n        if string[i] == substring[14] {\n            count++\n\
    \            last = i\n        }\n        if string[i] == substring[15] {\n  \
    \          count++\n            last = i\n        }\n        if string[i] == substring[16]\
    \ {\n            count++\n            last = i\n        }\n        if string[i]\
    \ == substring[17] {\n            count++\n            last = i\n        }\n \
    \       if string[i] == substring[18] {\n            count++\n            last\
    \ = i\n        }\n        if string[i] == substring[19] {\n            count++\n\
    \            last = i\n        }\n        if string[i] == substring[20] {\n  \
    \          count++\n            last = i\n        }\n        if string[i] == substring[21]\
    \ {\n            count++\n            last = i\n        }\n        if string[i]\
    \ == substring[22] {\n            count++\n            last = i\n        }\n \
    \       if string[i] == substring[23] {\n            count++\n            last\
    \ = i\n        }\n        if string[i] == substring[24] {\n            count++\n\
    \            last = i\n        }\n        if string[i] == substring[25] {\n  \
    \          count++\n            last = i\n        }\n        if string[i] == substring[26]\
    \ {\n            count++\n            last = i\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp2nc2_tyq.swift:18:12: error: expected type\n    for i := 0; i <\
    \ len(string); i++ {\n           ^\n            <#type#>\n/tmp/tmp2nc2_tyq.swift:18:12:\
    \ error: expected 'in' after for-each pattern\n    for i := 0; i < len(string);\
    \ i++ {\n           ^\n/tmp/tmp2nc2_tyq.swift:18:12: error: expected Sequence\
    \ expression for for-each loop\n    for i := 0; i < len(string); i++ {\n     \
    \      ^\n/tmp/tmp2nc2_tyq.swift:144:67: error: expected '}' at end of brace statement\n\
    assert(how_many_times(string: \"john doe\", substring: \"john\") == 1)\n     \
    \                                                             ^\n/tmp/tmp2nc2_tyq.swift:18:38:\
    \ note: to match this opening '{'\n    for i := 0; i < len(string); i++ {\n  \
    \                                   ^\n/tmp/tmp2nc2_tyq.swift:144:67: error: expected\
    \ '}' at end of brace statement\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)\n                                                          \
    \        ^\n/tmp/tmp2nc2_tyq.swift:9:63: note: to match this opening '{'\nfunc\
    \ how_many_times(string: String, substring: String) -> Int {\n               \
    \                                               ^\n/tmp/tmp2nc2_tyq.swift:14:16:\
    \ error: use of local variable 'count' before its declaration\n        return\
    \ count(string)\n               ^\n/tmp/tmp2nc2_tyq.swift:16:9: note: 'count'\
    \ declared here\n    var count = 0\n        ^\n"
  stdout: ''
  timestamp: 1659824941
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if\
    \ string == \"\" {\n        return 0\n    }\n    if substring == \"\" {\n    \
    \    return countOccurrences(string, \"\")\n    }\n    var count = 0\n    var\
    \ start = 0\n    var end = string.count\n    var found = false\n    while start\
    \ < end {\n        found = string.hasPrefix(substring)\n        if found {\n \
    \           start = string.startIndex\n            end = string.endIndex\n   \
    \         count += countOccurrences(string, substring)\n        }\n        found\
    \ = string.hasSuffix(substring)\n        if found {\n            start = string.endIndex\n\
    \            end = string.startIndex\n            count += countOccurrences(string,\
    \ substring)\n        }\n        start += 1\n        end -= 1\n    }\n    return\
    \ count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp0bja4ty_.swift:14:16: error: cannot find 'countOccurrences' in\
    \ scope\n        return countOccurrences(string, \"\")\n               ^~~~~~~~~~~~~~~~\n\
    /tmp/tmp0bja4ty_.swift:23:28: error: cannot assign value of type 'String.Index'\
    \ to type 'Int'\n            start = string.startIndex\n                    ~~~~~~~^~~~~~~~~~\n\
    /tmp/tmp0bja4ty_.swift:24:26: error: cannot assign value of type 'String.Index'\
    \ to type 'Int'\n            end = string.endIndex\n                  ~~~~~~~^~~~~~~~\n\
    /tmp/tmp0bja4ty_.swift:25:22: error: cannot find 'countOccurrences' in scope\n\
    \            count += countOccurrences(string, substring)\n                  \
    \   ^~~~~~~~~~~~~~~~\n/tmp/tmp0bja4ty_.swift:29:28: error: cannot assign value\
    \ of type 'String.Index' to type 'Int'\n            start = string.endIndex\n\
    \                    ~~~~~~~^~~~~~~~\n/tmp/tmp0bja4ty_.swift:30:26: error: cannot\
    \ assign value of type 'String.Index' to type 'Int'\n            end = string.startIndex\n\
    \                  ~~~~~~~^~~~~~~~~~\n/tmp/tmp0bja4ty_.swift:31:22: error: cannot\
    \ find 'countOccurrences' in scope\n            count += countOccurrences(string,\
    \ substring)\n                     ^~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824941
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if\
    \ string == \"\" {\n        return 0\n    }\n    if substring == \"\" {\n    \
    \    return string.count\n    }\n    var count = 0\n    var last = 0\n    for\
    \ index in string.indices(of: substring) {\n        count = count + 1\n      \
    \  if index != last {\n            count = count - 1\n        }\n        last\
    \ = index\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpet4aeoy8.swift:18:25: error: cannot call value of non-function\
    \ type 'DefaultIndices<String>'\n    for index in string.indices(of: substring)\
    \ {\n                        ^\n"
  stdout: ''
  timestamp: 1659824941
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if\
    \ string == \"\" {\n        return 0\n    }\n    if substring == \"\" {\n    \
    \    return countOccurrences(string, \"\")\n    }\n    var count = 0\n    var\
    \ last = 0\n    for index in 0..<string.characters.count {\n        if string[index]\
    \ == substring[0] {\n            count += countOccurrences(string, substring)\n\
    \            last = index\n        }\n        if string[index] == substring[substring.length\
    \ - 1] {\n            count += countOccurrences(string, substring)\n         \
    \   last = index\n        }\n    }\n    return count + countOccurrences(string,\
    \ substring[last..<string.characters.count])\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpo34_c51z.swift:14:16: error: cannot find 'countOccurrences' in\
    \ scope\n        return countOccurrences(string, \"\")\n               ^~~~~~~~~~~~~~~~\n\
    /tmp/tmpo34_c51z.swift:18:29: error: 'characters' is unavailable: Please use String\
    \ directly\n    for index in 0..<string.characters.count {\n                 \
    \           ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in\
    \ Swift 5.0\n    public var characters: String { get set }\n               ^\n\
    /tmp/tmpo34_c51z.swift:19:12: error: 'subscript(_:)' is unavailable: cannot subscript\
    \ String with an Int, use a String.Index instead.\n        if string[index] ==\
    \ substring[0] {\n           ^~~~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpo34_c51z.swift:19:29: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if string[index] == substring[0] {\n                            ^~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpo34_c51z.swift:20:22:\
    \ error: cannot find 'countOccurrences' in scope\n            count += countOccurrences(string,\
    \ substring)\n                     ^~~~~~~~~~~~~~~~\n/tmp/tmpo34_c51z.swift:23:49:\
    \ error: value of type 'String' has no member 'length'\n        if string[index]\
    \ == substring[substring.length - 1] {\n                                     \
    \ ~~~~~~~~~ ^~~~~~\n/tmp/tmpo34_c51z.swift:24:22: error: cannot find 'countOccurrences'\
    \ in scope\n            count += countOccurrences(string, substring)\n       \
    \              ^~~~~~~~~~~~~~~~\n/tmp/tmpo34_c51z.swift:28:20: error: cannot find\
    \ 'countOccurrences' in scope\n    return count + countOccurrences(string, substring[last..<string.characters.count])\n\
    \                   ^~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824941
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if\
    \ string == \"\" || substring == \"\" {\n        return 0\n    }\n    var count\
    \ = 0\n    var start = 0\n    var end = string.count\n    while start < end {\n\
    \        let index = string.index(start, offsetBy: substring.count)\n        if\
    \ index == nil {\n            break\n        }\n        start = index!\n     \
    \   count += 1\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpig5gmp3b.swift:17:34: error: cannot convert value of type 'Int'\
    \ to expected argument type 'String.Index'\n        let index = string.index(start,\
    \ offsetBy: substring.count)\n                                 ^\n"
  stdout: ''
  timestamp: 1659824940
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if\
    \ string == \"\" {\n        return 0\n    }\n    if substring == \"\" {\n    \
    \    return count(string)\n    }\n    var count = 0\n    var i = 0\n    var j\
    \ = string.count\n    while i < j {\n        if string[i] == substring[0] {\n\
    \            count += 1\n            i += count(substring)\n        } else {\n\
    \            i += 1\n        }\n    }\n    return count\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\n\
    assert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string:\
    \ \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john\
    \ doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmphm35p0q2.swift:14:16: error: use of local variable 'count' before\
    \ its declaration\n        return count(string)\n               ^\n/tmp/tmphm35p0q2.swift:16:9:\
    \ note: 'count' declared here\n    var count = 0\n        ^\n/tmp/tmphm35p0q2.swift:20:12:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if string[i] == substring[0] {\n      \
    \     ^~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly\
    \ marked unavailable here\n    public subscript(i: Int) -> Character { get }\n\
    \           ^\n/tmp/tmphm35p0q2.swift:20:25: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n        if\
    \ string[i] == substring[0] {\n                        ^~~~~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmphm35p0q2.swift:22:18:\
    \ error: cannot call value of non-function type 'Int'\n            i += count(substring)\n\
    \                 ^\n"
  stdout: ''
  timestamp: 1659824939
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if\
    \ string == \"\" {\n        return 0\n    }\n    if substring == \"\" {\n    \
    \    return string.count\n    }\n    var count = 0\n    var i = 0\n    var j =\
    \ string.count\n    while i < j {\n        if string[i] == substring[0] {\n  \
    \          count += 1\n            i += substring.length - 1\n        } else if\
    \ string[i] == substring[1] {\n            count += 1\n            i += substring.length\
    \ - 1\n        } else if string[i] == substring[2] {\n            count += 1\n\
    \            i += substring.length - 1\n        } else if string[i] == substring[3]\
    \ {\n            count += 1\n            i += substring.length - 1\n        }\
    \ else if string[i] == substring[4] {\n            count += 1\n            i +=\
    \ substring.length - 1\n        } else if string[i] == substring[5] {\n      \
    \      count += 1\n            i += substring.length - 1\n        } else if string[i]\
    \ == substring[6] {\n            count += 1\n            i += substring.length\
    \ - 1\n        } else if string[i] == substring[7] {\n            count += 1\n\
    \            i += substring.length - 1\n        } else if string[i] == substring[8]\
    \ {\n            count += 1\n            i += substring.length - 1\n        }\
    \ else if string[i] == substring[9] {\n            count += 1\n            i +=\
    \ substring.length - 1\n        } else if string[i] == substring[10] {\n     \
    \       count += 1\n            i += substring.length - 1\n        } else if string[i]\
    \ == substring[11] {\n            count += 1\n            i += substring.length\
    \ - 1\n        } else if string[i] == substring[12] {\n            count += 1\n\
    \            i += substring.length - 1\n        } else if string[i] == substring[13]\
    \ {\n            count += 1\n            i += substring.length - 1\n        }\
    \ else if string[i] == substring[14] {\n            count += 1\n            i\
    \ += substring.length - 1\n        } else if string[i] == substring[15] {\n  \
    \          count += 1\n            i += substring.length - 1\n        } else if\
    \ string[i] == substring[16] {\n            count += 1\n            i += substring.length\
    \ - 1\n        } else if string[i] == substring[17] {\n            count += 1\n\
    \            i += substring.length - 1\n        } else if string[i] == substring[18]\
    \ {\n            count += 1\n            i += substring.length - 1\n        }\
    \ else if string[i] == substring[19] {\n            count += 1\n            i\
    \ += substring.length - 1\n        } else if string[i] == substring[20] {\n  \
    \          count += 1\n            i += substring.length - 1\n        } else if\
    \ string[i] == substring[21] {\n            count += 1\n            i += substring.length\
    \ - 1\n        } else if string[i] == substring[22] {\n            count += 1\n\
    \            i += substring.length - 1\n        } else if string[i] == substring[23]\
    \ {\n            count += 1\n            i += substring.length - 1\n        }\
    \ else if string[i] == substring[24] {\n            count += 1\n            i\
    \ += substring.length - 1\n        } else if string[i] == substring[25] {\n  \
    \          count += 1\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpkxyyvbd9.swift:115:67: error: expected '}' at end of brace statement\n\
    assert(how_many_times(string: \"john doe\", substring: \"john\") == 1)\n     \
    \                                                             ^\n/tmp/tmpkxyyvbd9.swift:19:17:\
    \ note: to match this opening '{'\n    while i < j {\n                ^\n/tmp/tmpkxyyvbd9.swift:115:67:\
    \ error: expected '}' at end of brace statement\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)\n                                 \
    \                                 ^\n/tmp/tmpkxyyvbd9.swift:9:63: note: to match\
    \ this opening '{'\nfunc how_many_times(string: String, substring: String) ->\
    \ Int {\n                                                              ^\n/tmp/tmpkxyyvbd9.swift:20:12:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if string[i] == substring[0] {\n      \
    \     ^~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly\
    \ marked unavailable here\n    public subscript(i: Int) -> Character { get }\n\
    \           ^\n/tmp/tmpkxyyvbd9.swift:20:25: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n        if\
    \ string[i] == substring[0] {\n                        ^~~~~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpkxyyvbd9.swift:22:28:\
    \ error: value of type 'String' has no member 'length'\n            i += substring.length\
    \ - 1\n                 ~~~~~~~~~ ^~~~~~\n/tmp/tmpkxyyvbd9.swift:23:19: error:\
    \ 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index\
    \ instead.\n        } else if string[i] == substring[1] {\n                  ^~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpkxyyvbd9.swift:23:32:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index i"
  stdout: ''
  timestamp: 1659824940
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if\
    \ string == \"\" {\n        return 0\n    }\n    if substring == \"\" {\n    \
    \    return count(string)\n    }\n    var count = 0\n    var i = 0\n    var j\
    \ = string.characters.count\n    while i < j {\n        if string[i] == substring[0]\
    \ {\n            count += 1\n            i += count(substring)\n        } else\
    \ {\n            i += 1\n        }\n    }\n    return count\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\n\
    assert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string:\
    \ \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john\
    \ doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpan2_o30_.swift:14:16: error: use of local variable 'count' before\
    \ its declaration\n        return count(string)\n               ^\n/tmp/tmpan2_o30_.swift:16:9:\
    \ note: 'count' declared here\n    var count = 0\n        ^\n/tmp/tmpan2_o30_.swift:18:20:\
    \ error: 'characters' is unavailable: Please use String directly\n    var j =\
    \ string.characters.count\n                   ^~~~~~~~~~\nSwift.String:5:16: note:\
    \ 'characters' was obsoleted in Swift 5.0\n    public var characters: String {\
    \ get set }\n               ^\n/tmp/tmpan2_o30_.swift:20:12: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if string[i] == substring[0] {\n           ^~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpan2_o30_.swift:20:25:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if string[i] == substring[0] {\n      \
    \                  ^~~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has\
    \ been explicitly marked unavailable here\n    public subscript(i: Int) -> Character\
    \ { get }\n           ^\n/tmp/tmpan2_o30_.swift:22:18: error: cannot call value\
    \ of non-function type 'Int'\n            i += count(substring)\n            \
    \     ^\n"
  stdout: ''
  timestamp: 1659824940
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if\
    \ string == \"\" {\n        return 0\n    }\n    if substring == \"\" {\n    \
    \    return count(string)\n    }\n    var count = 0\n    var start = 0\n    var\
    \ end = count(string)\n    while start < end {\n        start = string.index(substring,\
    \ start) + 1\n        end = string.index(substring, end) + 1\n        count +=\
    \ 1\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp8ibbbtc3.swift:14:16: error: use of local variable 'count' before\
    \ its declaration\n        return count(string)\n               ^\n/tmp/tmp8ibbbtc3.swift:16:9:\
    \ note: 'count' declared here\n    var count = 0\n        ^\n/tmp/tmp8ibbbtc3.swift:18:15:\
    \ error: cannot call value of non-function type 'Int'\n    var end = count(string)\n\
    \              ^\n/tmp/tmp8ibbbtc3.swift:20:24: error: no exact matches in call\
    \ to instance method 'index'\n        start = string.index(substring, start) +\
    \ 1\n                       ^\n/tmp/tmp8ibbbtc3.swift:20:24: note: candidate has\
    \ partially matching parameter list (String.Index, offsetBy: Int)\n        start\
    \ = string.index(substring, start) + 1\n                       ^\n/tmp/tmp8ibbbtc3.swift:20:24:\
    \ note: candidate has partially matching parameter list (String.Index, offsetBy:\
    \ Int)\n        start = string.index(substring, start) + 1\n                 \
    \      ^\n/tmp/tmp8ibbbtc3.swift:20:24: note: candidate has partially matching\
    \ parameter list (String.Index, offsetBy: Int)\n        start = string.index(substring,\
    \ start) + 1\n                       ^\n/tmp/tmp8ibbbtc3.swift:20:24: error: cannot\
    \ convert value of type 'String.Index' to expected argument type 'Int'\n     \
    \   start = string.index(substring, start) + 1\n                       ^\n/tmp/tmp8ibbbtc3.swift:21:22:\
    \ error: no exact matches in call to instance method 'index'\n        end = string.index(substring,\
    \ end) + 1\n                     ^\n/tmp/tmp8ibbbtc3.swift:21:22: note: found\
    \ candidate with type '(String.Index, Int) -> String.Index'\n        end = string.index(substring,\
    \ end) + 1\n                     ^\n/tmp/tmp8ibbbtc3.swift:21:22: error: cannot\
    \ convert value of type 'String.Index' to expected argument type 'Int'\n     \
    \   end = string.index(substring, end) + 1\n                     ^\n"
  stdout: ''
  timestamp: 1659824939
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if\
    \ string == \"\" {\n        return 0\n    }\n    if substring == \"\" {\n    \
    \    return string.count\n    }\n    var count = 0\n    var startIndex = 0\n \
    \   var endIndex = 0\n    while startIndex < string.count {\n        endIndex\
    \ = string.index(substring, startIndex)\n        if endIndex == startIndex {\n\
    \            count += 1\n        } else {\n            count += endIndex - startIndex\n\
    \        }\n        startIndex = endIndex + 1\n    }\n    return count\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpp6hoy8b3.swift:20:27: error: no exact matches in call to instance\
    \ method 'index'\n        endIndex = string.index(substring, startIndex)\n   \
    \                       ^\n/tmp/tmpp6hoy8b3.swift:20:27: note: found candidate\
    \ with type '(String.Index, Int) -> String.Index'\n        endIndex = string.index(substring,\
    \ startIndex)\n                          ^\n/tmp/tmpp6hoy8b3.swift:20:27: error:\
    \ cannot assign value of type 'String.Index' to type 'Int'\n        endIndex =\
    \ string.index(substring, startIndex)\n                   ~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824941
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if\
    \ string == \"\" {\n        return 0\n    }\n    if substring == \"\" {\n    \
    \    return 1\n    }\n    var count = 0\n    var i = 0\n    var j = string.count\n\
    \    var k = substring.count\n    while i < j {\n        if string[i] == substring[0]\
    \ {\n            count = count + 1\n            i = i + 1\n            while i\
    \ < j && string[i] == substring[1] {\n                count = count + 1\n    \
    \            i = i + 1\n            }\n        } else {\n            i = i + 1\n\
    \        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp4em6md1z.swift:21:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if string[i]\
    \ == substring[0] {\n           ^~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmp4em6md1z.swift:21:25: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if string[i] == substring[0] {\n                        ^~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmp4em6md1z.swift:24:28:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n            while i < j && string[i] == substring[1]\
    \ {\n                           ^~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmp4em6md1z.swift:24:41: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \            while i < j && string[i] == substring[1] {\n                    \
    \                    ^~~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has\
    \ been explicitly marked unavailable here\n    public subscript(i: Int) -> Character\
    \ { get }\n           ^\n/tmp/tmp4em6md1z.swift:18:9: warning: variable 'j' was\
    \ never mutated; consider changing to 'let' constant\n    var j = string.count\n\
    \    ~~~ ^\n    let\n/tmp/tmp4em6md1z.swift:19:9: warning: initialization of variable\
    \ 'k' was never used; consider replacing with assignment to '_' or removing it\n\
    \    var k = substring.count\n    ~~~~^\n    _\n"
  stdout: ''
  timestamp: 1659824941
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if\
    \ string == \"\" {\n        return 0\n    }\n    if substring == \"\" {\n    \
    \    return count(string)\n    }\n    var count = 0\n    var i = 0\n    var j\
    \ = string.count\n    while i < j {\n        if string[i] == substring[0] {\n\
    \            count += 1\n            i += substring.length - 1\n        } else\
    \ if string[i] == substring[1] {\n            count += 1\n            i += substring.length\
    \ - 1\n        } else if string[i] == substring[2] {\n            count += 1\n\
    \            i += substring.length - 1\n        } else if string[i] == substring[3]\
    \ {\n            count += 1\n            i += substring.length - 1\n        }\
    \ else if string[i] == substring[4] {\n            count += 1\n            i +=\
    \ substring.length - 1\n        } else if string[i] == substring[5] {\n      \
    \      count += 1\n            i += substring.length - 1\n        } else if string[i]\
    \ == substring[6] {\n            count += 1\n            i += substring.length\
    \ - 1\n        } else if string[i] == substring[7] {\n            count += 1\n\
    \            i += substring.length - 1\n        } else if string[i] == substring[8]\
    \ {\n            count += 1\n            i += substring.length - 1\n        }\
    \ else if string[i] == substring[9] {\n            count += 1\n            i +=\
    \ substring.length - 1\n        } else if string[i] == substring[10] {\n     \
    \       count += 1\n            i += substring.length - 1\n        } else if string[i]\
    \ == substring[11] {\n            count += 1\n            i += substring.length\
    \ - 1\n        } else if string[i] == substring[12] {\n            count += 1\n\
    \            i += substring.length - 1\n        } else if string[i] == substring[13]\
    \ {\n            count += 1\n            i += substring.length - 1\n        }\
    \ else if string[i] == substring[14] {\n            count += 1\n            i\
    \ += substring.length - 1\n        } else if string[i] == substring[15] {\n  \
    \          count += 1\n            i += substring.length - 1\n        } else if\
    \ string[i] == substring[16] {\n            count += 1\n            i += substring.length\
    \ - 1\n        } else if string[i] == substring[17] {\n            count += 1\n\
    \            i += substring.length - 1\n        } else if string[i] == substring[18]\
    \ {\n            count += 1\n            i += substring.length - 1\n        }\
    \ else if string[i] == substring[19] {\n            count += 1\n            i\
    \ += substring.length - 1\n        } else if string[i] == substring[20] {\n  \
    \          count += 1\n            i += substring.length - 1\n        } else if\
    \ string[i] == substring[21] {\n            count += 1\n            i += substring.length\
    \ - 1\n        } else if string[i] == substring[22] {\n            count += 1\n\
    \            i += substring.length - 1\n        } else if string[i] == substring[23]\
    \ {\n            count += 1\n            i += substring.length - 1\n        }\
    \ else if string[i] == substring[24] {\n            count += 1\n            i\
    \ += substring.length - 1\n        } else if string[i] == substring[25] {\n  \
    \          count += 1\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpxib_anyz.swift:115:67: error: expected '}' at end of brace statement\n\
    assert(how_many_times(string: \"john doe\", substring: \"john\") == 1)\n     \
    \                                                             ^\n/tmp/tmpxib_anyz.swift:19:17:\
    \ note: to match this opening '{'\n    while i < j {\n                ^\n/tmp/tmpxib_anyz.swift:115:67:\
    \ error: expected '}' at end of brace statement\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)\n                                 \
    \                                 ^\n/tmp/tmpxib_anyz.swift:9:63: note: to match\
    \ this opening '{'\nfunc how_many_times(string: String, substring: String) ->\
    \ Int {\n                                                              ^\n/tmp/tmpxib_anyz.swift:14:16:\
    \ error: use of local variable 'count' before its declaration\n        return\
    \ count(string)\n               ^\n/tmp/tmpxib_anyz.swift:16:9: note: 'count'\
    \ declared here\n    var count = 0\n        ^\n/tmp/tmpxib_anyz.swift:20:12: error:\
    \ 'subscript(_:)' is unavailable: cannot subscript String with an Int, use a String.Index\
    \ instead.\n        if string[i] == substring[0] {\n           ^~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpxib_anyz.swift:20:25:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if string[i] == substring[0] {\n      \
    \                  ^~~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has\
    \ been explicitly marked unavailable here\n    public subscript(i: Int) -> Character\
    \ { get }\n           ^\n/tmp/tmpxib_anyz.swift:22:28: error: value of type 'String'\
    \ has no member 'length'\n            i += substring.length - 1\n            \
    \     ~~~~~~~~~ ^~~~~~\n/tmp/tmpxib_anyz.swift:23:19: error: 'subscript(_:)' is\
    \ unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        } else if string[i] == substring[1] {\n                  ^~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been exp"
  stdout: ''
  timestamp: 1659824941
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if\
    \ string == \"\" {\n        return 0\n    }\n    if substring == \"\" {\n    \
    \    return count(string)\n    }\n    var count = 0\n    var i = 0\n    var j\
    \ = string.count\n    while i < j {\n        if string[i] == substring[0] {\n\
    \            count += 1\n            i += count(substring)\n        } else {\n\
    \            i += 1\n        }\n    }\n    return count\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\n\
    assert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string:\
    \ \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john\
    \ doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmphm35p0q2.swift:14:16: error: use of local variable 'count' before\
    \ its declaration\n        return count(string)\n               ^\n/tmp/tmphm35p0q2.swift:16:9:\
    \ note: 'count' declared here\n    var count = 0\n        ^\n/tmp/tmphm35p0q2.swift:20:12:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if string[i] == substring[0] {\n      \
    \     ^~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly\
    \ marked unavailable here\n    public subscript(i: Int) -> Character { get }\n\
    \           ^\n/tmp/tmphm35p0q2.swift:20:25: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n        if\
    \ string[i] == substring[0] {\n                        ^~~~~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmphm35p0q2.swift:22:18:\
    \ error: cannot call value of non-function type 'Int'\n            i += count(substring)\n\
    \                 ^\n"
  stdout: ''
  timestamp: 1659824939
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if\
    \ string == \"\" {\n        return 0\n    }\n    if substring == \"\" {\n    \
    \    return string.count\n    }\n    var count = 0\n    var i = 0\n    var j =\
    \ string.count\n    while i < j {\n        if string[i] == substring[0] {\n  \
    \          count += 1\n            i += substring.length - 1\n        } else {\n\
    \            i += 1\n        }\n    }\n    return count\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\n\
    assert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string:\
    \ \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john\
    \ doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpagu0bbfx.swift:20:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if string[i]\
    \ == substring[0] {\n           ^~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpagu0bbfx.swift:20:25: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if string[i] == substring[0] {\n                        ^~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpagu0bbfx.swift:22:28:\
    \ error: value of type 'String' has no member 'length'\n            i += substring.length\
    \ - 1\n                 ~~~~~~~~~ ^~~~~~\n"
  stdout: ''
  timestamp: 1659824941
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if\
    \ string == \"\" {\n        return 0\n    }\n    if substring == \"\" {\n    \
    \    return count(string)\n    }\n    var count = 0\n    var i = 0\n    var j\
    \ = string.startIndex\n    while i < string.endIndex && j < string.endIndex {\n\
    \        if string[j] == substring[0] {\n            count += 1\n            j\
    \ += 1\n            if j == string.endIndex {\n                j += 1\n      \
    \          i += 1\n            }\n        } else {\n            j += 1\n     \
    \   }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpq438ifq8.swift:14:16: error: use of local variable 'count' before\
    \ its declaration\n        return count(string)\n               ^\n/tmp/tmpq438ifq8.swift:16:9:\
    \ note: 'count' declared here\n    var count = 0\n        ^\n/tmp/tmpq438ifq8.swift:19:13:\
    \ error: operator function '<' requires that 'String.Index' conform to 'BinaryInteger'\n\
    \    while i < string.endIndex && j < string.endIndex {\n            ^\nSwift.BinaryInteger:4:24:\
    \ note: where 'Other' = 'String.Index'\n    public static func < <Other>(lhs:\
    \ Self, rhs: Other) -> Bool where Other : BinaryInteger\n                    \
    \   ^\n/tmp/tmpq438ifq8.swift:20:25: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if string[j]\
    \ == substring[0] {\n                        ^~~~~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpq438ifq8.swift:22:15:\
    \ error: binary operator '+=' cannot be applied to operands of type 'String.Index'\
    \ and 'Int'\n            j += 1\n            ~ ^  ~\n/tmp/tmpq438ifq8.swift:24:19:\
    \ error: binary operator '+=' cannot be applied to operands of type 'String.Index'\
    \ and 'Int'\n                j += 1\n                ~ ^  ~\n/tmp/tmpq438ifq8.swift:28:15:\
    \ error: binary operator '+=' cannot be applied to operands of type 'String.Index'\
    \ and 'Int'\n            j += 1\n            ~ ^  ~\n"
  stdout: ''
  timestamp: 1659824941
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if\
    \ string == \"\" {\n        return 0\n    }\n    if substring == \"\" {\n    \
    \    return countOccurrences(string, \"\")\n    }\n    var count = 0\n    var\
    \ last = 0\n    for index in 0..<string.characters.count {\n        if string.characters[index]\
    \ == substring.characters[0] {\n            count += countOccurrences(string,\
    \ string.characters[index])\n            last = index\n        }\n    }\n    if\
    \ last < string.characters.count {\n        count += countOccurrences(string,\
    \ string.characters[last])\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpsecffq23.swift:14:16: error: cannot find 'countOccurrences' in\
    \ scope\n        return countOccurrences(string, \"\")\n               ^~~~~~~~~~~~~~~~\n\
    /tmp/tmpsecffq23.swift:18:29: error: 'characters' is unavailable: Please use String\
    \ directly\n    for index in 0..<string.characters.count {\n                 \
    \           ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in\
    \ Swift 5.0\n    public var characters: String { get set }\n               ^\n\
    /tmp/tmpsecffq23.swift:19:12: error: 'subscript(_:)' is unavailable: cannot subscript\
    \ String with an Int, use a String.Index instead.\n        if string.characters[index]\
    \ == substring.characters[0] {\n           ^~~~~~~~~~~~~~~~~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpsecffq23.swift:19:19:\
    \ error: 'characters' is unavailable: Please use String directly\n        if string.characters[index]\
    \ == substring.characters[0] {\n                  ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmpsecffq23.swift:19:40: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if string.characters[index] == substring.characters[0] {\n          \
    \                             ^~~~~~~~~~~~~~~~~~~~~~~\nSwift.String:3:12: note:\
    \ 'subscript(_:)' has been explicitly marked unavailable here\n    public subscript(i:\
    \ Int) -> Character { get }\n           ^\n/tmp/tmpsecffq23.swift:19:50: error:\
    \ 'characters' is unavailable: Please use String directly\n        if string.characters[index]\
    \ == substring.characters[0] {\n                                             \
    \    ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n/tmp/tmpsecffq23.swift:20:22:\
    \ error: cannot find 'countOccurrences' in scope\n            count += countOccurrences(string,\
    \ string.char"
  stdout: ''
  timestamp: 1659824941
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if\
    \ string == \"\" {\n        return 0\n    }\n    if substring == \"\" {\n    \
    \    return 1\n    }\n    var count = 0\n    var startIndex = 0\n    var endIndex\
    \ = 0\n    while startIndex < string.count {\n        endIndex = string.index(substring,\
    \ startIndex) ?? string.endIndex\n        if endIndex == startIndex {\n      \
    \      count += 1\n        }\n        startIndex = endIndex + 1\n    }\n    return\
    \ count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmppk7xaf5k.swift:20:27: error: no exact matches in call to instance\
    \ method 'index'\n        endIndex = string.index(substring, startIndex) ?? string.endIndex\n\
    \                          ^\n/tmp/tmppk7xaf5k.swift:20:27: note: found candidate\
    \ with type '(String.Index, Int) -> String.Index'\n        endIndex = string.index(substring,\
    \ startIndex) ?? string.endIndex\n                          ^\n/tmp/tmppk7xaf5k.swift:20:56:\
    \ error: cannot assign value of type 'String.Index' to type 'Int'\n        endIndex\
    \ = string.index(substring, startIndex) ?? string.endIndex\n                 \
    \  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824941
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if\
    \ string == \"\" {\n        return 0\n    }\n    if substring == \"\" {\n    \
    \    return count(string)\n    }\n    var count = 0\n    var start = 0\n    var\
    \ end = count(string)\n    while start < end {\n        start = find_first_index(string,\
    \ substring, start)\n        end = find_last_index(string, substring, end)\n \
    \       if start == end {\n            count += 1\n        }\n    }\n    return\
    \ count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp69ykn_yg.swift:14:16: error: use of local variable 'count' before\
    \ its declaration\n        return count(string)\n               ^\n/tmp/tmp69ykn_yg.swift:16:9:\
    \ note: 'count' declared here\n    var count = 0\n        ^\n/tmp/tmp69ykn_yg.swift:18:15:\
    \ error: cannot call value of non-function type 'Int'\n    var end = count(string)\n\
    \              ^\n/tmp/tmp69ykn_yg.swift:20:17: error: cannot find 'find_first_index'\
    \ in scope\n        start = find_first_index(string, substring, start)\n     \
    \           ^~~~~~~~~~~~~~~~\n/tmp/tmp69ykn_yg.swift:21:15: error: cannot find\
    \ 'find_last_index' in scope\n        end = find_last_index(string, substring,\
    \ end)\n              ^~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824941
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    return\
    \ count_overlapping_cases(string, substring)\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp__9p21xq.swift:10:12: error: cannot find 'count_overlapping_cases'\
    \ in scope\n    return count_overlapping_cases(string, substring)\n          \
    \ ^~~~~~~~~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824940
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    var\
    \ count = 0\n    var i = 0\n    var j = 0\n    while i < string.count && j < substring.count\
    \ {\n        if string[i] == substring[j] {\n            count += 1\n        \
    \    i += 1\n            j += 1\n        } else if string[i] < substring[j] {\n\
    \            i += 1\n        } else {\n            j += 1\n        }\n    }\n\
    \    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpkt9q3yxn.swift:14:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if string[i]\
    \ == substring[j] {\n           ^~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpkt9q3yxn.swift:14:25: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if string[i] == substring[j] {\n                        ^~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpkt9q3yxn.swift:18:19:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        } else if string[i] < substring[j] {\n\
    \                  ^~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has been\
    \ explicitly marked unavailable here\n    public subscript(i: Int) -> Character\
    \ { get }\n           ^\n/tmp/tmpkt9q3yxn.swift:18:31: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        } else if string[i] < substring[j] {\n                              ^~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1659824941
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    var\
    \ count = 0\n    for char in string {\n        if char == substring {\n      \
    \      count += 1\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpysb8gdg4.swift:12:17: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        if char == substring {\n\
    \           ~~~~ ^  ~~~~~~~~~\n/tmp/tmpysb8gdg4.swift:12:17: note: overloads for\
    \ '==' exist with these partially matching parameter lists: (Character, Character),\
    \ (String, String)\n        if char == substring {\n                ^\n"
  stdout: ''
  timestamp: 1659824941
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    var\
    \ count = 0\n    for index in 0..<string.characters.count {\n        if string.substring(index,\
    \ string.characters.count) == substring {\n            count += 1\n        }\n\
    \    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpja6rt6dx.swift:11:29: error: 'characters' is unavailable: Please\
    \ use String directly\n    for index in 0..<string.characters.count {\n      \
    \                      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpja6rt6dx.swift:12:19: error: value of type 'String' has no member\
    \ 'substring'\n        if string.substring(index, string.characters.count) ==\
    \ substring {\n           ~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824940
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if\
    \ string == \"\" {\n        return 0\n    }\n    if substring == \"\" {\n    \
    \    return countOccurrences(string, \"\")\n    }\n    return countOccurrences(string,\
    \ substring)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpwm9imvn4.swift:14:16: error: cannot find 'countOccurrences' in\
    \ scope\n        return countOccurrences(string, \"\")\n               ^~~~~~~~~~~~~~~~\n\
    /tmp/tmpwm9imvn4.swift:16:12: error: cannot find 'countOccurrences' in scope\n\
    \    return countOccurrences(string, substring)\n           ^~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824940
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if\
    \ string == \"\" {\n        return 0\n    }\n    if substring == \"\" {\n    \
    \    return countOccurrences(string, \"\")\n    }\n    var count = 0\n    var\
    \ start = 0\n    var end = string.count\n    var substring_start = string.startIndex\n\
    \    var substring_end = string.endIndex\n    while start < end {\n        if\
    \ string.hasPrefix(substring) {\n            count = countOccurrences(string,\
    \ substring)\n            start = substring_start\n            end = substring_end\n\
    \            substring_start = string.startIndex\n            substring_end =\
    \ string.endIndex\n            continue\n        }\n        if string.hasSuffix(substring)\
    \ {\n            count = countOccurrences(string, substring)\n            start\
    \ = substring_start\n            end = substring_end\n            substring_start\
    \ = string.startIndex\n            substring_end = string.endIndex\n         \
    \   continue\n        }\n        if string.hasPrefix(substring) {\n          \
    \  count = countOccurrences(string, substring)\n            start = substring_start\n\
    \            end = substring_end\n            substring_start = string.startIndex\n\
    \            substring_end = string.endIndex\n            continue\n        }\n\
    \        if string.hasSuffix(substring) {\n            count = countOccurrences(string,\
    \ substring)\n            start = substring_start\n            end = substring_end\n\
    \            substring_start = string.startIndex\n            substring_end =\
    \ string.endIndex\n            continue\n        }\n        if string.hasPrefix(substring)\
    \ {\n            count = countOccurrences(string, substring)\n            start\
    \ = substring_start\n            end = substring_end\n            substring_start\
    \ = string.startIndex\n            substring_end = string.endIndex\n         \
    \   continue\n        }\n        if string.hasSuffix(substring) {\n          \
    \  count = countOccurrences(string, substring)\n            start = substring_start\n\
    \            end = substring_end\n            substring_start = string.startIndex\n\
    \            substring_end = string.endIndex\n            continue\n        }\n\
    \        if string.hasPrefix(substring) {\n            count = countOccurrences(string,\
    \ substring)\n            start = substring_start\n            end = substring_end\n\
    \            substring_start = string.startIndex\n            substring_end =\
    \ string.endIndex\n            continue\n        }\n        if string.hasSuffix(substring)\
    \ {\n            count = countOccurrences(string, substring)\n            start\
    \ = substring_start\n            end = substring_end\n            substring_start\
    \ = string.startIndex\n            substring_end = string.endIndex\n         \
    \   continue\n        }\n        if string.hasPrefix(substring) {\n          \
    \  count = countOccurrences(string, substring)\n            start = substring_start\n\
    \            end = substring_end\n            substring_start = string.startIndex\n\
    \            substring_end = string.endIndex\n            continue\n        }\n\
    \        if string.hasSuffix(substring) {\n            count = countOccurrences(string,\
    \ substring)\n            \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp4vjgqd8m.swift:115:67: error: expected '}' at end of brace statement\n\
    assert(how_many_times(string: \"john doe\", substring: \"john\") == 1)\n     \
    \                                                             ^\n/tmp/tmp4vjgqd8m.swift:21:23:\
    \ note: to match this opening '{'\n    while start < end {\n                 \
    \     ^\n/tmp/tmp4vjgqd8m.swift:115:67: error: expected '}' at end of brace statement\n\
    assert(how_many_times(string: \"john doe\", substring: \"john\") == 1)\n     \
    \                                                             ^\n/tmp/tmp4vjgqd8m.swift:9:63:\
    \ note: to match this opening '{'\nfunc how_many_times(string: String, substring:\
    \ String) -> Int {\n                                                         \
    \     ^\n/tmp/tmp4vjgqd8m.swift:14:16: error: cannot find 'countOccurrences' in\
    \ scope\n        return countOccurrences(string, \"\")\n               ^~~~~~~~~~~~~~~~\n\
    /tmp/tmp4vjgqd8m.swift:23:21: error: cannot find 'countOccurrences' in scope\n\
    \            count = countOccurrences(string, substring)\n                   \
    \ ^~~~~~~~~~~~~~~~\n/tmp/tmp4vjgqd8m.swift:24:21: error: cannot assign value of\
    \ type 'String.Index' to type 'Int'\n            start = substring_start\n   \
    \                 ^~~~~~~~~~~~~~~\n/tmp/tmp4vjgqd8m.swift:25:19: error: cannot\
    \ assign value of type 'String.Index' to type 'Int'\n            end = substring_end\n\
    \                  ^~~~~~~~~~~~~\n/tmp/tmp4vjgqd8m.swift:31:21: error: cannot\
    \ find 'countOccurrences' in scope\n            count = countOccurrences(string,\
    \ substring)\n                    ^~~~~~~~~~~~~~~~\n/tmp/tmp4vjgqd8m.swift:32:21:\
    \ error: cannot assign value of type 'String.Index' to type 'Int'\n          \
    \  start = substring_start\n                    ^~~~~~~~~~~~~~~\n/tmp/tmp4vjgqd8m.swift:33:19:\
    \ error: cannot assign value of type 'String.Index' to type 'Int'\n          \
    \  end = substring_end\n                  ^~~~~~~~~~~~~\n/tmp/tmp4vjgqd8m.swift:39:21:\
    \ error: cannot find 'countOccurrences' in scope\n            count = countOccurrences(string,\
    \ substring)\n                    ^~~~~~~~~~~~~~~~\n/tmp/tmp4vjgqd"
  stdout: ''
  timestamp: 1659824941
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if\
    \ string == \"\" || substring == \"\" {\n        return 0\n    }\n    var count\
    \ = 0\n    var i = 0\n    var j = string.count\n    var k = substring.count\n\
    \    while i < j {\n        if string[i] == substring[k] {\n            count\
    \ += 1\n            i += k\n            k -= 1\n        }\n        i += 1\n  \
    \  }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpqah73p9z.swift:18:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if string[i]\
    \ == substring[k] {\n           ^~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpqah73p9z.swift:18:25: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if string[i] == substring[k] {\n                        ^~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpqah73p9z.swift:15:9:\
    \ warning: variable 'j' was never mutated; consider changing to 'let' constant\n\
    \    var j = string.count\n    ~~~ ^\n    let\n"
  stdout: ''
  timestamp: 1659824940
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if\
    \ string == \"\" || substring == \"\" {\n        return 0\n    }\n    var count\
    \ = 0\n    var start = 0\n    var end = string.count\n    var substring_start\
    \ = string.startIndex\n    var substring_end = string.endIndex\n    while start\
    \ < end {\n        if string.substring(start, start + substring.length) == substring\
    \ {\n            count += 1\n            start += substring.length\n        }\
    \ else {\n            if start < substring_end {\n                start = substring_start\n\
    \                substring_start = string.startIndex\n            } else {\n \
    \               start = end\n                substring_end = string.endIndex\n\
    \            }\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpk6x02fnn.swift:19:19: error: value of type 'String' has no member\
    \ 'substring'\n        if string.substring(start, start + substring.length) ==\
    \ substring {\n           ~~~~~~ ^~~~~~~~~\n/tmp/tmpk6x02fnn.swift:19:54: error:\
    \ value of type 'String' has no member 'length'\n        if string.substring(start,\
    \ start + substring.length) == substring {\n                                 \
    \          ~~~~~~~~~ ^~~~~~\n/tmp/tmpk6x02fnn.swift:21:32: error: value of type\
    \ 'String' has no member 'length'\n            start += substring.length\n   \
    \                  ~~~~~~~~~ ^~~~~~\n/tmp/tmpk6x02fnn.swift:23:22: error: operator\
    \ function '<' requires that 'String.Index' conform to 'BinaryInteger'\n     \
    \       if start < substring_end {\n                     ^\nSwift.BinaryInteger:4:24:\
    \ note: where 'Other' = 'String.Index'\n    public static func < <Other>(lhs:\
    \ Self, rhs: Other) -> Bool where Other : BinaryInteger\n                    \
    \   ^\n/tmp/tmpk6x02fnn.swift:24:25: error: cannot assign value of type 'String.Index'\
    \ to type 'Int'\n                start = substring_start\n                   \
    \     ^~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824941
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    var\
    \ count = 0\n    var start = 0\n    var end = string.count\n    while start <\
    \ end {\n        let index = string.index(start, offsetBy: substring.count)\n\
    \        if index == nil {\n            break\n        }\n        start = index!\n\
    \        count += 1\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpsv8kz63c.swift:14:34: error: cannot convert value of type 'Int'\
    \ to expected argument type 'String.Index'\n        let index = string.index(start,\
    \ offsetBy: substring.count)\n                                 ^\n"
  stdout: ''
  timestamp: 1659824941
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if\
    \ string == \"\" {\n        return 0\n    }\n    if substring == \"\" {\n    \
    \    return countOccurrences(string, \"\")\n    }\n    var count = 0\n    var\
    \ i = 0\n    var j = string.count\n    var k = substring.count\n    while i <\
    \ j {\n        if string[i] == substring[0] {\n            count += countOccurrences(&string[i+1],\
    \ substring[1:])\n            i += k\n        } else {\n            i += k\n \
    \       }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpabkcstzr.swift:22:64: error: expected ',' separator\n         \
    \   count += countOccurrences(&string[i+1], substring[1:])\n                 \
    \                                              ^\n                           \
    \                                    ,\n/tmp/tmpabkcstzr.swift:22:64: error: expected\
    \ expression in list of expressions\n            count += countOccurrences(&string[i+1],\
    \ substring[1:])\n                                                           \
    \    ^\n/tmp/tmpabkcstzr.swift:14:16: error: cannot find 'countOccurrences' in\
    \ scope\n        return countOccurrences(string, \"\")\n               ^~~~~~~~~~~~~~~~\n\
    /tmp/tmpabkcstzr.swift:21:12: error: 'subscript(_:)' is unavailable: cannot subscript\
    \ String with an Int, use a String.Index instead.\n        if string[i] == substring[0]\
    \ {\n           ^~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly\
    \ marked unavailable here\n    public subscript(i: Int) -> Character { get }\n\
    \           ^\n/tmp/tmpabkcstzr.swift:21:25: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n        if\
    \ string[i] == substring[0] {\n                        ^~~~~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpabkcstzr.swift:22:22:\
    \ error: cannot find 'countOccurrences' in scope\n            count += countOccurrences(&string[i+1],\
    \ substring[1:])\n                     ^~~~~~~~~~~~~~~~\n/tmp/tmpabkcstzr.swift:22:39:\
    \ error: cannot pass immutable value as inout argument: subscript is get-only\n\
    \            count += countOccurrences(&string[i+1], substring[1:])\n        \
    \                              ^~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824941
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if\
    \ string == \"\" {\n        return 0\n    }\n    if substring == \"\" {\n    \
    \    return count(string)\n    }\n    var count = 0\n    var i = 0\n    var j\
    \ = string.count\n    var k = substring.count\n    while i < j {\n        if string[i]\
    \ != substring[j] {\n            count = count + 1\n        }\n        i += 1\n\
    \        j += 1\n    }\n    while k < substring.count {\n        if string[k]\
    \ != substring[j] {\n            count = count + 1\n        }\n        k += 1\n\
    \        j += 1\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpm3k0cxrp.swift:14:16: error: use of local variable 'count' before\
    \ its declaration\n        return count(string)\n               ^\n/tmp/tmpm3k0cxrp.swift:16:9:\
    \ note: 'count' declared here\n    var count = 0\n        ^\n/tmp/tmpm3k0cxrp.swift:21:12:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if string[i] != substring[j] {\n      \
    \     ^~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly\
    \ marked unavailable here\n    public subscript(i: Int) -> Character { get }\n\
    \           ^\n/tmp/tmpm3k0cxrp.swift:21:25: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n        if\
    \ string[i] != substring[j] {\n                        ^~~~~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpm3k0cxrp.swift:28:12:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if string[k] != substring[j] {\n      \
    \     ^~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly\
    \ marked unavailable here\n    public subscript(i: Int) -> Character { get }\n\
    \           ^\n/tmp/tmpm3k0cxrp.swift:28:25: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n        if\
    \ string[k] != substring[j] {\n                        ^~~~~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1659824941
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if\
    \ string == \"\" {\n        return 0\n    }\n    if substring == \"\" {\n    \
    \    return string.count\n    }\n    var count = 0\n    var start = 0\n    var\
    \ end = string.count\n    while start < end {\n        start = string.index(substring,\
    \ start) + 1\n        end = string.index(substring, end) + 1\n        count +=\
    \ 1\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp0srebqec.swift:20:24: error: no exact matches in call to instance\
    \ method 'index'\n        start = string.index(substring, start) + 1\n       \
    \                ^\n/tmp/tmp0srebqec.swift:20:24: note: candidate has partially\
    \ matching parameter list (String.Index, offsetBy: Int)\n        start = string.index(substring,\
    \ start) + 1\n                       ^\n/tmp/tmp0srebqec.swift:20:24: note: candidate\
    \ has partially matching parameter list (String.Index, offsetBy: Int)\n      \
    \  start = string.index(substring, start) + 1\n                       ^\n/tmp/tmp0srebqec.swift:20:24:\
    \ note: candidate has partially matching parameter list (String.Index, offsetBy:\
    \ Int)\n        start = string.index(substring, start) + 1\n                 \
    \      ^\n/tmp/tmp0srebqec.swift:20:24: error: cannot convert value of type 'String.Index'\
    \ to expected argument type 'Int'\n        start = string.index(substring, start)\
    \ + 1\n                       ^\n/tmp/tmp0srebqec.swift:21:22: error: cannot convert\
    \ value of type 'String.Index' to expected argument type 'Int'\n        end =\
    \ string.index(substring, end) + 1\n                     ^\n/tmp/tmp0srebqec.swift:21:22:\
    \ error: no exact matches in call to instance method 'index'\n        end = string.index(substring,\
    \ end) + 1\n                     ^\n/tmp/tmp0srebqec.swift:21:22: note: candidate\
    \ has partially matching parameter list (String.Index, offsetBy: Int)\n      \
    \  end = string.index(substring, end) + 1\n                     ^\n/tmp/tmp0srebqec.swift:21:22:\
    \ note: candidate has partially matching parameter list (String.Index, offsetBy:\
    \ Int)\n        end = string.index(substring, end) + 1\n                     ^\n\
    /tmp/tmp0srebqec.swift:21:22: note: candidate has partially matching parameter\
    \ list (String.Index, offsetBy: Int)\n        end = string.index(substring, end)\
    \ + 1\n                     ^\n"
  stdout: ''
  timestamp: 1659824941
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if\
    \ string == \"\" {\n        return 0\n    }\n    if substring == \"\" {\n    \
    \    return countOccurrences(string, \"\")\n    }\n    var count = 0\n    var\
    \ i = 0\n    var j = string.count\n    var k = substring.count\n    while i <\
    \ j {\n        if string[i] == substring[k] {\n            count = count + 1\n\
    \            i = i + 1\n            k = k - 1\n            if k == -1 {\n    \
    \            j = j - 1\n                k = k + string.count\n            }\n\
    \        } else {\n            i = i + 1\n        }\n    }\n    return count\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpbqmn8tmu.swift:14:16: error: cannot find 'countOccurrences' in\
    \ scope\n        return countOccurrences(string, \"\")\n               ^~~~~~~~~~~~~~~~\n\
    /tmp/tmpbqmn8tmu.swift:21:12: error: 'subscript(_:)' is unavailable: cannot subscript\
    \ String with an Int, use a String.Index instead.\n        if string[i] == substring[k]\
    \ {\n           ^~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly\
    \ marked unavailable here\n    public subscript(i: Int) -> Character { get }\n\
    \           ^\n/tmp/tmpbqmn8tmu.swift:21:25: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n        if\
    \ string[i] == substring[k] {\n                        ^~~~~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1659824941
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if\
    \ string == \"\" || substring == \"\" {\n        return 0\n    }\n    var count\
    \ = 0\n    var start = 0\n    var end = string.count\n    while start < end {\n\
    \        let index = string.index(start, offsetBy: substring.count)\n        if\
    \ index == nil {\n            break\n        }\n        start = index!\n     \
    \   count += 1\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpig5gmp3b.swift:17:34: error: cannot convert value of type 'Int'\
    \ to expected argument type 'String.Index'\n        let index = string.index(start,\
    \ offsetBy: substring.count)\n                                 ^\n"
  stdout: ''
  timestamp: 1659824940
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    var\
    \ count = 0\n    for index in 0..<string.characters.count {\n        if string.substring(from:\
    \ index).lowercased() == substring.lowercased() {\n            count += 1\n  \
    \      }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpzebs1vtl.swift:11:29: error: 'characters' is unavailable: Please\
    \ use String directly\n    for index in 0..<string.characters.count {\n      \
    \                      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpzebs1vtl.swift:12:19: error: value of type 'String' has no member\
    \ 'substring'\n        if string.substring(from: index).lowercased() == substring.lowercased()\
    \ {\n           ~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824940
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    var\
    \ count = 0\n    for index in 0..<string.characters.count {\n        if string.substring(index,\
    \ string.characters.count) == substring {\n            count += 1\n        }\n\
    \    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpja6rt6dx.swift:11:29: error: 'characters' is unavailable: Please\
    \ use String directly\n    for index in 0..<string.characters.count {\n      \
    \                      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpja6rt6dx.swift:12:19: error: value of type 'String' has no member\
    \ 'substring'\n        if string.substring(index, string.characters.count) ==\
    \ substring {\n           ~~~~~~ ^~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824940
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    let\
    \ start = string.startIndex.advancedBy(substring.startIndex)\n    let end = string.endIndex.advancedBy(substring.endIndex)\n\
    \    let count = string.distance(from: start, to: end).magnitude\n    return count\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp1_6ogq29.swift:10:35: error: value of type 'String.Index' has no\
    \ member 'advancedBy'\n    let start = string.startIndex.advancedBy(substring.startIndex)\n\
    \                ~~~~~~~~~~~~~~~~~ ^~~~~~~~~~\n/tmp/tmp1_6ogq29.swift:11:31: error:\
    \ value of type 'String.Index' has no member 'advancedBy'\n    let end = string.endIndex.advancedBy(substring.endIndex)\n\
    \              ~~~~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824941
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if\
    \ string == \"\" {\n        return 0\n    }\n    if substring == \"\" {\n    \
    \    return string.length\n    }\n    var count = 0\n    var i = 0\n    var j\
    \ = string.length - 1\n    while i < j {\n        if string[i] == substring[0]\
    \ {\n            count += 1\n            i += substring.length - 1\n        }\
    \ else if string[j] == substring[0] {\n            count -= 1\n            j -=\
    \ 1\n        } else {\n            i += 1\n            j += 1\n        }\n   \
    \ }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmplf1hn_2x.swift:14:23: error: value of type 'String' has no member\
    \ 'length'\n        return string.length\n               ~~~~~~ ^~~~~~\n/tmp/tmplf1hn_2x.swift:18:20:\
    \ error: value of type 'String' has no member 'length'\n    var j = string.length\
    \ - 1\n            ~~~~~~ ^~~~~~\n/tmp/tmplf1hn_2x.swift:20:12: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if string[i] == substring[0] {\n           ^~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmplf1hn_2x.swift:20:25:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if string[i] == substring[0] {\n      \
    \                  ^~~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has\
    \ been explicitly marked unavailable here\n    public subscript(i: Int) -> Character\
    \ { get }\n           ^\n/tmp/tmplf1hn_2x.swift:22:28: error: value of type 'String'\
    \ has no member 'length'\n            i += substring.length - 1\n            \
    \     ~~~~~~~~~ ^~~~~~\n"
  stdout: ''
  timestamp: 1659824940
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if\
    \ string == \"\" {\n        return 0\n    }\n    if substring == \"\" {\n    \
    \    return countOccurrences(string, \"\")\n    }\n    var count = 0\n    var\
    \ i = 0\n    var j = string.count\n    var k = substring.count\n    while i <\
    \ j && k < string.count {\n        if string[i] == substring[k] {\n          \
    \  count = count + 1\n            i = i + 1\n            k = k + 1\n        }\n\
    \        if k == substring.count {\n            j = j - 1\n        }\n    }\n\
    \    return count\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp35he9w2e.swift:14:16: error: cannot find 'countOccurrences' in\
    \ scope\n        return countOccurrences(string, \"\")\n               ^~~~~~~~~~~~~~~~\n\
    /tmp/tmp35he9w2e.swift:21:12: error: 'subscript(_:)' is unavailable: cannot subscript\
    \ String with an Int, use a String.Index instead.\n        if string[i] == substring[k]\
    \ {\n           ^~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly\
    \ marked unavailable here\n    public subscript(i: Int) -> Character { get }\n\
    \           ^\n/tmp/tmp35he9w2e.swift:21:25: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n        if\
    \ string[i] == substring[k] {\n                        ^~~~~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1659824941
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if\
    \ string == \"\" {\n        return 0\n    }\n    if substring == \"\" {\n    \
    \    return string.count\n    }\n    var count = 0\n    var start = 0\n    var\
    \ end = string.count\n    while start < end {\n        let index = string.index(start,\
    \ offsetBy: substring.count)\n        if index == nil {\n            break\n \
    \       }\n        start = index!\n        count += 1\n    }\n    return count\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpc8g77_ig.swift:20:34: error: cannot convert value of type 'Int'\
    \ to expected argument type 'String.Index'\n        let index = string.index(start,\
    \ offsetBy: substring.count)\n                                 ^\n"
  stdout: ''
  timestamp: 1659824941
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if\
    \ string == \"\" {\n        return 0\n    }\n    if substring == \"\" {\n    \
    \    return countOccurrences(string, \"\")\n    }\n    var count = 0\n    var\
    \ i = 0\n    var j = 0\n    var k = 0\n    var found = false\n    for ; i < len(string);\
    \ i++ {\n        if string[i] == substring[0] {\n            found = true\n  \
    \          for ; j < len(substring); j++ {\n                if string[i + j] !=\
    \ substring[j] {\n                    found = false\n                    break\n\
    \                }\n            }\n            if found {\n                count\
    \ += countOccurrences(string, substring)\n                found = false\n    \
    \        }\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpm4wseq50.swift:21:5: error: C-style for statement has been removed\
    \ in Swift 3\n    for ; i < len(string); i++ {\n    ^   ~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpm4wseq50.swift:24:13: error: C-style for statement has been removed in\
    \ Swift 3\n            for ; j < len(substring); j++ {\n            ^   ~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpm4wseq50.swift:14:16: error: cannot find 'countOccurrences' in scope\n\
    \        return countOccurrences(string, \"\")\n               ^~~~~~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824941
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if\
    \ string == \"\" {\n        return 0\n    }\n    if substring == \"\" {\n    \
    \    return countOccurrences(string, \"\")\n    }\n    var count = 0\n    var\
    \ i = 0\n    var j = string.count\n    var k = substring.count\n    while i <\
    \ j {\n        if string[i] == substring[k] {\n            count += 1\n      \
    \      i += k\n            k += 1\n            if k == substring.count {\n   \
    \             i += 1\n                k = 0\n            }\n        } else {\n\
    \            i += 1\n            k = 0\n        }\n    }\n    return count\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpv_r7om81.swift:14:16: error: cannot find 'countOccurrences' in\
    \ scope\n        return countOccurrences(string, \"\")\n               ^~~~~~~~~~~~~~~~\n\
    /tmp/tmpv_r7om81.swift:21:12: error: 'subscript(_:)' is unavailable: cannot subscript\
    \ String with an Int, use a String.Index instead.\n        if string[i] == substring[k]\
    \ {\n           ^~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly\
    \ marked unavailable here\n    public subscript(i: Int) -> Character { get }\n\
    \           ^\n/tmp/tmpv_r7om81.swift:21:25: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n        if\
    \ string[i] == substring[k] {\n                        ^~~~~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1659824941
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if\
    \ string == \"\" || substring == \"\" {\n        return 0\n    }\n    var count\
    \ = 0\n    var i = 0\n    var j = string.count\n    var k = substring.count\n\
    \    while i < j && k < string.count {\n        if string[i] == substring[k] {\n\
    \            count += 1\n            i += 1\n            k += 1\n        }\n \
    \       if string[i] == substring[k] {\n            i += 1\n            k += 1\n\
    \        }\n        if string[i] == substring[k] {\n            i += 1\n     \
    \       k += 1\n        }\n        if string[i] == substring[k] {\n          \
    \  i += 1\n            k += 1\n        }\n        if string[i] == substring[k]\
    \ {\n            i += 1\n            k += 1\n        }\n        if string[i] ==\
    \ substring[k] {\n            i += 1\n            k += 1\n        }\n        if\
    \ string[i] == substring[k] {\n            i += 1\n            k += 1\n      \
    \  }\n        if string[i] == substring[k] {\n            i += 1\n           \
    \ k += 1\n        }\n        if string[i] == substring[k] {\n            i +=\
    \ 1\n            k += 1\n        }\n        if string[i] == substring[k] {\n \
    \           i += 1\n            k += 1\n        }\n        if string[i] == substring[k]\
    \ {\n            i += 1\n            k += 1\n        }\n        if string[i] ==\
    \ substring[k] {\n            i += 1\n            k += 1\n        }\n        if\
    \ string[i] == substring[k] {\n            i += 1\n            k += 1\n      \
    \  }\n        if string[i] == substring[k] {\n            i += 1\n           \
    \ k += 1\n        }\n        if string[i] == substring[k] {\n            i +=\
    \ 1\n            k += 1\n        }\n        if string[i] == substring[k] {\n \
    \           i += 1\n            k += 1\n        }\n        if string[i] == substring[k]\
    \ {\n            i += 1\n            k += 1\n        }\n        if string[i] ==\
    \ substring[k] {\n            i += 1\n            k += 1\n        }\n        if\
    \ string[i] == substring[k] {\n            i += 1\n            k += 1\n      \
    \  }\n        if string[i] == substring[k] {\n            i += 1\n           \
    \ k += 1\n        }\n        if string[i] == substring[k] {\n            i +=\
    \ 1\n            k += 1\n        }\n        if string[i] == substring[k] {\n \
    \           i += 1\n            k += 1\n        }\n        if string[i] == substring[k]\
    \ {\n            i += 1\n            k += 1\n        }\n        if string[i] ==\
    \ substring[k] {\n            i += 1\n            k += 1\n        }\n        if\
    \ string[i] == substring[k] {\n            i += 1\n            k += 1\n      \
    \  }\n        if string[i] == substring[k] {\n            i += 1\n           \
    \ k += 1\n        }\n        if string[i] == substring[k] {\n            i +=\
    \ 1\n            k += 1\n        }\n        if string[i] == substring[k] {\n \
    \           i += 1\n            k += 1\n        }\n        if string[i] == substring[k]\
    \ {\n            i += 1\n            k += 1\n        }\n        if string[i] ==\
    \ substring\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpecuqx1dv.swift:135:34: error: expected '{' after 'if' condition\n\
    \        if string[i] == substring\n                                 ^\n/tmp/tmpecuqx1dv.swift:154:67:\
    \ error: expected '}' at end of brace statement\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)\n                                 \
    \                                 ^\n/tmp/tmpecuqx1dv.swift:9:63: note: to match\
    \ this opening '{'\nfunc how_many_times(string: String, substring: String) ->\
    \ Int {\n                                                              ^\n/tmp/tmpecuqx1dv.swift:18:12:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if string[i] == substring[k] {\n      \
    \     ^~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly\
    \ marked unavailable here\n    public subscript(i: Int) -> Character { get }\n\
    \           ^\n/tmp/tmpecuqx1dv.swift:18:25: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n        if\
    \ string[i] == substring[k] {\n                        ^~~~~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpecuqx1dv.swift:23:12:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if string[i] == substring[k] {\n      \
    \     ^~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has been explicitly\
    \ marked unavailable here\n    public subscript(i: Int) -> Character { get }\n\
    \           ^\n/tmp/tmpecuqx1dv.swift:23:25: error: 'subscript(_:)' is unavailable:\
    \ cannot subscript String with an Int, use a String.Index instead.\n        if\
    \ string[i] == substring[k] {\n                        ^~~~~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmpecuqx1dv.swift:27:12:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int, "
  stdout: ''
  timestamp: 1659824942
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    var\
    \ count = 0\n    for c in string {\n        if c == substring {\n            count\
    \ += 1\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp1o2nzo8z.swift:12:14: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        if c == substring {\n\
    \           ~ ^  ~~~~~~~~~\n/tmp/tmp1o2nzo8z.swift:12:14: note: overloads for\
    \ '==' exist with these partially matching parameter lists: (Character, Character),\
    \ (String, String)\n        if c == substring {\n             ^\n"
  stdout: ''
  timestamp: 1659824940
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if\
    \ string == \"\" {\n        return 0\n    }\n    if substring == \"\" {\n    \
    \    return count(string)\n    }\n    var count = 0\n    var i = 0\n    var j\
    \ = 0\n    var k = 0\n    var last = 0\n    var last2 = 0\n    var last3 = 0\n\
    \    var last4 = 0\n    var last5 = 0\n    var last6 = 0\n    var last7 = 0\n\
    \    var last8 = 0\n    var last9 = 0\n    var last10 = 0\n    var last11 = 0\n\
    \    var last12 = 0\n    var last13 = 0\n    var last14 = 0\n    var last15 =\
    \ 0\n    var last16 = 0\n    var last17 = 0\n    var last18 = 0\n    var last19\
    \ = 0\n    var last20 = 0\n    var last21 = 0\n    var last22 = 0\n    var last23\
    \ = 0\n    var last24 = 0\n    var last25 = 0\n    var last26 = 0\n    var last27\
    \ = 0\n    var last28 = 0\n    var last29 = 0\n    var last30 = 0\n    var last31\
    \ = 0\n    var last32 = 0\n    var last33 = 0\n    var last34 = 0\n    var last35\
    \ = 0\n    var last36 = 0\n    var last37 = 0\n    var last38 = 0\n    var last39\
    \ = 0\n    var last40 = 0\n    var last41 = 0\n    var last42 = 0\n    var last43\
    \ = 0\n    var last44 = 0\n    var last45 = 0\n    var last46 = 0\n    var last47\
    \ = 0\n    var last48 = 0\n    var last49 = 0\n    var last50 = 0\n    var last51\
    \ = 0\n    var last52 = 0\n    var last53 = 0\n    var last54 = 0\n    var last55\
    \ = 0\n    var last56 = 0\n    var last57 = 0\n    var last58 = 0\n    var last59\
    \ = 0\n    var last60 = 0\n    var last61 = 0\n    var last62 = 0\n    var last63\
    \ = 0\n    var last64 = 0\n    var last65 = 0\n    var last66 = 0\n    var last67\
    \ = 0\n    var last68 = 0\n    var last69 = 0\n    var last70 = 0\n    var last71\
    \ = 0\n    var last72 = 0\n    var last73 = 0\n    var last74 = 0\n    var last75\
    \ = 0\n    var last76 = 0\n    var last77 = 0\n    var last78 = 0\n    var last79\
    \ = 0\n    var last80 = 0\n    var last81 = 0\n    var last82 = 0\n    var last83\
    \ = 0\n    var last84 = 0\n    var last85 = 0\n    var last86 = 0\n    var last87\
    \ = 0\n    var last88 = 0\n    var last89 = 0\n    var last90 = 0\n    var last91\
    \ = 0\n    var last92 = 0\n    var last93 = 0\n    var last94 = 0\n    var last95\
    \ = 0\n    var \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpdcagbxl6.swift:115:8: error: expected pattern\n    var \n     \
    \  ^\n/tmp/tmpdcagbxl6.swift:14:16: error: use of local variable 'count' before\
    \ its declaration\n        return count(string)\n               ^\n/tmp/tmpdcagbxl6.swift:16:9:\
    \ note: 'count' declared here\n    var count = 0\n        ^\n"
  stdout: ''
  timestamp: 1659824939
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    var\
    \ count = 0\n    for c in string.unicodeScalars {\n        if c == substring {\n\
    \            count += 1\n        }\n    }\n    return count\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\n\
    assert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string:\
    \ \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string: \"john\
    \ doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpd3rykh2s.swift:12:14: error: referencing operator function '=='\
    \ on 'StringProtocol' requires that 'Unicode.Scalar' conform to 'StringProtocol'\n\
    \        if c == substring {\n             ^\nSwift.StringProtocol:1:11: note:\
    \ where 'Self' = 'Unicode.Scalar'\nextension StringProtocol {\n          ^\n"
  stdout: ''
  timestamp: 1659824939
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if\
    \ string == \"\" {\n        return 0\n    }\n    if substring == \"\" {\n    \
    \    return count(string)\n    }\n    var count = 0\n    var i = 0\n    var j\
    \ = string.characters.count\n    var k = substring.characters.count\n    while\
    \ i < j {\n        if string[i] != substring[k] {\n            count = count +\
    \ 1\n        }\n        i = i + 1\n        k = k + 1\n    }\n    return count\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpbb1jjp_6.swift:14:16: error: use of local variable 'count' before\
    \ its declaration\n        return count(string)\n               ^\n/tmp/tmpbb1jjp_6.swift:16:9:\
    \ note: 'count' declared here\n    var count = 0\n        ^\n/tmp/tmpbb1jjp_6.swift:18:20:\
    \ error: 'characters' is unavailable: Please use String directly\n    var j =\
    \ string.characters.count\n                   ^~~~~~~~~~\nSwift.String:5:16: note:\
    \ 'characters' was obsoleted in Swift 5.0\n    public var characters: String {\
    \ get set }\n               ^\n/tmp/tmpbb1jjp_6.swift:19:23: error: 'characters'\
    \ is unavailable: Please use String directly\n    var k = substring.characters.count\n\
    \                      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpbb1jjp_6.swift:21:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if string[i]\
    \ != substring[k] {\n           ^~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)'\
    \ has been explicitly marked unavailable here\n    public subscript(i: Int) ->\
    \ Character { get }\n           ^\n/tmp/tmpbb1jjp_6.swift:21:25: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if string[i] != substring[k] {\n                        ^~~~~~~~~~~~\n\
    Swift.String:3:12: note: 'subscript(_:)' has been explicitly marked unavailable\
    \ here\n    public subscript(i: Int) -> Character { get }\n           ^\n"
  stdout: ''
  timestamp: 1659824941
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if\
    \ string == \"\" {\n        return 0\n    }\n    if substring == \"\" {\n    \
    \    return string.count\n    }\n    var count = 0\n    var i = 0\n    for c in\
    \ string {\n        if c == substring {\n            count = count + 1\n     \
    \   } else {\n            count = count + how_many_times(string[i..<string.endIndex],\
    \ substring)\n        }\n        i = i + 1\n    }\n    return count\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpbo3g9fcw.swift:19:14: error: binary operator '==' cannot be applied\
    \ to operands of type 'Character' and 'String'\n        if c == substring {\n\
    \           ~ ^  ~~~~~~~~~\n/tmp/tmpbo3g9fcw.swift:19:14: note: overloads for\
    \ '==' exist with these partially matching parameter lists: (Character, Character),\
    \ (String, String)\n        if c == substring {\n             ^\n/tmp/tmpbo3g9fcw.swift:22:43:\
    \ error: missing argument labels 'string:substring:' in call\n            count\
    \ = count + how_many_times(string[i..<string.endIndex], substring)\n         \
    \                                 ^\n                                        \
    \   string:                      substring: \n/tmp/tmpbo3g9fcw.swift:22:62: error:\
    \ cannot convert value of type 'String.Index' to expected argument type 'Int'\n\
    \            count = count + how_many_times(string[i..<string.endIndex], substring)\n\
    \                                                             ^\n"
  stdout: ''
  timestamp: 1659824941
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    var\
    \ count = 0\n    for index in 0..<string.characters.count {\n        if string.characters.contains(substring,\
    \ at: index) {\n            count += 1\n        }\n    }\n    return count\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpvmqb7rry.swift:11:29: error: 'characters' is unavailable: Please\
    \ use String directly\n    for index in 0..<string.characters.count {\n      \
    \                      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmpvmqb7rry.swift:12:54: error: extra argument 'at' in call\n      \
    \  if string.characters.contains(substring, at: index) {\n                   \
    \                  ~~~~~~~~~~~~~~~~^~~~~~\n"
  stdout: ''
  timestamp: 1659824940
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    let\
    \ start = string.startIndex.advancedBy(substring.startIndex)\n    let end = string.endIndex.advancedBy(substring.endIndex)\n\
    \    let range = start..<end\n    return string.distance(from: range, to: end)\
    \ + 1\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(how_many_times(string:\
    \ \"\", substring: \"x\") == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring:\
    \ \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\", substring: \"cac\"\
    ) == 4)\nassert(how_many_times(string: \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp_zyng0ai.swift:10:35: error: value of type 'String.Index' has no\
    \ member 'advancedBy'\n    let start = string.startIndex.advancedBy(substring.startIndex)\n\
    \                ~~~~~~~~~~~~~~~~~ ^~~~~~~~~~\n/tmp/tmp_zyng0ai.swift:11:31: error:\
    \ value of type 'String.Index' has no member 'advancedBy'\n    let end = string.endIndex.advancedBy(substring.endIndex)\n\
    \              ~~~~~~~~~~~~~~~ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824941
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    let\
    \ start = string.startIndex.advancedBy(substring.startIndex)\n    let end = string.startIndex.advancedBy(substring.endIndex)\n\
    \    return string.distance(from: start) - string.distance(from: end)\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp945vy48_.swift:10:35: error: value of type 'String.Index' has no\
    \ member 'advancedBy'\n    let start = string.startIndex.advancedBy(substring.startIndex)\n\
    \                ~~~~~~~~~~~~~~~~~ ^~~~~~~~~~\n/tmp/tmp945vy48_.swift:11:33: error:\
    \ value of type 'String.Index' has no member 'advancedBy'\n    let end = string.startIndex.advancedBy(substring.endIndex)\n\
    \              ~~~~~~~~~~~~~~~~~ ^~~~~~~~~~\n/tmp/tmp945vy48_.swift:12:68: error:\
    \ missing argument for parameter 'to' in call\n    return string.distance(from:\
    \ start) - string.distance(from: end)\n                                      \
    \                             ^\n                                            \
    \                       , to: <#String.Index#>\nSwift.String:11:17: note: 'distance(from:to:)'\
    \ declared here\n    public func distance(from start: String.Index, to end: String.Index)\
    \ -> Int\n                ^\n/tmp/tmp945vy48_.swift:12:39: error: missing argument\
    \ for parameter 'to' in call\n    return string.distance(from: start) - string.distance(from:\
    \ end)\n                                      ^\n                            \
    \          , to: <#String.Index#>\nSwift.String:11:17: note: 'distance(from:to:)'\
    \ declared here\n    public func distance(from start: String.Index, to end: String.Index)\
    \ -> Int\n                ^\n"
  stdout: ''
  timestamp: 1659824941
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if\
    \ string == \"\" || substring == \"\" {\n        return 0\n    }\n    var count\
    \ = 0\n    var last = 0\n    for index in 0..<string.characters.count {\n    \
    \    if string.characters[index] == substring.characters[last] {\n           \
    \ count += 1\n            last = index\n        }\n    }\n    return count\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp9ieez19o.swift:15:29: error: 'characters' is unavailable: Please\
    \ use String directly\n    for index in 0..<string.characters.count {\n      \
    \                      ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted\
    \ in Swift 5.0\n    public var characters: String { get set }\n              \
    \ ^\n/tmp/tmp9ieez19o.swift:16:12: error: 'subscript(_:)' is unavailable: cannot\
    \ subscript String with an Int, use a String.Index instead.\n        if string.characters[index]\
    \ == substring.characters[last] {\n           ^~~~~~~~~~~~~~~~~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmp9ieez19o.swift:16:19:\
    \ error: 'characters' is unavailable: Please use String directly\n        if string.characters[index]\
    \ == substring.characters[last] {\n                  ^~~~~~~~~~\nSwift.String:5:16:\
    \ note: 'characters' was obsoleted in Swift 5.0\n    public var characters: String\
    \ { get set }\n               ^\n/tmp/tmp9ieez19o.swift:16:40: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if string.characters[index] == substring.characters[last] {\n       \
    \                                ^~~~~~~~~~~~~~~~~~~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmp9ieez19o.swift:16:50:\
    \ error: 'characters' is unavailable: Please use String directly\n        if string.characters[index]\
    \ == substring.characters[last] {\n                                          \
    \       ^~~~~~~~~~\nSwift.String:5:16: note: 'characters' was obsoleted in Swift\
    \ 5.0\n    public var characters: String { get set }\n               ^\n"
  stdout: ''
  timestamp: 1659824941
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if\
    \ string == \"\" {\n        return 0\n    }\n    if substring == \"\" {\n    \
    \    return string.length\n    }\n    var count = 0\n    var i = 0\n    var j\
    \ = string.length - 1\n    while i < j {\n        if string[i] == substring[0]\
    \ {\n            count += 1\n            i -= 1\n            if i == 0 {\n   \
    \             j -= 1\n            }\n        } else if string[j] == substring[1]\
    \ {\n            count -= 1\n            j -= 1\n            if j == 0 {\n   \
    \             i += 1\n            }\n        } else {\n            i += 1\n  \
    \          j += 1\n        }\n    }\n    return count\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmprx38zx0y.swift:14:23: error: value of type 'String' has no member\
    \ 'length'\n        return string.length\n               ~~~~~~ ^~~~~~\n/tmp/tmprx38zx0y.swift:18:20:\
    \ error: value of type 'String' has no member 'length'\n    var j = string.length\
    \ - 1\n            ~~~~~~ ^~~~~~\n/tmp/tmprx38zx0y.swift:20:12: error: 'subscript(_:)'\
    \ is unavailable: cannot subscript String with an Int, use a String.Index instead.\n\
    \        if string[i] == substring[0] {\n           ^~~~~~~~~\nSwift.String:3:12:\
    \ note: 'subscript(_:)' has been explicitly marked unavailable here\n    public\
    \ subscript(i: Int) -> Character { get }\n           ^\n/tmp/tmprx38zx0y.swift:20:25:\
    \ error: 'subscript(_:)' is unavailable: cannot subscript String with an Int,\
    \ use a String.Index instead.\n        if string[i] == substring[0] {\n      \
    \                  ^~~~~~~~~~~~\nSwift.String:3:12: note: 'subscript(_:)' has\
    \ been explicitly marked unavailable here\n    public subscript(i: Int) -> Character\
    \ { get }\n           ^\n"
  stdout: ''
  timestamp: 1659824941
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if\
    \ string == \"\" {\n        return 0\n    }\n    if substring == \"\" {\n    \
    \    return countOccurrences(string, \"\")\n    }\n    var count = 0\n    var\
    \ startIndex = 0\n    var endIndex = 0\n    while startIndex < string.count {\n\
    \        endIndex = string.index(substring, startIndex)\n        if endIndex ==\
    \ startIndex {\n            count += 1\n            startIndex += 1\n        \
    \    continue\n        }\n        if endIndex == string.count {\n            count\
    \ += 1\n            startIndex += 1\n            continue\n        }\n       \
    \ if string.substring(startIndex, endIndex) == substring {\n            count\
    \ += 1\n            startIndex = endIndex + 1\n            continue\n        }\n\
    \        if string.substring(startIndex, endIndex).lowercased() == substring.lowercased()\
    \ {\n            count += 1\n            startIndex = endIndex + 1\n         \
    \   continue\n        }\n        if string.substring(startIndex, endIndex).uppercased()\
    \ == substring.uppercased() {\n            count += 1\n            startIndex\
    \ = endIndex + 1\n            continue\n        }\n        if string.substring(startIndex,\
    \ endIndex).capitalized() == substring.capitalized() {\n            count += 1\n\
    \            startIndex = endIndex + 1\n            continue\n        }\n    \
    \    if string.substring(startIndex, endIndex).range(of: substring) != nil {\n\
    \            count += 1\n            startIndex = endIndex + 1\n            continue\n\
    \        }\n        if string.substring(startIndex, endIndex).range(of: substring.lowercased())\
    \ != nil {\n            count += 1\n            startIndex = endIndex + 1\n  \
    \          continue\n        }\n        if string.substring(startIndex, endIndex).range(of:\
    \ substring.uppercased()) != nil {\n            count += 1\n            startIndex\
    \ = endIndex + 1\n            continue\n        }\n        if string.substring(startIndex,\
    \ endIndex).range(of: substring.capitalized()) != nil {\n            count +=\
    \ 1\n            startIndex = endIndex + 1\n            continue\n        }\n\
    \        if string.substring(startIndex, endIndex).range(of: substring.lowercased(),\
    \ options: .anchored) != nil {\n            count += 1\n            startIndex\
    \ = endIndex + 1\n            continue\n        }\n        if string.substring(startIndex,\
    \ endIndex).range(of: substring.uppercased(), options: .anchored) != nil {\n \
    \           count += 1\n            startIndex = endIndex + 1\n            continue\n\
    \        }\n        if string.substring(startIndex, endIndex).range(of: substring.capitalized(),\
    \ options: .anchored) != nil {\n            count += 1\n            startIndex\
    \ = endIndex + 1\n            continue\n        }\n        if string.substring(startIndex,\
    \ endIndex).range(of: substring.lowercased(), options: .backwards) != nil {\n\
    \            count += 1\n            startIndex = endIndex + 1\n            continue\n\
    \        }\n        if string.substring(startIndex, endIndex).range(of: substring.uppercased(),\
    \ options: .backwards) != nil {\n            count += 1\n            startIndex\
    \ = endIndex + 1\n            continue\n        }\n\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpsca9hobv.swift:115:67: error: expected '}' at end of brace statement\n\
    assert(how_many_times(string: \"john doe\", substring: \"john\") == 1)\n     \
    \                                                             ^\n/tmp/tmpsca9hobv.swift:9:63:\
    \ note: to match this opening '{'\nfunc how_many_times(string: String, substring:\
    \ String) -> Int {\n                                                         \
    \     ^\n/tmp/tmpsca9hobv.swift:14:16: error: cannot find 'countOccurrences' in\
    \ scope\n        return countOccurrences(string, \"\")\n               ^~~~~~~~~~~~~~~~\n\
    /tmp/tmpsca9hobv.swift:20:27: error: no exact matches in call to instance method\
    \ 'index'\n        endIndex = string.index(substring, startIndex)\n          \
    \                ^\n/tmp/tmpsca9hobv.swift:20:27: note: found candidate with type\
    \ '(String.Index, Int) -> String.Index'\n        endIndex = string.index(substring,\
    \ startIndex)\n                          ^\n/tmp/tmpsca9hobv.swift:20:27: error:\
    \ cannot assign value of type 'String.Index' to type 'Int'\n        endIndex =\
    \ string.index(substring, startIndex)\n                   ~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpsca9hobv.swift:31:19: error: value of type 'String' has no member 'substring'\n\
    \        if string.substring(startIndex, endIndex) == substring {\n          \
    \ ~~~~~~ ^~~~~~~~~\n/tmp/tmpsca9hobv.swift:36:19: error: value of type 'String'\
    \ has no member 'substring'\n        if string.substring(startIndex, endIndex).lowercased()\
    \ == substring.lowercased() {\n           ~~~~~~ ^~~~~~~~~\n/tmp/tmpsca9hobv.swift:41:19:\
    \ error: value of type 'String' has no member 'substring'\n        if string.substring(startIndex,\
    \ endIndex).uppercased() == substring.uppercased() {\n           ~~~~~~ ^~~~~~~~~\n\
    /tmp/tmpsca9hobv.swift:46:19: error: value of type 'String' has no member 'substring'\n\
    \        if string.substring(startIndex, endIndex).capitalized() == substring.capitalized()\
    \ {\n           ~~~~~~ ^~~~~~~~~\n/tmp/tmpsca9hobv.swift:46:78: error: value of\
    \ type 'String' has no member 'capitalized'\n        if string.substring(startIndex,\
    \ endIndex).c"
  stdout: ''
  timestamp: 1659824941
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    let\
    \ startIndex = string.startIndex.advancedBy(substring.startIndex)\n    let endIndex\
    \ = string.startIndex.advancedBy(substring.endIndex)\n    let count = string.distance(from:\
    \ startIndex, to: endIndex)\n    return count\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(how_many_times(string: \"\", substring: \"x\") == 0)\nassert(how_many_times(string:\
    \ \"xyxyxyx\", substring: \"x\") == 4)\nassert(how_many_times(string: \"cacacacac\"\
    , substring: \"cac\") == 4)\nassert(how_many_times(string: \"john doe\", substring:\
    \ \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmp5728gz6_.swift:10:40: error: value of type 'String.Index' has no\
    \ member 'advancedBy'\n    let startIndex = string.startIndex.advancedBy(substring.startIndex)\n\
    \                     ~~~~~~~~~~~~~~~~~ ^~~~~~~~~~\n/tmp/tmp5728gz6_.swift:11:38:\
    \ error: value of type 'String.Index' has no member 'advancedBy'\n    let endIndex\
    \ = string.startIndex.advancedBy(substring.endIndex)\n                   ~~~~~~~~~~~~~~~~~\
    \ ^~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659824941
- exit_code: 1
  program: "\n/// Find how many times a given substring can be found in the original\
    \ string. Count overlaping cases.\n/// >>> how_many_times('', 'a')\n/// 0\n///\
    \ >>> how_many_times('aaa', 'a')\n/// 3\n/// >>> how_many_times('aaaa', 'aa')\n\
    /// 3\nfunc how_many_times(string: String, substring: String) -> Int {\n    if\
    \ string == \"\" {\n        return 0\n    }\n    if substring == \"\" {\n    \
    \    return count(string)\n    }\n    var count = 0\n    var start = 0\n    var\
    \ end = count(string)\n    while start < end {\n        start = find(string, substring,\
    \ start)\n        end = find(string, substring, end + 1)\n        if start ==\
    \ end {\n            count += 1\n        }\n    }\n    return count\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(how_many_times(string: \"\", substring: \"x\"\
    ) == 0)\nassert(how_many_times(string: \"xyxyxyx\", substring: \"x\") == 4)\n\
    assert(how_many_times(string: \"cacacacac\", substring: \"cac\") == 4)\nassert(how_many_times(string:\
    \ \"john doe\", substring: \"john\") == 1)"
  status: SyntaxError
  stderr: "/tmp/tmpz__4o2rn.swift:14:16: error: use of local variable 'count' before\
    \ its declaration\n        return count(string)\n               ^\n/tmp/tmpz__4o2rn.swift:16:9:\
    \ note: 'count' declared here\n    var count = 0\n        ^\n/tmp/tmpz__4o2rn.swift:18:15:\
    \ error: cannot call value of non-function type 'Int'\n    var end = count(string)\n\
    \              ^\n/tmp/tmpz__4o2rn.swift:20:17: error: cannot find 'find' in scope\n\
    \        start = find(string, substring, start)\n                ^~~~\n/tmp/tmpz__4o2rn.swift:21:15:\
    \ error: cannot find 'find' in scope\n        end = find(string, substring, end\
    \ + 1)\n              ^~~~\n"
  stdout: ''
  timestamp: 1659824939
