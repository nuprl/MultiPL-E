language: swift
name: HumanEval_148_bf
results:
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    var planets = [String]()\n\
    \    \n    if planet1 == planet2 {\n        return planets\n    }\n    \n    if\
    \ planet1 == \"Mercury\" {\n        planets.append(\"Venus\")\n    }\n    \n \
    \   if planet1 == \"Venus\" {\n        planets.append(\"Earth\")\n    }\n    \n\
    \    if planet1 == \"Earth\" {\n        planets.append(\"Mars\")\n    }\n    \n\
    \    if planet1 == \"Mars\" {\n        planets.append(\"Jupiter\")\n    }\n  \
    \  \n    if planet1 == \"Jupiter\" {\n        planets.append(\"Saturn\")\n   \
    \ }\n    \n    if planet1 == \"Saturn\" {\n        planets.append(\"Uranus\")\n\
    \    }\n    \n    if planet1 == \"Uranus\" {\n        planets.append(\"Neptune\"\
    )\n    }\n    \n    if planet1 == \"Neptune\" {\n        planets.append(\"Mercury\"\
    )\n    }\n    \n    if planet2 == \"Mercury\" {\n        planets.append(\"Venus\"\
    )\n    }\n    \n    if planet2 == \"Venus\" {\n        planets.append(\"Earth\"\
    )\n    }\n    \n    if planet2 == \"Earth\" {\n        planets.append(\"Mars\"\
    )\n    }\n    \n    if planet2 == \"Mars\" {\n        planets.append(\"Jupiter\"\
    )\n    }\n    \n    if planet2 == \"Jupiter\" {\n        planets.append(\"Saturn\"\
    )\n    }\n    \n    if planet2 == \"Saturn\" {\n        planets.append(\"Uranus\"\
    )\n    }\n    \n    if planet2 == \"Uranus\" {\n        planets.append(\"Neptune\"\
    )\n    }\n    \n    if planet2 == \"Neptune\" {\n        planets.append(\"Mercury\"\
    )\n    }\n    \n    return planets\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(bf(planet1: \"Jupiter\", planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"\
    ])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1:\
    \ \"Mercury\", planet2: \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"])\nassert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2:\
    \ \"Earth\") == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\"\
    ) == [] as [String])"
  status: Exception
  stderr: 'tmp01j43xsq/tmp01j43xsq.swift:102: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae180e98c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae180b8fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae180b8f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae180b8e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp01j43xsq                        0x0000557927d3362b <unavailable> + 5675

    5    libc.so.6                          0x00002ae181084460 __libc_start_main +
    245

    6    tmp01j43xsq                        0x0000557927d331d9 <unavailable> + 4569

    '
  stdout: ''
  timestamp: 1659823230
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    var planets = [String]()\n\
    \    \n    if planet1 == planet2 {\n        return planets\n    }\n    \n    if\
    \ planet1 == \"Mercury\" && planet2 == \"Venus\" {\n        planets = [\"Mercury\"\
    , \"Venus\"]\n    } else if planet1 == \"Venus\" && planet2 == \"Mercury\" {\n\
    \        planets = [\"Venus\", \"Mercury\"]\n    } else if planet1 == \"Earth\"\
    \ && planet2 == \"Mars\" {\n        planets = [\"Earth\", \"Mars\"]\n    } else\
    \ if planet1 == \"Mars\" && planet2 == \"Earth\" {\n        planets = [\"Mars\"\
    , \"Earth\"]\n    } else if planet1 == \"Jupiter\" && planet2 == \"Saturn\" {\n\
    \        planets = [\"Jupiter\", \"Saturn\"]\n    } else if planet1 == \"Saturn\"\
    \ && planet2 == \"Jupiter\" {\n        planets = [\"Saturn\", \"Jupiter\"]\n \
    \   } else if planet1 == \"Uranus\" && planet2 == \"Neptune\" {\n        planets\
    \ = [\"Uranus\", \"Neptune\"]\n    } else if planet1 == \"Neptune\" && planet2\
    \ == \"Uranus\" {\n        planets = [\"Neptune\", \"Uranus\"]\n    }\n    \n\
    \    return planets\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2:\
    \ \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\n\
    assert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"\
    Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\")\
    \ == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: Exception
  stderr: 'tmppug9jgwh/tmppug9jgwh.swift:56: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aeb2fac5c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aeb2f7bcb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aeb2f7bc988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aeb2f7bb7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmppug9jgwh                        0x00005562beba95cb <unavailable> + 5579

    5    libc.so.6                          0x00002aeb2fcb1460 __libc_start_main +
    245

    6    tmppug9jgwh                        0x00005562beba9179 <unavailable> + 4473

    '
  stdout: ''
  timestamp: 1659823230
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    var planets = [String]()\n\
    \    \n    if planet1 == planet2 {\n        return planets\n    }\n    \n    if\
    \ planet1 == \"Mercury\" {\n        planets.append(\"Venus\")\n    }\n    \n \
    \   if planet1 == \"Venus\" {\n        planets.append(\"Earth\")\n    }\n    \n\
    \    if planet1 == \"Earth\" {\n        planets.append(\"Mars\")\n    }\n    \n\
    \    if planet1 == \"Mars\" {\n        planets.append(\"Jupiter\")\n    }\n  \
    \  \n    if planet1 == \"Jupiter\" {\n        planets.append(\"Saturn\")\n   \
    \ }\n    \n    if planet1 == \"Saturn\" {\n        planets.append(\"Uranus\")\n\
    \    }\n    \n    if planet1 == \"Uranus\" {\n        planets.append(\"Neptune\"\
    )\n    }\n    \n    if planet1 == \"Neptune\" {\n        planets.append(\"Mercury\"\
    )\n    }\n    \n    if planet2 == \"Mercury\" {\n        planets.append(\"Venus\"\
    )\n    }\n    \n    if planet2 == \"Venus\" {\n        planets.append(\"Earth\"\
    )\n    }\n    \n    if planet2 == \"Earth\" {\n        planets.append(\"Mars\"\
    )\n    }\n    \n    if planet2 == \"Mars\" {\n        planets.append(\"Jupiter\"\
    )\n    }\n    \n    if planet2 == \"Jupiter\" {\n        planets.append(\"Saturn\"\
    )\n    }\n    \n    if planet2 == \"Saturn\" {\n        planets.append(\"Uranus\"\
    )\n    }\n    \n    if planet2 == \"Uranus\" {\n        planets.append(\"Neptune\"\
    )\n    }\n    \n    if planet2 == \"Neptune\" {\n        planets.append(\"Mercury\"\
    )\n    }\n    \n    return planets\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(bf(planet1: \"Jupiter\", planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"\
    ])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1:\
    \ \"Mercury\", planet2: \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"])\nassert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2:\
    \ \"Earth\") == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\"\
    ) == [] as [String])"
  status: Exception
  stderr: 'tmp01j43xsq/tmp01j43xsq.swift:102: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae180e98c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae180b8fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae180b8f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae180b8e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp01j43xsq                        0x0000557927d3362b <unavailable> + 5675

    5    libc.so.6                          0x00002ae181084460 __libc_start_main +
    245

    6    tmp01j43xsq                        0x0000557927d331d9 <unavailable> + 4569

    '
  stdout: ''
  timestamp: 1659823230
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    var planets = [String]()\n\
    \    \n    // TODO: Write your code here\n    \n    return planets\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\"\
    ) == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\"\
    ) == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"\
    Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\n\
    assert(bf(planet1: \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Makemake\") == [] as [String])"
  status: Exception
  stderr: 'tmpqir0zopy/tmpqir0zopy.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b71b763fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b71b7336b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b71b7336988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b71b73357b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpqir0zopy                        0x00005603381a456b <unavailable> + 5483

    5    libc.so.6                          0x00002b71b782b460 __libc_start_main +
    245

    6    tmpqir0zopy                        0x00005603381a4119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659823230
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    \n    var planets\
    \ = [String]()\n    \n    if planet1 == planet2 {\n        return planets\n  \
    \  }\n    \n    if planet1 == \"Mercury\" {\n        planets = [\"Venus\"]\n \
    \   }\n    \n    if planet1 == \"Venus\" {\n        planets = [\"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"]\n    }\n    \n    if planet1\
    \ == \"Earth\" {\n        planets = [\"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    }\n    \n    if planet1 == \"Mars\" {\n        planets = [\"\
    Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"]\n    }\n    \n    if planet1 ==\
    \ \"Jupiter\" {\n        planets = [\"Saturn\", \"Uranus\", \"Neptune\"]\n   \
    \ }\n    \n    if planet1 == \"Saturn\" {\n        planets = [\"Uranus\", \"Neptune\"\
    ]\n    }\n    \n    if planet1 == \"Uranus\" {\n        planets = [\"Neptune\"\
    ]\n    }\n    \n    if planet1 == \"Neptune\" {\n        planets = [\"Mercury\"\
    , \"Venus\"]\n    }\n    \n    if planet2 == \"Mercury\" {\n        planets =\
    \ [\"Venus\"]\n    }\n    \n    if planet2 == \"Venus\" {\n        planets = [\"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"]\n    }\n\
    \    \n    if planet2 == \"Earth\" {\n        planets = [\"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\", \"Neptune\"]\n    }\n    \n    if planet2 == \"Mars\"\
    \ {\n        planets = [\"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"]\n  \
    \  }\n    \n    if planet2 == \"Jupiter\" {\n        planets = [\"Saturn\", \"\
    Uranus\", \"Neptune\"]\n    }\n    \n    if planet2 == \"Saturn\" {\n        planets\
    \ = [\"Uranus\", \"Neptune\"]\n    }\n    \n    if planet2 == \"Uranus\" {\n \
    \       planets = [\"Neptune\"]\n    }\n    \n    if planet2 == \"Neptune\" {\n\
    \        planets = [\"Mercury\", \"Venus\"]\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\") == [\"Saturn\", \"\
    Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\") == [\"Venus\"\
    ])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"Neptune\", planet2:\
    \ \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"])\n\
    assert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Makemake\") == [] as [String])"
  status: SyntaxError
  stderr: "/tmp/tmpedsiugxh.swift:106:70: error: expected '}' at end of brace statement\n\
    assert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") == [] as [String])\n  \
    \                                                                   ^\n/tmp/tmpedsiugxh.swift:15:55:\
    \ note: to match this opening '{'\nfunc bf(planet1: String, planet2: String) ->\
    \ [String] {\n                                                      ^\n/tmp/tmpedsiugxh.swift:88:6:\
    \ error: operator functions can only be declared at global or in type scope\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1659823230
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    \n    var result\
    \ = [String]()\n    \n    if planet1 == planet2 {\n        return result \n  \
    \  }\n    \n    if planet1 == \"Mercury\" && planet2 == \"Venus\" {\n        return\
    \ result \n    }\n    \n    if planet1 == \"Venus\" && planet2 == \"Mercury\"\
    \ {\n        return result \n    }\n    \n    if planet1 == \"Earth\" && planet2\
    \ == \"Mars\" {\n        return result \n    }\n    \n    if planet1 == \"Mars\"\
    \ && planet2 == \"Earth\" {\n        return result \n    }\n    \n    if planet1\
    \ == \"Jupiter\" && planet2 == \"Saturn\" {\n        return result \n    }\n \
    \   \n    if planet1 == \"Saturn\" && planet2 == \"Jupiter\" {\n        return\
    \ result \n    }\n    \n    if planet1 == \"Uranus\" && planet2 == \"Neptune\"\
    \ {\n        return result \n    }\n    \n    if planet1 == \"Neptune\" && planet2\
    \ == \"Uranus\" {\n        return result \n    }\n    \n    return []\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\"\
    ) == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\"\
    ) == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"\
    Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\n\
    assert(bf(planet1: \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Makemake\") == [] as [String])"
  status: Exception
  stderr: 'tmpo3iqtz5d/tmpo3iqtz5d.swift:71: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b73dc0adc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b73dbda4b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b73dbda4988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b73dbda37b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpo3iqtz5d                        0x0000561125e7e5cb <unavailable> + 5579

    5    libc.so.6                          0x00002b73dc299460 __libc_start_main +
    245

    6    tmpo3iqtz5d                        0x0000561125e7e179 <unavailable> + 4473

    '
  stdout: ''
  timestamp: 1659823230
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    var planets = [String]()\n\
    \    \n    if planet1 == planet2 {\n        return planets\n    }\n    \n    if\
    \ planet1 == \"Mercury\" || planet1 == \"Venus\" || planet1 == \"Earth\" || planet1\
    \ == \"Mars\" || planet1 == \"Jupiter\" || planet1 == \"Saturn\" || planet1 ==\
    \ \"Uranus\" || planet1 == \"Neptune\" {\n        planets.append(planet1)\n  \
    \  }\n    \n    if planet2 == \"Mercury\" || planet2 == \"Venus\" || planet2 ==\
    \ \"Earth\" || planet2 == \"Mars\" || planet2 == \"Jupiter\" || planet2 == \"\
    Saturn\" || planet2 == \"Uranus\" || planet2 == \"Neptune\" {\n        planets.append(planet2)\n\
    \    }\n    \n    if planet1 == \"Mercury\" && planet2 == \"Venus\" {\n      \
    \  planets.append(planet1)\n        planets.append(planet2)\n    }\n    \n   \
    \ if planet1 == \"Venus\" && planet2 == \"Mercury\" {\n        planets.append(planet1)\n\
    \        planets.append(planet2)\n    }\n    \n    if planet1 == \"Earth\" &&\
    \ planet2 == \"Mars\" {\n        planets.append(planet1)\n        planets.append(planet2)\n\
    \    }\n    \n    if planet1 == \"Mars\" && planet2 == \"Earth\" {\n        planets.append(planet1)\n\
    \        planets.append(planet2)\n    }\n    \n    if planet1 == \"Jupiter\" &&\
    \ planet2 == \"Saturn\" {\n        planets.append(planet1)\n        planets.append(planet2)\n\
    \    }\n    \n    if planet1 == \"Saturn\" && planet2 == \"Jupiter\" {\n     \
    \   planets.append(planet1)\n        planets.append(planet2)\n    }\n    \n  \
    \  if planet1 == \"Uranus\" && planet2 == \"Neptune\" {\n        planets.append(planet1)\n\
    \        planets.append(planet2)\n    }\n    \n    if planet1 == \"Neptune\" &&\
    \ planet2 == \"Uranus\" {\n        planets.append(planet1)\n        planets.append(planet2)\n\
    \    }\n    \n    if planet1 == \"Mercury\" && planet2 == \"Earth\" {\n      \
    \  planets.append(planet1)\n        planets.append(planet2)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\") == [\"\
    Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\") ==\
    \ [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"Venus\"\
    , \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"Neptune\"\
    , planet2: \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    ])\nassert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Makemake\") == [] as [String])"
  status: SyntaxError
  stderr: "/tmp/tmpbb3b92n7.swift:94:70: error: expected '}' at end of brace statement\n\
    assert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") == [] as [String])\n  \
    \                                                                   ^\n/tmp/tmpbb3b92n7.swift:15:55:\
    \ note: to match this opening '{'\nfunc bf(planet1: String, planet2: String) ->\
    \ [String] {\n                                                      ^\n/tmp/tmpbb3b92n7.swift:76:6:\
    \ error: operator functions can only be declared at global or in type scope\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1659823230
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    \n    var planets\
    \ = [String]()\n    \n    if planet1 == \"Mercury\" && planet2 == \"Venus\" {\n\
    \        planets = [\"Venus\"]\n    } else if planet1 == \"Venus\" && planet2\
    \ == \"Earth\" {\n        planets = [\"Earth\"]\n    } else if planet1 == \"Earth\"\
    \ && planet2 == \"Mars\" {\n        planets = [\"Mars\"]\n    } else if planet1\
    \ == \"Mars\" && planet2 == \"Jupiter\" {\n        planets = [\"Jupiter\"]\n \
    \   } else if planet1 == \"Jupiter\" && planet2 == \"Saturn\" {\n        planets\
    \ = [\"Saturn\"]\n    } else if planet1 == \"Saturn\" && planet2 == \"Uranus\"\
    \ {\n        planets = [\"Uranus\"]\n    } else if planet1 == \"Uranus\" && planet2\
    \ == \"Neptune\" {\n        planets = [\"Neptune\"]\n    } else {\n        return\
    \ planets\n    }\n    \n    return planets\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\") == [\"Saturn\", \"\
    Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\") == [\"Venus\"\
    ])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"Neptune\", planet2:\
    \ \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"])\n\
    assert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Makemake\") == [] as [String])"
  status: Exception
  stderr: 'tmpd32velsf/tmpd32velsf.swift:53: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b20ec535c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b20ec22cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b20ec22c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b20ec22b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpd32velsf                        0x00005570b6b255cb <unavailable> + 5579

    5    libc.so.6                          0x00002b20ec721460 __libc_start_main +
    245

    6    tmpd32velsf                        0x00005570b6b25179 <unavailable> + 4473

    '
  stdout: ''
  timestamp: 1659823230
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    var planets = [String]()\n\
    \    \n    guard let planet1Orbit = orbit(planet1) else {\n        return planets\n\
    \    }\n    guard let planet2Orbit = orbit(planet2) else {\n        return planets\n\
    \    }\n    \n    var orbit1 = planet1Orbit\n    var orbit2 = planet2Orbit\n \
    \   \n    while orbit1 != orbit2 {\n        planets.append(orbit1)\n        \n\
    \        if orbit1 == planet2 {\n            break\n        }\n        \n    \
    \    guard let nextOrbit = orbit(planet1) else {\n            return planets\n\
    \        }\n        \n        orbit1 = nextOrbit\n    }\n    \n    return planets\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\"\
    ) == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\"\
    ) == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"\
    Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\n\
    assert(bf(planet1: \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Makemake\") == [] as [String])"
  status: SyntaxError
  stderr: "/tmp/tmpujce22hu.swift:18:30: error: cannot find 'orbit' in scope\n   \
    \ guard let planet1Orbit = orbit(planet1) else {\n                           \
    \  ^~~~~\n/tmp/tmpujce22hu.swift:21:30: error: cannot find 'orbit' in scope\n\
    \    guard let planet2Orbit = orbit(planet2) else {\n                        \
    \     ^~~~~\n/tmp/tmpujce22hu.swift:35:31: error: cannot find 'orbit' in scope\n\
    \        guard let nextOrbit = orbit(planet1) else {\n                       \
    \       ^~~~~\n"
  stdout: ''
  timestamp: 1659823230
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    \n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\") == [\"\
    Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\") ==\
    \ [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"Venus\"\
    , \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"Neptune\"\
    , planet2: \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    ])\nassert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Makemake\") == [] as [String])"
  status: SyntaxError
  stderr: '/tmp/tmp3d9bvts2.swift:17:1: error: missing return in global function expected
    to return ''[String]''

    }

    ^

    '
  stdout: ''
  timestamp: 1659823230
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    \n    var planets\
    \ = [String]()\n    \n    if planet1 == planet2 {\n        return planets\n  \
    \  }\n    \n    if planet1 == \"Mercury\" || planet1 == \"Venus\" || planet1 ==\
    \ \"Earth\" || planet1 == \"Mars\" || planet1 == \"Jupiter\" || planet1 == \"\
    Saturn\" || planet1 == \"Uranus\" || planet1 == \"Neptune\" {\n        planets.append(planet1)\n\
    \    }\n    \n    if planet2 == \"Mercury\" || planet2 == \"Venus\" || planet2\
    \ == \"Earth\" || planet2 == \"Mars\" || planet2 == \"Jupiter\" || planet2 ==\
    \ \"Saturn\" || planet2 == \"Uranus\" || planet2 == \"Neptune\" {\n        planets.append(planet2)\n\
    \    }\n    \n    if planet1 == \"Mercury\" && planet2 == \"Venus\" {\n      \
    \  planets.append(planet1)\n        planets.append(planet2)\n    }\n    \n   \
    \ if planet1 == \"Venus\" && planet2 == \"Mercury\" {\n        planets.append(planet1)\n\
    \        planets.append(planet2)\n    }\n    \n    if planet1 == \"Earth\" &&\
    \ planet2 == \"Mercury\" {\n        planets.append(planet1)\n        planets.append(planet2)\n\
    \    }\n    \n    if planet1 == \"Mars\" && planet2 == \"Mercury\" {\n       \
    \ planets.append(planet1)\n        planets.append(planet2)\n    }\n    \n    if\
    \ planet1 == \"Jupiter\" && planet2 == \"Mercury\" {\n        planets.append(planet1)\n\
    \        planets.append(planet2)\n    }\n    \n    if planet1 == \"Saturn\" &&\
    \ planet2 == \"Mercury\" {\n        planets.append(planet1)\n        planets.append(planet2)\n\
    \    }\n    \n    if planet1 == \"Uranus\" && planet2 == \"Mercury\" {\n     \
    \   planets.append(planet1)\n        planets.append(planet2)\n    }\n    \n  \
    \  if planet1 == \"Neptune\" && planet2 == \"Mercury\" {\n        planets.append(planet1)\n\
    \        planets.append(planet2)\n    }\n    \n    if planet1 == \"Mercury\" &&\
    \ planet2 == \"Earth\" {\n        planets.append(planet1)\n        \n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\"\
    ) == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\"\
    ) == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"\
    Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\n\
    assert(bf(planet1: \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Makemake\") == [] as [String])"
  status: SyntaxError
  stderr: "/tmp/tmpkgny6dnt.swift:95:70: error: expected '}' at end of brace statement\n\
    assert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") == [] as [String])\n  \
    \                                                                   ^\n/tmp/tmpkgny6dnt.swift:15:55:\
    \ note: to match this opening '{'\nfunc bf(planet1: String, planet2: String) ->\
    \ [String] {\n                                                      ^\n/tmp/tmpkgny6dnt.swift:77:6:\
    \ error: operator functions can only be declared at global or in type scope\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1659823230
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    var planets = [String]()\n\
    \    \n    // TODO: Write your code here\n    \n    return planets\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\"\
    ) == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\"\
    ) == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"\
    Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\n\
    assert(bf(planet1: \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Makemake\") == [] as [String])"
  status: Exception
  stderr: 'tmpqir0zopy/tmpqir0zopy.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b71b763fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b71b7336b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b71b7336988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b71b73357b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpqir0zopy                        0x00005603381a456b <unavailable> + 5483

    5    libc.so.6                          0x00002b71b782b460 __libc_start_main +
    245

    6    tmpqir0zopy                        0x00005603381a4119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659823230
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    var planets = [String]()\n\
    \    \n    if planet1 == \"Mercury\" || planet1 == \"Venus\" || planet1 == \"\
    Earth\" || planet1 == \"Mars\" || planet1 == \"Jupiter\" || planet1 == \"Saturn\"\
    \ || planet1 == \"Uranus\" || planet1 == \"Neptune\" {\n        planets.append(planet1)\n\
    \    }\n    \n    if planet2 == \"Mercury\" || planet2 == \"Venus\" || planet2\
    \ == \"Earth\" || planet2 == \"Mars\" || planet2 == \"Jupiter\" || planet2 ==\
    \ \"Saturn\" || planet2 == \"Uranus\" || planet2 == \"Neptune\" {\n        planets.append(planet2)\n\
    \    }\n    \n    if planet1 == planet2 {\n        planets.append(planet1)\n \
    \   }\n    \n    if planet1 == \"Mercury\" && planet2 == \"Venus\" {\n       \
    \ planets.append(planet1)\n        planets.append(planet2)\n    }\n    \n    if\
    \ planet1 == \"Venus\" && planet2 == \"Mercury\" {\n        planets.append(planet1)\n\
    \        planets.append(planet2)\n    }\n    \n    if planet1 == \"Earth\" &&\
    \ planet2 == \"Mars\" {\n        planets.append(planet1)\n        planets.append(planet2)\n\
    \    }\n    \n    if planet1 == \"Mars\" && planet2 == \"Earth\" {\n        planets.append(planet1)\n\
    \        planets.append(planet2)\n    }\n    \n    if planet1 == \"Jupiter\" &&\
    \ planet2 == \"Saturn\" {\n        planets.append(planet1)\n        planets.append(planet2)\n\
    \    }\n    \n    if planet1 == \"Saturn\" && planet2 == \"Jupiter\" {\n     \
    \   planets.append(planet1)\n        planets.append(planet2)\n    }\n    \n  \
    \  if planet1 == \"Uranus\" && planet2 == \"Neptune\" {\n        planets.append(planet1)\n\
    \        planets.append(planet2)\n    }\n    \n    if planet1 == \"Neptune\" &&\
    \ planet2 == \"Uranus\" {\n        planets.append(planet1)\n        planets.append(planet2)\n\
    \    }\n    \n    if planet1 == \"Mercury\" && planet2 == \"Earth\" {\n      \
    \  planets.append(planet1)\n        planets.append(\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\") == [\"Saturn\"\
    , \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\") == [\"Venus\"\
    ])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"Neptune\", planet2:\
    \ \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"])\n\
    assert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Makemake\") == [] as [String])"
  status: SyntaxError
  stderr: "/tmp/tmplw2ltfq7.swift:73:1: error: expected expression in list of expressions\n\
    }\n^\n/tmp/tmplw2ltfq7.swift:94:70: error: expected '}' at end of brace statement\n\
    assert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") == [] as [String])\n  \
    \                                                                   ^\n/tmp/tmplw2ltfq7.swift:15:55:\
    \ note: to match this opening '{'\nfunc bf(planet1: String, planet2: String) ->\
    \ [String] {\n                                                      ^\n/tmp/tmplw2ltfq7.swift:72:23:\
    \ error: missing argument for parameter #1 in call\n        planets.append(\n\
    \                      ^\n                      <#String#>\nSwift.Array:6:37:\
    \ note: 'append' declared here\n    @inlinable public mutating func append(_ newElement:\
    \ __owned Element)\n                                    ^\n/tmp/tmplw2ltfq7.swift:76:6:\
    \ error: operator functions can only be declared at global or in type scope\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1659823230
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    var planets = [String]()\n\
    \    \n    if planet1 == planet2 {\n        return planets\n    }\n    \n    let\
    \ planet1Orbit = orbit(planet1)\n    let planet2Orbit = orbit(planet2)\n    \n\
    \    if planet1Orbit == planet2Orbit {\n        return planets\n    }\n    \n\
    \    let planet1OrbitToSun = planet1Orbit - sun\n    let planet2OrbitToSun = planet2Orbit\
    \ - sun\n    \n    if planet1OrbitToSun < planet2OrbitToSun {\n        planets.append(planet1)\n\
    \        planets.append(planet2)\n    } else {\n        planets.append(planet2)\n\
    \        planets.append(planet1)\n    }\n    \n    return planets\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\"\
    ) == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\"\
    ) == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"\
    Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\n\
    assert(bf(planet1: \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Makemake\") == [] as [String])"
  status: SyntaxError
  stderr: "/tmp/tmp9bweuujz.swift:22:24: error: cannot find 'orbit' in scope\n   \
    \ let planet1Orbit = orbit(planet1)\n                       ^~~~~\n/tmp/tmp9bweuujz.swift:23:24:\
    \ error: cannot find 'orbit' in scope\n    let planet2Orbit = orbit(planet2)\n\
    \                       ^~~~~\n/tmp/tmp9bweuujz.swift:29:44: error: cannot find\
    \ 'sun' in scope\n    let planet1OrbitToSun = planet1Orbit - sun\n           \
    \                                ^~~\n/tmp/tmp9bweuujz.swift:30:44: error: cannot\
    \ find 'sun' in scope\n    let planet2OrbitToSun = planet2Orbit - sun\n      \
    \                                     ^~~\n"
  stdout: ''
  timestamp: 1659823230
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    \n    var planets\
    \ = [String]()\n    \n    if planet1 == planet2 {\n        return planets\n  \
    \  }\n    \n    if planet1 == \"Mercury\" && planet2 == \"Earth\" {\n        planets\
    \ = [\"Venus\"]\n    } else if planet1 == \"Venus\" && planet2 == \"Earth\" {\n\
    \        planets = [\"Mercury\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    } else if planet1 == \"Mars\" && planet2 == \"Earth\" {\n\
    \        planets = [\"Mercury\", \"Venus\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    } else if planet1 == \"Jupiter\" && planet2 == \"Earth\" {\n\
    \        planets = [\"Mercury\", \"Venus\", \"Mars\", \"Saturn\", \"Uranus\",\
    \ \"Neptune\"]\n    } else if planet1 == \"Saturn\" && planet2 == \"Earth\" {\n\
    \        planets = [\"Mercury\", \"Venus\", \"Mars\", \"Jupiter\", \"Uranus\"\
    , \"Neptune\"]\n    } else if planet1 == \"Uranus\" && planet2 == \"Earth\" {\n\
    \        planets = [\"Mercury\", \"Venus\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Neptune\"]\n    } else if planet1 == \"Neptune\" && planet2 == \"Earth\" {\n\
    \        planets = [\"Mercury\", \"Venus\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\"]\n    } else if planet1 == \"Mercury\" && planet2 == \"Mars\" {\n\
    \        planets = [\"Venus\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    ]\n    } else if planet1 == \"Venus\" && planet2 == \"Mars\" {\n        planets\
    \ = [\"Mercury\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"]\n    } else\
    \ if planet1 == \"Mars\" && planet2 == \"Mars\" {\n        planets = [\"Mercury\"\
    , \"Venus\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"]\n    } else if\
    \ planet1 == \"Jupiter\" && planet2 == \"Mars\" {\n        planets = [\"Mercury\"\
    , \"Venus\", \"Mars\", \"Saturn\", \"Uranus\", \"Neptune\"]\n    } else if planet1\
    \ == \"Saturn\" && planet2 == \"Mars\" {\n        \n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\") == [\"Saturn\"\
    , \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\") == [\"Venus\"\
    ])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"Neptune\", planet2:\
    \ \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"])\n\
    assert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Makemake\") == [] as [String])"
  status: SyntaxError
  stderr: "/tmp/tmplejh6e7b.swift:68:70: error: expected '}' at end of brace statement\n\
    assert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") == [] as [String])\n  \
    \                                                                   ^\n/tmp/tmplejh6e7b.swift:15:55:\
    \ note: to match this opening '{'\nfunc bf(planet1: String, planet2: String) ->\
    \ [String] {\n                                                      ^\n/tmp/tmplejh6e7b.swift:50:6:\
    \ error: operator functions can only be declared at global or in type scope\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1659823230
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    \n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\") == [\"\
    Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\") ==\
    \ [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"Venus\"\
    , \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"Neptune\"\
    , planet2: \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    ])\nassert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Makemake\") == [] as [String])"
  status: SyntaxError
  stderr: '/tmp/tmp3d9bvts2.swift:17:1: error: missing return in global function expected
    to return ''[String]''

    }

    ^

    '
  stdout: ''
  timestamp: 1659823230
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    var planets = [String]()\n\
    \    \n    guard let planet1Orbit = orbit(planet1) else {\n        return planets\n\
    \    }\n    guard let planet2Orbit = orbit(planet2) else {\n        return planets\n\
    \    }\n    \n    let planet1Sun = planet1Orbit.sun\n    let planet2Sun = planet2Orbit.sun\n\
    \    \n    let planet1OrbitSun = planet1Orbit.orbit(planet1Sun)\n    let planet2OrbitSun\
    \ = planet2Orbit.orbit(planet2Sun)\n    \n    let planet1OrbitSunDistance = planet1OrbitSun.distance(planet2OrbitSun)\n\
    \    let planet2OrbitSunDistance = planet2OrbitSun.distance(planet1OrbitSun)\n\
    \    \n    if planet1OrbitSunDistance < planet2OrbitSunDistance {\n        planets.append(planet1)\n\
    \        planets.append(planet2)\n    } else {\n        planets.append(planet2)\n\
    \        planets.append(planet1)\n    }\n    \n    return planets\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\"\
    ) == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\"\
    ) == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"\
    Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\n\
    assert(bf(planet1: \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Makemake\") == [] as [String])"
  status: SyntaxError
  stderr: "/tmp/tmp7okft_o_.swift:18:30: error: cannot find 'orbit' in scope\n   \
    \ guard let planet1Orbit = orbit(planet1) else {\n                           \
    \  ^~~~~\n/tmp/tmp7okft_o_.swift:21:30: error: cannot find 'orbit' in scope\n\
    \    guard let planet2Orbit = orbit(planet2) else {\n                        \
    \     ^~~~~\n"
  stdout: ''
  timestamp: 1659823230
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    var result: [String]\
    \ = []\n    \n    if planet1 == planet2 {\n        return result\n    }\n    \n\
    \    var orbit1 = orbit(planet1)\n    var orbit2 = orbit(planet2)\n    \n    if\
    \ orbit1 == nil {\n        return result\n    }\n    \n    if orbit2 == nil {\n\
    \        return result\n    }\n    \n    if orbit1!.distance < orbit2!.distance\
    \ {\n        result.insert(planet1, atIndex(orbit1!.index))\n    } else {\n  \
    \      result.insert(planet2, atIndex(orbit2!.index))\n    }\n    \n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2:\
    \ \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\n\
    assert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"\
    Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\")\
    \ == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: SyntaxError
  stderr: "/tmp/tmpuacrc1w4.swift:22:18: error: cannot find 'orbit' in scope\n   \
    \ var orbit1 = orbit(planet1)\n                 ^~~~~\n/tmp/tmpuacrc1w4.swift:23:18:\
    \ error: cannot find 'orbit' in scope\n    var orbit2 = orbit(planet2)\n     \
    \            ^~~~~\n/tmp/tmpuacrc1w4.swift:34:32: error: cannot find 'atIndex'\
    \ in scope\n        result.insert(planet1, atIndex(orbit1!.index))\n         \
    \                      ^~~~~~~\n/tmp/tmpuacrc1w4.swift:34:16: error: no exact\
    \ matches in call to instance method 'insert'\n        result.insert(planet1,\
    \ atIndex(orbit1!.index))\n               ^\n/tmp/tmpuacrc1w4.swift:34:16: note:\
    \ found candidate with type '(__owned String, Int) -> ()'\n        result.insert(planet1,\
    \ atIndex(orbit1!.index))\n               ^\n/tmp/tmpuacrc1w4.swift:36:32: error:\
    \ cannot find 'atIndex' in scope\n        result.insert(planet2, atIndex(orbit2!.index))\n\
    \                               ^~~~~~~\n/tmp/tmpuacrc1w4.swift:36:16: error:\
    \ no exact matches in call to instance method 'insert'\n        result.insert(planet2,\
    \ atIndex(orbit2!.index))\n               ^\n/tmp/tmpuacrc1w4.swift:36:16: note:\
    \ found candidate with type '(__owned String, Int) -> ()'\n        result.insert(planet2,\
    \ atIndex(orbit2!.index))\n               ^\n"
  stdout: ''
  timestamp: 1659823230
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    \n    var planets\
    \ = [String]()\n    \n    if planet1 == planet2 {\n        return planets\n  \
    \  }\n    \n    let planet1Orbit = planet1Orbit(planet1)\n    let planet2Orbit\
    \ = planet2Orbit(planet2)\n    \n    if planet1Orbit == planet2Orbit {\n     \
    \   return planets\n    }\n    \n    let planet1Orbits = planet1Orbits(planet1)\n\
    \    let planet2Orbits = planet2Orbits(planet2)\n    \n    if planet1Orbits.count\
    \ > 0 && planet2Orbits.count > 0 {\n        let planet1OrbitIndex = planet1Orbits.index(of:\
    \ planet1Orbit)!\n        let planet2OrbitIndex = planet2Orbits.index(of: planet2Orbit)!\n\
    \        \n        let planet1OrbitDistance = planet1Orbits[planet1OrbitIndex]\
    \ - planet1Orbit\n        let planet2OrbitDistance = planet2Orbits[planet2OrbitIndex]\
    \ - planet2Orbit\n        \n        let planet1OrbitDistanceSquared = planet1OrbitDistance\
    \ * planet1OrbitDistance\n        let planet2OrbitDistanceSquared = planet2OrbitDistance\
    \ * planet2OrbitDistance\n        \n        let planet1OrbitDistanceSquaredMinusPlanet2OrbitDistance\
    \ = planet1OrbitDistanceSquared - planet2OrbitDistanceSquared\n        \n    \
    \    if planet1OrbitDistanceSquaredMinusPlanet2OrbitDistance < 0 {\n         \
    \   planets.append(planet1)\n        }\n        \n        if planet1OrbitDistanceSquaredMinusPlanet2OrbitDistance\
    \ > 0 {\n            planets.append(planet2)\n        }\n    }\n    \n    return\
    \ planets\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2:\
    \ \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\n\
    assert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"\
    Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\")\
    \ == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: SyntaxError
  stderr: "/tmp/tmpeljs2i93.swift:23:24: error: use of local variable 'planet1Orbit'\
    \ before its declaration\n    let planet1Orbit = planet1Orbit(planet1)\n     \
    \                  ^\n/tmp/tmpeljs2i93.swift:23:9: note: 'planet1Orbit' declared\
    \ here\n    let planet1Orbit = planet1Orbit(planet1)\n        ^\n/tmp/tmpeljs2i93.swift:24:24:\
    \ error: use of local variable 'planet2Orbit' before its declaration\n    let\
    \ planet2Orbit = planet2Orbit(planet2)\n                       ^\n/tmp/tmpeljs2i93.swift:24:9:\
    \ note: 'planet2Orbit' declared here\n    let planet2Orbit = planet2Orbit(planet2)\n\
    \        ^\n/tmp/tmpeljs2i93.swift:30:25: error: use of local variable 'planet1Orbits'\
    \ before its declaration\n    let planet1Orbits = planet1Orbits(planet1)\n   \
    \                     ^\n/tmp/tmpeljs2i93.swift:30:9: note: 'planet1Orbits' declared\
    \ here\n    let planet1Orbits = planet1Orbits(planet1)\n        ^\n/tmp/tmpeljs2i93.swift:31:25:\
    \ error: use of local variable 'planet2Orbits' before its declaration\n    let\
    \ planet2Orbits = planet2Orbits(planet2)\n                        ^\n/tmp/tmpeljs2i93.swift:31:9:\
    \ note: 'planet2Orbits' declared here\n    let planet2Orbits = planet2Orbits(planet2)\n\
    \        ^\n"
  stdout: ''
  timestamp: 1659823230
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    \n    var planets\
    \ = [String]()\n    \n    if planet1 == planet2 {\n        return planets\n  \
    \  }\n    \n    if planet1 == \"Mercury\" || planet1 == \"Venus\" || planet1 ==\
    \ \"Earth\" || planet1 == \"Mars\" || planet1 == \"Jupiter\" || planet1 == \"\
    Saturn\" || planet1 == \"Uranus\" || planet1 == \"Neptune\" {\n        planets.append(planet1)\n\
    \    }\n    \n    if planet2 == \"Mercury\" || planet2 == \"Venus\" || planet2\
    \ == \"Earth\" || planet2 == \"Mars\" || planet2 == \"Jupiter\" || planet2 ==\
    \ \"Saturn\" || planet2 == \"Uranus\" || planet2 == \"Neptune\" {\n        planets.append(planet2)\n\
    \    }\n    \n    if planet1 == \"Mercury\" && planet2 == \"Venus\" {\n      \
    \  planets.append(\"Earth\")\n    }\n    \n    if planet1 == \"Mercury\" && planet2\
    \ == \"Earth\" {\n        planets.append(\"Mars\")\n    }\n    \n    if planet1\
    \ == \"Mercury\" && planet2 == \"Mars\" {\n        planets.append(\"Jupiter\"\
    )\n    }\n    \n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n  \
    \      planets.append(\"Saturn\")\n    }\n    \n    if planet1 == \"Mercury\"\
    \ && planet2 == \"Saturn\" {\n        planets.append(\"Uranus\")\n    }\n    \n\
    \    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets.append(\"\
    Neptune\")\n    }\n    \n    if planet1 == \"Venus\" && planet2 == \"Earth\" {\n\
    \        planets.append(\"Mercury\")\n    }\n    \n    if planet1 == \"Venus\"\
    \ && planet2 == \"Mercury\" {\n        planets.append(\"Mars\")\n    }\n    \n\
    \    if planet1 == \"Venus\" && planet2 == \"Mars\" {\n        planets.append(\"\
    Jupiter\")\n    }\n    \n    if planet1 == \"Venus\" && planet2 == \"Jupiter\"\
    \ {\n        planets.append(\"Saturn\")\n    }\n    \n    if planet1 == \"Venus\"\
    \ && planet2 == \"Saturn\" {\n        planets.append(\"Uranus\")\n    }\n    \n\
    \    if planet1 == \"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1:\
    \ \"Earth\", planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\"\
    , planet2: \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    ])\nassert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2:\
    \ \"Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\"\
    ) == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: SyntaxError
  stderr: "/tmp/tmpev3dpe2o.swift:75:19: error: unterminated string literal\n    if\
    \ planet1 == \"\n                  ^\n"
  stdout: ''
  timestamp: 1659823230
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    \n    var planets\
    \ = [String]()\n    \n    if planet1 == planet2 {\n        return planets\n  \
    \  }\n    \n    if planet1 == \"Mercury\" || planet1 == \"Venus\" || planet1 ==\
    \ \"Earth\" || planet1 == \"Mars\" || planet1 == \"Jupiter\" || planet1 == \"\
    Saturn\" || planet1 == \"Uranus\" || planet1 == \"Neptune\" {\n        planets.append(planet1)\n\
    \    }\n    \n    if planet2 == \"Mercury\" || planet2 == \"Venus\" || planet2\
    \ == \"Earth\" || planet2 == \"Mars\" || planet2 == \"Jupiter\" || planet2 ==\
    \ \"Saturn\" || planet2 == \"Uranus\" || planet2 == \"Neptune\" {\n        planets.append(planet2)\n\
    \    }\n    \n    if planet1 == \"Mercury\" && planet2 == \"Venus\" {\n      \
    \  planets.append(planet1)\n        planets.append(planet2)\n    }\n    \n   \
    \ if planet1 == \"Venus\" && planet2 == \"Mercury\" {\n        planets.append(planet1)\n\
    \        planets.append(planet2)\n    }\n    \n    if planet1 == \"Earth\" &&\
    \ planet2 == \"Mercury\" {\n        planets.append(planet1)\n        planets.append(planet2)\n\
    \    }\n    \n    if planet1 == \"Mars\" && planet2 == \"Mercury\" {\n       \
    \ planets.append(planet1)\n        planets.append(planet2)\n    }\n    \n    if\
    \ planet1 == \"Jupiter\" && planet2 == \"Mercury\" {\n        planets.append(planet1)\n\
    \        planets.append(planet2)\n    }\n    \n    if planet1 == \"Saturn\" &&\
    \ planet2 == \"Mercury\" {\n        planets.append(planet1)\n        planets.append(planet2)\n\
    \    }\n    \n    if planet1 == \"Uranus\" && planet2 == \"Mercury\" {\n     \
    \   planets.append(planet1)\n        planets.append(planet2)\n    }\n    \n  \
    \  if planet1 == \"Neptune\" && planet2 == \"Mercury\" {\n        planets.append(planet1)\n\
    \        planets.append(planet2)\n    }\n    \n    if planet1 == \"Mercury\" &&\
    \ planet2 == \"Earth\" {\n        planets.append(planet1)\n        \n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\"\
    ) == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\"\
    ) == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"\
    Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\n\
    assert(bf(planet1: \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Makemake\") == [] as [String])"
  status: SyntaxError
  stderr: "/tmp/tmpkgny6dnt.swift:95:70: error: expected '}' at end of brace statement\n\
    assert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") == [] as [String])\n  \
    \                                                                   ^\n/tmp/tmpkgny6dnt.swift:15:55:\
    \ note: to match this opening '{'\nfunc bf(planet1: String, planet2: String) ->\
    \ [String] {\n                                                      ^\n/tmp/tmpkgny6dnt.swift:77:6:\
    \ error: operator functions can only be declared at global or in type scope\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1659823230
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    \n    var planets\
    \ = [String]()\n    \n    if planet1 == \"Mercury\" && planet2 == \"Earth\" {\n\
    \        planets = [\"Venus\"]\n    } else if planet1 == \"Venus\" && planet2\
    \ == \"Earth\" {\n        planets = [\"Mercury\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\", \"Neptune\"]\n    } else if planet1 == \"Earth\" && planet2 == \"\
    Mercury\" {\n        planets = [\"Venus\", \"Mars\", \"Jupiter\", \"Saturn\",\
    \ \"Uranus\", \"Neptune\"]\n    } else if planet1 == \"Mars\" && planet2 == \"\
    Earth\" {\n        planets = [\"Venus\", \"Mercury\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\", \"Neptune\"]\n    } else if planet1 == \"Jupiter\" && planet2 ==\
    \ \"Earth\" {\n        planets = [\"Venus\", \"Mercury\", \"Mars\", \"Saturn\"\
    , \"Uranus\", \"Neptune\"]\n    } else if planet1 == \"Saturn\" && planet2 ==\
    \ \"Earth\" {\n        planets = [\"Venus\", \"Mercury\", \"Mars\", \"Jupiter\"\
    , \"Uranus\", \"Neptune\"]\n    } else if planet1 == \"Uranus\" && planet2 ==\
    \ \"Earth\" {\n        planets = [\"Venus\", \"Mercury\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Neptune\"]\n    } else if planet1 == \"Neptune\" && planet2 ==\
    \ \"Earth\" {\n        planets = [\"Venus\", \"Mercury\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"]\n    } else if planet1 == \"Mercury\" && planet2 ==\
    \ \"Mars\" {\n        planets = [\"Venus\", \"Mercury\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\", \"Neptune\"]\n    } else if planet1 == \"Venus\" && planet2 == \"\
    Mars\" {\n        planets = [\"Mercury\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    } else if planet1 == \"Earth\" && planet2 == \"Mars\" {\n\
    \        planets = [\"Mercury\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    ]\n    } else if planet1 == \"Mars\" && planet2 == \"Mars\" {\n        planets\
    \ = [\"Mercury\", \"Jupiter\", \"Saturn\", \"Uranus\", \"\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\") == [\"\
    Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\") ==\
    \ [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"Venus\"\
    , \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"Neptune\"\
    , planet2: \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    ])\nassert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Makemake\") == [] as [String])"
  status: SyntaxError
  stderr: "/tmp/tmp4sjhhlq9.swift:42:62: error: unterminated string literal\n    \
    \    planets = [\"Mercury\", \"Jupiter\", \"Saturn\", \"Uranus\", \"\n       \
    \                                                      ^\n/tmp/tmp4sjhhlq9.swift:64:70:\
    \ error: expected '}' at end of brace statement\nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Makemake\") == [] as [String])\n                                \
    \                                     ^\n/tmp/tmp4sjhhlq9.swift:15:55: note: to\
    \ match this opening '{'\nfunc bf(planet1: String, planet2: String) -> [String]\
    \ {\n                                                      ^\n/tmp/tmp4sjhhlq9.swift:46:6:\
    \ error: operator functions can only be declared at global or in type scope\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n/tmp/tmp4sjhhlq9.swift:17:9:\
    \ warning: variable 'planets' was written to, but never read\n    var planets\
    \ = [String]()\n        ^\n"
  stdout: ''
  timestamp: 1659823230
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    var planets = [String]()\n\
    \    \n    if planet1 == planet2 {\n        return planets\n    }\n    \n    if\
    \ planet1 == \"Mercury\" || planet1 == \"Venus\" || planet1 == \"Earth\" || planet1\
    \ == \"Mars\" || planet1 == \"Jupiter\" || planet1 == \"Saturn\" || planet1 ==\
    \ \"Uranus\" || planet1 == \"Neptune\" {\n        planets.append(planet1)\n  \
    \  }\n    \n    if planet2 == \"Mercury\" || planet2 == \"Venus\" || planet2 ==\
    \ \"Earth\" || planet2 == \"Mars\" || planet2 == \"Jupiter\" || planet2 == \"\
    Saturn\" || planet2 == \"Uranus\" || planet2 == \"Neptune\" {\n        planets.append(planet2)\n\
    \    }\n    \n    if planet1 == \"Mercury\" && planet2 == \"Venus\" {\n      \
    \  planets.append(planet1)\n        planets.append(planet2)\n    }\n    \n   \
    \ if planet1 == \"Venus\" && planet2 == \"Mercury\" {\n        planets.append(planet1)\n\
    \        planets.append(planet2)\n    }\n    \n    if planet1 == \"Earth\" &&\
    \ planet2 == \"Mars\" {\n        planets.append(planet1)\n        planets.append(planet2)\n\
    \    }\n    \n    if planet1 == \"Mars\" && planet2 == \"Earth\" {\n        planets.append(planet1)\n\
    \        planets.append(planet2)\n    }\n    \n    if planet1 == \"Jupiter\" &&\
    \ planet2 == \"Saturn\" {\n        planets.append(planet1)\n        planets.append(planet2)\n\
    \    }\n    \n    if planet1 == \"Saturn\" && planet2 == \"Jupiter\" {\n     \
    \   planets.append(planet1)\n        planets.append(planet2)\n    }\n    \n  \
    \  if planet1 == \"Uranus\" && planet2 == \"Neptune\" {\n        planets.append(planet1)\n\
    \        planets.append(planet2)\n    }\n    \n    if planet1 == \"Neptune\" &&\
    \ planet2 == \"Uranus\" {\n        planets.append(planet1)\n        planets.append(planet2)\n\
    \    }\n    \n    if planet1 == \"Mercury\" && planet2 == \"Earth\" {\n      \
    \  planets.append(planet1)\n        planets.append(planet2)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\") == [\"\
    Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\") ==\
    \ [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"Venus\"\
    , \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"Neptune\"\
    , planet2: \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    ])\nassert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Makemake\") == [] as [String])"
  status: SyntaxError
  stderr: "/tmp/tmpbb3b92n7.swift:94:70: error: expected '}' at end of brace statement\n\
    assert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") == [] as [String])\n  \
    \                                                                   ^\n/tmp/tmpbb3b92n7.swift:15:55:\
    \ note: to match this opening '{'\nfunc bf(planet1: String, planet2: String) ->\
    \ [String] {\n                                                      ^\n/tmp/tmpbb3b92n7.swift:76:6:\
    \ error: operator functions can only be declared at global or in type scope\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1659823230
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    var planets = [String]()\n\
    \    \n    // TODO: Write your code here\n    \n    return planets\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\"\
    ) == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\"\
    ) == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"\
    Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\n\
    assert(bf(planet1: \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Makemake\") == [] as [String])"
  status: Exception
  stderr: 'tmpqir0zopy/tmpqir0zopy.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b71b763fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b71b7336b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b71b7336988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b71b73357b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpqir0zopy                        0x00005603381a456b <unavailable> + 5483

    5    libc.so.6                          0x00002b71b782b460 __libc_start_main +
    245

    6    tmpqir0zopy                        0x00005603381a4119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659823230
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    var result: [String]\
    \ = []\n    \n    if planet1 == planet2 {\n        return result\n    }\n    \n\
    \    if planet1 == \"Sun\" {\n        return planet2 == planet1 ? result : [planet1,\
    \ planet2]\n    }\n    \n    if planet2 == \"Sun\" {\n        return planet1 ==\
    \ planet2 ? result : [planet1, planet2]\n    }\n    \n    if planet1 == \"Mercury\"\
    \ {\n        return bf(\"Venus\", planet2)\n    }\n    \n    if planet2 == \"\
    Mercury\" {\n        return bf(\"Venus\", planet1)\n    }\n    \n    if planet1\
    \ == \"Venus\" {\n        return bf(\"Earth\", planet2)\n    }\n    \n    if planet2\
    \ == \"Venus\" {\n        return bf(\"Earth\", planet1)\n    }\n    \n    if planet1\
    \ == \"Earth\" {\n        return bf(\"Mars\", planet2)\n    }\n    \n    if planet2\
    \ == \"Earth\" {\n        return bf(\"Mars\", planet1)\n    }\n    \n    if planet1\
    \ == \"Mars\" {\n        return bf(\"Jupiter\", planet2)\n    }\n    \n    if\
    \ planet2 == \"Mars\" {\n        return bf(\"Jupiter\", planet1)\n    }\n    \n\
    \    if planet1 == \"Jupiter\" {\n        return bf(\"Saturn\", planet2)\n   \
    \ }\n    \n    if planet2 == \"Jupiter\" {\n        return bf(\"Saturn\", planet1)\n\
    \    }\n    \n    if planet1 == \"Saturn\" {\n        return bf(\"Uranus\", planet2)\n\
    \    }\n    \n    if planet2 == \"Saturn\" {\n        return bf(\"Uranus\", planet1)\n\
    \    }\n    \n    if planet1 == \"Uranus\" {\n        return bf(\"Neptune\", planet2)\n\
    \    }\n    \n    if planet2 == \"Uranus\" {\n        return bf(\"Neptune\", planet1)\n\
    \    }\n    \n    if planet1 == \"Neptune\" {\n        return result\n    }\n\
    \    \n    if planet2 == \"Neptune\" {\n        return result\n    }\n    \n \
    \   return []\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2:\
    \ \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\n\
    assert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"\
    Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\")\
    \ == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: SyntaxError
  stderr: "/tmp/tmpst95pama.swift:31:18: error: missing argument labels 'planet1:planet2:'\
    \ in call\n        return bf(\"Venus\", planet2)\n                 ^\n       \
    \           planet1: planet2: \n/tmp/tmpst95pama.swift:35:18: error: missing argument\
    \ labels 'planet1:planet2:' in call\n        return bf(\"Venus\", planet1)\n \
    \                ^\n                  planet1: planet2: \n/tmp/tmpst95pama.swift:39:18:\
    \ error: missing argument labels 'planet1:planet2:' in call\n        return bf(\"\
    Earth\", planet2)\n                 ^\n                  planet1: planet2: \n\
    /tmp/tmpst95pama.swift:43:18: error: missing argument labels 'planet1:planet2:'\
    \ in call\n        return bf(\"Earth\", planet1)\n                 ^\n       \
    \           planet1: planet2: \n/tmp/tmpst95pama.swift:47:18: error: missing argument\
    \ labels 'planet1:planet2:' in call\n        return bf(\"Mars\", planet2)\n  \
    \               ^\n                  planet1:  planet2: \n/tmp/tmpst95pama.swift:51:18:\
    \ error: missing argument labels 'planet1:planet2:' in call\n        return bf(\"\
    Mars\", planet1)\n                 ^\n                  planet1:  planet2: \n\
    /tmp/tmpst95pama.swift:55:18: error: missing argument labels 'planet1:planet2:'\
    \ in call\n        return bf(\"Jupiter\", planet2)\n                 ^\n     \
    \             planet1:   planet2: \n/tmp/tmpst95pama.swift:59:18: error: missing\
    \ argument labels 'planet1:planet2:' in call\n        return bf(\"Jupiter\", planet1)\n\
    \                 ^\n                  planet1:   planet2: \n/tmp/tmpst95pama.swift:63:18:\
    \ error: missing argument labels 'planet1:planet2:' in call\n        return bf(\"\
    Saturn\", planet2)\n                 ^\n                  planet1:  planet2: \n\
    /tmp/tmpst95pama.swift:67:18: error: missing argument labels 'planet1:planet2:'\
    \ in call\n        return bf(\"Saturn\", planet1)\n                 ^\n      \
    \            planet1:  planet2: \n/tmp/tmpst95pama.swift:71:18: error: missing\
    \ argument labels 'planet1:planet2:' in call\n        return bf(\"Uranus\", planet2)\n\
    \                 ^\n                  planet1:  planet2: \n/tmp/tmpst95pama.swift:75:18:\
    \ error: missing argument "
  stdout: ''
  timestamp: 1659823230
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    var planets = [String]()\n\
    \    \n    // TODO: Write your code here\n    \n    return planets\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\"\
    ) == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\"\
    ) == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"\
    Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\n\
    assert(bf(planet1: \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Makemake\") == [] as [String])"
  status: Exception
  stderr: 'tmpqir0zopy/tmpqir0zopy.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b71b763fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b71b7336b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b71b7336988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b71b73357b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpqir0zopy                        0x00005603381a456b <unavailable> + 5483

    5    libc.so.6                          0x00002b71b782b460 __libc_start_main +
    245

    6    tmpqir0zopy                        0x00005603381a4119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659823230
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    \n    // TODO: Write\
    \ your code here\n    \n    return []\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(bf(planet1: \"Jupiter\", planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"\
    ])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1:\
    \ \"Mercury\", planet2: \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"])\nassert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2:\
    \ \"Earth\") == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\"\
    ) == [] as [String])"
  status: Exception
  stderr: 'tmpbyjxxbwz/tmpbyjxxbwz.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b81eae97c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b81eab8eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b81eab8e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b81eab8d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpbyjxxbwz                        0x000055fa1b6d651b <unavailable> + 5403

    5    libc.so.6                          0x00002b81eb083460 __libc_start_main +
    245

    6    tmpbyjxxbwz                        0x000055fa1b6d60c9 <unavailable> + 4297

    '
  stdout: ''
  timestamp: 1659823230
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    \n    var planets\
    \ = [String]()\n    \n    if planet1 == planet2 {\n        return planets\n  \
    \  }\n    \n    if planet1 == \"Mercury\" {\n        planets = [\"Venus\", \"\
    Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"]\n    } else\
    \ if planet1 == \"Venus\" {\n        planets = [\"Mercury\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"]\n    } else if planet1 ==\
    \ \"Earth\" {\n        planets = [\"Mercury\", \"Venus\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\", \"Neptune\"]\n    } else if planet1 == \"Mars\" {\n\
    \        planets = [\"Mercury\", \"Venus\", \"Earth\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\", \"Neptune\"]\n    } else if planet1 == \"Jupiter\" {\n        planets\
    \ = [\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Saturn\", \"Uranus\", \"Neptune\"\
    ]\n    } else if planet1 == \"Saturn\" {\n        planets = [\"Mercury\", \"Venus\"\
    , \"Earth\", \"Mars\", \"Jupiter\", \"Uranus\", \"Neptune\"]\n    } else if planet1\
    \ == \"Uranus\" {\n        planets = [\"Mercury\", \"Venus\", \"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\", \"Neptune\"]\n    } else if planet1 == \"Neptune\"\
    \ {\n        planets = [\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"]\n    }\n    \n    if planet2 == \"Mercury\" {\n    \
    \    planets = [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    } else if planet2 == \"Venus\" {\n        planets = [\"Mercury\"\
    , \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"]\n   \
    \ } else if planet2 == \"Earth\" {\n        planets = [\"Mercury\", \"Venus\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"]\n    } else if planet2\
    \ == \"Mars\" {\n        planets = [\"Mercury\", \"Venus\", \"Earth\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\", \"Neptune\"]\n    \n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\") == [\"Saturn\", \"\
    Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\") == [\"Venus\"\
    ])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"Neptune\", planet2:\
    \ \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"])\n\
    assert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Makemake\") == [] as [String])"
  status: SyntaxError
  stderr: "/tmp/tmp4drxnrva.swift:71:70: error: expected '}' at end of brace statement\n\
    assert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") == [] as [String])\n  \
    \                                                                   ^\n/tmp/tmp4drxnrva.swift:15:55:\
    \ note: to match this opening '{'\nfunc bf(planet1: String, planet2: String) ->\
    \ [String] {\n                                                      ^\n/tmp/tmp4drxnrva.swift:53:6:\
    \ error: operator functions can only be declared at global or in type scope\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1659823230
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    var result = [String]()\n\
    \    \n    // TODO: Write your code here\n    \n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\"\
    ) == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\"\
    ) == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"\
    Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\n\
    assert(bf(planet1: \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Makemake\") == [] as [String])"
  status: Exception
  stderr: 'tmpeirebgxu/tmpeirebgxu.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b3a53e6fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3a53b66b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b3a53b66988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b3a53b657b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpeirebgxu                        0x0000555a58dcc56b <unavailable> + 5483

    5    libc.so.6                          0x00002b3a5405b460 __libc_start_main +
    245

    6    tmpeirebgxu                        0x0000555a58dcc119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659823230
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    \n    var planets\
    \ = [String]()\n    \n    if planet1 == planet2 {\n        return planets\n  \
    \  }\n    \n    if planet1 == \"Mercury\" || planet1 == \"Venus\" || planet1 ==\
    \ \"Earth\" || planet1 == \"Mars\" || planet1 == \"Jupiter\" || planet1 == \"\
    Saturn\" || planet1 == \"Uranus\" || planet1 == \"Neptune\" {\n        planets.append(planet1)\n\
    \    }\n    \n    if planet2 == \"Mercury\" || planet2 == \"Venus\" || planet2\
    \ == \"Earth\" || planet2 == \"Mars\" || planet2 == \"Jupiter\" || planet2 ==\
    \ \"Saturn\" || planet2 == \"Uranus\" || planet2 == \"Neptune\" {\n        planets.append(planet2)\n\
    \    }\n    \n    if planet1 == \"Mercury\" && planet2 == \"Venus\" {\n      \
    \  planets.append(planet1)\n        planets.append(planet2)\n    }\n    \n   \
    \ if planet1 == \"Venus\" && planet2 == \"Mercury\" {\n        planets.append(planet1)\n\
    \        planets.append(planet2)\n    }\n    \n    if planet1 == \"Earth\" &&\
    \ planet2 == \"Mars\" {\n        planets.append(planet1)\n        planets.append(planet2)\n\
    \    }\n    \n    if planet1 == \"Mars\" && planet2 == \"Earth\" {\n        planets.append(planet1)\n\
    \        planets.append(planet2)\n    }\n    \n    if planet1 == \"Jupiter\" &&\
    \ planet2 == \"Saturn\" {\n        planets.append(planet1)\n        planets.append(planet2)\n\
    \    }\n    \n    if planet1 == \"Saturn\" && planet2 == \"Jupiter\" {\n     \
    \   planets.append(planet1)\n        planets.append(planet2)\n    }\n    \n  \
    \  if planet1 == \"Uranus\" && planet2 == \"Neptune\" {\n        planets.append(planet1)\n\
    \        planets.append(planet2)\n    }\n    \n    if planet1 == \"Neptune\" &&\
    \ planet2 == \"Uranus\" {\n        planets.append(planet1)\n        planets.append(planet2)\n\
    \    }\n    \n    if planet1 == \"Mercury\" && planet2 == \"Earth\" {\n      \
    \  planets.append(planet1)\n        planets.append(plan\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\") == [\"\
    Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\") ==\
    \ [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"Venus\"\
    , \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"Neptune\"\
    , planet2: \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    ])\nassert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Makemake\") == [] as [String])"
  status: SyntaxError
  stderr: "/tmp/tmpifm6kcsp.swift:74:1: error: expected ')' in expression list\n}\n\
    ^\n/tmp/tmpifm6kcsp.swift:73:23: note: to match this opening '('\n        planets.append(plan\n\
    \                      ^\n/tmp/tmpifm6kcsp.swift:95:70: error: expected '}' at\
    \ end of brace statement\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\"\
    ) == [] as [String])\n                                                       \
    \              ^\n/tmp/tmpifm6kcsp.swift:15:55: note: to match this opening '{'\n\
    func bf(planet1: String, planet2: String) -> [String] {\n                    \
    \                                  ^\n/tmp/tmpifm6kcsp.swift:73:24: error: cannot\
    \ find 'plan' in scope\n        planets.append(plan\n                       ^~~~\n\
    /tmp/tmpifm6kcsp.swift:77:6: error: operator functions can only be declared at\
    \ global or in type scope\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n     ^\n"
  stdout: ''
  timestamp: 1659823230
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    \n    var planets\
    \ = [String]()\n    \n    if planet1 == planet2 {\n        return planets\n  \
    \  }\n    \n    if planet1 == \"Mercury\" && planet2 == \"Venus\" {\n        planets\
    \ = [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"]\n\
    \    }\n    \n    if planet1 == \"Venus\" && planet2 == \"Earth\" {\n        planets\
    \ = [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"]\n\
    \    }\n    \n    if planet1 == \"Mars\" && planet2 == \"Jupiter\" {\n       \
    \ planets = [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    ]\n    }\n    \n    if planet1 == \"Jupiter\" && planet2 == \"Saturn\" {\n   \
    \     planets = [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"\
    Neptune\"]\n    }\n    \n    if planet1 == \"Saturn\" && planet2 == \"Uranus\"\
    \ {\n        planets = [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    }\n    \n    if planet1 == \"Uranus\" && planet2 == \"Neptune\"\
    \ {\n        planets = [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    }\n    \n    if planet1 == \"Neptune\" && planet2 == \"Earth\"\
    \ {\n        planets = [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    }\n    \n    if planet1 == \"Earth\" && planet2 == \"Mars\"\
    \ {\n        planets = [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    }\n    \n    if planet1 == \"Mars\" && planet2 == \"Jupiter\"\
    \ {\n        planets = [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    }\n    \n    if planet1 == \"Jupiter\" && planet2 == \"Saturn\"\
    \ {\n        planets = [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    }\n    \n    if planet1 == \"Saturn\" && planet2 == \"Uranus\"\
    \ \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(bf(planet1: \"Jupiter\", planet2:\
    \ \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2:\
    \ \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\"\
    ) == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1:\
    \ \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\n\
    assert(bf(planet1: \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Makemake\") == [] as [String])"
  status: SyntaxError
  stderr: "/tmp/tmplgfxu8p5.swift:63:50: error: expected '{' after 'if' condition\n\
    \    if planet1 == \"Saturn\" && planet2 == \"Uranus\" \n                    \
    \                             ^\n"
  stdout: ''
  timestamp: 1659823230
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    \n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\") == [\"\
    Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\") ==\
    \ [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"Venus\"\
    , \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"Neptune\"\
    , planet2: \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    ])\nassert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Makemake\") == [] as [String])"
  status: SyntaxError
  stderr: '/tmp/tmp3d9bvts2.swift:17:1: error: missing return in global function expected
    to return ''[String]''

    }

    ^

    '
  stdout: ''
  timestamp: 1659823230
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    var result: [String]\
    \ = []\n    \n    if planet1 == \"Mercury\" || planet1 == \"Venus\" || planet1\
    \ == \"Earth\" || planet1 == \"Mars\" || planet1 == \"Jupiter\" || planet1 ==\
    \ \"Saturn\" || planet1 == \"Uranus\" || planet1 == \"Neptune\" {\n        if\
    \ planet2 == \"Mercury\" || planet2 == \"Venus\" || planet2 == \"Earth\" || planet2\
    \ == \"Mars\" || planet2 == \"Jupiter\" || planet2 == \"Saturn\" || planet2 ==\
    \ \"Uranus\" || planet2 == \"Neptune\" {\n            result = [planet1, planet2]\n\
    \        } else {\n            return result\n        }\n    } else {\n      \
    \  return result\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1:\
    \ \"Earth\", planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\"\
    , planet2: \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    ])\nassert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2:\
    \ \"Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\"\
    ) == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: SyntaxError
  stderr: '/tmp/tmpwa16p79i.swift:27:1: error: missing return in global function expected
    to return ''[String]''

    }

    ^

    '
  stdout: ''
  timestamp: 1659823230
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    \n    var planets\
    \ = [String]()\n    \n    if planet1 == planet2 {\n        planets.append(planet1)\n\
    \        return planets\n    }\n    \n    if planet1 == \"Mercury\" {\n      \
    \  planets.append(\"Earth\")\n        planets.append(\"Mars\")\n        planets.append(\"\
    Jupiter\")\n        planets.append(\"Saturn\")\n        planets.append(\"Uranus\"\
    )\n        planets.append(\"Neptune\")\n        return planets\n    }\n    \n\
    \    if planet1 == \"Venus\" {\n        planets.append(\"Earth\")\n        planets.append(\"\
    Mars\")\n        planets.append(\"Jupiter\")\n        planets.append(\"Saturn\"\
    )\n        planets.append(\"Uranus\")\n        planets.append(\"Neptune\")\n \
    \       return planets\n    }\n    \n    if planet1 == \"Earth\" {\n        planets.append(\"\
    Mars\")\n        planets.append(\"Jupiter\")\n        planets.append(\"Saturn\"\
    )\n        planets.append(\"Uranus\")\n        planets.append(\"Neptune\")\n \
    \       return planets\n    }\n    \n    if planet1 == \"Mars\" {\n        planets.append(\"\
    Jupiter\")\n        planets.append(\"Saturn\")\n        planets.append(\"Uranus\"\
    )\n        planets.append(\"Neptune\")\n        return planets\n    }\n    \n\
    \    if planet1 == \"Jupiter\" {\n        planets.append(\"Saturn\")\n       \
    \ planets.append(\"Uranus\")\n        planets.append(\"Neptune\")\n        return\
    \ planets\n    }\n    \n    if planet1 == \"Saturn\" {\n        planets.append(\"\
    Uranus\")\n        planets.append(\"Neptune\")\n        return planets\n    }\n\
    \    \n    if planet1 == \"Uranus\" {\n        planets.append(\"Neptune\")\n \
    \       return planets\n    }\n    \n    if planet1 == \"Neptune\" {\n       \
    \ return planets\n    }\n    \n    return planets\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\") == [\"Saturn\"\
    , \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\") == [\"Venus\"\
    ])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"Neptune\", planet2:\
    \ \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"])\n\
    assert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Makemake\") == [] as [String])"
  status: Exception
  stderr: 'tmppvrmfntm/tmppvrmfntm.swift:99: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b27ea87fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b27ea576b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b27ea576988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b27ea5757b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmppvrmfntm                        0x000055d471c4b62b <unavailable> + 5675

    5    libc.so.6                          0x00002b27eaa6b460 __libc_start_main +
    245

    6    tmppvrmfntm                        0x000055d471c4b1d9 <unavailable> + 4569

    '
  stdout: ''
  timestamp: 1659823230
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    var planets = [String]()\n\
    \    \n    if planet1 == planet2 {\n        return planets\n    }\n    \n    if\
    \ planet1 == \"Mercury\" {\n        planets.append(\"Venus\")\n    }\n    \n \
    \   if planet1 == \"Venus\" {\n        planets.append(\"Earth\")\n    }\n    \n\
    \    if planet1 == \"Earth\" {\n        planets.append(\"Mars\")\n    }\n    \n\
    \    if planet1 == \"Mars\" {\n        planets.append(\"Jupiter\")\n    }\n  \
    \  \n    if planet1 == \"Jupiter\" {\n        planets.append(\"Saturn\")\n   \
    \ }\n    \n    if planet1 == \"Saturn\" {\n        planets.append(\"Uranus\")\n\
    \    }\n    \n    if planet1 == \"Uranus\" {\n        planets.append(\"Neptune\"\
    )\n    }\n    \n    if planet1 == \"Neptune\" {\n        planets.append(\"Mercury\"\
    )\n    }\n    \n    if planet2 == \"Mercury\" {\n        planets.append(\"Venus\"\
    )\n    }\n    \n    if planet2 == \"Venus\" {\n        planets.append(\"Earth\"\
    )\n    }\n    \n    if planet2 == \"Earth\" {\n        planets.append(\"Mars\"\
    )\n    }\n    \n    if planet2 == \"Mars\" {\n        planets.append(\"Jupiter\"\
    )\n    }\n    \n    if planet2 == \"Jupiter\" {\n        planets.append(\"Saturn\"\
    )\n    }\n    \n    if planet2 == \"Saturn\" {\n        planets.append(\"Uranus\"\
    )\n    }\n    \n    if planet2 == \"Uranus\" {\n        planets.append(\"Neptune\"\
    )\n    }\n    \n    if planet2 == \"Neptune\" {\n        planets.append(\"Mercury\"\
    )\n    }\n    \n    return planets\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(bf(planet1: \"Jupiter\", planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"\
    ])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1:\
    \ \"Mercury\", planet2: \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"])\nassert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2:\
    \ \"Earth\") == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\"\
    ) == [] as [String])"
  status: Exception
  stderr: 'tmp01j43xsq/tmp01j43xsq.swift:102: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae180e98c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae180b8fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae180b8f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae180b8e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp01j43xsq                        0x0000557927d3362b <unavailable> + 5675

    5    libc.so.6                          0x00002ae181084460 __libc_start_main +
    245

    6    tmp01j43xsq                        0x0000557927d331d9 <unavailable> + 4569

    '
  stdout: ''
  timestamp: 1659823230
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    var result: [String]\
    \ = []\n    \n    if planet1 == planet2 {\n        return result\n    }\n    \n\
    \    let planet1Orbit = orbit(planet1)\n    let planet2Orbit = orbit(planet2)\n\
    \    \n    if planet1Orbit == planet2Orbit {\n        return result\n    }\n \
    \   \n    let planet1Sun = sunOrbit(planet1)\n    let planet2Sun = sunOrbit(planet2)\n\
    \    \n    if planet1Sun == planet2Sun {\n        return result\n    }\n    \n\
    \    let planet1SunDistance = distance(planet1, planet2)\n    let planet2SunDistance\
    \ = distance(planet2, planet1)\n    \n    if planet1SunDistance < planet2SunDistance\
    \ {\n        result.insert(planet1, at: 0)\n        result.insert(planet2, at:\
    \ 0)\n    } else {\n        result.insert(planet2, at: 0)\n        result.insert(planet1,\
    \ at: 0)\n    }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(bf(planet1: \"Jupiter\", planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"\
    ])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1:\
    \ \"Mercury\", planet2: \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"])\nassert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2:\
    \ \"Earth\") == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\"\
    ) == [] as [String])"
  status: SyntaxError
  stderr: "/tmp/tmpj6y0bkie.swift:22:24: error: cannot find 'orbit' in scope\n   \
    \ let planet1Orbit = orbit(planet1)\n                       ^~~~~\n/tmp/tmpj6y0bkie.swift:23:24:\
    \ error: cannot find 'orbit' in scope\n    let planet2Orbit = orbit(planet2)\n\
    \                       ^~~~~\n/tmp/tmpj6y0bkie.swift:29:22: error: cannot find\
    \ 'sunOrbit' in scope\n    let planet1Sun = sunOrbit(planet1)\n              \
    \       ^~~~~~~~\n/tmp/tmpj6y0bkie.swift:30:22: error: cannot find 'sunOrbit'\
    \ in scope\n    let planet2Sun = sunOrbit(planet2)\n                     ^~~~~~~~\n\
    /tmp/tmpj6y0bkie.swift:36:30: error: cannot find 'distance' in scope\n    let\
    \ planet1SunDistance = distance(planet1, planet2)\n                          \
    \   ^~~~~~~~\n/tmp/tmpj6y0bkie.swift:37:30: error: cannot find 'distance' in scope\n\
    \    let planet2SunDistance = distance(planet2, planet1)\n                   \
    \          ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659823230
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    var planets = [String]()\n\
    \    \n    switch planet1 {\n    case \"Mercury\":\n        planets = [\"Venus\"\
    , \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"]\n   \
    \ case \"Venus\":\n        planets = [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\", \"Neptune\"]\n    case \"Earth\":\n        planets = [\"Mars\",\
    \ \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"]\n    case \"Mars\":\n    \
    \    planets = [\"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"]\n    case \"\
    Jupiter\":\n        planets = [\"Saturn\", \"Uranus\", \"Neptune\"]\n    case\
    \ \"Saturn\":\n        planets = [\"Uranus\", \"Neptune\"]\n    case \"Uranus\"\
    :\n        planets = [\"Neptune\"]\n    case \"Neptune\":\n        planets = []\n\
    \    default:\n        return planets\n    }\n    \n    switch planet2 {\n   \
    \ case \"Mercury\":\n        planets = [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\", \"Neptune\"]\n    case \"Venus\":\n        planets =\
    \ [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"]\n  \
    \  case \"Earth\":\n        planets = [\"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    case \"Mars\":\n        planets = [\"Jupiter\", \"Saturn\"\
    , \"Uranus\", \"Neptune\"]\n    case \"Jupiter\":\n        planets = [\"Saturn\"\
    , \"Uranus\", \"Neptune\"]\n    case \"Saturn\":\n        planets = [\"Uranus\"\
    , \"Neptune\"]\n    case \"Uranus\":\n        planets = [\"Neptune\"]\n    case\
    \ \"Neptune\":\n        planets = []\n    default:\n        return planets\n \
    \   }\n    \n    planets = planets.filter { (planet) -> Bool in\n        let distance\
    \ = distance(planet, planet1)\n        return distance < distance(planet, planet2)\n\
    \    }\n    \n    return planets.sorted { (planet1, planet2) -> Bool in\n    \
    \    let distance = distance(planet1, planet2)\n        return distance < distance(planet2,\
    \ planet1)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2:\
    \ \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\n\
    assert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"\
    Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\")\
    \ == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: SyntaxError
  stderr: "/tmp/tmpvi1msrcj.swift:89:70: error: expected '}' at end of brace statement\n\
    assert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") == [] as [String])\n  \
    \                                                                   ^\n/tmp/tmpvi1msrcj.swift:15:55:\
    \ note: to match this opening '{'\nfunc bf(planet1: String, planet2: String) ->\
    \ [String] {\n                                                      ^\n/tmp/tmpvi1msrcj.swift:61:24:\
    \ error: use of local variable 'distance' before its declaration\n        let\
    \ distance = distance(planet, planet1)\n                       ^\n/tmp/tmpvi1msrcj.swift:61:13:\
    \ note: 'distance' declared here\n        let distance = distance(planet, planet1)\n\
    \            ^\n/tmp/tmpvi1msrcj.swift:66:24: error: use of local variable 'distance'\
    \ before its declaration\n        let distance = distance(planet1, planet2)\n\
    \                       ^\n/tmp/tmpvi1msrcj.swift:66:13: note: 'distance' declared\
    \ here\n        let distance = distance(planet1, planet2)\n            ^\n/tmp/tmpvi1msrcj.swift:71:6:\
    \ error: operator functions can only be declared at global or in type scope\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1659823230
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    var result: [String]\
    \ = []\n    \n    // TODO: Write your code here\n    \n    return result\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\"\
    ) == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\"\
    ) == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"\
    Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\n\
    assert(bf(planet1: \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Makemake\") == [] as [String])"
  status: Exception
  stderr: 'tmpzxxi8gnj/tmpzxxi8gnj.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba76d0ddc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba76cdd4b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba76cdd4988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba76cdd37b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpzxxi8gnj                        0x000055717b78f51b <unavailable> + 5403

    5    libc.so.6                          0x00002ba76d2c9460 __libc_start_main +
    245

    6    tmpzxxi8gnj                        0x000055717b78f0c9 <unavailable> + 4297

    '
  stdout: ''
  timestamp: 1659823230
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    var result = [String]()\n\
    \    \n    if planet1 == \"Mercury\" || planet1 == \"Venus\" || planet1 == \"\
    Earth\" || planet1 == \"Mars\" || planet1 == \"Jupiter\" || planet1 == \"Saturn\"\
    \ || planet1 == \"Uranus\" || planet1 == \"Neptune\" {\n        if planet2 ==\
    \ \"Mercury\" || planet2 == \"Venus\" || planet2 == \"Earth\" || planet2 == \"\
    Mars\" || planet2 == \"Jupiter\" || planet2 == \"Saturn\" || planet2 == \"Uranus\"\
    \ || planet2 == \"Neptune\" {\n            var orbit1 = orbit(planet1)\n     \
    \       var orbit2 = orbit(planet2)\n            var distance1 = distance(orbit1)\n\
    \            var distance2 = distance(orbit2)\n            var distance3 = distance(orbit1\
    \ + orbit2)\n            var distance4 = distance(orbit1 - orbit2)\n         \
    \   var distance5 = distance(orbit1 - orbit2)\n            var distance6 = distance(orbit1\
    \ + orbit2)\n            var distance7 = distance(orbit1 - orbit2)\n         \
    \   var distance8 = distance(orbit1 + orbit2)\n            var distance9 = distance(orbit1\
    \ - orbit2)\n            var distance10 = distance(orbit1 + orbit2)\n        \
    \    var distance11 = distance(orbit1 - orbit2)\n            var distance12 =\
    \ distance(orbit1 + orbit2)\n            var distance13 = distance(orbit1 - orbit2)\n\
    \            var distance14 = distance(orbit1 + orbit2)\n            var distance15\
    \ = distance(orbit1 - orbit2)\n            var distance16 = distance(orbit1 +\
    \ orbit2)\n            var distance17 = distance(orbit1 - orbit2)\n          \
    \  var distance18 = distance(orbit1 + orbit2)\n            var distance19 = distance(orbit1\
    \ - orbit2)\n            var distance20 = distance(orbit1 + orbit2)\n        \
    \    var distance21 = distance(orbit1 - orbit2)\n            var distance22 =\
    \ distance(orbit1 + orbit2)\n            var distance23 = distance(orbit1 - orbit2)\n\
    \            var distance24 = distance(orbit1 + orbit2)\n            var distance25\
    \ = distance(orbit1 - orbit2)\n            var distance26 = distance(orbit1 +\
    \ orbit2)\n            var distance27 = distance(orbit1 - orbit2)\n          \
    \  var distance28 = distance(orbit1 + orbit2)\n            var distance29 = distance(orbit1\
    \ - orbit2)\n            var distance30 = distance(orbit1 + orbit2)\n        \
    \    var distance31 = distance(orbit1 - orbit2)\n            var distance32 =\
    \ distance(orbit1 + orbit2)\n            var distance33 = distance(orbit1 - orbit2)\n\
    \            var distance34 = distance(orbit1 + orbit2)\n            var distance35\
    \ = distance(orbit1 - orbit2)\n            var distance36 = distance(orbit1 +\
    \ orbit2)\n            var distance37 = distance(orbit1 - orbit2)\n          \
    \  var distance38 = distance(\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1:\
    \ \"Earth\", planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\"\
    , planet2: \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    ])\nassert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2:\
    \ \"Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\"\
    ) == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: SyntaxError
  stderr: "/tmp/tmp83ne2eh_.swift:60:1: error: expected expression in list of expressions\n\
    }\n^\n/tmp/tmp83ne2eh_.swift:81:70: error: expected '}' at end of brace statement\n\
    assert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") == [] as [String])\n  \
    \                                                                   ^\n/tmp/tmp83ne2eh_.swift:18:188:\
    \ note: to match this opening '{'\n    if planet1 == \"Mercury\" || planet1 ==\
    \ \"Venus\" || planet1 == \"Earth\" || planet1 == \"Mars\" || planet1 == \"Jupiter\"\
    \ || planet1 == \"Saturn\" || planet1 == \"Uranus\" || planet1 == \"Neptune\"\
    \ {\n                                                                        \
    \                                                                            \
    \                                       ^\n/tmp/tmp83ne2eh_.swift:81:70: error:\
    \ expected '}' at end of brace statement\nassert(bf(planet1: \"Jupiter\", planet2:\
    \ \"Makemake\") == [] as [String])\n                                         \
    \                            ^\n/tmp/tmp83ne2eh_.swift:15:55: note: to match this\
    \ opening '{'\nfunc bf(planet1: String, planet2: String) -> [String] {\n     \
    \                                                 ^\n/tmp/tmp83ne2eh_.swift:20:26:\
    \ error: cannot find 'orbit' in scope\n            var orbit1 = orbit(planet1)\n\
    \                         ^~~~~\n/tmp/tmp83ne2eh_.swift:21:26: error: cannot find\
    \ 'orbit' in scope\n            var orbit2 = orbit(planet2)\n                \
    \         ^~~~~\n/tmp/tmp83ne2eh_.swift:22:29: error: cannot find 'distance' in\
    \ scope\n            var distance1 = distance(orbit1)\n                      \
    \      ^~~~~~~~\n/tmp/tmp83ne2eh_.swift:23:29: error: cannot find 'distance' in\
    \ scope\n            var distance2 = distance(orbit2)\n                      \
    \      ^~~~~~~~\n/tmp/tmp83ne2eh_.swift:24:29: error: cannot find 'distance' in\
    \ scope\n            var distance3 = distance(orbit1 + orbit2)\n             \
    \               ^~~~~~~~\n/tmp/tmp83ne2eh_.swift:25:29: error: cannot find 'distance'\
    \ in scope\n            var distance4 = distance(orbit1 - orbit2)\n          \
    \                  ^~~~~~~~\n/tmp/tmp83ne2eh_.swi"
  stdout: ''
  timestamp: 1659823230
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    \n    // Your code\
    \ here\n    \n    return []\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1:\
    \ \"Earth\", planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\"\
    , planet2: \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    ])\nassert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2:\
    \ \"Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\"\
    ) == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: Exception
  stderr: 'tmpub3vnyvf/tmpub3vnyvf.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9379153c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9378e4ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9378e4a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9378e497b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpub3vnyvf                        0x0000559f9836d51b <unavailable> + 5403

    5    libc.so.6                          0x00002b937933f460 __libc_start_main +
    245

    6    tmpub3vnyvf                        0x0000559f9836d0c9 <unavailable> + 4297

    '
  stdout: ''
  timestamp: 1659823230
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    var planets = [String]()\n\
    \    \n    guard let planet1Orbit = orbit(planet1) else {\n        return planets\n\
    \    }\n    guard let planet2Orbit = orbit(planet2) else {\n        return planets\n\
    \    }\n    \n    let planet1Sun = orbit(planet1)\n    let planet2Sun = orbit(planet2)\n\
    \    \n    let planet1SunDistance = distance(planet1Sun, planet2Sun)\n    let\
    \ planet2SunDistance = distance(planet2Sun, planet1Sun)\n    \n    if planet1SunDistance\
    \ < planet2SunDistance {\n        planets.append(planet1)\n        planets.append(planet2)\n\
    \    } else {\n        planets.append(planet2)\n        planets.append(planet1)\n\
    \    }\n    \n    return planets\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1:\
    \ \"Earth\", planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\"\
    , planet2: \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    ])\nassert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2:\
    \ \"Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\"\
    ) == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: SyntaxError
  stderr: "/tmp/tmp1_h4o292.swift:18:30: error: cannot find 'orbit' in scope\n   \
    \ guard let planet1Orbit = orbit(planet1) else {\n                           \
    \  ^~~~~\n/tmp/tmp1_h4o292.swift:21:30: error: cannot find 'orbit' in scope\n\
    \    guard let planet2Orbit = orbit(planet2) else {\n                        \
    \     ^~~~~\n/tmp/tmp1_h4o292.swift:25:22: error: cannot find 'orbit' in scope\n\
    \    let planet1Sun = orbit(planet1)\n                     ^~~~~\n/tmp/tmp1_h4o292.swift:26:22:\
    \ error: cannot find 'orbit' in scope\n    let planet2Sun = orbit(planet2)\n \
    \                    ^~~~~\n/tmp/tmp1_h4o292.swift:28:30: error: cannot find 'distance'\
    \ in scope\n    let planet1SunDistance = distance(planet1Sun, planet2Sun)\n  \
    \                           ^~~~~~~~\n/tmp/tmp1_h4o292.swift:29:30: error: cannot\
    \ find 'distance' in scope\n    let planet2SunDistance = distance(planet2Sun,\
    \ planet1Sun)\n                             ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659823230
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    var planets = [String]()\n\
    \    \n    // TODO: Write your code here\n    \n    return planets\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\"\
    ) == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\"\
    ) == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"\
    Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\n\
    assert(bf(planet1: \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Makemake\") == [] as [String])"
  status: Exception
  stderr: 'tmpqir0zopy/tmpqir0zopy.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b71b763fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b71b7336b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b71b7336988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b71b73357b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpqir0zopy                        0x00005603381a456b <unavailable> + 5483

    5    libc.so.6                          0x00002b71b782b460 __libc_start_main +
    245

    6    tmpqir0zopy                        0x00005603381a4119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659823230
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    \n    var planets\
    \ = [String]()\n    \n    if planet1 == planet2 {\n        return planets\n  \
    \  }\n    \n    if planet1 == \"Mercury\" {\n        planets.append(\"Venus\"\
    )\n    }\n    \n    if planet1 == \"Venus\" {\n        planets.append(\"Earth\"\
    )\n    }\n    \n    if planet1 == \"Earth\" {\n        planets.append(\"Mars\"\
    )\n    }\n    \n    if planet1 == \"Mars\" {\n        planets.append(\"Jupiter\"\
    )\n    }\n    \n    if planet1 == \"Jupiter\" {\n        planets.append(\"Saturn\"\
    )\n    }\n    \n    if planet1 == \"Saturn\" {\n        planets.append(\"Uranus\"\
    )\n    }\n    \n    if planet1 == \"Uranus\" {\n        planets.append(\"Neptune\"\
    )\n    }\n    \n    if planet1 == \"Neptune\" {\n        planets.append(\"Mercury\"\
    )\n    }\n    \n    if planet2 == \"Mercury\" {\n        planets.append(\"Venus\"\
    )\n    }\n    \n    if planet2 == \"Venus\" {\n        planets.append(\"Earth\"\
    )\n    }\n    \n    if planet2 == \"Earth\" {\n        planets.append(\"Mars\"\
    )\n    }\n    \n    if planet2 == \"Mars\" {\n        planets.append(\"Jupiter\"\
    )\n    }\n    \n    if planet2 == \"Jupiter\" {\n        planets.append(\"Saturn\"\
    )\n    }\n    \n    if planet2 == \"Saturn\" {\n        planets.append(\"Uranus\"\
    )\n    }\n    \n    if planet2 == \"Uranus\" {\n        planets.append(\"Neptune\"\
    )\n    }\n    \n    if planet2 == \"Neptune\" {\n        planets.append(\"Mercury\"\
    )\n    }\n    \n    return planets\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(bf(planet1: \"Jupiter\", planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"\
    ])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1:\
    \ \"Mercury\", planet2: \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"])\nassert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2:\
    \ \"Earth\") == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\"\
    ) == [] as [String])"
  status: Exception
  stderr: 'tmpu57pex14/tmpu57pex14.swift:103: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b64fd035c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b64fcd2cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b64fcd2c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b64fcd2b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpu57pex14                        0x00005605b977962b <unavailable> + 5675

    5    libc.so.6                          0x00002b64fd221460 __libc_start_main +
    245

    6    tmpu57pex14                        0x00005605b97791d9 <unavailable> + 4569

    '
  stdout: ''
  timestamp: 1659823230
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    \n    var planets\
    \ = [String]()\n    \n    if planet1 == \"Mercury\" && planet2 == \"Venus\" {\n\
    \        planets = [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"\
    Uranus\", \"Neptune\"]\n    } else if planet1 == \"Venus\" && planet2 == \"Earth\"\
    \ {\n        planets = [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    } else if planet1 == \"Earth\" && planet2 == \"Mars\" {\n\
    \        planets = [\"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    ]\n    } else if planet1 == \"Mars\" && planet2 == \"Jupiter\" {\n        planets\
    \ = [\"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"]\n    } else if planet1\
    \ == \"Jupiter\" && planet2 == \"Saturn\" {\n        planets = [\"Saturn\", \"\
    Uranus\", \"Neptune\"]\n    } else if planet1 == \"Saturn\" && planet2 == \"Uranus\"\
    \ {\n        planets = [\"Uranus\", \"Neptune\"]\n    } else if planet1 == \"\
    Uranus\" && planet2 == \"Neptune\" {\n        planets = [\"Neptune\"]\n    }\n\
    \    \n    return planets\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1:\
    \ \"Earth\", planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\"\
    , planet2: \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    ])\nassert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2:\
    \ \"Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\"\
    ) == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: Exception
  stderr: 'tmpdux5hd8h/tmpdux5hd8h.swift:51: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5250a08c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b52506ffb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b52506ff988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b52506fe7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpdux5hd8h                        0x000056324c12a5cb <unavailable> + 5579

    5    libc.so.6                          0x00002b5250bf4460 __libc_start_main +
    245

    6    tmpdux5hd8h                        0x000056324c12a179 <unavailable> + 4473

    '
  stdout: ''
  timestamp: 1659823230
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    \n    var planets\
    \ = [String]()\n    \n    if planet1 == \"Mercury\" && planet2 == \"Venus\" {\n\
    \        planets = [\"Mercury\", \"Venus\"]\n    } else if planet1 == \"Venus\"\
    \ && planet2 == \"Mercury\" {\n        planets = [\"Venus\", \"Mercury\"]\n  \
    \  } else if planet1 == \"Earth\" && planet2 == \"Mars\" {\n        planets =\
    \ [\"Earth\", \"Mars\"]\n    } else if planet1 == \"Mars\" && planet2 == \"Earth\"\
    \ {\n        planets = [\"Mars\", \"Earth\"]\n    } else if planet1 == \"Jupiter\"\
    \ && planet2 == \"Saturn\" {\n        planets = [\"Jupiter\", \"Saturn\"]\n  \
    \  } else if planet1 == \"Saturn\" && planet2 == \"Jupiter\" {\n        planets\
    \ = [\"Saturn\", \"Jupiter\"]\n    } else if planet1 == \"Uranus\" && planet2\
    \ == \"Neptune\" {\n        planets = [\"Uranus\", \"Neptune\"]\n    } else if\
    \ planet1 == \"Neptune\" && planet2 == \"Uranus\" {\n        planets = [\"Neptune\"\
    , \"Uranus\"]\n    } else {\n        return planets\n    }\n    \n    return planets\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\"\
    ) == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\"\
    ) == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"\
    Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\n\
    assert(bf(planet1: \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Makemake\") == [] as [String])"
  status: Exception
  stderr: 'tmp0jqynoz1/tmp0jqynoz1.swift:55: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b87c5091c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b87c4d88b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b87c4d88988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b87c4d877b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp0jqynoz1                        0x000055cce3a325cb <unavailable> + 5579

    5    libc.so.6                          0x00002b87c527d460 __libc_start_main +
    245

    6    tmp0jqynoz1                        0x000055cce3a32179 <unavailable> + 4473

    '
  stdout: ''
  timestamp: 1659823230
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    \n    var planets\
    \ = [String]()\n    \n    if planet1 == planet2 {\n        return planets\n  \
    \  }\n    \n    var orbit1 = orbit(planet1)\n    var orbit2 = orbit(planet2)\n\
    \    \n    var orbit1Sun = orbit1[0]\n    var orbit2Sun = orbit2[0]\n    \n  \
    \  var distance1 = distance(orbit1Sun, orbit1[1])\n    var distance2 = distance(orbit2Sun,\
    \ orbit2[1])\n    \n    if distance1 < distance2 {\n        planets.append(orbit1[0])\n\
    \        planets.append(orbit1[1])\n        planets.append(orbit2[0])\n      \
    \  planets.append(orbit2[1])\n        planets.append(orbit1[0])\n        planets.append(orbit1[1])\n\
    \        planets.append(orbit2[0])\n        planets.append(orbit2[1])\n      \
    \  planets.append(orbit1[0])\n        planets.append(orbit1[1])\n        planets.append(orbit2[0])\n\
    \        planets.append(orbit2[1])\n        planets.append(orbit1[0])\n      \
    \  planets.append(orbit1[1])\n        planets.append(orbit2[0])\n        planets.append(orbit2[1])\n\
    \        planets.append(orbit1[0])\n        planets.append(orbit1[1])\n      \
    \  planets.append(orbit2[0])\n        planets.append(orbit2[1])\n        planets.append(orbit1[0])\n\
    \        planets.append(orbit1[1])\n        planets.append(orbit2[0])\n      \
    \  planets.append(orbit2[1])\n        planets.append(orbit1[0])\n        planets.append(orbit1[1])\n\
    \        planets.append(orbit2[0])\n        planets.append(orbit2[1])\n      \
    \  planets.append(orbit1[0])\n        planets.append(orbit1[1])\n        planets.append(orbit2[0])\n\
    \        planets.append(orbit2[1])\n        planets.append(orbit1[0])\n      \
    \  planets.append(orbit1[1])\n        planets.append(orbit2[0])\n        planets.append(orbit2[1])\n\
    \        planets.append(orbit1[0])\n        planets.append(orbit1[1])\n      \
    \  planets.append(orbit2[0])\n        planets.append(orbit2[1])\n        planets.append(orbit1[0])\n\
    \        planets.append(orbit1[1])\n        planets.append(orbit2[0])\n      \
    \  planets.append(orbit2[1])\n        planets.append(orbit1[0])\n        planets.append(orbit1[1])\n\
    \        planets.append(orbit2[0])\n        planets.append(orbit2[1])\n      \
    \  planets.append(orbit1[0])\n        planets.append(orbit1[1])\n        planets.append(orbit2[0])\n\
    \        planet\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2:\
    \ \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\n\
    assert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"\
    Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\")\
    \ == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: SyntaxError
  stderr: "/tmp/tmp1oo0uqi3.swift:106:70: error: expected '}' at end of brace statement\n\
    assert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") == [] as [String])\n  \
    \                                                                   ^\n/tmp/tmp1oo0uqi3.swift:15:55:\
    \ note: to match this opening '{'\nfunc bf(planet1: String, planet2: String) ->\
    \ [String] {\n                                                      ^\n/tmp/tmp1oo0uqi3.swift:23:18:\
    \ error: cannot find 'orbit' in scope\n    var orbit1 = orbit(planet1)\n     \
    \            ^~~~~\n/tmp/tmp1oo0uqi3.swift:24:18: error: cannot find 'orbit' in\
    \ scope\n    var orbit2 = orbit(planet2)\n                 ^~~~~\n/tmp/tmp1oo0uqi3.swift:29:21:\
    \ error: cannot find 'distance' in scope\n    var distance1 = distance(orbit1Sun,\
    \ orbit1[1])\n                    ^~~~~~~~\n/tmp/tmp1oo0uqi3.swift:30:21: error:\
    \ cannot find 'distance' in scope\n    var distance2 = distance(orbit2Sun, orbit2[1])\n\
    \                    ^~~~~~~~\n/tmp/tmp1oo0uqi3.swift:84:9: error: cannot find\
    \ 'planet' in scope\n        planet\n        ^~~~~~\n/tmp/tmp1oo0uqi3.swift:88:6:\
    \ error: operator functions can only be declared at global or in type scope\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1659823230
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    var planets = [String]()\n\
    \    \n    if planet1 == planet2 {\n        return planets\n    }\n    \n    if\
    \ planet1 == \"Mercury\" && planet2 == \"Earth\" {\n        planets = [\"Venus\"\
    ]\n        return planets\n    }\n    \n    if planet1 == \"Venus\" && planet2\
    \ == \"Earth\" {\n        planets = [\"Mercury\"]\n        return planets\n  \
    \  }\n    \n    if planet1 == \"Earth\" && planet2 == \"Mercury\" {\n        planets\
    \ = [\"Venus\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"]\n\
    \        return planets\n    }\n    \n    if planet1 == \"Mars\" && planet2 ==\
    \ \"Earth\" {\n        planets = [\"Mercury\", \"Venus\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\", \"Neptune\"]\n        return planets\n    }\n    \n    if planet1\
    \ == \"Jupiter\" && planet2 == \"Mars\" {\n        planets = [\"Mercury\", \"\
    Venus\", \"Earth\", \"Mars\", \"Saturn\", \"Uranus\", \"Neptune\"]\n        return\
    \ planets\n    }\n    \n    if planet1 == \"Saturn\" && planet2 == \"Jupiter\"\
    \ {\n        planets = [\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Uranus\", \"Neptune\"]\n        return planets\n    }\n    \n    if planet1\
    \ == \"Uranus\" && planet2 == \"Saturn\" {\n        planets = [\"Mercury\", \"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Neptune\"]\n        return\
    \ planets\n    }\n    \n    if planet1 == \"Neptune\" && planet2 == \"Uranus\"\
    \ {\n        planets = [\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"]\n        return planets\n    }\n    \n    if planet1\
    \ == \"Mercury\" && planet2 == \"Venus\" {\n        planets = [\"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"]\n        return planets\n\
    \    }\n    \n    if planet1 == \"Venus\" && planet2 == \"Mercury\" {\n      \
    \  planets = [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    ]\n        return \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2:\
    \ \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\n\
    assert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"\
    Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\")\
    \ == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: SyntaxError
  stderr: "/tmp/tmplhk4yikj.swift:91:70: error: expected '}' at end of brace statement\n\
    assert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") == [] as [String])\n  \
    \                                                                   ^\n/tmp/tmplhk4yikj.swift:15:55:\
    \ note: to match this opening '{'\nfunc bf(planet1: String, planet2: String) ->\
    \ [String] {\n                                                      ^\n/tmp/tmplhk4yikj.swift:69:9:\
    \ error: non-void function should return a value\n        return \n        ^\n\
    /tmp/tmplhk4yikj.swift:73:6: error: operator functions can only be declared at\
    \ global or in type scope\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n     ^\n"
  stdout: ''
  timestamp: 1659823230
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    var planets = [String]()\n\
    \    \n    if planet1 == \"Mercury\" && planet2 == \"Venus\" {\n        planets\
    \ = [\"Mercury\", \"Venus\"]\n    } else if planet1 == \"Venus\" && planet2 ==\
    \ \"Earth\" {\n        planets = [\"Venus\", \"Earth\"]\n    } else if planet1\
    \ == \"Earth\" && planet2 == \"Mars\" {\n        planets = [\"Earth\", \"Mars\"\
    ]\n    } else if planet1 == \"Mars\" && planet2 == \"Jupiter\" {\n        planets\
    \ = [\"Mars\", \"Jupiter\"]\n    } else if planet1 == \"Jupiter\" && planet2 ==\
    \ \"Saturn\" {\n        planets = [\"Jupiter\", \"Saturn\"]\n    } else if planet1\
    \ == \"Saturn\" && planet2 == \"Uranus\" {\n        planets = [\"Saturn\", \"\
    Uranus\"]\n    } else if planet1 == \"Uranus\" && planet2 == \"Neptune\" {\n \
    \       planets = [\"Uranus\", \"Neptune\"]\n    } else {\n        return planets\n\
    \    }\n    \n    return planets\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1:\
    \ \"Earth\", planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\"\
    , planet2: \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    ])\nassert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2:\
    \ \"Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\"\
    ) == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: Exception
  stderr: 'tmpf39g5w4x/tmpf39g5w4x.swift:52: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b72ff839c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b72ff530b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b72ff530988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b72ff52f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpf39g5w4x                        0x0000560a264275cb <unavailable> + 5579

    5    libc.so.6                          0x00002b72ffa25460 __libc_start_main +
    245

    6    tmpf39g5w4x                        0x0000560a26427179 <unavailable> + 4473

    '
  stdout: ''
  timestamp: 1659823230
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    \n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\") == [\"\
    Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\") ==\
    \ [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"Venus\"\
    , \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"Neptune\"\
    , planet2: \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    ])\nassert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Makemake\") == [] as [String])"
  status: SyntaxError
  stderr: '/tmp/tmp3d9bvts2.swift:17:1: error: missing return in global function expected
    to return ''[String]''

    }

    ^

    '
  stdout: ''
  timestamp: 1659823230
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    var planets = [String]()\n\
    \    \n    // TODO: Write your code here\n    \n    return planets\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\"\
    ) == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\"\
    ) == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"\
    Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\n\
    assert(bf(planet1: \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Makemake\") == [] as [String])"
  status: Exception
  stderr: 'tmpqir0zopy/tmpqir0zopy.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b71b763fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b71b7336b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b71b7336988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b71b73357b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpqir0zopy                        0x00005603381a456b <unavailable> + 5483

    5    libc.so.6                          0x00002b71b782b460 __libc_start_main +
    245

    6    tmpqir0zopy                        0x00005603381a4119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659823230
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    \n    var result:\
    \ [String] = []\n    \n    if planet1 == planet2 {\n        return result\n  \
    \  }\n    \n    var orbit1 = orbit(planet1)\n    var orbit2 = orbit(planet2)\n\
    \    \n    var orbit1Index = orbit1.index(of: planet1)\n    var orbit2Index =\
    \ orbit2.index(of: planet2)\n    \n    if orbit1Index == -1 || orbit2Index ==\
    \ -1 {\n        return result\n    }\n    \n    let orbit1Distance = orbit1Index\
    \ - orbit2Index\n    \n    if orbit1Distance < 0 {\n        orbit1Distance *=\
    \ -1\n        orbit2Index -= 1\n    }\n    \n    if orbit1Distance < 2 {\n   \
    \     result.insert(planet1, at: 0)\n        result.insert(planet2, at: 0)\n \
    \       return result\n    }\n    \n    if orbit1Distance < 4 {\n        result.insert(planet1,\
    \ at: 0)\n        result.insert(planet2, at: 1)\n        return result\n    }\n\
    \    \n    if orbit1Distance < 8 {\n        result.insert(planet1, at: 1)\n  \
    \      result.insert(planet2, at: 0)\n        return result\n    }\n    \n   \
    \ if orbit1Distance < 16 {\n        result.insert(planet1, at: 1)\n        result.insert(planet2,\
    \ at: 1)\n        return result\n    }\n    \n    if orbit1Distance < 32 {\n \
    \       result.insert(planet1, at: 2)\n        result.insert(planet2, at: 0)\n\
    \        return result\n    }\n    \n    if orbit1Distance < 64 {\n        result.insert(planet1,\
    \ at: 2)\n        result.insert(planet2, at: 1)\n        return result\n    }\n\
    \    \n    if orbit1Distance < 128 {\n        result.insert(planet1, at: 3)\n\
    \        result.insert(planet2, at: 0)\n        return result\n    }\n    \n \
    \   if orbit1Distance < 256 {\n        result.insert(planet1, at: 3)\n       \
    \ result.insert(planet2, at: 1)\n        return result\n    }\n    \n    if orbit1Distance\
    \ < 512 {\n        result.insert(planet1, at: 4)\n        result.insert(planet2,\
    \ at: 0)\n        return result\n    }\n    \n    if orbit1Distance < 1024 {\n\
    \        result.insert(planet1, at: 4)\n        result.insert(planet2, at: 1)\n\
    \        return result\n    }\n    \n    if orbit1Distance < 2048 {\n        result.insert(planet1,\
    \ at: 5)\n        result.insert(planet2, at: 0)\n        return result\n    }\n\
    \    \n    if orbit1Distance < 4096 {\n        result.insert(planet1, at: 5)\n\
    \        result.insert(planet2, at: 1)\n        return result\n    }\n    \n\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\"\
    ) == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\"\
    ) == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"\
    Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\n\
    assert(bf(planet1: \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Makemake\") == [] as [String])"
  status: SyntaxError
  stderr: "/tmp/tmpvuzmzzlg.swift:23:18: error: cannot find 'orbit' in scope\n   \
    \ var orbit1 = orbit(planet1)\n                 ^~~~~\n/tmp/tmpvuzmzzlg.swift:24:18:\
    \ error: cannot find 'orbit' in scope\n    var orbit2 = orbit(planet2)\n     \
    \            ^~~~~\n"
  stdout: ''
  timestamp: 1659823230
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    var planets = [String]()\n\
    \    \n    // TODO: Write your code here\n    \n    return planets\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\"\
    ) == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\"\
    ) == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"\
    Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\n\
    assert(bf(planet1: \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Makemake\") == [] as [String])"
  status: Exception
  stderr: 'tmpqir0zopy/tmpqir0zopy.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b71b763fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b71b7336b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b71b7336988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b71b73357b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpqir0zopy                        0x00005603381a456b <unavailable> + 5483

    5    libc.so.6                          0x00002b71b782b460 __libc_start_main +
    245

    6    tmpqir0zopy                        0x00005603381a4119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659823230
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    var result: [String]\
    \ = []\n    \n    if planet1 == planet2 {\n        return result;\n    }\n   \
    \ \n    let planet1Orbit = orbit(planet1)\n    let planet2Orbit = orbit(planet2)\n\
    \    \n    for planet in planet1Orbit {\n        if planet == planet2 {\n    \
    \        continue;\n        }\n        \n        let distance = distance(planet,\
    \ planet2)\n        \n        if distance < planet1Orbit[planet] {\n         \
    \   result.append(planet)\n        }\n    }\n    \n    for planet in planet2Orbit\
    \ {\n        if planet == planet1 {\n            continue;\n        }\n      \
    \  \n        let distance = distance(planet, planet1)\n        \n        if distance\
    \ < planet2Orbit[planet] {\n            result.append(planet)\n        }\n   \
    \ }\n    \n    return result.sorted(by: { $0.distance(to: toSun) < $1.distance(to:\
    \ toSun) })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2:\
    \ \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\n\
    assert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"\
    Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\")\
    \ == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: SyntaxError
  stderr: "/tmp/tmp3k8tiuyo.swift:22:24: error: cannot find 'orbit' in scope\n   \
    \ let planet1Orbit = orbit(planet1)\n                       ^~~~~\n/tmp/tmp3k8tiuyo.swift:23:24:\
    \ error: cannot find 'orbit' in scope\n    let planet2Orbit = orbit(planet2)\n\
    \                       ^~~~~\n/tmp/tmp3k8tiuyo.swift:49:48: error: cannot find\
    \ 'toSun' in scope\n    return result.sorted(by: { $0.distance(to: toSun) < $1.distance(to:\
    \ toSun) })\n                                               ^~~~~\n/tmp/tmp3k8tiuyo.swift:49:73:\
    \ error: cannot find 'toSun' in scope\n    return result.sorted(by: { $0.distance(to:\
    \ toSun) < $1.distance(to: toSun) })\n                                       \
    \                                 ^~~~~\n/tmp/tmp3k8tiuyo.swift:30:24: error:\
    \ use of local variable 'distance' before its declaration\n        let distance\
    \ = distance(planet, planet2)\n                       ^\n/tmp/tmp3k8tiuyo.swift:30:13:\
    \ note: 'distance' declared here\n        let distance = distance(planet, planet2)\n\
    \            ^\n/tmp/tmp3k8tiuyo.swift:42:24: error: use of local variable 'distance'\
    \ before its declaration\n        let distance = distance(planet, planet1)\n \
    \                      ^\n/tmp/tmp3k8tiuyo.swift:42:13: note: 'distance' declared\
    \ here\n        let distance = distance(planet, planet1)\n            ^\n"
  stdout: ''
  timestamp: 1659823230
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    var result: [String]\
    \ = []\n    \n    if planet1 == planet2 {\n        return result;\n    }\n   \
    \ \n    if planet1 == \"Mercury\" || planet1 == \"Venus\" || planet1 == \"Earth\"\
    \ || planet1 == \"Mars\" || planet1 == \"Jupiter\" || planet1 == \"Saturn\" ||\
    \ planet1 == \"Uranus\" || planet1 == \"Neptune\" {\n        return result;\n\
    \    }\n    \n    if planet2 == \"Mercury\" || planet2 == \"Venus\" || planet2\
    \ == \"Earth\" || planet2 == \"Mars\" || planet2 == \"Jupiter\" || planet2 ==\
    \ \"Saturn\" || planet2 == \"Uranus\" || planet2 == \"Neptune\" {\n        return\
    \ result;\n    }\n    \n    if planet1 == \"Mercury\" && planet2 == \"Venus\"\
    \ {\n        result.append(\"Saturn\");\n        result.append(\"Uranus\");\n\
    \        return result;\n    }\n    \n    if planet1 == \"Venus\" && planet2 ==\
    \ \"Mercury\" {\n        result.append(\"Saturn\");\n        result.append(\"\
    Uranus\");\n        return result;\n    }\n    \n    if planet1 == \"Mercury\"\
    \ && planet2 == \"Earth\" {\n        result.append(\"Saturn\");\n        result.append(\"\
    Uranus\");\n        result.append(\"Neptune\");\n        return result;\n    }\n\
    \    \n    if planet1 == \"Venus\" && planet2 == \"Earth\" {\n        result.append(\"\
    Saturn\");\n        result.append(\"Uranus\");\n        result.append(\"Neptune\"\
    );\n        return result;\n    }\n    \n    if planet1 == \"Mercury\" && planet2\
    \ == \"Mars\" {\n        result.append(\"Saturn\");\n        result.append(\"\
    Uranus\");\n        result.append(\"Neptune\");\n        result.append(\"Jupiter\"\
    );\n        return result;\n    }\n    \n    if planet1 == \"Venus\" && planet2\
    \ == \"Mars\" {\n        result.append(\"Saturn\");\n        result.append(\"\
    Uranus\");\n        result.append(\"Neptune\");\n        result.append(\"Jupiter\"\
    );\n        return result;\n    }\n    \n    if planet1 == \"Mercury\" && planet2\
    \ == \"Jupiter\" {\n        result.append(\"Saturn\");\n        result.append(\"\
    Uranus\");\n        result.append(\"Neptune\");\n        result.append(\"Jupiter\"\
    );\n        return result;\n    }\n    \n    if planet1 == \"Venus\" && planet2\
    \ == \"Jupiter\" {\n        result.append(\"Saturn\");\n        result.append(\"\
    U\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\"\
    ) == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\"\
    ) == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"\
    Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\n\
    assert(bf(planet1: \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Makemake\") == [] as [String])"
  status: SyntaxError
  stderr: "/tmp/tmpsempzzlx.swift:82:23: error: unterminated string literal\n    \
    \    result.append(\"U\n                      ^\n/tmp/tmpsempzzlx.swift:104:70:\
    \ error: expected '}' at end of brace statement\nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Makemake\") == [] as [String])\n                                \
    \                                     ^\n/tmp/tmpsempzzlx.swift:15:55: note: to\
    \ match this opening '{'\nfunc bf(planet1: String, planet2: String) -> [String]\
    \ {\n                                                      ^\n/tmp/tmpsempzzlx.swift:82:23:\
    \ error: missing argument for parameter #1 in call\n        result.append(\"U\n\
    \                      ^\n                      <#String#>\nSwift.Array:6:37:\
    \ note: 'append' declared here\n    @inlinable public mutating func append(_ newElement:\
    \ __owned Element)\n                                    ^\n/tmp/tmpsempzzlx.swift:86:6:\
    \ error: operator functions can only be declared at global or in type scope\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1659823230
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    var planets = [String]()\n\
    \    var sun = Sun()\n    var planet1 = planet1\n    var planet2 = planet2\n \
    \   \n    if planet1 == planet2 {\n        return planets\n    }\n    \n    if\
    \ planet1 == planet2 {\n        return planets\n    }\n    \n    if planet1 ==\
    \ planet2 {\n        return planets\n    }\n    \n    if planet1 == planet2 {\n\
    \        return planets\n    }\n    \n    if planet1 == planet2 {\n        return\
    \ planets\n    }\n    \n    if planet1 == planet2 {\n        return planets\n\
    \    }\n    \n    if planet1 == planet2 {\n        return planets\n    }\n   \
    \ \n    if planet1 == planet2 {\n        return planets\n    }\n    \n    if planet1\
    \ == planet2 {\n        return planets\n    }\n    \n    if planet1 == planet2\
    \ {\n        return planets\n    }\n    \n    if planet1 == planet2 {\n      \
    \  return planets\n    }\n    \n    if planet1 == planet2 {\n        return planets\n\
    \    }\n    \n    if planet1 == planet2 {\n        return planets\n    }\n   \
    \ \n    if planet1 == planet2 {\n        return planets\n    }\n    \n    if planet1\
    \ == planet2 {\n        return planets\n    }\n    \n    if planet1 == planet2\
    \ {\n        return planets\n    }\n    \n    if planet1 == planet2 {\n      \
    \  return planets\n    }\n    \n    if planet1 == planet2 {\n        return planets\n\
    \    }\n    \n    if planet1 == planet2 {\n        return planets\n    }\n   \
    \ \n    if planet1 == planet2 {\n        return planets\n    }\n    \n    if planet1\
    \ == planet2 {\n        return planets\n    }\n    \n    if planet1 == planet2\
    \ {\n        return planets\n    }\n    \n    if planet1 == planet2 {\n      \
    \  return planets\n    }\n    \n    if planet1 == planet2 {\n        return planets\n\
    \    }\n    \n    if planet1 == planet2 {\n        return planets\n    }\n   \
    \ \n    if planet1 == planet2 {\n        return planets\n    }\n    \n    if planet1\
    \ == planet2 {\n        return planets\n    }\n    \n    if planet1 == planet2\
    \ {\n        return planets\n    }\n    \n    if planet1 == \n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\") == [\"\
    Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\") ==\
    \ [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"Venus\"\
    , \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"Neptune\"\
    , planet2: \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    ])\nassert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Makemake\") == [] as [String])"
  status: SyntaxError
  stderr: "/tmp/tmprlvfitnv.swift:134:1: error: expected expression after operator\n\
    }\n^\n/tmp/tmprlvfitnv.swift:17:15: error: cannot find 'Sun' in scope\n    var\
    \ sun = Sun()\n              ^~~\n"
  stdout: ''
  timestamp: 1659823230
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    var planets = [String]()\n\
    \    \n    if planet1 == \"Mercury\" && planet2 == \"Venus\" {\n        planets\
    \ = [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"]\n\
    \    } else if planet1 == \"Venus\" && planet2 == \"Earth\" {\n        planets\
    \ = [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"]\n\
    \    } else if planet1 == \"Earth\" && planet2 == \"Mars\" {\n        planets\
    \ = [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"]\n\
    \    } else if planet1 == \"Mars\" && planet2 == \"Jupiter\" {\n        planets\
    \ = [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"]\n\
    \    } else if planet1 == \"Jupiter\" && planet2 == \"Saturn\" {\n        planets\
    \ = [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"]\n\
    \    } else if planet1 == \"Saturn\" && planet2 == \"Uranus\" {\n        planets\
    \ = [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"]\n\
    \    } else if planet1 == \"Uranus\" && planet2 == \"Neptune\" {\n        planets\
    \ = [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"]\n\
    \    } else {\n        return planets\n    }\n    \n    return planets\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\"\
    ) == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\"\
    ) == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"\
    Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\n\
    assert(bf(planet1: \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Makemake\") == [] as [String])"
  status: Exception
  stderr: 'tmpgyrbh8ms/tmpgyrbh8ms.swift:52: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002afa8ddd1c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002afa8dac8b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002afa8dac8988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002afa8dac77b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpgyrbh8ms                        0x000055b8458d35cb <unavailable> + 5579

    5    libc.so.6                          0x00002afa8dfbd460 __libc_start_main +
    245

    6    tmpgyrbh8ms                        0x000055b8458d3179 <unavailable> + 4473

    '
  stdout: ''
  timestamp: 1659823230
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    \n    // Your code\
    \ here\n    \n    return []\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1:\
    \ \"Earth\", planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\"\
    , planet2: \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    ])\nassert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2:\
    \ \"Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\"\
    ) == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: Exception
  stderr: 'tmpub3vnyvf/tmpub3vnyvf.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9379153c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9378e4ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9378e4a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9378e497b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpub3vnyvf                        0x0000559f9836d51b <unavailable> + 5403

    5    libc.so.6                          0x00002b937933f460 __libc_start_main +
    245

    6    tmpub3vnyvf                        0x0000559f9836d0c9 <unavailable> + 4297

    '
  stdout: ''
  timestamp: 1659823230
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    var planets = [String]()\n\
    \    \n    if planet1 == planet2 {\n        return planets\n    }\n    \n    if\
    \ planet1 == \"Mercury\" || planet1 == \"Venus\" || planet1 == \"Earth\" || planet1\
    \ == \"Mars\" || planet1 == \"Jupiter\" || planet1 == \"Saturn\" || planet1 ==\
    \ \"Uranus\" || planet1 == \"Neptune\" {\n        planets.append(planet1)\n  \
    \  }\n    \n    if planet2 == \"Mercury\" || planet2 == \"Venus\" || planet2 ==\
    \ \"Earth\" || planet2 == \"Mars\" || planet2 == \"Jupiter\" || planet2 == \"\
    Saturn\" || planet2 == \"Uranus\" || planet2 == \"Neptune\" {\n        planets.append(planet2)\n\
    \    }\n    \n    if planet1 == \"Mercury\" && planet2 == \"Venus\" {\n      \
    \  planets.append(\"Earth\")\n    }\n    \n    if planet1 == \"Mercury\" && planet2\
    \ == \"Earth\" {\n        planets.append(\"Mars\")\n    }\n    \n    if planet1\
    \ == \"Mercury\" && planet2 == \"Mars\" {\n        planets.append(\"Jupiter\"\
    )\n    }\n    \n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n  \
    \      planets.append(\"Saturn\")\n    }\n    \n    if planet1 == \"Mercury\"\
    \ && planet2 == \"Saturn\" {\n        planets.append(\"Uranus\")\n    }\n    \n\
    \    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets.append(\"\
    Neptune\")\n    }\n    \n    if planet1 == \"Venus\" && planet2 == \"Earth\" {\n\
    \        planets.append(\"Mercury\")\n    }\n    \n    if planet1 == \"Venus\"\
    \ && planet2 == \"Mercury\" {\n        planets.append(\"Earth\")\n    }\n    \n\
    \    if planet1 == \"Venus\" && planet2 == \"Mars\" {\n        planets.append(\"\
    Jupiter\")\n    }\n    \n    if planet1 == \"Venus\" && planet2 == \"Jupiter\"\
    \ {\n        planets.append(\"Saturn\")\n    }\n    \n    if planet1 == \"Venus\"\
    \ && planet2 == \"Saturn\" {\n        planets.append(\"Uranus\")\n    }\n    \n\
    \    if planet1 == \"Venus\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1:\
    \ \"Earth\", planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\"\
    , planet2: \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    ])\nassert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2:\
    \ \"Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\"\
    ) == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: SyntaxError
  stderr: "/tmp/tmpdr1lg5u5.swift:74:19: error: unterminated string literal\n    if\
    \ planet1 == \"Venus\n                  ^\n"
  stdout: ''
  timestamp: 1659823230
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    var planets = [String]()\n\
    \    \n    if planet1 == planet2 {\n        return planets\n    }\n    \n    if\
    \ planet1 == \"Mercury\" {\n        planets = [\"Venus\"]\n    } else if planet1\
    \ == \"Venus\" {\n        planets = [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\", \"Neptune\"]\n    } else if planet1 == \"Earth\" {\n        planets\
    \ = [\"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"]\n    } else if\
    \ planet1 == \"Mars\" {\n        planets = [\"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    } else if planet1 == \"Jupiter\" {\n        planets = [\"\
    Saturn\", \"Uranus\", \"Neptune\"]\n    } else if planet1 == \"Saturn\" {\n  \
    \      planets = [\"Uranus\", \"Neptune\"]\n    } else if planet1 == \"Uranus\"\
    \ {\n        planets = [\"Neptune\"]\n    } else if planet1 == \"Neptune\" {\n\
    \        planets = [\"Mercury\", \"Venus\"]\n    }\n    \n    if planet2 == \"\
    Mercury\" {\n        planets = [\"Venus\"]\n    } else if planet2 == \"Venus\"\
    \ {\n        planets = [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    } else if planet2 == \"Earth\" {\n        planets = [\"Mars\"\
    , \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"]\n    } else if planet2 ==\
    \ \"Mars\" {\n        planets = [\"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    ]\n    } else if planet2 == \"Jupiter\" {\n        planets = [\"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    } else if planet2 == \"Saturn\" {\n        planets = [\"Uranus\"\
    , \"Neptune\"]\n    } else if planet2 == \"Uranus\" {\n        planets = [\"Neptune\"\
    ]\n    } else if planet2 == \"Neptune\" {\n        planets = [\"Mercury\", \"\
    Venus\"]\n    }\n    \n    return planets\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\") == [\"Saturn\", \"\
    Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\") == [\"Venus\"\
    ])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"Neptune\", planet2:\
    \ \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"])\n\
    assert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Makemake\") == [] as [String])"
  status: Exception
  stderr: 'tmp8grfsni8/tmp8grfsni8.swift:74: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002afa8fef2c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002afa8fbe9b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002afa8fbe9988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002afa8fbe87b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp8grfsni8                        0x0000557d9c5345cb <unavailable> + 5579

    5    libc.so.6                          0x00002afa900de460 __libc_start_main +
    245

    6    tmp8grfsni8                        0x0000557d9c534179 <unavailable> + 4473

    '
  stdout: ''
  timestamp: 1659823230
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    var planets = [String]()\n\
    \    \n    if planet1 == planet2 {\n        return planets\n    }\n    \n    let\
    \ planet1Orbit = orbit(planet1)\n    let planet2Orbit = orbit(planet2)\n    \n\
    \    if planet1Orbit == planet2Orbit {\n        return planets\n    }\n    \n\
    \    let planet1Sun = sunOrbit(planet1)\n    let planet2Sun = sunOrbit(planet2)\n\
    \    \n    if planet1Sun == planet2Sun {\n        return planets\n    }\n    \n\
    \    let planet1SunDistance = distance(planet1, planet2)\n    let planet2SunDistance\
    \ = distance(planet2, planet1)\n    \n    if planet1SunDistance < planet2SunDistance\
    \ {\n        return planets\n    }\n    \n    return planets\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\") == [\"\
    Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\") ==\
    \ [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"Venus\"\
    , \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"Neptune\"\
    , planet2: \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    ])\nassert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Makemake\") == [] as [String])"
  status: SyntaxError
  stderr: "/tmp/tmpd4rtfonr.swift:22:24: error: cannot find 'orbit' in scope\n   \
    \ let planet1Orbit = orbit(planet1)\n                       ^~~~~\n/tmp/tmpd4rtfonr.swift:23:24:\
    \ error: cannot find 'orbit' in scope\n    let planet2Orbit = orbit(planet2)\n\
    \                       ^~~~~\n/tmp/tmpd4rtfonr.swift:29:22: error: cannot find\
    \ 'sunOrbit' in scope\n    let planet1Sun = sunOrbit(planet1)\n              \
    \       ^~~~~~~~\n/tmp/tmpd4rtfonr.swift:30:22: error: cannot find 'sunOrbit'\
    \ in scope\n    let planet2Sun = sunOrbit(planet2)\n                     ^~~~~~~~\n\
    /tmp/tmpd4rtfonr.swift:36:30: error: cannot find 'distance' in scope\n    let\
    \ planet1SunDistance = distance(planet1, planet2)\n                          \
    \   ^~~~~~~~\n/tmp/tmpd4rtfonr.swift:37:30: error: cannot find 'distance' in scope\n\
    \    let planet2SunDistance = distance(planet2, planet1)\n                   \
    \          ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659823230
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    var planets = [String]()\n\
    \    \n    if planet1 == \"Mercury\" || planet1 == \"Venus\" || planet1 == \"\
    Earth\" || planet1 == \"Mars\" || planet1 == \"Jupiter\" || planet1 == \"Saturn\"\
    \ || planet1 == \"Uranus\" || planet1 == \"Neptune\" {\n        planets.append(planet1)\n\
    \    }\n    \n    if planet2 == \"Mercury\" || planet2 == \"Venus\" || planet2\
    \ == \"Earth\" || planet2 == \"Mars\" || planet2 == \"Jupiter\" || planet2 ==\
    \ \"Saturn\" || planet2 == \"Uranus\" || planet2 == \"Neptune\" {\n        planets.append(planet2)\n\
    \    }\n    \n    if planet1 == planet2 {\n        return planets\n    }\n   \
    \ \n    if planet1 == \"Mercury\" && planet2 == \"Venus\" {\n        planets.append(planet1)\n\
    \        planets.append(planet2)\n    }\n    \n    if planet1 == \"Venus\" &&\
    \ planet2 == \"Mercury\" {\n        planets.append(planet1)\n        planets.append(planet2)\n\
    \    }\n    \n    if planet1 == \"Earth\" && planet2 == \"Mars\" {\n        planets.append(planet1)\n\
    \        planets.append(planet2)\n    }\n    \n    if planet1 == \"Mars\" && planet2\
    \ == \"Earth\" {\n        planets.append(planet1)\n        planets.append(planet2)\n\
    \    }\n    \n    if planet1 == \"Jupiter\" && planet2 == \"Saturn\" {\n     \
    \   planets.append(planet1)\n        planets.append(planet2)\n    }\n    \n  \
    \  if planet1 == \"Saturn\" && planet2 == \"Jupiter\" {\n        planets.append(planet1)\n\
    \        planets.append(planet2)\n    }\n    \n    if planet1 == \"Uranus\" &&\
    \ planet2 == \"Neptune\" {\n        planets.append(planet1)\n        planets.append(planet2)\n\
    \    }\n    \n    if planet1 == \"Neptune\" && planet2 == \"Uranus\" {\n     \
    \   planets.append(planet1)\n        planets.append(planet2)\n    }\n    \n  \
    \  if planet1 == \"Mercury\" && planet2 == \"Earth\" {\n        planets.append(planet1)\n\
    \        planets.append(planet2)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1:\
    \ \"Earth\", planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\"\
    , planet2: \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    ])\nassert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2:\
    \ \"Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\"\
    ) == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: SyntaxError
  stderr: "/tmp/tmpiquzhzqj.swift:94:70: error: expected '}' at end of brace statement\n\
    assert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") == [] as [String])\n  \
    \                                                                   ^\n/tmp/tmpiquzhzqj.swift:15:55:\
    \ note: to match this opening '{'\nfunc bf(planet1: String, planet2: String) ->\
    \ [String] {\n                                                      ^\n/tmp/tmpiquzhzqj.swift:76:6:\
    \ error: operator functions can only be declared at global or in type scope\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1659823230
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    var planets = [String]()\n\
    \    \n    if planet1 == planet2 {\n        return planets\n    }\n    \n    if\
    \ planet1 == \"Mercury\" && planet2 == \"Venus\" {\n        planets = [\"Mercury\"\
    , \"Venus\"]\n        return planets\n    }\n    \n    if planet1 == \"Venus\"\
    \ && planet2 == \"Mercury\" {\n        planets = [\"Venus\", \"Mercury\"]\n  \
    \      return planets\n    }\n    \n    if planet1 == \"Earth\" && planet2 ==\
    \ \"Mars\" {\n        planets = [\"Earth\", \"Mars\"]\n        return planets\n\
    \    }\n    \n    if planet1 == \"Mars\" && planet2 == \"Earth\" {\n        planets\
    \ = [\"Mars\", \"Earth\"]\n        return planets\n    }\n    \n    if planet1\
    \ == \"Jupiter\" && planet2 == \"Saturn\" {\n        planets = [\"Jupiter\", \"\
    Saturn\"]\n        return planets\n    }\n    \n    if planet1 == \"Saturn\" &&\
    \ planet2 == \"Jupiter\" {\n        planets = [\"Saturn\", \"Jupiter\"]\n    \
    \    return planets\n    }\n    \n    if planet1 == \"Uranus\" && planet2 == \"\
    Neptune\" {\n        planets = [\"Uranus\", \"Neptune\"]\n        return planets\n\
    \    }\n    \n    if planet1 == \"Neptune\" && planet2 == \"Uranus\" {\n     \
    \   planets = [\"Neptune\", \"Uranus\"]\n        return planets\n    }\n    \n\
    \    return planets\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2:\
    \ \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\n\
    assert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"\
    Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\")\
    \ == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: Exception
  stderr: 'tmp7ahio947/tmp7ahio947.swift:78: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b81f9a51c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b81f9748b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b81f9748988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b81f97477b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp7ahio947                        0x000055e774deb5cb <unavailable> + 5579

    5    libc.so.6                          0x00002b81f9c3d460 __libc_start_main +
    245

    6    tmp7ahio947                        0x000055e774deb179 <unavailable> + 4473

    '
  stdout: ''
  timestamp: 1659823230
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    var planets = [String]()\n\
    \    \n    if planet1 == planet2 {\n        return planets\n    }\n    \n    if\
    \ planet1 == \"Mercury\" || planet1 == \"Venus\" || planet1 == \"Earth\" || planet1\
    \ == \"Mars\" || planet1 == \"Jupiter\" || planet1 == \"Saturn\" || planet1 ==\
    \ \"Uranus\" || planet1 == \"Neptune\" {\n        planets.append(planet1)\n  \
    \  }\n    \n    if planet2 == \"Mercury\" || planet2 == \"Venus\" || planet2 ==\
    \ \"Earth\" || planet2 == \"Mars\" || planet2 == \"Jupiter\" || planet2 == \"\
    Saturn\" || planet2 == \"Uranus\" || planet2 == \"Neptune\" {\n        planets.append(planet2)\n\
    \    }\n    \n    if planet1 == \"Mercury\" && planet2 == \"Venus\" {\n      \
    \  planets.append(planet1)\n        planets.append(planet2)\n    }\n    \n   \
    \ if planet1 == \"Venus\" && planet2 == \"Mercury\" {\n        planets.append(planet1)\n\
    \        planets.append(planet2)\n    }\n    \n    if planet1 == \"Earth\" &&\
    \ planet2 == \"Mars\" {\n        planets.append(planet1)\n        planets.append(planet2)\n\
    \    }\n    \n    if planet1 == \"Mars\" && planet2 == \"Earth\" {\n        planets.append(planet1)\n\
    \        planets.append(planet2)\n    }\n    \n    if planet1 == \"Jupiter\" &&\
    \ planet2 == \"Saturn\" {\n        planets.append(planet1)\n        planets.append(planet2)\n\
    \    }\n    \n    if planet1 == \"Saturn\" && planet2 == \"Jupiter\" {\n     \
    \   planets.append(planet1)\n        planets.append(planet2)\n    }\n    \n  \
    \  if planet1 == \"Uranus\" && planet2 == \"Neptune\" {\n        planets.append(planet1)\n\
    \        planets.append(planet2)\n    }\n    \n    if planet1 == \"Neptune\" &&\
    \ planet2 == \"Uranus\" {\n        planets.append(planet1)\n        planets.append(planet2)\n\
    \    }\n    \n    if planet1 == \"Mercury\" && planet2 == \"Earth\" {\n      \
    \  planets.append(planet1)\n        planets.append(planet2)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\") == [\"\
    Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\") ==\
    \ [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"Venus\"\
    , \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"Neptune\"\
    , planet2: \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    ])\nassert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Makemake\") == [] as [String])"
  status: SyntaxError
  stderr: "/tmp/tmpbb3b92n7.swift:94:70: error: expected '}' at end of brace statement\n\
    assert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") == [] as [String])\n  \
    \                                                                   ^\n/tmp/tmpbb3b92n7.swift:15:55:\
    \ note: to match this opening '{'\nfunc bf(planet1: String, planet2: String) ->\
    \ [String] {\n                                                      ^\n/tmp/tmpbb3b92n7.swift:76:6:\
    \ error: operator functions can only be declared at global or in type scope\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1659823230
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    \n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\") == [\"\
    Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\") ==\
    \ [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"Venus\"\
    , \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"Neptune\"\
    , planet2: \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    ])\nassert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Makemake\") == [] as [String])"
  status: SyntaxError
  stderr: '/tmp/tmp3d9bvts2.swift:17:1: error: missing return in global function expected
    to return ''[String]''

    }

    ^

    '
  stdout: ''
  timestamp: 1659823230
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    var planets = [String]()\n\
    \    \n    if planet1 == \"Mercury\" || planet1 == \"Venus\" || planet1 == \"\
    Earth\" || planet1 == \"Mars\" || planet1 == \"Jupiter\" || planet1 == \"Saturn\"\
    \ || planet1 == \"Uranus\" || planet1 == \"Neptune\" {\n        planets.append(planet1)\n\
    \    }\n    \n    if planet2 == \"Mercury\" || planet2 == \"Venus\" || planet2\
    \ == \"Earth\" || planet2 == \"Mars\" || planet2 == \"Jupiter\" || planet2 ==\
    \ \"Saturn\" || planet2 == \"Uranus\" || planet2 == \"Neptune\" {\n        planets.append(planet2)\n\
    \    }\n    \n    return planets\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1:\
    \ \"Earth\", planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\"\
    , planet2: \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    ])\nassert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2:\
    \ \"Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\"\
    ) == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: Exception
  stderr: 'tmpvahu4dty/tmpvahu4dty.swift:42: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b2b5c1b4c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b2b5beabb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b2b5beab988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b2b5beaa7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpvahu4dty                        0x000055ed352d362b <unavailable> + 5675

    5    libc.so.6                          0x00002b2b5c3a0460 __libc_start_main +
    245

    6    tmpvahu4dty                        0x000055ed352d31d9 <unavailable> + 4569

    '
  stdout: ''
  timestamp: 1659823230
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    var result: [String]\
    \ = []\n    \n    if planet1 == planet2 {\n        return result\n    }\n    \n\
    \    let planet1Orbit = orbit(planet1)\n    let planet2Orbit = orbit(planet2)\n\
    \    \n    if planet1Orbit == planet2Orbit {\n        return result\n    }\n \
    \   \n    let planet1Orbits = planet1Orbit.map { orbit($0) }\n    let planet2Orbits\
    \ = planet2Orbit.map { orbit($0) }\n    \n    let planet1OrbitsSet = Set(planet1Orbits)\n\
    \    let planet2OrbitsSet = Set(planet2Orbits)\n    \n    let planet1OrbitsSetUnion\
    \ = planet1OrbitsSet.union(planet2OrbitsSet)\n    let planet2OrbitsSetUnion =\
    \ planet2OrbitsSet.union(planet1OrbitsSet)\n    \n    let planet1OrbitsSetDifference\
    \ = planet1OrbitsSet.difference(planet2OrbitsSet)\n    let planet2OrbitsSetDifference\
    \ = planet2OrbitsSet.difference(planet1OrbitsSet)\n    \n    let planet1OrbitsSetIntersection\
    \ = planet1OrbitsSet.intersection(planet2OrbitsSet)\n    let planet2OrbitsSetIntersection\
    \ = planet2OrbitsSet.intersection(planet1OrbitsSet)\n    \n    let planet1OrbitsSetSymmetricDifference\
    \ = planet1OrbitsSet.symmetricDifference(planet2OrbitsSet)\n    let planet2OrbitsSetSymmetricDifference\
    \ = planet2OrbitsSet.symmetricDifference(planet1OrbitsSet)\n    \n    let planet1OrbitsSetSymmetricIntersection\
    \ = planet1OrbitsSet.symmetricIntersection(planet2OrbitsSet)\n    let planet2OrbitsSetSymmetricIntersection\
    \ = planet2OrbitsSet.symmetricIntersection(planet1OrbitsSet)\n    \n    let planet1OrbitsSetIsSubset\
    \ = planet1OrbitsSet.isSubset(planet2OrbitsSet)\n    let planet2OrbitsSetIsSubset\
    \ = planet2OrbitsSet.isSubset(planet1OrbitsSet)\n    \n    let planet1OrbitsSetIsSuperset\
    \ = planet1OrbitsSet.isSuperset(planet2OrbitsSet)\n    let planet2Or\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\"\
    ) == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\"\
    ) == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"\
    Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\n\
    assert(bf(planet1: \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Makemake\") == [] as [String])"
  status: SyntaxError
  stderr: "/tmp/tmpdp12i48o.swift:22:24: error: cannot find 'orbit' in scope\n   \
    \ let planet1Orbit = orbit(planet1)\n                       ^~~~~\n/tmp/tmpdp12i48o.swift:23:24:\
    \ error: cannot find 'orbit' in scope\n    let planet2Orbit = orbit(planet2)\n\
    \                       ^~~~~\n/tmp/tmpdp12i48o.swift:29:44: error: cannot find\
    \ 'orbit' in scope\n    let planet1Orbits = planet1Orbit.map { orbit($0) }\n \
    \                                          ^~~~~\n/tmp/tmpdp12i48o.swift:30:44:\
    \ error: cannot find 'orbit' in scope\n    let planet2Orbits = planet2Orbit.map\
    \ { orbit($0) }\n                                           ^~~~~\n/tmp/tmpdp12i48o.swift:54:9:\
    \ error: type annotation missing in pattern\n    let planet2Or\n        ^\n"
  stdout: ''
  timestamp: 1659823230
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    var planets = [String]()\n\
    \    \n    if planet1 == planet2 {\n        return planets\n    }\n    \n    if\
    \ planet1 == \"Mercury\" || planet1 == \"Venus\" || planet1 == \"Earth\" || planet1\
    \ == \"Mars\" || planet1 == \"Jupiter\" || planet1 == \"Saturn\" || planet1 ==\
    \ \"Uranus\" || planet1 == \"Neptune\" {\n        planets.append(planet1)\n  \
    \  }\n    \n    if planet2 == \"Mercury\" || planet2 == \"Venus\" || planet2 ==\
    \ \"Earth\" || planet2 == \"Mars\" || planet2 == \"Jupiter\" || planet2 == \"\
    Saturn\" || planet2 == \"Uranus\" || planet2 == \"Neptune\" {\n        planets.append(planet2)\n\
    \    }\n    \n    if planet1 == \"Mercury\" && planet2 == \"Venus\" {\n      \
    \  planets.append(planet1)\n        planets.append(planet2)\n    }\n    \n   \
    \ if planet1 == \"Venus\" && planet2 == \"Mercury\" {\n        planets.append(planet1)\n\
    \        planets.append(planet2)\n    }\n    \n    if planet1 == \"Earth\" &&\
    \ planet2 == \"Mars\" {\n        planets.append(planet1)\n        planets.append(planet2)\n\
    \    }\n    \n    if planet1 == \"Mars\" && planet2 == \"Earth\" {\n        planets.append(planet1)\n\
    \        planets.append(planet2)\n    }\n    \n    if planet1 == \"Jupiter\" &&\
    \ planet2 == \"Saturn\" {\n        planets.append(planet1)\n        planets.append(planet2)\n\
    \    }\n    \n    if planet1 == \"Saturn\" && planet2 == \"Jupiter\" {\n     \
    \   planets.append(planet1)\n        planets.append(planet2)\n    }\n    \n  \
    \  if planet1 == \"Uranus\" && planet2 == \"Neptune\" {\n        planets.append(planet1)\n\
    \        planets.append(planet2)\n    }\n    \n    if planet1 == \"Neptune\" &&\
    \ planet2 == \"Uranus\" {\n        planets.append(planet1)\n        planets.append(planet2)\n\
    \    }\n    \n    if planet1 == \"Mercury\" && planet2 == \"Earth\" {\n      \
    \  planets.append(planet1)\n        planets.append(planet2)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\") == [\"\
    Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\") ==\
    \ [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"Venus\"\
    , \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"Neptune\"\
    , planet2: \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    ])\nassert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Makemake\") == [] as [String])"
  status: SyntaxError
  stderr: "/tmp/tmpbb3b92n7.swift:94:70: error: expected '}' at end of brace statement\n\
    assert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") == [] as [String])\n  \
    \                                                                   ^\n/tmp/tmpbb3b92n7.swift:15:55:\
    \ note: to match this opening '{'\nfunc bf(planet1: String, planet2: String) ->\
    \ [String] {\n                                                      ^\n/tmp/tmpbb3b92n7.swift:76:6:\
    \ error: operator functions can only be declared at global or in type scope\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1659823230
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    var planets = [String]()\n\
    \    \n    // TODO: Write your code here\n    \n    return planets\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\"\
    ) == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\"\
    ) == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"\
    Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\n\
    assert(bf(planet1: \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Makemake\") == [] as [String])"
  status: Exception
  stderr: 'tmpqir0zopy/tmpqir0zopy.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b71b763fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b71b7336b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b71b7336988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b71b73357b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpqir0zopy                        0x00005603381a456b <unavailable> + 5483

    5    libc.so.6                          0x00002b71b782b460 __libc_start_main +
    245

    6    tmpqir0zopy                        0x00005603381a4119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659823230
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    var planets = [String]()\n\
    \    \n    switch planet1 {\n    case \"Mercury\":\n        planets = [\"Venus\"\
    , \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"]\n   \
    \ case \"Venus\":\n        planets = [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\", \"Neptune\"]\n    case \"Earth\":\n        planets = [\"Mars\",\
    \ \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"]\n    case \"Mars\":\n    \
    \    planets = [\"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"]\n    case \"\
    Jupiter\":\n        planets = [\"Saturn\", \"Uranus\", \"Neptune\"]\n    case\
    \ \"Saturn\":\n        planets = [\"Uranus\", \"Neptune\"]\n    case \"Uranus\"\
    :\n        planets = [\"Neptune\"]\n    case \"Neptune\":\n        planets = []\n\
    \    default:\n        return planets\n    }\n    \n    switch planet2 {\n   \
    \ case \"Mercury\":\n        planets = [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\", \"Neptune\"]\n    case \"Venus\":\n        planets =\
    \ [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"]\n  \
    \  case \"Earth\":\n        planets = [\"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    case \"Mars\":\n        planets = [\"Jupiter\", \"Saturn\"\
    , \"Uranus\", \"Neptune\"]\n    case \"Jupiter\":\n        planets = [\"Saturn\"\
    , \"Uranus\", \"Neptune\"]\n    case \"Saturn\":\n        planets = [\"Uranus\"\
    , \"Neptune\"]\n    case \"Uranus\":\n        planets = [\"Neptune\"]\n    case\
    \ \"Neptune\":\n        planets = []\n    default:\n        return planets\n \
    \   }\n    \n    var planet1 = planets.firstIndex(of: planet1)!\n    var planet2\
    \ = planets.firstIndex(of: planet2)!\n    \n    var orbit1 = planets[planet1]\n\
    \    var orbit2 = planets[planet2]\n    \n    var distance1 = distance(planet1,\
    \ orbit1)\n    var distance2 = distance(planet2, orbit2)\n    \n    var distance\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\"\
    ) == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\"\
    ) == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"\
    Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\n\
    assert(bf(planet1: \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Makemake\") == [] as [String])"
  status: SyntaxError
  stderr: "/tmp/tmp3y4b8s9m.swift:66:21: error: use of local variable 'distance' before\
    \ its declaration\n    var distance1 = distance(planet1, orbit1)\n           \
    \         ^\n/tmp/tmp3y4b8s9m.swift:69:9: note: 'distance' declared here\n   \
    \ var distance\n        ^\n/tmp/tmp3y4b8s9m.swift:67:21: error: use of local variable\
    \ 'distance' before its declaration\n    var distance2 = distance(planet2, orbit2)\n\
    \                    ^\n/tmp/tmp3y4b8s9m.swift:69:9: note: 'distance' declared\
    \ here\n    var distance\n        ^\n/tmp/tmp3y4b8s9m.swift:69:9: error: type\
    \ annotation missing in pattern\n    var distance\n        ^\n"
  stdout: ''
  timestamp: 1659823230
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    var planets = [String]()\n\
    \    \n    if planet1 == planet2 {\n        return planets\n    }\n    \n    if\
    \ planet1 == \"Mercury\" || planet1 == \"Venus\" || planet1 == \"Earth\" || planet1\
    \ == \"Mars\" || planet1 == \"Jupiter\" || planet1 == \"Saturn\" || planet1 ==\
    \ \"Uranus\" || planet1 == \"Neptune\" {\n        planets.append(planet1)\n  \
    \  }\n    \n    if planet2 == \"Mercury\" || planet2 == \"Venus\" || planet2 ==\
    \ \"Earth\" || planet2 == \"Mars\" || planet2 == \"Jupiter\" || planet2 == \"\
    Saturn\" || planet2 == \"Uranus\" || planet2 == \"Neptune\" {\n        planets.append(planet2)\n\
    \    }\n    \n    if planet1 == \"Mercury\" && planet2 == \"Earth\" {\n      \
    \  planets.append(\"Mars\")\n    }\n    \n    if planet1 == \"Mercury\" && planet2\
    \ == \"Mars\" {\n        planets.append(\"Jupiter\")\n    }\n    \n    if planet1\
    \ == \"Mercury\" && planet2 == \"Jupiter\" {\n        planets.append(\"Saturn\"\
    )\n    }\n    \n    if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n   \
    \     planets.append(\"Uranus\")\n    }\n    \n    if planet1 == \"Mercury\" &&\
    \ planet2 == \"Uranus\" {\n        planets.append(\"Neptune\")\n    }\n    \n\
    \    if planet1 == \"Venus\" && planet2 == \"Earth\" {\n        planets.append(\"\
    Mercury\")\n    }\n    \n    if planet1 == \"Venus\" && planet2 == \"Mercury\"\
    \ {\n        planets.append(\"Earth\")\n    }\n    \n    if planet1 == \"Venus\"\
    \ && planet2 == \"Earth\" {\n        planets.append(\"Mars\")\n    }\n    \n \
    \   if planet1 == \"Venus\" && planet2 == \"Mars\" {\n        planets.append(\"\
    Jupiter\")\n    }\n    \n    if planet1 == \"Venus\" && planet2 == \"Jupiter\"\
    \ {\n        planets.append(\"Saturn\")\n    }\n    \n    if planet1 == \"Venus\"\
    \ && planet2 == \"Saturn\" {\n        planets.append(\"Uranus\")\n    }\n    \n\
    \    if planet1 == \"Venus\" && plan\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(bf(planet1: \"Jupiter\", planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"\
    ])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1:\
    \ \"Mercury\", planet2: \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"])\nassert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2:\
    \ \"Earth\") == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\"\
    ) == [] as [String])"
  status: SyntaxError
  stderr: "/tmp/tmpatg5q088.swift:74:34: error: expected '{' after 'if' condition\n\
    \    if planet1 == \"Venus\" && plan\n                                 ^\n/tmp/tmpatg5q088.swift:74:30:\
    \ error: cannot find 'plan' in scope\n    if planet1 == \"Venus\" && plan\n  \
    \                           ^~~~\n"
  stdout: ''
  timestamp: 1659823230
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    \n    var planets\
    \ = [String]()\n    \n    if planet1 == \"Mercury\" && planet2 == \"Venus\" {\n\
    \        planets = [\"Mercury\", \"Venus\"]\n    } else if planet1 == \"Venus\"\
    \ && planet2 == \"Earth\" {\n        planets = [\"Venus\", \"Earth\"]\n    } else\
    \ if planet1 == \"Earth\" && planet2 == \"Mars\" {\n        planets = [\"Earth\"\
    , \"Mars\"]\n    } else if planet1 == \"Mars\" && planet2 == \"Jupiter\" {\n \
    \       planets = [\"Mars\", \"Jupiter\"]\n    } else if planet1 == \"Jupiter\"\
    \ && planet2 == \"Saturn\" {\n        planets = [\"Jupiter\", \"Saturn\"]\n  \
    \  } else if planet1 == \"Saturn\" && planet2 == \"Uranus\" {\n        planets\
    \ = [\"Saturn\", \"Uranus\"]\n    } else if planet1 == \"Uranus\" && planet2 ==\
    \ \"Neptune\" {\n        planets = [\"Uranus\", \"Neptune\"]\n    } else if planet1\
    \ == \"Neptune\" && planet2 == \"Mercury\" {\n        planets = [\"Neptune\",\
    \ \"Mercury\"]\n    } else if planet1 == \"Mercury\" && planet2 == \"Earth\" {\n\
    \        planets = [\"Mercury\", \"Earth\"]\n    } else if planet1 == \"Earth\"\
    \ && planet2 == \"Mars\" {\n        planets = [\"Earth\", \"Mars\"]\n    } else\
    \ if planet1 == \"Mars\" && planet2 == \"Jupiter\" {\n        planets = [\"Mars\"\
    , \"Jupiter\"]\n    } else if planet1 == \"Jupiter\" && planet2 == \"Saturn\"\
    \ {\n        planets = [\"Jupiter\", \"Saturn\"]\n    } else if planet1 == \"\
    Saturn\" && planet2 == \"Uranus\" {\n        planets = [\"Saturn\", \"Uranus\"\
    ]\n    } else if planet1 == \"Uranus\" && planet2 == \"Neptune\" {\n        planets\
    \ = [\"Uranus\", \"Neptune\"]\n    } else if planet1 == \"Neptune\" && planet2\
    \ == \"Mercury\" {\n        planets = [\"Neptune\", \"Mercury\"]\n    } else if\
    \ planet1 == \"Mercury\" && planet2 == \"Earth\" {\n        planets = [\"Mercury\"\
    , \"Earth\"]\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2:\
    \ \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\n\
    assert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"\
    Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\")\
    \ == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: SyntaxError
  stderr: "/tmp/tmpk4yflkkn.swift:72:70: error: expected '}' at end of brace statement\n\
    assert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") == [] as [String])\n  \
    \                                                                   ^\n/tmp/tmpk4yflkkn.swift:15:55:\
    \ note: to match this opening '{'\nfunc bf(planet1: String, planet2: String) ->\
    \ [String] {\n                                                      ^\n/tmp/tmpk4yflkkn.swift:54:6:\
    \ error: operator functions can only be declared at global or in type scope\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n/tmp/tmpk4yflkkn.swift:17:9:\
    \ warning: variable 'planets' was written to, but never read\n    var planets\
    \ = [String]()\n        ^\n"
  stdout: ''
  timestamp: 1659823230
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    var planets = [String]()\n\
    \    var orbit1 = orbit(planet1)\n    var orbit2 = orbit(planet2)\n    var distance1\
    \ = distance(orbit1)\n    var distance2 = distance(orbit2)\n    var distance3\
    \ = distance(orbit1, orbit2)\n    var distance4 = distance(orbit1, orbit2)\n \
    \   var distance5 = distance(orbit1, orbit2)\n    var distance6 = distance(orbit1,\
    \ orbit2)\n    var distance7 = distance(orbit1, orbit2)\n    var distance8 = distance(orbit1,\
    \ orbit2)\n    if distance1 < distance2 {\n        planets.append(planet1)\n \
    \       planets.append(planet2)\n    }\n    if distance2 < distance3 {\n     \
    \   planets.append(planet2)\n        planets.append(planet1)\n    }\n    if distance3\
    \ < distance4 {\n        planets.append(planet1)\n        planets.append(planet2)\n\
    \    }\n    if distance4 < distance5 {\n        planets.append(planet2)\n    \
    \    planets.append(planet1)\n    }\n    if distance5 < distance6 {\n        planets.append(planet1)\n\
    \        planets.append(planet2)\n    }\n    if distance6 < distance7 {\n    \
    \    planets.append(planet2)\n        planets.append(planet1)\n    }\n    if distance7\
    \ < distance8 {\n        planets.append(planet2)\n        planets.append(planet1)\n\
    \    }\n    if distance8 < distance1 {\n        planets.append(planet1)\n    \
    \    planets.append(planet2)\n    }\n    return planets\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\") == [\"\
    Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\") ==\
    \ [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"Venus\"\
    , \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"Neptune\"\
    , planet2: \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    ])\nassert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Makemake\") == [] as [String])"
  status: SyntaxError
  stderr: "/tmp/tmp4asl08pj.swift:17:18: error: cannot find 'orbit' in scope\n   \
    \ var orbit1 = orbit(planet1)\n                 ^~~~~\n/tmp/tmp4asl08pj.swift:18:18:\
    \ error: cannot find 'orbit' in scope\n    var orbit2 = orbit(planet2)\n     \
    \            ^~~~~\n/tmp/tmp4asl08pj.swift:19:21: error: cannot find 'distance'\
    \ in scope\n    var distance1 = distance(orbit1)\n                    ^~~~~~~~\n\
    /tmp/tmp4asl08pj.swift:20:21: error: cannot find 'distance' in scope\n    var\
    \ distance2 = distance(orbit2)\n                    ^~~~~~~~\n/tmp/tmp4asl08pj.swift:21:21:\
    \ error: cannot find 'distance' in scope\n    var distance3 = distance(orbit1,\
    \ orbit2)\n                    ^~~~~~~~\n/tmp/tmp4asl08pj.swift:22:21: error:\
    \ cannot find 'distance' in scope\n    var distance4 = distance(orbit1, orbit2)\n\
    \                    ^~~~~~~~\n/tmp/tmp4asl08pj.swift:23:21: error: cannot find\
    \ 'distance' in scope\n    var distance5 = distance(orbit1, orbit2)\n        \
    \            ^~~~~~~~\n/tmp/tmp4asl08pj.swift:24:21: error: cannot find 'distance'\
    \ in scope\n    var distance6 = distance(orbit1, orbit2)\n                   \
    \ ^~~~~~~~\n/tmp/tmp4asl08pj.swift:25:21: error: cannot find 'distance' in scope\n\
    \    var distance7 = distance(orbit1, orbit2)\n                    ^~~~~~~~\n\
    /tmp/tmp4asl08pj.swift:26:21: error: cannot find 'distance' in scope\n    var\
    \ distance8 = distance(orbit1, orbit2)\n                    ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659823230
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    \n    var planets\
    \ = [String]()\n    \n    if planet1 == planet2 {\n        return planets\n  \
    \  }\n    \n    if planet1 == \"Mercury\" && planet2 == \"Venus\" {\n        planets\
    \ = [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"]\n\
    \    } else if planet1 == \"Venus\" && planet2 == \"Mercury\" {\n        planets\
    \ = [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"]\n\
    \    } else if planet1 == \"Earth\" && planet2 == \"Mars\" {\n        planets\
    \ = [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"]\n\
    \    } else if planet1 == \"Mars\" && planet2 == \"Earth\" {\n        planets\
    \ = [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"]\n\
    \    } else if planet1 == \"Jupiter\" && planet2 == \"Saturn\" {\n        planets\
    \ = [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"]\n\
    \    } else if planet1 == \"Saturn\" && planet2 == \"Jupiter\" {\n        planets\
    \ = [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"]\n\
    \    } else if planet1 == \"Uranus\" && planet2 == \"Neptune\" {\n        planets\
    \ = [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"]\n\
    \    } else if planet1 == \"Neptune\" && planet2 == \"Uranus\" {\n        planets\
    \ = [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"]\n\
    \    }\n    \n    return planets\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1:\
    \ \"Earth\", planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\"\
    , planet2: \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    ])\nassert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2:\
    \ \"Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\"\
    ) == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: Exception
  stderr: 'tmp0nvwup5m/tmp0nvwup5m.swift:57: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b3c85314c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3c8500bb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b3c8500b988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b3c8500a7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp0nvwup5m                        0x000055fa6769f5cb <unavailable> + 5579

    5    libc.so.6                          0x00002b3c85500460 __libc_start_main +
    245

    6    tmp0nvwup5m                        0x000055fa6769f179 <unavailable> + 4473

    '
  stdout: ''
  timestamp: 1659823231
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    var planets = [String]()\n\
    \    \n    if planet1 == planet2 {\n        return planets\n    }\n    \n    if\
    \ planet1 == \"Mercury\" {\n        planets.append(\"Venus\")\n    }\n    \n \
    \   if planet1 == \"Venus\" {\n        planets.append(\"Earth\")\n    }\n    \n\
    \    if planet1 == \"Earth\" {\n        planets.append(\"Mars\")\n    }\n    \n\
    \    if planet1 == \"Mars\" {\n        planets.append(\"Jupiter\")\n    }\n  \
    \  \n    if planet1 == \"Jupiter\" {\n        planets.append(\"Saturn\")\n   \
    \ }\n    \n    if planet1 == \"Saturn\" {\n        planets.append(\"Uranus\")\n\
    \    }\n    \n    if planet1 == \"Uranus\" {\n        planets.append(\"Neptune\"\
    )\n    }\n    \n    if planet1 == \"Neptune\" {\n        planets.append(\"Mercury\"\
    )\n    }\n    \n    if planet2 == \"Mercury\" {\n        planets.append(\"Venus\"\
    )\n    }\n    \n    if planet2 == \"Venus\" {\n        planets.append(\"Earth\"\
    )\n    }\n    \n    if planet2 == \"Earth\" {\n        planets.append(\"Mars\"\
    )\n    }\n    \n    if planet2 == \"Mars\" {\n        planets.append(\"Jupiter\"\
    )\n    }\n    \n    if planet2 == \"Jupiter\" {\n        planets.append(\"Saturn\"\
    )\n    }\n    \n    if planet2 == \"Saturn\" {\n        planets.append(\"Uranus\"\
    )\n    }\n    \n    if planet2 == \"Uranus\" {\n        planets.append(\"Neptune\"\
    )\n    }\n    \n    if planet2 == \"Neptune\" {\n        planets.append(\"Mercury\"\
    )\n    }\n    \n    return planets\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(bf(planet1: \"Jupiter\", planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"\
    ])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1:\
    \ \"Mercury\", planet2: \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"])\nassert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2:\
    \ \"Earth\") == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\"\
    ) == [] as [String])"
  status: Exception
  stderr: 'tmp01j43xsq/tmp01j43xsq.swift:102: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae180e98c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae180b8fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae180b8f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae180b8e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp01j43xsq                        0x0000557927d3362b <unavailable> + 5675

    5    libc.so.6                          0x00002ae181084460 __libc_start_main +
    245

    6    tmp01j43xsq                        0x0000557927d331d9 <unavailable> + 4569

    '
  stdout: ''
  timestamp: 1659823230
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    var planets = [String]()\n\
    \    \n    if planet1 == planet2 {\n        return planets\n    }\n    \n    if\
    \ planet1 == \"Sun\" {\n        return planets\n    }\n    \n    if planet2 ==\
    \ \"Sun\" {\n        return planets\n    }\n    \n    if planet1 == \"Mercury\"\
    \ {\n        if planet2 == \"Venus\" {\n            planets = [\"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"]\n        } else if planet2\
    \ == \"Earth\" {\n            planets = [\"Mars\", \"Jupiter\", \"Saturn\", \"\
    Uranus\", \"Neptune\"]\n        } else if planet2 == \"Mars\" {\n            planets\
    \ = [\"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"]\n        } else if planet2\
    \ == \"Jupiter\" {\n            planets = [\"Saturn\", \"Uranus\", \"Neptune\"\
    ]\n        } else if planet2 == \"Saturn\" {\n            planets = [\"Uranus\"\
    , \"Neptune\"]\n        } else if planet2 == \"Uranus\" {\n            planets\
    \ = [\"Neptune\"]\n        } else if planet2 == \"Neptune\" {\n            planets\
    \ = []\n        }\n    } else if planet1 == \"Venus\" {\n        if planet2 ==\
    \ \"Earth\" {\n            planets = [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\", \"Neptune\"]\n        } else if planet2 == \"Mars\" {\n        \
    \    planets = [\"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"]\n        } else\
    \ if planet2 == \"Jupiter\" {\n            planets = [\"Saturn\", \"Uranus\",\
    \ \"Neptune\"]\n        } else if planet2 == \"Saturn\" {\n            planets\
    \ = [\"Uranus\", \"Neptune\"]\n        } else if planet2 == \"Uranus\" {\n   \
    \         planets = [\"Neptune\"]\n        } else if planet2 == \"Neptune\" {\n\
    \            planets = []\n        }\n    } else if planet1 == \"Earth\" {\n \
    \       if planet2 == \"Mars\" {\n            planets = [\"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\", \"Neptune\"]\n        } else if planet2 == \"Jupiter\"\
    \ {\n            planet\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1:\
    \ \"Earth\", planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\"\
    , planet2: \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    ])\nassert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2:\
    \ \"Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\"\
    ) == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: SyntaxError
  stderr: "/tmp/tmpjy3z0qe_.swift:86:70: error: expected '}' at end of brace statement\n\
    assert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") == [] as [String])\n  \
    \                                                                   ^\n/tmp/tmpjy3z0qe_.swift:60:34:\
    \ note: to match this opening '{'\n    } else if planet1 == \"Earth\" {\n    \
    \                             ^\n/tmp/tmpjy3z0qe_.swift:86:70: error: expected\
    \ '}' at end of brace statement\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\"\
    ) == [] as [String])\n                                                       \
    \              ^\n/tmp/tmpjy3z0qe_.swift:15:55: note: to match this opening '{'\n\
    func bf(planet1: String, planet2: String) -> [String] {\n                    \
    \                                  ^\n/tmp/tmpjy3z0qe_.swift:64:13: error: cannot\
    \ find 'planet' in scope\n            planet\n            ^~~~~~\n/tmp/tmpjy3z0qe_.swift:68:6:\
    \ error: operator functions can only be declared at global or in type scope\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1659823230
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    \n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\") == [\"\
    Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\") ==\
    \ [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"Venus\"\
    , \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"Neptune\"\
    , planet2: \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    ])\nassert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Makemake\") == [] as [String])"
  status: SyntaxError
  stderr: '/tmp/tmp3d9bvts2.swift:17:1: error: missing return in global function expected
    to return ''[String]''

    }

    ^

    '
  stdout: ''
  timestamp: 1659823230
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    \n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\") == [\"\
    Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\") ==\
    \ [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"Venus\"\
    , \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"Neptune\"\
    , planet2: \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    ])\nassert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Makemake\") == [] as [String])"
  status: SyntaxError
  stderr: '/tmp/tmp3d9bvts2.swift:17:1: error: missing return in global function expected
    to return ''[String]''

    }

    ^

    '
  stdout: ''
  timestamp: 1659823230
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    \n    var planets\
    \ = [String]()\n    \n    if planet1 == planet2 {\n        return planets\n  \
    \  }\n    \n    if planet1 == \"Mercury\" || planet1 == \"Venus\" || planet1 ==\
    \ \"Earth\" || planet1 == \"Mars\" || planet1 == \"Jupiter\" || planet1 == \"\
    Saturn\" || planet1 == \"Uranus\" || planet1 == \"Neptune\" {\n        planets.append(planet1)\n\
    \    }\n    \n    if planet2 == \"Mercury\" || planet2 == \"Venus\" || planet2\
    \ == \"Earth\" || planet2 == \"Mars\" || planet2 == \"Jupiter\" || planet2 ==\
    \ \"Saturn\" || planet2 == \"Uranus\" || planet2 == \"Neptune\" {\n        planets.append(planet2)\n\
    \    }\n    \n    if planet1 == \"Mercury\" && planet2 == \"Venus\" {\n      \
    \  planets.append(planet1)\n        planets.append(planet2)\n    }\n    \n   \
    \ if planet1 == \"Venus\" && planet2 == \"Mercury\" {\n        planets.append(planet1)\n\
    \        planets.append(planet2)\n    }\n    \n    if planet1 == \"Earth\" &&\
    \ planet2 == \"Mars\" {\n        planets.append(planet1)\n        planets.append(planet2)\n\
    \    }\n    \n    if planet1 == \"Mars\" && planet2 == \"Earth\" {\n        planets.append(planet1)\n\
    \        planets.append(planet2)\n    }\n    \n    if planet1 == \"Jupiter\" &&\
    \ planet2 == \"Saturn\" {\n        planets.append(planet1)\n        planets.append(planet2)\n\
    \    }\n    \n    if planet1 == \"Saturn\" && planet2 == \"Jupiter\" {\n     \
    \   planets.append(planet1)\n        planets.append(planet2)\n    }\n    \n  \
    \  if planet1 == \"Uranus\" && planet2 == \"Neptune\" {\n        planets.append(planet1)\n\
    \        planets.append(planet2)\n    }\n    \n    if planet1 == \"Neptune\" &&\
    \ planet2 == \"Uranus\" {\n        planets.append(planet1)\n        planets.append(planet2)\n\
    \    }\n    \n    if planet1 == \"Mercury\" && planet2 == \"Earth\" {\n      \
    \  planets.append(planet1)\n        planets.append(plan\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\") == [\"\
    Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\") ==\
    \ [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"Venus\"\
    , \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"Neptune\"\
    , planet2: \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    ])\nassert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Makemake\") == [] as [String])"
  status: SyntaxError
  stderr: "/tmp/tmpifm6kcsp.swift:74:1: error: expected ')' in expression list\n}\n\
    ^\n/tmp/tmpifm6kcsp.swift:73:23: note: to match this opening '('\n        planets.append(plan\n\
    \                      ^\n/tmp/tmpifm6kcsp.swift:95:70: error: expected '}' at\
    \ end of brace statement\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\"\
    ) == [] as [String])\n                                                       \
    \              ^\n/tmp/tmpifm6kcsp.swift:15:55: note: to match this opening '{'\n\
    func bf(planet1: String, planet2: String) -> [String] {\n                    \
    \                                  ^\n/tmp/tmpifm6kcsp.swift:73:24: error: cannot\
    \ find 'plan' in scope\n        planets.append(plan\n                       ^~~~\n\
    /tmp/tmpifm6kcsp.swift:77:6: error: operator functions can only be declared at\
    \ global or in type scope\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n     ^\n"
  stdout: ''
  timestamp: 1659823230
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    var planets = [String]()\n\
    \    \n    if planet1 == planet2 {\n        return planets\n    }\n    \n    if\
    \ planet1 == \"Mercury\" || planet1 == \"Venus\" || planet1 == \"Earth\" || planet1\
    \ == \"Mars\" || planet1 == \"Jupiter\" || planet1 == \"Saturn\" || planet1 ==\
    \ \"Uranus\" || planet1 == \"Neptune\" {\n        planets.append(planet1)\n  \
    \  }\n    \n    if planet2 == \"Mercury\" || planet2 == \"Venus\" || planet2 ==\
    \ \"Earth\" || planet2 == \"Mars\" || planet2 == \"Jupiter\" || planet2 == \"\
    Saturn\" || planet2 == \"Uranus\" || planet2 == \"Neptune\" {\n        planets.append(planet2)\n\
    \    }\n    \n    if planet1 == \"Mercury\" || planet1 == \"Venus\" || planet1\
    \ == \"Earth\" || planet1 == \"Mars\" || planet1 == \"Jupiter\" || planet1 ==\
    \ \"Saturn\" || planet1 == \"Uranus\" || planet1 == \"Neptune\" {\n        planets.append(planet2)\n\
    \    }\n    \n    if planet2 == \"Mercury\" || planet2 == \"Venus\" || planet2\
    \ == \"Earth\" || planet2 == \"Mars\" || planet2 == \"Jupiter\" || planet2 ==\
    \ \"Saturn\" || planet2 == \"Uranus\" || planet2 == \"Neptune\" {\n        planets.append(planet1)\n\
    \    }\n    \n    if planet1 == \"Mercury\" || planet1 == \"Venus\" || planet1\
    \ == \"Earth\" || planet1 == \"Mars\" || planet1 == \"Jupiter\" || planet1 ==\
    \ \"Saturn\" || planet1 == \"Uranus\" || planet1 == \"Neptune\" {\n        planets.append(planet2)\n\
    \    }\n    \n    if planet2 == \"Mercury\" || planet2 == \"Venus\" || planet2\
    \ == \"Earth\" || planet2 == \"Mars\" || planet2 == \"Jupiter\" || planet2 ==\
    \ \"Saturn\" || planet2 == \"Uranus\" || planet2 == \"Neptune\" {\n        planets.append(planet1)\n\
    \    }\n    \n    if planet1 == \"Mercury\" || planet1 == \"Venus\" || planet1\
    \ == \"Earth\" || planet1 == \"Mars\" || planet1 == \"Jup\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\") == [\"\
    Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\") ==\
    \ [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"Venus\"\
    , \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"Neptune\"\
    , planet2: \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    ])\nassert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Makemake\") == [] as [String])"
  status: SyntaxError
  stderr: "/tmp/tmp4i4zkkv1.swift:46:108: error: unterminated string literal\n   \
    \ if planet1 == \"Mercury\" || planet1 == \"Venus\" || planet1 == \"Earth\" ||\
    \ planet1 == \"Mars\" || planet1 == \"Jup\n                                  \
    \                                                                         ^\n"
  stdout: ''
  timestamp: 1659823230
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    var planets = [String]()\n\
    \    \n    // TODO: Write your code here\n    \n    return planets\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\"\
    ) == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\"\
    ) == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"\
    Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\n\
    assert(bf(planet1: \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Makemake\") == [] as [String])"
  status: Exception
  stderr: 'tmpqir0zopy/tmpqir0zopy.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b71b763fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b71b7336b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b71b7336988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b71b73357b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpqir0zopy                        0x00005603381a456b <unavailable> + 5483

    5    libc.so.6                          0x00002b71b782b460 __libc_start_main +
    245

    6    tmpqir0zopy                        0x00005603381a4119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659823230
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    var result = [String]()\n\
    \    \n    // TODO: Write your code here\n    \n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\"\
    ) == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\"\
    ) == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"\
    Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\n\
    assert(bf(planet1: \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Makemake\") == [] as [String])"
  status: Exception
  stderr: 'tmpeirebgxu/tmpeirebgxu.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b3a53e6fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3a53b66b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b3a53b66988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b3a53b657b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpeirebgxu                        0x0000555a58dcc56b <unavailable> + 5483

    5    libc.so.6                          0x00002b3a5405b460 __libc_start_main +
    245

    6    tmpeirebgxu                        0x0000555a58dcc119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659823230
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    var result = [String]()\n\
    \    \n    if planet1 == planet2 {\n        return result \n    }\n    \n    if\
    \ planet1 == \"Mercury\" || planet1 == \"Venus\" || planet1 == \"Earth\" || planet1\
    \ == \"Mars\" || planet1 == \"Jupiter\" || planet1 == \"Saturn\" || planet1 ==\
    \ \"Uranus\" || planet1 == \"Neptune\" {\n        return result \n    }\n    \n\
    \    if planet2 == \"Mercury\" || planet2 == \"Venus\" || planet2 == \"Earth\"\
    \ || planet2 == \"Mars\" || planet2 == \"Jupiter\" || planet2 == \"Saturn\" ||\
    \ planet2 == \"Uranus\" || planet2 == \"Neptune\" {\n        return result \n\
    \    }\n    \n    if planet1 == \"Mercury\" && planet2 == \"Venus\" {\n      \
    \  return result \n    }\n    \n    if planet1 == \"Venus\" && planet2 == \"Mercury\"\
    \ {\n        return result \n    }\n    \n    if planet1 == \"Earth\" && planet2\
    \ == \"Mars\" {\n        return result \n    }\n    \n    if planet1 == \"Mars\"\
    \ && planet2 == \"Earth\" {\n        return result \n    }\n    \n    if planet1\
    \ == \"Jupiter\" && planet2 == \"Saturn\" {\n        return result \n    }\n \
    \   \n    if planet1 == \"Saturn\" && planet2 == \"Jupiter\" {\n        return\
    \ result \n    }\n    \n    if planet1 == \"Uranus\" && planet2 == \"Neptune\"\
    \ {\n        return result \n    }\n    \n    if planet1 == \"Neptune\" && planet2\
    \ == \"Uranus\" {\n        return result \n    }\n    \n    return result \n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\"\
    ) == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\"\
    ) == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"\
    Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\n\
    assert(bf(planet1: \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Makemake\") == [] as [String])"
  status: Exception
  stderr: 'tmpzunql4cb/tmpzunql4cb.swift:78: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae7b98e7c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae7b95deb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae7b95de988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae7b95dd7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpzunql4cb                        0x00005574c346d5cb <unavailable> + 5579

    5    libc.so.6                          0x00002ae7b9ad3460 __libc_start_main +
    245

    6    tmpzunql4cb                        0x00005574c346d179 <unavailable> + 4473

    '
  stdout: ''
  timestamp: 1659823231
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    var planets = [String]()\n\
    \    \n    if planet1 == planet2 {\n        return planets\n    }\n    \n    if\
    \ planet1 == \"Mercury\" || planet1 == \"Venus\" || planet1 == \"Earth\" || planet1\
    \ == \"Mars\" || planet1 == \"Jupiter\" || planet1 == \"Saturn\" || planet1 ==\
    \ \"Uranus\" || planet1 == \"Neptune\" {\n        planets.append(planet1)\n  \
    \  }\n    \n    if planet2 == \"Mercury\" || planet2 == \"Venus\" || planet2 ==\
    \ \"Earth\" || planet2 == \"Mars\" || planet2 == \"Jupiter\" || planet2 == \"\
    Saturn\" || planet2 == \"Uranus\" || planet2 == \"Neptune\" {\n        planets.append(planet2)\n\
    \    }\n    \n    if planet1 == \"Mercury\" && planet2 == \"Venus\" {\n      \
    \  planets.append(planet1)\n        planets.append(planet2)\n    }\n    \n   \
    \ if planet1 == \"Venus\" && planet2 == \"Mercury\" {\n        planets.append(planet1)\n\
    \        planets.append(planet2)\n    }\n    \n    if planet1 == \"Earth\" &&\
    \ planet2 == \"Mars\" {\n        planets.append(planet1)\n        planets.append(planet2)\n\
    \    }\n    \n    if planet1 == \"Mars\" && planet2 == \"Earth\" {\n        planets.append(planet1)\n\
    \        planets.append(planet2)\n    }\n    \n    if planet1 == \"Jupiter\" &&\
    \ planet2 == \"Saturn\" {\n        planets.append(planet1)\n        planets.append(planet2)\n\
    \    }\n    \n    if planet1 == \"Saturn\" && planet2 == \"Jupiter\" {\n     \
    \   planets.append(planet1)\n        planets.append(planet2)\n    }\n    \n  \
    \  if planet1 == \"Uranus\" && planet2 == \"Neptune\" {\n        planets.append(planet1)\n\
    \        planets.append(planet2)\n    }\n    \n    if planet1 == \"Neptune\" &&\
    \ planet2 == \"Uranus\" {\n        planets.append(planet1)\n        planets.append(planet2)\n\
    \    }\n    \n    if planet1 == \"Mercury\" && planet2 == \"Earth\" {\n      \
    \  planets.append(planet1)\n        planets.append(planet2)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\") == [\"\
    Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\") ==\
    \ [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"Venus\"\
    , \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"Neptune\"\
    , planet2: \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    ])\nassert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Makemake\") == [] as [String])"
  status: SyntaxError
  stderr: "/tmp/tmpbb3b92n7.swift:94:70: error: expected '}' at end of brace statement\n\
    assert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") == [] as [String])\n  \
    \                                                                   ^\n/tmp/tmpbb3b92n7.swift:15:55:\
    \ note: to match this opening '{'\nfunc bf(planet1: String, planet2: String) ->\
    \ [String] {\n                                                      ^\n/tmp/tmpbb3b92n7.swift:76:6:\
    \ error: operator functions can only be declared at global or in type scope\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1659823230
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    var planets = [String]()\n\
    \    \n    if planet1 == planet2 {\n        return planets\n    }\n    \n    if\
    \ planet1 == \"Mercury\" || planet1 == \"Venus\" || planet1 == \"Earth\" || planet1\
    \ == \"Mars\" || planet1 == \"Jupiter\" || planet1 == \"Saturn\" || planet1 ==\
    \ \"Uranus\" || planet1 == \"Neptune\" {\n        planets.append(planet1)\n  \
    \  }\n    \n    if planet2 == \"Mercury\" || planet2 == \"Venus\" || planet2 ==\
    \ \"Earth\" || planet2 == \"Mars\" || planet2 == \"Jupiter\" || planet2 == \"\
    Saturn\" || planet2 == \"Uranus\" || planet2 == \"Neptune\" {\n        planets.append(planet2)\n\
    \    }\n    \n    if planet1 == \"Mercury\" && planet2 == \"Venus\" {\n      \
    \  planets.append(planet1)\n        planets.append(planet2)\n    }\n    \n   \
    \ if planet1 == \"Venus\" && planet2 == \"Mercury\" {\n        planets.append(planet1)\n\
    \        planets.append(planet2)\n    }\n    \n    if planet1 == \"Earth\" &&\
    \ planet2 == \"Mercury\" {\n        planets.append(planet1)\n        planets.append(planet2)\n\
    \    }\n    \n    if planet1 == \"Mars\" && planet2 == \"Mercury\" {\n       \
    \ planets.append(planet1)\n        planets.append(planet2)\n    }\n    \n    if\
    \ planet1 == \"Jupiter\" && planet2 == \"Mercury\" {\n        planets.append(planet1)\n\
    \        planets.append(planet2)\n    }\n    \n    if planet1 == \"Saturn\" &&\
    \ planet2 == \"Mercury\" {\n        planets.append(planet1)\n        planets.append(planet2)\n\
    \    }\n    \n    if planet1 == \"Uranus\" && planet2 == \"Mercury\" {\n     \
    \   planets.append(planet1)\n        planets.append(planet2)\n    }\n    \n  \
    \  if planet1 == \"Neptune\" && planet2 == \"Mercury\" {\n        planets.append(planet1)\n\
    \        planets.append(planet2)\n    }\n    \n    if planet1 == \"Mercury\" &&\
    \ planet2 == \"Earth\" {\n        planets.append(planet1)\n        planet\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\"\
    ) == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\"\
    ) == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"\
    Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\n\
    assert(bf(planet1: \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Makemake\") == [] as [String])"
  status: SyntaxError
  stderr: "/tmp/tmpecbl596z.swift:94:70: error: expected '}' at end of brace statement\n\
    assert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") == [] as [String])\n  \
    \                                                                   ^\n/tmp/tmpecbl596z.swift:15:55:\
    \ note: to match this opening '{'\nfunc bf(planet1: String, planet2: String) ->\
    \ [String] {\n                                                      ^\n/tmp/tmpecbl596z.swift:72:9:\
    \ error: cannot find 'planet' in scope\n        planet\n        ^~~~~~\n/tmp/tmpecbl596z.swift:76:6:\
    \ error: operator functions can only be declared at global or in type scope\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1659823230
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    var result: [String]\
    \ = []\n    \n    if planet1 == planet2 {\n        return result;\n    }\n   \
    \ \n    if planet1 == \"Mercury\" || planet1 == \"Venus\" || planet1 == \"Earth\"\
    \ || planet1 == \"Mars\" || planet1 == \"Jupiter\" || planet1 == \"Saturn\" ||\
    \ planet1 == \"Uranus\" || planet1 == \"Neptune\" {\n        return result;\n\
    \    }\n    \n    if planet2 == \"Mercury\" || planet2 == \"Venus\" || planet2\
    \ == \"Earth\" || planet2 == \"Mars\" || planet2 == \"Jupiter\" || planet2 ==\
    \ \"Saturn\" || planet2 == \"Uranus\" || planet2 == \"Neptune\" {\n        return\
    \ result;\n    }\n    \n    if planet1 == \"Mercury\" && planet2 == \"Venus\"\
    \ {\n        return result;\n    }\n    \n    if planet1 == \"Mercury\" && planet2\
    \ == \"Earth\" {\n        return result;\n    }\n    \n    if planet1 == \"Mercury\"\
    \ && planet2 == \"Mars\" {\n        return result;\n    }\n    \n    if planet1\
    \ == \"Mercury\" && planet2 == \"Jupiter\" {\n        return result;\n    }\n\
    \    \n    if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n        return\
    \ result;\n    }\n    \n    if planet1 == \"Mercury\" && planet2 == \"Uranus\"\
    \ {\n        return result;\n    }\n    \n    if planet1 == \"Mercury\" && planet2\
    \ == \"Neptune\" {\n        return result;\n    }\n    \n    if planet1 == \"\
    Venus\" && planet2 == \"Earth\" {\n        return result;\n    }\n    \n    if\
    \ planet1 == \"Venus\" && planet2 == \"Mars\" {\n        return result;\n    }\n\
    \    \n    if planet1 == \"Venus\" && planet2 == \"Jupiter\" {\n        return\
    \ result;\n    }\n    \n    if planet1 == \"Venus\" && planet2 == \"Saturn\" {\n\
    \        return result;\n    }\n    \n    if planet1 == \"Venus\" && planet2 ==\
    \ \"Uranus\" {\n        return result;\n    }\n    \n    if planet1 == \"Venus\"\
    \ && planet2 == \"Neptune\" {\n        return result;\n    }\n    \n    if planet1\
    \ == \"Earth\" && planet2 == \"Mars\" {\n        return result;\n    }\n    \n\
    \    if planet1\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2:\
    \ \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\n\
    assert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"\
    Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\")\
    \ == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: SyntaxError
  stderr: "/tmp/tmp5wu8pas0.swift:86:15: error: expected '{' after 'if' condition\n\
    \    if planet1\n              ^\n/tmp/tmp5wu8pas0.swift:86:8: error: cannot convert\
    \ value of type 'String' to expected condition type 'Bool'\n    if planet1\n \
    \      ^~~~~~~\n"
  stdout: ''
  timestamp: 1659823231
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    \n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\") == [\"\
    Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\") ==\
    \ [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"Venus\"\
    , \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"Neptune\"\
    , planet2: \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    ])\nassert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Makemake\") == [] as [String])"
  status: SyntaxError
  stderr: '/tmp/tmp3d9bvts2.swift:17:1: error: missing return in global function expected
    to return ''[String]''

    }

    ^

    '
  stdout: ''
  timestamp: 1659823230
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    var planets = [String]()\n\
    \    \n    if planet1 == planet2 {\n        return planets\n    }\n    \n    if\
    \ planet1 == \"Mercury\" || planet1 == \"Venus\" || planet1 == \"Earth\" || planet1\
    \ == \"Mars\" || planet1 == \"Jupiter\" || planet1 == \"Saturn\" || planet1 ==\
    \ \"Uranus\" || planet1 == \"Neptune\" {\n        planets.append(planet1)\n  \
    \  }\n    \n    if planet2 == \"Mercury\" || planet2 == \"Venus\" || planet2 ==\
    \ \"Earth\" || planet2 == \"Mars\" || planet2 == \"Jupiter\" || planet2 == \"\
    Saturn\" || planet2 == \"Uranus\" || planet2 == \"Neptune\" {\n        planets.append(planet2)\n\
    \    }\n    \n    if planet1 == \"Mercury\" && planet2 == \"Earth\" {\n      \
    \  planets.append(planet1)\n        planets.append(planet2)\n    }\n    \n   \
    \ if planet1 == \"Mercury\" && planet2 == \"Mars\" {\n        planets.append(planet1)\n\
    \        planets.append(planet2)\n    }\n    \n    if planet1 == \"Mercury\" &&\
    \ planet2 == \"Jupiter\" {\n        planets.append(planet1)\n        planets.append(planet2)\n\
    \    }\n    \n    if planet1 == \"Mercury\" && planet2 == \"Saturn\" {\n     \
    \   planets.append(planet1)\n        planets.append(planet2)\n    }\n    \n  \
    \  if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets.append(planet1)\n\
    \        planets.append(planet2)\n    }\n    \n    if planet1 == \"Mercury\" &&\
    \ planet2 == \"Neptune\" {\n        planets.append(planet1)\n        planets.append(planet2)\n\
    \    }\n    \n    if planet1 == \"Venus\" && planet2 == \"Earth\" {\n        planets.append(planet1)\n\
    \        planets.append(planet2)\n    }\n    \n    if planet1 == \"Venus\" &&\
    \ planet2 == \"Mars\" {\n        planets.append(planet1)\n        planets.append(planet2)\n\
    \    }\n    \n    if planet1 == \"Venus\" && planet2 == \"Jupiter\" {\n      \
    \  planets.append(planet1)\n        planets.append(planet2)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\") == [\"\
    Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\") ==\
    \ [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"Venus\"\
    , \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"Neptune\"\
    , planet2: \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    ])\nassert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Makemake\") == [] as [String])"
  status: SyntaxError
  stderr: "/tmp/tmpmupps9zb.swift:94:70: error: expected '}' at end of brace statement\n\
    assert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") == [] as [String])\n  \
    \                                                                   ^\n/tmp/tmpmupps9zb.swift:15:55:\
    \ note: to match this opening '{'\nfunc bf(planet1: String, planet2: String) ->\
    \ [String] {\n                                                      ^\n/tmp/tmpmupps9zb.swift:76:6:\
    \ error: operator functions can only be declared at global or in type scope\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1659823230
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    var planets = [String]()\n\
    \    \n    // TODO: Write your code here\n    \n    return planets\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\"\
    ) == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\"\
    ) == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"\
    Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\n\
    assert(bf(planet1: \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Makemake\") == [] as [String])"
  status: Exception
  stderr: 'tmpqir0zopy/tmpqir0zopy.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b71b763fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b71b7336b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b71b7336988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b71b73357b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpqir0zopy                        0x00005603381a456b <unavailable> + 5483

    5    libc.so.6                          0x00002b71b782b460 __libc_start_main +
    245

    6    tmpqir0zopy                        0x00005603381a4119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659823230
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    var planets = [String]()\n\
    \    \n    if planet1 == planet2 {\n        return planets\n    }\n    \n    if\
    \ planet1 == \"Mercury\" || planet1 == \"Venus\" || planet1 == \"Earth\" || planet1\
    \ == \"Mars\" || planet1 == \"Jupiter\" || planet1 == \"Saturn\" || planet1 ==\
    \ \"Uranus\" || planet1 == \"Neptune\" {\n        planets.append(planet1)\n  \
    \  }\n    \n    if planet2 == \"Mercury\" || planet2 == \"Venus\" || planet2 ==\
    \ \"Earth\" || planet2 == \"Mars\" || planet2 == \"Jupiter\" || planet2 == \"\
    Saturn\" || planet2 == \"Uranus\" || planet2 == \"Neptune\" {\n        planets.append(planet2)\n\
    \    }\n    \n    if planet1 == \"Mercury\" && planet2 == \"Venus\" {\n      \
    \  planets.append(planet1)\n        planets.append(planet2)\n    }\n    \n   \
    \ if planet1 == \"Venus\" && planet2 == \"Mercury\" {\n        planets.append(planet1)\n\
    \        planets.append(planet2)\n    }\n    \n    if planet1 == \"Earth\" &&\
    \ planet2 == \"Mars\" {\n        planets.append(planet1)\n        planets.append(planet2)\n\
    \    }\n    \n    if planet1 == \"Mars\" && planet2 == \"Earth\" {\n        planets.append(planet1)\n\
    \        planets.append(planet2)\n    }\n    \n    if planet1 == \"Jupiter\" &&\
    \ planet2 == \"Saturn\" {\n        planets.append(planet1)\n        planets.append(planet2)\n\
    \    }\n    \n    if planet1 == \"Saturn\" && planet2 == \"Jupiter\" {\n     \
    \   planets.append(planet1)\n        planets.append(planet2)\n    }\n    \n  \
    \  if planet1 == \"Uranus\" && planet2 == \"Neptune\" {\n        planets.append(planet1)\n\
    \        planets.append(planet2)\n    }\n    \n    if planet1 == \"Neptune\" &&\
    \ planet2 == \"Uranus\" {\n        planets.append(planet1)\n        planets.append(planet2)\n\
    \    }\n    \n    if planet1 == \"Mercury\" && planet2 == \"Earth\" {\n      \
    \  planets.append(planet1)\n        planets.append(planet2)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\") == [\"\
    Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\") ==\
    \ [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"Venus\"\
    , \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"Neptune\"\
    , planet2: \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    ])\nassert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Makemake\") == [] as [String])"
  status: SyntaxError
  stderr: "/tmp/tmpbb3b92n7.swift:94:70: error: expected '}' at end of brace statement\n\
    assert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") == [] as [String])\n  \
    \                                                                   ^\n/tmp/tmpbb3b92n7.swift:15:55:\
    \ note: to match this opening '{'\nfunc bf(planet1: String, planet2: String) ->\
    \ [String] {\n                                                      ^\n/tmp/tmpbb3b92n7.swift:76:6:\
    \ error: operator functions can only be declared at global or in type scope\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1659823230
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    \n    var planets\
    \ = [String]()\n    \n    if planet1 == planet2 {\n        return planets\n  \
    \  }\n    \n    if planet1 == \"Mercury\" || planet1 == \"Venus\" || planet1 ==\
    \ \"Earth\" || planet1 == \"Mars\" || planet1 == \"Jupiter\" || planet1 == \"\
    Saturn\" || planet1 == \"Uranus\" || planet1 == \"Neptune\" {\n        planets.append(planet1)\n\
    \    }\n    \n    if planet2 == \"Mercury\" || planet2 == \"Venus\" || planet2\
    \ == \"Earth\" || planet2 == \"Mars\" || planet2 == \"Jupiter\" || planet2 ==\
    \ \"Saturn\" || planet2 == \"Uranus\" || planet2 == \"Neptune\" {\n        planets.append(planet2)\n\
    \    }\n    \n    if planet1 == \"Mercury\" && planet2 == \"Venus\" {\n      \
    \  planets.append(planet1)\n        planets.append(planet2)\n    }\n    \n   \
    \ if planet1 == \"Venus\" && planet2 == \"Mercury\" {\n        planets.append(planet1)\n\
    \        planets.append(planet2)\n    }\n    \n    if planet1 == \"Earth\" &&\
    \ planet2 == \"Mars\" {\n        planets.append(planet1)\n        planets.append(planet2)\n\
    \    }\n    \n    if planet1 == \"Mars\" && planet2 == \"Earth\" {\n        planets.append(planet1)\n\
    \        planets.append(planet2)\n    }\n    \n    if planet1 == \"Jupiter\" &&\
    \ planet2 == \"Saturn\" {\n        planets.append(planet1)\n        planets.append(planet2)\n\
    \    }\n    \n    if planet1 == \"Saturn\" && planet2 == \"Jupiter\" {\n     \
    \   planets.append(planet1)\n        planets.append(planet2)\n    }\n    \n  \
    \  if planet1 == \"Uranus\" && planet2 == \"Neptune\" {\n        planets.append(planet1)\n\
    \        planets.append(planet2)\n    }\n    \n    if planet1 == \"Neptune\" &&\
    \ planet2 == \"Uranus\" {\n        planets.append(planet1)\n        planets.append(planet2)\n\
    \    }\n    \n    if planet1 == \"Mercury\" && planet2 == \"Earth\" {\n      \
    \  planets.append(planet1)\n        planets.append(plan\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\") == [\"\
    Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\") ==\
    \ [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"Venus\"\
    , \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"Neptune\"\
    , planet2: \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    ])\nassert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Makemake\") == [] as [String])"
  status: SyntaxError
  stderr: "/tmp/tmpifm6kcsp.swift:74:1: error: expected ')' in expression list\n}\n\
    ^\n/tmp/tmpifm6kcsp.swift:73:23: note: to match this opening '('\n        planets.append(plan\n\
    \                      ^\n/tmp/tmpifm6kcsp.swift:95:70: error: expected '}' at\
    \ end of brace statement\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\"\
    ) == [] as [String])\n                                                       \
    \              ^\n/tmp/tmpifm6kcsp.swift:15:55: note: to match this opening '{'\n\
    func bf(planet1: String, planet2: String) -> [String] {\n                    \
    \                                  ^\n/tmp/tmpifm6kcsp.swift:73:24: error: cannot\
    \ find 'plan' in scope\n        planets.append(plan\n                       ^~~~\n\
    /tmp/tmpifm6kcsp.swift:77:6: error: operator functions can only be declared at\
    \ global or in type scope\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n     ^\n"
  stdout: ''
  timestamp: 1659823230
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    var planets = [String]()\n\
    \    \n    // TODO: Write your code here\n    \n    return planets\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\"\
    ) == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\"\
    ) == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"\
    Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\n\
    assert(bf(planet1: \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Makemake\") == [] as [String])"
  status: Exception
  stderr: 'tmpqir0zopy/tmpqir0zopy.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b71b763fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b71b7336b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b71b7336988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b71b73357b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpqir0zopy                        0x00005603381a456b <unavailable> + 5483

    5    libc.so.6                          0x00002b71b782b460 __libc_start_main +
    245

    6    tmpqir0zopy                        0x00005603381a4119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659823230
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    var planets = [String]()\n\
    \    \n    if planet1 == \"Mercury\" && planet2 == \"Venus\" {\n        planets\
    \ = [\"Mercury\", \"Venus\"]\n    } else if planet1 == \"Venus\" && planet2 ==\
    \ \"Mercury\" {\n        planets = [\"Venus\", \"Mercury\"]\n    } else if planet1\
    \ == \"Earth\" && planet2 == \"Mars\" {\n        planets = [\"Earth\", \"Mars\"\
    ]\n    } else if planet1 == \"Mars\" && planet2 == \"Earth\" {\n        planets\
    \ = [\"Mars\", \"Earth\"]\n    } else if planet1 == \"Jupiter\" && planet2 ==\
    \ \"Saturn\" {\n        planets = [\"Jupiter\", \"Saturn\"]\n    } else if planet1\
    \ == \"Saturn\" && planet2 == \"Jupiter\" {\n        planets = [\"Saturn\", \"\
    Jupiter\"]\n    } else if planet1 == \"Uranus\" && planet2 == \"Neptune\" {\n\
    \        planets = [\"Uranus\", \"Neptune\"]\n    } else if planet1 == \"Neptune\"\
    \ && planet2 == \"Uranus\" {\n        planets = [\"Neptune\", \"Uranus\"]\n  \
    \  } else {\n        return planets\n    }\n    \n    return planets\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\"\
    ) == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\"\
    ) == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"\
    Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\n\
    assert(bf(planet1: \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Makemake\") == [] as [String])"
  status: Exception
  stderr: 'tmp7ma8dqwc/tmp7ma8dqwc.swift:54: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b2194625c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b219431cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b219431c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b219431b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp7ma8dqwc                        0x0000558a2caab5cb <unavailable> + 5579

    5    libc.so.6                          0x00002b2194811460 __libc_start_main +
    245

    6    tmp7ma8dqwc                        0x0000558a2caab179 <unavailable> + 4473

    '
  stdout: ''
  timestamp: 1659823231
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    var planets = [String]()\n\
    \    \n    if planet1 == planet2 {\n        return planets\n    }\n    \n    let\
    \ planet1Orbit = orbit(planet1)\n    let planet2Orbit = orbit(planet2)\n    \n\
    \    if planet1Orbit == planet2Orbit {\n        return planets\n    }\n    \n\
    \    let planet1Sun = sunOrbit(planet1)\n    let planet2Sun = sunOrbit(planet2)\n\
    \    \n    if planet1Sun == planet2Sun {\n        return planets\n    }\n    \n\
    \    let planet1OrbitSun = orbit(planet1, sunOrbit: planet1Sun)\n    let planet2OrbitSun\
    \ = orbit(planet2, sunOrbit: planet2Sun)\n    \n    if planet1OrbitSun == planet2OrbitSun\
    \ {\n        return planets\n    }\n    \n    let planet1OrbitSunAndPlanet2 =\
    \ orbit(planet1, sunOrbit: planet1Sun, planet2: planet2)\n    let planet2OrbitSunAndPlanet1\
    \ = orbit(planet2, sunOrbit: planet2Sun, planet1: planet1)\n    \n    if planet1OrbitSunAndPlanet2\
    \ == planet2OrbitSunAndPlanet1 {\n        return planets\n    }\n    \n    let\
    \ planet1OrbitSunAndPlanet2AndPlanet1 = orbit(planet1, sunOrbit: planet1Sun, planet2:\
    \ planet2, planet1: planet1)\n    let planet2OrbitSunAndPlanet1AndPlanet2 = orbit(planet2,\
    \ sunOrbit: planet2Sun, planet1: planet1, planet2: planet2)\n    \n    if planet1OrbitSunAndPlanet2AndPlanet1\
    \ == planet2OrbitSunAndPlanet1AndPlanet2 {\n        return planets\n    }\n  \
    \  \n    let planet1OrbitSunAndPlanet2AndPlanet1AndPlanet2 = orbit(planet1, sunOrbit:\
    \ planet1Sun, planet2: planet2, planet1: planet1, planet2: planet2)\n    \n  \
    \  if planet1OrbitSunAndPlanet2AndPlanet1AndPlanet2 == planet2OrbitSunAndPlanet1AndPlanet2And\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\"\
    ) == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\"\
    ) == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"\
    Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\n\
    assert(bf(planet1: \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Makemake\") == [] as [String])"
  status: SyntaxError
  stderr: "/tmp/tmpwigktgmd.swift:59:95: error: expected '{' after 'if' condition\n\
    \    if planet1OrbitSunAndPlanet2AndPlanet1AndPlanet2 == planet2OrbitSunAndPlanet1AndPlanet2And\n\
    \                                                                            \
    \                  ^\n/tmp/tmpwigktgmd.swift:22:24: error: cannot find 'orbit'\
    \ in scope\n    let planet1Orbit = orbit(planet1)\n                       ^~~~~\n\
    /tmp/tmpwigktgmd.swift:23:24: error: cannot find 'orbit' in scope\n    let planet2Orbit\
    \ = orbit(planet2)\n                       ^~~~~\n/tmp/tmpwigktgmd.swift:29:22:\
    \ error: cannot find 'sunOrbit' in scope\n    let planet1Sun = sunOrbit(planet1)\n\
    \                     ^~~~~~~~\n/tmp/tmpwigktgmd.swift:30:22: error: cannot find\
    \ 'sunOrbit' in scope\n    let planet2Sun = sunOrbit(planet2)\n              \
    \       ^~~~~~~~\n/tmp/tmpwigktgmd.swift:36:27: error: cannot find 'orbit' in\
    \ scope\n    let planet1OrbitSun = orbit(planet1, sunOrbit: planet1Sun)\n    \
    \                      ^~~~~\n/tmp/tmpwigktgmd.swift:37:27: error: cannot find\
    \ 'orbit' in scope\n    let planet2OrbitSun = orbit(planet2, sunOrbit: planet2Sun)\n\
    \                          ^~~~~\n/tmp/tmpwigktgmd.swift:43:37: error: cannot\
    \ find 'orbit' in scope\n    let planet1OrbitSunAndPlanet2 = orbit(planet1, sunOrbit:\
    \ planet1Sun, planet2: planet2)\n                                    ^~~~~\n/tmp/tmpwigktgmd.swift:44:37:\
    \ error: cannot find 'orbit' in scope\n    let planet2OrbitSunAndPlanet1 = orbit(planet2,\
    \ sunOrbit: planet2Sun, planet1: planet1)\n                                  \
    \  ^~~~~\n/tmp/tmpwigktgmd.swift:50:47: error: cannot find 'orbit' in scope\n\
    \    let planet1OrbitSunAndPlanet2AndPlanet1 = orbit(planet1, sunOrbit: planet1Sun,\
    \ planet2: planet2, planet1: planet1)\n                                      \
    \        ^~~~~\n/tmp/tmpwigktgmd.swift:51:47: error: cannot find 'orbit' in scope\n\
    \    let planet2OrbitSunAndPlanet1AndPlanet2 = orbit(planet2, sunOrbit: planet2Sun,\
    \ planet1: planet1, planet2: planet2)\n                                      \
    \        ^~~~~\n/tmp/tmpwigktgmd.swift:57:57: error: cannot find '"
  stdout: ''
  timestamp: 1659823231
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    var planets = [String]()\n\
    \    \n    // TODO: Write your code here\n    \n    return planets\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\"\
    ) == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\"\
    ) == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"\
    Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\n\
    assert(bf(planet1: \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Makemake\") == [] as [String])"
  status: Exception
  stderr: 'tmpqir0zopy/tmpqir0zopy.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b71b763fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b71b7336b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b71b7336988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b71b73357b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpqir0zopy                        0x00005603381a456b <unavailable> + 5483

    5    libc.so.6                          0x00002b71b782b460 __libc_start_main +
    245

    6    tmpqir0zopy                        0x00005603381a4119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659823230
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    var planets = [String]()\n\
    \    \n    // TODO: Write your code here\n    \n    return planets\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\"\
    ) == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\"\
    ) == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"\
    Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\n\
    assert(bf(planet1: \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Makemake\") == [] as [String])"
  status: Exception
  stderr: 'tmpqir0zopy/tmpqir0zopy.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b71b763fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b71b7336b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b71b7336988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b71b73357b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpqir0zopy                        0x00005603381a456b <unavailable> + 5483

    5    libc.so.6                          0x00002b71b782b460 __libc_start_main +
    245

    6    tmpqir0zopy                        0x00005603381a4119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659823230
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    \n    var planets\
    \ = [String]()\n    \n    if planet1 == planet2 {\n        return planets\n  \
    \  }\n    \n    if planet1 == \"Mercury\" || planet1 == \"Venus\" || planet1 ==\
    \ \"Earth\" || planet1 == \"Mars\" || planet1 == \"Jupiter\" || planet1 == \"\
    Saturn\" || planet1 == \"Uranus\" || planet1 == \"Neptune\" {\n        planets.append(planet1)\n\
    \    }\n    \n    if planet2 == \"Mercury\" || planet2 == \"Venus\" || planet2\
    \ == \"Earth\" || planet2 == \"Mars\" || planet2 == \"Jupiter\" || planet2 ==\
    \ \"Saturn\" || planet2 == \"Uranus\" || planet2 == \"Neptune\" {\n        planets.append(planet2)\n\
    \    }\n    \n    if planet1 == \"Mercury\" && planet2 == \"Venus\" {\n      \
    \  planets.append(planet1)\n        planets.append(planet2)\n    }\n    \n   \
    \ if planet1 == \"Venus\" && planet2 == \"Mercury\" {\n        planets.append(planet1)\n\
    \        planets.append(planet2)\n    }\n    \n    if planet1 == \"Earth\" &&\
    \ planet2 == \"Mars\" {\n        planets.append(planet1)\n        planets.append(planet2)\n\
    \    }\n    \n    if planet1 == \"Mars\" && planet2 == \"Earth\" {\n        planets.append(planet1)\n\
    \        planets.append(planet2)\n    }\n    \n    if planet1 == \"Jupiter\" &&\
    \ planet2 == \"Saturn\" {\n        planets.append(planet1)\n        planets.append(planet2)\n\
    \    }\n    \n    if planet1 == \"Saturn\" && planet2 == \"Jupiter\" {\n     \
    \   planets.append(planet1)\n        planets.append(planet2)\n    }\n    \n  \
    \  if planet1 == \"Uranus\" && planet2 == \"Neptune\" {\n        planets.append(planet1)\n\
    \        planets.append(planet2)\n    }\n    \n    if planet1 == \"Neptune\" &&\
    \ planet2 == \"Uranus\" {\n        planets.append(planet1)\n        planets.append(planet2)\n\
    \    }\n    \n    if planet1 == \"Mercury\" && planet2 == \"Earth\" {\n      \
    \  planets.append(planet1)\n        planets.append(plan\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\") == [\"\
    Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\") ==\
    \ [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"Venus\"\
    , \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"Neptune\"\
    , planet2: \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    ])\nassert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Makemake\") == [] as [String])"
  status: SyntaxError
  stderr: "/tmp/tmpifm6kcsp.swift:74:1: error: expected ')' in expression list\n}\n\
    ^\n/tmp/tmpifm6kcsp.swift:73:23: note: to match this opening '('\n        planets.append(plan\n\
    \                      ^\n/tmp/tmpifm6kcsp.swift:95:70: error: expected '}' at\
    \ end of brace statement\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\"\
    ) == [] as [String])\n                                                       \
    \              ^\n/tmp/tmpifm6kcsp.swift:15:55: note: to match this opening '{'\n\
    func bf(planet1: String, planet2: String) -> [String] {\n                    \
    \                                  ^\n/tmp/tmpifm6kcsp.swift:73:24: error: cannot\
    \ find 'plan' in scope\n        planets.append(plan\n                       ^~~~\n\
    /tmp/tmpifm6kcsp.swift:77:6: error: operator functions can only be declared at\
    \ global or in type scope\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n     ^\n"
  stdout: ''
  timestamp: 1659823230
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    var planets = [String]()\n\
    \    \n    if planet1 == \"Mercury\" && planet2 == \"Venus\" {\n        planets\
    \ = [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"]\n\
    \    } else if planet1 == \"Venus\" && planet2 == \"Earth\" {\n        planets\
    \ = [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"]\n\
    \    } else if planet1 == \"Earth\" && planet2 == \"Mars\" {\n        planets\
    \ = [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"]\n\
    \    } else if planet1 == \"Mars\" && planet2 == \"Jupiter\" {\n        planets\
    \ = [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"]\n\
    \    } else if planet1 == \"Jupiter\" && planet2 == \"Saturn\" {\n        planets\
    \ = [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"]\n\
    \    } else if planet1 == \"Saturn\" && planet2 == \"Uranus\" {\n        planets\
    \ = [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"]\n\
    \    } else if planet1 == \"Uranus\" && planet2 == \"Neptune\" {\n        planets\
    \ = [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"]\n\
    \    } else {\n        return planets\n    }\n    \n    return planets\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\"\
    ) == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\"\
    ) == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"\
    Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\n\
    assert(bf(planet1: \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Makemake\") == [] as [String])"
  status: Exception
  stderr: 'tmpgyrbh8ms/tmpgyrbh8ms.swift:52: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002afa8ddd1c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002afa8dac8b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002afa8dac8988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002afa8dac77b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpgyrbh8ms                        0x000055b8458d35cb <unavailable> + 5579

    5    libc.so.6                          0x00002afa8dfbd460 __libc_start_main +
    245

    6    tmpgyrbh8ms                        0x000055b8458d3179 <unavailable> + 4473

    '
  stdout: ''
  timestamp: 1659823230
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    \n    var planets\
    \ = [String]()\n    \n    if planet1 == planet2 {\n        return planets\n  \
    \  }\n    \n    if planet1 == \"Mercury\" || planet1 == \"Venus\" || planet1 ==\
    \ \"Earth\" || planet1 == \"Mars\" || planet1 == \"Jupiter\" || planet1 == \"\
    Saturn\" || planet1 == \"Uranus\" || planet1 == \"Neptune\" {\n        planets.append(planet1)\n\
    \    }\n    \n    if planet2 == \"Mercury\" || planet2 == \"Venus\" || planet2\
    \ == \"Earth\" || planet2 == \"Mars\" || planet2 == \"Jupiter\" || planet2 ==\
    \ \"Saturn\" || planet2 == \"Uranus\" || planet2 == \"Neptune\" {\n        planets.append(planet2)\n\
    \    }\n    \n    if planet1 == \"Mercury\" && planet2 == \"Venus\" {\n      \
    \  planets.append(planet1)\n        planets.append(planet2)\n    }\n    \n   \
    \ if planet1 == \"Venus\" && planet2 == \"Mercury\" {\n        planets.append(planet1)\n\
    \        planets.append(planet2)\n    }\n    \n    if planet1 == \"Earth\" &&\
    \ planet2 == \"Mars\" {\n        planets.append(planet1)\n        planets.append(planet2)\n\
    \    }\n    \n    if planet1 == \"Mars\" && planet2 == \"Earth\" {\n        planets.append(planet1)\n\
    \        planets.append(planet2)\n    }\n    \n    if planet1 == \"Jupiter\" &&\
    \ planet2 == \"Saturn\" {\n        planets.append(planet1)\n        planets.append(planet2)\n\
    \    }\n    \n    if planet1 == \"Saturn\" && planet2 == \"Jupiter\" {\n     \
    \   planets.append(planet1)\n        planets.append(planet2)\n    }\n    \n  \
    \  if planet1 == \"Uranus\" && planet2 == \"Neptune\" {\n        planets.append(planet1)\n\
    \        planets.append(planet2)\n    }\n    \n    if planet1 == \"Neptune\" &&\
    \ planet2 == \"Uranus\" {\n        planets.append(planet1)\n        planets.append(planet2)\n\
    \    }\n    \n    if planet1 == \"Mercury\" && planet2 == \"Earth\" {\n      \
    \  planets.append(planet1)\n        planets.append(plan\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\") == [\"\
    Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\") ==\
    \ [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"Venus\"\
    , \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"Neptune\"\
    , planet2: \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    ])\nassert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Makemake\") == [] as [String])"
  status: SyntaxError
  stderr: "/tmp/tmpifm6kcsp.swift:74:1: error: expected ')' in expression list\n}\n\
    ^\n/tmp/tmpifm6kcsp.swift:73:23: note: to match this opening '('\n        planets.append(plan\n\
    \                      ^\n/tmp/tmpifm6kcsp.swift:95:70: error: expected '}' at\
    \ end of brace statement\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\"\
    ) == [] as [String])\n                                                       \
    \              ^\n/tmp/tmpifm6kcsp.swift:15:55: note: to match this opening '{'\n\
    func bf(planet1: String, planet2: String) -> [String] {\n                    \
    \                                  ^\n/tmp/tmpifm6kcsp.swift:73:24: error: cannot\
    \ find 'plan' in scope\n        planets.append(plan\n                       ^~~~\n\
    /tmp/tmpifm6kcsp.swift:77:6: error: operator functions can only be declared at\
    \ global or in type scope\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n     ^\n"
  stdout: ''
  timestamp: 1659823230
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    \n    var result:\
    \ [String] = []\n    \n    if planet1 == planet2 {\n        return result\n  \
    \  }\n    \n    if planet1 == \"Mercury\" && planet2 == \"Earth\" {\n        result.append(planet1)\n\
    \    }\n    \n    if planet1 == \"Venus\" && planet2 == \"Earth\" {\n        result.append(planet1)\n\
    \    }\n    \n    if planet1 == \"Earth\" && planet2 == \"Mars\" {\n        result.append(planet1)\n\
    \    }\n    \n    if planet1 == \"Mars\" && planet2 == \"Jupiter\" {\n       \
    \ result.append(planet1)\n    }\n    \n    if planet1 == \"Jupiter\" && planet2\
    \ == \"Saturn\" {\n        result.append(planet1)\n    }\n    \n    if planet1\
    \ == \"Saturn\" && planet2 == \"Uranus\" {\n        result.append(planet1)\n \
    \   }\n    \n    if planet1 == \"Uranus\" && planet2 == \"Neptune\" {\n      \
    \  result.append(planet1)\n    }\n    \n    if planet1 == \"Neptune\" && planet2\
    \ == \"Mercury\" {\n        result.append(planet1)\n    }\n    \n    if planet1\
    \ == \"Mercury\" && planet2 == \"Venus\" {\n        result.append(planet1)\n \
    \   }\n    \n    if planet1 == \"Venus\" && planet2 == \"Earth\" {\n        result.append(planet1)\n\
    \    }\n    \n    if planet1 == \"Earth\" && planet2 == \"Mars\" {\n        result.append(planet1)\n\
    \    }\n    \n    if planet1 == \"Mars\" && planet2 == \"Jupiter\" {\n       \
    \ result.append(planet1)\n    }\n    \n    if planet1 == \"Jupiter\" && planet2\
    \ == \"Saturn\" {\n        result.append(planet1)\n    }\n    \n    if planet1\
    \ == \"Saturn\" && planet2 == \"Uranus\" {\n        result.append(planet1)\n \
    \   }\n    \n    if planet1 == \"Uranus\" && planet2 == \"Neptune\" {\n      \
    \  result.append(planet1)\n    }\n    \n    if planet1 == \"Neptune\" && planet2\
    \ == \"Mercury\" {\n        result.append(planet1)\n    }\n    \n    if planet1\
    \ == \"Mercury\" && planet2 == \"Venus\" {\n        result.append(planet1)\n \
    \   }\n    \n    if planet1 == \"Venus\" && planet2 == \"Earth\" {\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\"\
    ) == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\"\
    ) == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"\
    Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\n\
    assert(bf(planet1: \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Makemake\") == [] as [String])"
  status: SyntaxError
  stderr: "/tmp/tmp7k5pa1i6.swift:113:70: error: expected '}' at end of brace statement\n\
    assert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") == [] as [String])\n  \
    \                                                                   ^\n/tmp/tmp7k5pa1i6.swift:15:55:\
    \ note: to match this opening '{'\nfunc bf(planet1: String, planet2: String) ->\
    \ [String] {\n                                                      ^\n/tmp/tmp7k5pa1i6.swift:95:6:\
    \ error: operator functions can only be declared at global or in type scope\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1659823231
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    \n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\") == [\"\
    Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\") ==\
    \ [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"Venus\"\
    , \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"Neptune\"\
    , planet2: \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    ])\nassert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Makemake\") == [] as [String])"
  status: SyntaxError
  stderr: '/tmp/tmp3d9bvts2.swift:17:1: error: missing return in global function expected
    to return ''[String]''

    }

    ^

    '
  stdout: ''
  timestamp: 1659823230
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    \n    // Your code\
    \ here\n    \n    return []\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1:\
    \ \"Earth\", planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\"\
    , planet2: \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    ])\nassert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2:\
    \ \"Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\"\
    ) == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: Exception
  stderr: 'tmpub3vnyvf/tmpub3vnyvf.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9379153c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9378e4ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9378e4a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9378e497b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpub3vnyvf                        0x0000559f9836d51b <unavailable> + 5403

    5    libc.so.6                          0x00002b937933f460 __libc_start_main +
    245

    6    tmpub3vnyvf                        0x0000559f9836d0c9 <unavailable> + 4297

    '
  stdout: ''
  timestamp: 1659823230
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    \n    var planets\
    \ = [String]()\n    \n    if planet1 == planet2 {\n        planets.append(planet1)\n\
    \        return planets\n    }\n    \n    if planet1 == \"Mercury\" {\n      \
    \  planets.append(planet1)\n        return planets\n    }\n    \n    if planet1\
    \ == \"Venus\" {\n        planets.append(planet1)\n        return planets\n  \
    \  }\n    \n    if planet1 == \"Earth\" {\n        planets.append(planet1)\n \
    \       return planets\n    }\n    \n    if planet1 == \"Mars\" {\n        planets.append(planet1)\n\
    \        return planets\n    }\n    \n    if planet1 == \"Jupiter\" {\n      \
    \  planets.append(planet1)\n        return planets\n    }\n    \n    if planet1\
    \ == \"Saturn\" {\n        planets.append(planet1)\n        return planets\n \
    \   }\n    \n    if planet1 == \"Uranus\" {\n        planets.append(planet1)\n\
    \        return planets\n    }\n    \n    if planet1 == \"Neptune\" {\n      \
    \  planets.append(planet1)\n        return planets\n    }\n    \n    if planet2\
    \ == \"Mercury\" {\n        planets.append(planet2)\n        return planets\n\
    \    }\n    \n    if planet2 == \"Venus\" {\n        planets.append(planet2)\n\
    \        return planets\n    }\n    \n    if planet2 == \"Earth\" {\n        planets.append(planet2)\n\
    \        return planets\n    }\n    \n    if planet2 == \"Mars\" {\n        planets.append(planet2)\n\
    \        return planets\n    }\n    \n    if planet2 == \"Jupiter\" {\n      \
    \  planets.append(planet2)\n        return planets\n    }\n    \n    if planet2\
    \ == \"Saturn\" {\n        planets.append(planet2)\n        return planets\n \
    \   }\n    \n    if planet2 == \"Uranus\" {\n        planets.append(planet2)\n\
    \        return planets\n    }\n    \n    if planet2 == \"Neptune\" {\n      \
    \  planets.append(planet2)\n        return planets\n    }\n    \n    return planets\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\"\
    ) == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\"\
    ) == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"\
    Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\n\
    assert(bf(planet1: \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Makemake\") == [] as [String])"
  status: Exception
  stderr: 'tmpqiag0v86/tmpqiag0v86.swift:120: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae097ec2c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae097bb9b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae097bb9988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae097bb87b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpqiag0v86                        0x00005652ed1aa62b <unavailable> + 5675

    5    libc.so.6                          0x00002ae0980ae460 __libc_start_main +
    245

    6    tmpqiag0v86                        0x00005652ed1aa1d9 <unavailable> + 4569

    '
  stdout: ''
  timestamp: 1659823231
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    \n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\") == [\"\
    Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\") ==\
    \ [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"Venus\"\
    , \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"Neptune\"\
    , planet2: \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    ])\nassert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Makemake\") == [] as [String])"
  status: SyntaxError
  stderr: '/tmp/tmp3d9bvts2.swift:17:1: error: missing return in global function expected
    to return ''[String]''

    }

    ^

    '
  stdout: ''
  timestamp: 1659823230
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    var result = [String]()\n\
    \    \n    switch planet1 {\n    case \"Mercury\":\n    case \"Venus\":\n    case\
    \ \"Earth\":\n    case \"Mars\":\n    case \"Jupiter\":\n    case \"Saturn\":\n\
    \    case \"Uranus\":\n    case \"Neptune\":\n    default:\n        return ()\n\
    \    }\n    \n    switch planet2 {\n    case \"Mercury\":\n    case \"Venus\"\
    :\n    case \"Earth\":\n    case \"Mars\":\n    case \"Jupiter\":\n    case \"\
    Saturn\":\n    case \"Uranus\":\n    case \"Neptune\":\n    default:\n       \
    \ return ()\n    }\n    \n    var orbit1 = orbit(planet1)\n    var orbit2 = orbit(planet2)\n\
    \    \n    for planet in orbit1 {\n        if let index = orbit2.index(of: planet)\
    \ {\n            result.append(planet)\n            orbit2.remove(at: index)\n\
    \        }\n    }\n    \n    for planet in orbit2 {\n        if let index = orbit1.index(of:\
    \ planet) {\n            result.append(planet)\n            orbit1.remove(at:\
    \ index)\n        }\n    }\n    \n    return result.sorted(by: { $0.distance(from:\
    \ orbit1) < $1.distance(from: orbit2) })\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(bf(planet1: \"Jupiter\", planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"\
    ])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1:\
    \ \"Mercury\", planet2: \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"])\nassert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2:\
    \ \"Earth\") == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\"\
    ) == [] as [String])"
  status: SyntaxError
  stderr: "/tmp/tmpzzrd1qxh.swift:19:5: error: 'case' label in a 'switch' must have\
    \ at least one executable statement\n    case \"Mercury\":\n    ^~~~~~~~~~~~~~~\n\
    \                    break\n/tmp/tmpzzrd1qxh.swift:20:5: error: 'case' label in\
    \ a 'switch' must have at least one executable statement\n    case \"Venus\":\n\
    \    ^~~~~~~~~~~~~\n                  break\n/tmp/tmpzzrd1qxh.swift:21:5: error:\
    \ 'case' label in a 'switch' must have at least one executable statement\n   \
    \ case \"Earth\":\n    ^~~~~~~~~~~~~\n                  break\n/tmp/tmpzzrd1qxh.swift:22:5:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \    case \"Mars\":\n    ^~~~~~~~~~~~\n                 break\n/tmp/tmpzzrd1qxh.swift:23:5:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \    case \"Jupiter\":\n    ^~~~~~~~~~~~~~~\n                    break\n/tmp/tmpzzrd1qxh.swift:24:5:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \    case \"Saturn\":\n    ^~~~~~~~~~~~~~\n                   break\n/tmp/tmpzzrd1qxh.swift:25:5:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \    case \"Uranus\":\n    ^~~~~~~~~~~~~~\n                   break\n/tmp/tmpzzrd1qxh.swift:26:5:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \    case \"Neptune\":\n    ^~~~~~~~~~~~~~~\n                    break\n/tmp/tmpzzrd1qxh.swift:32:5:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \    case \"Mercury\":\n    ^~~~~~~~~~~~~~~\n                    break\n/tmp/tmpzzrd1qxh.swift:33:5:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \    case \"Venus\":\n    ^~~~~~~~~~~~~\n                  break\n/tmp/tmpzzrd1qxh.swift:34:5:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \    case \"Earth\":\n    ^~~~~~~~~~~~~\n                  break\n/tmp/tmpzzrd1qxh.swift:35:5:\
    \ error: 'case' label in a 'switch' must have at least one executable statement\n\
    \    case \"Mars\":\n    ^~~~~~~~~~~~\n                 break\n/tmp/tmpzzrd1qxh.swi"
  stdout: ''
  timestamp: 1659823231
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    var result: [String]\
    \ = []\n    \n    if planet1 == planet2 {\n        return result;\n    }\n   \
    \ \n    let planet1Orbit = orbit(planet1)\n    let planet2Orbit = orbit(planet2)\n\
    \    \n    for planet in planet1Orbit {\n        if planet in planet2Orbit {\n\
    \            if planet1Orbit.distance(planet2Orbit[planet]) < planet2Orbit.distance(planet1Orbit[planet])\
    \ {\n                result.append(planet)\n            }\n        }\n    }\n\
    \    \n    return result.sorted(by: { (planet1, planet2) -> Bool in\n        return\
    \ planet1Orbit.distance(planet2Orbit[planet1]) < planet2Orbit.distance(planet1Orbit[planet1])\n\
    \    })\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n \
    \   if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2:\
    \ \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\n\
    assert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"\
    Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\")\
    \ == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: SyntaxError
  stderr: "/tmp/tmpbphm1xb_.swift:26:19: error: expected '{' after 'if' condition\n\
    \        if planet in planet2Orbit {\n                  ^\n/tmp/tmpbphm1xb_.swift:22:24:\
    \ error: cannot find 'orbit' in scope\n    let planet1Orbit = orbit(planet1)\n\
    \                       ^~~~~\n/tmp/tmpbphm1xb_.swift:23:24: error: cannot find\
    \ 'orbit' in scope\n    let planet2Orbit = orbit(planet2)\n                  \
    \     ^~~~~\n"
  stdout: ''
  timestamp: 1659823231
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    var planets = [String]()\n\
    \    \n    if planet1 == planet2 {\n        return planets\n    }\n    \n    if\
    \ planet1 == \"Sun\" {\n        return planets\n    }\n    \n    if planet2 ==\
    \ \"Sun\" {\n        return planets\n    }\n    \n    if planet1 == \"Mercury\"\
    \ {\n        planets.append(planet2)\n        return planets\n    }\n    \n  \
    \  if planet2 == \"Mercury\" {\n        planets.append(planet1)\n        return\
    \ planets\n    }\n    \n    if planet1 == \"Venus\" {\n        planets.append(planet2)\n\
    \        return planets\n    }\n    \n    if planet2 == \"Venus\" {\n        planets.append(planet1)\n\
    \        return planets\n    }\n    \n    if planet1 == \"Earth\" {\n        planets.append(planet2)\n\
    \        return planets\n    }\n    \n    if planet2 == \"Earth\" {\n        planets.append(planet1)\n\
    \        return planets\n    }\n    \n    if planet1 == \"Mars\" {\n        planets.append(planet2)\n\
    \        return planets\n    }\n    \n    if planet2 == \"Mars\" {\n        planets.append(planet1)\n\
    \        return planets\n    }\n    \n    if planet1 == \"Jupiter\" {\n      \
    \  planets.append(planet2)\n        return planets\n    }\n    \n    if planet2\
    \ == \"Jupiter\" {\n        planets.append(planet1)\n        return planets\n\
    \    }\n    \n    if planet1 == \"Saturn\" {\n        planets.append(planet2)\n\
    \        return planets\n    }\n    \n    if planet2 == \"Saturn\" {\n       \
    \ planets.append(planet1)\n        return planets\n    }\n    \n    if planet1\
    \ == \"Uranus\" {\n        planets.append(planet2)\n        return planets\n \
    \   }\n    \n    if planet2 == \"Uranus\" {\n        planets.append(planet1)\n\
    \        return planets\n    }\n    \n    if planet1 == \"Neptune\" {\n      \
    \  planets.append(planet2)\n        return planets\n    }\n    \n    if planet2\
    \ == \"Neptune\" {\n        planets.append(planet1)\n        return planets\n\
    \    }\n    \n    return planets\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1:\
    \ \"Earth\", planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\"\
    , planet2: \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    ])\nassert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2:\
    \ \"Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\"\
    ) == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: Exception
  stderr: 'tmppvrncj2v/tmppvrncj2v.swift:126: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9c76d9dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9c76a94b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9c76a94988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9c76a937b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmppvrncj2v                        0x000055813d85162b <unavailable> + 5675

    5    libc.so.6                          0x00002b9c76f89460 __libc_start_main +
    245

    6    tmppvrncj2v                        0x000055813d8511d9 <unavailable> + 4569

    '
  stdout: ''
  timestamp: 1659823231
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    \n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\") == [\"\
    Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\") ==\
    \ [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"Venus\"\
    , \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"Neptune\"\
    , planet2: \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    ])\nassert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Makemake\") == [] as [String])"
  status: SyntaxError
  stderr: '/tmp/tmp3d9bvts2.swift:17:1: error: missing return in global function expected
    to return ''[String]''

    }

    ^

    '
  stdout: ''
  timestamp: 1659823230
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    var planets = [String]()\n\
    \    \n    if planet1 == planet2 {\n        return planets\n    }\n    \n    if\
    \ planet1 == \"Mercury\" || planet1 == \"Venus\" || planet1 == \"Earth\" || planet1\
    \ == \"Mars\" || planet1 == \"Jupiter\" || planet1 == \"Saturn\" || planet1 ==\
    \ \"Uranus\" || planet1 == \"Neptune\" {\n        planets.append(planet1)\n  \
    \  }\n    \n    if planet2 == \"Mercury\" || planet2 == \"Venus\" || planet2 ==\
    \ \"Earth\" || planet2 == \"Mars\" || planet2 == \"Jupiter\" || planet2 == \"\
    Saturn\" || planet2 == \"Uranus\" || planet2 == \"Neptune\" {\n        planets.append(planet2)\n\
    \    }\n    \n    if planet1 == \"Mercury\" && planet2 == \"Venus\" {\n      \
    \  planets.append(\"Earth\")\n    }\n    \n    if planet1 == \"Mercury\" && planet2\
    \ == \"Earth\" {\n        planets.append(\"Mars\")\n    }\n    \n    if planet1\
    \ == \"Mercury\" && planet2 == \"Mars\" {\n        planets.append(\"Jupiter\"\
    )\n    }\n    \n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n  \
    \      planets.append(\"Saturn\")\n    }\n    \n    if planet1 == \"Mercury\"\
    \ && planet2 == \"Saturn\" {\n        planets.append(\"Uranus\")\n    }\n    \n\
    \    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets.append(\"\
    Neptune\")\n    }\n    \n    if planet1 == \"Venus\" && planet2 == \"Earth\" {\n\
    \        planets.append(\"Mercury\")\n    }\n    \n    if planet1 == \"Venus\"\
    \ && planet2 == \"Mercury\" {\n        planets.append(\"Earth\")\n    }\n    \n\
    \    if planet1 == \"Venus\" && planet2 == \"Mars\" {\n        planets.append(\"\
    Jupiter\")\n    }\n    \n    if planet1 == \"Venus\" && planet2 == \"Jupiter\"\
    \ {\n        planets.append(\"Saturn\")\n    }\n    \n    if planet1 == \"Venus\"\
    \ && planet2 == \"Saturn\" {\n        planets.append(\"Uranus\")\n    }\n    \n\
    \    if planet1 == \"Venus\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1:\
    \ \"Earth\", planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\"\
    , planet2: \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    ])\nassert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2:\
    \ \"Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\"\
    ) == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: SyntaxError
  stderr: "/tmp/tmpdr1lg5u5.swift:74:19: error: unterminated string literal\n    if\
    \ planet1 == \"Venus\n                  ^\n"
  stdout: ''
  timestamp: 1659823230
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    var planets = [String]()\n\
    \    \n    if planet1 == \"Mercury\" && planet2 == \"Earth\" {\n        planets\
    \ = [\"Venus\"]\n    } else if planet1 == \"Venus\" && planet2 == \"Earth\" {\n\
    \        planets = [\"Earth\"]\n    } else if planet1 == \"Earth\" && planet2\
    \ == \"Mars\" {\n        planets = [\"Mars\"]\n    } else if planet1 == \"Mars\"\
    \ && planet2 == \"Jupiter\" {\n        planets = [\"Jupiter\", \"Saturn\"]\n \
    \   } else if planet1 == \"Jupiter\" && planet2 == \"Saturn\" {\n        planets\
    \ = [\"Saturn\"]\n    } else if planet1 == \"Saturn\" && planet2 == \"Uranus\"\
    \ {\n        planets = [\"Uranus\"]\n    } else if planet1 == \"Uranus\" && planet2\
    \ == \"Neptune\" {\n        planets = [\"Neptune\"]\n    } else if planet1 ==\
    \ \"Neptune\" && planet2 == \"Mercury\" {\n        planets = [\"Mercury\"]\n \
    \   } else if planet1 == \"Mercury\" && planet2 == \"Venus\" {\n        planets\
    \ = [\"Mercury\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"]\n    } else if\
    \ planet1 == \"Venus\" && planet2 == \"Earth\" {\n        planets = [\"Venus\"\
    , \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"]\n    } else if planet1 == \"Earth\"\
    \ && planet2 == \"Mars\" {\n        planets = [\"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"]\n    } else if planet1 == \"Mars\" && planet2 == \"Jupiter\" {\n\
    \        planets = [\"Mars\", \"Jupiter\", \"Saturn\"]\n    } else if planet1\
    \ == \"Jupiter\" && planet2 == \"Saturn\" {\n        planets = [\"Jupiter\", \"\
    Saturn\"]\n    } else if planet1 == \"Saturn\" && planet2 == \"Uranus\" {\n  \
    \      planets = [\"Saturn\", \"Uranus\"]\n    } else if planet1 == \"Uranus\"\
    \ && planet2 == \"Neptune\" {\n        planets = [\"Uranus\", \"Neptune\"]\n \
    \   } else if planet1 == \"Neptune\" && planet2 == \"Mercury\" {\n        planets\
    \ = [\"Neptune\", \"Mercur\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1:\
    \ \"Earth\", planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\"\
    , planet2: \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    ])\nassert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2:\
    \ \"Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\"\
    ) == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: SyntaxError
  stderr: "/tmp/tmp5ki65108.swift:49:31: error: unterminated string literal\n    \
    \    planets = [\"Neptune\", \"Mercur\n                              ^\n/tmp/tmp5ki65108.swift:71:70:\
    \ error: expected '}' at end of brace statement\nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Makemake\") == [] as [String])\n                                \
    \                                     ^\n/tmp/tmp5ki65108.swift:15:55: note: to\
    \ match this opening '{'\nfunc bf(planet1: String, planet2: String) -> [String]\
    \ {\n                                                      ^\n/tmp/tmp5ki65108.swift:53:6:\
    \ error: operator functions can only be declared at global or in type scope\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n/tmp/tmp5ki65108.swift:16:9:\
    \ warning: variable 'planets' was written to, but never read\n    var planets\
    \ = [String]()\n        ^\n"
  stdout: ''
  timestamp: 1659823231
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    var planets = [String]()\n\
    \    \n    // TODO: Write your code here\n    \n    return planets\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\"\
    ) == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\"\
    ) == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"\
    Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\n\
    assert(bf(planet1: \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Makemake\") == [] as [String])"
  status: Exception
  stderr: 'tmpqir0zopy/tmpqir0zopy.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b71b763fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b71b7336b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b71b7336988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b71b73357b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpqir0zopy                        0x00005603381a456b <unavailable> + 5483

    5    libc.so.6                          0x00002b71b782b460 __libc_start_main +
    245

    6    tmpqir0zopy                        0x00005603381a4119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659823230
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    \n    var planets\
    \ = [String]()\n    \n    if planet1 == planet2 {\n        return planets\n  \
    \  }\n    \n    if planet1 == \"Mercury\" || planet1 == \"Venus\" || planet1 ==\
    \ \"Earth\" || planet1 == \"Mars\" || planet1 == \"Jupiter\" || planet1 == \"\
    Saturn\" || planet1 == \"Uranus\" || planet1 == \"Neptune\" {\n        planets.append(planet1)\n\
    \    }\n    \n    if planet2 == \"Mercury\" || planet2 == \"Venus\" || planet2\
    \ == \"Earth\" || planet2 == \"Mars\" || planet2 == \"Jupiter\" || planet2 ==\
    \ \"Saturn\" || planet2 == \"Uranus\" || planet2 == \"Neptune\" {\n        planets.append(planet2)\n\
    \    }\n    \n    if planet1 == \"Mercury\" && planet2 == \"Venus\" {\n      \
    \  planets.append(\"Earth\")\n    }\n    \n    if planet1 == \"Mercury\" && planet2\
    \ == \"Earth\" {\n        planets.append(\"Mars\")\n    }\n    \n    if planet1\
    \ == \"Mercury\" && planet2 == \"Mars\" {\n        planets.append(\"Jupiter\"\
    )\n    }\n    \n    if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n  \
    \      planets.append(\"Saturn\")\n    }\n    \n    if planet1 == \"Mercury\"\
    \ && planet2 == \"Saturn\" {\n        planets.append(\"Uranus\")\n    }\n    \n\
    \    if planet1 == \"Mercury\" && planet2 == \"Uranus\" {\n        planets.append(\"\
    Neptune\")\n    }\n    \n    if planet1 == \"Venus\" && planet2 == \"Earth\" {\n\
    \        planets.append(\"Mercury\")\n    }\n    \n    if planet1 == \"Venus\"\
    \ && planet2 == \"Mercury\" {\n        planets.append(\"Mars\")\n    }\n    \n\
    \    if planet1 == \"Venus\" && planet2 == \"Mars\" {\n        planets.append(\"\
    Jupiter\")\n    }\n    \n    if planet1 == \"Venus\" && planet2 == \"Jupiter\"\
    \ {\n        planets.append(\"Saturn\")\n    }\n    \n    if planet1 == \"Venus\"\
    \ && planet2 == \"Saturn\" {\n        planets.append(\"Uranus\")\n    }\n    \n\
    \    if planet1 == \"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1:\
    \ \"Earth\", planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\"\
    , planet2: \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    ])\nassert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2:\
    \ \"Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\"\
    ) == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: SyntaxError
  stderr: "/tmp/tmpev3dpe2o.swift:75:19: error: unterminated string literal\n    if\
    \ planet1 == \"\n                  ^\n"
  stdout: ''
  timestamp: 1659823230
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    var planets = [String]()\n\
    \    \n    if planet1 == planet2 {\n        return planets\n    }\n    \n    if\
    \ planet1 == \"Mercury\" {\n        planets = [\"Venus\"]\n    } else if planet1\
    \ == \"Venus\" {\n        planets = [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\", \"Neptune\"]\n    } else if planet1 == \"Earth\" {\n        planets\
    \ = [\"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"]\n    } else if\
    \ planet1 == \"Mars\" {\n        planets = [\"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    } else if planet1 == \"Jupiter\" {\n        planets = [\"\
    Saturn\", \"Uranus\", \"Neptune\"]\n    } else if planet1 == \"Saturn\" {\n  \
    \      planets = [\"Uranus\", \"Neptune\"]\n    } else if planet1 == \"Uranus\"\
    \ {\n        planets = [\"Neptune\"]\n    } else if planet1 == \"Neptune\" {\n\
    \        planets = [\"Mercury\", \"Venus\"]\n    }\n    \n    if planet2 == \"\
    Mercury\" {\n        planets = [\"Venus\"]\n    } else if planet2 == \"Venus\"\
    \ {\n        planets = [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    } else if planet2 == \"Earth\" {\n        planets = [\"Mars\"\
    , \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"]\n    } else if planet2 ==\
    \ \"Mars\" {\n        planets = [\"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    ]\n    } else if planet2 == \"Jupiter\" {\n        planets = [\"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    } else if planet2 == \"Saturn\" {\n        planets = [\"Uranus\"\
    , \"Neptune\"]\n    } else if planet2 == \"Uranus\" {\n        planets = [\"Neptune\"\
    ]\n    } else if planet2 == \"Neptune\" {\n        planets = [\"Mercury\", \"\
    Venus\"]\n    }\n    \n    return planets\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\") == [\"Saturn\", \"\
    Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\") == [\"Venus\"\
    ])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"Neptune\", planet2:\
    \ \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"])\n\
    assert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Makemake\") == [] as [String])"
  status: Exception
  stderr: 'tmp8grfsni8/tmp8grfsni8.swift:74: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002afa8fef2c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002afa8fbe9b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002afa8fbe9988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002afa8fbe87b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp8grfsni8                        0x0000557d9c5345cb <unavailable> + 5579

    5    libc.so.6                          0x00002afa900de460 __libc_start_main +
    245

    6    tmp8grfsni8                        0x0000557d9c534179 <unavailable> + 4473

    '
  stdout: ''
  timestamp: 1659823230
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    \n    var planets\
    \ = [String]()\n    \n    if planet1 == planet2 {\n        return planets\n  \
    \  }\n    \n    if planet1 == \"Mercury\" || planet1 == \"Venus\" || planet1 ==\
    \ \"Earth\" || planet1 == \"Mars\" || planet1 == \"Jupiter\" || planet1 == \"\
    Saturn\" || planet1 == \"Uranus\" || planet1 == \"Neptune\" {\n        planets.append(planet1)\n\
    \    }\n    \n    if planet2 == \"Mercury\" || planet2 == \"Venus\" || planet2\
    \ == \"Earth\" || planet2 == \"Mars\" || planet2 == \"Jupiter\" || planet2 ==\
    \ \"Saturn\" || planet2 == \"Uranus\" || planet2 == \"Neptune\" {\n        planets.append(planet2)\n\
    \    }\n    \n    if planet1 == \"Mercury\" && planet2 == \"Venus\" {\n      \
    \  planets.append(planet1)\n        planets.append(planet2)\n    }\n    \n   \
    \ if planet1 == \"Venus\" && planet2 == \"Mercury\" {\n        planets.append(planet1)\n\
    \        planets.append(planet2)\n    }\n    \n    if planet1 == \"Earth\" &&\
    \ planet2 == \"Mars\" {\n        planets.append(planet1)\n        planets.append(planet2)\n\
    \    }\n    \n    if planet1 == \"Mars\" && planet2 == \"Earth\" {\n        planets.append(planet1)\n\
    \        planets.append(planet2)\n    }\n    \n    if planet1 == \"Jupiter\" &&\
    \ planet2 == \"Saturn\" {\n        planets.append(planet1)\n        planets.append(planet2)\n\
    \    }\n    \n    if planet1 == \"Saturn\" && planet2 == \"Jupiter\" {\n     \
    \   planets.append(planet1)\n        planets.append(planet2)\n    }\n    \n  \
    \  if planet1 == \"Uranus\" && planet2 == \"Neptune\" {\n        planets.append(planet1)\n\
    \        planets.append(planet2)\n    }\n    \n    if planet1 == \"Neptune\" &&\
    \ planet2 == \"Uranus\" {\n        planets.append(planet1)\n        planets.append(planet2)\n\
    \    }\n    \n    if planet1 == \"Mercury\" && planet2 == \"Earth\" {\n      \
    \  planets.append(planet1)\n        planets.append(plan\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\") == [\"\
    Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\") ==\
    \ [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"Venus\"\
    , \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"Neptune\"\
    , planet2: \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    ])\nassert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Makemake\") == [] as [String])"
  status: SyntaxError
  stderr: "/tmp/tmpifm6kcsp.swift:74:1: error: expected ')' in expression list\n}\n\
    ^\n/tmp/tmpifm6kcsp.swift:73:23: note: to match this opening '('\n        planets.append(plan\n\
    \                      ^\n/tmp/tmpifm6kcsp.swift:95:70: error: expected '}' at\
    \ end of brace statement\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\"\
    ) == [] as [String])\n                                                       \
    \              ^\n/tmp/tmpifm6kcsp.swift:15:55: note: to match this opening '{'\n\
    func bf(planet1: String, planet2: String) -> [String] {\n                    \
    \                                  ^\n/tmp/tmpifm6kcsp.swift:73:24: error: cannot\
    \ find 'plan' in scope\n        planets.append(plan\n                       ^~~~\n\
    /tmp/tmpifm6kcsp.swift:77:6: error: operator functions can only be declared at\
    \ global or in type scope\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n     ^\n"
  stdout: ''
  timestamp: 1659823230
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    var result: [String]\
    \ = []\n    \n    // TODO: Write your code here\n    \n    return result\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\"\
    ) == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\"\
    ) == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"\
    Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\n\
    assert(bf(planet1: \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Makemake\") == [] as [String])"
  status: Exception
  stderr: 'tmpzxxi8gnj/tmpzxxi8gnj.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba76d0ddc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba76cdd4b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba76cdd4988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba76cdd37b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpzxxi8gnj                        0x000055717b78f51b <unavailable> + 5403

    5    libc.so.6                          0x00002ba76d2c9460 __libc_start_main +
    245

    6    tmpzxxi8gnj                        0x000055717b78f0c9 <unavailable> + 4297

    '
  stdout: ''
  timestamp: 1659823230
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    var planets = [String]()\n\
    \    \n    guard let planet1Orbit = orbit(planet1) else {\n        return planets\n\
    \    }\n    guard let planet2Orbit = orbit(planet2) else {\n        return planets\n\
    \    }\n    \n    var orbit1: [String] = []\n    var orbit2: [String] = []\n \
    \   \n    for planet in planets {\n        if planet == planet1 {\n          \
    \  orbit1.append(planet)\n        } else if planet == planet2 {\n            orbit2.append(planet)\n\
    \        }\n    }\n    \n    let orbit1Sun = orbit1Orbit.filter {\n        planet\
    \ in planet1Orbit.contains($0)\n    }\n    let orbit2Sun = orbit2Orbit.filter\
    \ {\n        planet in planet2Orbit.contains($0)\n    }\n    \n    let orbit1SunAndOrbit2Sun\
    \ = orbit1Sun.union(orbit2Sun)\n    \n    let orbit1SunAndOrbit2SunAndOrbit1SunAndOrbit2Sun\
    \ = orbit1SunAndOrbit2Sun.union(orbit1SunAndOrbit2Sun.union(orbit2Sun))\n    \n\
    \    let orbit1SunAndOrbit2SunAndOrbit1SunAndOrbit2SunAndOrbit1SunAndOrbit2Sun\
    \ = orbit1SunAndOrbit2SunAndOrbit1SunAndOrbit2Sun.union(orbit1SunAndOrbit2SunAndOrbit1SunAndOrbit2Sun.union(orbit1SunAndOrbit2SunAndOrbit1SunAndOrbit2Sun))\n\
    \    \n    let orbit1SunAndOrbit2SunAndOrbit1SunAndOrbit2SunAndOrbit1SunAndOrbit2SunAndOrbit1SunAndOrbit2Sun\
    \ = orbit1SunAndOrbit2SunAndOrbit1SunAndOrbit2SunAndOrbit1SunAndOrbit2SunAndOrbit1SunAndOrbit2Sun\n\
    \    \n    let orbit1SunAndOrbit2SunAndOrbit1SunAndOrbit2SunAndOrbit1SunAndOrbit2SunAndOrbit1SunAndOrbit2SunAndOrbit1SunAndOrbit2Sun\
    \ = orbit1SunAndOrbit2SunAndOrbit1SunAndOrbit2SunAndOrbit1SunAndOrbit2SunAndOrbit1SunAndOrbit\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\"\
    ) == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\"\
    ) == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"\
    Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\n\
    assert(bf(planet1: \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Makemake\") == [] as [String])"
  status: SyntaxError
  stderr: "/tmp/tmpum9plalx.swift:37:41: error: anonymous closure arguments cannot\
    \ be used inside a closure that has explicit arguments; did you mean 'planet'?\n\
    \        planet in planet1Orbit.contains($0)\n                               \
    \         ^~\n                                        planet\n/tmp/tmpum9plalx.swift:40:41:\
    \ error: anonymous closure arguments cannot be used inside a closure that has\
    \ explicit arguments; did you mean 'planet'?\n        planet in planet2Orbit.contains($0)\n\
    \                                        ^~\n                                \
    \        planet\n/tmp/tmpum9plalx.swift:18:30: error: cannot find 'orbit' in scope\n\
    \    guard let planet1Orbit = orbit(planet1) else {\n                        \
    \     ^~~~~\n/tmp/tmpum9plalx.swift:21:30: error: cannot find 'orbit' in scope\n\
    \    guard let planet2Orbit = orbit(planet2) else {\n                        \
    \     ^~~~~\n/tmp/tmpum9plalx.swift:36:21: error: cannot find 'orbit1Orbit' in\
    \ scope\n    let orbit1Sun = orbit1Orbit.filter {\n                    ^~~~~~~~~~~\n\
    /tmp/tmpum9plalx.swift:39:21: error: cannot find 'orbit2Orbit' in scope\n    let\
    \ orbit2Sun = orbit2Orbit.filter {\n                    ^~~~~~~~~~~\n/tmp/tmpum9plalx.swift:49:105:\
    \ error: use of local variable 'orbit1SunAndOrbit2SunAndOrbit1SunAndOrbit2SunAndOrbit1SunAndOrbit2SunAndOrbit1SunAndOrbit2Sun'\
    \ before its declaration\n    let orbit1SunAndOrbit2SunAndOrbit1SunAndOrbit2SunAndOrbit1SunAndOrbit2SunAndOrbit1SunAndOrbit2Sun\
    \ = orbit1SunAndOrbit2SunAndOrbit1SunAndOrbit2SunAndOrbit1SunAndOrbit2SunAndOrbit1SunAndOrbit2Sun\n\
    \                                                                            \
    \                            ^\n/tmp/tmpum9plalx.swift:49:9: note: 'orbit1SunAndOrbit2SunAndOrbit1SunAndOrbit2SunAndOrbit1SunAndOrbit2SunAndOrbit1SunAndOrbit2Sun'\
    \ declared here\n    let orbit1SunAndOrbit2SunAndOrbit1SunAndOrbit2SunAndOrbit1SunAndOrbit2SunAndOrbit1SunAndOrbit2Sun\
    \ = orbit1SunAndOrbit2SunAndOrbit1SunAndOrbit2SunAndOrbit1SunAndOrbit2SunAndOrbit1SunAndOrbit2Sun\n\
    \        ^\n/tmp/tmpum9plalx.swift:51:129: error: cannot find 'o"
  stdout: ''
  timestamp: 1659823231
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    var planets = [String]()\n\
    \    \n    switch planet1 {\n    case \"Mercury\":\n        planets.append(\"\
    Venus\")\n    case \"Venus\":\n        planets.append(\"Earth\")\n    case \"\
    Earth\":\n        planets.append(\"Mars\")\n    case \"Mars\":\n        planets.append(\"\
    Jupiter\")\n    case \"Jupiter\":\n        planets.append(\"Saturn\")\n    case\
    \ \"Saturn\":\n        planets.append(\"Uranus\")\n    case \"Uranus\":\n    \
    \    planets.append(\"Neptune\")\n    case \"Neptune\":\n        planets.append(\"\
    Mercury\")\n    default:\n        return planets\n    }\n    \n    switch planet2\
    \ {\n    case \"Mercury\":\n        planets.append(\"Venus\")\n    case \"Venus\"\
    :\n        planets.append(\"Earth\")\n    case \"Earth\":\n        planets.append(\"\
    Mars\")\n    case \"Mars\":\n        planets.append(\"Jupiter\")\n    case \"\
    Jupiter\":\n        planets.append(\"Saturn\")\n    case \"Saturn\":\n       \
    \ planets.append(\"Uranus\")\n    case \"Uranus\":\n        planets.append(\"\
    Neptune\")\n    case \"Neptune\":\n        planets.append(\"Mercury\")\n    default:\n\
    \        return planets\n    }\n    \n    return planets\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\") == [\"\
    Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\") ==\
    \ [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"Venus\"\
    , \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"Neptune\"\
    , planet2: \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    ])\nassert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Makemake\") == [] as [String])"
  status: Exception
  stderr: 'tmpuix6xo9g/tmpuix6xo9g.swift:76: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b6139d76c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6139a6db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b6139a6d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b6139a6c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpuix6xo9g                        0x000056452976462b <unavailable> + 5675

    5    libc.so.6                          0x00002b6139f62460 __libc_start_main +
    245

    6    tmpuix6xo9g                        0x00005645297641d9 <unavailable> + 4569

    '
  stdout: ''
  timestamp: 1659823231
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    var planets = [String]()\n\
    \    \n    if planet1 == \"Mercury\" && planet2 == \"Venus\" {\n        planets\
    \ = [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"]\n\
    \    } else if planet1 == \"Venus\" && planet2 == \"Earth\" {\n        planets\
    \ = [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"]\n\
    \    } else if planet1 == \"Earth\" && planet2 == \"Mars\" {\n        planets\
    \ = [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"]\n\
    \    } else if planet1 == \"Mars\" && planet2 == \"Jupiter\" {\n        planets\
    \ = [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"]\n\
    \    } else if planet1 == \"Jupiter\" && planet2 == \"Saturn\" {\n        planets\
    \ = [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"]\n\
    \    } else if planet1 == \"Saturn\" && planet2 == \"Uranus\" {\n        planets\
    \ = [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"]\n\
    \    } else if planet1 == \"Uranus\" && planet2 == \"Neptune\" {\n        planets\
    \ = [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"]\n\
    \    } else {\n        return planets\n    }\n    \n    return planets\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\"\
    ) == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\"\
    ) == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"\
    Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\n\
    assert(bf(planet1: \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Makemake\") == [] as [String])"
  status: Exception
  stderr: 'tmpgyrbh8ms/tmpgyrbh8ms.swift:52: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002afa8ddd1c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002afa8dac8b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002afa8dac8988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002afa8dac77b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpgyrbh8ms                        0x000055b8458d35cb <unavailable> + 5579

    5    libc.so.6                          0x00002afa8dfbd460 __libc_start_main +
    245

    6    tmpgyrbh8ms                        0x000055b8458d3179 <unavailable> + 4473

    '
  stdout: ''
  timestamp: 1659823230
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    \n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\") == [\"\
    Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\") ==\
    \ [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"Venus\"\
    , \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"Neptune\"\
    , planet2: \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    ])\nassert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Makemake\") == [] as [String])"
  status: SyntaxError
  stderr: '/tmp/tmp3d9bvts2.swift:17:1: error: missing return in global function expected
    to return ''[String]''

    }

    ^

    '
  stdout: ''
  timestamp: 1659823230
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    var planets = [String]()\n\
    \    \n    if planet1 == \"Mercury\" && planet2 == \"Venus\" {\n        planets\
    \ = [\"Mercury\", \"Venus\"]\n    } else if planet1 == \"Venus\" && planet2 ==\
    \ \"Mercury\" {\n        planets = [\"Venus\", \"Mercury\"]\n    } else if planet1\
    \ == \"Earth\" && planet2 == \"Mars\" {\n        planets = [\"Earth\", \"Mars\"\
    ]\n    } else if planet1 == \"Mars\" && planet2 == \"Earth\" {\n        planets\
    \ = [\"Mars\", \"Earth\"]\n    } else if planet1 == \"Jupiter\" && planet2 ==\
    \ \"Saturn\" {\n        planets = [\"Jupiter\", \"Saturn\"]\n    } else if planet1\
    \ == \"Saturn\" && planet2 == \"Jupiter\" {\n        planets = [\"Saturn\", \"\
    Jupiter\"]\n    } else if planet1 == \"Uranus\" && planet2 == \"Neptune\" {\n\
    \        planets = [\"Uranus\", \"Neptune\"]\n    } else if planet1 == \"Neptune\"\
    \ && planet2 == \"Uranus\" {\n        planets = [\"Neptune\", \"Uranus\"]\n  \
    \  } else {\n        return planets\n    }\n    \n    return planets\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\"\
    ) == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\"\
    ) == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"\
    Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\n\
    assert(bf(planet1: \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Makemake\") == [] as [String])"
  status: Exception
  stderr: 'tmp7ma8dqwc/tmp7ma8dqwc.swift:54: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b2194625c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b219431cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b219431c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b219431b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp7ma8dqwc                        0x0000558a2caab5cb <unavailable> + 5579

    5    libc.so.6                          0x00002b2194811460 __libc_start_main +
    245

    6    tmp7ma8dqwc                        0x0000558a2caab179 <unavailable> + 4473

    '
  stdout: ''
  timestamp: 1659823231
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    var planets = [String]()\n\
    \    \n    if planet1 == planet2 {\n        return planets\n    }\n    \n    if\
    \ planet1 == \"Mercury\" || planet1 == \"Venus\" || planet1 == \"Earth\" || planet1\
    \ == \"Mars\" || planet1 == \"Jupiter\" || planet1 == \"Saturn\" || planet1 ==\
    \ \"Uranus\" || planet1 == \"Neptune\" {\n        planets.append(planet1)\n  \
    \  }\n    \n    if planet2 == \"Mercury\" || planet2 == \"Venus\" || planet2 ==\
    \ \"Earth\" || planet2 == \"Mars\" || planet2 == \"Jupiter\" || planet2 == \"\
    Saturn\" || planet2 == \"Uranus\" || planet2 == \"Neptune\" {\n        planets.append(planet2)\n\
    \    }\n    \n    if planet1 == \"Mercury\" && planet2 == \"Venus\" {\n      \
    \  planets.append(planet1)\n        planets.append(planet2)\n    }\n    \n   \
    \ if planet1 == \"Venus\" && planet2 == \"Mercury\" {\n        planets.append(planet1)\n\
    \        planets.append(planet2)\n    }\n    \n    if planet1 == \"Earth\" &&\
    \ planet2 == \"Mercury\" {\n        planets.append(planet1)\n        planets.append(planet2)\n\
    \    }\n    \n    if planet1 == \"Mars\" && planet2 == \"Mercury\" {\n       \
    \ planets.append(planet1)\n        planets.append(planet2)\n    }\n    \n    if\
    \ planet1 == \"Jupiter\" && planet2 == \"Mercury\" {\n        planets.append(planet1)\n\
    \        planets.append(planet2)\n    }\n    \n    if planet1 == \"Saturn\" &&\
    \ planet2 == \"Mercury\" {\n        planets.append(planet1)\n        planets.append(planet2)\n\
    \    }\n    \n    if planet1 == \"Uranus\" && planet2 == \"Mercury\" {\n     \
    \   planets.append(planet1)\n        planets.append(planet2)\n    }\n    \n  \
    \  if planet1 == \"Neptune\" && planet2 == \"Mercury\" {\n        planets.append(planet1)\n\
    \        planets.append(planet2)\n    }\n    \n    if planet1 == \"Mercury\" &&\
    \ planet2 == \"Earth\" {\n        planets.append(planet1)\n        planet\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\"\
    ) == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\"\
    ) == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"\
    Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\n\
    assert(bf(planet1: \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Makemake\") == [] as [String])"
  status: SyntaxError
  stderr: "/tmp/tmpecbl596z.swift:94:70: error: expected '}' at end of brace statement\n\
    assert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") == [] as [String])\n  \
    \                                                                   ^\n/tmp/tmpecbl596z.swift:15:55:\
    \ note: to match this opening '{'\nfunc bf(planet1: String, planet2: String) ->\
    \ [String] {\n                                                      ^\n/tmp/tmpecbl596z.swift:72:9:\
    \ error: cannot find 'planet' in scope\n        planet\n        ^~~~~~\n/tmp/tmpecbl596z.swift:76:6:\
    \ error: operator functions can only be declared at global or in type scope\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1659823230
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    var planets = [String]()\n\
    \    \n    if planet1 == planet2 {\n        return planets\n    }\n    \n    if\
    \ planet1 == \"Mercury\" {\n        planets.append(\"Venus\")\n    }\n    \n \
    \   if planet1 == \"Venus\" {\n        planets.append(\"Earth\")\n    }\n    \n\
    \    if planet1 == \"Earth\" {\n        planets.append(\"Mars\")\n    }\n    \n\
    \    if planet1 == \"Mars\" {\n        planets.append(\"Jupiter\")\n    }\n  \
    \  \n    if planet1 == \"Jupiter\" {\n        planets.append(\"Saturn\")\n   \
    \ }\n    \n    if planet1 == \"Saturn\" {\n        planets.append(\"Uranus\")\n\
    \    }\n    \n    if planet1 == \"Uranus\" {\n        planets.append(\"Neptune\"\
    )\n    }\n    \n    if planet1 == \"Neptune\" {\n        planets.append(\"Mercury\"\
    )\n    }\n    \n    if planet2 == \"Mercury\" {\n        planets.append(\"Venus\"\
    )\n    }\n    \n    if planet2 == \"Venus\" {\n        planets.append(\"Earth\"\
    )\n    }\n    \n    if planet2 == \"Earth\" {\n        planets.append(\"Mars\"\
    )\n    }\n    \n    if planet2 == \"Mars\" {\n        planets.append(\"Jupiter\"\
    )\n    }\n    \n    if planet2 == \"Jupiter\" {\n        planets.append(\"Saturn\"\
    )\n    }\n    \n    if planet2 == \"Saturn\" {\n        planets.append(\"Uranus\"\
    )\n    }\n    \n    if planet2 == \"Uranus\" {\n        planets.append(\"Neptune\"\
    )\n    }\n    \n    if planet2 == \"Neptune\" {\n        planets.append(\"Mercury\"\
    )\n    }\n    \n    return planets\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(bf(planet1: \"Jupiter\", planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"\
    ])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1:\
    \ \"Mercury\", planet2: \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"])\nassert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2:\
    \ \"Earth\") == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\"\
    ) == [] as [String])"
  status: Exception
  stderr: 'tmp01j43xsq/tmp01j43xsq.swift:102: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae180e98c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae180b8fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae180b8f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae180b8e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp01j43xsq                        0x0000557927d3362b <unavailable> + 5675

    5    libc.so.6                          0x00002ae181084460 __libc_start_main +
    245

    6    tmp01j43xsq                        0x0000557927d331d9 <unavailable> + 4569

    '
  stdout: ''
  timestamp: 1659823230
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    var result = [String]()\n\
    \    \n    if planet1 == planet2 {\n        return result;\n    }\n    \n    var\
    \ planet1Orbit = orbit(planet1)\n    var planet2Orbit = orbit(planet2)\n    \n\
    \    if planet1Orbit == planet2Orbit {\n        return result;\n    }\n    \n\
    \    var planet1OrbitIndex = index(planet1Orbit)\n    var planet2OrbitIndex =\
    \ index(planet2Orbit)\n    \n    if planet1OrbitIndex < planet2OrbitIndex {\n\
    \        result.insert(planet1, atIndex(planet1OrbitIndex))\n        result.insert(planet2,\
    \ atIndex(planet2OrbitIndex))\n    } else {\n        result.insert(planet2, atIndex(planet1OrbitIndex))\n\
    \        result.insert(planet1, atIndex(planet2OrbitIndex))\n    }\n    \n   \
    \ return result.sorted(byDistance)\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(bf(planet1: \"Jupiter\", planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"\
    ])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1:\
    \ \"Mercury\", planet2: \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"])\nassert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2:\
    \ \"Earth\") == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\"\
    ) == [] as [String])"
  status: SyntaxError
  stderr: "/tmp/tmpf147btk_.swift:22:24: error: cannot find 'orbit' in scope\n   \
    \ var planet1Orbit = orbit(planet1)\n                       ^~~~~\n/tmp/tmpf147btk_.swift:23:24:\
    \ error: cannot find 'orbit' in scope\n    var planet2Orbit = orbit(planet2)\n\
    \                       ^~~~~\n/tmp/tmpf147btk_.swift:29:29: error: cannot find\
    \ 'index' in scope\n    var planet1OrbitIndex = index(planet1Orbit)\n        \
    \                    ^~~~~\n/tmp/tmpf147btk_.swift:30:29: error: cannot find 'index'\
    \ in scope\n    var planet2OrbitIndex = index(planet2Orbit)\n                \
    \            ^~~~~\n/tmp/tmpf147btk_.swift:33:32: error: cannot find 'atIndex'\
    \ in scope\n        result.insert(planet1, atIndex(planet1OrbitIndex))\n     \
    \                          ^~~~~~~\n/tmp/tmpf147btk_.swift:33:16: error: no exact\
    \ matches in call to instance method 'insert'\n        result.insert(planet1,\
    \ atIndex(planet1OrbitIndex))\n               ^\n/tmp/tmpf147btk_.swift:33:16:\
    \ note: found candidate with type '(__owned String, Int) -> ()'\n        result.insert(planet1,\
    \ atIndex(planet1OrbitIndex))\n               ^\n/tmp/tmpf147btk_.swift:34:32:\
    \ error: cannot find 'atIndex' in scope\n        result.insert(planet2, atIndex(planet2OrbitIndex))\n\
    \                               ^~~~~~~\n/tmp/tmpf147btk_.swift:34:16: error:\
    \ no exact matches in call to instance method 'insert'\n        result.insert(planet2,\
    \ atIndex(planet2OrbitIndex))\n               ^\n/tmp/tmpf147btk_.swift:34:16:\
    \ note: found candidate with type '(__owned String, Int) -> ()'\n        result.insert(planet2,\
    \ atIndex(planet2OrbitIndex))\n               ^\n/tmp/tmpf147btk_.swift:36:32:\
    \ error: cannot find 'atIndex' in scope\n        result.insert(planet2, atIndex(planet1OrbitIndex))\n\
    \                               ^~~~~~~\n/tmp/tmpf147btk_.swift:36:16: error:\
    \ no exact matches in call to instance method 'insert'\n        result.insert(planet2,\
    \ atIndex(planet1OrbitIndex))\n               ^\n/tmp/tmpf147btk_.swift:36:16:\
    \ note: found candidate with type '(__owned String, Int) -> ()'\n        result.insert(planet2,\
    \ atIndex(planet1OrbitIndex))\n   "
  stdout: ''
  timestamp: 1659823231
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    \n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\") == [\"\
    Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\") ==\
    \ [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"Venus\"\
    , \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"Neptune\"\
    , planet2: \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    ])\nassert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Makemake\") == [] as [String])"
  status: SyntaxError
  stderr: '/tmp/tmp3d9bvts2.swift:17:1: error: missing return in global function expected
    to return ''[String]''

    }

    ^

    '
  stdout: ''
  timestamp: 1659823230
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    var planets = [String]()\n\
    \    \n    // TODO: Write your code here\n    \n    return planets\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\"\
    ) == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\"\
    ) == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"\
    Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\n\
    assert(bf(planet1: \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Makemake\") == [] as [String])"
  status: Exception
  stderr: 'tmpqir0zopy/tmpqir0zopy.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b71b763fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b71b7336b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b71b7336988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b71b73357b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpqir0zopy                        0x00005603381a456b <unavailable> + 5483

    5    libc.so.6                          0x00002b71b782b460 __libc_start_main +
    245

    6    tmpqir0zopy                        0x00005603381a4119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659823230
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    var result = [String]()\n\
    \    \n    guard let planet1Orbit = orbit(planet1) else {\n        return result;\n\
    \    }\n    guard let planet2Orbit = orbit(planet2) else {\n        return result;\n\
    \    }\n    \n    let sunOrbit = orbit(\"Sun\")\n    \n    if planet1Orbit ==\
    \ sunOrbit {\n        if planet2Orbit == sunOrbit {\n            result.append(planet1)\n\
    \            result.append(planet2)\n        } else {\n            result.append(planet2)\n\
    \            result.append(planet1)\n        }\n    } else {\n        if planet2Orbit\
    \ == sunOrbit {\n            result.append(planet1)\n            result.append(planet2)\n\
    \        } else {\n            result.append(planet1)\n            result.append(planet2)\n\
    \        }\n    }\n    \n    result.sort(by: { (planet1, planet2) -> Bool in\n\
    \        let planet1Orbit = orbit(planet1)\n        let planet2Orbit = orbit(planet2)\n\
    \        \n        if planet1Orbit == planet2Orbit {\n            return false\n\
    \        }\n        \n        let sunOrbit = orbit(\"Sun\")\n        \n      \
    \  if planet1Orbit == sunOrbit {\n            return true\n        }\n       \
    \ \n        if planet2Orbit == sunOrbit {\n            return false\n        }\n\
    \        \n        return true\n    })\n    \n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\") == [\"\
    Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\") ==\
    \ [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"Venus\"\
    , \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"Neptune\"\
    , planet2: \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    ])\nassert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Makemake\") == [] as [String])"
  status: SyntaxError
  stderr: "/tmp/tmpizf7uwbg.swift:18:30: error: cannot find 'orbit' in scope\n   \
    \ guard let planet1Orbit = orbit(planet1) else {\n                           \
    \  ^~~~~\n/tmp/tmpizf7uwbg.swift:21:30: error: cannot find 'orbit' in scope\n\
    \    guard let planet2Orbit = orbit(planet2) else {\n                        \
    \     ^~~~~\n/tmp/tmpizf7uwbg.swift:25:20: error: cannot find 'orbit' in scope\n\
    \    let sunOrbit = orbit(\"Sun\")\n                   ^~~~~\n/tmp/tmpizf7uwbg.swift:46:28:\
    \ error: cannot find 'orbit' in scope\n        let planet1Orbit = orbit(planet1)\n\
    \                           ^~~~~\n/tmp/tmpizf7uwbg.swift:47:28: error: cannot\
    \ find 'orbit' in scope\n        let planet2Orbit = orbit(planet2)\n         \
    \                  ^~~~~\n/tmp/tmpizf7uwbg.swift:53:24: error: cannot find 'orbit'\
    \ in scope\n        let sunOrbit = orbit(\"Sun\")\n                       ^~~~~\n"
  stdout: ''
  timestamp: 1659823231
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    \n    // TODO: Write\
    \ your code here\n    \n    return []\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(bf(planet1: \"Jupiter\", planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"\
    ])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1:\
    \ \"Mercury\", planet2: \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"])\nassert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2:\
    \ \"Earth\") == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\"\
    ) == [] as [String])"
  status: Exception
  stderr: 'tmpbyjxxbwz/tmpbyjxxbwz.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b81eae97c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b81eab8eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b81eab8e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b81eab8d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpbyjxxbwz                        0x000055fa1b6d651b <unavailable> + 5403

    5    libc.so.6                          0x00002b81eb083460 __libc_start_main +
    245

    6    tmpbyjxxbwz                        0x000055fa1b6d60c9 <unavailable> + 4297

    '
  stdout: ''
  timestamp: 1659823230
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    \n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\") == [\"\
    Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\") ==\
    \ [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"Venus\"\
    , \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"Neptune\"\
    , planet2: \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    ])\nassert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Makemake\") == [] as [String])"
  status: SyntaxError
  stderr: '/tmp/tmp3d9bvts2.swift:17:1: error: missing return in global function expected
    to return ''[String]''

    }

    ^

    '
  stdout: ''
  timestamp: 1659823230
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    var planets = [String]()\n\
    \    \n    if planet1 == \"Mercury\" || planet1 == \"Venus\" || planet1 == \"\
    Earth\" || planet1 == \"Mars\" || planet1 == \"Jupiter\" || planet1 == \"Saturn\"\
    \ || planet1 == \"Uranus\" || planet1 == \"Neptune\" {\n        planets.append(planet1)\n\
    \    }\n    \n    if planet2 == \"Mercury\" || planet2 == \"Venus\" || planet2\
    \ == \"Earth\" || planet2 == \"Mars\" || planet2 == \"Jupiter\" || planet2 ==\
    \ \"Saturn\" || planet2 == \"Uranus\" || planet2 == \"Neptune\" {\n        planets.append(planet2)\n\
    \    }\n    \n    if planet1 == planet2 {\n        return planets\n    }\n   \
    \ \n    if planet1 == \"Mercury\" && planet2 == \"Venus\" {\n        planets.append(planet1)\n\
    \        planets.append(planet2)\n    }\n    \n    if planet1 == \"Venus\" &&\
    \ planet2 == \"Mercury\" {\n        planets.append(planet1)\n        planets.append(planet2)\n\
    \    }\n    \n    if planet1 == \"Earth\" && planet2 == \"Mars\" {\n        planets.append(planet1)\n\
    \        planets.append(planet2)\n    }\n    \n    if planet1 == \"Mars\" && planet2\
    \ == \"Earth\" {\n        planets.append(planet1)\n        planets.append(planet2)\n\
    \    }\n    \n    if planet1 == \"Jupiter\" && planet2 == \"Saturn\" {\n     \
    \   planets.append(planet1)\n        planets.append(planet2)\n    }\n    \n  \
    \  if planet1 == \"Saturn\" && planet2 == \"Jupiter\" {\n        planets.append(planet1)\n\
    \        planets.append(planet2)\n    }\n    \n    if planet1 == \"Uranus\" &&\
    \ planet2 == \"Neptune\" {\n        planets.append(planet1)\n        planets.append(planet2)\n\
    \    }\n    \n    if planet1 == \"Neptune\" && planet2 == \"Uranus\" {\n     \
    \   planets.append(planet1)\n        planets.append(planet2)\n    }\n    \n  \
    \  if planet1 == \"Mercury\" && planet2 == \"Earth\" {\n        planets.append(planet1)\n\
    \        planets.append(planet2)\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1:\
    \ \"Earth\", planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\"\
    , planet2: \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    ])\nassert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2:\
    \ \"Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\"\
    ) == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: SyntaxError
  stderr: "/tmp/tmpiquzhzqj.swift:94:70: error: expected '}' at end of brace statement\n\
    assert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") == [] as [String])\n  \
    \                                                                   ^\n/tmp/tmpiquzhzqj.swift:15:55:\
    \ note: to match this opening '{'\nfunc bf(planet1: String, planet2: String) ->\
    \ [String] {\n                                                      ^\n/tmp/tmpiquzhzqj.swift:76:6:\
    \ error: operator functions can only be declared at global or in type scope\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1659823230
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    var planets = [String]()\n\
    \    \n    switch planet1 {\n    case \"Mercury\":\n        planets = [\"Venus\"\
    ]\n    case \"Venus\":\n        planets = [\"Earth\", \"Mars\", \"Jupiter\", \"\
    Saturn\", \"Uranus\", \"Neptune\"]\n    case \"Earth\":\n        planets = [\"\
    Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"]\n    case \"Mars\":\n\
    \        planets = [\"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"]\n    case\
    \ \"Jupiter\":\n        planets = [\"Saturn\", \"Uranus\", \"Neptune\"]\n    case\
    \ \"Saturn\":\n        planets = [\"Uranus\", \"Neptune\"]\n    case \"Uranus\"\
    :\n        planets = [\"Neptune\"]\n    case \"Neptune\":\n        planets = [\"\
    Mercury\", \"Venus\"]\n    default:\n        return planets\n    }\n    \n   \
    \ switch planet2 {\n    case \"Mercury\":\n        planets = [\"Venus\"]\n   \
    \ case \"Venus\":\n        planets = [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\", \"Neptune\"]\n    case \"Earth\":\n        planets = [\"Mars\",\
    \ \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"]\n    case \"Mars\":\n    \
    \    planets = [\"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"]\n    case \"\
    Jupiter\":\n        planets = [\"Saturn\", \"Uranus\", \"Neptune\"]\n    case\
    \ \"Saturn\":\n        planets = [\"Uranus\", \"Neptune\"]\n    case \"Uranus\"\
    :\n        planets = [\"Neptune\"]\n    case \"Neptune\":\n        planets = [\"\
    Mercury\", \"Venus\"]\n    default:\n        return planets\n    }\n    \n   \
    \ var result = [String]()\n    \n    for planet in planets {\n        let distance\
    \ = distance(planet, planet1)\n        let distance2 = distance(planet, planet2)\n\
    \        \n        if distance < distance2 {\n            result.append(planet)\n\
    \        }\n    }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\") == [\"Saturn\", \"\
    Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\") == [\"Venus\"\
    ])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"Neptune\", planet2:\
    \ \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"])\n\
    assert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Makemake\") == [] as [String])"
  status: SyntaxError
  stderr: "/tmp/tmptovjjxm3.swift:63:24: error: use of local variable 'distance' before\
    \ its declaration\n        let distance = distance(planet, planet1)\n        \
    \               ^\n/tmp/tmptovjjxm3.swift:63:13: note: 'distance' declared here\n\
    \        let distance = distance(planet, planet1)\n            ^\n"
  stdout: ''
  timestamp: 1659823231
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    var result: [String]\
    \ = []\n    \n    // TODO: Write your code here\n    \n    return result\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\"\
    ) == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\"\
    ) == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"\
    Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\n\
    assert(bf(planet1: \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Makemake\") == [] as [String])"
  status: Exception
  stderr: 'tmpzxxi8gnj/tmpzxxi8gnj.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba76d0ddc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba76cdd4b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba76cdd4988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba76cdd37b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpzxxi8gnj                        0x000055717b78f51b <unavailable> + 5403

    5    libc.so.6                          0x00002ba76d2c9460 __libc_start_main +
    245

    6    tmpzxxi8gnj                        0x000055717b78f0c9 <unavailable> + 4297

    '
  stdout: ''
  timestamp: 1659823230
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    \n    var planets\
    \ = [String]()\n    \n    if planet1 == planet2 {\n        return planets\n  \
    \  }\n    \n    if planet1 == \"Mercury\" && planet2 == \"Earth\" {\n        planets\
    \ = [\"Venus\"]\n    } else if planet1 == \"Venus\" && planet2 == \"Earth\" {\n\
    \        planets = [\"Mercury\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    } else if planet1 == \"Earth\" && planet2 == \"Mars\" {\n\
    \        planets = [\"Venus\", \"Mercury\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    } else if planet1 == \"Mars\" && planet2 == \"Jupiter\" {\n\
    \        planets = [\"Venus\", \"Mercury\", \"Earth\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    } else if planet1 == \"Jupiter\" && planet2 == \"Saturn\"\
    \ {\n        planets = [\"Venus\", \"Mercury\", \"Earth\", \"Mars\", \"Uranus\"\
    , \"Neptune\"]\n    } else if planet1 == \"Saturn\" && planet2 == \"Uranus\" {\n\
    \        planets = [\"Venus\", \"Mercury\", \"Earth\", \"Mars\", \"Jupiter\",\
    \ \"Neptune\"]\n    } else if planet1 == \"Uranus\" && planet2 == \"Neptune\"\
    \ {\n        planets = [\"Venus\", \"Mercury\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"]\n    } else if planet1 == \"Neptune\" && planet2 == \"Mercury\"\
    \ {\n        planets = [\"Venus\", \"Mercury\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\", \"Uranus\"]\n    } else if planet1 == \"Mercury\" && planet2 ==\
    \ \"Venus\" {\n        planets = [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\", \"Neptune\"]\n    } else if planet1 == \"Venus\" && planet2 == \"\
    Earth\" {\n        planets = [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"\
    Uranus\", \"Neptune\"]\n    } else if planet1 == \"Earth\" && planet2 == \"Mars\"\
    \ {\n        planets = [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    } else if planet1 == \"Mars\" && planet2 == \"J\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\"\
    ) == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\"\
    ) == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"\
    Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\n\
    assert(bf(planet1: \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Makemake\") == [] as [String])"
  status: SyntaxError
  stderr: "/tmp/tmp8r7zvjnn.swift:45:47: error: unterminated string literal\n    }\
    \ else if planet1 == \"Mars\" && planet2 == \"J\n                            \
    \                  ^\n"
  stdout: ''
  timestamp: 1659823231
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    \n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\") == [\"\
    Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\") ==\
    \ [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"Venus\"\
    , \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"Neptune\"\
    , planet2: \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    ])\nassert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Makemake\") == [] as [String])"
  status: SyntaxError
  stderr: '/tmp/tmp3d9bvts2.swift:17:1: error: missing return in global function expected
    to return ''[String]''

    }

    ^

    '
  stdout: ''
  timestamp: 1659823230
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    var planets = [String]()\n\
    \    \n    // TODO: Write your code here\n    \n    return planets\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\"\
    ) == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\"\
    ) == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"\
    Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\n\
    assert(bf(planet1: \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Makemake\") == [] as [String])"
  status: Exception
  stderr: 'tmpqir0zopy/tmpqir0zopy.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b71b763fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b71b7336b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b71b7336988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b71b73357b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpqir0zopy                        0x00005603381a456b <unavailable> + 5483

    5    libc.so.6                          0x00002b71b782b460 __libc_start_main +
    245

    6    tmpqir0zopy                        0x00005603381a4119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659823230
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    var result = [String]()\n\
    \    \n    if planet1 == planet2 {\n        return result \n    }\n    \n    let\
    \ planet1Orbit = orbit(planet1)\n    let planet2Orbit = orbit(planet2)\n    \n\
    \    if planet1Orbit == planet2Orbit {\n        return result \n    }\n    \n\
    \    let planet1Sun = orbit(planet1)\n    let planet2Sun = orbit(planet2)\n  \
    \  \n    if planet1Orbit == planet2Sun {\n        return result \n    }\n    \n\
    \    let planet1Sun = orbit(planet1)\n    let planet2Sun = orbit(planet2)\n  \
    \  \n    if planet1Orbit == planet2Sun {\n        return result \n    }\n    \n\
    \    let planet1Sun = orbit(planet1)\n    let planet2Sun = orbit(planet2)\n  \
    \  \n    if planet1Orbit == planet2Sun {\n        return result \n    }\n    \n\
    \    let planet1Sun = orbit(planet1)\n    let planet2Sun = orbit(planet2)\n  \
    \  \n    if planet1Orbit == planet2Sun {\n        return result \n    }\n    \n\
    \    let planet1Sun = orbit(planet1)\n    let planet2Sun = orbit(planet2)\n  \
    \  \n    if planet1Orbit == planet2Sun {\n        return result \n    }\n    \n\
    \    let planet1Sun = orbit(planet1)\n    let planet2Sun = orbit(planet2)\n  \
    \  \n    if planet1Orbit == planet2Sun {\n        return result \n    }\n    \n\
    \    let planet1Sun = orbit(planet1)\n    let planet2Sun = orbit(planet2)\n  \
    \  \n    if planet1Orbit == planet2Sun {\n        return result \n    }\n    \n\
    \    let planet1Sun = orbit(planet1)\n    let planet2Sun = orbit(planet2)\n  \
    \  \n    if planet1Orbit == planet2Sun {\n        return result \n    }\n    \n\
    \    let planet1Sun = orbit(planet1)\n    let planet2Sun = orbit(planet2)\n  \
    \  \n    if planet1Orbit == planet2Sun {\n        return result \n    }\n    \n\
    \    let planet1Sun = orbit(planet1)\n    let planet2Sun = orbit(planet2)\n  \
    \  \n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
    \ left.count != right.count {\n        return false\n    }\n    for (l, r) in\
    \ zip(left, right) {\n        if l != r {\n            return false\n        }\n\
    \    }\n    return true\n}\n            \nassert(bf(planet1: \"Jupiter\", planet2:\
    \ \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2:\
    \ \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\"\
    ) == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1:\
    \ \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\n\
    assert(bf(planet1: \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Makemake\") == [] as [String])"
  status: SyntaxError
  stderr: "/tmp/tmph7iiz3wi.swift:22:24: error: cannot find 'orbit' in scope\n   \
    \ let planet1Orbit = orbit(planet1)\n                       ^~~~~\n/tmp/tmph7iiz3wi.swift:23:24:\
    \ error: cannot find 'orbit' in scope\n    let planet2Orbit = orbit(planet2)\n\
    \                       ^~~~~\n/tmp/tmph7iiz3wi.swift:29:22: error: cannot find\
    \ 'orbit' in scope\n    let planet1Sun = orbit(planet1)\n                    \
    \ ^~~~~\n/tmp/tmph7iiz3wi.swift:30:22: error: cannot find 'orbit' in scope\n \
    \   let planet2Sun = orbit(planet2)\n                     ^~~~~\n/tmp/tmph7iiz3wi.swift:36:22:\
    \ error: cannot find 'orbit' in scope\n    let planet1Sun = orbit(planet1)\n \
    \                    ^~~~~\n/tmp/tmph7iiz3wi.swift:37:22: error: cannot find 'orbit'\
    \ in scope\n    let planet2Sun = orbit(planet2)\n                     ^~~~~\n\
    /tmp/tmph7iiz3wi.swift:43:22: error: cannot find 'orbit' in scope\n    let planet1Sun\
    \ = orbit(planet1)\n                     ^~~~~\n/tmp/tmph7iiz3wi.swift:44:22:\
    \ error: cannot find 'orbit' in scope\n    let planet2Sun = orbit(planet2)\n \
    \                    ^~~~~\n/tmp/tmph7iiz3wi.swift:50:22: error: cannot find 'orbit'\
    \ in scope\n    let planet1Sun = orbit(planet1)\n                     ^~~~~\n\
    /tmp/tmph7iiz3wi.swift:51:22: error: cannot find 'orbit' in scope\n    let planet2Sun\
    \ = orbit(planet2)\n                     ^~~~~\n/tmp/tmph7iiz3wi.swift:57:22:\
    \ error: cannot find 'orbit' in scope\n    let planet1Sun = orbit(planet1)\n \
    \                    ^~~~~\n/tmp/tmph7iiz3wi.swift:58:22: error: cannot find 'orbit'\
    \ in scope\n    let planet2Sun = orbit(planet2)\n                     ^~~~~\n\
    /tmp/tmph7iiz3wi.swift:64:22: error: cannot find 'orbit' in scope\n    let planet1Sun\
    \ = orbit(planet1)\n                     ^~~~~\n/tmp/tmph7iiz3wi.swift:65:22:\
    \ error: cannot find 'orbit' in scope\n    let planet2Sun = orbit(planet2)\n \
    \                    ^~~~~\n/tmp/tmph7iiz3wi.swift:71:22: error: cannot find 'orbit'\
    \ in scope\n    let planet1Sun = orbit(planet1)\n                     ^~~~~\n\
    /tmp/tmph7iiz3wi.swift:72:22: error: cannot find 'orbit' in scope\n    let planet2Sun\
    \ = orbit(planet2)\n   "
  stdout: ''
  timestamp: 1659823231
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    var result = [String]()\n\
    \    \n    if planet1 == planet2 {\n        return result;\n    }\n    \n    if\
    \ planet1 == \"Sun\" {\n        return result;\n    }\n    \n    if planet2 ==\
    \ \"Sun\" {\n        return result;\n    }\n    \n    let planet1Orbit = orbit(planet1)\n\
    \    let planet2Orbit = orbit(planet2)\n    \n    if planet1Orbit == planet2Orbit\
    \ {\n        return result;\n    }\n    \n    let planet1OrbitDistance = distance(planet1,\
    \ planet1Orbit)\n    let planet2OrbitDistance = distance(planet2, planet2Orbit)\n\
    \    \n    if planet1OrbitDistance < planet2OrbitDistance {\n        return result;\n\
    \    }\n    \n    if planet1OrbitDistance > planet2OrbitDistance {\n        return\
    \ result;\n    }\n    \n    if planet1OrbitDistance == planet2OrbitDistance {\n\
    \        return result;\n    }\n    \n    if planet1OrbitDistance < planet2OrbitDistance\
    \ {\n        return result;\n    }\n    \n    if planet1OrbitDistance > planet2OrbitDistance\
    \ {\n        return result;\n    }\n    \n    if planet1OrbitDistance == planet2OrbitDistance\
    \ {\n        return result;\n    }\n    \n    if planet1OrbitDistance < planet2OrbitDistance\
    \ {\n        return result;\n    }\n    \n    if planet1OrbitDistance > planet2OrbitDistance\
    \ {\n        return result;\n    }\n    \n    if planet1OrbitDistance == planet2OrbitDistance\
    \ {\n        return result;\n    }\n    \n    if planet1OrbitDistance < planet2OrbitDistance\
    \ {\n        return result;\n    }\n    \n    if planet1OrbitDistance > planet2OrbitDistance\
    \ {\n        return result;\n    }\n    \n    if planet1OrbitDistance == planet2OrbitDistance\
    \ {\n        return result;\n    }\n    \n    if planet1OrbitDistance < planet2OrbitDistance\
    \ {\n        return result;\n    }\n    \n    if planet1OrbitDistance > planet2OrbitDistance\
    \ {\n        return result;\n    }\n    \n    if planet1OrbitDistance == planet2OrbitDistance\
    \ {\n        return result;\n    }\n    \n    if planet1OrbitDistance < planet2OrbitDistance\
    \ {\n        return result;\n    }\n    \n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(bf(planet1: \"Jupiter\", planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"\
    ])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1:\
    \ \"Mercury\", planet2: \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"])\nassert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2:\
    \ \"Earth\") == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\"\
    ) == [] as [String])"
  status: SyntaxError
  stderr: "/tmp/tmpbqr_pqwq.swift:30:24: error: cannot find 'orbit' in scope\n   \
    \ let planet1Orbit = orbit(planet1)\n                       ^~~~~\n/tmp/tmpbqr_pqwq.swift:31:24:\
    \ error: cannot find 'orbit' in scope\n    let planet2Orbit = orbit(planet2)\n\
    \                       ^~~~~\n/tmp/tmpbqr_pqwq.swift:37:32: error: cannot find\
    \ 'distance' in scope\n    let planet1OrbitDistance = distance(planet1, planet1Orbit)\n\
    \                               ^~~~~~~~\n/tmp/tmpbqr_pqwq.swift:38:32: error:\
    \ cannot find 'distance' in scope\n    let planet2OrbitDistance = distance(planet2,\
    \ planet2Orbit)\n                               ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659823231
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    \n    guard let planet1Orbit\
    \ = orbit(planet1),\n        let planet2Orbit = orbit(planet2) else {\n      \
    \      return []\n    }\n    \n    var orbitsBetweenPlanets: [String] = []\n \
    \   \n    for planet in planet1Orbit {\n        if planet == planet2 {\n     \
    \       continue\n        }\n        \n        for otherPlanet in planet2Orbit\
    \ {\n            if otherPlanet == planet {\n                continue\n      \
    \      }\n            \n            let distance = distance(planet: planet, otherPlanet:\
    \ otherPlanet)\n            if distance < 1.0 {\n                orbitsBetweenPlanets.append(planet)\n\
    \            }\n        }\n    }\n    \n    return orbitsBetweenPlanets.sorted(by:\
    \ { (planet1, planet2) -> Bool in\n        let distance = distance(planet: planet1,\
    \ otherPlanet: planet2)\n        return distance < 1.0\n    })\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\") == [\"\
    Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\") ==\
    \ [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"Venus\"\
    , \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"Neptune\"\
    , planet2: \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    ])\nassert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Makemake\") == [] as [String])"
  status: SyntaxError
  stderr: "/tmp/tmpdnpf22ig.swift:17:30: error: cannot find 'orbit' in scope\n   \
    \ guard let planet1Orbit = orbit(planet1),\n                             ^~~~~\n\
    /tmp/tmpdnpf22ig.swift:18:28: error: cannot find 'orbit' in scope\n        let\
    \ planet2Orbit = orbit(planet2) else {\n                           ^~~~~\n/tmp/tmpdnpf22ig.swift:42:24:\
    \ error: use of local variable 'distance' before its declaration\n        let\
    \ distance = distance(planet: planet1, otherPlanet: planet2)\n               \
    \        ^\n/tmp/tmpdnpf22ig.swift:42:13: note: 'distance' declared here\n   \
    \     let distance = distance(planet: planet1, otherPlanet: planet2)\n       \
    \     ^\n/tmp/tmpdnpf22ig.swift:34:28: error: use of local variable 'distance'\
    \ before its declaration\n            let distance = distance(planet: planet,\
    \ otherPlanet: otherPlanet)\n                           ^\n/tmp/tmpdnpf22ig.swift:34:17:\
    \ note: 'distance' declared here\n            let distance = distance(planet:\
    \ planet, otherPlanet: otherPlanet)\n                ^\n"
  stdout: ''
  timestamp: 1659823231
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    var planets = [String]()\n\
    \    \n    if planet1 == planet2 {\n        return planets\n    }\n    \n    if\
    \ planet1 == \"Mercury\" || planet1 == \"Venus\" || planet1 == \"Earth\" || planet1\
    \ == \"Mars\" || planet1 == \"Jupiter\" || planet1 == \"Saturn\" || planet1 ==\
    \ \"Uranus\" || planet1 == \"Neptune\" {\n        planets.append(planet1)\n  \
    \  }\n    \n    if planet2 == \"Mercury\" || planet2 == \"Venus\" || planet2 ==\
    \ \"Earth\" || planet2 == \"Mars\" || planet2 == \"Jupiter\" || planet2 == \"\
    Saturn\" || planet2 == \"Uranus\" || planet2 == \"Neptune\" {\n        planets.append(planet2)\n\
    \    }\n    \n    if planet1 == \"Mercury\" && planet2 == \"Venus\" {\n      \
    \  planets.append(planet1)\n        planets.append(planet2)\n    }\n    \n   \
    \ if planet1 == \"Venus\" && planet2 == \"Mercury\" {\n        planets.append(planet1)\n\
    \        planets.append(planet2)\n    }\n    \n    if planet1 == \"Earth\" &&\
    \ planet2 == \"Mars\" {\n        planets.append(planet1)\n        planets.append(planet2)\n\
    \    }\n    \n    if planet1 == \"Mars\" && planet2 == \"Earth\" {\n        planets.append(planet1)\n\
    \        planets.append(planet2)\n    }\n    \n    if planet1 == \"Jupiter\" &&\
    \ planet2 == \"Saturn\" {\n        planets.append(planet1)\n        planets.append(planet2)\n\
    \    }\n    \n    if planet1 == \"Saturn\" && planet2 == \"Jupiter\" {\n     \
    \   planets.append(planet1)\n        planets.append(planet2)\n    }\n    \n  \
    \  if planet1 == \"Uranus\" && planet2 == \"Neptune\" {\n        planets.append(planet1)\n\
    \        planets.append(planet2)\n    }\n    \n    if planet1 == \"Neptune\" &&\
    \ planet2 == \"Uranus\" {\n        planets.append(planet1)\n        planets.append(planet2)\n\
    \    }\n    \n    if planet1 == \"Mercury\" && planet2 == \"Earth\" {\n      \
    \  planets.append(planet1)\n        planets.append(planet2)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\") == [\"\
    Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\") ==\
    \ [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"Venus\"\
    , \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"Neptune\"\
    , planet2: \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    ])\nassert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Makemake\") == [] as [String])"
  status: SyntaxError
  stderr: "/tmp/tmpbb3b92n7.swift:94:70: error: expected '}' at end of brace statement\n\
    assert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") == [] as [String])\n  \
    \                                                                   ^\n/tmp/tmpbb3b92n7.swift:15:55:\
    \ note: to match this opening '{'\nfunc bf(planet1: String, planet2: String) ->\
    \ [String] {\n                                                      ^\n/tmp/tmpbb3b92n7.swift:76:6:\
    \ error: operator functions can only be declared at global or in type scope\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1659823230
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    var planets = [String]()\n\
    \    \n    // TODO: Write your code here\n    \n    return planets\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\"\
    ) == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\"\
    ) == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"\
    Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\n\
    assert(bf(planet1: \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Makemake\") == [] as [String])"
  status: Exception
  stderr: 'tmpqir0zopy/tmpqir0zopy.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b71b763fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b71b7336b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b71b7336988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b71b73357b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpqir0zopy                        0x00005603381a456b <unavailable> + 5483

    5    libc.so.6                          0x00002b71b782b460 __libc_start_main +
    245

    6    tmpqir0zopy                        0x00005603381a4119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659823230
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    var planets = [String]()\n\
    \    \n    if planet1 == planet2 {\n        return planets\n    }\n    \n    if\
    \ planet1 == \"Mercury\" || planet1 == \"Venus\" || planet1 == \"Earth\" || planet1\
    \ == \"Mars\" || planet1 == \"Jupiter\" || planet1 == \"Saturn\" || planet1 ==\
    \ \"Uranus\" || planet1 == \"Neptune\" {\n        planets.append(planet1)\n  \
    \  }\n    \n    if planet2 == \"Mercury\" || planet2 == \"Venus\" || planet2 ==\
    \ \"Earth\" || planet2 == \"Mars\" || planet2 == \"Jupiter\" || planet2 == \"\
    Saturn\" || planet2 == \"Uranus\" || planet2 == \"Neptune\" {\n        planets.append(planet2)\n\
    \    }\n    \n    if planet1 == \"Mercury\" && planet2 == \"Venus\" {\n      \
    \  planets.append(planet1)\n        planets.append(planet2)\n    }\n    \n   \
    \ if planet1 == \"Venus\" && planet2 == \"Mercury\" {\n        planets.append(planet1)\n\
    \        planets.append(planet2)\n    }\n    \n    if planet1 == \"Earth\" &&\
    \ planet2 == \"Mars\" {\n        planets.append(planet1)\n        planets.append(planet2)\n\
    \    }\n    \n    if planet1 == \"Mars\" && planet2 == \"Earth\" {\n        planets.append(planet1)\n\
    \        planets.append(planet2)\n    }\n    \n    if planet1 == \"Jupiter\" &&\
    \ planet2 == \"Saturn\" {\n        planets.append(planet1)\n        planets.append(planet2)\n\
    \    }\n    \n    if planet1 == \"Saturn\" && planet2 == \"Jupiter\" {\n     \
    \   planets.append(planet1)\n        planets.append(planet2)\n    }\n    \n  \
    \  if planet1 == \"Uranus\" && planet2 == \"Neptune\" {\n        planets.append(planet1)\n\
    \        planets.append(planet2)\n    }\n    \n    if planet1 == \"Neptune\" &&\
    \ planet2 == \"Uranus\" {\n        planets.append(planet1)\n        planets.append(planet2)\n\
    \    }\n    \n    if planet1 == \"Mercury\" && planet2 == \"Earth\" {\n      \
    \  planets.append(planet1)\n        planets.append(planet2)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\") == [\"\
    Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\") ==\
    \ [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"Venus\"\
    , \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"Neptune\"\
    , planet2: \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    ])\nassert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Makemake\") == [] as [String])"
  status: SyntaxError
  stderr: "/tmp/tmpbb3b92n7.swift:94:70: error: expected '}' at end of brace statement\n\
    assert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") == [] as [String])\n  \
    \                                                                   ^\n/tmp/tmpbb3b92n7.swift:15:55:\
    \ note: to match this opening '{'\nfunc bf(planet1: String, planet2: String) ->\
    \ [String] {\n                                                      ^\n/tmp/tmpbb3b92n7.swift:76:6:\
    \ error: operator functions can only be declared at global or in type scope\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1659823230
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    var planets = [String]()\n\
    \    \n    if planet1 == planet2 {\n        return planets\n    }\n    \n    if\
    \ planet1 == \"Sun\" {\n        return planets\n    }\n    \n    if planet2 ==\
    \ \"Sun\" {\n        return planets\n    }\n    \n    if planet1 == \"Mercury\"\
    \ {\n        planets.append(\"Venus\")\n        return planets\n    }\n    \n\
    \    if planet2 == \"Mercury\" {\n        planets.append(\"Venus\")\n        return\
    \ planets\n    }\n    \n    if planet1 == \"Venus\" {\n        planets.append(\"\
    Earth\")\n        return planets\n    }\n    \n    if planet2 == \"Venus\" {\n\
    \        planets.append(\"Earth\")\n        return planets\n    }\n    \n    if\
    \ planet1 == \"Earth\" {\n        planets.append(\"Mars\")\n        return planets\n\
    \    }\n    \n    if planet2 == \"Earth\" {\n        planets.append(\"Mars\")\n\
    \        return planets\n    }\n    \n    if planet1 == \"Mars\" {\n        planets.append(\"\
    Jupiter\")\n        return planets\n    }\n    \n    if planet2 == \"Mars\" {\n\
    \        planets.append(\"Jupiter\")\n        return planets\n    }\n    \n  \
    \  if planet1 == \"Jupiter\" {\n        planets.append(\"Saturn\")\n        return\
    \ planets\n    }\n    \n    if planet2 == \"Jupiter\" {\n        planets.append(\"\
    Saturn\")\n        return planets\n    }\n    \n    if planet1 == \"Saturn\" {\n\
    \        planets.append(\"Uranus\")\n        return planets\n    }\n    \n   \
    \ if planet2 == \"Saturn\" {\n        planets.append(\"Uranus\")\n        return\
    \ planets\n    }\n    \n    if planet1 == \"Uranus\" {\n        planets.append(\"\
    Neptune\")\n        return planets\n    }\n    \n    if planet2 == \"Uranus\"\
    \ {\n        planets.append(\"Neptune\")\n        return planets\n    }\n    \n\
    \    if planet1 == \"Neptune\" {\n        return planets\n    }\n    \n    if\
    \ planet2 == \"Neptune\" {\n        return planets\n    }\n    \n    return planets\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\"\
    ) == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\"\
    ) == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"\
    Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\n\
    assert(bf(planet1: \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Makemake\") == [] as [String])"
  status: Exception
  stderr: 'tmp6yicsb8f/tmp6yicsb8f.swift:124: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b2d52127c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b2d51e1eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b2d51e1e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b2d51e1d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp6yicsb8f                        0x000055c52a2c562b <unavailable> + 5675

    5    libc.so.6                          0x00002b2d52313460 __libc_start_main +
    245

    6    tmp6yicsb8f                        0x000055c52a2c51d9 <unavailable> + 4569

    '
  stdout: ''
  timestamp: 1659823231
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    \n    // TODO: Write\
    \ your code here\n    \n    return []\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(bf(planet1: \"Jupiter\", planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"\
    ])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1:\
    \ \"Mercury\", planet2: \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"])\nassert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2:\
    \ \"Earth\") == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\"\
    ) == [] as [String])"
  status: Exception
  stderr: 'tmpbyjxxbwz/tmpbyjxxbwz.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b81eae97c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b81eab8eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b81eab8e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b81eab8d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpbyjxxbwz                        0x000055fa1b6d651b <unavailable> + 5403

    5    libc.so.6                          0x00002b81eb083460 __libc_start_main +
    245

    6    tmpbyjxxbwz                        0x000055fa1b6d60c9 <unavailable> + 4297

    '
  stdout: ''
  timestamp: 1659823230
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    var result: [String]\
    \ = []\n    \n    if planet1 == planet2 {\n        return result;\n    }\n   \
    \ \n    let planet1Orbit = orbit(planet1)\n    let planet2Orbit = orbit(planet2)\n\
    \    \n    for planet in planet1Orbit {\n        if planet2Orbit.contains(planet)\
    \ {\n            result.append(planet)\n        }\n    }\n    \n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\"\
    ) == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\"\
    ) == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"\
    Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\n\
    assert(bf(planet1: \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Makemake\") == [] as [String])"
  status: SyntaxError
  stderr: "/tmp/tmpx48wqasa.swift:22:24: error: cannot find 'orbit' in scope\n   \
    \ let planet1Orbit = orbit(planet1)\n                       ^~~~~\n/tmp/tmpx48wqasa.swift:23:24:\
    \ error: cannot find 'orbit' in scope\n    let planet2Orbit = orbit(planet2)\n\
    \                       ^~~~~\n"
  stdout: ''
  timestamp: 1659823231
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    \n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\") == [\"\
    Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\") ==\
    \ [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"Venus\"\
    , \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"Neptune\"\
    , planet2: \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    ])\nassert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Makemake\") == [] as [String])"
  status: SyntaxError
  stderr: '/tmp/tmp3d9bvts2.swift:17:1: error: missing return in global function expected
    to return ''[String]''

    }

    ^

    '
  stdout: ''
  timestamp: 1659823230
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    var result: [String]\
    \ = []\n    \n    if planet1 == planet2 {\n        return result\n    }\n    \n\
    \    if planet1 == \"Mercury\" || planet1 == \"Venus\" || planet1 == \"Earth\"\
    \ || planet1 == \"Mars\" || planet1 == \"Jupiter\" || planet1 == \"Saturn\" ||\
    \ planet1 == \"Uranus\" || planet1 == \"Neptune\" {\n        let planet1Orbit\
    \ = orbit(planet1)\n        let planet2Orbit = orbit(planet2)\n        \n    \
    \    if planet1Orbit == planet2Orbit {\n            return result\n        }\n\
    \        \n        let planet1OrbitDistance = distance(planet1Orbit, planet2)\n\
    \        let planet2OrbitDistance = distance(planet2Orbit, planet1)\n        \n\
    \        if planet1OrbitDistance < planet2OrbitDistance {\n            return\
    \ result\n        }\n        \n        return result.sorted{$0.distance < $1.distance}\n\
    \    }\n    \n    return []\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1:\
    \ \"Earth\", planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\"\
    , planet2: \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    ])\nassert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2:\
    \ \"Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\"\
    ) == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: SyntaxError
  stderr: "/tmp/tmpjq0ffwdo.swift:23:28: error: cannot find 'orbit' in scope\n   \
    \     let planet1Orbit = orbit(planet1)\n                           ^~~~~\n/tmp/tmpjq0ffwdo.swift:24:28:\
    \ error: cannot find 'orbit' in scope\n        let planet2Orbit = orbit(planet2)\n\
    \                           ^~~~~\n/tmp/tmpjq0ffwdo.swift:30:36: error: cannot\
    \ find 'distance' in scope\n        let planet1OrbitDistance = distance(planet1Orbit,\
    \ planet2)\n                                   ^~~~~~~~\n/tmp/tmpjq0ffwdo.swift:31:36:\
    \ error: cannot find 'distance' in scope\n        let planet2OrbitDistance = distance(planet2Orbit,\
    \ planet1)\n                                   ^~~~~~~~\n/tmp/tmpjq0ffwdo.swift:37:42:\
    \ error: type '(String.Index, String.Index) -> Int' cannot conform to 'Comparable'\n\
    \        return result.sorted{$0.distance < $1.distance}\n                   \
    \                      ^\n/tmp/tmpjq0ffwdo.swift:37:42: note: only concrete types\
    \ such as structs, enums and classes can conform to protocols\n        return\
    \ result.sorted{$0.distance < $1.distance}\n                                 \
    \        ^\n/tmp/tmpjq0ffwdo.swift:37:42: note: required by referencing operator\
    \ function '<' on 'Comparable' where 'Self' = '(String.Index, String.Index) ->\
    \ Int'\n        return result.sorted{$0.distance < $1.distance}\n            \
    \                             ^\n"
  stdout: ''
  timestamp: 1659823231
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    \n    var result:\
    \ [String] = []\n    \n    if planet1 == planet2 {\n        result.append(planet1)\n\
    \        return result\n    }\n    \n    if planet1 == \"Sun\" {\n        result.append(planet2)\n\
    \        return result\n    }\n    \n    if planet2 == \"Sun\" {\n        result.append(planet1)\n\
    \        return result\n    }\n    \n    if planet1 == \"Mercury\" {\n       \
    \ if planet2 == \"Venus\" {\n            result.append(planet1)\n            result.append(planet2)\n\
    \            return result\n        }\n    }\n    \n    if planet2 == \"Mercury\"\
    \ {\n        if planet1 == \"Venus\" {\n            result.append(planet1)\n \
    \           result.append(planet2)\n            return result\n        }\n   \
    \ }\n    \n    if planet1 == \"Earth\" {\n        if planet2 == \"Mars\" {\n \
    \           result.append(planet1)\n            result.append(planet2)\n     \
    \       return result\n        }\n    }\n    \n    if planet2 == \"Earth\" {\n\
    \        if planet1 == \"Mars\" {\n            result.append(planet1)\n      \
    \      result.append(planet2)\n            return result\n        }\n    }\n \
    \   \n    if planet1 == \"Mars\" {\n        if planet2 == \"Jupiter\" {\n    \
    \        result.append(planet1)\n            result.append(planet2)\n        \
    \    return result\n        }\n    }\n    \n    if planet2 == \"Mars\" {\n   \
    \     if planet1 == \"Jupiter\" {\n            result.append(planet1)\n      \
    \      result.append(planet2)\n            return result\n        }\n    }\n \
    \   \n    if planet1 == \"Jupiter\" {\n        if planet2 == \"Saturn\" {\n  \
    \          result.append(planet1)\n            result.append(planet2)\n      \
    \      return result\n        }\n    }\n    \n    if planet2 == \"Jupiter\" {\n\
    \        if planet1 == \"Saturn\" {\n            result.append(planet1)\n    \
    \        result.append(planet2)\n            return result\n        }\n    }\n\
    \    \n    if planet1 == \"Saturn\" {\n        if planet2 == \"Uranus\" {\n  \
    \          result.append(planet1)\n            result.append(planet2)\n      \
    \      return result\n        }\n    }\n    \n    if planet2 == \"Saturn\" {\n\
    \        if planet1 == \"Uranus\" {\n            result.append(planet1)\n    \
    \        result.append(planet2)\n            return result\n        }\n    }\n\
    \    \n    if planet1 == \"Uranus\" {\n        if planet2 == \"Neptune\" {\n \
    \           result.append(planet1)\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(bf(planet1: \"Jupiter\", planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"\
    ])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1:\
    \ \"Mercury\", planet2: \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"])\nassert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2:\
    \ \"Earth\") == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\"\
    ) == [] as [String])"
  status: SyntaxError
  stderr: "/tmp/tmppc2_rmqz.swift:138:70: error: expected '}' at end of brace statement\n\
    assert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") == [] as [String])\n  \
    \                                                                   ^\n/tmp/tmppc2_rmqz.swift:114:28:\
    \ note: to match this opening '{'\n    if planet1 == \"Uranus\" {\n          \
    \                 ^\n/tmp/tmppc2_rmqz.swift:138:70: error: expected '}' at end\
    \ of brace statement\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])\n                                                          \
    \           ^\n/tmp/tmppc2_rmqz.swift:15:55: note: to match this opening '{'\n\
    func bf(planet1: String, planet2: String) -> [String] {\n                    \
    \                                  ^\n/tmp/tmppc2_rmqz.swift:120:6: error: operator\
    \ functions can only be declared at global or in type scope\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1659823231
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    var planets = [String]()\n\
    \    \n    if planet1 == planet2 {\n        return planets\n    }\n    \n    if\
    \ planet1 == \"Mercury\" {\n        planets.append(\"Venus\")\n    }\n    \n \
    \   if planet1 == \"Venus\" {\n        planets.append(\"Earth\")\n    }\n    \n\
    \    if planet1 == \"Earth\" {\n        planets.append(\"Mars\")\n    }\n    \n\
    \    if planet1 == \"Mars\" {\n        planets.append(\"Jupiter\")\n    }\n  \
    \  \n    if planet1 == \"Jupiter\" {\n        planets.append(\"Saturn\")\n   \
    \ }\n    \n    if planet1 == \"Saturn\" {\n        planets.append(\"Uranus\")\n\
    \    }\n    \n    if planet1 == \"Uranus\" {\n        planets.append(\"Neptune\"\
    )\n    }\n    \n    if planet1 == \"Neptune\" {\n        planets.append(\"Mercury\"\
    )\n    }\n    \n    if planet2 == \"Mercury\" {\n        planets.append(\"Venus\"\
    )\n    }\n    \n    if planet2 == \"Venus\" {\n        planets.append(\"Earth\"\
    )\n    }\n    \n    if planet2 == \"Earth\" {\n        planets.append(\"Mars\"\
    )\n    }\n    \n    if planet2 == \"Mars\" {\n        planets.append(\"Jupiter\"\
    )\n    }\n    \n    if planet2 == \"Jupiter\" {\n        planets.append(\"Saturn\"\
    )\n    }\n    \n    if planet2 == \"Saturn\" {\n        planets.append(\"Uranus\"\
    )\n    }\n    \n    if planet2 == \"Uranus\" {\n        planets.append(\"Neptune\"\
    )\n    }\n    \n    if planet2 == \"Neptune\" {\n        planets.append(\"Mercury\"\
    )\n    }\n    \n    return planets\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(bf(planet1: \"Jupiter\", planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"\
    ])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1:\
    \ \"Mercury\", planet2: \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"])\nassert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2:\
    \ \"Earth\") == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\"\
    ) == [] as [String])"
  status: Exception
  stderr: 'tmp01j43xsq/tmp01j43xsq.swift:102: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae180e98c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae180b8fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae180b8f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae180b8e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp01j43xsq                        0x0000557927d3362b <unavailable> + 5675

    5    libc.so.6                          0x00002ae181084460 __libc_start_main +
    245

    6    tmp01j43xsq                        0x0000557927d331d9 <unavailable> + 4569

    '
  stdout: ''
  timestamp: 1659823230
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    var planets = [String]()\n\
    \    \n    if planet1 == planet2 {\n        return planets\n    }\n    \n    if\
    \ planet1 == \"Mercury\" || planet1 == \"Venus\" || planet1 == \"Earth\" || planet1\
    \ == \"Mars\" || planet1 == \"Jupiter\" || planet1 == \"Saturn\" || planet1 ==\
    \ \"Uranus\" || planet1 == \"Neptune\" {\n        planets.append(planet1)\n  \
    \  }\n    \n    if planet2 == \"Mercury\" || planet2 == \"Venus\" || planet2 ==\
    \ \"Earth\" || planet2 == \"Mars\" || planet2 == \"Jupiter\" || planet2 == \"\
    Saturn\" || planet2 == \"Uranus\" || planet2 == \"Neptune\" {\n        planets.append(planet2)\n\
    \    }\n    \n    if planet1 == \"Mercury\" || planet1 == \"Venus\" || planet1\
    \ == \"Earth\" || planet1 == \"Mars\" || planet1 == \"Jupiter\" || planet1 ==\
    \ \"Saturn\" || planet1 == \"Uranus\" || planet1 == \"Neptune\" {\n        planets.append(planet2)\n\
    \    }\n    \n    if planet2 == \"Mercury\" || planet2 == \"Venus\" || planet2\
    \ == \"Earth\" || planet2 == \"Mars\" || planet2 == \"Jupiter\" || planet2 ==\
    \ \"Saturn\" || planet2 == \"Uranus\" || planet2 == \"Neptune\" {\n        planets.append(planet1)\n\
    \    }\n    \n    if planet1 == \"Mercury\" || planet1 == \"Venus\" || planet1\
    \ == \"Earth\" || planet1 == \"Mars\" || planet1 == \"Jupiter\" || planet1 ==\
    \ \"Saturn\" || planet1 == \"Uranus\" || planet1 == \"Neptune\" {\n        planets.append(planet2)\n\
    \    }\n    \n    if planet2 == \"Mercury\" || planet2 == \"Venus\" || planet2\
    \ == \"Earth\" || planet2 == \"Mars\" || planet2 == \"Jupiter\" || planet2 ==\
    \ \"Saturn\" || planet2 == \"Uranus\" || planet2 == \"Neptune\" {\n        planets.append(planet1)\n\
    \    }\n    \n    if planet1 == \"Mercury\" || planet1 == \"Venus\" || planet1\
    \ == \"Earth\" || planet1 == \"Mars\" || planet1 == \"Jup\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\") == [\"\
    Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\") ==\
    \ [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"Venus\"\
    , \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"Neptune\"\
    , planet2: \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    ])\nassert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Makemake\") == [] as [String])"
  status: SyntaxError
  stderr: "/tmp/tmp4i4zkkv1.swift:46:108: error: unterminated string literal\n   \
    \ if planet1 == \"Mercury\" || planet1 == \"Venus\" || planet1 == \"Earth\" ||\
    \ planet1 == \"Mars\" || planet1 == \"Jup\n                                  \
    \                                                                         ^\n"
  stdout: ''
  timestamp: 1659823230
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    var planets = [String]()\n\
    \    \n    if planet1 == planet2 {\n        return planets\n    }\n    \n    if\
    \ planet1 == \"Mercury\" {\n        planets = [\"Venus\"]\n    } else if planet1\
    \ == \"Venus\" {\n        planets = [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\", \"Neptune\"]\n    } else if planet1 == \"Earth\" {\n        planets\
    \ = [\"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"]\n    } else if\
    \ planet1 == \"Mars\" {\n        planets = [\"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    } else if planet1 == \"Jupiter\" {\n        planets = [\"\
    Saturn\", \"Uranus\", \"Neptune\"]\n    } else if planet1 == \"Saturn\" {\n  \
    \      planets = [\"Uranus\", \"Neptune\"]\n    } else if planet1 == \"Uranus\"\
    \ {\n        planets = [\"Neptune\"]\n    } else if planet1 == \"Neptune\" {\n\
    \        planets = [\"Mercury\", \"Venus\"]\n    }\n    \n    if planet2 == \"\
    Mercury\" {\n        planets = [\"Venus\"]\n    } else if planet2 == \"Venus\"\
    \ {\n        planets = [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    } else if planet2 == \"Earth\" {\n        planets = [\"Mars\"\
    , \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"]\n    } else if planet2 ==\
    \ \"Mars\" {\n        planets = [\"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    ]\n    } else if planet2 == \"Jupiter\" {\n        planets = [\"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    } else if planet2 == \"Saturn\" {\n        planets = [\"Uranus\"\
    , \"Neptune\"]\n    } else if planet2 == \"Uranus\" {\n        planets = [\"Neptune\"\
    ]\n    } else if planet2 == \"Neptune\" {\n        planets = [\"Mercury\", \"\
    Venus\"]\n    }\n    \n    return planets\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\") == [\"Saturn\", \"\
    Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\") == [\"Venus\"\
    ])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"Neptune\", planet2:\
    \ \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"])\n\
    assert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Makemake\") == [] as [String])"
  status: Exception
  stderr: 'tmp8grfsni8/tmp8grfsni8.swift:74: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002afa8fef2c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002afa8fbe9b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002afa8fbe9988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002afa8fbe87b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp8grfsni8                        0x0000557d9c5345cb <unavailable> + 5579

    5    libc.so.6                          0x00002afa900de460 __libc_start_main +
    245

    6    tmp8grfsni8                        0x0000557d9c534179 <unavailable> + 4473

    '
  stdout: ''
  timestamp: 1659823230
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    var result: [String]\
    \ = []\n    \n    if planet1 == \"Mercury\" && planet2 == \"Earth\" {\n      \
    \  result = [planet1, planet2]\n    } else if planet1 == \"Mercury\" && planet2\
    \ == \"Venus\" {\n        result = [planet1, planet2]\n    } else if planet1 ==\
    \ \"Mercury\" && planet2 == \"Mars\" {\n        result = [planet1, planet2]\n\
    \    } else if planet1 == \"Mercury\" && planet2 == \"Jupiter\" {\n        result\
    \ = [planet1, planet2]\n    } else if planet1 == \"Mercury\" && planet2 == \"\
    Saturn\" {\n        result = [planet1, planet2]\n    } else if planet1 == \"Mercury\"\
    \ && planet2 == \"Uranus\" {\n        result = [planet1, planet2]\n    } else\
    \ if planet1 == \"Mercury\" && planet2 == \"Neptune\" {\n        result = [planet1,\
    \ planet2]\n    } else if planet1 == \"Venus\" && planet2 == \"Earth\" {\n   \
    \     result = [planet1, planet2]\n    } else if planet1 == \"Venus\" && planet2\
    \ == \"Mercury\" {\n        result = [planet1, planet2]\n    } else if planet1\
    \ == \"Venus\" && planet2 == \"Mars\" {\n        result = [planet1, planet2]\n\
    \    } else if planet1 == \"Venus\" && planet2 == \"Jupiter\" {\n        result\
    \ = [planet1, planet2]\n    } else if planet1 == \"Venus\" && planet2 == \"Saturn\"\
    \ {\n        result = [planet1, planet2]\n    } else if planet1 == \"Venus\" &&\
    \ planet2 == \"Uranus\" {\n        result = [planet1, planet2]\n    } else if\
    \ planet1 == \"Venus\" && planet2 == \"Neptune\" {\n        result = [planet1,\
    \ planet2]\n    } else if planet1 == \"Mars\" && planet2 == \"Earth\" {\n    \
    \    result = [planet1, planet2]\n    } else if planet1 == \"Mars\" && planet2\
    \ == \"Mercury\" {\n        result = [planet1, planet2]\n    } else if planet1\
    \ == \"Mars\" && planet2 == \"Venus\" {\n        result = [planet1, planet2]\n\
    \    } else if planet1 == \"Mars\" && planet2 == \"Jupiter\" \n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\") == [\"\
    Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\") ==\
    \ [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"Venus\"\
    , \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"Neptune\"\
    , planet2: \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    ])\nassert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Makemake\") == [] as [String])"
  status: SyntaxError
  stderr: "/tmp/tmpovvyyrrb.swift:52:56: error: expected '{' after 'if' condition\n\
    \    } else if planet1 == \"Mars\" && planet2 == \"Jupiter\" \n              \
    \                                         ^\n/tmp/tmpovvyyrrb.swift:16:9: warning:\
    \ variable 'result' was written to, but never read\n    var result: [String] =\
    \ []\n        ^\n"
  stdout: ''
  timestamp: 1659823231
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    var planets = [String]()\n\
    \    \n    // TODO: Write your code here\n    \n    return planets\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\"\
    ) == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\"\
    ) == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"\
    Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\n\
    assert(bf(planet1: \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Makemake\") == [] as [String])"
  status: Exception
  stderr: 'tmpqir0zopy/tmpqir0zopy.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b71b763fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b71b7336b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b71b7336988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b71b73357b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpqir0zopy                        0x00005603381a456b <unavailable> + 5483

    5    libc.so.6                          0x00002b71b782b460 __libc_start_main +
    245

    6    tmpqir0zopy                        0x00005603381a4119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659823230
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    var result = [String]()\n\
    \    \n    if planet1 == planet2 {\n        return result;\n    }\n    \n    let\
    \ planet1Orbit = orbit(planet1)\n    let planet2Orbit = orbit(planet2)\n    \n\
    \    if planet1Orbit == planet2Orbit {\n        return result;\n    }\n    \n\
    \    let planet1Sun = sunOrbit(planet1)\n    let planet2Sun = sunOrbit(planet2)\n\
    \    \n    if planet1Sun == planet2Sun {\n        return result;\n    }\n    \n\
    \    let planet1SunDistance = distance(planet1, planet2)\n    let planet2SunDistance\
    \ = distance(planet2, planet1)\n    \n    if planet1SunDistance < planet2SunDistance\
    \ {\n        let closestPlanet = planet1\n        let closestPlanetOrbit = planet1Orbit\n\
    \    } else {\n        let closestPlanet = planet2\n        let closestPlanetOrbit\
    \ = planet2Orbit\n    }\n    \n    let closestPlanetSun = sunOrbit(closestPlanet)\n\
    \    \n    if closestPlanetSun == closestPlanetOrbit {\n        return result;\n\
    \    }\n    \n    let closestPlanetSunDistance = distance(closestPlanet, planet1)\n\
    \    let closestPlanetOrbitDistance = distance(closestPlanetOrbit, planet1)\n\
    \    \n    if closestPlanetSunDistance < closestPlanetOrbitDistance {\n      \
    \  let closestPlanetOrbit = closestPlanetOrbit\n        let closestPlanetSun =\
    \ closestPlanetSun\n    } else {\n        let closestPlanetOrbit = closestPlanetOrbit\n\
    \        let closestPlanetSun = closestPlanetSun\n    }\n    \n    let closestPlanetOrbitDistance\
    \ = distance(closestPlanetOrbit, planet2)\n    let closestPlanetSunDistance =\
    \ distance(closestPlanetSun, planet2)\n    \n    if closestPlanetOrbitDistance\
    \ < closestPlanetSunDistance {\n        let closestPlanetSun = closestPlanetSun\n\
    \        let closestPlanetOrbit = closestPlanetOrbit\n    } else {\n        let\
    \ closestPlanetSun = closestPlanetSun\n        let closestPlanetOrbit = closestPlanetOrbit\n\
    \    }\n    \n    if closestPlanetOrbit == closestPlanetSun {\n        return\
    \ result;\n    }\n    \n    let closestPlanetOrbitDistance = distance(closestPlanetOrbit,\
    \ planet2)\n    let closestPlanetSun\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(bf(planet1: \"Jupiter\", planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"\
    ])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1:\
    \ \"Mercury\", planet2: \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"])\nassert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2:\
    \ \"Earth\") == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\"\
    ) == [] as [String])"
  status: SyntaxError
  stderr: "/tmp/tmp_3z7w6u9.swift:22:24: error: cannot find 'orbit' in scope\n   \
    \ let planet1Orbit = orbit(planet1)\n                       ^~~~~\n/tmp/tmp_3z7w6u9.swift:23:24:\
    \ error: cannot find 'orbit' in scope\n    let planet2Orbit = orbit(planet2)\n\
    \                       ^~~~~\n/tmp/tmp_3z7w6u9.swift:29:22: error: cannot find\
    \ 'sunOrbit' in scope\n    let planet1Sun = sunOrbit(planet1)\n              \
    \       ^~~~~~~~\n/tmp/tmp_3z7w6u9.swift:30:22: error: cannot find 'sunOrbit'\
    \ in scope\n    let planet2Sun = sunOrbit(planet2)\n                     ^~~~~~~~\n\
    /tmp/tmp_3z7w6u9.swift:36:30: error: cannot find 'distance' in scope\n    let\
    \ planet1SunDistance = distance(planet1, planet2)\n                          \
    \   ^~~~~~~~\n/tmp/tmp_3z7w6u9.swift:37:30: error: cannot find 'distance' in scope\n\
    \    let planet2SunDistance = distance(planet2, planet1)\n                   \
    \          ^~~~~~~~\n/tmp/tmp_3z7w6u9.swift:47:28: error: cannot find 'sunOrbit'\
    \ in scope\n    let closestPlanetSun = sunOrbit(closestPlanet)\n             \
    \              ^~~~~~~~\n/tmp/tmp_3z7w6u9.swift:47:37: error: cannot find 'closestPlanet'\
    \ in scope\n    let closestPlanetSun = sunOrbit(closestPlanet)\n             \
    \                       ^~~~~~~~~~~~~\n/tmp/tmp_3z7w6u9.swift:49:28: error: cannot\
    \ find 'closestPlanetOrbit' in scope\n    if closestPlanetSun == closestPlanetOrbit\
    \ {\n                           ^~~~~~~~~~~~~~~~~~\n/tmp/tmp_3z7w6u9.swift:53:36:\
    \ error: cannot find 'distance' in scope\n    let closestPlanetSunDistance = distance(closestPlanet,\
    \ planet1)\n                                   ^~~~~~~~\n/tmp/tmp_3z7w6u9.swift:53:45:\
    \ error: cannot find 'closestPlanet' in scope\n    let closestPlanetSunDistance\
    \ = distance(closestPlanet, planet1)\n                                       \
    \     ^~~~~~~~~~~~~\n/tmp/tmp_3z7w6u9.swift:54:38: error: cannot find 'distance'\
    \ in scope\n    let closestPlanetOrbitDistance = distance(closestPlanetOrbit,\
    \ planet1)\n                                     ^~~~~~~~\n/tmp/tmp_3z7w6u9.swift:54:47:\
    \ error: cannot find 'closestPlanetOrbit' in scope\n    let closestPlanetOrbit"
  stdout: ''
  timestamp: 1659823231
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    var planets = [String]()\n\
    \    \n    // TODO: Write your code here\n    \n    return planets\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\"\
    ) == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\"\
    ) == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"\
    Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\n\
    assert(bf(planet1: \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Makemake\") == [] as [String])"
  status: Exception
  stderr: 'tmpqir0zopy/tmpqir0zopy.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b71b763fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b71b7336b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b71b7336988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b71b73357b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpqir0zopy                        0x00005603381a456b <unavailable> + 5483

    5    libc.so.6                          0x00002b71b782b460 __libc_start_main +
    245

    6    tmpqir0zopy                        0x00005603381a4119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659823230
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    var planets = [String]()\n\
    \    \n    if planet1 == planet2 {\n        return planets\n    }\n    \n    if\
    \ planet1 == \"Mercury\" || planet1 == \"Venus\" || planet1 == \"Earth\" || planet1\
    \ == \"Mars\" || planet1 == \"Jupiter\" || planet1 == \"Saturn\" || planet1 ==\
    \ \"Uranus\" || planet1 == \"Neptune\" {\n        planets.append(planet1)\n  \
    \  }\n    \n    if planet2 == \"Mercury\" || planet2 == \"Venus\" || planet2 ==\
    \ \"Earth\" || planet2 == \"Mars\" || planet2 == \"Jupiter\" || planet2 == \"\
    Saturn\" || planet2 == \"Uranus\" || planet2 == \"Neptune\" {\n        planets.append(planet2)\n\
    \    }\n    \n    if planet1 == \"Mercury\" && planet2 == \"Venus\" {\n      \
    \  planets.append(planet1)\n        planets.append(planet2)\n    }\n    \n   \
    \ if planet1 == \"Venus\" && planet2 == \"Mercury\" {\n        planets.append(planet1)\n\
    \        planets.append(planet2)\n    }\n    \n    if planet1 == \"Earth\" &&\
    \ planet2 == \"Mars\" {\n        planets.append(planet1)\n        planets.append(planet2)\n\
    \    }\n    \n    if planet1 == \"Mars\" && planet2 == \"Earth\" {\n        planets.append(planet1)\n\
    \        planets.append(planet2)\n    }\n    \n    if planet1 == \"Jupiter\" &&\
    \ planet2 == \"Saturn\" {\n        planets.append(planet1)\n        planets.append(planet2)\n\
    \    }\n    \n    if planet1 == \"Saturn\" && planet2 == \"Jupiter\" {\n     \
    \   planets.append(planet1)\n        planets.append(planet2)\n    }\n    \n  \
    \  if planet1 == \"Uranus\" && planet2 == \"Neptune\" {\n        planets.append(planet1)\n\
    \        planets.append(planet2)\n    }\n    \n    if planet1 == \"Neptune\" &&\
    \ planet2 == \"Uranus\" {\n        planets.append(planet1)\n        planets.append(planet2)\n\
    \    }\n    \n    if planet1 == \"Mercury\" && planet2 == \"Earth\" {\n      \
    \  planets.append(planet1)\n        planets.append(planet2)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\") == [\"\
    Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\") ==\
    \ [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"Venus\"\
    , \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"Neptune\"\
    , planet2: \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    ])\nassert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Makemake\") == [] as [String])"
  status: SyntaxError
  stderr: "/tmp/tmpbb3b92n7.swift:94:70: error: expected '}' at end of brace statement\n\
    assert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") == [] as [String])\n  \
    \                                                                   ^\n/tmp/tmpbb3b92n7.swift:15:55:\
    \ note: to match this opening '{'\nfunc bf(planet1: String, planet2: String) ->\
    \ [String] {\n                                                      ^\n/tmp/tmpbb3b92n7.swift:76:6:\
    \ error: operator functions can only be declared at global or in type scope\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1659823230
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    var planets = [String]()\n\
    \    \n    if planet1 == planet2 {\n        return planets\n    }\n    \n    if\
    \ planet1 == \"Mercury\" || planet1 == \"Venus\" || planet1 == \"Earth\" || planet1\
    \ == \"Mars\" || planet1 == \"Jupiter\" || planet1 == \"Saturn\" || planet1 ==\
    \ \"Uranus\" || planet1 == \"Neptune\" {\n        planets.append(planet1)\n  \
    \  }\n    \n    if planet2 == \"Mercury\" || planet2 == \"Venus\" || planet2 ==\
    \ \"Earth\" || planet2 == \"Mars\" || planet2 == \"Jupiter\" || planet2 == \"\
    Saturn\" || planet2 == \"Uranus\" || planet2 == \"Neptune\" {\n        planets.append(planet2)\n\
    \    }\n    \n    if planet1 == \"Mercury\" && planet2 == \"Venus\" {\n      \
    \  planets.append(planet1)\n        planets.append(planet2)\n    }\n    \n   \
    \ if planet1 == \"Venus\" && planet2 == \"Mercury\" {\n        planets.append(planet1)\n\
    \        planets.append(planet2)\n    }\n    \n    if planet1 == \"Earth\" &&\
    \ planet2 == \"Mercury\" {\n        planets.append(planet1)\n        planets.append(planet2)\n\
    \    }\n    \n    if planet1 == \"Mars\" && planet2 == \"Mercury\" {\n       \
    \ planets.append(planet1)\n        planets.append(planet2)\n    }\n    \n    if\
    \ planet1 == \"Jupiter\" && planet2 == \"Mercury\" {\n        planets.append(planet1)\n\
    \        planets.append(planet2)\n    }\n    \n    if planet1 == \"Saturn\" &&\
    \ planet2 == \"Mercury\" {\n        planets.append(planet1)\n        planets.append(planet2)\n\
    \    }\n    \n    if planet1 == \"Uranus\" && planet2 == \"Mercury\" {\n     \
    \   planets.append(planet1)\n        planets.append(planet2)\n    }\n    \n  \
    \  if planet1 == \"Neptune\" && planet2 == \"Mercury\" {\n        planets.append(planet1)\n\
    \        planets.append(planet2)\n    }\n    \n    if planet1 == \"Mercury\" &&\
    \ planet2 == \"Earth\" {\n        planets.append(planet1)\n        planet\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\"\
    ) == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\"\
    ) == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"\
    Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\n\
    assert(bf(planet1: \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Makemake\") == [] as [String])"
  status: SyntaxError
  stderr: "/tmp/tmpecbl596z.swift:94:70: error: expected '}' at end of brace statement\n\
    assert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") == [] as [String])\n  \
    \                                                                   ^\n/tmp/tmpecbl596z.swift:15:55:\
    \ note: to match this opening '{'\nfunc bf(planet1: String, planet2: String) ->\
    \ [String] {\n                                                      ^\n/tmp/tmpecbl596z.swift:72:9:\
    \ error: cannot find 'planet' in scope\n        planet\n        ^~~~~~\n/tmp/tmpecbl596z.swift:76:6:\
    \ error: operator functions can only be declared at global or in type scope\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1659823230
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    var planets = [String]()\n\
    \    \n    if planet1 == planet2 {\n        return planets\n    }\n    \n    if\
    \ planet1 == \"Mercury\" {\n        planets.append(\"Venus\")\n    }\n    \n \
    \   if planet1 == \"Venus\" {\n        planets.append(\"Earth\")\n    }\n    \n\
    \    if planet1 == \"Earth\" {\n        planets.append(\"Mars\")\n    }\n    \n\
    \    if planet1 == \"Mars\" {\n        planets.append(\"Jupiter\")\n    }\n  \
    \  \n    if planet1 == \"Jupiter\" {\n        planets.append(\"Saturn\")\n   \
    \ }\n    \n    if planet1 == \"Saturn\" {\n        planets.append(\"Uranus\")\n\
    \    }\n    \n    if planet1 == \"Uranus\" {\n        planets.append(\"Neptune\"\
    )\n    }\n    \n    if planet1 == \"Neptune\" {\n        planets.append(\"Mercury\"\
    )\n    }\n    \n    if planet2 == \"Mercury\" {\n        planets.append(\"Venus\"\
    )\n    }\n    \n    if planet2 == \"Venus\" {\n        planets.append(\"Earth\"\
    )\n    }\n    \n    if planet2 == \"Earth\" {\n        planets.append(\"Mars\"\
    )\n    }\n    \n    if planet2 == \"Mars\" {\n        planets.append(\"Jupiter\"\
    )\n    }\n    \n    if planet2 == \"Jupiter\" {\n        planets.append(\"Saturn\"\
    )\n    }\n    \n    if planet2 == \"Saturn\" {\n        planets.append(\"Uranus\"\
    )\n    }\n    \n    if planet2 == \"Uranus\" {\n        planets.append(\"Neptune\"\
    )\n    }\n    \n    if planet2 == \"Neptune\" {\n        planets.append(\"Mercury\"\
    )\n    }\n    \n    return planets\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(bf(planet1: \"Jupiter\", planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"\
    ])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1:\
    \ \"Mercury\", planet2: \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"])\nassert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2:\
    \ \"Earth\") == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\"\
    ) == [] as [String])"
  status: Exception
  stderr: 'tmp01j43xsq/tmp01j43xsq.swift:102: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae180e98c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae180b8fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae180b8f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae180b8e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp01j43xsq                        0x0000557927d3362b <unavailable> + 5675

    5    libc.so.6                          0x00002ae181084460 __libc_start_main +
    245

    6    tmp01j43xsq                        0x0000557927d331d9 <unavailable> + 4569

    '
  stdout: ''
  timestamp: 1659823230
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    \n    var planets\
    \ = [String]()\n    \n    if planet1 == planet2 {\n        return planets\n  \
    \  }\n    \n    if planet1 == \"Mercury\" || planet1 == \"Venus\" || planet1 ==\
    \ \"Earth\" || planet1 == \"Mars\" || planet1 == \"Jupiter\" || planet1 == \"\
    Saturn\" || planet1 == \"Uranus\" || planet1 == \"Neptune\" {\n        planets.append(planet1)\n\
    \    }\n    \n    if planet2 == \"Mercury\" || planet2 == \"Venus\" || planet2\
    \ == \"Earth\" || planet2 == \"Mars\" || planet2 == \"Jupiter\" || planet2 ==\
    \ \"Saturn\" || planet2 == \"Uranus\" || planet2 == \"Neptune\" {\n        planets.append(planet2)\n\
    \    }\n    \n    if planet1 == \"Mercury\" && planet2 == \"Venus\" {\n      \
    \  planets.append(planet1)\n        planets.append(planet2)\n    }\n    \n   \
    \ if planet1 == \"Venus\" && planet2 == \"Mercury\" {\n        planets.append(planet1)\n\
    \        planets.append(planet2)\n    }\n    \n    if planet1 == \"Earth\" &&\
    \ planet2 == \"Mercury\" {\n        planets.append(planet1)\n        planets.append(planet2)\n\
    \    }\n    \n    if planet1 == \"Mars\" && planet2 == \"Mercury\" {\n       \
    \ planets.append(planet1)\n        planets.append(planet2)\n    }\n    \n    if\
    \ planet1 == \"Jupiter\" && planet2 == \"Mercury\" {\n        planets.append(planet1)\n\
    \        planets.append(planet2)\n    }\n    \n    if planet1 == \"Saturn\" &&\
    \ planet2 == \"Mercury\" {\n        planets.append(planet1)\n        planets.append(planet2)\n\
    \    }\n    \n    if planet1 == \"Uranus\" && planet2 == \"Mercury\" {\n     \
    \   planets.append(planet1)\n        planets.append(planet2)\n    }\n    \n  \
    \  if planet1 == \"Neptune\" && planet2 == \"Mercury\" {\n        planets.append(planet1)\n\
    \        planets.append(planet2)\n    }\n    \n    if planet1 == \"Mercury\" &&\
    \ planet2 == \"Earth\" {\n        planets.append(planet1)\n        \n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\"\
    ) == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\"\
    ) == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"\
    Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\n\
    assert(bf(planet1: \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Makemake\") == [] as [String])"
  status: SyntaxError
  stderr: "/tmp/tmpkgny6dnt.swift:95:70: error: expected '}' at end of brace statement\n\
    assert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") == [] as [String])\n  \
    \                                                                   ^\n/tmp/tmpkgny6dnt.swift:15:55:\
    \ note: to match this opening '{'\nfunc bf(planet1: String, planet2: String) ->\
    \ [String] {\n                                                      ^\n/tmp/tmpkgny6dnt.swift:77:6:\
    \ error: operator functions can only be declared at global or in type scope\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1659823230
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    var result: [String]\
    \ = []\n    \n    guard let planet1Orbit = planetOrbit(planet1),\n        let\
    \ planet2Orbit = planetOrbit(planet2) else {\n        return result\n    }\n \
    \   \n    let planet1OrbitIndex = index(planet1Orbit)\n    let planet2OrbitIndex\
    \ = index(planet2Orbit)\n    \n    if planet1OrbitIndex < planet2OrbitIndex {\n\
    \        result.insert(planet1, at: planet1OrbitIndex)\n        result.insert(planet2,\
    \ at: planet2OrbitIndex)\n    } else {\n        result.insert(planet2, at: planet1OrbitIndex)\n\
    \        result.insert(planet1, at: planet2OrbitIndex)\n    }\n    \n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2:\
    \ \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\n\
    assert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"\
    Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\")\
    \ == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: SyntaxError
  stderr: "/tmp/tmpqanmxvus.swift:18:30: error: cannot find 'planetOrbit' in scope\n\
    \    guard let planet1Orbit = planetOrbit(planet1),\n                        \
    \     ^~~~~~~~~~~\n/tmp/tmpqanmxvus.swift:19:28: error: cannot find 'planetOrbit'\
    \ in scope\n        let planet2Orbit = planetOrbit(planet2) else {\n         \
    \                  ^~~~~~~~~~~\n/tmp/tmpqanmxvus.swift:23:29: error: cannot find\
    \ 'index' in scope\n    let planet1OrbitIndex = index(planet1Orbit)\n        \
    \                    ^~~~~\n/tmp/tmpqanmxvus.swift:24:29: error: cannot find 'index'\
    \ in scope\n    let planet2OrbitIndex = index(planet2Orbit)\n                \
    \            ^~~~~\n"
  stdout: ''
  timestamp: 1659823231
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    var result = [String]()\n\
    \    \n    if planet1 == planet2 {\n        return result\n    }\n    \n    if\
    \ planet1 == \"Mercury\" || planet1 == \"Venus\" || planet1 == \"Earth\" || planet1\
    \ == \"Mars\" || planet1 == \"Jupiter\" || planet1 == \"Saturn\" || planet1 ==\
    \ \"Uranus\" || planet1 == \"Neptune\" {\n        if planet2 == \"Mercury\" ||\
    \ planet2 == \"Venus\" || planet2 == \"Earth\" || planet2 == \"Mars\" || planet2\
    \ == \"Jupiter\" || planet2 == \"Saturn\" || planet2 == \"Uranus\" || planet2\
    \ == \"Neptune\" {\n            return result\n        }\n    }\n    \n    if\
    \ planet2 == \"Mercury\" || planet2 == \"Venus\" || planet2 == \"Earth\" || planet2\
    \ == \"Mars\" || planet2 == \"Jupiter\" || planet2 == \"Saturn\" || planet2 ==\
    \ \"Uranus\" || planet2 == \"Neptune\" {\n        if planet1 == \"Mercury\" ||\
    \ planet1 == \"Venus\" || planet1 == \"Earth\" || planet1 == \"Mars\" || planet1\
    \ == \"Jupiter\" || planet1 == \"Saturn\" || planet1 == \"Uranus\" || planet1\
    \ == \"Neptune\" {\n            return result\n        }\n    }\n    \n    if\
    \ planet1 == \"Mercury\" || planet1 == \"Venus\" || planet1 == \"Earth\" || planet1\
    \ == \"Mars\" || planet1 == \"Jupiter\" || planet1 == \"Saturn\" || planet1 ==\
    \ \"Uranus\" || planet1 == \"Neptune\" {\n        if planet2 == \"Mercury\" ||\
    \ planet2 == \"Venus\" || planet2 == \"Earth\" || planet2 == \"Mars\" || planet2\
    \ == \"Jupiter\" || planet2 == \"Saturn\" || planet2 == \"Uranus\" || planet2\
    \ == \"Neptune\" {\n            return result\n        }\n    }\n    \n    if\
    \ planet2 == \"Mercury\" || planet2 == \"Venus\" || planet2 == \"Earth\" || planet2\
    \ == \"Mars\" || planet2 == \"Jupiter\" || planet2 == \"Saturn\" || planet2 ==\
    \ \"Uranus\" || planet2 == \"Neptune\" {\n        if planet1 == \"Mercury\" ||\
    \ planet1 == \"Venus\" || planet1 == \"Earth\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\") == [\"Saturn\", \"\
    Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\") == [\"Venus\"\
    ])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"Neptune\", planet2:\
    \ \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"])\n\
    assert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Makemake\") == [] as [String])"
  status: SyntaxError
  stderr: "/tmp/tmpwu1e0ujv.swift:41:69: error: unterminated string literal\n    \
    \    if planet1 == \"Mercury\" || planet1 == \"Venus\" || planet1 == \"Earth\n\
    \                                                                    ^\n/tmp/tmpwu1e0ujv.swift:63:70:\
    \ error: expected '}' at end of brace statement\nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Makemake\") == [] as [String])\n                                \
    \                                     ^\n/tmp/tmpwu1e0ujv.swift:15:55: note: to\
    \ match this opening '{'\nfunc bf(planet1: String, planet2: String) -> [String]\
    \ {\n                                                      ^\n/tmp/tmpwu1e0ujv.swift:45:6:\
    \ error: operator functions can only be declared at global or in type scope\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1659823231
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    var planets = [String]()\n\
    \    \n    if planet1 == \"Mercury\" && planet2 == \"Venus\" {\n        planets\
    \ = [\"Mercury\", \"Venus\"]\n    } else if planet1 == \"Venus\" && planet2 ==\
    \ \"Earth\" {\n        planets = [\"Venus\", \"Earth\"]\n    } else if planet1\
    \ == \"Earth\" && planet2 == \"Mars\" {\n        planets = [\"Earth\", \"Mars\"\
    ]\n    } else if planet1 == \"Mars\" && planet2 == \"Jupiter\" {\n        planets\
    \ = [\"Mars\", \"Jupiter\"]\n    } else if planet1 == \"Jupiter\" && planet2 ==\
    \ \"Saturn\" {\n        planets = [\"Jupiter\", \"Saturn\"]\n    } else if planet1\
    \ == \"Saturn\" && planet2 == \"Uranus\" {\n        planets = [\"Saturn\", \"\
    Uranus\"]\n    } else if planet1 == \"Uranus\" && planet2 == \"Neptune\" {\n \
    \       planets = [\"Uranus\", \"Neptune\"]\n    } else if planet1 == \"Neptune\"\
    \ && planet2 == \"Mercury\" {\n        planets = [\"Neptune\", \"Mercury\"]\n\
    \    } else {\n        return planets\n    }\n    \n    return planets\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\"\
    ) == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\"\
    ) == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"\
    Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\n\
    assert(bf(planet1: \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Makemake\") == [] as [String])"
  status: Exception
  stderr: 'tmpfj6zav_w/tmpfj6zav_w.swift:54: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b6f447ddc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6f444d4b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b6f444d4988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b6f444d37b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpfj6zav_w                        0x0000557816a0a5cb <unavailable> + 5579

    5    libc.so.6                          0x00002b6f449c9460 __libc_start_main +
    245

    6    tmpfj6zav_w                        0x0000557816a0a179 <unavailable> + 4473

    '
  stdout: ''
  timestamp: 1659823231
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    var planets = [String]()\n\
    \    \n    if planet1 == planet2 {\n        return planets\n    }\n    \n    if\
    \ planet1 == \"Mercury\" {\n        planets = [\"Venus\"]\n    } else if planet1\
    \ == \"Venus\" {\n        planets = [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\", \"Neptune\"]\n    } else if planet1 == \"Earth\" {\n        planets\
    \ = [\"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"]\n    } else if\
    \ planet1 == \"Mars\" {\n        planets = [\"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    } else if planet1 == \"Jupiter\" {\n        planets = [\"\
    Saturn\", \"Uranus\", \"Neptune\"]\n    } else if planet1 == \"Saturn\" {\n  \
    \      planets = [\"Uranus\", \"Neptune\"]\n    } else if planet1 == \"Uranus\"\
    \ {\n        planets = [\"Neptune\"]\n    } else if planet1 == \"Neptune\" {\n\
    \        planets = [\"Mercury\", \"Venus\"]\n    }\n    \n    if planet2 == \"\
    Mercury\" {\n        planets = [\"Venus\"]\n    } else if planet2 == \"Venus\"\
    \ {\n        planets = [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    } else if planet2 == \"Earth\" {\n        planets = [\"Mars\"\
    , \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"]\n    } else if planet2 ==\
    \ \"Mars\" {\n        planets = [\"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    ]\n    } else if planet2 == \"Jupiter\" {\n        planets = [\"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    } else if planet2 == \"Saturn\" {\n        planets = [\"Uranus\"\
    , \"Neptune\"]\n    } else if planet2 == \"Uranus\" {\n        planets = [\"Neptune\"\
    ]\n    } else if planet2 == \"Neptune\" {\n        planets = [\"Mercury\", \"\
    Venus\"]\n    }\n    \n    return planets\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\") == [\"Saturn\", \"\
    Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\") == [\"Venus\"\
    ])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"Neptune\", planet2:\
    \ \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"])\n\
    assert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Makemake\") == [] as [String])"
  status: Exception
  stderr: 'tmp8grfsni8/tmp8grfsni8.swift:74: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002afa8fef2c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002afa8fbe9b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002afa8fbe9988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002afa8fbe87b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp8grfsni8                        0x0000557d9c5345cb <unavailable> + 5579

    5    libc.so.6                          0x00002afa900de460 __libc_start_main +
    245

    6    tmp8grfsni8                        0x0000557d9c534179 <unavailable> + 4473

    '
  stdout: ''
  timestamp: 1659823230
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    \n    var planets\
    \ = [String]()\n    \n    if planet1 == planet2 {\n        return planets\n  \
    \  }\n    \n    if planet1 == \"Mercury\" && planet2 == \"Venus\" {\n        planets\
    \ = [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"]\n\
    \    }\n    \n    if planet1 == \"Venus\" && planet2 == \"Mercury\" {\n      \
    \  planets = [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    ]\n    }\n    \n    if planet1 == \"Earth\" && planet2 == \"Mercury\" {\n    \
    \    planets = [\"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"]\n\
    \    }\n    \n    if planet1 == \"Mars\" && planet2 == \"Mercury\" {\n       \
    \ planets = [\"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"]\n    }\n    \n\
    \    if planet1 == \"Jupiter\" && planet2 == \"Mercury\" {\n        planets =\
    \ [\"Saturn\", \"Uranus\", \"Neptune\"]\n    }\n    \n    if planet1 == \"Saturn\"\
    \ && planet2 == \"Mercury\" {\n        planets = [\"Uranus\", \"Neptune\"]\n \
    \   }\n    \n    if planet1 == \"Uranus\" && planet2 == \"Mercury\" {\n      \
    \  planets = [\"Neptune\"]\n    }\n    \n    if planet1 == \"Neptune\" && planet2\
    \ == \"Mercury\" {\n        planets = [\"Mercury\"]\n    }\n    \n    if planet1\
    \ == \"Mercury\" && planet2 == \"Earth\" {\n        planets = [\"Venus\"]\n  \
    \  }\n    \n    if planet1 == \"Venus\" && planet2 == \"Earth\" {\n        planets\
    \ = [\"Mercury\"]\n    }\n    \n    if planet1 == \"Earth\" && planet2 == \"Earth\"\
    \ {\n        planets = [\"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    ]\n    }\n    \n    if planet1 == \"Mars\" && planet2 == \"Earth\" {\n       \
    \ planets = [\"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"]\n    }\n    \n\
    \    if planet1 == \"Jupiter\" && planet2 == \"Earth\" {\n        plan\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\"\
    ) == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\"\
    ) == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"\
    Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\n\
    assert(bf(planet1: \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Makemake\") == [] as [String])"
  status: SyntaxError
  stderr: "/tmp/tmpuxjfu1yx.swift:94:70: error: expected '}' at end of brace statement\n\
    assert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") == [] as [String])\n  \
    \                                                                   ^\n/tmp/tmpuxjfu1yx.swift:15:55:\
    \ note: to match this opening '{'\nfunc bf(planet1: String, planet2: String) ->\
    \ [String] {\n                                                      ^\n/tmp/tmpuxjfu1yx.swift:72:9:\
    \ error: cannot find 'plan' in scope\n        plan\n        ^~~~\n/tmp/tmpuxjfu1yx.swift:76:6:\
    \ error: operator functions can only be declared at global or in type scope\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1659823231
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    var planets = [String]()\n\
    \    \n    // TODO: write your code here\n    \n    return planets\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\"\
    ) == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\"\
    ) == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"\
    Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\n\
    assert(bf(planet1: \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Makemake\") == [] as [String])"
  status: Exception
  stderr: 'tmpxu1j0xgi/tmpxu1j0xgi.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac11528bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac114f82b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac114f82988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac114f817b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpxu1j0xgi                        0x0000564f54cf056b <unavailable> + 5483

    5    libc.so.6                          0x00002ac115477460 __libc_start_main +
    245

    6    tmpxu1j0xgi                        0x0000564f54cf0119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659823231
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    \n    var planets\
    \ = [String]()\n    \n    if planet1 == planet2 {\n        return planets\n  \
    \  }\n    \n    if planet1 == \"Mercury\" {\n        planets.append(\"Earth\"\
    )\n        planets.append(\"Mars\")\n        planets.append(\"Jupiter\")\n   \
    \     planets.append(\"Saturn\")\n        planets.append(\"Uranus\")\n       \
    \ planets.append(\"Neptune\")\n        planets.append(\"Venus\")\n    }\n    \n\
    \    if planet1 == \"Venus\" {\n        planets.append(\"Earth\")\n        planets.append(\"\
    Mars\")\n        planets.append(\"Jupiter\")\n        planets.append(\"Saturn\"\
    )\n        planets.append(\"Uranus\")\n        planets.append(\"Neptune\")\n \
    \       planets.append(\"Mercury\")\n    }\n    \n    if planet1 == \"Earth\"\
    \ {\n        planets.append(\"Mars\")\n        planets.append(\"Jupiter\")\n \
    \       planets.append(\"Saturn\")\n        planets.append(\"Uranus\")\n     \
    \   planets.append(\"Neptune\")\n        planets.append(\"Mercury\")\n       \
    \ planets.append(\"Venus\")\n    }\n    \n    if planet1 == \"Mars\" {\n     \
    \   planets.append(\"Jupiter\")\n        planets.append(\"Saturn\")\n        planets.append(\"\
    Uranus\")\n        planets.append(\"Neptune\")\n        planets.append(\"Mercury\"\
    )\n        planets.append(\"Venus\")\n        planets.append(\"Earth\")\n    }\n\
    \    \n    if planet1 == \"Jupiter\" {\n        planets.append(\"Saturn\")\n \
    \       planets.append(\"Uranus\")\n        planets.append(\"Neptune\")\n    \
    \    planets.append(\"Mercury\")\n        planets.append(\"Venus\")\n        planets.append(\"\
    Earth\")\n        planets.append(\"Mars\")\n    }\n    \n    if planet1 == \"\
    Saturn\" {\n        planets.append(\"Uranus\")\n        planets.append(\"Neptune\"\
    )\n        planets.append(\"Mercury\")\n        planets.append(\"Venus\")\n  \
    \      planets.append(\"Earth\")\n        planets.append(\"Mars\")\n        planets.append(\"\
    Jupiter\")\n    }\n    \n    if planet1 == \"Uranus\" {\n        planets.append(\"\
    Neptune\")\n        planets.append(\"Mercury\")\n        planets.append(\"Venus\"\
    )\n        planets.append(\"Earth\")\n        planets.append(\"Mars\")\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\"\
    ) == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\"\
    ) == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"\
    Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\n\
    assert(bf(planet1: \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Makemake\") == [] as [String])"
  status: SyntaxError
  stderr: "/tmp/tmpvwqem9oc.swift:110:70: error: expected '}' at end of brace statement\n\
    assert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") == [] as [String])\n  \
    \                                                                   ^\n/tmp/tmpvwqem9oc.swift:15:55:\
    \ note: to match this opening '{'\nfunc bf(planet1: String, planet2: String) ->\
    \ [String] {\n                                                      ^\n/tmp/tmpvwqem9oc.swift:92:6:\
    \ error: operator functions can only be declared at global or in type scope\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1659823231
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    var planets = [String]()\n\
    \    \n    if planet1 == \"Mercury\" && planet2 == \"Venus\" {\n        planets\
    \ = [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"]\n\
    \    } else if planet1 == \"Venus\" && planet2 == \"Earth\" {\n        planets\
    \ = [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"]\n\
    \    } else if planet1 == \"Earth\" && planet2 == \"Mars\" {\n        planets\
    \ = [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"]\n\
    \    } else if planet1 == \"Mars\" && planet2 == \"Jupiter\" {\n        planets\
    \ = [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"]\n\
    \    } else if planet1 == \"Jupiter\" && planet2 == \"Saturn\" {\n        planets\
    \ = [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"]\n\
    \    } else if planet1 == \"Saturn\" && planet2 == \"Uranus\" {\n        planets\
    \ = [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"]\n\
    \    } else if planet1 == \"Uranus\" && planet2 == \"Neptune\" {\n        planets\
    \ = [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"]\n\
    \    } else {\n        return planets\n    }\n    \n    return planets\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\"\
    ) == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\"\
    ) == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"\
    Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\n\
    assert(bf(planet1: \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Makemake\") == [] as [String])"
  status: Exception
  stderr: 'tmpgyrbh8ms/tmpgyrbh8ms.swift:52: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002afa8ddd1c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002afa8dac8b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002afa8dac8988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002afa8dac77b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpgyrbh8ms                        0x000055b8458d35cb <unavailable> + 5579

    5    libc.so.6                          0x00002afa8dfbd460 __libc_start_main +
    245

    6    tmpgyrbh8ms                        0x000055b8458d3179 <unavailable> + 4473

    '
  stdout: ''
  timestamp: 1659823230
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    var result = [String]()\n\
    \    \n    // TODO: Write your code here\n    \n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\"\
    ) == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\"\
    ) == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"\
    Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\n\
    assert(bf(planet1: \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Makemake\") == [] as [String])"
  status: Exception
  stderr: 'tmpeirebgxu/tmpeirebgxu.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b3a53e6fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3a53b66b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b3a53b66988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b3a53b657b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpeirebgxu                        0x0000555a58dcc56b <unavailable> + 5483

    5    libc.so.6                          0x00002b3a5405b460 __libc_start_main +
    245

    6    tmpeirebgxu                        0x0000555a58dcc119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659823230
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    var planets = [String]()\n\
    \    \n    if planet1 == planet2 {\n        return planets\n    }\n    \n    let\
    \ planet1Orbit = orbit(planet1)\n    let planet2Orbit = orbit(planet2)\n    \n\
    \    if planet1Orbit == planet2Orbit {\n        return planets\n    }\n    \n\
    \    let planet1Sun = sunOrbit(planet1)\n    let planet2Sun = sunOrbit(planet2)\n\
    \    \n    if planet1Sun == planet2Sun {\n        return planets\n    }\n    \n\
    \    let planet1SunDistance = distance(planet1, planet2)\n    let planet2SunDistance\
    \ = distance(planet2, planet1)\n    \n    if planet1SunDistance < planet2SunDistance\
    \ {\n        planets.append(planet1)\n        planets.append(planet2)\n    } else\
    \ {\n        planets.append(planet2)\n        planets.append(planet1)\n    }\n\
    \    \n    return planets\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1:\
    \ \"Earth\", planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\"\
    , planet2: \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    ])\nassert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2:\
    \ \"Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\"\
    ) == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: SyntaxError
  stderr: "/tmp/tmpm9pqwgej.swift:22:24: error: cannot find 'orbit' in scope\n   \
    \ let planet1Orbit = orbit(planet1)\n                       ^~~~~\n/tmp/tmpm9pqwgej.swift:23:24:\
    \ error: cannot find 'orbit' in scope\n    let planet2Orbit = orbit(planet2)\n\
    \                       ^~~~~\n/tmp/tmpm9pqwgej.swift:29:22: error: cannot find\
    \ 'sunOrbit' in scope\n    let planet1Sun = sunOrbit(planet1)\n              \
    \       ^~~~~~~~\n/tmp/tmpm9pqwgej.swift:30:22: error: cannot find 'sunOrbit'\
    \ in scope\n    let planet2Sun = sunOrbit(planet2)\n                     ^~~~~~~~\n\
    /tmp/tmpm9pqwgej.swift:36:30: error: cannot find 'distance' in scope\n    let\
    \ planet1SunDistance = distance(planet1, planet2)\n                          \
    \   ^~~~~~~~\n/tmp/tmpm9pqwgej.swift:37:30: error: cannot find 'distance' in scope\n\
    \    let planet2SunDistance = distance(planet2, planet1)\n                   \
    \          ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659823231
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    \n    // Your code\
    \ here\n    \n    return []\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1:\
    \ \"Earth\", planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\"\
    , planet2: \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    ])\nassert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2:\
    \ \"Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\"\
    ) == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: Exception
  stderr: 'tmpub3vnyvf/tmpub3vnyvf.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9379153c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9378e4ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9378e4a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9378e497b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpub3vnyvf                        0x0000559f9836d51b <unavailable> + 5403

    5    libc.so.6                          0x00002b937933f460 __libc_start_main +
    245

    6    tmpub3vnyvf                        0x0000559f9836d0c9 <unavailable> + 4297

    '
  stdout: ''
  timestamp: 1659823230
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    var result = [String]()\n\
    \    \n    guard let planet1Orbit = planet1Orbit(planet1) else {\n        return\
    \ result\n    }\n    guard let planet2Orbit = planet2Orbit(planet2) else {\n \
    \       return result\n    }\n    \n    let planet1OrbitIndex = planet1Orbit.index(of:\
    \ planet2)\n    let planet2OrbitIndex = planet2Orbit.index(of: planet1)\n    \n\
    \    if planet1OrbitIndex < planet2OrbitIndex {\n        result.insert(planet1,\
    \ at: planet1OrbitIndex)\n        result.insert(planet2, at: planet2OrbitIndex)\n\
    \    } else {\n        result.insert(planet2, at: planet1OrbitIndex)\n       \
    \ result.insert(planet1, at: planet2OrbitIndex)\n    }\n    \n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\"\
    ) == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\"\
    ) == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"\
    Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\n\
    assert(bf(planet1: \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Makemake\") == [] as [String])"
  status: SyntaxError
  stderr: "/tmp/tmp6x24l3ko.swift:18:30: error: cannot find 'planet1Orbit' in scope\n\
    \    guard let planet1Orbit = planet1Orbit(planet1) else {\n                 \
    \            ^~~~~~~~~~~~\n/tmp/tmp6x24l3ko.swift:21:30: error: cannot find 'planet2Orbit'\
    \ in scope\n    guard let planet2Orbit = planet2Orbit(planet2) else {\n      \
    \                       ^~~~~~~~~~~~\n"
  stdout: ''
  timestamp: 1659823231
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    \n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\") == [\"\
    Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\") ==\
    \ [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"Venus\"\
    , \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"Neptune\"\
    , planet2: \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    ])\nassert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Makemake\") == [] as [String])"
  status: SyntaxError
  stderr: '/tmp/tmp3d9bvts2.swift:17:1: error: missing return in global function expected
    to return ''[String]''

    }

    ^

    '
  stdout: ''
  timestamp: 1659823230
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    var planets = [String]()\n\
    \    \n    if planet1 == \"Mercury\" && planet2 == \"Venus\" {\n        planets\
    \ = [\"Mercury\", \"Venus\"]\n    } else if planet1 == \"Venus\" && planet2 ==\
    \ \"Mercury\" {\n        planets = [\"Venus\", \"Mercury\"]\n    } else if planet1\
    \ == \"Earth\" && planet2 == \"Mars\" {\n        planets = [\"Earth\", \"Mars\"\
    ]\n    } else if planet1 == \"Mars\" && planet2 == \"Earth\" {\n        planets\
    \ = [\"Mars\", \"Earth\"]\n    } else if planet1 == \"Jupiter\" && planet2 ==\
    \ \"Saturn\" {\n        planets = [\"Jupiter\", \"Saturn\"]\n    } else if planet1\
    \ == \"Saturn\" && planet2 == \"Jupiter\" {\n        planets = [\"Saturn\", \"\
    Jupiter\"]\n    } else if planet1 == \"Uranus\" && planet2 == \"Neptune\" {\n\
    \        planets = [\"Uranus\", \"Neptune\"]\n    } else if planet1 == \"Neptune\"\
    \ && planet2 == \"Uranus\" {\n        planets = [\"Neptune\", \"Uranus\"]\n  \
    \  } else {\n        return planets\n    }\n    \n    return planets\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\"\
    ) == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\"\
    ) == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"\
    Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\n\
    assert(bf(planet1: \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Makemake\") == [] as [String])"
  status: Exception
  stderr: 'tmp7ma8dqwc/tmp7ma8dqwc.swift:54: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b2194625c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b219431cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b219431c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b219431b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp7ma8dqwc                        0x0000558a2caab5cb <unavailable> + 5579

    5    libc.so.6                          0x00002b2194811460 __libc_start_main +
    245

    6    tmp7ma8dqwc                        0x0000558a2caab179 <unavailable> + 4473

    '
  stdout: ''
  timestamp: 1659823231
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    var planets = [String]()\n\
    \    \n    switch planet1 {\n    case \"Mercury\":\n        planets = [\"Venus\"\
    ]\n    case \"Venus\":\n        planets = [\"Earth\", \"Mars\", \"Jupiter\", \"\
    Saturn\", \"Uranus\", \"Neptune\"]\n    case \"Earth\":\n        planets = [\"\
    Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"]\n    case \"Mars\":\n\
    \        planets = [\"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"]\n    case\
    \ \"Jupiter\":\n        planets = [\"Saturn\", \"Uranus\", \"Neptune\"]\n    case\
    \ \"Saturn\":\n        planets = [\"Uranus\", \"Neptune\"]\n    case \"Uranus\"\
    :\n        planets = [\"Neptune\"]\n    case \"Neptune\":\n        planets = []\n\
    \    default:\n        return planets\n    }\n    \n    switch planet2 {\n   \
    \ case \"Mercury\":\n        planets = [\"Venus\"]\n    case \"Venus\":\n    \
    \    planets = [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    ]\n    case \"Earth\":\n        planets = [\"Mars\", \"Jupiter\", \"Saturn\",\
    \ \"Uranus\", \"Neptune\"]\n    case \"Mars\":\n        planets = [\"Jupiter\"\
    , \"Saturn\", \"Uranus\", \"Neptune\"]\n    case \"Jupiter\":\n        planets\
    \ = [\"Saturn\", \"Uranus\", \"Neptune\"]\n    case \"Saturn\":\n        planets\
    \ = [\"Uranus\", \"Neptune\"]\n    case \"Uranus\":\n        planets = [\"Neptune\"\
    ]\n    case \"Neptune\":\n        planets = []\n    default:\n        return planets\n\
    \    }\n    \n    return planets\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1:\
    \ \"Earth\", planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\"\
    , planet2: \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    ])\nassert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2:\
    \ \"Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\"\
    ) == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: Exception
  stderr: 'tmp3r_invh9/tmp3r_invh9.swift:76: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b180a2fdc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b1809ff4b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b1809ff4988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b1809ff37b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp3r_invh9                        0x000055668ffbc5cb <unavailable> + 5579

    5    libc.so.6                          0x00002b180a4e9460 __libc_start_main +
    245

    6    tmp3r_invh9                        0x000055668ffbc179 <unavailable> + 4473

    '
  stdout: ''
  timestamp: 1659823231
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    var planets = [String]()\n\
    \    \n    // TODO: Write your code here\n    \n    return planets\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\"\
    ) == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\"\
    ) == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"\
    Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\n\
    assert(bf(planet1: \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Makemake\") == [] as [String])"
  status: Exception
  stderr: 'tmpqir0zopy/tmpqir0zopy.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b71b763fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b71b7336b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b71b7336988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b71b73357b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpqir0zopy                        0x00005603381a456b <unavailable> + 5483

    5    libc.so.6                          0x00002b71b782b460 __libc_start_main +
    245

    6    tmpqir0zopy                        0x00005603381a4119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659823230
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    var planets = [String]()\n\
    \    \n    if planet1 == planet2 {\n        return planets\n    }\n    \n    if\
    \ planet1 == \"Mercury\" || planet1 == \"Venus\" || planet1 == \"Earth\" || planet1\
    \ == \"Mars\" || planet1 == \"Jupiter\" || planet1 == \"Saturn\" || planet1 ==\
    \ \"Uranus\" || planet1 == \"Neptune\" {\n        planets.append(planet1)\n  \
    \  }\n    \n    if planet2 == \"Mercury\" || planet2 == \"Venus\" || planet2 ==\
    \ \"Earth\" || planet2 == \"Mars\" || planet2 == \"Jupiter\" || planet2 == \"\
    Saturn\" || planet2 == \"Uranus\" || planet2 == \"Neptune\" {\n        planets.append(planet2)\n\
    \    }\n    \n    if planet1 == \"Mercury\" || planet1 == \"Venus\" || planet1\
    \ == \"Earth\" || planet1 == \"Mars\" || planet1 == \"Jupiter\" || planet1 ==\
    \ \"Saturn\" || planet1 == \"Uranus\" || planet1 == \"Neptune\" {\n        planets.append(planet2)\n\
    \    }\n    \n    if planet2 == \"Mercury\" || planet2 == \"Venus\" || planet2\
    \ == \"Earth\" || planet2 == \"Mars\" || planet2 == \"Jupiter\" || planet2 ==\
    \ \"Saturn\" || planet2 == \"Uranus\" || planet2 == \"Neptune\" {\n        planets.append(planet1)\n\
    \    }\n    \n    if planet1 == \"Mercury\" || planet1 == \"Venus\" || planet1\
    \ == \"Earth\" || planet1 == \"Mars\" || planet1 == \"Jupiter\" || planet1 ==\
    \ \"Saturn\" || planet1 == \"Uranus\" || planet1 == \"Neptune\" {\n        planets.append(planet2)\n\
    \    }\n    \n    if planet2 == \"Mercury\" || planet2 == \"Venus\" || planet2\
    \ == \"Earth\" || planet2 == \"Mars\" || planet2 == \"Jupiter\" || planet2 ==\
    \ \"Saturn\" || planet2 == \"Uranus\" || planet2 == \"Neptune\" {\n        planets.append(planet1)\n\
    \    }\n    \n    if planet1 == \"Mercury\" || planet1 == \"Venus\" || planet1\
    \ == \"Earth\" || planet1 == \"Mars\" || planet1 == \"Jup\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\") == [\"\
    Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\") ==\
    \ [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"Venus\"\
    , \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"Neptune\"\
    , planet2: \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    ])\nassert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Makemake\") == [] as [String])"
  status: SyntaxError
  stderr: "/tmp/tmp4i4zkkv1.swift:46:108: error: unterminated string literal\n   \
    \ if planet1 == \"Mercury\" || planet1 == \"Venus\" || planet1 == \"Earth\" ||\
    \ planet1 == \"Mars\" || planet1 == \"Jup\n                                  \
    \                                                                         ^\n"
  stdout: ''
  timestamp: 1659823230
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    var result: [String]\
    \ = []\n    \n    // TODO: Write your code here\n    \n    return result\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\"\
    ) == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\"\
    ) == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"\
    Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\n\
    assert(bf(planet1: \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Makemake\") == [] as [String])"
  status: Exception
  stderr: 'tmpzxxi8gnj/tmpzxxi8gnj.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba76d0ddc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba76cdd4b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba76cdd4988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba76cdd37b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpzxxi8gnj                        0x000055717b78f51b <unavailable> + 5403

    5    libc.so.6                          0x00002ba76d2c9460 __libc_start_main +
    245

    6    tmpzxxi8gnj                        0x000055717b78f0c9 <unavailable> + 4297

    '
  stdout: ''
  timestamp: 1659823230
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    \n    // Your code\
    \ here\n    \n    return []\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1:\
    \ \"Earth\", planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\"\
    , planet2: \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    ])\nassert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2:\
    \ \"Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\"\
    ) == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: Exception
  stderr: 'tmpub3vnyvf/tmpub3vnyvf.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9379153c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9378e4ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9378e4a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9378e497b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpub3vnyvf                        0x0000559f9836d51b <unavailable> + 5403

    5    libc.so.6                          0x00002b937933f460 __libc_start_main +
    245

    6    tmpub3vnyvf                        0x0000559f9836d0c9 <unavailable> + 4297

    '
  stdout: ''
  timestamp: 1659823230
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    var planets = [String]()\n\
    \    \n    if planet1 == planet2 {\n        return planets\n    }\n    \n    if\
    \ planet1 == \"Mercury\" {\n        planets.append(\"Venus\")\n    }\n    \n \
    \   if planet1 == \"Venus\" {\n        planets.append(\"Earth\")\n    }\n    \n\
    \    if planet1 == \"Earth\" {\n        planets.append(\"Mars\")\n    }\n    \n\
    \    if planet1 == \"Mars\" {\n        planets.append(\"Jupiter\")\n    }\n  \
    \  \n    if planet1 == \"Jupiter\" {\n        planets.append(\"Saturn\")\n   \
    \ }\n    \n    if planet1 == \"Saturn\" {\n        planets.append(\"Uranus\")\n\
    \    }\n    \n    if planet1 == \"Uranus\" {\n        planets.append(\"Neptune\"\
    )\n    }\n    \n    if planet1 == \"Neptune\" {\n        return planets\n    }\n\
    \    \n    if planet2 == \"Mercury\" {\n        planets.append(\"Venus\")\n  \
    \  }\n    \n    if planet2 == \"Venus\" {\n        planets.append(\"Earth\")\n\
    \    }\n    \n    if planet2 == \"Earth\" {\n        planets.append(\"Mars\")\n\
    \    }\n    \n    if planet2 == \"Mars\" {\n        planets.append(\"Jupiter\"\
    )\n    }\n    \n    if planet2 == \"Jupiter\" {\n        planets.append(\"Saturn\"\
    )\n    }\n    \n    if planet2 == \"Saturn\" {\n        planets.append(\"Uranus\"\
    )\n    }\n    \n    if planet2 == \"Uranus\" {\n        planets.append(\"Neptune\"\
    )\n    }\n    \n    if planet2 == \"Neptune\" {\n        return planets\n    }\n\
    \    \n    return planets\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1:\
    \ \"Earth\", planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\"\
    , planet2: \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    ])\nassert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2:\
    \ \"Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\"\
    ) == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: Exception
  stderr: 'tmp6hdlqszs/tmp6hdlqszs.swift:102: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b3841159c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b3840e50b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b3840e50988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b3840e4f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp6hdlqszs                        0x00005595dec7d62b <unavailable> + 5675

    5    libc.so.6                          0x00002b3841345460 __libc_start_main +
    245

    6    tmp6hdlqszs                        0x00005595dec7d1d9 <unavailable> + 4569

    '
  stdout: ''
  timestamp: 1659823231
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    var planets = [String]()\n\
    \    \n    if planet1 == planet2 {\n        return planets\n    }\n    \n    if\
    \ planet1 == \"Mercury\" || planet1 == \"Venus\" || planet1 == \"Earth\" || planet1\
    \ == \"Mars\" || planet1 == \"Jupiter\" || planet1 == \"Saturn\" || planet1 ==\
    \ \"Uranus\" || planet1 == \"Neptune\" {\n        planets.append(planet1)\n  \
    \  }\n    \n    if planet2 == \"Mercury\" || planet2 == \"Venus\" || planet2 ==\
    \ \"Earth\" || planet2 == \"Mars\" || planet2 == \"Jupiter\" || planet2 == \"\
    Saturn\" || planet2 == \"Uranus\" || planet2 == \"Neptune\" {\n        planets.append(planet2)\n\
    \    }\n    \n    if planet1 == \"Mercury\" && planet2 == \"Venus\" {\n      \
    \  planets.append(planet1)\n        planets.append(planet2)\n    }\n    \n   \
    \ if planet1 == \"Venus\" && planet2 == \"Mercury\" {\n        planets.append(planet1)\n\
    \        planets.append(planet2)\n    }\n    \n    if planet1 == \"Earth\" &&\
    \ planet2 == \"Mars\" {\n        planets.append(planet1)\n        planets.append(planet2)\n\
    \    }\n    \n    if planet1 == \"Mars\" && planet2 == \"Earth\" {\n        planets.append(planet1)\n\
    \        planets.append(planet2)\n    }\n    \n    if planet1 == \"Jupiter\" &&\
    \ planet2 == \"Saturn\" {\n        planets.append(planet1)\n        planets.append(planet2)\n\
    \    }\n    \n    if planet1 == \"Saturn\" && planet2 == \"Jupiter\" {\n     \
    \   planets.append(planet1)\n        planets.append(planet2)\n    }\n    \n  \
    \  if planet1 == \"Uranus\" && planet2 == \"Neptune\" {\n        planets.append(planet1)\n\
    \        planets.append(planet2)\n    }\n    \n    if planet1 == \"Neptune\" &&\
    \ planet2 == \"Uranus\" {\n        planets.append(planet1)\n        planets.append(planet2)\n\
    \    }\n    \n    if planet1 == \"Mercury\" && planet2 == \"Earth\" {\n      \
    \  planets.append(planet1)\n        planets.append(planet2)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\") == [\"\
    Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\") ==\
    \ [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"Venus\"\
    , \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"Neptune\"\
    , planet2: \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    ])\nassert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Makemake\") == [] as [String])"
  status: SyntaxError
  stderr: "/tmp/tmpbb3b92n7.swift:94:70: error: expected '}' at end of brace statement\n\
    assert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") == [] as [String])\n  \
    \                                                                   ^\n/tmp/tmpbb3b92n7.swift:15:55:\
    \ note: to match this opening '{'\nfunc bf(planet1: String, planet2: String) ->\
    \ [String] {\n                                                      ^\n/tmp/tmpbb3b92n7.swift:76:6:\
    \ error: operator functions can only be declared at global or in type scope\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1659823230
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    var planets = [String]()\n\
    \    \n    if planet1 == planet2 {\n        return planets\n    }\n    \n    var\
    \ orbit1 = orbit(planet1)\n    var orbit2 = orbit(planet2)\n    \n    if orbit1.distance\
    \ < orbit2.distance {\n        planets.append(planet1)\n        planets.append(planet2)\n\
    \    } else {\n        planets.append(planet2)\n        planets.append(planet1)\n\
    \    }\n    \n    return planets\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1:\
    \ \"Earth\", planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\"\
    , planet2: \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    ])\nassert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2:\
    \ \"Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\"\
    ) == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: SyntaxError
  stderr: "/tmp/tmpdm1hk01w.swift:22:18: error: cannot find 'orbit' in scope\n   \
    \ var orbit1 = orbit(planet1)\n                 ^~~~~\n/tmp/tmpdm1hk01w.swift:23:18:\
    \ error: cannot find 'orbit' in scope\n    var orbit2 = orbit(planet2)\n     \
    \            ^~~~~\n"
  stdout: ''
  timestamp: 1659823231
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    var planets = [String]()\n\
    \    \n    guard planet1 != planet2 else { return planets }\n    \n    guard planet1.isEmpty\
    \ == planet2.isEmpty else { return planets }\n    \n    guard planet1.isEmpty\
    \ == false else { return planets }\n    \n    guard planet2.isEmpty == false else\
    \ { return planets }\n    \n    guard planet1.isEmpty == true else { return planets\
    \ }\n    \n    guard planet2.isEmpty == true else { return planets }\n    \n \
    \   guard planet1.isEmpty == false && planet2.isEmpty == false else { return planets\
    \ }\n    \n    guard planet1.isEmpty == true && planet2.isEmpty == true else {\
    \ return planets }\n    \n    guard planet1.isEmpty == false && planet2.isEmpty\
    \ == true else { return planets }\n    \n    guard planet1.isEmpty == true &&\
    \ planet2.isEmpty == false else { return planets }\n    \n    guard planet1.isEmpty\
    \ == false && planet2.isEmpty == false else { return planets }\n    \n    guard\
    \ planet1.isEmpty == true && planet2.isEmpty == true else { return planets }\n\
    \    \n    guard planet1.isEmpty == false && planet2.isEmpty == false else { return\
    \ planets }\n    \n    guard planet1.isEmpty == true && planet2.isEmpty == true\
    \ else { return planets }\n    \n    guard planet1.isEmpty == false && planet2.isEmpty\
    \ == false else { return planets }\n    \n    guard planet1.isEmpty == true &&\
    \ planet2.isEmpty == true else { return planets }\n    \n    guard planet1.isEmpty\
    \ == false && planet2.isEmpty == false else { return planets }\n    \n    guard\
    \ planet1.isEmpty == true && planet2.isEmpty == true else { return planets }\n\
    \    \n    guard planet1.isEmpty == false && planet2.isEmpty == false else { return\
    \ planets }\n    \n    guard planet1.isEmpty == true && planet2.isEmpty == true\
    \ else { return planets }\n    \n    guard planet1.isEmpty \n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\") == [\"\
    Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\") ==\
    \ [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"Venus\"\
    , \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"Neptune\"\
    , planet2: \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    ])\nassert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Makemake\") == [] as [String])"
  status: SyntaxError
  stderr: "/tmp/tmpzwtvfnkt.swift:58:26: error: expected 'else' after 'guard' condition\n\
    \    guard planet1.isEmpty \n                         ^\n/tmp/tmpzwtvfnkt.swift:16:9:\
    \ warning: variable 'planets' was never mutated; consider changing to 'let' constant\n\
    \    var planets = [String]()\n    ~~~ ^\n    let\n"
  stdout: ''
  timestamp: 1659823231
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    var result: [String]\
    \ = []\n    \n    // TODO: Write your code here\n    \n    return result\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\"\
    ) == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\"\
    ) == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"\
    Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\n\
    assert(bf(planet1: \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Makemake\") == [] as [String])"
  status: Exception
  stderr: 'tmpzxxi8gnj/tmpzxxi8gnj.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba76d0ddc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba76cdd4b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba76cdd4988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba76cdd37b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpzxxi8gnj                        0x000055717b78f51b <unavailable> + 5403

    5    libc.so.6                          0x00002ba76d2c9460 __libc_start_main +
    245

    6    tmpzxxi8gnj                        0x000055717b78f0c9 <unavailable> + 4297

    '
  stdout: ''
  timestamp: 1659823230
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    \n    var planets\
    \ = [String]()\n    \n    if planet1 == planet2 {\n        return planets\n  \
    \  }\n    \n    if planet1 == \"Mercury\" || planet1 == \"Venus\" || planet1 ==\
    \ \"Earth\" || planet1 == \"Mars\" || planet1 == \"Jupiter\" || planet1 == \"\
    Saturn\" || planet1 == \"Uranus\" || planet1 == \"Neptune\" {\n        planets.append(planet1)\n\
    \    }\n    \n    if planet2 == \"Mercury\" || planet2 == \"Venus\" || planet2\
    \ == \"Earth\" || planet2 == \"Mars\" || planet2 == \"Jupiter\" || planet2 ==\
    \ \"Saturn\" || planet2 == \"Uranus\" || planet2 == \"Neptune\" {\n        planets.append(planet2)\n\
    \    }\n    \n    if planet1 == \"Mercury\" && planet2 == \"Venus\" {\n      \
    \  planets.append(\"Earth\")\n    }\n    \n    if planet1 == \"Venus\" && planet2\
    \ == \"Mercury\" {\n        planets.append(\"Mars\")\n    }\n    \n    if planet1\
    \ == \"Earth\" && planet2 == \"Mars\" {\n        planets.append(\"Jupiter\")\n\
    \    }\n    \n    if planet1 == \"Mars\" && planet2 == \"Jupiter\" {\n       \
    \ planets.append(\"Saturn\")\n    }\n    \n    if planet1 == \"Jupiter\" && planet2\
    \ == \"Saturn\" {\n        planets.append(\"Uranus\")\n    }\n    \n    if planet1\
    \ == \"Saturn\" && planet2 == \"Uranus\" {\n        planets.append(\"Neptune\"\
    )\n    }\n    \n    if planet1 == \"Uranus\" && planet2 == \"Neptune\" {\n   \
    \     planets.append(\"Mercury\")\n    }\n    \n    if planet1 == \"Neptune\"\
    \ && planet2 == \"Mercury\" {\n        planets.append(\"Venus\")\n    }\n    \n\
    \    if planet1 == \"Mercury\" && planet2 == \"Venus\" {\n        planets.append(\"\
    Earth\")\n    }\n    \n    if planet1 == \"Venus\" && planet2 == \"Mercury\" {\n\
    \        planets.append(\"Mars\")\n    }\n    \n    if planet1 == \"Earth\" &&\
    \ planet2 == \"Mars\" {\n        planets.append(\"Jupiter\")\n    }\n    \n  \
    \  if planet1\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool\
    \ {\n    if left.count != right.count {\n        return false\n    }\n    for\
    \ (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2:\
    \ \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\n\
    assert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"\
    Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\")\
    \ == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: SyntaxError
  stderr: "/tmp/tmp5xcz60pw.swift:75:15: error: expected '{' after 'if' condition\n\
    \    if planet1\n              ^\n/tmp/tmp5xcz60pw.swift:75:8: error: cannot convert\
    \ value of type 'String' to expected condition type 'Bool'\n    if planet1\n \
    \      ^~~~~~~\n"
  stdout: ''
  timestamp: 1659823231
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    var result = [String]()\n\
    \    \n    if planet1 == planet2 {\n        return result\n    }\n    \n    let\
    \ planet1Orbit = orbit(planet1)\n    let planet2Orbit = orbit(planet2)\n    \n\
    \    if planet1Orbit == planet2Orbit {\n        return result\n    }\n    \n \
    \   let planet1Sun = sunOrbit(planet1)\n    let planet2Sun = sunOrbit(planet2)\n\
    \    \n    if planet1Sun == planet2Sun {\n        return result\n    }\n    \n\
    \    let planet1SunDistance = distance(planet1, planet2)\n    let planet2SunDistance\
    \ = distance(planet2, planet1)\n    \n    if planet1SunDistance < planet2SunDistance\
    \ {\n        result.insert(planet1, at: 0)\n        result.insert(planet2, at:\
    \ 0)\n    } else {\n        result.insert(planet2, at: 0)\n        result.insert(planet1,\
    \ at: 0)\n    }\n    \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(bf(planet1: \"Jupiter\", planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"\
    ])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1:\
    \ \"Mercury\", planet2: \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"])\nassert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2:\
    \ \"Earth\") == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\"\
    ) == [] as [String])"
  status: SyntaxError
  stderr: "/tmp/tmpyumlg6rc.swift:22:24: error: cannot find 'orbit' in scope\n   \
    \ let planet1Orbit = orbit(planet1)\n                       ^~~~~\n/tmp/tmpyumlg6rc.swift:23:24:\
    \ error: cannot find 'orbit' in scope\n    let planet2Orbit = orbit(planet2)\n\
    \                       ^~~~~\n/tmp/tmpyumlg6rc.swift:29:22: error: cannot find\
    \ 'sunOrbit' in scope\n    let planet1Sun = sunOrbit(planet1)\n              \
    \       ^~~~~~~~\n/tmp/tmpyumlg6rc.swift:30:22: error: cannot find 'sunOrbit'\
    \ in scope\n    let planet2Sun = sunOrbit(planet2)\n                     ^~~~~~~~\n\
    /tmp/tmpyumlg6rc.swift:36:30: error: cannot find 'distance' in scope\n    let\
    \ planet1SunDistance = distance(planet1, planet2)\n                          \
    \   ^~~~~~~~\n/tmp/tmpyumlg6rc.swift:37:30: error: cannot find 'distance' in scope\n\
    \    let planet2SunDistance = distance(planet2, planet1)\n                   \
    \          ^~~~~~~~\n"
  stdout: ''
  timestamp: 1659823231
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    \n    var planets\
    \ = [String]()\n    \n    if planet1 == planet2 {\n        return planets\n  \
    \  }\n    \n    if planet1 == \"Mercury\" && planet2 == \"Venus\" {\n        planets\
    \ = [\"Mercury\", \"Venus\"]\n        return planets\n    }\n    \n    if planet1\
    \ == \"Venus\" && planet2 == \"Mercury\" {\n        planets = [\"Venus\", \"Mercury\"\
    ]\n        return planets\n    }\n    \n    if planet1 == \"Earth\" && planet2\
    \ == \"Mars\" {\n        planets = [\"Earth\", \"Mars\"]\n        return planets\n\
    \    }\n    \n    if planet1 == \"Mars\" && planet2 == \"Earth\" {\n        planets\
    \ = [\"Mars\", \"Earth\"]\n        return planets\n    }\n    \n    if planet1\
    \ == \"Jupiter\" && planet2 == \"Saturn\" {\n        planets = [\"Jupiter\", \"\
    Saturn\"]\n        return planets\n    }\n    \n    if planet1 == \"Saturn\" &&\
    \ planet2 == \"Jupiter\" {\n        planets = [\"Saturn\", \"Jupiter\"]\n    \
    \    return planets\n    }\n    \n    if planet1 == \"Uranus\" && planet2 == \"\
    Neptune\" {\n        planets = [\"Uranus\", \"Neptune\"]\n        return planets\n\
    \    }\n    \n    if planet1 == \"Neptune\" && planet2 == \"Uranus\" {\n     \
    \   planets = [\"Neptune\", \"Uranus\"]\n        return planets\n    }\n    \n\
    \    return planets\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2:\
    \ \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\n\
    assert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"\
    Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"\
    Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\")\
    \ == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: Exception
  stderr: 'tmpzlg0dar4/tmpzlg0dar4.swift:79: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aaf1926dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aaf18f64b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aaf18f64988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aaf18f637b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpzlg0dar4                        0x000056374eb7f5cb <unavailable> + 5579

    5    libc.so.6                          0x00002aaf19459460 __libc_start_main +
    245

    6    tmpzlg0dar4                        0x000056374eb7f179 <unavailable> + 4473

    '
  stdout: ''
  timestamp: 1659823231
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    var planets = [String]()\n\
    \    \n    if planet1 == planet2 {\n        return planets\n    }\n    \n    if\
    \ planet1 == \"Mercury\" || planet1 == \"Venus\" || planet1 == \"Earth\" || planet1\
    \ == \"Mars\" || planet1 == \"Jupiter\" || planet1 == \"Saturn\" || planet1 ==\
    \ \"Uranus\" || planet1 == \"Neptune\" {\n        planets.append(planet1)\n  \
    \  }\n    \n    if planet2 == \"Mercury\" || planet2 == \"Venus\" || planet2 ==\
    \ \"Earth\" || planet2 == \"Mars\" || planet2 == \"Jupiter\" || planet2 == \"\
    Saturn\" || planet2 == \"Uranus\" || planet2 == \"Neptune\" {\n        planets.append(planet2)\n\
    \    }\n    \n    if planet1 == \"Mercury\" && planet2 == \"Venus\" {\n      \
    \  planets.append(planet1)\n        planets.append(planet2)\n    }\n    \n   \
    \ if planet1 == \"Venus\" && planet2 == \"Mercury\" {\n        planets.append(planet1)\n\
    \        planets.append(planet2)\n    }\n    \n    if planet1 == \"Earth\" &&\
    \ planet2 == \"Mars\" {\n        planets.append(planet1)\n        planets.append(planet2)\n\
    \    }\n    \n    if planet1 == \"Mars\" && planet2 == \"Earth\" {\n        planets.append(planet1)\n\
    \        planets.append(planet2)\n    }\n    \n    if planet1 == \"Jupiter\" &&\
    \ planet2 == \"Saturn\" {\n        planets.append(planet1)\n        planets.append(planet2)\n\
    \    }\n    \n    if planet1 == \"Saturn\" && planet2 == \"Jupiter\" {\n     \
    \   planets.append(planet1)\n        planets.append(planet2)\n    }\n    \n  \
    \  if planet1 == \"Uranus\" && planet2 == \"Neptune\" {\n        planets.append(planet1)\n\
    \        planets.append(planet2)\n    }\n    \n    if planet1 == \"Neptune\" &&\
    \ planet2 == \"Uranus\" {\n        planets.append(planet1)\n        planets.append(planet2)\n\
    \    }\n    \n    if planet1 == \"Mercury\" && planet2 == \"Earth\" {\n      \
    \  planets.append(planet1)\n        planets.append(planet2)\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\") == [\"\
    Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\") ==\
    \ [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"Venus\"\
    , \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"Neptune\"\
    , planet2: \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    ])\nassert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Makemake\") == [] as [String])"
  status: SyntaxError
  stderr: "/tmp/tmpbb3b92n7.swift:94:70: error: expected '}' at end of brace statement\n\
    assert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") == [] as [String])\n  \
    \                                                                   ^\n/tmp/tmpbb3b92n7.swift:15:55:\
    \ note: to match this opening '{'\nfunc bf(planet1: String, planet2: String) ->\
    \ [String] {\n                                                      ^\n/tmp/tmpbb3b92n7.swift:76:6:\
    \ error: operator functions can only be declared at global or in type scope\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1659823230
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    \n    var planets\
    \ = [String]()\n    \n    if planet1 == planet2 {\n        return planets\n  \
    \  }\n    \n    if planet1 == \"Mercury\" {\n        planets.append(\"Earth\"\
    )\n        planets.append(\"Mars\")\n        planets.append(\"Jupiter\")\n   \
    \     planets.append(\"Saturn\")\n        planets.append(\"Uranus\")\n       \
    \ planets.append(\"Neptune\")\n        return planets\n    }\n    \n    if planet1\
    \ == \"Venus\" {\n        planets.append(\"Earth\")\n        planets.append(\"\
    Mars\")\n        planets.append(\"Jupiter\")\n        planets.append(\"Saturn\"\
    )\n        planets.append(\"Uranus\")\n        planets.append(\"Neptune\")\n \
    \       return planets\n    }\n    \n    if planet1 == \"Earth\" {\n        planets.append(\"\
    Mars\")\n        planets.append(\"Jupiter\")\n        planets.append(\"Saturn\"\
    )\n        planets.append(\"Uranus\")\n        planets.append(\"Neptune\")\n \
    \       return planets\n    }\n    \n    if planet1 == \"Mars\" {\n        planets.append(\"\
    Jupiter\")\n        planets.append(\"Saturn\")\n        planets.append(\"Uranus\"\
    )\n        planets.append(\"Neptune\")\n        return planets\n    }\n    \n\
    \    if planet1 == \"Jupiter\" {\n        planets.append(\"Saturn\")\n       \
    \ planets.append(\"Uranus\")\n        planets.append(\"Neptune\")\n        return\
    \ planets\n    }\n    \n    if planet1 == \"Saturn\" {\n        planets.append(\"\
    Uranus\")\n        planets.append(\"Neptune\")\n        return planets\n    }\n\
    \    \n    if planet1 == \"Uranus\" {\n        planets.append(\"Neptune\")\n \
    \       return planets\n    }\n    \n    if planet1 == \"Neptune\" {\n       \
    \ return planets\n    }\n    \n    return planets\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\") == [\"Saturn\"\
    , \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\") == [\"Venus\"\
    ])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"Neptune\", planet2:\
    \ \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"])\n\
    assert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Makemake\") == [] as [String])"
  status: Exception
  stderr: 'tmppftm1vrd/tmppftm1vrd.swift:98: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b11ee006c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b11edcfdb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b11edcfd988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b11edcfc7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmppftm1vrd                        0x00005578c5ae962b <unavailable> + 5675

    5    libc.so.6                          0x00002b11ee1f2460 __libc_start_main +
    245

    6    tmppftm1vrd                        0x00005578c5ae91d9 <unavailable> + 4569

    '
  stdout: ''
  timestamp: 1659823231
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    \n    // Your code\
    \ here\n    \n    return []\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1:\
    \ \"Earth\", planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\"\
    , planet2: \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    ])\nassert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2:\
    \ \"Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\"\
    ) == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: Exception
  stderr: 'tmpub3vnyvf/tmpub3vnyvf.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9379153c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9378e4ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9378e4a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9378e497b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpub3vnyvf                        0x0000559f9836d51b <unavailable> + 5403

    5    libc.so.6                          0x00002b937933f460 __libc_start_main +
    245

    6    tmpub3vnyvf                        0x0000559f9836d0c9 <unavailable> + 4297

    '
  stdout: ''
  timestamp: 1659823230
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    var planets = [String]()\n\
    \    \n    // TODO: Write your code here\n    \n    return planets\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\"\
    ) == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\"\
    ) == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"\
    Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\n\
    assert(bf(planet1: \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Makemake\") == [] as [String])"
  status: Exception
  stderr: 'tmpqir0zopy/tmpqir0zopy.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b71b763fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b71b7336b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b71b7336988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b71b73357b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpqir0zopy                        0x00005603381a456b <unavailable> + 5483

    5    libc.so.6                          0x00002b71b782b460 __libc_start_main +
    245

    6    tmpqir0zopy                        0x00005603381a4119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659823230
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    var result: [String]\
    \ = []\n    \n    if planet1 == planet2 {\n        return result;\n    }\n   \
    \ \n    let planet1Orbit = orbit(planet1)\n    let planet2Orbit = orbit(planet2)\n\
    \    \n    if planet1Orbit == planet2Orbit {\n        return result;\n    }\n\
    \    \n    let planet1Sun = sunOrbit(planet1)\n    let planet2Sun = sunOrbit(planet2)\n\
    \    \n    if planet1Sun == planet2Sun {\n        return result;\n    }\n    \n\
    \    let planet1SunDistance = distance(planet1, planet2)\n    let planet2SunDistance\
    \ = distance(planet2, planet1)\n    \n    if planet1SunDistance < planet2SunDistance\
    \ {\n        let planet1SunOrbit = orbit(planet1)\n        let planet2SunOrbit\
    \ = orbit(planet2)\n        \n        if planet1SunOrbit == planet2SunOrbit {\n\
    \            return result;\n        }\n        \n        let planet1SunSun =\
    \ sunOrbit(planet1)\n        let planet2SunSun = sunOrbit(planet2)\n        \n\
    \        if planet1SunSun == planet2SunSun {\n            return result;\n   \
    \     }\n        \n        let planet1SunSunDistance = distance(planet1, planet2)\n\
    \        let planet2SunSunDistance = distance(planet2, planet1)\n        \n  \
    \      if planet1SunSunDistance < planet2SunSunDistance {\n            let planet1SunOrbit\
    \ = orbit(planet1)\n            let planet2SunOrbit = orbit(planet2)\n       \
    \     \n            if planet1SunOrbit == planet2SunOrbit {\n                return\
    \ result;\n            }\n            \n            let planet1SunSun = sunOrbit(planet1)\n\
    \            let planet2SunSun = sunOrbit(planet2)\n            \n           \
    \ if planet1SunSun == planet2SunSun {\n                return result;\n      \
    \      }\n            \n            let planet1SunSunDistance = distance(planet1,\
    \ planet2)\n            let planet2SunSunDistance = distance(planet2, planet1)\n\
    \            \n            if planet1SunSunDistance < planet2SunSunDistance {\n\
    \                let planet1SunOrbit = orbit(planet1)\n                let planet2SunOrbit\
    \ = orbit(planet2)\n                \n                if \n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\") == [\"\
    Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\") ==\
    \ [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"Venus\"\
    , \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"Neptune\"\
    , planet2: \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    ])\nassert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Makemake\") == [] as [String])"
  status: SyntaxError
  stderr: "/tmp/tmp9mv9sowv.swift:79:19: error: expected expression, var, or let in\
    \ 'if' condition\n                if \n                  ^\n/tmp/tmp9mv9sowv.swift:101:70:\
    \ error: expected '}' at end of brace statement\nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Makemake\") == [] as [String])\n                                \
    \                                     ^\n/tmp/tmp9mv9sowv.swift:57:58: note: to\
    \ match this opening '{'\n        if planet1SunSunDistance < planet2SunSunDistance\
    \ {\n                                                         ^\n/tmp/tmp9mv9sowv.swift:101:70:\
    \ error: expected '}' at end of brace statement\nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Makemake\") == [] as [String])\n                                \
    \                                     ^\n/tmp/tmp9mv9sowv.swift:39:48: note: to\
    \ match this opening '{'\n    if planet1SunDistance < planet2SunDistance {\n \
    \                                              ^\n/tmp/tmp9mv9sowv.swift:101:70:\
    \ error: expected '}' at end of brace statement\nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Makemake\") == [] as [String])\n                                \
    \                                     ^\n/tmp/tmp9mv9sowv.swift:15:55: note: to\
    \ match this opening '{'\nfunc bf(planet1: String, planet2: String) -> [String]\
    \ {\n                                                      ^\n/tmp/tmp9mv9sowv.swift:22:24:\
    \ error: cannot find 'orbit' in scope\n    let planet1Orbit = orbit(planet1)\n\
    \                       ^~~~~\n/tmp/tmp9mv9sowv.swift:23:24: error: cannot find\
    \ 'orbit' in scope\n    let planet2Orbit = orbit(planet2)\n                  \
    \     ^~~~~\n/tmp/tmp9mv9sowv.swift:29:22: error: cannot find 'sunOrbit' in scope\n\
    \    let planet1Sun = sunOrbit(planet1)\n                     ^~~~~~~~\n/tmp/tmp9mv9sowv.swift:30:22:\
    \ error: cannot find 'sunOrbit' in scope\n    let planet2Sun = sunOrbit(planet2)\n\
    \                     ^~~~~~~~\n/tmp/tmp9mv9sowv.swift:36:30: error: cannot find\
    \ 'distance' in scope\n    let planet1SunDistance = distance(planet1, planet2)\n\
    \                             ^~~~~~~~\n/tmp/tmp9mv9sowv.swift:37:30: error: cannot\
    \ fin"
  stdout: ''
  timestamp: 1659823231
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    var planets = [String]()\n\
    \    var orbit1 = orbit(planet1)\n    var orbit2 = orbit(planet2)\n    var sun\
    \ = orbit1.sun\n    var sun2 = orbit2.sun\n    var sun3 = orbit1.sun\n    var\
    \ sun4 = orbit2.sun\n    var sun5 = orbit1.sun\n    var sun6 = orbit2.sun\n  \
    \  var sun7 = orbit1.sun\n    var sun8 = orbit2.sun\n    var sun9 = orbit1.sun\n\
    \    var sun10 = orbit2.sun\n    var sun11 = orbit1.sun\n    var sun12 = orbit2.sun\n\
    \    var sun13 = orbit1.sun\n    var sun14 = orbit2.sun\n    var sun15 = orbit1.sun\n\
    \    var sun16 = orbit2.sun\n    var sun17 = orbit1.sun\n    var sun18 = orbit2.sun\n\
    \    var sun19 = orbit1.sun\n    var sun20 = orbit2.sun\n    var sun21 = orbit1.sun\n\
    \    var sun22 = orbit2.sun\n    var sun23 = orbit1.sun\n    var sun24 = orbit2.sun\n\
    \    var sun25 = orbit1.sun\n    var sun26 = orbit2.sun\n    var sun27 = orbit1.sun\n\
    \    var sun28 = orbit2.sun\n    var sun29 = orbit1.sun\n    var sun30 = orbit2.sun\n\
    \    var sun31 = orbit1.sun\n    var sun32 = orbit2.sun\n    var sun33 = orbit1.sun\n\
    \    var sun34 = orbit2.sun\n    var sun35 = orbit1.sun\n    var sun36 = orbit2.sun\n\
    \    var sun37 = orbit1.sun\n    var sun38 = orbit2.sun\n    var sun39 = orbit1.sun\n\
    \    var sun40 = orbit2.sun\n    var sun41 = orbit1.sun\n    var sun42 = orbit2.sun\n\
    \    var sun43 = orbit1.sun\n    var sun44 = orbit2.sun\n    var sun45 = orbit1.sun\n\
    \    var sun46 = orbit2.sun\n    var sun47 = orbit1.sun\n    var sun48 = orbit2.sun\n\
    \    var sun49 = orbit1.sun\n    var sun50 = orbit2.sun\n    var sun51 = orbit1.sun\n\
    \    var sun52 = orbit2.sun\n    var sun53 = orbit1.sun\n    var sun54 = orbit2.sun\n\
    \    var sun55 = orbit1.sun\n    var sun56 = orbit2.sun\n    var sun57 = orbit1.sun\n\
    \    var sun58 = orbit2.sun\n    var sun59 = orbit1.sun\n    var sun60 = orbit2.sun\n\
    \    var sun61 = orbit1.sun\n    var sun62 = orbit2.sun\n    var sun\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\"\
    ) == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\"\
    ) == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"\
    Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\n\
    assert(bf(planet1: \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Makemake\") == [] as [String])"
  status: SyntaxError
  stderr: "/tmp/tmpu1qezcv4.swift:17:18: error: cannot find 'orbit' in scope\n   \
    \ var orbit1 = orbit(planet1)\n                 ^~~~~\n/tmp/tmpu1qezcv4.swift:18:18:\
    \ error: cannot find 'orbit' in scope\n    var orbit2 = orbit(planet2)\n     \
    \            ^~~~~\n/tmp/tmpu1qezcv4.swift:81:9: error: type annotation missing\
    \ in pattern\n    var sun\n        ^\n"
  stdout: ''
  timestamp: 1659823231
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    var result: [String]\
    \ = []\n    \n    if planet1 == planet2 {\n        return result;\n    }\n   \
    \ \n    let planet1Orbit = orbit(planet1)\n    let planet2Orbit = orbit(planet2)\n\
    \    \n    if planet1Orbit == planet2Orbit {\n        return result;\n    }\n\
    \    \n    let planet1Sun = sunOrbit(planet1)\n    let planet2Sun = sunOrbit(planet2)\n\
    \    \n    if planet1Sun == planet2Sun {\n        return result;\n    }\n    \n\
    \    let planet1SunDistance = distance(planet1, planet2)\n    let planet2SunDistance\
    \ = distance(planet2, planet1)\n    \n    if planet1SunDistance < planet2SunDistance\
    \ {\n        let planet1SunDistanceToPlanet2 = planet1SunDistance - planet2SunDistance\n\
    \        let planet2SunDistanceToPlanet1 = planet2SunDistance - planet1SunDistance\n\
    \        \n        let planet1SunDistanceToPlanet2ToPlanet1 = planet1SunDistanceToPlanet2\
    \ - planet2SunDistanceToPlanet1\n        \n        if planet1SunDistanceToPlanet2ToPlanet1\
    \ < 0 {\n            return result;\n        }\n        \n        let planet1SunDistanceToPlanet2ToPlanet1ToPlanet1\
    \ = planet1SunDistanceToPlanet2ToPlanet1 - planet2SunDistanceToPlanet1ToPlanet1\n\
    \        \n        if planet1SunDistanceToPlanet2ToPlanet1ToPlanet1 < 0 {\n  \
    \          return result;\n        }\n        \n        let planet1SunDistanceToPlanet2ToPlanet1ToPlanet1ToPlanet1\
    \ = planet1SunDistanceToPlanet2ToPlanet1ToPlanet1 - planet2SunDistanceToPlanet1ToPlanet1ToPlanet1\n\
    \        \n        if planet1SunDistanceToPlanet2ToPlanet1ToPlanet1ToPlanet1 <\
    \ 0 {\n            return result;\n        }\n        \n        let planet1SunDistanceToPlanet2ToPlanet1ToPlanet1ToPlanet1ToPlanet1\
    \ = planet1SunDistanceToPlanet2ToPlanet1ToPlanet1ToPlanet1 - planet2SunDistanceToPlanet1ToPlanet1ToPlanet1ToPlanet1\n\
    \        \n        if planet1SunDistance\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(bf(planet1: \"Jupiter\", planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"\
    ])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1:\
    \ \"Mercury\", planet2: \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"])\nassert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2:\
    \ \"Earth\") == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\"\
    ) == [] as [String])"
  status: SyntaxError
  stderr: "/tmp/tmplm6u5_id.swift:63:30: error: expected '{' after 'if' condition\n\
    \        if planet1SunDistance\n                             ^\n/tmp/tmplm6u5_id.swift:85:70:\
    \ error: expected '}' at end of brace statement\nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Makemake\") == [] as [String])\n                                \
    \                                     ^\n/tmp/tmplm6u5_id.swift:15:55: note: to\
    \ match this opening '{'\nfunc bf(planet1: String, planet2: String) -> [String]\
    \ {\n                                                      ^\n/tmp/tmplm6u5_id.swift:22:24:\
    \ error: cannot find 'orbit' in scope\n    let planet1Orbit = orbit(planet1)\n\
    \                       ^~~~~\n/tmp/tmplm6u5_id.swift:23:24: error: cannot find\
    \ 'orbit' in scope\n    let planet2Orbit = orbit(planet2)\n                  \
    \     ^~~~~\n/tmp/tmplm6u5_id.swift:29:22: error: cannot find 'sunOrbit' in scope\n\
    \    let planet1Sun = sunOrbit(planet1)\n                     ^~~~~~~~\n/tmp/tmplm6u5_id.swift:30:22:\
    \ error: cannot find 'sunOrbit' in scope\n    let planet2Sun = sunOrbit(planet2)\n\
    \                     ^~~~~~~~\n/tmp/tmplm6u5_id.swift:36:30: error: cannot find\
    \ 'distance' in scope\n    let planet1SunDistance = distance(planet1, planet2)\n\
    \                             ^~~~~~~~\n/tmp/tmplm6u5_id.swift:37:30: error: cannot\
    \ find 'distance' in scope\n    let planet2SunDistance = distance(planet2, planet1)\n\
    \                             ^~~~~~~~\n/tmp/tmplm6u5_id.swift:49:100: error:\
    \ cannot find 'planet2SunDistanceToPlanet1ToPlanet1' in scope\n        let planet1SunDistanceToPlanet2ToPlanet1ToPlanet1\
    \ = planet1SunDistanceToPlanet2ToPlanet1 - planet2SunDistanceToPlanet1ToPlanet1\n\
    \                                                                            \
    \                       ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmplm6u5_id.swift:55:118:\
    \ error: cannot find 'planet2SunDistanceToPlanet1ToPlanet1ToPlanet1' in scope\n\
    \        let planet1SunDistanceToPlanet2ToPlanet1ToPlanet1ToPlanet1 = planet1SunDistanceToPlanet2ToPlanet1ToPlanet1\
    \ - planet2SunDistanceToPlanet1ToPlanet1ToPlanet1\n                 "
  stdout: ''
  timestamp: 1659823231
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    \n    // TODO: Write\
    \ your code here\n    \n    return []\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(bf(planet1: \"Jupiter\", planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"\
    ])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1:\
    \ \"Mercury\", planet2: \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\"\
    , \"Saturn\"])\nassert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\"\
    , planet2: \"Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2:\
    \ \"Earth\") == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\"\
    ) == [] as [String])"
  status: Exception
  stderr: 'tmpbyjxxbwz/tmpbyjxxbwz.swift:35: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b81eae97c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b81eab8eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b81eab8e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b81eab8d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpbyjxxbwz                        0x000055fa1b6d651b <unavailable> + 5403

    5    libc.so.6                          0x00002b81eb083460 __libc_start_main +
    245

    6    tmpbyjxxbwz                        0x000055fa1b6d60c9 <unavailable> + 4297

    '
  stdout: ''
  timestamp: 1659823230
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    var planets = [String]()\n\
    \    \n    // TODO: write your code here\n    \n    return planets\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\"\
    ) == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\"\
    ) == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"\
    Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\n\
    assert(bf(planet1: \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Makemake\") == [] as [String])"
  status: Exception
  stderr: 'tmpxu1j0xgi/tmpxu1j0xgi.swift:36: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac11528bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac114f82b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac114f82988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac114f817b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpxu1j0xgi                        0x0000564f54cf056b <unavailable> + 5483

    5    libc.so.6                          0x00002ac115477460 __libc_start_main +
    245

    6    tmpxu1j0xgi                        0x0000564f54cf0119 <unavailable> + 4377

    '
  stdout: ''
  timestamp: 1659823231
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    var planets = [String]()\n\
    \    \n    if planet1 == planet2 {\n        return planets\n    }\n    \n    if\
    \ planet1 == \"Sun\" {\n        return planets\n    }\n    \n    if planet2 ==\
    \ \"Sun\" {\n        return planets\n    }\n    \n    if planet1 == \"Mercury\"\
    \ {\n        planets.append(\"Venus\")\n        return planets\n    }\n    \n\
    \    if planet2 == \"Mercury\" {\n        planets.append(\"Venus\")\n        return\
    \ planets\n    }\n    \n    if planet1 == \"Venus\" {\n        planets.append(\"\
    Earth\")\n        return planets\n    }\n    \n    if planet2 == \"Venus\" {\n\
    \        planets.append(\"Earth\")\n        return planets\n    }\n    \n    if\
    \ planet1 == \"Earth\" {\n        planets.append(\"Mars\")\n        return planets\n\
    \    }\n    \n    if planet2 == \"Earth\" {\n        planets.append(\"Mars\")\n\
    \        return planets\n    }\n    \n    if planet1 == \"Mars\" {\n        planets.append(\"\
    Jupiter\")\n        return planets\n    }\n    \n    if planet2 == \"Mars\" {\n\
    \        planets.append(\"Jupiter\")\n        return planets\n    }\n    \n  \
    \  if planet1 == \"Jupiter\" {\n        planets.append(\"Saturn\")\n        return\
    \ planets\n    }\n    \n    if planet2 == \"Jupiter\" {\n        planets.append(\"\
    Saturn\")\n        return planets\n    }\n    \n    if planet1 == \"Saturn\" {\n\
    \        planets.append(\"Uranus\")\n        return planets\n    }\n    \n   \
    \ if planet2 == \"Saturn\" {\n        planets.append(\"Uranus\")\n        return\
    \ planets\n    }\n    \n    if planet1 == \"Uranus\" {\n        planets.append(\"\
    Neptune\")\n        return planets\n    }\n    \n    if planet2 == \"Uranus\"\
    \ {\n        planets.append(\"Neptune\")\n        return planets\n    }\n    \n\
    \    if planet1 == \"Neptune\" {\n        return planets\n    }\n    \n    if\
    \ planet2 == \"Neptune\" {\n        return planets\n    }\n    \n    return planets\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\"\
    ) == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\"\
    ) == [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"\
    Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"\
    Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\n\
    assert(bf(planet1: \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Makemake\") == [] as [String])"
  status: Exception
  stderr: 'tmp6yicsb8f/tmp6yicsb8f.swift:124: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b2d52127c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b2d51e1eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b2d51e1e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b2d51e1d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp6yicsb8f                        0x000055c52a2c562b <unavailable> + 5675

    5    libc.so.6                          0x00002b2d52313460 __libc_start_main +
    245

    6    tmp6yicsb8f                        0x000055c52a2c51d9 <unavailable> + 4569

    '
  stdout: ''
  timestamp: 1659823231
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    var result = [String]()\n\
    \    \n    if planet1 == planet2 {\n        return result\n    }\n    \n    if\
    \ planet1 == \"Mercury\" || planet1 == \"Venus\" || planet1 == \"Earth\" || planet1\
    \ == \"Mars\" || planet1 == \"Jupiter\" || planet1 == \"Saturn\" || planet1 ==\
    \ \"Uranus\" || planet1 == \"Neptune\" {\n        if planet2 == \"Mercury\" ||\
    \ planet2 == \"Venus\" || planet2 == \"Earth\" || planet2 == \"Mars\" || planet2\
    \ == \"Jupiter\" || planet2 == \"Saturn\" || planet2 == \"Uranus\" || planet2\
    \ == \"Neptune\" {\n            return result\n        }\n    }\n    \n    if\
    \ planet2 == \"Mercury\" || planet2 == \"Venus\" || planet2 == \"Earth\" || planet2\
    \ == \"Mars\" || planet2 == \"Jupiter\" || planet2 == \"Saturn\" || planet2 ==\
    \ \"Uranus\" || planet2 == \"Neptune\" {\n        if planet1 == \"Mercury\" ||\
    \ planet1 == \"Venus\" || planet1 == \"Earth\" || planet1 == \"Mars\" || planet1\
    \ == \"Jupiter\" || planet1 == \"Saturn\" || planet1 == \"Uranus\" || planet1\
    \ == \"Neptune\" {\n            return result\n        }\n    }\n    \n    if\
    \ planet1 == \"Mercury\" || planet1 == \"Venus\" || planet1 == \"Earth\" || planet1\
    \ == \"Mars\" || planet1 == \"Jupiter\" || planet1 == \"Saturn\" || planet1 ==\
    \ \"Uranus\" || planet1 == \"Neptune\" {\n        if planet2 == \"Mercury\" ||\
    \ planet2 == \"Venus\" || planet2 == \"Earth\" || planet2 == \"Mars\" || planet2\
    \ == \"Jupiter\" || planet2 == \"Saturn\" || planet2 == \"Uranus\" || planet2\
    \ == \"Neptune\" {\n            return result\n        }\n    }\n    \n    if\
    \ planet2 == \"Mercury\" || planet2 == \"Venus\" || planet2 == \"Earth\" || planet2\
    \ == \"Mars\" || planet2 == \"Jupiter\" || planet2 == \"Saturn\" || planet2 ==\
    \ \"Uranus\" || planet2 == \"Neptune\" {\n        if planet1 == \"Mercury\" ||\
    \ planet1 == \"Venus\" || planet1 == \"Earth\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\") == [\"Saturn\", \"\
    Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\") == [\"Venus\"\
    ])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"Neptune\", planet2:\
    \ \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"])\n\
    assert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Makemake\") == [] as [String])"
  status: SyntaxError
  stderr: "/tmp/tmpwu1e0ujv.swift:41:69: error: unterminated string literal\n    \
    \    if planet1 == \"Mercury\" || planet1 == \"Venus\" || planet1 == \"Earth\n\
    \                                                                    ^\n/tmp/tmpwu1e0ujv.swift:63:70:\
    \ error: expected '}' at end of brace statement\nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Makemake\") == [] as [String])\n                                \
    \                                     ^\n/tmp/tmpwu1e0ujv.swift:15:55: note: to\
    \ match this opening '{'\nfunc bf(planet1: String, planet2: String) -> [String]\
    \ {\n                                                      ^\n/tmp/tmpwu1e0ujv.swift:45:6:\
    \ error: operator functions can only be declared at global or in type scope\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1659823231
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    \n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\") == [\"\
    Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\") ==\
    \ [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"Venus\"\
    , \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"Neptune\"\
    , planet2: \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    ])\nassert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Makemake\") == [] as [String])"
  status: SyntaxError
  stderr: '/tmp/tmp3d9bvts2.swift:17:1: error: missing return in global function expected
    to return ''[String]''

    }

    ^

    '
  stdout: ''
  timestamp: 1659823230
- exit_code: -4
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    var planets = [String]()\n\
    \    \n    if planet1 == planet2 {\n        return planets\n    }\n    \n    if\
    \ planet1 == \"Mercury\" {\n        planets = [\"Venus\"]\n    } else if planet1\
    \ == \"Venus\" {\n        planets = [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    , \"Uranus\", \"Neptune\"]\n    } else if planet1 == \"Earth\" {\n        planets\
    \ = [\"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"]\n    } else if\
    \ planet1 == \"Mars\" {\n        planets = [\"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    } else if planet1 == \"Jupiter\" {\n        planets = [\"\
    Saturn\", \"Uranus\", \"Neptune\"]\n    } else if planet1 == \"Saturn\" {\n  \
    \      planets = [\"Uranus\", \"Neptune\"]\n    } else if planet1 == \"Uranus\"\
    \ {\n        planets = [\"Neptune\"]\n    } else if planet1 == \"Neptune\" {\n\
    \        planets = [\"Mercury\", \"Venus\"]\n    }\n    \n    if planet2 == \"\
    Mercury\" {\n        planets = [\"Venus\"]\n    } else if planet2 == \"Venus\"\
    \ {\n        planets = [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    } else if planet2 == \"Earth\" {\n        planets = [\"Mars\"\
    , \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"]\n    } else if planet2 ==\
    \ \"Mars\" {\n        planets = [\"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"\
    ]\n    } else if planet2 == \"Jupiter\" {\n        planets = [\"Saturn\", \"Uranus\"\
    , \"Neptune\"]\n    } else if planet2 == \"Saturn\" {\n        planets = [\"Uranus\"\
    , \"Neptune\"]\n    } else if planet2 == \"Uranus\" {\n        planets = [\"Neptune\"\
    ]\n    } else if planet2 == \"Neptune\" {\n        planets = [\"Mercury\", \"\
    Venus\"]\n    }\n    \n    return planets\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\") == [\"Saturn\", \"\
    Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\") == [\"Venus\"\
    ])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"Venus\", \"Earth\"\
    , \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"Neptune\", planet2:\
    \ \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"])\n\
    assert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Makemake\") == [] as [String])"
  status: Exception
  stderr: 'tmp8grfsni8/tmp8grfsni8.swift:74: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002afa8fef2c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002afa8fbe9b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002afa8fbe9988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002afa8fbe87b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp8grfsni8                        0x0000557d9c5345cb <unavailable> + 5579

    5    libc.so.6                          0x00002afa900de460 __libc_start_main +
    245

    6    tmp8grfsni8                        0x0000557d9c534179 <unavailable> + 4473

    '
  stdout: ''
  timestamp: 1659823230
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    \n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\") == [\"\
    Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\") ==\
    \ [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"Venus\"\
    , \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"Neptune\"\
    , planet2: \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    ])\nassert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Makemake\") == [] as [String])"
  status: SyntaxError
  stderr: '/tmp/tmp3d9bvts2.swift:17:1: error: missing return in global function expected
    to return ''[String]''

    }

    ^

    '
  stdout: ''
  timestamp: 1659823230
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    var result = [String]()\n\
    \    \n    if planet1 == planet2 {\n        return result;\n    }\n    \n    var\
    \ planet1Orbit = orbit(planet1)\n    var planet2Orbit = orbit(planet2)\n    \n\
    \    if planet1Orbit == planet2Orbit {\n        return result;\n    }\n    \n\
    \    var planet1OrbitIndex = index(planet1Orbit)\n    var planet2OrbitIndex =\
    \ index(planet2Orbit)\n    \n    if planet1OrbitIndex < planet2OrbitIndex {\n\
    \        return result;\n    }\n    \n    var planet1OrbitIndex = index(planet1Orbit)\n\
    \    var planet2OrbitIndex = index(planet2Orbit)\n    \n    if planet1OrbitIndex\
    \ > planet2OrbitIndex {\n        return result;\n    }\n    \n    var planet1OrbitIndex\
    \ = index(planet1Orbit)\n    var planet2OrbitIndex = index(planet2Orbit)\n   \
    \ \n    if planet1OrbitIndex == planet2OrbitIndex {\n        if planet1OrbitIndex\
    \ < planet2OrbitIndex {\n            return result;\n        }\n        \n   \
    \     if planet1OrbitIndex > planet2OrbitIndex {\n            return result;\n\
    \        }\n        \n        if planet1OrbitIndex == planet2OrbitIndex {\n  \
    \          if planet1OrbitIndex < planet2OrbitIndex {\n                return\
    \ result;\n            }\n            \n            if planet1OrbitIndex > planet2OrbitIndex\
    \ {\n                return result;\n            }\n        }\n    }\n    \n \
    \   if planet1OrbitIndex < planet2OrbitIndex {\n        return result;\n    }\n\
    \    \n    if planet1OrbitIndex > planet2OrbitIndex {\n        return result;\n\
    \    }\n    \n    if planet1OrbitIndex == planet2OrbitIndex {\n        if planet1OrbitIndex\
    \ < planet2OrbitIndex {\n            return result;\n        }\n        \n   \
    \     if planet1OrbitIndex > planet2OrbitIndex {\n            return result;\n\
    \        }\n        \n        if planet1OrbitIndex == planet2OrbitIndex {\n  \
    \          if planet1OrbitIndex < planet2OrbitIndex {\n                return\
    \ result;\n            }\n            \n            if planet1OrbitIndex > planet2OrbitIndex\
    \ {\n                return result;\n            }\n        }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\") == [\"\
    Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\") ==\
    \ [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"Venus\"\
    , \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"Neptune\"\
    , planet2: \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    ])\nassert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Makemake\") == [] as [String])"
  status: SyntaxError
  stderr: "/tmp/tmplmmfbjo4.swift:113:70: error: expected '}' at end of brace statement\n\
    assert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") == [] as [String])\n  \
    \                                                                   ^\n/tmp/tmplmmfbjo4.swift:15:55:\
    \ note: to match this opening '{'\nfunc bf(planet1: String, planet2: String) ->\
    \ [String] {\n                                                      ^\n/tmp/tmplmmfbjo4.swift:22:24:\
    \ error: cannot find 'orbit' in scope\n    var planet1Orbit = orbit(planet1)\n\
    \                       ^~~~~\n/tmp/tmplmmfbjo4.swift:23:24: error: cannot find\
    \ 'orbit' in scope\n    var planet2Orbit = orbit(planet2)\n                  \
    \     ^~~~~\n/tmp/tmplmmfbjo4.swift:29:29: error: cannot find 'index' in scope\n\
    \    var planet1OrbitIndex = index(planet1Orbit)\n                           \
    \ ^~~~~\n/tmp/tmplmmfbjo4.swift:30:29: error: cannot find 'index' in scope\n \
    \   var planet2OrbitIndex = index(planet2Orbit)\n                            ^~~~~\n\
    /tmp/tmplmmfbjo4.swift:36:29: error: cannot find 'index' in scope\n    var planet1OrbitIndex\
    \ = index(planet1Orbit)\n                            ^~~~~\n/tmp/tmplmmfbjo4.swift:37:29:\
    \ error: cannot find 'index' in scope\n    var planet2OrbitIndex = index(planet2Orbit)\n\
    \                            ^~~~~\n/tmp/tmplmmfbjo4.swift:43:29: error: cannot\
    \ find 'index' in scope\n    var planet1OrbitIndex = index(planet1Orbit)\n   \
    \                         ^~~~~\n/tmp/tmplmmfbjo4.swift:44:29: error: cannot find\
    \ 'index' in scope\n    var planet2OrbitIndex = index(planet2Orbit)\n        \
    \                    ^~~~~\n/tmp/tmplmmfbjo4.swift:95:6: error: operator functions\
    \ can only be declared at global or in type scope\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n     ^\n"
  stdout: ''
  timestamp: 1659823231
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    var result = [String]()\n\
    \    \n    if planet1 == planet2 {\n        return result \n    }\n    \n    let\
    \ planet1Orbit = orbit(planet1)\n    let planet2Orbit = orbit(planet2)\n    \n\
    \    if planet1Orbit == planet2Orbit {\n        return result \n    }\n    \n\
    \    let planet1OrbitDistance = distance(planet1Orbit)\n    let planet2OrbitDistance\
    \ = distance(planet2Orbit)\n    \n    if planet1OrbitDistance < planet2OrbitDistance\
    \ {\n        result.insert(planet1)\n        result.insert(planet2)\n    } else\
    \ {\n        result.insert(planet2)\n        result.insert(planet1)\n    }\n \
    \   \n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(bf(planet1:\
    \ \"Jupiter\", planet2: \"Neptune\") == [\"Saturn\", \"Uranus\"])\nassert(bf(planet1:\
    \ \"Earth\", planet2: \"Mercury\") == [\"Venus\"])\nassert(bf(planet1: \"Mercury\"\
    , planet2: \"Uranus\") == [\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"\
    ])\nassert(bf(planet1: \"Neptune\", planet2: \"Venus\") == [\"Earth\", \"Mars\"\
    , \"Jupiter\", \"Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2:\
    \ \"Earth\") == [] as [String])\nassert(bf(planet1: \"Mars\", planet2: \"Earth\"\
    ) == [] as [String])\nassert(bf(planet1: \"Jupiter\", planet2: \"Makemake\") ==\
    \ [] as [String])"
  status: SyntaxError
  stderr: "/tmp/tmpoux63_ch.swift:22:24: error: cannot find 'orbit' in scope\n   \
    \ let planet1Orbit = orbit(planet1)\n                       ^~~~~\n/tmp/tmpoux63_ch.swift:23:24:\
    \ error: cannot find 'orbit' in scope\n    let planet2Orbit = orbit(planet2)\n\
    \                       ^~~~~\n/tmp/tmpoux63_ch.swift:29:32: error: cannot find\
    \ 'distance' in scope\n    let planet1OrbitDistance = distance(planet1Orbit)\n\
    \                               ^~~~~~~~\n/tmp/tmpoux63_ch.swift:30:32: error:\
    \ cannot find 'distance' in scope\n    let planet2OrbitDistance = distance(planet2Orbit)\n\
    \                               ^~~~~~~~\n/tmp/tmpoux63_ch.swift:33:30: error:\
    \ missing argument for parameter 'at' in call\n        result.insert(planet1)\n\
    \                             ^\n                             , at: <#Int#>\n\
    Swift.Array:11:37: note: 'insert(_:at:)' declared here\n    @inlinable public\
    \ mutating func insert(_ newElement: __owned Element, at i: Int)\n           \
    \                         ^\n/tmp/tmpoux63_ch.swift:34:30: error: missing argument\
    \ for parameter 'at' in call\n        result.insert(planet2)\n               \
    \              ^\n                             , at: <#Int#>\nSwift.Array:11:37:\
    \ note: 'insert(_:at:)' declared here\n    @inlinable public mutating func insert(_\
    \ newElement: __owned Element, at i: Int)\n                                  \
    \  ^\n/tmp/tmpoux63_ch.swift:36:30: error: missing argument for parameter 'at'\
    \ in call\n        result.insert(planet2)\n                             ^\n  \
    \                           , at: <#Int#>\nSwift.Array:11:37: note: 'insert(_:at:)'\
    \ declared here\n    @inlinable public mutating func insert(_ newElement: __owned\
    \ Element, at i: Int)\n                                    ^\n/tmp/tmpoux63_ch.swift:37:30:\
    \ error: missing argument for parameter 'at' in call\n        result.insert(planet1)\n\
    \                             ^\n                             , at: <#Int#>\n\
    Swift.Array:11:37: note: 'insert(_:at:)' declared here\n    @inlinable public\
    \ mutating func insert(_ newElement: __owned Element, at i: Int)\n           \
    \                         ^\n"
  stdout: ''
  timestamp: 1659823231
- exit_code: 1
  program: "\n/// There are eight planets in our solar system: the closerst to the\
    \ Sun \n/// is Mercury, the next one is Venus, then Earth, Mars, Jupiter, Saturn,\
    \ \n/// Uranus, Neptune.\n/// Write a function that takes two planet names as\
    \ strings planet1 and planet2. \n/// The function should return a tuple containing\
    \ all planets whose orbits are \n/// located between the orbit of planet1 and\
    \ the orbit of planet2, sorted by \n/// the proximity to the sun. \n/// The function\
    \ should return an empty tuple if planet1 or planet2\n/// are not correct planet\
    \ names. \n/// Examples\n/// bf(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"\
    Uranus\")\n/// bf(\"Earth\", \"Mercury\") ==> (\"Venus\")\n/// bf(\"Mercury\"\
    , \"Uranus\") ==> (\"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\")\n\
    func bf(planet1: String, planet2: String) -> [String] {\n    var planets = [String]()\n\
    \    \n    if planet1 == planet2 {\n        return planets\n    }\n    \n    if\
    \ planet1 == \"Mercury\" || planet1 == \"Venus\" || planet1 == \"Earth\" || planet1\
    \ == \"Mars\" || planet1 == \"Jupiter\" || planet1 == \"Saturn\" || planet1 ==\
    \ \"Uranus\" || planet1 == \"Neptune\" {\n        planets.append(planet1)\n  \
    \  }\n    \n    if planet2 == \"Mercury\" || planet2 == \"Venus\" || planet2 ==\
    \ \"Earth\" || planet2 == \"Mars\" || planet2 == \"Jupiter\" || planet2 == \"\
    Saturn\" || planet2 == \"Uranus\" || planet2 == \"Neptune\" {\n        planets.append(planet2)\n\
    \    }\n    \n    if planet1 == \"Mercury\" || planet1 == \"Venus\" || planet1\
    \ == \"Earth\" || planet1 == \"Mars\" || planet1 == \"Jupiter\" || planet1 ==\
    \ \"Saturn\" || planet1 == \"Uranus\" || planet1 == \"Neptune\" {\n        planets.append(planet2)\n\
    \    }\n    \n    if planet2 == \"Mercury\" || planet2 == \"Venus\" || planet2\
    \ == \"Earth\" || planet2 == \"Mars\" || planet2 == \"Jupiter\" || planet2 ==\
    \ \"Saturn\" || planet2 == \"Uranus\" || planet2 == \"Neptune\" {\n        planets.append(planet1)\n\
    \    }\n    \n    if planet1 == \"Mercury\" || planet1 == \"Venus\" || planet1\
    \ == \"Earth\" || planet1 == \"Mars\" || planet1 == \"Jupiter\" || planet1 ==\
    \ \"Saturn\" || planet1 == \"Uranus\" || planet1 == \"Neptune\" {\n        planets.append(planet2)\n\
    \    }\n    \n    if planet2 == \"Mercury\" || planet2 == \"Venus\" || planet2\
    \ == \"Earth\" || planet2 == \"Mars\" || planet2 == \"Jupiter\" || planet2 ==\
    \ \"Saturn\" || planet2 == \"Uranus\" || planet2 == \"Neptune\" {\n        planets.append(planet1)\n\
    \    }\n    \n    if planet1 == \"Mercury\" || planet1 == \"Venus\" || planet1\
    \ == \"Earth\" || planet1 == \"Mars\" || planet1 == \"Jup\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(bf(planet1: \"Jupiter\", planet2: \"Neptune\") == [\"\
    Saturn\", \"Uranus\"])\nassert(bf(planet1: \"Earth\", planet2: \"Mercury\") ==\
    \ [\"Venus\"])\nassert(bf(planet1: \"Mercury\", planet2: \"Uranus\") == [\"Venus\"\
    , \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\"])\nassert(bf(planet1: \"Neptune\"\
    , planet2: \"Venus\") == [\"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\"\
    ])\nassert(bf(planet1: \"Earth\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1:\
    \ \"Mars\", planet2: \"Earth\") == [] as [String])\nassert(bf(planet1: \"Jupiter\"\
    , planet2: \"Makemake\") == [] as [String])"
  status: SyntaxError
  stderr: "/tmp/tmp4i4zkkv1.swift:46:108: error: unterminated string literal\n   \
    \ if planet1 == \"Mercury\" || planet1 == \"Venus\" || planet1 == \"Earth\" ||\
    \ planet1 == \"Mars\" || planet1 == \"Jup\n                                  \
    \                                                                         ^\n"
  stdout: ''
  timestamp: 1659823230
