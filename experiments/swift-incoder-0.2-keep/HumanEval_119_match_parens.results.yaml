language: swift
name: HumanEval_119_match_parens
results:
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = Stack()\n    for s in lst {\n       \
    \ if s == '(' {\n            stack.push(s)\n        } else if s == ')' {\n   \
    \         if stack.top() == '(' {\n                stack.pop()\n            }\
    \ else {\n                return \"No\"\n            }\n        } else {\n   \
    \         return \"No\"\n        }\n    }\n    if stack.top() != nil {\n     \
    \   return \"No\"\n    } else {\n        return \"Yes\"\n    }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmp9044s0w7.swift:16:17: error: single-quoted string literal found,\
    \ use '\"'\n        if s == '(' {\n                ^~~\n                \"(\"\n\
    /tmp/tmp9044s0w7.swift:18:24: error: single-quoted string literal found, use '\"\
    '\n        } else if s == ')' {\n                       ^~~\n                \
    \       \")\"\n/tmp/tmp9044s0w7.swift:19:31: error: single-quoted string literal\
    \ found, use '\"'\n            if stack.top() == '(' {\n                     \
    \         ^~~\n                              \"(\"\n/tmp/tmp9044s0w7.swift:14:17:\
    \ error: cannot find 'Stack' in scope\n    var stack = Stack()\n             \
    \   ^~~~~\n"
  stdout: ''
  timestamp: 1659824803
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n  \
    \      } else if s == \")\" {\n            if stack.isEmpty {\n              \
    \  result = \"Yes\"\n                break\n            } else {\n           \
    \     stack.removeLast()\n            }\n        } else {\n            if stack.isEmpty\
    \ {\n                result = \"Yes\"\n                break\n            }\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmp3mn4qtum/tmp3mn4qtum.swift:50: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b44c6380c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b44c6077b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b44c6077988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b44c60767b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp3mn4qtum                        0x000055d5c0410960 <unavailable> + 6496

    5    libc.so.6                          0x00002b44c656c460 __libc_start_main +
    245

    6    tmp3mn4qtum                        0x000055d5c04103d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659824803
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    for s in lst {\n    \
    \    if s == \"(\" {\n            stack.append(s)\n        } else if s == \")\"\
    \ {\n            if stack.count > 0 {\n                stack.removeLast()\n  \
    \          } else {\n                return \"No\"\n            }\n        } else\
    \ {\n            return \"No\"\n        }\n    }\n    if stack.count > 0 {\n \
    \       return \"No\"\n    } else {\n        return \"Yes\"\n    }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmperot8zk6/tmperot8zk6.swift:48: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b09a9bcec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b09a98c5b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b09a98c5988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b09a98c47b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmperot8zk6                        0x000055adb572c7f6 <unavailable> + 6134

    5    libc.so.6                          0x00002b09a9dba460 __libc_start_main +
    245

    6    tmperot8zk6                        0x000055adb572c3d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659824803
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n  \
    \      } else if s == \")\" {\n            if stack.isEmpty {\n              \
    \  result = \"No\"\n                break\n            }\n            stack.removeLast()\n\
    \        } else {\n            if stack.isEmpty {\n                result = \"\
    Yes\"\n                break\n            }\n            stack.removeLast()\n\
    \            stack.append(s)\n        }\n    }\n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmper3pjgt7/tmper3pjgt7.swift:52: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b8f9a0dec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8f99dd5b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b8f99dd5988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b8f99dd47b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmper3pjgt7                        0x00005596ce385aeb <unavailable> + 6891

    5    libc.so.6                          0x00002b8f9a2ca460 __libc_start_main +
    245

    6    tmper3pjgt7                        0x00005596ce3853d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659824804
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n  \
    \      } else if s == \")\" {\n            if stack.count > 0 {\n            \
    \    stack.removeLast()\n            } else {\n                result = \"Yes\"\
    \n            }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmp3rvtwdo_/tmp3rvtwdo_.swift:44: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b2dbaa72c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b2dba769b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b2dba769988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b2dba7687b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp3rvtwdo_                        0x000055e109e92960 <unavailable> + 6496

    5    libc.so.6                          0x00002b2dbac5e460 __libc_start_main +
    245

    6    tmp3rvtwdo_                        0x000055e109e923d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659824803
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n  \
    \      } else if s == \")\" {\n            if stack.isEmpty {\n              \
    \  result = \"Yes\"\n                break\n            }\n            stack.removeLast()\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmpc9tow60w/tmpc9tow60w.swift:44: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab676de7c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab676adeb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab676ade988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab676add7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpc9tow60w                        0x0000555f05973960 <unavailable> + 6496

    5    libc.so.6                          0x00002ab676fd3460 __libc_start_main +
    245

    6    tmpc9tow60w                        0x0000555f059733d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659824804
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = Stack()\n    for s in lst {\n       \
    \ if s == '(' {\n            stack.push(s)\n        } else if s == ')' {\n   \
    \         if stack.top() == '(' {\n                stack.pop()\n            }\
    \ else {\n                return \"No\"\n            }\n        } else {\n   \
    \         return \"No\"\n        }\n    }\n    if stack.top() != nil {\n     \
    \   return \"No\"\n    } else {\n        return \"Yes\"\n    }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmp9044s0w7.swift:16:17: error: single-quoted string literal found,\
    \ use '\"'\n        if s == '(' {\n                ^~~\n                \"(\"\n\
    /tmp/tmp9044s0w7.swift:18:24: error: single-quoted string literal found, use '\"\
    '\n        } else if s == ')' {\n                       ^~~\n                \
    \       \")\"\n/tmp/tmp9044s0w7.swift:19:31: error: single-quoted string literal\
    \ found, use '\"'\n            if stack.top() == '(' {\n                     \
    \         ^~~\n                              \"(\"\n/tmp/tmp9044s0w7.swift:14:17:\
    \ error: cannot find 'Stack' in scope\n    var stack = Stack()\n             \
    \   ^~~~~\n"
  stdout: ''
  timestamp: 1659824803
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n  \
    \      } else if s == \")\" {\n            if stack.isEmpty {\n              \
    \  result = \"Yes\"\n                break\n            }\n            stack.removeLast()\n\
    \        } else {\n            if stack.isEmpty {\n                result = \"\
    Yes\"\n                break\n            }\n            stack.removeLast()\n\
    \            stack.append(s)\n        }\n    }\n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmp5yctdyd3/tmp5yctdyd3.swift:51: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b27a36e3c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b27a33dab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b27a33da988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b27a33d97b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp5yctdyd3                        0x000056491dca9960 <unavailable> + 6496

    5    libc.so.6                          0x00002b27a38cf460 __libc_start_main +
    245

    6    tmp5yctdyd3                        0x000056491dca93d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659824803
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s.contains(\"(\") {\n            stack.append(s)\n\
    \        } else {\n            if stack.count > 0 {\n                if stack[stack.count\
    \ - 1] == s {\n                    stack.removeLast()\n                } else\
    \ {\n                    result = \"No\"\n                    break\n        \
    \        }\n            } else {\n                result = \"Yes\"\n         \
    \       break\n            }\n        }\n    }\n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpfh634lob/tmpfh634lob.swift:49: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aea44d56c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aea44a4db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aea44a4d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aea44a4c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpfh634lob                        0x0000561336e189c6 <unavailable> + 6598

    5    libc.so.6                          0x00002aea44f42460 __libc_start_main +
    245

    6    tmpfh634lob                        0x0000561336e185a9 <unavailable> + 5545

    '
  stdout: ''
  timestamp: 1659824804
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = Stack()\n    var result = \"No\"\n  \
    \  for s in lst {\n        if s == \"(\" || s == \")\" {\n            stack.push(s)\n\
    \        } else {\n            if stack.len() == 0 {\n                result =\
    \ \"No\"\n                break\n            }\n            result == \"Yes\"\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpmka3ykp3.swift:14:17: error: cannot find 'Stack' in scope\n   \
    \ var stack = Stack()\n                ^~~~~\n/tmp/tmpmka3ykp3.swift:24:20: warning:\
    \ result of operator '==' is unused\n            result == \"Yes\"\n         \
    \   ~~~~~~ ^  ~~~~~\n"
  stdout: ''
  timestamp: 1659824803
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s.contains(\"(\") {\n            stack.append(s)\n\
    \        } else if s.contains(\")\") {\n            if stack.count > 0 {\n   \
    \             stack.removeLast()\n            } else {\n                result\
    \ = \"Yes\"\n            }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmp92jtdhou/tmp92jtdhou.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b59c9667c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b59c935eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b59c935e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b59c935d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp92jtdhou                        0x0000562346572976 <unavailable> + 6518

    5    libc.so.6                          0x00002b59c9853460 __libc_start_main +
    245

    6    tmp92jtdhou                        0x0000562346572559 <unavailable> + 5465

    '
  stdout: ''
  timestamp: 1659824803
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = Stack()\n    for s in lst {\n       \
    \ if s == '(' {\n            stack.push(s)\n        } else if s == ')' {\n   \
    \         if stack.top() == '(' {\n                stack.pop()\n            }\
    \ else {\n                return \"No\"\n            }\n        } else {\n   \
    \         return \"No\"\n        }\n    }\n    if stack.top() != nil {\n     \
    \   return \"No\"\n    } else {\n        return \"Yes\"\n    }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmp9044s0w7.swift:16:17: error: single-quoted string literal found,\
    \ use '\"'\n        if s == '(' {\n                ^~~\n                \"(\"\n\
    /tmp/tmp9044s0w7.swift:18:24: error: single-quoted string literal found, use '\"\
    '\n        } else if s == ')' {\n                       ^~~\n                \
    \       \")\"\n/tmp/tmp9044s0w7.swift:19:31: error: single-quoted string literal\
    \ found, use '\"'\n            if stack.top() == '(' {\n                     \
    \         ^~~\n                              \"(\"\n/tmp/tmp9044s0w7.swift:14:17:\
    \ error: cannot find 'Stack' in scope\n    var stack = Stack()\n             \
    \   ^~~~~\n"
  stdout: ''
  timestamp: 1659824803
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = Stack()\n    var res = \"\"\n    for\
    \ s in lst {\n        if s == \"(\" || s == \")\" {\n            stack.push(s)\n\
    \        } else {\n            if stack.len() == 0 {\n                res += s\n\
    \            } else {\n                let top = stack.top()\n               \
    \ if top == \"(\" && s == \"(\" || top == \"(\" && s == \")\" {\n            \
    \        stack.pop()\n                } else {\n                    res += top\n\
    \                }\n            }\n        }\n    }\n    return res == \"\" ?\
    \ \"No\" : \"Yes\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmphlmplvgr.swift:14:17: error: cannot find 'Stack' in scope\n   \
    \ var stack = Stack()\n                ^~~~~\n"
  stdout: ''
  timestamp: 1659824803
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s.contains(\"(\") {\n            stack.append(s)\n\
    \        } else if s.contains(\")\") {\n            if stack.count > 0 {\n   \
    \             stack.removeLast()\n            } else {\n                result\
    \ = \"Yes\"\n            }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmp92jtdhou/tmp92jtdhou.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b59c9667c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b59c935eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b59c935e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b59c935d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp92jtdhou                        0x0000562346572976 <unavailable> + 6518

    5    libc.so.6                          0x00002b59c9853460 __libc_start_main +
    245

    6    tmp92jtdhou                        0x0000562346572559 <unavailable> + 5465

    '
  stdout: ''
  timestamp: 1659824803
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n  \
    \      } else if s == \")\" {\n            if stack.isEmpty {\n              \
    \  result = \"Yes\"\n                break\n            } else {\n           \
    \     stack.removeLast()\n            }\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmp7eihgb1y/tmp7eihgb1y.swift:45: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b11fece8c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b11fe9dfb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b11fe9df988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b11fe9de7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp7eihgb1y                        0x0000559d7ffc8960 <unavailable> + 6496

    5    libc.so.6                          0x00002b11feed4460 __libc_start_main +
    245

    6    tmp7eihgb1y                        0x0000559d7ffc83d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659824804
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n  \
    \      } else if s == \")\" {\n            if stack.isEmpty {\n              \
    \  result = \"Yes\"\n                break\n            } else {\n           \
    \     stack.removeLast()\n            }\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmp7eihgb1y/tmp7eihgb1y.swift:45: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b11fece8c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b11fe9dfb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b11fe9df988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b11fe9de7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp7eihgb1y                        0x0000559d7ffc8960 <unavailable> + 6496

    5    libc.so.6                          0x00002b11feed4460 __libc_start_main +
    245

    6    tmp7eihgb1y                        0x0000559d7ffc83d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659824804
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n  \
    \      } else if s == \")\" {\n            if stack.isEmpty {\n              \
    \  result = \"Yes\"\n                break\n            } else {\n           \
    \     stack.removeLast()\n            }\n        } else {\n            if stack.isEmpty\
    \ {\n                result = \"Yes\"\n                break\n            }\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmp3mn4qtum/tmp3mn4qtum.swift:50: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b44c6380c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b44c6077b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b44c6077988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b44c60767b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp3mn4qtum                        0x000055d5c0410960 <unavailable> + 6496

    5    libc.so.6                          0x00002b44c656c460 __libc_start_main +
    245

    6    tmp3mn4qtum                        0x000055d5c04103d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659824803
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n  \
    \      } else if s == \")\" {\n            if stack.isEmpty {\n              \
    \  result = \"Yes\"\n                break\n            }\n            stack.removeLast()\n\
    \        } else {\n            if stack.isEmpty {\n                result = \"\
    Yes\"\n                break\n            }\n            stack.removeLast()\n\
    \            stack.append(s)\n        }\n    }\n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmp5yctdyd3/tmp5yctdyd3.swift:51: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b27a36e3c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b27a33dab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b27a33da988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b27a33d97b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp5yctdyd3                        0x000056491dca9960 <unavailable> + 6496

    5    libc.so.6                          0x00002b27a38cf460 __libc_start_main +
    245

    6    tmp5yctdyd3                        0x000056491dca93d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659824803
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfunc match_parens(lst:\
    \ [String]) -> String {\n    guard lst.count >= 2 else { return \"No\" }\n   \
    \ guard lst[0] == \")\" && lst[1] == \")\" else { return \"No\" }\n    var stack\
    \ = [String]()\n    var result = \"No\"\n    for str in lst {\n        if str\
    \ == \"(\" {\n            stack.append(str)\n        } else if str == \")\" {\n\
    \            if stack.count > 0 {\n                stack.removeLast()\n      \
    \      } else {\n                result = \"Yes\"\n            }\n        }\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmp7k4nv79k/tmp7k4nv79k.swift:45: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aaf9c1c6c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aaf9bebdb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aaf9bebd988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aaf9bebc7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp7k4nv79k                        0x0000556b376d8846 <unavailable> + 6214

    5    libc.so.6                          0x00002aaf9c3b2460 __libc_start_main +
    245

    6    tmp7k4nv79k                        0x0000556b376d8429 <unavailable> + 5161

    '
  stdout: ''
  timestamp: 1659824804
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s == \"(\" || s == \")\" {\n            if stack.isEmpty\
    \ {\n                result = \"Yes\"\n                break\n            }\n\
    \            if stack[stack.count - 1] == s {\n                stack.removeLast()\n\
    \            } else {\n                result = \"No\"\n                break\n\
    \            }\n        } else {\n            stack.append(s)\n        }\n   \
    \ }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmp4ijhfg_0/tmp4ijhfg_0.swift:48: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b2772d84c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b2772a7bb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b2772a7b988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b2772a7a7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp4ijhfg_0                        0x0000560b850e68a6 <unavailable> + 6310

    5    libc.so.6                          0x00002b2772f70460 __libc_start_main +
    245

    6    tmp4ijhfg_0                        0x0000560b850e6489 <unavailable> + 5257

    '
  stdout: ''
  timestamp: 1659824804
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n  \
    \      } else if s == \")\" {\n            if stack.count > 0 {\n            \
    \    stack.removeLast()\n            } else {\n                result = \"Yes\"\
    \n            }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmp3rvtwdo_/tmp3rvtwdo_.swift:44: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b2dbaa72c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b2dba769b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b2dba769988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b2dba7687b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp3rvtwdo_                        0x000055e109e92960 <unavailable> + 6496

    5    libc.so.6                          0x00002b2dbac5e460 __libc_start_main +
    245

    6    tmp3rvtwdo_                        0x000055e109e923d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659824803
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    for s in lst {\n    \
    \    if s.contains(\"(\") {\n            stack.append(s)\n        } else if s.contains(\"\
    )\") {\n            if stack.count > 0 {\n                let first = stack.removeLast()\n\
    \                let last = s\n                stack.append(first + last)\n  \
    \          }\n        }\n    }\n    if stack.count > 0 {\n        return \"No\"\
    \n    } else {\n        return \"Yes\"\n    }\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmpkdk7w5ul/tmpkdk7w5ul.swift:46: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae240cdbc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae2409d2b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae2409d2988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae2409d17b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpkdk7w5ul                        0x00005631a1d559c6 <unavailable> + 6598

    5    libc.so.6                          0x00002ae240ec7460 __libc_start_main +
    245

    6    tmpkdk7w5ul                        0x00005631a1d555a9 <unavailable> + 5545

    '
  stdout: ''
  timestamp: 1659824804
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n  \
    \      } else if s == \")\" {\n            if stack.count > 0 {\n            \
    \    stack.removeLast()\n            } else {\n                result = \"Yes\"\
    \n                break\n            }\n        } else {\n            if stack.count\
    \ > 0 {\n                stack.removeLast()\n            } else {\n          \
    \      result = \"Yes\"\n                break\n            }\n        }\n   \
    \ }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpnjqxofwj/tmpnjqxofwj.swift:52: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ace25c5dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ace25954b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ace25954988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ace259537b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpnjqxofwj                        0x00005645f972a960 <unavailable> + 6496

    5    libc.so.6                          0x00002ace25e49460 __libc_start_main +
    245

    6    tmpnjqxofwj                        0x00005645f972a3d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659824804
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n  \
    \      } else if s == \")\" {\n            if stack.isEmpty {\n              \
    \  result = \"Yes\"\n                break\n            }\n            stack.removeLast()\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmpc9tow60w/tmpc9tow60w.swift:44: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab676de7c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab676adeb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab676ade988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab676add7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpc9tow60w                        0x0000555f05973960 <unavailable> + 6496

    5    libc.so.6                          0x00002ab676fd3460 __libc_start_main +
    245

    6    tmpc9tow60w                        0x0000555f059733d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659824804
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n  \
    \      } else if s == \")\" {\n            if stack.isEmpty {\n              \
    \  result = \"No\"\n                break\n            } else {\n            \
    \    stack.removeLast()\n            }\n        } else {\n            if stack.isEmpty\
    \ {\n                result = \"Yes\"\n                break\n            }\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmpc1dl9p67/tmpc1dl9p67.swift:51: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac9450f2c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac944de9b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac944de9988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac944de87b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpc1dl9p67                        0x000055897db1aaeb <unavailable> + 6891

    5    libc.so.6                          0x00002ac9452de460 __libc_start_main +
    245

    6    tmpc1dl9p67                        0x000055897db1a3d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659824804
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfunc match_parens(lst:\
    \ [String]) -> String {\n    guard lst.count >= 2 else { return \"No\" }\n   \
    \ guard lst[0] == \"(\" && lst[lst[0].length - 1] == \")\" else { return \"No\"\
    \ }\n    var stack = [String]()\n    var result = \"No\"\n    for s in lst {\n\
    \        if s == \"(\" {\n            stack.append(s)\n        } else if s ==\
    \ \")\" {\n            if stack.count > 0 {\n                stack.removeLast()\n\
    \            } else {\n                result = \"Yes\"\n            }\n     \
    \   }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpad4q3b7z.swift:15:39: error: value of type 'String' has no member\
    \ 'length'\n    guard lst[0] == \"(\" && lst[lst[0].length - 1] == \")\" else\
    \ { return \"No\" }\n                               ~~~~~~ ^~~~~~\n"
  stdout: ''
  timestamp: 1659824803
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n  \
    \      } else if s == \")\" {\n            if stack.isEmpty {\n              \
    \  result = \"No\"\n            } else {\n                stack.removeLast()\n\
    \            }\n        } else {\n            if stack.isEmpty {\n           \
    \     result = \"Yes\"\n            } else {\n                stack.removeLast()\n\
    \            }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmp5dj0p34v/tmp5dj0p34v.swift:49: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b8ca084ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8ca0541b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b8ca0541988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b8ca05407b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp5dj0p34v                        0x000056319731d7f6 <unavailable> + 6134

    5    libc.so.6                          0x00002b8ca0a36460 __libc_start_main +
    245

    6    tmp5dj0p34v                        0x000056319731d3d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659824804
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n  \
    \      } else if s == \")\" {\n            if stack.isEmpty {\n              \
    \  result = \"Yes\"\n                break\n            }\n            stack.removeLast()\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmpc9tow60w/tmpc9tow60w.swift:44: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab676de7c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab676adeb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab676ade988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab676add7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpc9tow60w                        0x0000555f05973960 <unavailable> + 6496

    5    libc.so.6                          0x00002ab676fd3460 __libc_start_main +
    245

    6    tmpc9tow60w                        0x0000555f059733d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659824804
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    for s in lst {\n    \
    \    if s == \"(\" {\n            stack.append(s)\n        } else if s == \")\"\
    \ {\n            if stack.isEmpty {\n                return \"No\"\n         \
    \   }\n            stack.removeLast()\n        } else {\n            if stack.isEmpty\
    \ {\n                return \"Yes\"\n            }\n            stack.removeLast()\n\
    \            stack.append(s)\n        }\n    }\n    return \"No\"\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpjdm8qf06/tmpjdm8qf06.swift:49: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af76b519c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af76b210b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af76b210988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af76b20f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpjdm8qf06                        0x0000558bea806aeb <unavailable> + 6891

    5    libc.so.6                          0x00002af76b705460 __libc_start_main +
    245

    6    tmpjdm8qf06                        0x0000558bea8063d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659824803
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n  \
    \      } else if s == \")\" {\n            if stack.isEmpty {\n              \
    \  result = \"No\"\n                break\n            }\n            stack.removeLast()\n\
    \        } else {\n            if stack.isEmpty {\n                result = \"\
    Yes\"\n                break\n            }\n            stack.removeLast()\n\
    \            stack.append(s)\n        }\n    }\n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmper3pjgt7/tmper3pjgt7.swift:52: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b8f9a0dec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8f99dd5b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b8f99dd5988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b8f99dd47b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmper3pjgt7                        0x00005596ce385aeb <unavailable> + 6891

    5    libc.so.6                          0x00002b8f9a2ca460 __libc_start_main +
    245

    6    tmper3pjgt7                        0x00005596ce3853d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659824804
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n  \
    \      } else if s == \")\" {\n            if stack.isEmpty {\n              \
    \  result = \"Yes\"\n                break\n            }\n            stack.removeLast()\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmpc9tow60w/tmpc9tow60w.swift:44: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab676de7c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab676adeb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab676ade988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab676add7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpc9tow60w                        0x0000555f05973960 <unavailable> + 6496

    5    libc.so.6                          0x00002ab676fd3460 __libc_start_main +
    245

    6    tmpc9tow60w                        0x0000555f059733d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659824804
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s.contains(\"(\") {\n            stack.append(s)\n\
    \        }\n        if s.contains(\")\") {\n            if stack.count > 0 {\n\
    \                stack.removeLast()\n            }\n        }\n    }\n    if stack.count\
    \ == 0 {\n        result = \"Yes\"\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmpav8efsnq/tmpav8efsnq.swift:46: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba043cb1c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba0439a8b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba0439a8988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba0439a77b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpav8efsnq                        0x0000559fc7148ae0 <unavailable> + 6880

    5    libc.so.6                          0x00002ba043e9d460 __libc_start_main +
    245

    6    tmpav8efsnq                        0x0000559fc7148559 <unavailable> + 5465

    '
  stdout: ''
  timestamp: 1659824803
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n  \
    \      } else if s == \")\" {\n            if stack.isEmpty {\n              \
    \  result = \"Yes\"\n                break\n            } else {\n           \
    \     stack.removeLast()\n            }\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmp7eihgb1y/tmp7eihgb1y.swift:45: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b11fece8c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b11fe9dfb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b11fe9df988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b11fe9de7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp7eihgb1y                        0x0000559d7ffc8960 <unavailable> + 6496

    5    libc.so.6                          0x00002b11feed4460 __libc_start_main +
    245

    6    tmp7eihgb1y                        0x0000559d7ffc83d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659824804
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n  \
    \      } else if s == \")\" {\n            if stack.last == \"(\" {\n        \
    \        stack.removeLast()\n            } else {\n                result = \"\
    No\"\n                break\n            }\n        } else {\n            if stack.last\
    \ == \"(\" {\n                stack.removeLast()\n            } else {\n     \
    \           result = \"No\"\n                break\n            }\n        }\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpmes1bcwb/tmpmes1bcwb.swift:51: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b90fa27ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b90f9f71b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b90f9f71988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b90f9f707b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpmes1bcwb                        0x0000557f413197f6 <unavailable> + 6134

    5    libc.so.6                          0x00002b90fa466460 __libc_start_main +
    245

    6    tmpmes1bcwb                        0x0000557f413193d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659824804
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfunc match_parens(lst:\
    \ [String]) -> String {\n    guard lst.count >= 2 else { return \"No\" }\n   \
    \ var stack = [String]()\n    var result = \"No\"\n    for s in lst {\n      \
    \  if s == \"(\" {\n            stack.append(s)\n        } else if s == \")\"\
    \ {\n            if stack.count > 0 {\n                stack.removeLast()\n  \
    \          } else {\n                result = \"Yes\"\n                break\n\
    \            }\n        } else {\n            if stack.count == 0 {\n        \
    \        result = \"No\"\n                break\n            }\n        }\n  \
    \  }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmp10qonbkk/tmp10qonbkk.swift:50: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b8ed72cfc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8ed6fc6b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b8ed6fc6988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b8ed6fc57b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp10qonbkk                        0x0000562f6567e7f6 <unavailable> + 6134

    5    libc.so.6                          0x00002b8ed74bb460 __libc_start_main +
    245

    6    tmp10qonbkk                        0x0000562f6567e3d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659824804
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s.contains(\"(\") {\n            stack.append(s)\n\
    \        } else if s.contains(\")\") {\n            if stack.count > 0 {\n   \
    \             let top = stack.removeLast()\n                if top == s {\n  \
    \                  result = \"Yes\"\n                    break\n             \
    \   }\n            }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmpp4b_dx5o/tmpp4b_dx5o.swift:45: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ada5cbf3c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ada5c8eab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ada5c8ea988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ada5c8e97b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpp4b_dx5o                        0x00005609eeffb976 <unavailable> + 6518

    5    libc.so.6                          0x00002ada5cddf460 __libc_start_main +
    245

    6    tmpp4b_dx5o                        0x00005609eeffb559 <unavailable> + 5465

    '
  stdout: ''
  timestamp: 1659824804
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n  \
    \      } else if s == \")\" {\n            if stack.isEmpty {\n              \
    \  result = \"Yes\"\n                break\n            } else {\n           \
    \     stack.removeLast()\n            }\n        } else {\n            if stack.isEmpty\
    \ {\n                result = \"Yes\"\n                break\n            }\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmp3mn4qtum/tmp3mn4qtum.swift:50: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b44c6380c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b44c6077b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b44c6077988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b44c60767b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp3mn4qtum                        0x000055d5c0410960 <unavailable> + 6496

    5    libc.so.6                          0x00002b44c656c460 __libc_start_main +
    245

    6    tmp3mn4qtum                        0x000055d5c04103d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659824803
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n  \
    \      } else if s == \")\" {\n            if stack.isEmpty {\n              \
    \  result = \"No\"\n                break\n            } else {\n            \
    \    stack.removeLast()\n            }\n        } else {\n            if stack.isEmpty\
    \ {\n                result = \"Yes\"\n                break\n            }\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmpc1dl9p67/tmpc1dl9p67.swift:51: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac9450f2c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac944de9b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac944de9988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac944de87b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpc1dl9p67                        0x000055897db1aaeb <unavailable> + 6891

    5    libc.so.6                          0x00002ac9452de460 __libc_start_main +
    245

    6    tmpc1dl9p67                        0x000055897db1a3d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659824804
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s.contains(\"(\") {\n            stack.append(s)\n\
    \        }\n        if s.contains(\")\") {\n            if stack.count > 0 {\n\
    \                stack.removeLast()\n            } else {\n                result\
    \ = \"Yes\"\n            }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmpscodgx4v/tmpscodgx4v.swift:45: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b187112ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b1870e21b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b1870e21988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b1870e207b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpscodgx4v                        0x0000555f83707ae0 <unavailable> + 6880

    5    libc.so.6                          0x00002b1871316460 __libc_start_main +
    245

    6    tmpscodgx4v                        0x0000555f83707559 <unavailable> + 5465

    '
  stdout: ''
  timestamp: 1659824804
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n  \
    \      } else if s == \")\" {\n            if stack.isEmpty {\n              \
    \  result = \"No\"\n            } else {\n                stack.removeLast()\n\
    \            }\n        } else {\n            if stack.isEmpty {\n           \
    \     result = \"Yes\"\n            } else {\n                if stack.last ==\
    \ s {\n                    stack.removeLast()\n                } else {\n    \
    \                result = \"No\"\n                }\n            }\n        }\n\
    \    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpuy3e07lt/tmpuy3e07lt.swift:53: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002add01135c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002add00e2cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002add00e2c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002add00e2b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpuy3e07lt                        0x0000562e3d8df856 <unavailable> + 6230

    5    libc.so.6                          0x00002add01321460 __libc_start_main +
    245

    6    tmpuy3e07lt                        0x0000562e3d8df439 <unavailable> + 5177

    '
  stdout: ''
  timestamp: 1659824804
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s == \"(\" || s == \")\" {\n            if stack.isEmpty\
    \ {\n                result = \"Yes\"\n                break\n            }\n\
    \            stack.removeLast()\n        } else {\n            stack.append(s)\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmpv_273aj5/tmpv_273aj5.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b7b54488c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b7b5417fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b7b5417f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b7b5417e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpv_273aj5                        0x00005557416297f6 <unavailable> + 6134

    5    libc.so.6                          0x00002b7b54674460 __libc_start_main +
    245

    6    tmpv_273aj5                        0x00005557416293d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659824804
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s.contains(\"(\") {\n            stack.append(s)\n\
    \        } else {\n            if stack.isEmpty {\n                result = \"\
    Yes\"\n                break\n            }\n            stack.pop()\n       \
    \ }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmp8ek74s8g.swift:24:19: error: value of type '[String]' has no member\
    \ 'pop'\n            stack.pop()\n            ~~~~~ ^~~\n"
  stdout: ''
  timestamp: 1659824804
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n  \
    \      } else if s == \")\" {\n            if stack.isEmpty {\n              \
    \  result = \"No\"\n                break\n            }\n            stack.removeLast()\n\
    \        } else {\n            if stack.isEmpty {\n                result = \"\
    Yes\"\n                break\n            }\n            stack.removeLast()\n\
    \            stack.append(s)\n        }\n    }\n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmper3pjgt7/tmper3pjgt7.swift:52: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b8f9a0dec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8f99dd5b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b8f99dd5988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b8f99dd47b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmper3pjgt7                        0x00005596ce385aeb <unavailable> + 6891

    5    libc.so.6                          0x00002b8f9a2ca460 __libc_start_main +
    245

    6    tmper3pjgt7                        0x00005596ce3853d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659824804
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n  \
    \      } else if s == \")\" {\n            if stack.isEmpty {\n              \
    \  result = \"Yes\"\n                break\n            }\n            stack.removeLast()\n\
    \        } else {\n            if stack.isEmpty {\n                result = \"\
    No\"\n                break\n            }\n            stack.removeLast()\n \
    \       }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmp7q6vd_47/tmp7q6vd_47.swift:49: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae91618fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae915e86b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae915e86988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae915e857b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp7q6vd_47                        0x000056453d9587f6 <unavailable> + 6134

    5    libc.so.6                          0x00002ae91637b460 __libc_start_main +
    245

    6    tmp7q6vd_47                        0x000056453d9583d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659824804
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n  \
    \      } else if s == \")\" {\n            if stack.isEmpty {\n              \
    \  result = \"No\"\n                break\n            }\n            stack.removeLast()\n\
    \        } else {\n            if stack.isEmpty {\n                result = \"\
    Yes\"\n                break\n            }\n            if stack.last != s {\n\
    \                result = \"No\"\n                break\n            }\n     \
    \   }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpbu20pe97/tmpbu20pe97.swift:54: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aacbf5a6c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aacbf29db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aacbf29d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aacbf29c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpbu20pe97                        0x00005627a5613b4b <unavailable> + 6987

    5    libc.so.6                          0x00002aacbf792460 __libc_start_main +
    245

    6    tmpbu20pe97                        0x00005627a5613439 <unavailable> + 5177

    '
  stdout: ''
  timestamp: 1659824804
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n  \
    \      } else if s == \")\" {\n            if stack.last == \"(\" {\n        \
    \        stack.removeLast()\n            } else {\n                result = \"\
    Yes\"\n                break\n            }\n        } else {\n            if\
    \ stack.last == \")\" {\n                stack.removeLast()\n            }\n \
    \       }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmp7f0x7y8l/tmp7f0x7y8l.swift:49: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad64b957c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad64b64eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad64b64e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad64b64d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp7f0x7y8l                        0x000056037d552960 <unavailable> + 6496

    5    libc.so.6                          0x00002ad64bb43460 __libc_start_main +
    245

    6    tmp7f0x7y8l                        0x000056037d5523d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659824804
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n  \
    \      } else if s == \")\" {\n            if stack.isEmpty {\n              \
    \  result = \"No\"\n                break\n            }\n            stack.removeLast()\n\
    \        } else {\n            if stack.isEmpty {\n                result = \"\
    Yes\"\n                break\n            }\n            stack.removeLast()\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmpv1l7onuz/tmpv1l7onuz.swift:51: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad7f2b5fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad7f2856b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad7f2856988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad7f28557b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpv1l7onuz                        0x0000561d3a8c3aeb <unavailable> + 6891

    5    libc.so.6                          0x00002ad7f2d4b460 __libc_start_main +
    245

    6    tmpv1l7onuz                        0x0000561d3a8c33d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659824804
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n  \
    \      } else if s == \")\" {\n            if stack.count > 0 {\n            \
    \    stack.removeLast()\n            } else {\n                result = \"Yes\"\
    \n                break\n            }\n        } else {\n            if stack.count\
    \ > 0 {\n                if stack.last == s {\n                    stack.removeLast()\n\
    \                } else {\n                    result = \"No\"\n             \
    \       break\n                }\n            } else {\n                result\
    \ = \"Yes\"\n                break\n            }\n        }\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"\
    ()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpbtogr482/tmpbtogr482.swift:57: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b93d0821c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b93d0518b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b93d0518988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b93d05177b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpbtogr482                        0x000055ded4d259c0 <unavailable> + 6592

    5    libc.so.6                          0x00002b93d0a0d460 __libc_start_main +
    245

    6    tmpbtogr482                        0x000055ded4d25439 <unavailable> + 5177

    '
  stdout: ''
  timestamp: 1659824804
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    for s in lst {\n    \
    \    if s == \")\" {\n            if stack.isEmpty {\n                return \"\
    No\"\n            }\n            stack.removeLast()\n        } else if s == \"\
    (\" {\n            stack.append(s)\n        }\n    }\n    if stack.isEmpty {\n\
    \        return \"Yes\"\n    }\n    return \"No\"\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmp09ctgrm2/tmp09ctgrm2.swift:44: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1e8c8cdc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b1e8c5c4b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b1e8c5c4988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b1e8c5c37b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp09ctgrm2                        0x00005591f773b7f6 <unavailable> + 6134

    5    libc.so.6                          0x00002b1e8cab9460 __libc_start_main +
    245

    6    tmp09ctgrm2                        0x00005591f773b3d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659824804
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n  \
    \      } else if s == \")\" {\n            if stack.isEmpty {\n              \
    \  result = \"Yes\"\n                break\n            }\n            stack.removeLast()\n\
    \        } else {\n            if stack.isEmpty {\n                result = \"\
    Yes\"\n                break\n            }\n            stack.removeLast()\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmp8q78hrgw/tmp8q78hrgw.swift:50: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ad737194c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ad736e8bb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ad736e8b988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ad736e8a7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp8q78hrgw                        0x000055a25bcb1960 <unavailable> + 6496

    5    libc.so.6                          0x00002ad737380460 __libc_start_main +
    245

    6    tmp8q78hrgw                        0x000055a25bcb13d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659824804
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n  \
    \      } else if s == \")\" {\n            if stack.isEmpty {\n              \
    \  result = \"No\"\n            } else {\n                stack.pop()\n      \
    \      }\n        } else {\n            if stack.isEmpty {\n                result\
    \ = \"Yes\"\n            } else {\n                if stack[stack.count - 1] !=\
    \ s {\n                    result = \"No\"\n                }\n            }\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmp_8z9es8x.swift:23:23: error: value of type '[String]' has no member\
    \ 'pop'\n                stack.pop()\n                ~~~~~ ^~~\n"
  stdout: ''
  timestamp: 1659824804
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n  \
    \      } else if s == \")\" {\n            if stack.isEmpty {\n              \
    \  result = \"Yes\"\n                break\n            }\n            stack.removeLast()\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmpc9tow60w/tmpc9tow60w.swift:44: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab676de7c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab676adeb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab676ade988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab676add7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpc9tow60w                        0x0000555f05973960 <unavailable> + 6496

    5    libc.so.6                          0x00002ab676fd3460 __libc_start_main +
    245

    6    tmpc9tow60w                        0x0000555f059733d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659824804
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n  \
    \      } else if s == \")\" {\n            if stack.isEmpty {\n              \
    \  result = \"No\"\n            } else {\n                stack.pop()\n      \
    \      }\n        } else {\n            if stack.isEmpty {\n                result\
    \ = \"Yes\"\n            } else {\n                stack.pop()\n            }\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpp701w74k.swift:23:23: error: value of type '[String]' has no member\
    \ 'pop'\n                stack.pop()\n                ~~~~~ ^~~\n/tmp/tmpp701w74k.swift:29:23:\
    \ error: value of type '[String]' has no member 'pop'\n                stack.pop()\n\
    \                ~~~~~ ^~~\n"
  stdout: ''
  timestamp: 1659824804
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n  \
    \      } else if s == \")\" {\n            if stack.count > 0 {\n            \
    \    stack.removeLast()\n            } else {\n                result = \"Yes\"\
    \n                break\n            }\n        } else {\n            if stack.count\
    \ > 0 {\n                stack.removeLast()\n            }\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmp260rkg0p/tmp260rkg0p.swift:49: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac4c2f5ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac4c2c55b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac4c2c55988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac4c2c547b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp260rkg0p                        0x0000563682439960 <unavailable> + 6496

    5    libc.so.6                          0x00002ac4c314a460 __libc_start_main +
    245

    6    tmp260rkg0p                        0x00005636824393d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659824804
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = Stack()\n    for s in lst {\n       \
    \ if s == '(' {\n            stack.push(s)\n        } else if s == ')' {\n   \
    \         if stack.top() == '(' {\n                stack.pop()\n            }\
    \ else {\n                return \"No\"\n            }\n        } else {\n   \
    \         return \"No\"\n        }\n    }\n    if stack.top() != nil {\n     \
    \   return \"No\"\n    } else {\n        return \"Yes\"\n    }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmp9044s0w7.swift:16:17: error: single-quoted string literal found,\
    \ use '\"'\n        if s == '(' {\n                ^~~\n                \"(\"\n\
    /tmp/tmp9044s0w7.swift:18:24: error: single-quoted string literal found, use '\"\
    '\n        } else if s == ')' {\n                       ^~~\n                \
    \       \")\"\n/tmp/tmp9044s0w7.swift:19:31: error: single-quoted string literal\
    \ found, use '\"'\n            if stack.top() == '(' {\n                     \
    \         ^~~\n                              \"(\"\n/tmp/tmp9044s0w7.swift:14:17:\
    \ error: cannot find 'Stack' in scope\n    var stack = Stack()\n             \
    \   ^~~~~\n"
  stdout: ''
  timestamp: 1659824803
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n  \
    \      } else if s == \")\" {\n            if stack.isEmpty {\n              \
    \  result = \"Yes\"\n                break\n            } else {\n           \
    \     stack.removeLast()\n            }\n        } else {\n            if stack.isEmpty\
    \ {\n                result = \"Yes\"\n                break\n            }\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmp3mn4qtum/tmp3mn4qtum.swift:50: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b44c6380c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b44c6077b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b44c6077988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b44c60767b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp3mn4qtum                        0x000055d5c0410960 <unavailable> + 6496

    5    libc.so.6                          0x00002b44c656c460 __libc_start_main +
    245

    6    tmp3mn4qtum                        0x000055d5c04103d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659824803
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    for s in lst {\n    \
    \    if s == \"(\" {\n            stack.append(s)\n        } else if s == \")\"\
    \ {\n            if stack.last == \"(\" {\n                stack.removeLast()\n\
    \            } else {\n                return \"No\"\n            }\n        }\
    \ else {\n            if stack.last == \"(\" {\n                stack.removeLast()\n\
    \            } else {\n                return \"No\"\n            }\n        }\n\
    \    }\n    if stack.last == \"(\" {\n        return \"Yes\"\n    } else {\n \
    \       return \"No\"\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpvfv4d0d4/tmpvfv4d0d4.swift:52: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aef833b3c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aef830aab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aef830aa988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aef830a97b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpvfv4d0d4                        0x0000562c44a7d7f6 <unavailable> + 6134

    5    libc.so.6                          0x00002aef8359f460 __libc_start_main +
    245

    6    tmpvfv4d0d4                        0x0000562c44a7d3d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659824804
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = Stack()\n    for s in lst {\n       \
    \ if s == \"(\" {\n            stack.push(\"(\")\n        } else if s == \")\"\
    \ {\n            if stack.top() == \"(\" {\n                stack.pop()\n    \
    \        } else {\n                return \"No\"\n            }\n        } else\
    \ {\n            return \"No\"\n        }\n    }\n    if stack.top() == \"(\"\
    \ {\n        return \"Yes\"\n    } else {\n        return \"No\"\n    }\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpuuzpit5j.swift:14:17: error: cannot find 'Stack' in scope\n   \
    \ var stack = Stack()\n                ^~~~~\n"
  stdout: ''
  timestamp: 1659824804
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n  \
    \      } else if s == \")\" {\n            if stack.isEmpty {\n              \
    \  result = \"Yes\"\n                break\n            } else {\n           \
    \     stack.pop()\n            }\n        } else {\n            if stack.isEmpty\
    \ {\n                result = \"No\"\n                break\n            }\n \
    \       }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmp344m80wd.swift:24:23: error: value of type '[String]' has no member\
    \ 'pop'\n                stack.pop()\n                ~~~~~ ^~~\n"
  stdout: ''
  timestamp: 1659824804
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n  \
    \      } else if s == \")\" {\n            if stack.isEmpty {\n              \
    \  result = \"Yes\"\n                break\n            } else {\n           \
    \     stack.removeLast()\n            }\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmp7eihgb1y/tmp7eihgb1y.swift:45: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b11fece8c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b11fe9dfb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b11fe9df988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b11fe9de7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp7eihgb1y                        0x0000559d7ffc8960 <unavailable> + 6496

    5    libc.so.6                          0x00002b11feed4460 __libc_start_main +
    245

    6    tmp7eihgb1y                        0x0000559d7ffc83d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659824804
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n  \
    \      } else if s == \")\" {\n            if stack.isEmpty {\n              \
    \  result = \"No\"\n            } else {\n                stack.pop()\n      \
    \      }\n        } else {\n            if stack.isEmpty {\n                result\
    \ = \"Yes\"\n            } else {\n                stack.pop()\n             \
    \   stack.append(s)\n            }\n        }\n    }\n    return result\n}\n\n\
    \nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpaj_pioa0.swift:23:23: error: value of type '[String]' has no member\
    \ 'pop'\n                stack.pop()\n                ~~~~~ ^~~\n/tmp/tmpaj_pioa0.swift:29:23:\
    \ error: value of type '[String]' has no member 'pop'\n                stack.pop()\n\
    \                ~~~~~ ^~~\n"
  stdout: ''
  timestamp: 1659824804
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n  \
    \      } else if s == \")\" {\n            if stack.isEmpty {\n              \
    \  result = \"No\"\n                break\n            } else {\n            \
    \    stack.removeLast()\n            }\n        } else {\n            if stack.isEmpty\
    \ {\n                result = \"Yes\"\n                break\n            }\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmpc1dl9p67/tmpc1dl9p67.swift:51: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac9450f2c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac944de9b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac944de9988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac944de87b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpc1dl9p67                        0x000055897db1aaeb <unavailable> + 6891

    5    libc.so.6                          0x00002ac9452de460 __libc_start_main +
    245

    6    tmpc1dl9p67                        0x000055897db1a3d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659824804
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n  \
    \      } else if s == \")\" {\n            if stack.count > 0 {\n            \
    \    stack.removeLast()\n            } else {\n                result = \"Yes\"\
    \n                break\n            }\n        } else {\n            if stack.count\
    \ > 0 {\n                if stack.last == s {\n                    stack.removeLast()\n\
    \                } else {\n                    result = \"No\"\n             \
    \       break\n                }\n            } else {\n                result\
    \ = \"Yes\"\n                break\n            }\n        }\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"\
    ()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpbtogr482/tmpbtogr482.swift:57: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b93d0821c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b93d0518b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b93d0518988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b93d05177b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpbtogr482                        0x000055ded4d259c0 <unavailable> + 6592

    5    libc.so.6                          0x00002b93d0a0d460 __libc_start_main +
    245

    6    tmpbtogr482                        0x000055ded4d25439 <unavailable> + 5177

    '
  stdout: ''
  timestamp: 1659824804
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n  \
    \      } else if s == \")\" {\n            if stack.isEmpty {\n              \
    \  result = \"No\"\n            } else {\n                stack.removeLast()\n\
    \            }\n        } else {\n            if stack.isEmpty {\n           \
    \     result = \"Yes\"\n            } else {\n                stack.removeLast()\n\
    \            }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmp5dj0p34v/tmp5dj0p34v.swift:49: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b8ca084ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8ca0541b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b8ca0541988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b8ca05407b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp5dj0p34v                        0x000056319731d7f6 <unavailable> + 6134

    5    libc.so.6                          0x00002b8ca0a36460 __libc_start_main +
    245

    6    tmp5dj0p34v                        0x000056319731d3d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659824804
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = Stack()\n    for s in lst {\n       \
    \ if s == '(' {\n            stack.push(s)\n        } else if s == ')' {\n   \
    \         if stack.isEmpty {\n                return \"No\"\n            }\n \
    \           stack.pop()\n        }\n    }\n    if stack.isEmpty {\n        return\
    \ \"Yes\"\n    }\n    return \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpq4q70pes.swift:16:17: error: single-quoted string literal found,\
    \ use '\"'\n        if s == '(' {\n                ^~~\n                \"(\"\n\
    /tmp/tmpq4q70pes.swift:18:24: error: single-quoted string literal found, use '\"\
    '\n        } else if s == ')' {\n                       ^~~\n                \
    \       \")\"\n/tmp/tmpq4q70pes.swift:14:17: error: cannot find 'Stack' in scope\n\
    \    var stack = Stack()\n                ^~~~~\n"
  stdout: ''
  timestamp: 1659824804
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n  \
    \      } else if s == \")\" {\n            if stack.count > 0 {\n            \
    \    stack.removeLast()\n            } else {\n                result = \"Yes\"\
    \n            }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmp3rvtwdo_/tmp3rvtwdo_.swift:44: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b2dbaa72c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b2dba769b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b2dba769988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b2dba7687b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp3rvtwdo_                        0x000055e109e92960 <unavailable> + 6496

    5    libc.so.6                          0x00002b2dbac5e460 __libc_start_main +
    245

    6    tmp3rvtwdo_                        0x000055e109e923d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659824803
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    for s in lst {\n    \
    \    if s == \"(\" {\n            stack.append(s)\n        } else if s == \")\"\
    \ {\n            if stack.isEmpty {\n                return \"No\"\n         \
    \   }\n            stack.removeLast()\n        } else if stack.isEmpty {\n   \
    \         return \"Yes\"\n        }\n    }\n    return \"No\"\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmpf4zspvdj/tmpf4zspvdj.swift:45: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af1269b5c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af1266acb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af1266ac988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af1266ab7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpf4zspvdj                        0x000056236b292aeb <unavailable> + 6891

    5    libc.so.6                          0x00002af126ba1460 __libc_start_main +
    245

    6    tmpf4zspvdj                        0x000056236b2923d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659824804
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfunc match_parens(lst:\
    \ [String]) -> String {\n    guard lst.count >= 2 else { return \"No\" }\n   \
    \ var stack = [String]()\n    var result = \"No\"\n    for s in lst {\n      \
    \  if s == \"(\" {\n            stack.append(s)\n        } else if s == \")\"\
    \ {\n            if stack.count > 0 {\n                stack.removeLast()\n  \
    \          } else {\n                result = \"Yes\"\n            }\n       \
    \ }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmp22i0_wyr/tmp22i0_wyr.swift:45: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9a6022dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9a5ff24b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9a5ff24988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9a5ff237b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp22i0_wyr                        0x0000563810463960 <unavailable> + 6496

    5    libc.so.6                          0x00002b9a60419460 __libc_start_main +
    245

    6    tmp22i0_wyr                        0x00005638104633d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659824804
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfunc match_parens(lst:\
    \ [String]) -> String {\n    guard lst.count >= 2 else { return \"No\" }\n   \
    \ var stack = [String]()\n    var result = \"No\"\n    for s in lst {\n      \
    \  if s.contains(\"(\") {\n            stack.append(s)\n        } else if s.contains(\"\
    )\") {\n            if stack.count > 0 {\n                stack.removeLast()\n\
    \            } else {\n                result = \"Yes\"\n            }\n     \
    \   }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpfppwiojf/tmpfppwiojf.swift:44: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b6527ae5c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b65277dcb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b65277dc988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b65277db7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpfppwiojf                        0x000055ba515d8976 <unavailable> + 6518

    5    libc.so.6                          0x00002b6527cd1460 __libc_start_main +
    245

    6    tmpfppwiojf                        0x000055ba515d8559 <unavailable> + 5465

    '
  stdout: ''
  timestamp: 1659824804
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    for s in lst {\n    \
    \    if s.contains(\"(\") {\n            stack.append(s)\n        } else {\n \
    \           if stack.isEmpty {\n                return \"No\"\n            }\n\
    \            stack.pop()\n        }\n    }\n    if stack.isEmpty {\n        return\
    \ \"Yes\"\n    }\n    return \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpg5swp60u.swift:22:19: error: value of type '[String]' has no member\
    \ 'pop'\n            stack.pop()\n            ~~~~~ ^~~\n"
  stdout: ''
  timestamp: 1659824804
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = Stack()\n    var result = \"No\"\n  \
    \  for s in lst {\n        if s == \"(\" {\n            stack.push(s)\n      \
    \  } else if s == \")\" {\n            if stack.top() == \"(\" {\n           \
    \     stack.pop()\n            } else {\n                result = \"Yes\"\n  \
    \              break\n            }\n        } else {\n            result = \"\
    No\"\n            break\n        }\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpaeqvfagc.swift:14:17: error: cannot find 'Stack' in scope\n   \
    \ var stack = Stack()\n                ^~~~~\n"
  stdout: ''
  timestamp: 1659824804
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n  \
    \      } else if s == \")\" {\n            if stack.count > 0 {\n            \
    \    stack.removeLast()\n            } else {\n                result = \"Yes\"\
    \n            }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmp3rvtwdo_/tmp3rvtwdo_.swift:44: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b2dbaa72c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b2dba769b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b2dba769988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b2dba7687b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp3rvtwdo_                        0x000055e109e92960 <unavailable> + 6496

    5    libc.so.6                          0x00002b2dbac5e460 __libc_start_main +
    245

    6    tmp3rvtwdo_                        0x000055e109e923d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659824803
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n  \
    \      } else if s == \")\" {\n            if stack.isEmpty {\n              \
    \  result = \"No\"\n            } else {\n                stack.removeLast()\n\
    \            }\n        } else {\n            if stack.isEmpty {\n           \
    \     result = \"Yes\"\n            } else {\n                stack.removeLast()\n\
    \            }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmp5dj0p34v/tmp5dj0p34v.swift:49: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b8ca084ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8ca0541b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b8ca0541988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b8ca05407b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp5dj0p34v                        0x000056319731d7f6 <unavailable> + 6134

    5    libc.so.6                          0x00002b8ca0a36460 __libc_start_main +
    245

    6    tmp5dj0p34v                        0x000056319731d3d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659824804
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n  \
    \      } else if s == \")\" {\n            if stack.isEmpty {\n              \
    \  result = \"Yes\"\n                break\n            } else {\n           \
    \     stack.removeLast()\n            }\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmp7eihgb1y/tmp7eihgb1y.swift:45: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b11fece8c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b11fe9dfb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b11fe9df988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b11fe9de7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp7eihgb1y                        0x0000559d7ffc8960 <unavailable> + 6496

    5    libc.so.6                          0x00002b11feed4460 __libc_start_main +
    245

    6    tmp7eihgb1y                        0x0000559d7ffc83d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659824804
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n  \
    \      } else if s == \")\" {\n            if stack.isEmpty {\n              \
    \  result = \"Yes\"\n                break\n            } else {\n           \
    \     stack.removeLast()\n            }\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmp7eihgb1y/tmp7eihgb1y.swift:45: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b11fece8c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b11fe9dfb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b11fe9df988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b11fe9de7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp7eihgb1y                        0x0000559d7ffc8960 <unavailable> + 6496

    5    libc.so.6                          0x00002b11feed4460 __libc_start_main +
    245

    6    tmp7eihgb1y                        0x0000559d7ffc83d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659824804
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = Stack()\n    for s in lst {\n       \
    \ if s == '(' {\n            stack.push(s)\n        } else if s == ')' {\n   \
    \         if stack.top() == '(' {\n                stack.pop()\n            }\
    \ else {\n                return \"No\"\n            }\n        } else {\n   \
    \         return \"No\"\n        }\n    }\n    if stack.top() != nil {\n     \
    \   return \"No\"\n    }\n    return \"Yes\"\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpkimm9ytd.swift:16:17: error: single-quoted string literal found,\
    \ use '\"'\n        if s == '(' {\n                ^~~\n                \"(\"\n\
    /tmp/tmpkimm9ytd.swift:18:24: error: single-quoted string literal found, use '\"\
    '\n        } else if s == ')' {\n                       ^~~\n                \
    \       \")\"\n/tmp/tmpkimm9ytd.swift:19:31: error: single-quoted string literal\
    \ found, use '\"'\n            if stack.top() == '(' {\n                     \
    \         ^~~\n                              \"(\"\n/tmp/tmpkimm9ytd.swift:14:17:\
    \ error: cannot find 'Stack' in scope\n    var stack = Stack()\n             \
    \   ^~~~~\n"
  stdout: ''
  timestamp: 1659824804
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = Stack()\n    for s in lst {\n       \
    \ if s == '(' {\n            stack.push(s)\n        } else if s == ')' {\n   \
    \         if stack.top() == '(' {\n                stack.pop()\n            }\
    \ else {\n                return \"No\"\n            }\n        } else {\n   \
    \         return \"No\"\n        }\n    }\n    if stack.top() != nil {\n     \
    \   return \"No\"\n    } else {\n        return \"Yes\"\n    }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmp9044s0w7.swift:16:17: error: single-quoted string literal found,\
    \ use '\"'\n        if s == '(' {\n                ^~~\n                \"(\"\n\
    /tmp/tmp9044s0w7.swift:18:24: error: single-quoted string literal found, use '\"\
    '\n        } else if s == ')' {\n                       ^~~\n                \
    \       \")\"\n/tmp/tmp9044s0w7.swift:19:31: error: single-quoted string literal\
    \ found, use '\"'\n            if stack.top() == '(' {\n                     \
    \         ^~~\n                              \"(\"\n/tmp/tmp9044s0w7.swift:14:17:\
    \ error: cannot find 'Stack' in scope\n    var stack = Stack()\n             \
    \   ^~~~~\n"
  stdout: ''
  timestamp: 1659824803
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n  \
    \      } else if s == \")\" {\n            if stack.isEmpty {\n              \
    \  result = \"Yes\"\n                break\n            } else {\n           \
    \     stack.removeLast()\n            }\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmp7eihgb1y/tmp7eihgb1y.swift:45: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b11fece8c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b11fe9dfb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b11fe9df988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b11fe9de7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp7eihgb1y                        0x0000559d7ffc8960 <unavailable> + 6496

    5    libc.so.6                          0x00002b11feed4460 __libc_start_main +
    245

    6    tmp7eihgb1y                        0x0000559d7ffc83d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659824804
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n  \
    \      } else if s == \")\" {\n            if stack.isEmpty {\n              \
    \  result = \"Yes\"\n                break\n            }\n            stack.removeLast()\n\
    \        } else {\n            if stack.isEmpty {\n                result = \"\
    Yes\"\n                break\n            }\n            stack.removeLast()\n\
    \            stack.append(s)\n        }\n    }\n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmp5yctdyd3/tmp5yctdyd3.swift:51: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b27a36e3c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b27a33dab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b27a33da988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b27a33d97b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp5yctdyd3                        0x000056491dca9960 <unavailable> + 6496

    5    libc.so.6                          0x00002b27a38cf460 __libc_start_main +
    245

    6    tmp5yctdyd3                        0x000056491dca93d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659824803
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n  \
    \      } else if s == \")\" {\n            if stack.isEmpty {\n              \
    \  result = \"Yes\"\n                break\n            }\n            stack.removeLast()\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmpc9tow60w/tmpc9tow60w.swift:44: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab676de7c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab676adeb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab676ade988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab676add7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpc9tow60w                        0x0000555f05973960 <unavailable> + 6496

    5    libc.so.6                          0x00002ab676fd3460 __libc_start_main +
    245

    6    tmpc9tow60w                        0x0000555f059733d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659824804
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s.contains(\"(\") {\n            stack.append(s)\n\
    \        } else if s.contains(\")\") {\n            if stack.count > 0 {\n   \
    \             stack.removeLast()\n            } else {\n                result\
    \ = \"Yes\"\n            }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmp92jtdhou/tmp92jtdhou.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b59c9667c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b59c935eb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b59c935e988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b59c935d7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp92jtdhou                        0x0000562346572976 <unavailable> + 6518

    5    libc.so.6                          0x00002b59c9853460 __libc_start_main +
    245

    6    tmp92jtdhou                        0x0000562346572559 <unavailable> + 5465

    '
  stdout: ''
  timestamp: 1659824803
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s.contains(\"(\") {\n            stack.append(s)\n\
    \        } else if s.contains(\")\") {\n            if stack.count > 0 {\n   \
    \             stack.removeLast()\n            } else {\n                result\
    \ = \"No\"\n                break\n            }\n        } else {\n         \
    \   result = \"No\"\n            break\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpmt8a2ilk/tmpmt8a2ilk.swift:47: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac69f411c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac69f108b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac69f108988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac69f1077b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpmt8a2ilk                        0x0000558e53d85976 <unavailable> + 6518

    5    libc.so.6                          0x00002ac69f5fd460 __libc_start_main +
    245

    6    tmpmt8a2ilk                        0x0000558e53d85559 <unavailable> + 5465

    '
  stdout: ''
  timestamp: 1659824804
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n  \
    \      } else if s == \")\" {\n            if stack.isEmpty {\n              \
    \  result = \"No\"\n                break\n            } else {\n            \
    \    stack.removeLast()\n            }\n        } else {\n            if stack.isEmpty\
    \ {\n                result = \"Yes\"\n                break\n            }\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmpc1dl9p67/tmpc1dl9p67.swift:51: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac9450f2c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac944de9b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac944de9988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac944de87b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpc1dl9p67                        0x000055897db1aaeb <unavailable> + 6891

    5    libc.so.6                          0x00002ac9452de460 __libc_start_main +
    245

    6    tmpc1dl9p67                        0x000055897db1a3d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659824804
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = Stack()\n    for s in lst {\n       \
    \ if s == '(' {\n            stack.push(s)\n        } else if s == ')' {\n   \
    \         if stack.top() == '(' {\n                stack.pop()\n            }\
    \ else {\n                return \"No\"\n            }\n        } else {\n   \
    \         return \"No\"\n        }\n    }\n    if stack.top() != nil {\n     \
    \   return \"No\"\n    } else {\n        return \"Yes\"\n    }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmp9044s0w7.swift:16:17: error: single-quoted string literal found,\
    \ use '\"'\n        if s == '(' {\n                ^~~\n                \"(\"\n\
    /tmp/tmp9044s0w7.swift:18:24: error: single-quoted string literal found, use '\"\
    '\n        } else if s == ')' {\n                       ^~~\n                \
    \       \")\"\n/tmp/tmp9044s0w7.swift:19:31: error: single-quoted string literal\
    \ found, use '\"'\n            if stack.top() == '(' {\n                     \
    \         ^~~\n                              \"(\"\n/tmp/tmp9044s0w7.swift:14:17:\
    \ error: cannot find 'Stack' in scope\n    var stack = Stack()\n             \
    \   ^~~~~\n"
  stdout: ''
  timestamp: 1659824803
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s == \"(\" || s == \")\" {\n            stack.append(s)\n\
    \        } else {\n            if stack.count > 0 {\n                if stack[stack.count\
    \ - 1] == s {\n                    stack.removeLast()\n                } else\
    \ {\n                    result = \"No\"\n                    break\n        \
    \        }\n            } else {\n                result = \"Yes\"\n         \
    \       break\n            }\n        }\n    }\n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmp2dhb_66l/tmp2dhb_66l.swift:51: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af704ccdc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af7049c4b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af7049c4988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af7049c37b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp2dhb_66l                        0x000055abca369b3b <unavailable> + 6971

    5    libc.so.6                          0x00002af704eb9460 __libc_start_main +
    245

    6    tmp2dhb_66l                        0x000055abca369429 <unavailable> + 5161

    '
  stdout: ''
  timestamp: 1659824804
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n  \
    \      } else if s == \")\" {\n            if stack.count > 0 {\n            \
    \    stack.removeLast()\n            } else {\n                result = \"Yes\"\
    \n            }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmp3rvtwdo_/tmp3rvtwdo_.swift:44: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b2dbaa72c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b2dba769b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b2dba769988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b2dba7687b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp3rvtwdo_                        0x000055e109e92960 <unavailable> + 6496

    5    libc.so.6                          0x00002b2dbac5e460 __libc_start_main +
    245

    6    tmp3rvtwdo_                        0x000055e109e923d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659824803
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = Stack()\n    for s in lst {\n       \
    \ if s == '(' {\n            stack.push(s)\n        } else if s == ')' {\n   \
    \         if stack.top() == '(' {\n                stack.pop()\n            }\
    \ else {\n                return \"No\"\n            }\n        } else {\n   \
    \         return \"No\"\n        }\n    }\n    if stack.top() != nil {\n     \
    \   return \"No\"\n    } else {\n        return \"Yes\"\n    }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmp9044s0w7.swift:16:17: error: single-quoted string literal found,\
    \ use '\"'\n        if s == '(' {\n                ^~~\n                \"(\"\n\
    /tmp/tmp9044s0w7.swift:18:24: error: single-quoted string literal found, use '\"\
    '\n        } else if s == ')' {\n                       ^~~\n                \
    \       \")\"\n/tmp/tmp9044s0w7.swift:19:31: error: single-quoted string literal\
    \ found, use '\"'\n            if stack.top() == '(' {\n                     \
    \         ^~~\n                              \"(\"\n/tmp/tmp9044s0w7.swift:14:17:\
    \ error: cannot find 'Stack' in scope\n    var stack = Stack()\n             \
    \   ^~~~~\n"
  stdout: ''
  timestamp: 1659824803
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = Stack()\n    for s in lst {\n       \
    \ if s == '(' {\n            stack.push(s)\n        } else if s == ')' {\n   \
    \         if stack.top() == '(' {\n                stack.pop()\n            }\
    \ else {\n                return \"No\"\n            }\n        } else {\n   \
    \         return \"No\"\n        }\n    }\n    if stack.top() != nil {\n     \
    \   return \"No\"\n    } else {\n        return \"Yes\"\n    }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmp9044s0w7.swift:16:17: error: single-quoted string literal found,\
    \ use '\"'\n        if s == '(' {\n                ^~~\n                \"(\"\n\
    /tmp/tmp9044s0w7.swift:18:24: error: single-quoted string literal found, use '\"\
    '\n        } else if s == ')' {\n                       ^~~\n                \
    \       \")\"\n/tmp/tmp9044s0w7.swift:19:31: error: single-quoted string literal\
    \ found, use '\"'\n            if stack.top() == '(' {\n                     \
    \         ^~~\n                              \"(\"\n/tmp/tmp9044s0w7.swift:14:17:\
    \ error: cannot find 'Stack' in scope\n    var stack = Stack()\n             \
    \   ^~~~~\n"
  stdout: ''
  timestamp: 1659824803
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfunc match_parens(lst:\
    \ [String]) -> String {\n    guard lst.count >= 2 else { return \"No\" }\n   \
    \ var stack = [String]()\n    var result = \"No\"\n    for s in lst {\n      \
    \  if s == \"(\" {\n            stack.append(s)\n        } else if s == \")\"\
    \ {\n            if stack.count > 0 {\n                stack.removeLast()\n  \
    \          } else {\n                result = \"Yes\"\n            }\n       \
    \ }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmp22i0_wyr/tmp22i0_wyr.swift:45: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9a6022dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9a5ff24b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9a5ff24988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9a5ff237b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp22i0_wyr                        0x0000563810463960 <unavailable> + 6496

    5    libc.so.6                          0x00002b9a60419460 __libc_start_main +
    245

    6    tmp22i0_wyr                        0x00005638104633d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659824804
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n  \
    \      } else if s == \")\" {\n            if stack.isEmpty {\n              \
    \  result = \"Yes\"\n                break\n            } else {\n           \
    \     stack.removeLast()\n            }\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmp7eihgb1y/tmp7eihgb1y.swift:45: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b11fece8c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b11fe9dfb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b11fe9df988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b11fe9de7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp7eihgb1y                        0x0000559d7ffc8960 <unavailable> + 6496

    5    libc.so.6                          0x00002b11feed4460 __libc_start_main +
    245

    6    tmp7eihgb1y                        0x0000559d7ffc83d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659824804
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n  \
    \      } else if s == \")\" {\n            if stack.isEmpty {\n              \
    \  result = \"Yes\"\n                break\n            } else {\n           \
    \     stack.removeLast()\n            }\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmp7eihgb1y/tmp7eihgb1y.swift:45: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b11fece8c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b11fe9dfb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b11fe9df988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b11fe9de7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp7eihgb1y                        0x0000559d7ffc8960 <unavailable> + 6496

    5    libc.so.6                          0x00002b11feed4460 __libc_start_main +
    245

    6    tmp7eihgb1y                        0x0000559d7ffc83d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659824804
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = Stack()\n    for s in lst {\n       \
    \ if s == '(' {\n            stack.push(s)\n        } else if s == ')' {\n   \
    \         if stack.top() == '(' {\n                stack.pop()\n            }\
    \ else {\n                return \"No\"\n            }\n        } else {\n   \
    \         return \"No\"\n        }\n    }\n    if stack.top() != nil {\n     \
    \   return \"No\"\n    }\n    return \"Yes\"\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpkimm9ytd.swift:16:17: error: single-quoted string literal found,\
    \ use '\"'\n        if s == '(' {\n                ^~~\n                \"(\"\n\
    /tmp/tmpkimm9ytd.swift:18:24: error: single-quoted string literal found, use '\"\
    '\n        } else if s == ')' {\n                       ^~~\n                \
    \       \")\"\n/tmp/tmpkimm9ytd.swift:19:31: error: single-quoted string literal\
    \ found, use '\"'\n            if stack.top() == '(' {\n                     \
    \         ^~~\n                              \"(\"\n/tmp/tmpkimm9ytd.swift:14:17:\
    \ error: cannot find 'Stack' in scope\n    var stack = Stack()\n             \
    \   ^~~~~\n"
  stdout: ''
  timestamp: 1659824804
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s == \"(\" || s == \")\" {\n            stack.append(s)\n\
    \        } else {\n            if stack.count > 0 {\n                if stack[stack.count\
    \ - 1] == \"(\" && s == \"(\" {\n                    stack.pop()\n           \
    \     } else if stack[stack.count - 1] == \")\" && s == \")\" {\n            \
    \        stack.pop()\n                } else {\n                    result = \"\
    No\"\n                    break\n                }\n            } else {\n   \
    \             result = \"Yes\"\n                break\n            }\n       \
    \ }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpm_9whmt3.swift:22:27: error: value of type '[String]' has no member\
    \ 'pop'\n                    stack.pop()\n                    ~~~~~ ^~~\n/tmp/tmpm_9whmt3.swift:24:27:\
    \ error: value of type '[String]' has no member 'pop'\n                    stack.pop()\n\
    \                    ~~~~~ ^~~\n"
  stdout: ''
  timestamp: 1659824804
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n  \
    \      } else if s == \")\" {\n            if stack.isEmpty {\n              \
    \  result = \"No\"\n            } else {\n                stack.removeLast()\n\
    \            }\n        } else {\n            if stack.isEmpty {\n           \
    \     result = \"Yes\"\n            } else {\n                stack.removeLast()\n\
    \            }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmp5dj0p34v/tmp5dj0p34v.swift:49: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b8ca084ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8ca0541b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b8ca0541988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b8ca05407b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp5dj0p34v                        0x000056319731d7f6 <unavailable> + 6134

    5    libc.so.6                          0x00002b8ca0a36460 __libc_start_main +
    245

    6    tmp5dj0p34v                        0x000056319731d3d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659824804
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = Stack()\n    var result = \"No\"\n  \
    \  for s in lst {\n        if s == \"(\" {\n            stack.push(s)\n      \
    \  } else if s == \")\" {\n            if stack.top() == \"(\" {\n           \
    \     stack.pop()\n            } else {\n                result = \"Yes\"\n  \
    \              break\n            }\n        } else {\n            result = \"\
    No\"\n            break\n        }\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpaeqvfagc.swift:14:17: error: cannot find 'Stack' in scope\n   \
    \ var stack = Stack()\n                ^~~~~\n"
  stdout: ''
  timestamp: 1659824804
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n  \
    \      } else if s == \")\" {\n            if stack.count > 0 {\n            \
    \    stack.removeLast()\n            } else {\n                result = \"Yes\"\
    \n            }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmp3rvtwdo_/tmp3rvtwdo_.swift:44: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b2dbaa72c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b2dba769b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b2dba769988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b2dba7687b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp3rvtwdo_                        0x000055e109e92960 <unavailable> + 6496

    5    libc.so.6                          0x00002b2dbac5e460 __libc_start_main +
    245

    6    tmp3rvtwdo_                        0x000055e109e923d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659824803
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n  \
    \      } else if s == \")\" {\n            if stack.isEmpty {\n              \
    \  result = \"No\"\n            } else {\n                stack.pop()\n      \
    \      }\n        } else {\n            if stack.isEmpty {\n                result\
    \ = \"Yes\"\n            } else {\n                stack.pop()\n            }\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpp701w74k.swift:23:23: error: value of type '[String]' has no member\
    \ 'pop'\n                stack.pop()\n                ~~~~~ ^~~\n/tmp/tmpp701w74k.swift:29:23:\
    \ error: value of type '[String]' has no member 'pop'\n                stack.pop()\n\
    \                ~~~~~ ^~~\n"
  stdout: ''
  timestamp: 1659824804
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfunc match_parens(lst:\
    \ [String]) -> String {\n    guard lst.count >= 2 else { return \"No\" }\n   \
    \ guard lst[0] != \"(\" && lst[0] != \")\" else { return \"No\" }\n    guard lst[1]\
    \ != \"(\" && lst[1] != \")\" else { return \"No\" }\n    var stack = [String]()\n\
    \    var result = \"No\"\n    for s in lst {\n        if s == \"(\" {\n      \
    \      stack.append(s)\n        } else if s == \")\" {\n            if stack.count\
    \ > 0 {\n                stack.removeLast()\n            } else {\n          \
    \      result = \"Yes\"\n                break\n            }\n        } else\
    \ {\n            if stack.count > 0 {\n                stack.removeLast()\n  \
    \          } else {\n                result = \"No\"\n                break\n\
    \            }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmpwcicxhj0/tmpwcicxhj0.swift:54: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b816d091c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b816cd88b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b816cd88988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b816cd877b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpwcicxhj0                        0x00005561c1e00846 <unavailable> + 6214

    5    libc.so.6                          0x00002b816d27d460 __libc_start_main +
    245

    6    tmpwcicxhj0                        0x00005561c1e00429 <unavailable> + 5161

    '
  stdout: ''
  timestamp: 1659824804
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = Stack()\n    for s in lst {\n       \
    \ if s == '(' {\n            stack.push(s)\n        } else if s == ')' {\n   \
    \         if stack.top() == '(' {\n                stack.pop()\n            }\
    \ else {\n                return \"No\"\n            }\n        } else {\n   \
    \         return \"No\"\n        }\n    }\n    if stack.top() != nil {\n     \
    \   return \"No\"\n    } else {\n        return \"Yes\"\n    }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmp9044s0w7.swift:16:17: error: single-quoted string literal found,\
    \ use '\"'\n        if s == '(' {\n                ^~~\n                \"(\"\n\
    /tmp/tmp9044s0w7.swift:18:24: error: single-quoted string literal found, use '\"\
    '\n        } else if s == ')' {\n                       ^~~\n                \
    \       \")\"\n/tmp/tmp9044s0w7.swift:19:31: error: single-quoted string literal\
    \ found, use '\"'\n            if stack.top() == '(' {\n                     \
    \         ^~~\n                              \"(\"\n/tmp/tmp9044s0w7.swift:14:17:\
    \ error: cannot find 'Stack' in scope\n    var stack = Stack()\n             \
    \   ^~~~~\n"
  stdout: ''
  timestamp: 1659824803
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s.contains(\"(\") {\n            stack.append(s)\n\
    \        } else {\n            if stack.count > 0 {\n                if stack[stack.count\
    \ - 1] == s {\n                    stack.removeLast()\n                } else\
    \ {\n                    result = \"No\"\n                    break\n        \
    \        }\n            } else {\n                result = \"Yes\"\n         \
    \       break\n            }\n        }\n    }\n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpfh634lob/tmpfh634lob.swift:49: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aea44d56c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aea44a4db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aea44a4d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aea44a4c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpfh634lob                        0x0000561336e189c6 <unavailable> + 6598

    5    libc.so.6                          0x00002aea44f42460 __libc_start_main +
    245

    6    tmpfh634lob                        0x0000561336e185a9 <unavailable> + 5545

    '
  stdout: ''
  timestamp: 1659824804
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n  \
    \      } else if s == \")\" {\n            if stack.isEmpty {\n              \
    \  result = \"No\"\n            } else {\n                stack.removeLast()\n\
    \            }\n        } else {\n            if stack.isEmpty {\n           \
    \     result = \"Yes\"\n            } else {\n                stack.removeLast()\n\
    \            }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmp5dj0p34v/tmp5dj0p34v.swift:49: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b8ca084ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8ca0541b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b8ca0541988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b8ca05407b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp5dj0p34v                        0x000056319731d7f6 <unavailable> + 6134

    5    libc.so.6                          0x00002b8ca0a36460 __libc_start_main +
    245

    6    tmp5dj0p34v                        0x000056319731d3d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659824804
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfunc match_parens(lst:\
    \ [String]) -> String {\n    guard lst.count >= 2 else { return \"No\" }\n   \
    \ var stack = [String]()\n    var result = \"No\"\n    for s in lst {\n      \
    \  if s == \"(\" {\n            stack.append(s)\n        } else if s == \")\"\
    \ {\n            if stack.count > 0 {\n                stack.removeLast()\n  \
    \          } else {\n                result = \"Yes\"\n                break\n\
    \            }\n        } else {\n            if stack.count == 0 {\n        \
    \        result = \"Yes\"\n                break\n            }\n        }\n \
    \   }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpxcokijhz/tmpxcokijhz.swift:51: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b00ccd40c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b00cca37b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b00cca37988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b00cca367b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpxcokijhz                        0x000055c3804f6960 <unavailable> + 6496

    5    libc.so.6                          0x00002b00ccf2c460 __libc_start_main +
    245

    6    tmpxcokijhz                        0x000055c3804f63d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659824804
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = Stack()\n    for s in lst {\n       \
    \ if s == '(' {\n            stack.push(s)\n        } else if s == ')' {\n   \
    \         if stack.isEmpty {\n                return \"No\"\n            }\n \
    \           stack.pop()\n        } else {\n            if stack.isEmpty {\n  \
    \              return \"No\"\n            }\n            stack.pop()\n       \
    \     stack.push(s)\n        }\n    }\n    if stack.isEmpty {\n        return\
    \ \"Yes\"\n    }\n    return \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpw5zrrbgy.swift:16:17: error: single-quoted string literal found,\
    \ use '\"'\n        if s == '(' {\n                ^~~\n                \"(\"\n\
    /tmp/tmpw5zrrbgy.swift:18:24: error: single-quoted string literal found, use '\"\
    '\n        } else if s == ')' {\n                       ^~~\n                \
    \       \")\"\n/tmp/tmpw5zrrbgy.swift:14:17: error: cannot find 'Stack' in scope\n\
    \    var stack = Stack()\n                ^~~~~\n"
  stdout: ''
  timestamp: 1659824804
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n  \
    \      } else if s == \")\" {\n            if stack.isEmpty {\n              \
    \  result = \"No\"\n            } else {\n                stack.removeLast()\n\
    \            }\n        } else {\n            if stack.isEmpty {\n           \
    \     result = \"Yes\"\n            } else {\n                stack.removeLast()\n\
    \            }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmp5dj0p34v/tmp5dj0p34v.swift:49: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b8ca084ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8ca0541b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b8ca0541988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b8ca05407b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp5dj0p34v                        0x000056319731d7f6 <unavailable> + 6134

    5    libc.so.6                          0x00002b8ca0a36460 __libc_start_main +
    245

    6    tmp5dj0p34v                        0x000056319731d3d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659824804
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = Stack()\n    for s in lst {\n       \
    \ if s == \"(\" {\n            stack.push(s)\n        } else if s == \")\" {\n\
    \            if stack.top() == \"(\" {\n                stack.pop()\n        \
    \    } else {\n                return \"No\"\n            }\n        } else {\n\
    \            return \"No\"\n        }\n    }\n    if stack.top() == \"(\" {\n\
    \        return \"Yes\"\n    } else {\n        return \"No\"\n    }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpmdsy16gs.swift:14:17: error: cannot find 'Stack' in scope\n   \
    \ var stack = Stack()\n                ^~~~~\n"
  stdout: ''
  timestamp: 1659824804
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    for s in lst {\n    \
    \    if s == \"(\" {\n            stack.append(s)\n        } else if s == \")\"\
    \ {\n            if stack.isEmpty {\n                return \"No\"\n         \
    \   }\n            stack.removeLast()\n        } else if stack.isEmpty {\n   \
    \         return \"No\"\n        }\n    }\n    if stack.isEmpty {\n        return\
    \ \"Yes\"\n    }\n    return \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmpz2fyj22v/tmpz2fyj22v.swift:46: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b1988fe6c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b1988cddb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b1988cdd988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b1988cdc7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpz2fyj22v                        0x000055c8300317f6 <unavailable> + 6134

    5    libc.so.6                          0x00002b19891d2460 __libc_start_main +
    245

    6    tmpz2fyj22v                        0x000055c8300313d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659824804
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n  \
    \      } else if s == \")\" {\n            if stack.count > 0 {\n            \
    \    stack.removeLast()\n            } else {\n                result = \"Yes\"\
    \n                break\n            }\n        } else {\n            if stack.count\
    \ > 0 {\n                if stack.last == s {\n                    stack.removeLast()\n\
    \                } else {\n                    result = \"Yes\"\n            \
    \        break\n                }\n            } else {\n                result\
    \ = \"Yes\"\n                break\n            }\n        }\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"\
    ()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmp_d7phvad/tmp_d7phvad.swift:57: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b7e402bcc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b7e3ffb3b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b7e3ffb3988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b7e3ffb27b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp_d7phvad                        0x000055b27bd1b9c0 <unavailable> + 6592

    5    libc.so.6                          0x00002b7e404a8460 __libc_start_main +
    245

    6    tmp_d7phvad                        0x000055b27bd1b439 <unavailable> + 5177

    '
  stdout: ''
  timestamp: 1659824804
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n  \
    \      } else if s == \")\" {\n            if stack.isEmpty {\n              \
    \  result = \"No\"\n            } else {\n                stack.removeLast()\n\
    \            }\n        } else {\n            if stack.isEmpty {\n           \
    \     result = \"Yes\"\n            } else {\n                stack.removeLast()\n\
    \            }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmp5dj0p34v/tmp5dj0p34v.swift:49: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b8ca084ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8ca0541b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b8ca0541988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b8ca05407b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp5dj0p34v                        0x000056319731d7f6 <unavailable> + 6134

    5    libc.so.6                          0x00002b8ca0a36460 __libc_start_main +
    245

    6    tmp5dj0p34v                        0x000056319731d3d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659824804
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n  \
    \      } else if s == \")\" {\n            if stack.count > 0 {\n            \
    \    stack.removeLast()\n            } else {\n                result = \"Yes\"\
    \n            }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmp3rvtwdo_/tmp3rvtwdo_.swift:44: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b2dbaa72c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b2dba769b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b2dba769988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b2dba7687b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp3rvtwdo_                        0x000055e109e92960 <unavailable> + 6496

    5    libc.so.6                          0x00002b2dbac5e460 __libc_start_main +
    245

    6    tmp3rvtwdo_                        0x000055e109e923d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659824803
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n  \
    \      } else if s == \")\" {\n            if stack.isEmpty {\n              \
    \  result = \"Yes\"\n                break\n            }\n            stack.removeLast()\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmpc9tow60w/tmpc9tow60w.swift:44: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab676de7c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab676adeb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab676ade988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab676add7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpc9tow60w                        0x0000555f05973960 <unavailable> + 6496

    5    libc.so.6                          0x00002ab676fd3460 __libc_start_main +
    245

    6    tmpc9tow60w                        0x0000555f059733d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659824804
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n  \
    \      } else if s == \")\" {\n            if stack.isEmpty {\n              \
    \  result = \"Yes\"\n                break\n            } else {\n           \
    \     stack.removeLast()\n            }\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmp7eihgb1y/tmp7eihgb1y.swift:45: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b11fece8c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b11fe9dfb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b11fe9df988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b11fe9de7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp7eihgb1y                        0x0000559d7ffc8960 <unavailable> + 6496

    5    libc.so.6                          0x00002b11feed4460 __libc_start_main +
    245

    6    tmp7eihgb1y                        0x0000559d7ffc83d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659824804
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s == \"(\" || s == \")\" {\n            stack.append(s)\n\
    \        } else {\n            if stack.isEmpty {\n                result = \"\
    Yes\"\n                break\n            }\n            stack.pop()\n       \
    \ }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmp4kfrm8yq.swift:24:19: error: value of type '[String]' has no member\
    \ 'pop'\n            stack.pop()\n            ~~~~~ ^~~\n"
  stdout: ''
  timestamp: 1659824804
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n  \
    \      } else if s == \")\" {\n            if stack.isEmpty {\n              \
    \  result = \"No\"\n            } else {\n                stack.removeLast()\n\
    \            }\n        } else {\n            if stack.isEmpty {\n           \
    \     result = \"Yes\"\n            } else {\n                stack.removeLast()\n\
    \            }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmp5dj0p34v/tmp5dj0p34v.swift:49: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b8ca084ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8ca0541b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b8ca0541988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b8ca05407b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp5dj0p34v                        0x000056319731d7f6 <unavailable> + 6134

    5    libc.so.6                          0x00002b8ca0a36460 __libc_start_main +
    245

    6    tmp5dj0p34v                        0x000056319731d3d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659824804
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n  \
    \      } else if s == \")\" {\n            if stack.isEmpty {\n              \
    \  result = \"Yes\"\n                break\n            }\n            stack.removeLast()\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmpc9tow60w/tmpc9tow60w.swift:44: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab676de7c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab676adeb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab676ade988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab676add7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpc9tow60w                        0x0000555f05973960 <unavailable> + 6496

    5    libc.so.6                          0x00002ab676fd3460 __libc_start_main +
    245

    6    tmpc9tow60w                        0x0000555f059733d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659824804
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n  \
    \      } else if s == \")\" {\n            if stack.isEmpty {\n              \
    \  result = \"No\"\n                break\n            }\n            stack.removeLast()\n\
    \        }\n    }\n    if result == \"No\" {\n        result = \"Yes\"\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpczs4piqu/tmpczs4piqu.swift:47: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ace537d6c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ace534cdb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ace534cd988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ace534cc7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpczs4piqu                        0x000056181c34e960 <unavailable> + 6496

    5    libc.so.6                          0x00002ace539c2460 __libc_start_main +
    245

    6    tmpczs4piqu                        0x000056181c34e3d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659824804
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n  \
    \      } else if s == \")\" {\n            if stack.isEmpty {\n              \
    \  result = \"No\"\n                break\n            }\n            stack.removeLast()\n\
    \        } else {\n            if stack.isEmpty {\n                result = \"\
    Yes\"\n                break\n            }\n            stack.removeLast()\n\
    \            stack.append(s)\n        }\n    }\n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmper3pjgt7/tmper3pjgt7.swift:52: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b8f9a0dec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8f99dd5b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b8f99dd5988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b8f99dd47b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmper3pjgt7                        0x00005596ce385aeb <unavailable> + 6891

    5    libc.so.6                          0x00002b8f9a2ca460 __libc_start_main +
    245

    6    tmper3pjgt7                        0x00005596ce3853d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659824804
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s == \"(\" || s == \"{\" || s == \"[\" {\n   \
    \         stack.append(s)\n        } else if s == \"}\" || s == \"]\" {\n    \
    \        if stack.isEmpty {\n                result = \"No\"\n            } else\
    \ {\n                stack.removeLast()\n            }\n        } else if s ==\
    \ \")\" || s == \"]\" {\n            if stack.isEmpty {\n                result\
    \ = \"No\"\n            } else {\n                stack.removeLast()\n       \
    \     }\n        } else {\n            if stack.isEmpty {\n                result\
    \ = \"Yes\"\n            } else {\n                stack.removeLast()\n      \
    \      }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmp1ffbdkrw/tmp1ffbdkrw.swift:55: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aed895cbc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aed892c2b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aed892c2988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aed892c17b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp1ffbdkrw                        0x00005651ae8247f6 <unavailable> + 6134

    5    libc.so.6                          0x00002aed897b7460 __libc_start_main +
    245

    6    tmp1ffbdkrw                        0x00005651ae8243d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659824804
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s.contains(\"(\") {\n            stack.append(s)\n\
    \        } else {\n            if stack.count > 0 {\n                if s.contains(\"\
    )\") {\n                    stack.removeLast()\n                } else {\n   \
    \                 result = \"Yes\"\n                    break\n              \
    \  }\n            } else {\n                result = \"No\"\n                break\n\
    \            }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmpqsbmek2c/tmpqsbmek2c.swift:49: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b5043effc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b5043bf6b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b5043bf6988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b5043bf57b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpqsbmek2c                        0x000055739e400976 <unavailable> + 6518

    5    libc.so.6                          0x00002b50440eb460 __libc_start_main +
    245

    6    tmpqsbmek2c                        0x000055739e400559 <unavailable> + 5465

    '
  stdout: ''
  timestamp: 1659824804
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s == \"(\" || s == \")\" {\n            stack.append(s)\n\
    \        } else {\n            if stack.isEmpty {\n                result = \"\
    Yes\"\n                break\n            }\n            if stack[stack.count\
    \ - 1] == \"(\" && s == \"(\" {\n                stack.pop()\n            } else\
    \ if stack[stack.count - 1] == \")\" && s == \")\" {\n                stack.pop()\n\
    \            } else {\n                result = \"No\"\n                break\n\
    \            }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmp116u9g05.swift:25:23: error: value of type '[String]' has no member\
    \ 'pop'\n                stack.pop()\n                ~~~~~ ^~~\n/tmp/tmp116u9g05.swift:27:23:\
    \ error: value of type '[String]' has no member 'pop'\n                stack.pop()\n\
    \                ~~~~~ ^~~\n"
  stdout: ''
  timestamp: 1659824804
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n  \
    \      } else if s == \")\" {\n            if stack.isEmpty {\n              \
    \  result = \"Yes\"\n                break\n            } else {\n           \
    \     stack.pop()\n            }\n        }\n    }\n    return result\n}\n\n\n\
    func ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmprdxowq55.swift:24:23: error: value of type '[String]' has no member\
    \ 'pop'\n                stack.pop()\n                ~~~~~ ^~~\n"
  stdout: ''
  timestamp: 1659824804
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    for s in lst {\n    \
    \    if s == \"(\" {\n            stack.append(s)\n        } else if s == \")\"\
    \ {\n            if stack.count > 0 {\n                stack.removeLast()\n  \
    \          } else {\n                return \"No\"\n            }\n        }\n\
    \    }\n    if stack.count > 0 {\n        return \"No\"\n    } else {\n      \
    \  return \"Yes\"\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpu3t14x5e/tmpu3t14x5e.swift:46: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aadc0310c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aadc0007b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aadc0007988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aadc00067b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpu3t14x5e                        0x0000562e0126a7f6 <unavailable> + 6134

    5    libc.so.6                          0x00002aadc04fc460 __libc_start_main +
    245

    6    tmpu3t14x5e                        0x0000562e0126a3d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659824804
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n  \
    \      } else if s == \")\" {\n            if stack.isEmpty {\n              \
    \  result = \"No\"\n            } else {\n                stack.removeLast()\n\
    \            }\n        } else {\n            if stack.isEmpty {\n           \
    \     result = \"Yes\"\n            } else {\n                stack.removeLast()\n\
    \            }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmp5dj0p34v/tmp5dj0p34v.swift:49: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b8ca084ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8ca0541b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b8ca0541988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b8ca05407b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp5dj0p34v                        0x000056319731d7f6 <unavailable> + 6134

    5    libc.so.6                          0x00002b8ca0a36460 __libc_start_main +
    245

    6    tmp5dj0p34v                        0x000056319731d3d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659824804
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s == \"(\" || s == \")\" {\n            if stack.isEmpty\
    \ {\n                result = \"Yes\"\n                break\n            }\n\
    \            stack.removeLast()\n        } else {\n            stack.append(s)\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmpv_273aj5/tmpv_273aj5.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b7b54488c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b7b5417fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b7b5417f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b7b5417e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpv_273aj5                        0x00005557416297f6 <unavailable> + 6134

    5    libc.so.6                          0x00002b7b54674460 __libc_start_main +
    245

    6    tmpv_273aj5                        0x00005557416293d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659824804
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s.contains(\"(\") {\n            stack.append(s)\n\
    \        } else {\n            if stack.count > 0 {\n                if stack[stack.count\
    \ - 1] == s {\n                    stack.removeLast()\n                } else\
    \ {\n                    result = \"No\"\n                    break\n        \
    \        }\n            } else {\n                result = \"Yes\"\n         \
    \       break\n            }\n        }\n    }\n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpfh634lob/tmpfh634lob.swift:49: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aea44d56c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aea44a4db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aea44a4d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aea44a4c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpfh634lob                        0x0000561336e189c6 <unavailable> + 6598

    5    libc.so.6                          0x00002aea44f42460 __libc_start_main +
    245

    6    tmpfh634lob                        0x0000561336e185a9 <unavailable> + 5545

    '
  stdout: ''
  timestamp: 1659824804
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = Stack()\n    var result = \"No\"\n  \
    \  for s in lst {\n        if s == \"(\" {\n            stack.push(s)\n      \
    \  } else if s == \")\" {\n            if stack.len() == 0 {\n               \
    \ result = \"No\"\n                break\n            }\n            stack.pop()\n\
    \        } else {\n            if stack.len() != 0 {\n                result =\
    \ \"No\"\n                break\n            }\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpvn6_afrq.swift:14:17: error: cannot find 'Stack' in scope\n   \
    \ var stack = Stack()\n                ^~~~~\n"
  stdout: ''
  timestamp: 1659824804
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s == \"(\" || s == \")\" {\n            stack.append(s)\n\
    \        } else {\n            if stack.count > 0 {\n                if stack[stack.count\
    \ - 1] == s {\n                    stack.removeLast()\n                } else\
    \ {\n                    result = \"No\"\n                    break\n        \
    \        }\n            } else {\n                result = \"Yes\"\n         \
    \       break\n            }\n        }\n    }\n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmp2dhb_66l/tmp2dhb_66l.swift:51: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af704ccdc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af7049c4b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af7049c4988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af7049c37b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp2dhb_66l                        0x000055abca369b3b <unavailable> + 6971

    5    libc.so.6                          0x00002af704eb9460 __libc_start_main +
    245

    6    tmp2dhb_66l                        0x000055abca369429 <unavailable> + 5161

    '
  stdout: ''
  timestamp: 1659824804
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n  \
    \      } else if s == \")\" {\n            if stack.isEmpty {\n              \
    \  result = \"No\"\n            } else {\n                stack.removeLast()\n\
    \            }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmpd5fe1gvn/tmpd5fe1gvn.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ae597bb6c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ae5978adb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ae5978ad988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ae5978ac7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpd5fe1gvn                        0x000055621af007f6 <unavailable> + 6134

    5    libc.so.6                          0x00002ae597da2460 __libc_start_main +
    245

    6    tmpd5fe1gvn                        0x000055621af003d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659824804
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n  \
    \      } else if s == \")\" {\n            if stack.isEmpty {\n              \
    \  result = \"No\"\n            } else {\n                stack.removeLast()\n\
    \            }\n        } else {\n            if stack.isEmpty {\n           \
    \     result = \"Yes\"\n            } else {\n                stack.removeLast()\n\
    \            }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmp5dj0p34v/tmp5dj0p34v.swift:49: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b8ca084ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8ca0541b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b8ca0541988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b8ca05407b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp5dj0p34v                        0x000056319731d7f6 <unavailable> + 6134

    5    libc.so.6                          0x00002b8ca0a36460 __libc_start_main +
    245

    6    tmp5dj0p34v                        0x000056319731d3d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659824804
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n  \
    \      } else if s == \")\" {\n            if stack.isEmpty {\n              \
    \  result = \"No\"\n            } else {\n                stack.removeLast()\n\
    \            }\n        } else {\n            if stack.isEmpty {\n           \
    \     result = \"Yes\"\n            } else {\n                stack.removeLast()\n\
    \            }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmp5dj0p34v/tmp5dj0p34v.swift:49: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b8ca084ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8ca0541b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b8ca0541988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b8ca05407b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp5dj0p34v                        0x000056319731d7f6 <unavailable> + 6134

    5    libc.so.6                          0x00002b8ca0a36460 __libc_start_main +
    245

    6    tmp5dj0p34v                        0x000056319731d3d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659824804
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n  \
    \      } else if s == \")\" {\n            if stack.isEmpty {\n              \
    \  result = \"No\"\n                break\n            } else {\n            \
    \    stack.removeLast()\n            }\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpw1xwkq0d/tmpw1xwkq0d.swift:44: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af2c3125c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af2c2e1cb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af2c2e1c988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af2c2e1b7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpw1xwkq0d                        0x000055e53e8e47f6 <unavailable> + 6134

    5    libc.so.6                          0x00002af2c3311460 __libc_start_main +
    245

    6    tmpw1xwkq0d                        0x000055e53e8e43d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659824804
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = Stack()\n    for s in lst {\n       \
    \ if s == '(' {\n            stack.push(s)\n        } else if s == ')' {\n   \
    \         if stack.top() == '(' {\n                stack.pop()\n            }\
    \ else {\n                return \"No\"\n            }\n        } else {\n   \
    \         return \"No\"\n        }\n    }\n    if stack.top() != nil {\n     \
    \   return \"No\"\n    } else {\n        return \"Yes\"\n    }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmp9044s0w7.swift:16:17: error: single-quoted string literal found,\
    \ use '\"'\n        if s == '(' {\n                ^~~\n                \"(\"\n\
    /tmp/tmp9044s0w7.swift:18:24: error: single-quoted string literal found, use '\"\
    '\n        } else if s == ')' {\n                       ^~~\n                \
    \       \")\"\n/tmp/tmp9044s0w7.swift:19:31: error: single-quoted string literal\
    \ found, use '\"'\n            if stack.top() == '(' {\n                     \
    \         ^~~\n                              \"(\"\n/tmp/tmp9044s0w7.swift:14:17:\
    \ error: cannot find 'Stack' in scope\n    var stack = Stack()\n             \
    \   ^~~~~\n"
  stdout: ''
  timestamp: 1659824803
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n  \
    \      } else if s == \")\" {\n            if stack.isEmpty {\n              \
    \  result = \"Yes\"\n                break\n            }\n            stack.removeLast()\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmpc9tow60w/tmpc9tow60w.swift:44: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab676de7c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab676adeb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab676ade988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab676add7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpc9tow60w                        0x0000555f05973960 <unavailable> + 6496

    5    libc.so.6                          0x00002ab676fd3460 __libc_start_main +
    245

    6    tmpc9tow60w                        0x0000555f059733d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659824804
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = Stack()\n    for s in lst {\n       \
    \ if s == '(' {\n            stack.push(s)\n        } else if s == ')' {\n   \
    \         if stack.top() == '(' {\n                stack.pop()\n            }\
    \ else {\n                return \"No\"\n            }\n        } else {\n   \
    \         return \"No\"\n        }\n    }\n    if stack.top() != nil {\n     \
    \   return \"No\"\n    } else {\n        return \"Yes\"\n    }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmp9044s0w7.swift:16:17: error: single-quoted string literal found,\
    \ use '\"'\n        if s == '(' {\n                ^~~\n                \"(\"\n\
    /tmp/tmp9044s0w7.swift:18:24: error: single-quoted string literal found, use '\"\
    '\n        } else if s == ')' {\n                       ^~~\n                \
    \       \")\"\n/tmp/tmp9044s0w7.swift:19:31: error: single-quoted string literal\
    \ found, use '\"'\n            if stack.top() == '(' {\n                     \
    \         ^~~\n                              \"(\"\n/tmp/tmp9044s0w7.swift:14:17:\
    \ error: cannot find 'Stack' in scope\n    var stack = Stack()\n             \
    \   ^~~~~\n"
  stdout: ''
  timestamp: 1659824803
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s.contains(\"(\") {\n            stack.append(s)\n\
    \        } else {\n            if stack.count > 0 {\n                if stack[stack.count\
    \ - 1] == s {\n                    stack.removeLast()\n                } else\
    \ {\n                    result = \"No\"\n                    break\n        \
    \        }\n            } else {\n                result = \"Yes\"\n         \
    \       break\n            }\n        }\n    }\n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpfh634lob/tmpfh634lob.swift:49: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aea44d56c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aea44a4db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aea44a4d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aea44a4c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpfh634lob                        0x0000561336e189c6 <unavailable> + 6598

    5    libc.so.6                          0x00002aea44f42460 __libc_start_main +
    245

    6    tmpfh634lob                        0x0000561336e185a9 <unavailable> + 5545

    '
  stdout: ''
  timestamp: 1659824804
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = Stack()\n    for s in lst {\n       \
    \ if s == '(' {\n            stack.push(s)\n        } else if s == ')' {\n   \
    \         if stack.isEmpty {\n                return \"No\"\n            }\n \
    \           stack.pop()\n        }\n    }\n    if stack.isEmpty {\n        return\
    \ \"Yes\"\n    }\n    return \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpq4q70pes.swift:16:17: error: single-quoted string literal found,\
    \ use '\"'\n        if s == '(' {\n                ^~~\n                \"(\"\n\
    /tmp/tmpq4q70pes.swift:18:24: error: single-quoted string literal found, use '\"\
    '\n        } else if s == ')' {\n                       ^~~\n                \
    \       \")\"\n/tmp/tmpq4q70pes.swift:14:17: error: cannot find 'Stack' in scope\n\
    \    var stack = Stack()\n                ^~~~~\n"
  stdout: ''
  timestamp: 1659824804
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n  \
    \      } else if s == \")\" {\n            if stack.last == \"(\" {\n        \
    \        stack.removeLast()\n            } else {\n                result = \"\
    Yes\"\n                break\n            }\n        } else {\n            result\
    \ = \"No\"\n            break\n        }\n    }\n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmprgzbibob/tmprgzbibob.swift:47: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b7eeba63c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b7eeb75ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b7eeb75a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b7eeb7597b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmprgzbibob                        0x0000559e5d6497f6 <unavailable> + 6134

    5    libc.so.6                          0x00002b7eebc4f460 __libc_start_main +
    245

    6    tmprgzbibob                        0x0000559e5d6493d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659824804
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s == \"(\" || s == \")\" {\n            if stack.isEmpty\
    \ {\n                result = \"Yes\"\n                break\n            }\n\
    \            stack.removeLast()\n        } else {\n            stack.append(s)\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmpv_273aj5/tmpv_273aj5.swift:43: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b7b54488c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b7b5417fb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b7b5417f988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b7b5417e7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpv_273aj5                        0x00005557416297f6 <unavailable> + 6134

    5    libc.so.6                          0x00002b7b54674460 __libc_start_main +
    245

    6    tmpv_273aj5                        0x00005557416293d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659824804
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s.contains(\"(\") {\n            stack.append(s)\n\
    \        }\n        if s.contains(\")\") {\n            if stack.count > 0 {\n\
    \                stack.removeLast()\n            } else {\n                result\
    \ = \"Yes\"\n            }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmpscodgx4v/tmpscodgx4v.swift:45: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b187112ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b1870e21b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b1870e21988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b1870e207b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpscodgx4v                        0x0000555f83707ae0 <unavailable> + 6880

    5    libc.so.6                          0x00002b1871316460 __libc_start_main +
    245

    6    tmpscodgx4v                        0x0000555f83707559 <unavailable> + 5465

    '
  stdout: ''
  timestamp: 1659824804
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    for s in lst {\n    \
    \    if s == \"(\" {\n            stack.append(s)\n        } else if s == \")\"\
    \ {\n            if stack.count > 0 {\n                stack.removeLast()\n  \
    \          } else {\n                return \"No\"\n            }\n        } else\
    \ {\n            if stack.count > 0 {\n                stack.removeLast()\n  \
    \          }\n        }\n    }\n    if stack.count > 0 {\n        return \"No\"\
    \n    } else {\n        return \"Yes\"\n    }\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmpi_224w2h/tmpi_224w2h.swift:50: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b6fbfafac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6fbf7f1b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b6fbf7f1988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b6fbf7f07b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpi_224w2h                        0x0000555dc61b37f6 <unavailable> + 6134

    5    libc.so.6                          0x00002b6fbfce6460 __libc_start_main +
    245

    6    tmpi_224w2h                        0x0000555dc61b33d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659824804
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfunc match_parens(lst:\
    \ [String]) -> String {\n    guard lst.count >= 2 else { return \"No\" }\n   \
    \ var stack = [String]()\n    var result = \"No\"\n    for s in lst {\n      \
    \  if s == \"(\" {\n            stack.append(s)\n        } else if s == \")\"\
    \ {\n            if stack.count > 0 {\n                stack.removeLast()\n  \
    \          } else {\n                result = \"Yes\"\n            }\n       \
    \ }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmp22i0_wyr/tmp22i0_wyr.swift:45: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9a6022dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9a5ff24b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9a5ff24988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9a5ff237b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp22i0_wyr                        0x0000563810463960 <unavailable> + 6496

    5    libc.so.6                          0x00002b9a60419460 __libc_start_main +
    245

    6    tmp22i0_wyr                        0x00005638104633d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659824804
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n  \
    \      } else if s == \")\" {\n            if stack.count > 0 {\n            \
    \    stack.removeLast()\n            } else {\n                result = \"Yes\"\
    \n            }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmp3rvtwdo_/tmp3rvtwdo_.swift:44: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b2dbaa72c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b2dba769b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b2dba769988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b2dba7687b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp3rvtwdo_                        0x000055e109e92960 <unavailable> + 6496

    5    libc.so.6                          0x00002b2dbac5e460 __libc_start_main +
    245

    6    tmp3rvtwdo_                        0x000055e109e923d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659824803
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s == \"(\" || s == \"{\" || s == \"[\" {\n   \
    \         stack.append(s)\n        } else if s == \"}\" || s == \"]\" {\n    \
    \        if stack.isEmpty {\n                result = \"No\"\n               \
    \ break\n            } else {\n                stack.pop()\n            }\n  \
    \      } else {\n            if stack.isEmpty {\n                result = \"Yes\"\
    \n                break\n            }\n            if stack[stack.count - 1]\
    \ == s {\n                stack.pop()\n            } else {\n                result\
    \ = \"No\"\n                break\n            }\n        }\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"\
    ()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmprcbrlesd.swift:24:23: error: value of type '[String]' has no member\
    \ 'pop'\n                stack.pop()\n                ~~~~~ ^~~\n/tmp/tmprcbrlesd.swift:32:23:\
    \ error: value of type '[String]' has no member 'pop'\n                stack.pop()\n\
    \                ~~~~~ ^~~\n"
  stdout: ''
  timestamp: 1659824804
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfunc match_parens(lst:\
    \ [String]) -> String {\n    guard lst.count >= 2 else { return \"No\" }\n   \
    \ var stack = [String]()\n    var result = \"No\"\n    for s in lst {\n      \
    \  if s == \"(\" {\n            stack.append(s)\n        } else if s == \")\"\
    \ {\n            if stack.count > 0 {\n                stack.removeLast()\n  \
    \          } else {\n                result = \"Yes\"\n            }\n       \
    \ }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmp22i0_wyr/tmp22i0_wyr.swift:45: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9a6022dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9a5ff24b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9a5ff24988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9a5ff237b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp22i0_wyr                        0x0000563810463960 <unavailable> + 6496

    5    libc.so.6                          0x00002b9a60419460 __libc_start_main +
    245

    6    tmp22i0_wyr                        0x00005638104633d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659824804
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n  \
    \      } else if s == \")\" {\n            if stack.isEmpty {\n              \
    \  result = \"No\"\n            } else {\n                stack.removeLast()\n\
    \            }\n        } else {\n            if stack.isEmpty {\n           \
    \     result = \"Yes\"\n            } else {\n                stack.removeLast()\n\
    \            }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmp5dj0p34v/tmp5dj0p34v.swift:49: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b8ca084ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8ca0541b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b8ca0541988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b8ca05407b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp5dj0p34v                        0x000056319731d7f6 <unavailable> + 6134

    5    libc.so.6                          0x00002b8ca0a36460 __libc_start_main +
    245

    6    tmp5dj0p34v                        0x000056319731d3d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659824804
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n  \
    \      } else if s == \")\" {\n            if stack.count > 0 {\n            \
    \    stack.removeLast()\n            } else {\n                result = \"Yes\"\
    \n            }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmp3rvtwdo_/tmp3rvtwdo_.swift:44: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b2dbaa72c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b2dba769b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b2dba769988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b2dba7687b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp3rvtwdo_                        0x000055e109e92960 <unavailable> + 6496

    5    libc.so.6                          0x00002b2dbac5e460 __libc_start_main +
    245

    6    tmp3rvtwdo_                        0x000055e109e923d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659824803
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    for s in lst {\n    \
    \    if s == \"(\" {\n            stack.append(s)\n        } else if s == \")\"\
    \ {\n            if stack.isEmpty {\n                return \"No\"\n         \
    \   }\n            stack.removeLast()\n        } else {\n            if stack.isEmpty\
    \ {\n                return \"Yes\"\n            }\n            stack.removeLast()\n\
    \            stack.append(s)\n        }\n    }\n    return \"No\"\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpjdm8qf06/tmpjdm8qf06.swift:49: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af76b519c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af76b210b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af76b210988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af76b20f7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpjdm8qf06                        0x0000558bea806aeb <unavailable> + 6891

    5    libc.so.6                          0x00002af76b705460 __libc_start_main +
    245

    6    tmpjdm8qf06                        0x0000558bea8063d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659824803
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n  \
    \      } else if s == \")\" {\n            if stack.count > 0 {\n            \
    \    stack.removeLast()\n            } else {\n                result = \"Yes\"\
    \n            }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmp3rvtwdo_/tmp3rvtwdo_.swift:44: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b2dbaa72c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b2dba769b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b2dba769988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b2dba7687b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp3rvtwdo_                        0x000055e109e92960 <unavailable> + 6496

    5    libc.so.6                          0x00002b2dbac5e460 __libc_start_main +
    245

    6    tmp3rvtwdo_                        0x000055e109e923d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659824803
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    for s in lst {\n    \
    \    if s.contains(\"(\") {\n            stack.append(s)\n        } else {\n \
    \           if stack.count > 0 {\n                let top = stack.removeLast()\n\
    \                if top == s {\n                    stack.append(s)\n        \
    \        }\n            }\n        }\n    }\n    if stack.count > 0 {\n      \
    \  return \"No\"\n    } else {\n        return \"Yes\"\n    }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmpr34q3igw/tmpr34q3igw.swift:48: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b49a50f5c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b49a4decb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b49a4dec988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b49a4deb7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpr34q3igw                        0x00005579eb583ae0 <unavailable> + 6880

    5    libc.so.6                          0x00002b49a52e1460 __libc_start_main +
    245

    6    tmpr34q3igw                        0x00005579eb583559 <unavailable> + 5465

    '
  stdout: ''
  timestamp: 1659824804
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n  \
    \      } else if s == \")\" {\n            if stack.isEmpty {\n              \
    \  result = \"No\"\n            } else {\n                stack.removeLast()\n\
    \            }\n        } else {\n            if stack.isEmpty {\n           \
    \     result = \"Yes\"\n            } else {\n                stack.removeLast()\n\
    \            }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmp5dj0p34v/tmp5dj0p34v.swift:49: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b8ca084ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8ca0541b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b8ca0541988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b8ca05407b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp5dj0p34v                        0x000056319731d7f6 <unavailable> + 6134

    5    libc.so.6                          0x00002b8ca0a36460 __libc_start_main +
    245

    6    tmp5dj0p34v                        0x000056319731d3d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659824804
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n  \
    \      } else if s == \")\" {\n            if stack.isEmpty {\n              \
    \  result = \"Yes\"\n                break\n            }\n            stack.removeLast()\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmpc9tow60w/tmpc9tow60w.swift:44: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab676de7c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab676adeb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab676ade988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab676add7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpc9tow60w                        0x0000555f05973960 <unavailable> + 6496

    5    libc.so.6                          0x00002ab676fd3460 __libc_start_main +
    245

    6    tmpc9tow60w                        0x0000555f059733d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659824804
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n  \
    \      } else if s == \")\" {\n            if stack.isEmpty {\n              \
    \  result = \"Yes\"\n                break\n            }\n            stack.removeLast()\n\
    \        } else {\n            if stack.isEmpty {\n                result = \"\
    Yes\"\n                break\n            }\n            stack.removeLast()\n\
    \            stack.append(s)\n        }\n    }\n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmp5yctdyd3/tmp5yctdyd3.swift:51: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b27a36e3c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b27a33dab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b27a33da988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b27a33d97b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp5yctdyd3                        0x000056491dca9960 <unavailable> + 6496

    5    libc.so.6                          0x00002b27a38cf460 __libc_start_main +
    245

    6    tmp5yctdyd3                        0x000056491dca93d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659824803
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n  \
    \      } else if s == \")\" {\n            if stack.isEmpty {\n              \
    \  result = \"Yes\"\n                break\n            } else {\n           \
    \     stack.removeLast()\n            }\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmp7eihgb1y/tmp7eihgb1y.swift:45: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b11fece8c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b11fe9dfb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b11fe9df988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b11fe9de7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp7eihgb1y                        0x0000559d7ffc8960 <unavailable> + 6496

    5    libc.so.6                          0x00002b11feed4460 __libc_start_main +
    245

    6    tmp7eihgb1y                        0x0000559d7ffc83d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659824804
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = Stack()\n    for s in lst {\n       \
    \ if s == '(' {\n            stack.push(s)\n        } else if s == ')' {\n   \
    \         if stack.top() == '(' {\n                stack.pop()\n            }\
    \ else {\n                return \"No\"\n            }\n        } else {\n   \
    \         return \"No\"\n        }\n    }\n    if stack.top() != nil {\n     \
    \   return \"No\"\n    } else {\n        return \"Yes\"\n    }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmp9044s0w7.swift:16:17: error: single-quoted string literal found,\
    \ use '\"'\n        if s == '(' {\n                ^~~\n                \"(\"\n\
    /tmp/tmp9044s0w7.swift:18:24: error: single-quoted string literal found, use '\"\
    '\n        } else if s == ')' {\n                       ^~~\n                \
    \       \")\"\n/tmp/tmp9044s0w7.swift:19:31: error: single-quoted string literal\
    \ found, use '\"'\n            if stack.top() == '(' {\n                     \
    \         ^~~\n                              \"(\"\n/tmp/tmp9044s0w7.swift:14:17:\
    \ error: cannot find 'Stack' in scope\n    var stack = Stack()\n             \
    \   ^~~~~\n"
  stdout: ''
  timestamp: 1659824803
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = Stack()\n    for s in lst {\n       \
    \ if s == \"(\" {\n            stack.push(s)\n        } else if s == \")\" {\n\
    \            if stack.top() == \"(\" {\n                stack.pop()\n        \
    \    } else {\n                return \"No\"\n            }\n        } else {\n\
    \            return \"No\"\n        }\n    }\n    if stack.top() == \"(\" {\n\
    \        return \"Yes\"\n    } else {\n        return \"No\"\n    }\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpmdsy16gs.swift:14:17: error: cannot find 'Stack' in scope\n   \
    \ var stack = Stack()\n                ^~~~~\n"
  stdout: ''
  timestamp: 1659824804
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n  \
    \      } else if s == \")\" {\n            if stack.isEmpty {\n              \
    \  result = \"No\"\n            } else {\n                stack.removeLast()\n\
    \            }\n        } else {\n            if stack.isEmpty {\n           \
    \     result = \"Yes\"\n            } else {\n                if stack.removeLast()\
    \ != s {\n                    result = \"No\"\n                    break\n   \
    \             }\n            }\n        }\n    }\n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpqjs13oft/tmpqjs13oft.swift:52: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b2a40a8ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b2a40785b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b2a40785988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b2a407847b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpqjs13oft                        0x000055c44d91e7f6 <unavailable> + 6134

    5    libc.so.6                          0x00002b2a40c7a460 __libc_start_main +
    245

    6    tmpqjs13oft                        0x000055c44d91e3d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659824804
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n  \
    \      } else if s == \")\" {\n            if stack.isEmpty {\n              \
    \  result = \"Yes\"\n                break\n            }\n            stack.removeLast()\n\
    \        } else {\n            if stack.isEmpty {\n                result = \"\
    Yes\"\n                break\n            }\n            stack.removeLast()\n\
    \            stack.append(s)\n        }\n    }\n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmp5yctdyd3/tmp5yctdyd3.swift:51: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b27a36e3c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b27a33dab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b27a33da988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b27a33d97b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp5yctdyd3                        0x000056491dca9960 <unavailable> + 6496

    5    libc.so.6                          0x00002b27a38cf460 __libc_start_main +
    245

    6    tmp5yctdyd3                        0x000056491dca93d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659824803
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s.contains(\"(\") {\n            stack.append(s)\n\
    \        } else {\n            if stack.count > 0 {\n                if stack.last\
    \ == s {\n                    stack.removeLast()\n                } else {\n \
    \                   result = \"No\"\n                    break\n             \
    \   }\n            }\n        }\n    }\n    if stack.count > 0 {\n        result\
    \ = \"Yes\"\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmp5qgiu9q9/tmp5qgiu9q9.swift:51: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b6a81d80c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6a81a77b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b6a81a77988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b6a81a767b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp5qgiu9q9                        0x000056196a882cbb <unavailable> + 7355

    5    libc.so.6                          0x00002b6a81f6c460 __libc_start_main +
    245

    6    tmp5qgiu9q9                        0x000056196a8825a9 <unavailable> + 5545

    '
  stdout: ''
  timestamp: 1659824804
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfunc match_parens(lst:\
    \ [String]) -> String {\n    \n    var stack = [String]()\n    var result = \"\
    No\"\n    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n\
    \        } else if s == \")\" {\n            if stack.last == \"(\" {\n      \
    \          stack.removeLast()\n            } else {\n                result =\
    \ \"Yes\"\n                break\n            }\n        } else {\n          \
    \  if stack.last == \")\" {\n                stack.removeLast()\n            }\
    \ else {\n                result = \"No\"\n                break\n           \
    \ }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmp_tfr0p35/tmp_tfr0p35.swift:52: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9b97eddc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9b97bd4b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9b97bd4988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9b97bd37b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp_tfr0p35                        0x00005616729537f6 <unavailable> + 6134

    5    libc.so.6                          0x00002b9b980c9460 __libc_start_main +
    245

    6    tmp_tfr0p35                        0x00005616729533d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659824804
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n  \
    \      } else if s == \")\" {\n            if stack.isEmpty {\n              \
    \  result = \"No\"\n            } else {\n                stack.removeLast()\n\
    \            }\n        } else {\n            if stack.isEmpty {\n           \
    \     result = \"Yes\"\n            } else {\n                stack.removeLast()\n\
    \            }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmp5dj0p34v/tmp5dj0p34v.swift:49: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b8ca084ac80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b8ca0541b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b8ca0541988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b8ca05407b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp5dj0p34v                        0x000056319731d7f6 <unavailable> + 6134

    5    libc.so.6                          0x00002b8ca0a36460 __libc_start_main +
    245

    6    tmp5dj0p34v                        0x000056319731d3d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659824804
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    for s in lst {\n    \
    \    if s == \"(\" {\n            stack.append(s)\n        } else if s == \")\"\
    \ {\n            if stack.last == \"(\" {\n                stack.removeLast()\n\
    \            } else {\n                return \"No\"\n            }\n        }\
    \ else {\n            return \"No\"\n        }\n    }\n    if stack.last == \"\
    (\" {\n        return \"Yes\"\n    } else {\n        return \"No\"\n    }\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmp5gz72ukx/tmp5gz72ukx.swift:48: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b91b5cc9c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b91b59c0b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b91b59c0988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b91b59bf7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp5gz72ukx                        0x000056496a53a7f6 <unavailable> + 6134

    5    libc.so.6                          0x00002b91b5eb5460 __libc_start_main +
    245

    6    tmp5gz72ukx                        0x000056496a53a3d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659824804
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    for s in lst {\n    \
    \    if s == \"(\" {\n            stack.append(s)\n        } else if s == \")\"\
    \ {\n            if stack.last == \"(\" {\n                stack.removeLast()\n\
    \            } else {\n                return \"No\"\n            }\n        }\
    \ else {\n            if stack.last == \")\" {\n                stack.removeLast()\n\
    \            } else {\n                return \"No\"\n            }\n        }\n\
    \    }\n    if stack.last == \")\" {\n        return \"Yes\"\n    } else {\n \
    \       return \"No\"\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpp84jt65n/tmpp84jt65n.swift:52: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0095acdc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b00957c4b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b00957c4988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b00957c37b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpp84jt65n                        0x00005567bcead7f6 <unavailable> + 6134

    5    libc.so.6                          0x00002b0095cb9460 __libc_start_main +
    245

    6    tmpp84jt65n                        0x00005567bcead3d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659824804
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfunc match_parens(lst:\
    \ [String]) -> String {\n    guard lst.count >= 2 else { return \"No\" }\n   \
    \ var stack = [String]()\n    var result = \"No\"\n    for s in lst {\n      \
    \  if s == \"(\" {\n            stack.append(s)\n        } else if s == \")\"\
    \ {\n            if stack.count > 0 {\n                stack.removeLast()\n  \
    \          } else {\n                result = \"Yes\"\n                break\n\
    \            }\n        } else {\n            if stack.count > 0 {\n         \
    \       if stack.last == s {\n                    stack.removeLast()\n       \
    \         } else {\n                    result = \"No\"\n                    break\n\
    \                }\n            } else {\n                result = \"Yes\"\n \
    \               break\n            }\n        }\n    }\n    return result\n}\n\
    \n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmp1nvxcsnd/tmp1nvxcsnd.swift:58: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b0e6390fc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b0e63606b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b0e63606988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b0e636057b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp1nvxcsnd                        0x00005627dcc579c0 <unavailable> + 6592

    5    libc.so.6                          0x00002b0e63afb460 __libc_start_main +
    245

    6    tmp1nvxcsnd                        0x00005627dcc57439 <unavailable> + 5177

    '
  stdout: ''
  timestamp: 1659824804
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n  \
    \      } else if s == \")\" {\n            if stack.count > 0 {\n            \
    \    stack.removeLast()\n            } else {\n                result = \"Yes\"\
    \n                break\n            }\n        } else {\n            if stack.count\
    \ > 0 {\n                stack.removeLast()\n            }\n        }\n    }\n\
    \    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmp260rkg0p/tmp260rkg0p.swift:49: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac4c2f5ec80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac4c2c55b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac4c2c55988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac4c2c547b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp260rkg0p                        0x0000563682439960 <unavailable> + 6496

    5    libc.so.6                          0x00002ac4c314a460 __libc_start_main +
    245

    6    tmp260rkg0p                        0x00005636824393d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659824804
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s == \"(\" || s == \"{\" || s == \"[\" {\n   \
    \         stack.append(s)\n        } else if s == \"}\" || s == \"]\" {\n    \
    \        if stack.isEmpty {\n                result = \"No\"\n            } else\
    \ {\n                stack.removeLast()\n            }\n        } else if s ==\
    \ \")\" || s == \"]\" {\n            if stack.isEmpty {\n                result\
    \ = \"No\"\n            } else {\n                stack.removeLast()\n       \
    \     }\n        } else {\n            if stack.isEmpty {\n                result\
    \ = \"Yes\"\n            } else {\n                stack.removeLast()\n      \
    \      }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)],\
    \ right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n       \
    \ return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r\
    \ {\n            return false\n        }\n    }\n    return true\n}\n        \
    \    \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmp1ffbdkrw/tmp1ffbdkrw.swift:55: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aed895cbc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aed892c2b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aed892c2988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aed892c17b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp1ffbdkrw                        0x00005651ae8247f6 <unavailable> + 6134

    5    libc.so.6                          0x00002aed897b7460 __libc_start_main +
    245

    6    tmp1ffbdkrw                        0x00005651ae8243d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659824804
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n  \
    \      } else if s == \")\" {\n            if stack.isEmpty {\n              \
    \  result = \"No\"\n                break\n            } else {\n            \
    \    stack.pop()\n            }\n        } else {\n            if stack.isEmpty\
    \ {\n                result = \"Yes\"\n                break\n            }\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmp69876kf1.swift:24:23: error: value of type '[String]' has no member\
    \ 'pop'\n                stack.pop()\n                ~~~~~ ^~~\n"
  stdout: ''
  timestamp: 1659824804
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    for s in lst {\n    \
    \    if s.contains(\"(\") {\n            stack.append(s)\n        }\n        if\
    \ s.contains(\")\") {\n            if stack.count > 0 {\n                stack.removeLast()\n\
    \            }\n        }\n    }\n    if stack.count == 0 {\n        return \"\
    No\"\n    }\n    return \"Yes\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmp4d9yrmpz/tmp4d9yrmpz.swift:44: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b2e6b5b5c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b2e6b2acb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b2e6b2ac988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b2e6b2ab7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp4d9yrmpz                        0x00005559e1c1e976 <unavailable> + 6518

    5    libc.so.6                          0x00002b2e6b7a1460 __libc_start_main +
    245

    6    tmp4d9yrmpz                        0x00005559e1c1e559 <unavailable> + 5465

    '
  stdout: ''
  timestamp: 1659824804
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfunc match_parens(lst:\
    \ [String]) -> String {\n    guard lst.count >= 2 else { return \"No\" }\n   \
    \ var stack = [String]()\n    var result = \"No\"\n    for s in lst {\n      \
    \  if s.contains(\"(\") {\n            stack.append(s)\n        } else if s.contains(\"\
    )\") {\n            if stack.count > 0 {\n                stack.removeLast()\n\
    \            } else {\n                result = \"Yes\"\n            }\n     \
    \   }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpfppwiojf/tmpfppwiojf.swift:44: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b6527ae5c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b65277dcb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b65277dc988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b65277db7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpfppwiojf                        0x000055ba515d8976 <unavailable> + 6518

    5    libc.so.6                          0x00002b6527cd1460 __libc_start_main +
    245

    6    tmpfppwiojf                        0x000055ba515d8559 <unavailable> + 5465

    '
  stdout: ''
  timestamp: 1659824804
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s.contains(\"(\") {\n            stack.append(s)\n\
    \        } else {\n            if stack.count > 0 {\n                if stack[stack.count\
    \ - 1] == s {\n                    stack.removeLast()\n                } else\
    \ {\n                    result = \"Yes\"\n                    break\n       \
    \         }\n            } else {\n                result = \"Yes\"\n        \
    \        break\n            }\n        }\n    }\n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpy2cy1ovn/tmpy2cy1ovn.swift:50: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b6e8d84bc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6e8d542b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b6e8d542988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b6e8d5417b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpy2cy1ovn                        0x000055f570bebb30 <unavailable> + 6960

    5    libc.so.6                          0x00002b6e8da37460 __libc_start_main +
    245

    6    tmpy2cy1ovn                        0x000055f570beb5a9 <unavailable> + 5545

    '
  stdout: ''
  timestamp: 1659824804
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfunc match_parens(lst:\
    \ [String]) -> String {\n    guard lst.count >= 2 else { return \"No\" }\n   \
    \ var stack = [String]()\n    var result = \"No\"\n    for s in lst {\n      \
    \  if s == \"(\" {\n            stack.append(s)\n        } else if s == \")\"\
    \ {\n            if stack.count > 0 {\n                stack.removeLast()\n  \
    \          } else {\n                result = \"Yes\"\n                break\n\
    \            }\n        } else {\n            if stack.count > 0 {\n         \
    \       stack.removeLast()\n            } else {\n                result = \"\
    Yes\"\n                break\n            }\n        }\n    }\n    return result\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpxc_r1_i4/tmpxc_r1_i4.swift:53: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b82aaea6c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b82aab9db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b82aab9d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b82aab9c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpxc_r1_i4                        0x0000557f9ff20960 <unavailable> + 6496

    5    libc.so.6                          0x00002b82ab092460 __libc_start_main +
    245

    6    tmpxc_r1_i4                        0x0000557f9ff203d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659824804
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = Stack()\n    var result = \"No\"\n  \
    \  for s in lst {\n        if s == \"(\" {\n            stack.push(s)\n      \
    \  } else if s == \")\" {\n            if stack.top() == \"(\" {\n           \
    \     stack.pop()\n            } else {\n                result = \"No\"\n   \
    \             break\n            }\n        } else {\n            result = \"\
    No\"\n            break\n        }\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpe8glr8zy.swift:14:17: error: cannot find 'Stack' in scope\n   \
    \ var stack = Stack()\n                ^~~~~\n"
  stdout: ''
  timestamp: 1659824804
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s.contains(\"(\") {\n            stack.append(s)\n\
    \        } else {\n            if stack.count > 0 {\n                if stack[stack.count\
    \ - 1] == s {\n                    stack.removeLast()\n                } else\
    \ {\n                    result = \"No\"\n                    break\n        \
    \        }\n            } else {\n                result = \"Yes\"\n         \
    \       break\n            }\n        }\n    }\n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpfh634lob/tmpfh634lob.swift:49: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aea44d56c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aea44a4db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aea44a4d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aea44a4c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpfh634lob                        0x0000561336e189c6 <unavailable> + 6598

    5    libc.so.6                          0x00002aea44f42460 __libc_start_main +
    245

    6    tmpfh634lob                        0x0000561336e185a9 <unavailable> + 5545

    '
  stdout: ''
  timestamp: 1659824804
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = Stack()\n    var result = \"No\"\n  \
    \  for s in lst {\n        if s == \"(\" {\n            stack.push(s)\n      \
    \  } else if s == \")\" {\n            if stack.len() == 0 {\n               \
    \ result = \"No\"\n                break\n            } else {\n             \
    \   stack.pop()\n            }\n        }\n    }\n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmp9oayly6u.swift:14:17: error: cannot find 'Stack' in scope\n   \
    \ var stack = Stack()\n                ^~~~~\n"
  stdout: ''
  timestamp: 1659824804
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n  \
    \      } else if s == \")\" {\n            if stack.isEmpty {\n              \
    \  result = \"No\"\n                break\n            } else {\n            \
    \    stack.removeLast()\n            }\n        } else {\n            if stack.isEmpty\
    \ {\n                result = \"Yes\"\n                break\n            }\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmpc1dl9p67/tmpc1dl9p67.swift:51: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac9450f2c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac944de9b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac944de9988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac944de87b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpc1dl9p67                        0x000055897db1aaeb <unavailable> + 6891

    5    libc.so.6                          0x00002ac9452de460 __libc_start_main +
    245

    6    tmpc1dl9p67                        0x000055897db1a3d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659824804
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = Stack()\n    for s in lst {\n       \
    \ if s == '(' {\n            stack.push(s)\n        } else if s == ')' {\n   \
    \         if stack.isEmpty {\n                return \"No\"\n            }\n \
    \           stack.pop()\n        } else {\n            if stack.isEmpty {\n  \
    \              return \"No\"\n            }\n            stack.pop()\n       \
    \     stack.push(s)\n        }\n    }\n    if stack.isEmpty {\n        return\
    \ \"Yes\"\n    }\n    return \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpw5zrrbgy.swift:16:17: error: single-quoted string literal found,\
    \ use '\"'\n        if s == '(' {\n                ^~~\n                \"(\"\n\
    /tmp/tmpw5zrrbgy.swift:18:24: error: single-quoted string literal found, use '\"\
    '\n        } else if s == ')' {\n                       ^~~\n                \
    \       \")\"\n/tmp/tmpw5zrrbgy.swift:14:17: error: cannot find 'Stack' in scope\n\
    \    var stack = Stack()\n                ^~~~~\n"
  stdout: ''
  timestamp: 1659824804
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s.contains(\"(\") {\n            stack.append(s)\n\
    \        } else if s.contains(\")\") {\n            if stack.count > 0 {\n   \
    \             let last = stack.removeLast()\n                if last == s {\n\
    \                    result = \"Yes\"\n                    break\n           \
    \     }\n            }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmp0ekzt48z/tmp0ekzt48z.swift:45: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ba06f0c2c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ba06edb9b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ba06edb9988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ba06edb87b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp0ekzt48z                        0x000055b3e481f976 <unavailable> + 6518

    5    libc.so.6                          0x00002ba06f2ae460 __libc_start_main +
    245

    6    tmp0ekzt48z                        0x000055b3e481f559 <unavailable> + 5465

    '
  stdout: ''
  timestamp: 1659824805
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n  \
    \      } else if s == \")\" {\n            if stack.count > 0 {\n            \
    \    stack.removeLast()\n            } else {\n                result = \"Yes\"\
    \n            }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmp3rvtwdo_/tmp3rvtwdo_.swift:44: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b2dbaa72c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b2dba769b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b2dba769988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b2dba7687b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp3rvtwdo_                        0x000055e109e92960 <unavailable> + 6496

    5    libc.so.6                          0x00002b2dbac5e460 __libc_start_main +
    245

    6    tmp3rvtwdo_                        0x000055e109e923d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659824803
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n  \
    \      } else if s == \")\" {\n            if stack.count > 0 {\n            \
    \    stack.removeLast()\n            } else {\n                result = \"Yes\"\
    \n                break\n            }\n        } else {\n            if stack.count\
    \ > 0 {\n                if stack.last == s {\n                    stack.removeLast()\n\
    \                } else {\n                    result = \"Yes\"\n            \
    \        break\n                }\n            } else {\n                result\
    \ = \"Yes\"\n                break\n            }\n        }\n    }\n    return\
    \ result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n\
    \    if left.count != right.count {\n        return false\n    }\n    for (l,\
    \ r) in zip(left, right) {\n        if l != r {\n            return false\n  \
    \      }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"\
    ()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmp_d7phvad/tmp_d7phvad.swift:57: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b7e402bcc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b7e3ffb3b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b7e3ffb3988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b7e3ffb27b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp_d7phvad                        0x000055b27bd1b9c0 <unavailable> + 6592

    5    libc.so.6                          0x00002b7e404a8460 __libc_start_main +
    245

    6    tmp_d7phvad                        0x000055b27bd1b439 <unavailable> + 5177

    '
  stdout: ''
  timestamp: 1659824804
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n  \
    \      } else if s == \")\" {\n            if stack.isEmpty {\n              \
    \  result = \"Yes\"\n                break\n            }\n            stack.removeLast()\n\
    \        } else {\n            if stack.isEmpty {\n                result = \"\
    Yes\"\n                break\n            }\n            stack.removeLast()\n\
    \            stack.append(s)\n        }\n    }\n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmp5yctdyd3/tmp5yctdyd3.swift:51: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b27a36e3c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b27a33dab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b27a33da988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b27a33d97b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp5yctdyd3                        0x000056491dca9960 <unavailable> + 6496

    5    libc.so.6                          0x00002b27a38cf460 __libc_start_main +
    245

    6    tmp5yctdyd3                        0x000056491dca93d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659824803
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = Stack()\n    var result = \"No\"\n  \
    \  for s in lst {\n        if s == \"(\" {\n            stack.push(s)\n      \
    \  } else if s == \")\" {\n            if stack.len() == 0 {\n               \
    \ result = \"No\"\n                break\n            } else {\n             \
    \   stack.pop()\n            }\n        } else {\n            if stack.len() !=\
    \ 0 {\n                result = \"No\"\n                break\n            }\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpga99tdts.swift:14:17: error: cannot find 'Stack' in scope\n   \
    \ var stack = Stack()\n                ^~~~~\n"
  stdout: ''
  timestamp: 1659824804
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfunc match_parens(lst:\
    \ [String]) -> String {\n    guard lst.count >= 2 else { return \"No\" }\n   \
    \ var stack = [String]()\n    var result = \"No\"\n    for s in lst {\n      \
    \  if s == \"(\" {\n            stack.append(s)\n        } else if s == \")\"\
    \ {\n            if stack.count > 0 {\n                stack.removeLast()\n  \
    \          } else {\n                result = \"Yes\"\n            }\n       \
    \ }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmp22i0_wyr/tmp22i0_wyr.swift:45: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9a6022dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9a5ff24b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9a5ff24988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9a5ff237b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp22i0_wyr                        0x0000563810463960 <unavailable> + 6496

    5    libc.so.6                          0x00002b9a60419460 __libc_start_main +
    245

    6    tmp22i0_wyr                        0x00005638104633d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659824804
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s == \"(\" || s == \")\" {\n            stack.append(s)\n\
    \        } else {\n            if stack.count > 0 {\n                if stack[stack.count\
    \ - 1] == \"(\" && s == \"(\" || stack[stack.count - 1] == \")\" && s == \")\"\
    \ {\n                    stack[stack.count - 1] = s\n                } else {\n\
    \                    result = \"No\"\n                    break\n            \
    \    }\n            } else {\n                result = \"Yes\"\n             \
    \   break\n            }\n        }\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmptvgf353j/tmptvgf353j.swift:51: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9b8ba96c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9b8b78db6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9b8b78d988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9b8b78c7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmptvgf353j                        0x00005572abc4caab <unavailable> + 6827

    5    libc.so.6                          0x00002b9b8bc82460 __libc_start_main +
    245

    6    tmptvgf353j                        0x00005572abc4c399 <unavailable> + 5017

    '
  stdout: ''
  timestamp: 1659824805
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = Stack()\n    for s in lst {\n       \
    \ if s == '(' {\n            stack.push(s)\n        } else if s == ')' {\n   \
    \         if stack.top() == '(' {\n                stack.pop()\n            }\
    \ else {\n                return \"No\"\n            }\n        } else {\n   \
    \         return \"No\"\n        }\n    }\n    if stack.top() != nil {\n     \
    \   return \"No\"\n    } else {\n        return \"Yes\"\n    }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmp9044s0w7.swift:16:17: error: single-quoted string literal found,\
    \ use '\"'\n        if s == '(' {\n                ^~~\n                \"(\"\n\
    /tmp/tmp9044s0w7.swift:18:24: error: single-quoted string literal found, use '\"\
    '\n        } else if s == ')' {\n                       ^~~\n                \
    \       \")\"\n/tmp/tmp9044s0w7.swift:19:31: error: single-quoted string literal\
    \ found, use '\"'\n            if stack.top() == '(' {\n                     \
    \         ^~~\n                              \"(\"\n/tmp/tmp9044s0w7.swift:14:17:\
    \ error: cannot find 'Stack' in scope\n    var stack = Stack()\n             \
    \   ^~~~~\n"
  stdout: ''
  timestamp: 1659824803
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = Stack()\n    for s in lst {\n       \
    \ if s == '(' {\n            stack.push(s)\n        } else if s == ')' {\n   \
    \         if stack.top() == '(' {\n                stack.pop()\n            }\
    \ else {\n                return \"No\"\n            }\n        } else {\n   \
    \         return \"No\"\n        }\n    }\n    if stack.top() != nil {\n     \
    \   return \"No\"\n    } else {\n        return \"Yes\"\n    }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmp9044s0w7.swift:16:17: error: single-quoted string literal found,\
    \ use '\"'\n        if s == '(' {\n                ^~~\n                \"(\"\n\
    /tmp/tmp9044s0w7.swift:18:24: error: single-quoted string literal found, use '\"\
    '\n        } else if s == ')' {\n                       ^~~\n                \
    \       \")\"\n/tmp/tmp9044s0w7.swift:19:31: error: single-quoted string literal\
    \ found, use '\"'\n            if stack.top() == '(' {\n                     \
    \         ^~~\n                              \"(\"\n/tmp/tmp9044s0w7.swift:14:17:\
    \ error: cannot find 'Stack' in scope\n    var stack = Stack()\n             \
    \   ^~~~~\n"
  stdout: ''
  timestamp: 1659824803
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = Stack()\n    var result = \"\"\n    for\
    \ s in lst {\n        if s == \"(\" {\n            stack.push(s)\n        } else\
    \ if s == \")\" {\n            if stack.isEmpty {\n                return \"No\"\
    \n            }\n            result += \"(\" + stack.pop() + \")\"\n        }\
    \ else {\n            result += s\n        }\n    }\n    if stack.isEmpty {\n\
    \        return \"Yes\"\n    }\n    return \"No\"\n}\n\n\nfunc ==(left: [(Int,\
    \ Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n\
    \        return false\n    }\n    for (l, r) in zip(left, right) {\n        if\
    \ l != r {\n            return false\n        }\n    }\n    return true\n}\n \
    \           \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmp9m3ijq5b.swift:14:17: error: cannot find 'Stack' in scope\n   \
    \ var stack = Stack()\n                ^~~~~\n"
  stdout: ''
  timestamp: 1659824804
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = Stack()\n    for s in lst {\n       \
    \ if s == \"(\" {\n            stack.push(s)\n        } else if s == \")\" {\n\
    \            if stack.len() == 0 {\n                return \"No\"\n          \
    \  }\n            stack.pop()\n        } else {\n            return \"No\"\n \
    \       }\n    }\n    if stack.len() == 0 {\n        return \"Yes\"\n    }\n \
    \   return \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) ->\
    \ Bool {\n    if left.count != right.count {\n        return false\n    }\n  \
    \  for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n\
    \        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpt9jmg9e_.swift:14:17: error: cannot find 'Stack' in scope\n   \
    \ var stack = Stack()\n                ^~~~~\n"
  stdout: ''
  timestamp: 1659824804
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var res = \"\"\n    for\
    \ s in lst {\n        if s == \"(\" {\n            stack.append(s)\n        }\
    \ else if s == \")\" {\n            if stack.isEmpty {\n                return\
    \ \"No\"\n            }\n            stack.removeLast()\n            if stack.isEmpty\
    \ {\n                res += \"Yes\"\n            }\n        } else {\n       \
    \     if stack.isEmpty {\n                res += \"No\"\n            } else {\n\
    \                res += \"No\"\n            }\n        }\n    }\n    return res\n\
    }\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count\
    \ != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpqcw2ikp1/tmpqcw2ikp1.swift:51: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002af89eecdc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002af89ebc4b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002af89ebc4988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002af89ebc37b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpqcw2ikp1                        0x0000562537586846 <unavailable> + 6214

    5    libc.so.6                          0x00002af89f0b9460 __libc_start_main +
    245

    6    tmpqcw2ikp1                        0x0000562537586429 <unavailable> + 5161

    '
  stdout: ''
  timestamp: 1659824805
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n  \
    \      } else if s == \")\" {\n            if stack.count > 0 {\n            \
    \    stack.removeLast()\n            } else {\n                result = \"Yes\"\
    \n            }\n        } else {\n            if stack.count > 0 {\n        \
    \        if stack.last == s {\n                    stack.removeLast()\n      \
    \          } else {\n                    result = \"No\"\n                }\n\
    \            } else {\n                result = \"Yes\"\n            }\n     \
    \   }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpd5at_44a/tmpd5at_44a.swift:54: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002aef042a3c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002aef03f9ab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002aef03f9a988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002aef03f997b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpd5at_44a                        0x000055a0684709c0 <unavailable> + 6592

    5    libc.so.6                          0x00002aef0448f460 __libc_start_main +
    245

    6    tmpd5at_44a                        0x000055a068470439 <unavailable> + 5177

    '
  stdout: ''
  timestamp: 1659824805
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = Stack()\n    for s in lst {\n       \
    \ if s == '(' {\n            stack.push(s)\n        } else if s == ')' {\n   \
    \         if stack.isEmpty {\n                return \"No\"\n            }\n \
    \           stack.pop()\n        } else {\n            if stack.isEmpty {\n  \
    \              return \"No\"\n            }\n            stack.pop()\n       \
    \     stack.push(s)\n        }\n    }\n    if stack.isEmpty {\n        return\
    \ \"Yes\"\n    }\n    return \"No\"\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpw5zrrbgy.swift:16:17: error: single-quoted string literal found,\
    \ use '\"'\n        if s == '(' {\n                ^~~\n                \"(\"\n\
    /tmp/tmpw5zrrbgy.swift:18:24: error: single-quoted string literal found, use '\"\
    '\n        } else if s == ')' {\n                       ^~~\n                \
    \       \")\"\n/tmp/tmpw5zrrbgy.swift:14:17: error: cannot find 'Stack' in scope\n\
    \    var stack = Stack()\n                ^~~~~\n"
  stdout: ''
  timestamp: 1659824804
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n  \
    \      } else if s == \")\" {\n            if stack.isEmpty {\n              \
    \  result = \"No\"\n                break\n            } else {\n            \
    \    stack.removeLast()\n            }\n        } else {\n            if stack.isEmpty\
    \ {\n                result = \"Yes\"\n                break\n            }\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmpc1dl9p67/tmpc1dl9p67.swift:51: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ac9450f2c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ac944de9b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ac944de9988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ac944de87b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpc1dl9p67                        0x000055897db1aaeb <unavailable> + 6891

    5    libc.so.6                          0x00002ac9452de460 __libc_start_main +
    245

    6    tmpc1dl9p67                        0x000055897db1a3d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659824804
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = Stack()\n    for s in lst {\n       \
    \ if s == '(' {\n            stack.push(s)\n        } else if s == ')' {\n   \
    \         if stack.top() == '(' {\n                stack.pop()\n            }\
    \ else {\n                return \"No\"\n            }\n        } else {\n   \
    \         return \"No\"\n        }\n    }\n    if stack.top() != nil {\n     \
    \   return \"No\"\n    } else {\n        return \"Yes\"\n    }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmp9044s0w7.swift:16:17: error: single-quoted string literal found,\
    \ use '\"'\n        if s == '(' {\n                ^~~\n                \"(\"\n\
    /tmp/tmp9044s0w7.swift:18:24: error: single-quoted string literal found, use '\"\
    '\n        } else if s == ')' {\n                       ^~~\n                \
    \       \")\"\n/tmp/tmp9044s0w7.swift:19:31: error: single-quoted string literal\
    \ found, use '\"'\n            if stack.top() == '(' {\n                     \
    \         ^~~\n                              \"(\"\n/tmp/tmp9044s0w7.swift:14:17:\
    \ error: cannot find 'Stack' in scope\n    var stack = Stack()\n             \
    \   ^~~~~\n"
  stdout: ''
  timestamp: 1659824803
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfunc match_parens(lst:\
    \ [String]) -> String {\n    guard lst.count >= 2 else { return \"No\" }\n   \
    \ var stack = [String]()\n    var result = \"No\"\n    for s in lst {\n      \
    \  if s == \"(\" {\n            stack.append(s)\n        } else if s == \")\"\
    \ {\n            if stack.count > 0 {\n                stack.removeLast()\n  \
    \          } else {\n                result = \"Yes\"\n            }\n       \
    \ }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int,\
    \ Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n\
    \    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n          \
    \  return false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmp22i0_wyr/tmp22i0_wyr.swift:45: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b9a6022dc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b9a5ff24b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b9a5ff24988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b9a5ff237b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp22i0_wyr                        0x0000563810463960 <unavailable> + 6496

    5    libc.so.6                          0x00002b9a60419460 __libc_start_main +
    245

    6    tmp22i0_wyr                        0x00005638104633d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659824804
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n  \
    \      } else if s == \")\" {\n            if stack.isEmpty {\n              \
    \  result = \"Yes\"\n                break\n            }\n            stack.removeLast()\n\
    \        } else {\n            if stack.isEmpty {\n                result = \"\
    Yes\"\n                break\n            }\n            stack.removeLast()\n\
    \            stack.append(s)\n        }\n    }\n    return result\n}\n\n\nfunc\
    \ ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count !=\
    \ right.count {\n        return false\n    }\n    for (l, r) in zip(left, right)\
    \ {\n        if l != r {\n            return false\n        }\n    }\n    return\
    \ true\n}\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\"\
    )\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmp5yctdyd3/tmp5yctdyd3.swift:51: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b27a36e3c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b27a33dab6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b27a33da988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b27a33d97b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmp5yctdyd3                        0x000056491dca9960 <unavailable> + 6496

    5    libc.so.6                          0x00002b27a38cf460 __libc_start_main +
    245

    6    tmp5yctdyd3                        0x000056491dca93d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659824803
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n  \
    \      } else if s == \")\" {\n            if stack.isEmpty {\n              \
    \  result = \"Yes\"\n                break\n            }\n            stack.removeLast()\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmpc9tow60w/tmpc9tow60w.swift:44: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab676de7c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab676adeb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab676ade988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab676add7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpc9tow60w                        0x0000555f05973960 <unavailable> + 6496

    5    libc.so.6                          0x00002ab676fd3460 __libc_start_main +
    245

    6    tmpc9tow60w                        0x0000555f059733d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659824804
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    for s in lst {\n    \
    \    if s.contains(\"(\") {\n            stack.append(s)\n        } else if s.contains(\"\
    )\") {\n            if stack.count > 0 {\n                stack.removeLast()\n\
    \            } else {\n                return \"No\"\n            }\n        }\n\
    \    }\n    if stack.count == 0 {\n        return \"Yes\"\n    } else {\n    \
    \    return \"No\"\n    }\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)])\
    \ -> Bool {\n    if left.count != right.count {\n        return false\n    }\n\
    \    for (l, r) in zip(left, right) {\n        if l != r {\n            return\
    \ false\n        }\n    }\n    return true\n}\n            \nassert(match_parens(lst:\
    \ [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"\
    No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")())\", \"(()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"\
    (()())((\"]) == \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\"\
    )\nassert(match_parens(lst: [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpkjoxamqy/tmpkjoxamqy.swift:49: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b06ceeedc80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b06cebe4b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b06cebe4988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b06cebe37b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpkjoxamqy                        0x000055d541b36df6 <unavailable> + 7670

    5    libc.so.6                          0x00002b06cf0d9460 __libc_start_main +
    245

    6    tmpkjoxamqy                        0x000055d541b36559 <unavailable> + 5465

    '
  stdout: ''
  timestamp: 1659824805
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n  \
    \      } else if s == \")\" {\n            if stack.isEmpty {\n              \
    \  result = \"Yes\"\n                break\n            }\n            stack.removeLast()\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmpc9tow60w/tmpc9tow60w.swift:44: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab676de7c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab676adeb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab676ade988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab676add7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpc9tow60w                        0x0000555f05973960 <unavailable> + 6496

    5    libc.so.6                          0x00002ab676fd3460 __libc_start_main +
    245

    6    tmpc9tow60w                        0x0000555f059733d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659824804
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = Stack()\n    var result = \"No\"\n  \
    \  for s in lst {\n        if s == \"(\" {\n            stack.push(s)\n      \
    \  } else if s == \")\" {\n            if stack.top() == \"(\" {\n           \
    \     stack.pop()\n            } else {\n                result = \"Yes\"\n  \
    \              break\n            }\n        } else {\n            result = \"\
    No\"\n            break\n        }\n    }\n    return result\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpaeqvfagc.swift:14:17: error: cannot find 'Stack' in scope\n   \
    \ var stack = Stack()\n                ^~~~~\n"
  stdout: ''
  timestamp: 1659824804
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = Stack()\n    for s in lst {\n       \
    \ if s == '(' {\n            stack.push(s)\n        } else if s == ')' {\n   \
    \         if stack.isEmpty {\n                return \"No\"\n            }\n \
    \           stack.pop()\n        } else {\n            return stack.contains(s)\
    \ ? \"Yes\" : \"No\"\n        }\n    }\n    return \"No\"\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmpn4fvnwu3.swift:16:17: error: single-quoted string literal found,\
    \ use '\"'\n        if s == '(' {\n                ^~~\n                \"(\"\n\
    /tmp/tmpn4fvnwu3.swift:18:24: error: single-quoted string literal found, use '\"\
    '\n        } else if s == ')' {\n                       ^~~\n                \
    \       \")\"\n/tmp/tmpn4fvnwu3.swift:14:17: error: cannot find 'Stack' in scope\n\
    \    var stack = Stack()\n                ^~~~~\n"
  stdout: ''
  timestamp: 1659824804
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    var result = \"No\"\n\
    \    for s in lst {\n        if s == \"(\" {\n            stack.append(s)\n  \
    \      } else if s == \")\" {\n            if stack.isEmpty {\n              \
    \  result = \"Yes\"\n                break\n            }\n            stack.removeLast()\n\
    \        }\n    }\n    return result\n}\n\n\nfunc ==(left: [(Int, Int)], right:\
    \ [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return\
    \ false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n  \
    \          return false\n        }\n    }\n    return true\n}\n            \n\
    assert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: Exception
  stderr: 'tmpc9tow60w/tmpc9tow60w.swift:44: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002ab676de7c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002ab676adeb6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002ab676ade988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002ab676add7b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpc9tow60w                        0x0000555f05973960 <unavailable> + 6496

    5    libc.so.6                          0x00002ab676fd3460 __libc_start_main +
    245

    6    tmpc9tow60w                        0x0000555f059733d9 <unavailable> + 5081

    '
  stdout: ''
  timestamp: 1659824804
- exit_code: 1
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = Stack()\n    for s in lst {\n       \
    \ if s == '(' {\n            stack.push(s)\n        } else if s == ')' {\n   \
    \         if stack.top() == '(' {\n                stack.pop()\n            }\
    \ else {\n                return \"No\"\n            }\n        } else {\n   \
    \         return \"No\"\n        }\n    }\n    if stack.top() != nil {\n     \
    \   return \"No\"\n    } else {\n        return \"Yes\"\n    }\n}\n\n\nfunc ==(left:\
    \ [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count\
    \ {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n     \
    \   if l != r {\n            return false\n        }\n    }\n    return true\n\
    }\n            \nassert(match_parens(lst: [\"()(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \")\"]) == \"No\")\nassert(match_parens(lst: [\"(()(())\", \"())())\"\
    ]) == \"No\")\nassert(match_parens(lst: [\")())\", \"(()()(\"]) == \"Yes\")\n\
    assert(match_parens(lst: [\"(())))\", \"(()())((\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst: [\"(()(\", \"()))()\"\
    ]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"((())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\")(()\", \"(()(\"]) == \"No\")\nassert(match_parens(lst: [\")(\", \")(\"])\
    \ == \"No\")\nassert(match_parens(lst: [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst:\
    \ [\")\", \"(\"]) == \"Yes\")"
  status: SyntaxError
  stderr: "/tmp/tmp9044s0w7.swift:16:17: error: single-quoted string literal found,\
    \ use '\"'\n        if s == '(' {\n                ^~~\n                \"(\"\n\
    /tmp/tmp9044s0w7.swift:18:24: error: single-quoted string literal found, use '\"\
    '\n        } else if s == ')' {\n                       ^~~\n                \
    \       \")\"\n/tmp/tmp9044s0w7.swift:19:31: error: single-quoted string literal\
    \ found, use '\"'\n            if stack.top() == '(' {\n                     \
    \         ^~~\n                              \"(\"\n/tmp/tmp9044s0w7.swift:14:17:\
    \ error: cannot find 'Stack' in scope\n    var stack = Stack()\n             \
    \   ^~~~~\n"
  stdout: ''
  timestamp: 1659824803
- exit_code: -4
  program: "\n/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfunc match_parens(lst:\
    \ [String]) -> String {\n    var stack = [String]()\n    for s in lst {\n    \
    \    if s.contains(\"(\") {\n            stack.append(s)\n        }\n        if\
    \ s.contains(\")\") {\n            if stack.count > 0 {\n                stack.removeLast()\n\
    \            } else {\n                return \"No\"\n            }\n        }\n\
    \    }\n    if stack.count > 0 {\n        return \"No\"\n    }\n    return \"\
    Yes\"\n}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n   \
    \ if left.count != right.count {\n        return false\n    }\n    for (l, r)\
    \ in zip(left, right) {\n        if l != r {\n            return false\n     \
    \   }\n    }\n    return true\n}\n            \nassert(match_parens(lst: [\"()(\"\
    , \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \")\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(())\", \"())())\"]) == \"No\")\nassert(match_parens(lst: [\")())\", \"\
    (()()(\"]) == \"Yes\")\nassert(match_parens(lst: [\"(())))\", \"(()())((\"]) ==\
    \ \"Yes\")\nassert(match_parens(lst: [\"()\", \"())\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(()(\", \"()))()\"]) == \"Yes\")\nassert(match_parens(lst: [\"((((\", \"\
    ((())\"]) == \"No\")\nassert(match_parens(lst: [\")(()\", \"(()(\"]) == \"No\"\
    )\nassert(match_parens(lst: [\")(\", \")(\"]) == \"No\")\nassert(match_parens(lst:\
    \ [\"(\", \")\"]) == \"Yes\")\nassert(match_parens(lst: [\")\", \"(\"]) == \"\
    Yes\")"
  status: Exception
  stderr: 'tmpqxkk5gbi/tmpqxkk5gbi.swift:46: Assertion failed

    Current stack trace:

    0    libswiftCore.so                    0x00002b6e21fa1c80 _swift_stdlib_reportFatalErrorInFile
    + 112

    1    libswiftCore.so                    0x00002b6e21c98b6c <unavailable> + 1436524

    2    libswiftCore.so                    0x00002b6e21c98988 <unavailable> + 1436040

    3    libswiftCore.so                    0x00002b6e21c977b0 _assertionFailure(_:_:file:line:flags:)
    + 699

    4    tmpqxkk5gbi                        0x00005565745f2976 <unavailable> + 6518

    5    libc.so.6                          0x00002b6e2218d460 __libc_start_main +
    245

    6    tmpqxkk5gbi                        0x00005565745f2559 <unavailable> + 5465

    '
  stdout: ''
  timestamp: 1659824805
