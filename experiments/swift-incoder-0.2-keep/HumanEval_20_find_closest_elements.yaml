name: HumanEval_20_find_closest_elements
language: swift
prompt: "\n/// From a supplied list of numbers (of length at least two) select and\
  \ return two that are the closest to each\n/// other and return them in order (smaller\
  \ number, larger number).\n/// >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0,\
  \ 2.2])\n/// (2.0, 2.2)\n/// >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0,\
  \ 2.0])\n/// (2.0, 2.0)\nfunc find_closest_elements(numbers: [Double]) -> (Double,\
  \ Double) {\n"
tests: "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if\
  \ left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left,\
  \ right) {\n        if l != r {\n            return false\n        }\n    }\n  \
  \  return true\n}\n            \nassert(find_closest_elements(numbers: [1.0, 2.0,\
  \ 3.9, 4.0, 5.0, 2.2]) == (3.9, 4.0))\nassert(find_closest_elements(numbers: [1.0,\
  \ 2.0, 5.9, 4.0, 5.0]) == (5.0, 5.9))\nassert(find_closest_elements(numbers: [1.0,\
  \ 2.0, 3.0, 4.0, 5.0, 2.2]) == (2.0, 2.2))\nassert(find_closest_elements(numbers:\
  \ [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]) == (2.0, 2.0))\nassert(find_closest_elements(numbers:\
  \ [1.1, 2.2, 3.1, 4.1, 5.1]) == (2.2, 3.1))"
completions: ["    var smallest = numbers[0]\n    var largest = numbers[0]\n    for\
    \ number in numbers {\n        if number < smallest {\n            smallest =\
    \ number\n        }\n        if number > largest {\n            largest = number\n\
    \        }\n    }\n    return (smallest, largest)", "    guard numbers.count >=\
    \ 2 else { return (numbers[0], numbers[0]) }\n    guard numbers.count >= 3 else\
    \ { return (numbers[0], numbers[0]) }\n\n    var smallest = numbers[0]\n    var\
    \ largest = numbers[0]\n    var smallestIndex = -1\n    var largestIndex = -1\n\
    \n    for i in 1..<numbers.count {\n        let currentNumber = numbers[i]\n \
    \       if currentNumber < smallest {\n            smallest = currentNumber\n\
    \            smallestIndex = i\n        }\n        if currentNumber > largest\
    \ {\n            largest = currentNumber\n            largestIndex = i\n     \
    \   }\n    }\n\n    return (numbers[smallestIndex], numbers[largestIndex])", " \
    \   var smallest = numbers[0]\n    var largest = numbers[0]\n    for number in\
    \ numbers {\n        if number < smallest {\n            smallest = number\n \
    \       }\n        if number > largest {\n            largest = number\n     \
    \   }\n    }\n    return (smallest, largest)", "    let smallest = min(numbers)\n\
    \    let largest = max(numbers)\n    return (smallest, largest)", "    var smallest\
    \ = numbers[0]\n    var largest = numbers[0]\n    for number in numbers {\n  \
    \      if number < smallest {\n            smallest = number\n        }\n    \
    \    if number > largest {\n            largest = number\n        }\n    }\n \
    \   return (smallest, largest)", "    guard numbers.count >= 2 else { return (numbers[0],\
    \ numbers[0]) }\n    guard numbers.count > 2 else { return (numbers[0], numbers[0])\
    \ }\n    guard numbers.count > 3 else { return (numbers[0], numbers[0]) }\n  \
    \  guard numbers.count > 4 else { return (numbers[0], numbers[0]) }\n    guard\
    \ numbers.count > 5 else { return (numbers[0], numbers[0]) }\n    guard numbers.count\
    \ > 6 else { return (numbers[0], numbers[0]) }\n    guard numbers.count > 7 else\
    \ { return (numbers[0], numbers[0]) }\n    guard numbers.count > 8 else { return\
    \ (numbers[0], numbers[0]) }\n    guard numbers.count > 9 else { return (numbers[0],\
    \ numbers[0]) }\n    guard numbers.count > 10 else { return (numbers[0], numbers[0])\
    \ }\n    guard numbers.count > 11 else { return (numbers[0], numbers[0]) }\n \
    \   guard numbers.count > 12 else { return (numbers[0], numbers[0]) }\n    guard\
    \ numbers.count > 13 else { return (numbers[0], numbers[0]) }\n    guard numbers.count\
    \ > 14 else { return (numbers[0], numbers[0]) }\n    guard numbers.count > 15\
    \ else { return (numbers[0], numbers[0]) }\n    guard numbers.count > 16 else\
    \ { return (numbers[0], numbers[0]) }\n    guard numbers.count > 17 else { return\
    \ (numbers[0], numbers[0]) }\n    guard numbers.count > 18 else { return (numbers[0],\
    \ numbers[0]) }\n    guard numbers.count > 19 else { return (numbers[0], numbers[0])\
    \ }\n    guard numbers.count > 20 else { return (numbers[0], numbers[0]) }\n \
    \   guard numbers.count > 21 else { return (numbers[0], numbers[0]) }\n    guard\
    \ numbers.count > 22 else { return (numbers[0], numbers[0]) }\n    guard numbers.count\
    \ > 23 else { return (numbers[0], numbers[0]) }\n    guard numbers.count > 24\
    \ else { return (numbers[0], numbers[0]) }\n    guard numbers.count > 25 else\
    \ { return (numbers[0], numbers[0]) }\n    guard numbers.count > 26 else { return\
    \ (numbers[0], numbers[0]) }\n    guard numbers.count > 27 else { return (numbers[0],\
    \ numbers[0]) }\n    guard numbers.count > 28 else { return (numbers[0], numbers[0])\
    \ }\n    guard numbers.count > 29 else { return (numbers[0], numbers[0]) }\n \
    \   guard numbers.count > 30 else { return (numbers[0], numbers[0]) }\n    guard\
    \ numbers.", "    let min1 = min(numbers)\n    let min2 = min(numbers)\n    if\
    \ min1 < min2 {\n        return (min1, min2)\n    }\n    return (min2, min1)",
  "    if numbers.isEmpty {\n        return (numbers[0], numbers[0])\n    }\n    let\
    \ sortedNumbers = numbers.sorted()\n    let closestToFirst = sortedNumbers[0]\n\
    \    let closestToSecond = sortedNumbers[1]\n    return (closestToFirst, closestToSecond)",
  "    guard numbers.count > 2 else {\n        return (0.0,0.0)\n    }\n    var smallest\
    \ = numbers[0]\n    var largest = numbers[0]\n    for i in 1..numbers.count {\n\
    \        if numbers[i] < smallest {\n            smallest = numbers[i]\n     \
    \   }\n        if numbers[i] > largest {\n            largest = numbers[i]\n \
    \       }\n    }\n    return (smallest, largest)", "    let smallest = numbers[0]\n\
    \    let largest = numbers[0]\n    for number in numbers {\n        if number\
    \ < smallest {\n            smallest = number\n        }\n        if number >\
    \ largest {\n            largest = number\n        }\n    }\n    return (smallest,\
    \ largest)", "    let sortedNumbers = numbers.sorted()\n    let closestIndex =\
    \ sortedNumbers.firstIndex({ $0 > sortedNumbers.last })\n    let closestNumber\
    \ = sortedNumbers[closestIndex]\n    return (closestNumber, sortedNumbers[closestIndex\
    \ + 1])", "    let min1 = numbers[0]\n    let min2 = numbers[0]\n    for i in\
    \ 1..<numbers.count {\n        let current1 = numbers[i]\n        let current2\
    \ = numbers[i - 1]\n        if current1 < current2 {\n            if min1 < current1\
    \ {\n                min1 = current1\n            }\n            if min2 < current2\
    \ {\n                min2 = current2\n            }\n        } else {\n      \
    \      if min1 < current2 {\n                min1 = current2\n            }\n\
    \            if min2 < current1 {\n                min2 = current1\n         \
    \   }\n        }\n    }\n    return (min1, min2)", "    guard numbers.count >=\
    \ 2 else {\n        return (0.0,0.0)\n    }\n    let smallest = numbers[0]\n \
    \   let largest = numbers[0]\n    for i in 1..<numbers.count {\n        if numbers[i]\
    \ > largest {\n            largest = numbers[i]\n        }\n        if numbers[i]\
    \ < smallest {\n            smallest = numbers[i]\n        }\n    }\n    return\
    \ (smallest, largest)", "    let min1 = numbers[0]\n    let max1 = numbers[0]\n\
    \    let min2 = numbers[0]\n    let max2 = numbers[0]\n    for i in 1..<numbers.count\
    \ {\n        let current1 = numbers[i]\n        let current2 = numbers[i - 1]\n\
    \        let current3 = numbers[i - 1]\n        let current4 = numbers[i]\n  \
    \      if current1 < min1 {\n            min1 = current1\n        }\n        if\
    \ current1 > max1 {\n            max1 = current1\n        }\n        if current2\
    \ < min2 {\n            min2 = current2\n        }\n        if current2 > max2\
    \ {\n            max2 = current2\n        }\n        if current3 < min3 {\n  \
    \          min3 = current3\n        }\n        if current3 > max3 {\n        \
    \    max3 = current3\n        }\n        if current4 < min4 {\n            min4\
    \ = current4\n        }\n        if current4 > max4 {\n            max4 = current4\n\
    \        }\n    }\n    return (min1, max1)", "    guard numbers.count > 1 else\
    \ {\n        return (0.0,0.0)\n    }\n    guard numbers.count >= 2 else {\n  \
    \      return (0.0,0.0)\n    }\n    let smallest = numbers[0]\n    let largest\
    \ = numbers[0]\n    for i in 1..<numbers.count {\n        if numbers[i] > largest\
    \ {\n            largest = numbers[i]\n        }\n        if numbers[i] < smallest\
    \ {\n            smallest = numbers[i]\n        }\n    }\n    return (smallest,\
    \ largest)", "    let smallest = min(numbers)\n    let largest = max(numbers)\n\
    \    return (smallest, largest)", "    let smallest = numbers[0]\n    let largest\
    \ = numbers[0]\n    for number in numbers {\n        if number < smallest {\n\
    \            smallest = number\n        }\n        if number > largest {\n   \
    \         largest = number\n        }\n    }\n    return (smallest, largest)",
  "    let min1 = min(numbers)\n    let max1 = max(numbers)\n    let min2 = min(min1,\
    \ max1)\n    let max2 = max(min1, max1)\n    return (min2, max2)", "    let smallest\
    \ = numbers[0]\n    let largest = numbers[0]\n    for number in numbers {\n  \
    \      if number < smallest {\n            smallest = number\n        } else if\
    \ number > largest {\n            largest = number\n        }\n    }\n    return\
    \ (smallest, largest)", "    if numbers.isEmpty {\n        return (0.0, 0.0)\n\
    \    }\n\n    let sortedNumbers = numbers.sorted()\n    let closestToFirst = sortedNumbers.first!\n\
    \    let closestToSecond = sortedNumbers.last!\n\n    return (closestToFirst,\
    \ closestToSecond)"]
stop_tokens:
- "\n}"
